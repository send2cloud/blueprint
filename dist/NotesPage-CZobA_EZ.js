var uv = Object.defineProperty;
var dv = (e, t, n) => t in e ? uv(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Ir = (e, t, n) => dv(e, typeof t != "symbol" ? t + "" : t, n);
import { P as me, b as we, S as ot, E as fv, c as hv, l as cy, d as uy, e as pe, f as dy, g as fy, N as gh, F as be, h as bh, D as Mn, i as hy, k as py, m as my, n as gy, o as vc, p as by, q as yy, r as Ey, s as ky, t as Cy, u as Ty, v as yh, w as xy, x as wy, y as vy, z as Sy, B as _y, C as Po, G as cn, H as Nl, I as Ay, J as ro, K as lt, L as Iy, M as Ny, O as My, R as Ly, Q as Sc, U as As, V as Eh, W as _c, X as pv, Y as mv, Z as kt, _ as Lt, $ as gv, a0 as Oy, a1 as bv, a2 as yv, a3 as Ev, a4 as kv, a5 as Cv, a6 as Tv, a7 as Km, a8 as xv, a9 as Dy, aa as wv, ab as Ry, ac as kh, j as E, ad as Rt, ae as ll, af as vv, ag as Sv, ah as Vu, ai as _v, aj as Av, ak as Iv, al as Nv, am as Ln, an as mo, ao as Hr, ap as Ml, aq as Py, ar as Is, as as Ur, at as Mv, au as Qm, av as gs, aw as By, ax as Lv, ay as Ov, az as Dv, a as Rv } from "./App-HBsrkeKv.js";
import { useParams as Pv } from "react-router-dom";
import * as K from "react";
import st, { useLayoutEffect as Ch, createContext as Xn, useContext as Tn, useMemo as Me, lazy as $y, useState as fe, useEffect as ie, forwardRef as se, useImperativeHandle as Bv, useCallback as Z, useDebugValue as $v, Suspense as Hv, useSyncExternalStore as Th, useRef as Ae, Fragment as Hy, Children as xh, useId as Fv, cloneElement as $i, createElement as Uv } from "react";
import * as jv from "react-dom";
import Vv, { flushSync as zv, createPortal as Ac } from "react-dom";
var qv = Object.defineProperty, wh = (e, t) => {
  for (var n in t)
    qv(e, n, { get: t[n], enumerable: !0 });
};
function Ic(e) {
  const { state: t, transaction: n } = e;
  let { selection: r } = n, { doc: o } = n, { storedMarks: i } = n;
  return {
    ...t,
    apply: t.apply.bind(t),
    applyTransaction: t.applyTransaction.bind(t),
    plugins: t.plugins,
    schema: t.schema,
    reconfigure: t.reconfigure.bind(t),
    toJSON: t.toJSON.bind(t),
    get storedMarks() {
      return i;
    },
    get selection() {
      return r;
    },
    get doc() {
      return o;
    },
    get tr() {
      return r = n.selection, o = n.doc, i = n.storedMarks, n;
    }
  };
}
var Nc = class {
  constructor(t) {
    this.editor = t.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = t.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: t, editor: n, state: r } = this, { view: o } = n, { tr: i } = r, s = this.buildProps(i);
    return Object.fromEntries(
      Object.entries(t).map(([a, l]) => [a, (...u) => {
        const d = l(...u)(s);
        return !i.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(i), d;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(t, n = !0) {
    const { rawCommands: r, editor: o, state: i } = this, { view: s } = o, a = [], l = !!t, c = t || i.tr, u = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(c), a.every((f) => f === !0)), d = {
      ...Object.fromEntries(
        Object.entries(r).map(([f, h]) => [f, (...m) => {
          const b = this.buildProps(c, n), y = h(...m)(b);
          return a.push(y), d;
        }])
      ),
      run: u
    };
    return d;
  }
  createCan(t) {
    const { rawCommands: n, state: r } = this, o = !1, i = t || r.tr, s = this.buildProps(i, o);
    return {
      ...Object.fromEntries(
        Object.entries(n).map(([l, c]) => [l, (...u) => c(...u)({ ...s, dispatch: void 0 })])
      ),
      chain: () => this.createChain(i, o)
    };
  }
  buildProps(t, n = !0) {
    const { rawCommands: r, editor: o, state: i } = this, { view: s } = o, a = {
      tr: t,
      editor: o,
      view: s,
      state: Ic({
        state: i,
        transaction: t
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(t, n),
      can: () => this.createCan(t),
      get commands() {
        return Object.fromEntries(
          Object.entries(r).map(([l, c]) => [l, (...u) => c(...u)(a)])
        );
      }
    };
    return a;
  }
}, Fy = {};
wh(Fy, {
  blur: () => Wv,
  clearContent: () => Gv,
  clearNodes: () => Yv,
  command: () => Kv,
  createParagraphNear: () => Qv,
  cut: () => Zv,
  deleteCurrentNode: () => Xv,
  deleteNode: () => Jv,
  deleteRange: () => eS,
  deleteSelection: () => tS,
  enter: () => nS,
  exitCode: () => rS,
  extendMarkRange: () => oS,
  first: () => iS,
  focus: () => aS,
  forEach: () => lS,
  insertContent: () => cS,
  insertContentAt: () => dS,
  joinBackward: () => pS,
  joinDown: () => hS,
  joinForward: () => mS,
  joinItemBackward: () => gS,
  joinItemForward: () => bS,
  joinTextblockBackward: () => yS,
  joinTextblockForward: () => ES,
  joinUp: () => fS,
  keyboardShortcut: () => CS,
  lift: () => TS,
  liftEmptyBlock: () => xS,
  liftListItem: () => wS,
  newlineInCode: () => vS,
  resetAttributes: () => SS,
  scrollIntoView: () => _S,
  selectAll: () => AS,
  selectNodeBackward: () => IS,
  selectNodeForward: () => NS,
  selectParentNode: () => MS,
  selectTextblockEnd: () => LS,
  selectTextblockStart: () => OS,
  setContent: () => DS,
  setMark: () => ZS,
  setMeta: () => XS,
  setNode: () => JS,
  setNodeSelection: () => e_,
  setTextDirection: () => t_,
  setTextSelection: () => n_,
  sinkListItem: () => r_,
  splitBlock: () => o_,
  splitListItem: () => i_,
  toggleList: () => s_,
  toggleMark: () => a_,
  toggleNode: () => l_,
  toggleWrap: () => c_,
  undoInputRule: () => u_,
  unsetAllMarks: () => d_,
  unsetMark: () => f_,
  unsetTextDirection: () => h_,
  updateAttributes: () => p_,
  wrapIn: () => m_,
  wrapInList: () => g_
});
var Wv = () => ({ editor: e, view: t }) => (requestAnimationFrame(() => {
  var n;
  e.isDestroyed || (t.dom.blur(), (n = window == null ? void 0 : window.getSelection()) == null || n.removeAllRanges());
}), !0), Gv = (e = !0) => ({ commands: t }) => t.setContent("", { emitUpdate: e }), Yv = () => ({ state: e, tr: t, dispatch: n }) => {
  const { selection: r } = t, { ranges: o } = r;
  return n && o.forEach(({ $from: i, $to: s }) => {
    e.doc.nodesBetween(i.pos, s.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: u } = t, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + a.nodeSize)), h = d.blockRange(f);
      if (!h)
        return;
      const p = cy(h);
      if (a.type.isTextblock) {
        const { defaultType: m } = d.parent.contentMatchAt(d.index());
        t.setNodeMarkup(h.start, m);
      }
      (p || p === 0) && t.lift(h, p);
    });
  }), !0;
}, Kv = (e) => (t) => e(t), Qv = () => ({ state: e, dispatch: t }) => uy(e, t), Zv = (e, t) => ({ editor: n, tr: r }) => {
  const { state: o } = n, i = o.doc.slice(e.from, e.to);
  r.deleteRange(e.from, e.to);
  const s = r.mapping.map(t);
  return r.insert(s, i.content), r.setSelection(new pe(r.doc.resolve(Math.max(s - 1, 0)))), !0;
}, Xv = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const o = e.selection.$anchor;
  for (let i = o.depth; i > 0; i -= 1)
    if (o.node(i).type === r.type) {
      if (t) {
        const a = o.before(i), l = o.after(i);
        e.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
};
function St(e, t) {
  if (typeof e == "string") {
    if (!t.nodes[e])
      throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);
    return t.nodes[e];
  }
  return e;
}
var Jv = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const o = St(e, n.schema), i = t.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === o) {
      if (r) {
        const l = i.before(s), c = i.after(s);
        t.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, eS = (e) => ({ tr: t, dispatch: n }) => {
  const { from: r, to: o } = e;
  return n && t.delete(r, o), !0;
}, tS = () => ({ state: e, dispatch: t }) => dy(e, t), nS = () => ({ commands: e }) => e.keyboardShortcut("Enter"), rS = () => ({ state: e, dispatch: t }) => fy(e, t);
function vh(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function Ll(e, t, n = { strict: !0 }) {
  const r = Object.keys(t);
  return r.length ? r.every((o) => n.strict ? t[o] === e[o] : vh(t[o]) ? t[o].test(e[o]) : t[o] === e[o]) : !0;
}
function Uy(e, t, n = {}) {
  return e.find((r) => r.type === t && Ll(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((o) => [o, r.attrs[o]])),
    n
  ));
}
function Zm(e, t, n = {}) {
  return !!Uy(e, t, n);
}
function Mc(e, t, n) {
  var r;
  if (!e || !t)
    return;
  let o = e.parent.childAfter(e.parentOffset);
  if ((!o.node || !o.node.marks.some((u) => u.type === t)) && (o = e.parent.childBefore(e.parentOffset)), !o.node || !o.node.marks.some((u) => u.type === t) || (n = n || ((r = o.node.marks[0]) == null ? void 0 : r.attrs), !Uy([...o.node.marks], t, n)))
    return;
  let s = o.index, a = e.start() + o.offset, l = s + 1, c = a + o.node.nodeSize;
  for (; s > 0 && Zm([...e.parent.child(s - 1).marks], t, n); )
    s -= 1, a -= e.parent.child(s).nodeSize;
  for (; l < e.parent.childCount && Zm([...e.parent.child(l).marks], t, n); )
    c += e.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: c
  };
}
function jr(e, t) {
  if (typeof e == "string") {
    if (!t.marks[e])
      throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);
    return t.marks[e];
  }
  return e;
}
var oS = (e, t = {}) => ({ tr: n, state: r, dispatch: o }) => {
  const i = jr(e, r.schema), { doc: s, selection: a } = n, { $from: l, from: c, to: u } = a;
  if (o) {
    const d = Mc(l, i, t);
    if (d && d.from <= c && d.to >= u) {
      const f = pe.create(s, d.from, d.to);
      n.setSelection(f);
    }
  }
  return !0;
}, iS = (e) => (t) => {
  const n = typeof e == "function" ? e(t) : e;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](t))
      return !0;
  return !1;
};
function jy(e) {
  return e instanceof pe;
}
function Dr(e = 0, t = 0, n = 0) {
  return Math.min(Math.max(e, t), n);
}
function Vy(e, t = null) {
  if (!t)
    return null;
  const n = ot.atStart(e), r = ot.atEnd(e);
  if (t === "start" || t === !0)
    return n;
  if (t === "end")
    return r;
  const o = n.from, i = r.to;
  return t === "all" ? pe.create(e, Dr(0, o, i), Dr(e.content.size, o, i)) : pe.create(e, Dr(t, o, i), Dr(t, o, i));
}
function Xm() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function Ol() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function sS() {
  return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
}
var aS = (e = null, t = {}) => ({ editor: n, view: r, tr: o, dispatch: i }) => {
  t = {
    scrollIntoView: !0,
    ...t
  };
  const s = () => {
    (Ol() || Xm()) && r.dom.focus(), sS() && !Ol() && !Xm() && r.dom.focus({ preventScroll: !0 }), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), t != null && t.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  try {
    if (r.hasFocus() && e === null || e === !1)
      return !0;
  } catch {
    return !1;
  }
  if (i && e === null && !jy(n.state.selection))
    return s(), !0;
  const a = Vy(o.doc, e) || n.state.selection, l = n.state.selection.eq(a);
  return i && (l || o.setSelection(a), l && o.storedMarks && o.setStoredMarks(o.storedMarks), s()), !0;
}, lS = (e, t) => (n) => e.every((r, o) => t(r, { ...n, index: o })), cS = (e, t) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, e, t), zy = (e) => {
  const t = e.childNodes;
  for (let n = t.length - 1; n >= 0; n -= 1) {
    const r = t[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? e.removeChild(r) : r.nodeType === 1 && zy(r);
  }
  return e;
};
function Aa(e) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const t = `<body>${e}</body>`, n = new window.DOMParser().parseFromString(t, "text/html").body;
  return zy(n);
}
function Ns(e, t, n) {
  if (e instanceof gh || e instanceof be)
    return e;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof e == "object" && e !== null, o = typeof e == "string";
  if (r)
    try {
      if (Array.isArray(e) && e.length > 0)
        return be.fromArray(e.map((a) => t.nodeFromJSON(a)));
      const s = t.nodeFromJSON(e);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (i) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", i), Ns("", t, n);
    }
  if (o) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const l = new bh({
        topNode: t.spec.topNode,
        marks: t.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: t.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (s = !0, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Mn.fromSchema(l).parseSlice(Aa(e), n.parseOptions) : Mn.fromSchema(l).parse(Aa(e), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`)
        });
    }
    const i = Mn.fromSchema(t);
    return n.slice ? i.parseSlice(Aa(e), n.parseOptions).content : i.parse(Aa(e), n.parseOptions);
  }
  return Ns("", t, n);
}
function qy(e, t, n) {
  const r = e.steps.length - 1;
  if (r < t)
    return;
  const o = e.steps[r];
  if (!(o instanceof Sc || o instanceof As))
    return;
  const i = e.mapping.maps[r];
  let s = 0;
  i.forEach((a, l, c, u) => {
    s === 0 && (s = u);
  }), e.setSelection(ot.near(e.doc.resolve(s), n));
}
var uS = (e) => !("type" in e), dS = (e, t, n) => ({ tr: r, dispatch: o, editor: i }) => {
  var s;
  if (o) {
    n = {
      parseOptions: i.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    const l = (b) => {
      i.emit("contentError", {
        editor: i,
        error: b,
        disableCollaboration: () => {
          "collaboration" in i.storage && typeof i.storage.collaboration == "object" && i.storage.collaboration && (i.storage.collaboration.isDisabled = !0);
        }
      });
    }, c = {
      preserveWhitespace: "full",
      ...n.parseOptions
    };
    if (!n.errorOnInvalidContent && !i.options.enableContentCheck && i.options.emitContentError)
      try {
        Ns(t, i.schema, {
          parseOptions: c,
          errorOnInvalidContent: !0
        });
      } catch (b) {
        l(b);
      }
    try {
      a = Ns(t, i.schema, {
        parseOptions: c,
        errorOnInvalidContent: (s = n.errorOnInvalidContent) != null ? s : i.options.enableContentCheck
      });
    } catch (b) {
      return l(b), !1;
    }
    let { from: u, to: d } = typeof e == "number" ? { from: e, to: e } : { from: e.from, to: e.to }, f = !0, h = !0;
    if ((uS(a) ? a : [a]).forEach((b) => {
      b.check(), f = f ? b.isText && b.marks.length === 0 : !1, h = h ? b.isBlock : !1;
    }), u === d && h) {
      const { parent: b } = r.doc.resolve(u);
      b.isTextblock && !b.type.spec.code && !b.childCount && (u -= 1, d += 1);
    }
    let m;
    if (f) {
      if (Array.isArray(t))
        m = t.map((b) => b.text || "").join("");
      else if (t instanceof be) {
        let b = "";
        t.forEach((y) => {
          y.text && (b += y.text);
        }), m = b;
      } else typeof t == "object" && t && t.text ? m = t.text : m = t;
      r.insertText(m, u, d);
    } else {
      m = a;
      const b = r.doc.resolve(u), y = b.node(), k = b.parentOffset === 0, C = y.isText || y.isTextblock, _ = y.content.size > 0;
      k && C && _ && (u = Math.max(0, u - 1)), r.replaceWith(u, d, m);
    }
    n.updateSelection && qy(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: u, text: m }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: u, text: m });
  }
  return !0;
}, fS = () => ({ state: e, dispatch: t }) => hy(e, t), hS = () => ({ state: e, dispatch: t }) => py(e, t), pS = () => ({ state: e, dispatch: t }) => my(e, t), mS = () => ({ state: e, dispatch: t }) => gy(e, t), gS = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = vc(e.doc, e.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, bS = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = vc(e.doc, e.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, yS = () => ({ state: e, dispatch: t }) => by(e, t), ES = () => ({ state: e, dispatch: t }) => yy(e, t);
function Wy() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function kS(e) {
  const t = e.split(/-(?!$)/);
  let n = t[t.length - 1];
  n === "Space" && (n = " ");
  let r, o, i, s;
  for (let a = 0; a < t.length - 1; a += 1) {
    const l = t[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      o = !0;
    else if (/^s(hift)?$/i.test(l))
      i = !0;
    else if (/^mod$/i.test(l))
      Ol() || Wy() ? s = !0 : o = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (n = `Alt-${n}`), o && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), i && (n = `Shift-${n}`), n;
}
var CS = (e) => ({ editor: t, view: n, tr: r, dispatch: o }) => {
  const i = kS(e).split(/-(?!$)/), s = i.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: i.includes("Alt"),
    ctrlKey: i.includes("Ctrl"),
    metaKey: i.includes("Meta"),
    shiftKey: i.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = t.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, a));
  });
  return l == null || l.steps.forEach((c) => {
    const u = c.map(r.mapping);
    u && o && r.maybeStep(u);
  }), !0;
};
function Ms(e, t, n = {}) {
  const { from: r, to: o, empty: i } = e.selection, s = t ? St(t, e.schema) : null, a = [];
  e.doc.nodesBetween(r, o, (d, f) => {
    if (d.isText)
      return;
    const h = Math.max(r, f), p = Math.min(o, f + d.nodeSize);
    a.push({
      node: d,
      from: h,
      to: p
    });
  });
  const l = o - r, c = a.filter((d) => s ? s.name === d.node.type.name : !0).filter((d) => Ll(d.node.attrs, n, { strict: !1 }));
  return i ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
var TS = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const o = St(e, n.schema);
  return Ms(n, o, t) ? Ey(n, r) : !1;
}, xS = () => ({ state: e, dispatch: t }) => ky(e, t), wS = (e) => ({ state: t, dispatch: n }) => {
  const r = St(e, t.schema);
  return Cy(r)(t, n);
}, vS = () => ({ state: e, dispatch: t }) => Ty(e, t);
function Lc(e, t) {
  return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null;
}
function Jm(e, t) {
  const n = typeof t == "string" ? [t] : t;
  return Object.keys(e).reduce((r, o) => (n.includes(o) || (r[o] = e[o]), r), {});
}
var SS = (e, t) => ({ tr: n, state: r, dispatch: o }) => {
  let i = null, s = null;
  const a = Lc(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (i = St(e, r.schema)), a === "mark" && (s = jr(e, r.schema));
  let l = !1;
  return n.selection.ranges.forEach((c) => {
    r.doc.nodesBetween(c.$from.pos, c.$to.pos, (u, d) => {
      i && i === u.type && (l = !0, o && n.setNodeMarkup(d, void 0, Jm(u.attrs, t))), s && u.marks.length && u.marks.forEach((f) => {
        s === f.type && (l = !0, o && n.addMark(d, d + u.nodeSize, s.create(Jm(f.attrs, t))));
      });
    });
  }), l;
}, _S = () => ({ tr: e, dispatch: t }) => (t && e.scrollIntoView(), !0), AS = () => ({ tr: e, dispatch: t }) => {
  if (t) {
    const n = new yh(e.doc);
    e.setSelection(n);
  }
  return !0;
}, IS = () => ({ state: e, dispatch: t }) => xy(e, t), NS = () => ({ state: e, dispatch: t }) => wy(e, t), MS = () => ({ state: e, dispatch: t }) => vy(e, t), LS = () => ({ state: e, dispatch: t }) => Sy(e, t), OS = () => ({ state: e, dispatch: t }) => _y(e, t);
function Dl(e, t, n = {}, r = {}) {
  return Ns(e, t, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
var DS = (e, { errorOnInvalidContent: t, emitUpdate: n = !0, parseOptions: r = {} } = {}) => ({ editor: o, tr: i, dispatch: s, commands: a }) => {
  const { doc: l } = i;
  if (r.preserveWhitespace !== "full") {
    const c = Dl(e, o.schema, r, {
      errorOnInvalidContent: t ?? o.options.enableContentCheck
    });
    return s && i.replaceWith(0, l.content.size, c).setMeta("preventUpdate", !n), !0;
  }
  return s && i.setMeta("preventUpdate", !n), a.insertContentAt({ from: 0, to: l.content.size }, e, {
    parseOptions: r,
    errorOnInvalidContent: t ?? o.options.enableContentCheck
  });
};
function Gy(e, t) {
  const n = jr(t, e.schema), { from: r, to: o, empty: i } = e.selection, s = [];
  i ? (e.storedMarks && s.push(...e.storedMarks), s.push(...e.selection.$head.marks())) : e.doc.nodesBetween(r, o, (l) => {
    s.push(...l.marks);
  });
  const a = s.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function Oc(e, t) {
  const n = new Eh(e);
  return t.forEach((r) => {
    r.steps.forEach((o) => {
      n.step(o);
    });
  }), n;
}
function RS(e) {
  for (let t = 0; t < e.edgeCount; t += 1) {
    const { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function e0(e, t) {
  const n = [];
  return e.descendants((r, o) => {
    t(r) && n.push({
      node: r,
      pos: o
    });
  }), n;
}
function Yy(e, t, n) {
  const r = [];
  return e.nodesBetween(t.from, t.to, (o, i) => {
    n(o) && r.push({
      node: o,
      pos: i
    });
  }), r;
}
function PS(e, t) {
  for (let n = e.depth; n > 0; n -= 1) {
    const r = e.node(n);
    if (t(r))
      return {
        pos: n > 0 ? e.before(n) : 0,
        start: e.start(n),
        depth: n,
        node: r
      };
  }
}
function Dc(e) {
  return (t) => PS(t.$from, e);
}
function te(e, t, n) {
  return e.config[t] === void 0 && e.parent ? te(e.parent, t, n) : typeof e.config[t] == "function" ? e.config[t].bind({
    ...n,
    parent: e.parent ? te(e.parent, t, n) : null
  }) : e.config[t];
}
function Sh(e) {
  return e.map((t) => {
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    }, r = te(t, "addExtensions", n);
    return r ? [t, ...Sh(r())] : t;
  }).flat(10);
}
function _h(e, t) {
  const n = Po.fromSchema(t).serializeFragment(e), o = document.implementation.createHTMLDocument().createElement("div");
  return o.appendChild(n), o.innerHTML;
}
function Ky(e) {
  return typeof e == "function";
}
function We(e, t = void 0, ...n) {
  return Ky(e) ? t ? e.bind(t)(...n) : e(...n) : e;
}
function BS(e = {}) {
  return Object.keys(e).length === 0 && e.constructor === Object;
}
function vi(e) {
  const t = e.filter((o) => o.type === "extension"), n = e.filter((o) => o.type === "node"), r = e.filter((o) => o.type === "mark");
  return {
    baseExtensions: t,
    nodeExtensions: n,
    markExtensions: r
  };
}
function Qy(e) {
  const t = [], { nodeExtensions: n, markExtensions: r } = vi(e), o = [...n, ...r], i = {
    default: null,
    validate: void 0,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return e.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: o
    }, l = te(
      s,
      "addGlobalAttributes",
      a
    );
    if (!l)
      return;
    l().forEach((u) => {
      u.types.forEach((d) => {
        Object.entries(u.attributes).forEach(([f, h]) => {
          t.push({
            type: d,
            name: f,
            attribute: {
              ...i,
              ...h
            }
          });
        });
      });
    });
  }), o.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, l = te(
      s,
      "addAttributes",
      a
    );
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([u, d]) => {
      const f = {
        ...i,
        ...d
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, t.push({
        type: s.name,
        name: u,
        attribute: f
      });
    });
  }), t;
}
function kn(...e) {
  return e.filter((t) => !!t).reduce((t, n) => {
    const r = { ...t };
    return Object.entries(n).forEach(([o, i]) => {
      if (!r[o]) {
        r[o] = i;
        return;
      }
      if (o === "class") {
        const a = i ? String(i).split(" ") : [], l = r[o] ? r[o].split(" ") : [], c = a.filter((u) => !l.includes(u));
        r[o] = [...l, ...c].join(" ");
      } else if (o === "style") {
        const a = i ? i.split(";").map((u) => u.trim()).filter(Boolean) : [], l = r[o] ? r[o].split(";").map((u) => u.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        l.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), a.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), r[o] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
      } else
        r[o] = i;
    }), r;
  }, {});
}
function Rl(e, t) {
  return t.filter((n) => n.type === e.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(e.attrs) || {} : {
    [n.name]: e.attrs[n.name]
  }).reduce((n, r) => kn(n, r), {});
}
function $S(e) {
  return typeof e != "string" ? e : e.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(e) : e === "true" ? !0 : e === "false" ? !1 : e;
}
function t0(e, t) {
  return "style" in e ? e : {
    ...e,
    getAttrs: (n) => {
      const r = e.getAttrs ? e.getAttrs(n) : e.attrs;
      if (r === !1)
        return !1;
      const o = t.reduce((i, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : $S(n.getAttribute(s.name));
        return a == null ? i : {
          ...i,
          [s.name]: a
        };
      }, {});
      return { ...r, ...o };
    }
  };
}
function n0(e) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(e).filter(([t, n]) => t === "attrs" && BS(n) ? !1 : n != null)
  );
}
function r0(e) {
  var t, n;
  const r = {};
  return !((t = e == null ? void 0 : e.attribute) != null && t.isRequired) && "default" in ((e == null ? void 0 : e.attribute) || {}) && (r.default = e.attribute.default), ((n = e == null ? void 0 : e.attribute) == null ? void 0 : n.validate) !== void 0 && (r.validate = e.attribute.validate), [e.name, r];
}
function Zy(e, t) {
  var n;
  const r = Qy(e), { nodeExtensions: o, markExtensions: i } = vi(e), s = (n = o.find((c) => te(c, "topNode"))) == null ? void 0 : n.name, a = Object.fromEntries(
    o.map((c) => {
      const u = r.filter((y) => y.type === c.name), d = {
        name: c.name,
        options: c.options,
        storage: c.storage,
        editor: t
      }, f = e.reduce((y, k) => {
        const C = te(k, "extendNodeSchema", d);
        return {
          ...y,
          ...C ? C(c) : {}
        };
      }, {}), h = n0({
        ...f,
        content: We(te(c, "content", d)),
        marks: We(te(c, "marks", d)),
        group: We(te(c, "group", d)),
        inline: We(te(c, "inline", d)),
        atom: We(te(c, "atom", d)),
        selectable: We(te(c, "selectable", d)),
        draggable: We(te(c, "draggable", d)),
        code: We(te(c, "code", d)),
        whitespace: We(te(c, "whitespace", d)),
        linebreakReplacement: We(
          te(c, "linebreakReplacement", d)
        ),
        defining: We(te(c, "defining", d)),
        isolating: We(te(c, "isolating", d)),
        attrs: Object.fromEntries(u.map(r0))
      }), p = We(te(c, "parseHTML", d));
      p && (h.parseDOM = p.map(
        (y) => t0(y, u)
      ));
      const m = te(c, "renderHTML", d);
      m && (h.toDOM = (y) => m({
        node: y,
        HTMLAttributes: Rl(y, u)
      }));
      const b = te(c, "renderText", d);
      return b && (h.toText = b), [c.name, h];
    })
  ), l = Object.fromEntries(
    i.map((c) => {
      const u = r.filter((b) => b.type === c.name), d = {
        name: c.name,
        options: c.options,
        storage: c.storage,
        editor: t
      }, f = e.reduce((b, y) => {
        const k = te(y, "extendMarkSchema", d);
        return {
          ...b,
          ...k ? k(c) : {}
        };
      }, {}), h = n0({
        ...f,
        inclusive: We(te(c, "inclusive", d)),
        excludes: We(te(c, "excludes", d)),
        group: We(te(c, "group", d)),
        spanning: We(te(c, "spanning", d)),
        code: We(te(c, "code", d)),
        attrs: Object.fromEntries(u.map(r0))
      }), p = We(te(c, "parseHTML", d));
      p && (h.parseDOM = p.map(
        (b) => t0(b, u)
      ));
      const m = te(c, "renderHTML", d);
      return m && (h.toDOM = (b) => m({
        mark: b,
        HTMLAttributes: Rl(b, u)
      })), [c.name, h];
    })
  );
  return new bh({
    topNode: s,
    nodes: a,
    marks: l
  });
}
function HS(e) {
  const t = e.filter((n, r) => e.indexOf(n) !== r);
  return Array.from(new Set(t));
}
function Pl(e) {
  return e.sort((n, r) => {
    const o = te(n, "priority") || 100, i = te(r, "priority") || 100;
    return o > i ? -1 : o < i ? 1 : 0;
  });
}
function Ah(e) {
  const t = Pl(Sh(e)), n = HS(t.map((r) => r.name));
  return n.length && console.warn(
    `[tiptap warn]: Duplicate extension names found: [${n.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`
  ), t;
}
function FS(e, t) {
  const n = Ah(e);
  return Zy(n, t);
}
function Xy(e, t, n) {
  const { from: r, to: o } = t, { blockSeparator: i = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return e.nodesBetween(r, o, (l, c, u, d) => {
    var f;
    l.isBlock && c > r && (a += i);
    const h = s == null ? void 0 : s[l.type.name];
    if (h)
      return u && (a += h({
        node: l,
        pos: c,
        parent: u,
        index: d,
        range: t
      })), !1;
    l.isText && (a += (f = l == null ? void 0 : l.text) == null ? void 0 : f.slice(Math.max(r, c) - c, o - c));
  }), a;
}
function US(e, t) {
  const n = {
    from: 0,
    to: e.content.size
  };
  return Xy(e, n, t);
}
function Jy(e) {
  return Object.fromEntries(
    Object.entries(e.nodes).filter(([, t]) => t.spec.toText).map(([t, n]) => [t, n.spec.toText])
  );
}
function jS(e, t) {
  const n = St(t, e.schema), { from: r, to: o } = e.selection, i = [];
  e.doc.nodesBetween(r, o, (a) => {
    i.push(a);
  });
  const s = i.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function eE(e, t) {
  const n = Lc(
    typeof t == "string" ? t : t.name,
    e.schema
  );
  return n === "node" ? jS(e, t) : n === "mark" ? Gy(e, t) : {};
}
function VS(e, t = JSON.stringify) {
  const n = {};
  return e.filter((r) => {
    const o = t(r);
    return Object.prototype.hasOwnProperty.call(n, o) ? !1 : n[o] = !0;
  });
}
function zS(e) {
  const t = VS(e);
  return t.length === 1 ? t : t.filter((n, r) => !t.filter((i, s) => s !== r).some((i) => n.oldRange.from >= i.oldRange.from && n.oldRange.to <= i.oldRange.to && n.newRange.from >= i.newRange.from && n.newRange.to <= i.newRange.to));
}
function Ih(e) {
  const { mapping: t, steps: n } = e, r = [];
  return t.maps.forEach((o, i) => {
    const s = [];
    if (o.ranges.length)
      o.forEach((a, l) => {
        s.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[i];
      if (a === void 0 || l === void 0)
        return;
      s.push({ from: a, to: l });
    }
    s.forEach(({ from: a, to: l }) => {
      const c = t.slice(i).map(a, -1), u = t.slice(i).map(l), d = t.invert().map(c, -1), f = t.invert().map(u);
      r.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), zS(r);
}
function Nh(e, t, n) {
  const r = [];
  return e === t ? n.resolve(e).marks().forEach((o) => {
    const i = n.resolve(e), s = Mc(i, o.type);
    s && r.push({
      mark: o,
      ...s
    });
  }) : n.nodesBetween(e, t, (o, i) => {
    !o || (o == null ? void 0 : o.nodeSize) === void 0 || r.push(
      ...o.marks.map((s) => ({
        from: i,
        to: i + o.nodeSize,
        mark: s
      }))
    );
  }), r;
}
function Ia(e, t) {
  return t.nodes[e] || t.marks[e] || null;
}
function cl(e, t, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const o = e.find((i) => i.type === t && i.name === r);
      return o ? o.attribute.keepOnSplit : !1;
    })
  );
}
var qS = (e, t = 500) => {
  let n = "";
  const r = e.parentOffset;
  return e.parent.nodesBetween(Math.max(0, r - t), r, (o, i, s, a) => {
    var l, c;
    const u = ((c = (l = o.type.spec).toText) == null ? void 0 : c.call(l, {
      node: o,
      pos: i,
      parent: s,
      index: a
    })) || o.textContent || "%leaf%";
    n += o.isAtom && !o.isText ? u : u.slice(0, Math.max(0, r - i));
  }), n;
};
function nf(e, t, n = {}) {
  const { empty: r, ranges: o } = e.selection, i = t ? jr(t, e.schema) : null;
  if (r)
    return !!(e.storedMarks || e.selection.$from.marks()).filter((d) => i ? i.name === d.type.name : !0).find((d) => Ll(d.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (o.forEach(({ $from: d, $to: f }) => {
    const h = d.pos, p = f.pos;
    e.doc.nodesBetween(h, p, (m, b) => {
      if (!m.isText && !m.marks.length)
        return;
      const y = Math.max(h, b), k = Math.min(p, b + m.nodeSize), C = k - y;
      s += C, a.push(
        ...m.marks.map((_) => ({
          mark: _,
          from: y,
          to: k
        }))
      );
    });
  }), s === 0)
    return !1;
  const l = a.filter((d) => i ? i.name === d.mark.type.name : !0).filter((d) => Ll(d.mark.attrs, n, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = a.filter((d) => i ? d.mark.type !== i && d.mark.type.excludes(i) : !0).reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= s;
}
function WS(e, t, n = {}) {
  if (!t)
    return Ms(e, null, n) || nf(e, null, n);
  const r = Lc(t, e.schema);
  return r === "node" ? Ms(e, t, n) : r === "mark" ? nf(e, t, n) : !1;
}
function o0(e, t) {
  return Array.isArray(t) ? t.some((n) => (typeof n == "string" ? n : n.name) === e.name) : t;
}
function i0(e, t) {
  const { nodeExtensions: n } = vi(t), r = n.find((s) => s.name === e);
  if (!r)
    return !1;
  const o = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, i = We(te(r, "group", o));
  return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function Mh(e, {
  checkChildren: t = !0,
  ignoreWhitespace: n = !1
} = {}) {
  var r;
  if (n) {
    if (e.type.name === "hardBreak")
      return !0;
    if (e.isText)
      return /^\s*$/m.test((r = e.text) != null ? r : "");
  }
  if (e.isText)
    return !e.text;
  if (e.isAtom || e.isLeaf)
    return !1;
  if (e.content.childCount === 0)
    return !0;
  if (t) {
    let o = !0;
    return e.content.forEach((i) => {
      o !== !1 && (Mh(i, { ignoreWhitespace: n, checkChildren: t }) || (o = !1));
    }), o;
  }
  return !1;
}
function GS(e) {
  return e instanceof cn;
}
var tE = class nE {
  constructor(t) {
    this.position = t;
  }
  /**
   * Creates a MappablePosition from a JSON object.
   */
  static fromJSON(t) {
    return new nE(t.position);
  }
  /**
   * Converts the MappablePosition to a JSON object.
   */
  toJSON() {
    return {
      position: this.position
    };
  }
};
function YS(e, t) {
  const n = t.mapping.mapResult(e.position);
  return {
    position: new tE(n.pos),
    mapResult: n
  };
}
function KS(e) {
  return new tE(e);
}
function rE(e, t, n) {
  const o = e.state.doc.content.size, i = Dr(t, 0, o), s = Dr(n, 0, o), a = e.coordsAtPos(i), l = e.coordsAtPos(s, -1), c = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), f = Math.max(a.right, l.right), h = f - d, p = u - c, y = {
    top: c,
    bottom: u,
    left: d,
    right: f,
    width: h,
    height: p,
    x: d,
    y: c
  };
  return {
    ...y,
    toJSON: () => y
  };
}
function QS(e, t, n) {
  var r;
  const { selection: o } = t;
  let i = null;
  if (jy(o) && (i = o.$cursor), i) {
    const a = (r = e.storedMarks) != null ? r : i.marks();
    return i.parent.type.allowsMarkType(n) && (!!n.isInSet(a) || !a.some((c) => c.type.excludes(n)));
  }
  const { ranges: s } = o;
  return s.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? e.doc.inlineContent && e.doc.type.allowsMarkType(n) : !1;
    return e.doc.nodesBetween(a.pos, l.pos, (u, d, f) => {
      if (c)
        return !1;
      if (u.isInline) {
        const h = !f || f.type.allowsMarkType(n), p = !!n.isInSet(u.marks) || !u.marks.some((m) => m.type.excludes(n));
        c = h && p;
      }
      return !c;
    }), c;
  });
}
var ZS = (e, t = {}) => ({ tr: n, state: r, dispatch: o }) => {
  const { selection: i } = n, { empty: s, ranges: a } = i, l = jr(e, r.schema);
  if (o)
    if (s) {
      const c = Gy(r, l);
      n.addStoredMark(
        l.create({
          ...c,
          ...t
        })
      );
    } else
      a.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        r.doc.nodesBetween(u, d, (f, h) => {
          const p = Math.max(h, u), m = Math.min(h + f.nodeSize, d);
          f.marks.find((y) => y.type === l) ? f.marks.forEach((y) => {
            l === y.type && n.addMark(
              p,
              m,
              l.create({
                ...y.attrs,
                ...t
              })
            );
          }) : n.addMark(p, m, l.create(t));
        });
      });
  return QS(r, n, l);
}, XS = (e, t) => ({ tr: n }) => (n.setMeta(e, t), !0), JS = (e, t = {}) => ({ state: n, dispatch: r, chain: o }) => {
  const i = St(e, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), i.isTextblock ? o().command(({ commands: a }) => Nl(i, { ...s, ...t })(n) ? !0 : a.clearNodes()).command(({ state: a }) => Nl(i, { ...s, ...t })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, e_ = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, o = Dr(e, 0, r.content.size), i = cn.create(r, o);
    t.setSelection(i);
  }
  return !0;
}, t_ = (e, t) => ({ tr: n, state: r, dispatch: o }) => {
  const { selection: i } = r;
  let s, a;
  return typeof t == "number" ? (s = t, a = t) : t && "from" in t && "to" in t ? (s = t.from, a = t.to) : (s = i.from, a = i.to), o && n.doc.nodesBetween(s, a, (l, c) => {
    l.isText || n.setNodeMarkup(c, void 0, {
      ...l.attrs,
      dir: e
    });
  }), !0;
}, n_ = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, { from: o, to: i } = typeof e == "number" ? { from: e, to: e } : e, s = pe.atStart(r).from, a = pe.atEnd(r).to, l = Dr(o, s, a), c = Dr(i, s, a), u = pe.create(r, l, c);
    t.setSelection(u);
  }
  return !0;
}, r_ = (e) => ({ state: t, dispatch: n }) => {
  const r = St(e, t.schema);
  return Ay(r)(t, n);
};
function s0(e, t) {
  const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
  if (n) {
    const r = n.filter((o) => t == null ? void 0 : t.includes(o.type.name));
    e.tr.ensureMarks(r);
  }
}
var o_ = ({ keepMarks: e = !0 } = {}) => ({ tr: t, state: n, dispatch: r, editor: o }) => {
  const { selection: i, doc: s } = t, { $from: a, $to: l } = i, c = o.extensionManager.attributes, u = cl(c, a.node().type.name, a.node().attrs);
  if (i instanceof cn && i.node.isBlock)
    return !a.parentOffset || !ro(s, a.pos) ? !1 : (r && (e && s0(n, o.extensionManager.splittableMarks), t.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : RS(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let h = d && f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0, p = ro(t.doc, t.mapping.map(a.pos), 1, h);
  if (!h && !p && ro(t.doc, t.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (p = !0, h = f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0), r) {
    if (p && (i instanceof pe && t.deleteSelection(), t.split(t.mapping.map(a.pos), 1, h), f && !d && !a.parentOffset && a.parent.type !== f)) {
      const m = t.mapping.map(a.before()), b = t.doc.resolve(m);
      a.node(-1).canReplaceWith(b.index(), b.index() + 1, f) && t.setNodeMarkup(t.mapping.map(a.before()), f);
    }
    e && s0(n, o.extensionManager.splittableMarks), t.scrollIntoView();
  }
  return p;
}, i_ = (e, t = {}) => ({ tr: n, state: r, dispatch: o, editor: i }) => {
  var s;
  const a = St(e, r.schema), { $from: l, $to: c } = r.selection, u = r.selection.node;
  if (u && u.isBlock || l.depth < 2 || !l.sameParent(c))
    return !1;
  const d = l.node(-1);
  if (d.type !== a)
    return !1;
  const f = i.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (o) {
      let y = be.empty;
      const k = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let D = l.depth - k; D >= l.depth - 3; D -= 1)
        y = be.from(l.node(D).copy(y));
      const C = (
        // eslint-disable-next-line no-nested-ternary
        l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3
      ), _ = {
        ...cl(f, l.node().type.name, l.node().attrs),
        ...t
      }, w = ((s = a.contentMatch.defaultType) == null ? void 0 : s.createAndFill(_)) || void 0;
      y = y.append(be.from(a.createAndFill(null, w) || void 0));
      const T = l.before(l.depth - (k - 1));
      n.replace(T, l.after(-C), new lt(y, 4 - k, 0));
      let M = -1;
      n.doc.nodesBetween(T, n.doc.content.size, (D, R) => {
        if (M > -1)
          return !1;
        D.isTextblock && D.content.size === 0 && (M = R + 1);
      }), M > -1 && n.setSelection(pe.near(n.doc.resolve(M))), n.scrollIntoView();
    }
    return !0;
  }
  const h = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, p = {
    ...cl(f, d.type.name, d.attrs),
    ...t
  }, m = {
    ...cl(f, l.node().type.name, l.node().attrs),
    ...t
  };
  n.delete(l.pos, c.pos);
  const b = h ? [
    { type: a, attrs: p },
    { type: h, attrs: m }
  ] : [{ type: a, attrs: p }];
  if (!ro(n.doc, l.pos, 2))
    return !1;
  if (o) {
    const { selection: y, storedMarks: k } = r, { splittableMarks: C } = i.extensionManager, _ = k || y.$to.parentOffset && y.$from.marks();
    if (n.split(l.pos, 2, b).scrollIntoView(), !_ || !o)
      return !0;
    const w = _.filter((T) => C.includes(T.type.name));
    n.ensureMarks(w);
  }
  return !0;
}, zu = (e, t) => {
  const n = Dc((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const o = e.doc.nodeAt(r);
  return n.node.type === (o == null ? void 0 : o.type) && _c(e.doc, n.pos) && e.join(n.pos), !0;
}, qu = (e, t) => {
  const n = Dc((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const o = e.doc.nodeAt(r);
  return n.node.type === (o == null ? void 0 : o.type) && _c(e.doc, r) && e.join(r), !0;
}, s_ = (e, t, n, r = {}) => ({ editor: o, tr: i, state: s, dispatch: a, chain: l, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: f } = o.extensionManager, h = St(e, s.schema), p = St(t, s.schema), { selection: m, storedMarks: b } = s, { $from: y, $to: k } = m, C = y.blockRange(k), _ = b || m.$to.parentOffset && m.$from.marks();
  if (!C)
    return !1;
  const w = Dc((T) => i0(T.type.name, d))(m);
  if (C.depth >= 1 && w && C.depth - w.depth <= 1) {
    if (w.node.type === h)
      return c.liftListItem(p);
    if (i0(w.node.type.name, d) && h.validContent(w.node.content) && a)
      return l().command(() => (i.setNodeMarkup(w.pos, h), !0)).command(() => zu(i, h)).command(() => qu(i, h)).run();
  }
  return !n || !_ || !a ? l().command(() => u().wrapInList(h, r) ? !0 : c.clearNodes()).wrapInList(h, r).command(() => zu(i, h)).command(() => qu(i, h)).run() : l().command(() => {
    const T = u().wrapInList(h, r), M = _.filter((D) => f.includes(D.type.name));
    return i.ensureMarks(M), T ? !0 : c.clearNodes();
  }).wrapInList(h, r).command(() => zu(i, h)).command(() => qu(i, h)).run();
}, a_ = (e, t = {}, n = {}) => ({ state: r, commands: o }) => {
  const { extendEmptyMarkRange: i = !1 } = n, s = jr(e, r.schema);
  return nf(r, s, t) ? o.unsetMark(s, { extendEmptyMarkRange: i }) : o.setMark(s, t);
}, l_ = (e, t, n = {}) => ({ state: r, commands: o }) => {
  const i = St(e, r.schema), s = St(t, r.schema), a = Ms(r, i, n);
  let l;
  return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), a ? o.setNode(s, l) : o.setNode(i, { ...l, ...n });
}, c_ = (e, t = {}) => ({ state: n, commands: r }) => {
  const o = St(e, n.schema);
  return Ms(n, o, t) ? r.lift(o) : r.wrapIn(o, t);
}, u_ = () => ({ state: e, dispatch: t }) => {
  const n = e.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const o = n[r];
    let i;
    if (o.spec.isInputRules && (i = o.getState(e))) {
      if (t) {
        const s = e.tr, a = i.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          s.step(a.steps[l].invert(a.docs[l]));
        if (i.text) {
          const l = s.doc.resolve(i.from).marks();
          s.replaceWith(i.from, i.to, e.schema.text(i.text, l));
        } else
          s.delete(i.from, i.to);
      }
      return !0;
    }
  }
  return !1;
}, d_ = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, { empty: r, ranges: o } = n;
  return r || t && o.forEach((i) => {
    e.removeMark(i.$from.pos, i.$to.pos);
  }), !0;
}, f_ = (e, t = {}) => ({ tr: n, state: r, dispatch: o }) => {
  var i;
  const { extendEmptyMarkRange: s = !1 } = t, { selection: a } = n, l = jr(e, r.schema), { $from: c, empty: u, ranges: d } = a;
  if (!o)
    return !0;
  if (u && s) {
    let { from: f, to: h } = a;
    const p = (i = c.marks().find((b) => b.type === l)) == null ? void 0 : i.attrs, m = Mc(c, l, p);
    m && (f = m.from, h = m.to), n.removeMark(f, h, l);
  } else
    d.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, h_ = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const { selection: o } = n;
  let i, s;
  return typeof e == "number" ? (i = e, s = e) : e && "from" in e && "to" in e ? (i = e.from, s = e.to) : (i = o.from, s = o.to), r && t.doc.nodesBetween(i, s, (a, l) => {
    if (a.isText)
      return;
    const c = { ...a.attrs };
    delete c.dir, t.setNodeMarkup(l, void 0, c);
  }), !0;
}, p_ = (e, t = {}) => ({ tr: n, state: r, dispatch: o }) => {
  let i = null, s = null;
  const a = Lc(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (i = St(e, r.schema)), a === "mark" && (s = jr(e, r.schema));
  let l = !1;
  return n.selection.ranges.forEach((c) => {
    const u = c.$from.pos, d = c.$to.pos;
    let f, h, p, m;
    n.selection.empty ? r.doc.nodesBetween(u, d, (b, y) => {
      i && i === b.type && (l = !0, p = Math.max(y, u), m = Math.min(y + b.nodeSize, d), f = y, h = b);
    }) : r.doc.nodesBetween(u, d, (b, y) => {
      y < u && i && i === b.type && (l = !0, p = Math.max(y, u), m = Math.min(y + b.nodeSize, d), f = y, h = b), y >= u && y <= d && (i && i === b.type && (l = !0, o && n.setNodeMarkup(y, void 0, {
        ...b.attrs,
        ...t
      })), s && b.marks.length && b.marks.forEach((k) => {
        if (s === k.type && (l = !0, o)) {
          const C = Math.max(y, u), _ = Math.min(y + b.nodeSize, d);
          n.addMark(
            C,
            _,
            s.create({
              ...k.attrs,
              ...t
            })
          );
        }
      }));
    }), h && (f !== void 0 && o && n.setNodeMarkup(f, void 0, {
      ...h.attrs,
      ...t
    }), s && h.marks.length && h.marks.forEach((b) => {
      s === b.type && o && n.addMark(
        p,
        m,
        s.create({
          ...b.attrs,
          ...t
        })
      );
    }));
  }), l;
}, m_ = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const o = St(e, n.schema);
  return Iy(o, t)(n, r);
}, g_ = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const o = St(e, n.schema);
  return Ny(o, t)(n, r);
}, b_ = class {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const n = this.callbacks[e];
    return n && n.forEach((r) => r.apply(this, t)), this;
  }
  off(e, t) {
    const n = this.callbacks[e];
    return n && (t ? this.callbacks[e] = n.filter((r) => r !== t) : delete this.callbacks[e]), this;
  }
  once(e, t) {
    const n = (...r) => {
      this.off(e, n), t.apply(this, r);
    };
    return this.on(e, n);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}, y_ = class {
  constructor(t) {
    var n;
    this.find = t.find, this.handler = t.handler, this.undoable = (n = t.undoable) != null ? n : !0;
  }
}, E_ = (e, t) => {
  if (vh(t))
    return t.exec(e);
  const n = t(e);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = e, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function Na(e) {
  var t;
  const { editor: n, from: r, to: o, text: i, rules: s, plugin: a } = e, { view: l } = n;
  if (l.composing)
    return !1;
  const c = l.state.doc.resolve(r);
  if (
    // check for code node
    c.parent.type.spec.code || (t = c.nodeBefore || c.nodeAfter) != null && t.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let u = !1;
  const d = qS(c) + i;
  return s.forEach((f) => {
    if (u)
      return;
    const h = E_(d, f.find);
    if (!h)
      return;
    const p = l.state.tr, m = Ic({
      state: l.state,
      transaction: p
    }), b = {
      from: r - (h[0].length - i.length),
      to: o
    }, { commands: y, chain: k, can: C } = new Nc({
      editor: n,
      state: m
    });
    f.handler({
      state: m,
      range: b,
      match: h,
      commands: y,
      chain: k,
      can: C
    }) === null || !p.steps.length || (f.undoable && p.setMeta(a, {
      transform: p,
      from: r,
      to: o,
      text: i
    }), l.dispatch(p), u = !0);
  }), u;
}
function k_(e) {
  const { editor: t, rules: n } = e, r = new me({
    state: {
      init() {
        return null;
      },
      apply(o, i, s) {
        const a = o.getMeta(r);
        if (a)
          return a;
        const l = o.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: u } = l;
          typeof u == "string" ? u = u : u = _h(be.from(u), s.schema);
          const { from: d } = l, f = d + u.length;
          Na({
            editor: t,
            from: d,
            to: f,
            text: u,
            rules: n,
            plugin: r
          });
        }), o.selectionSet || o.docChanged ? null : i;
      }
    },
    props: {
      handleTextInput(o, i, s, a) {
        return Na({
          editor: t,
          from: i,
          to: s,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (o) => (setTimeout(() => {
          const { $cursor: i } = o.state.selection;
          i && Na({
            editor: t,
            from: i.pos,
            to: i.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(o, i) {
        if (i.key !== "Enter")
          return !1;
        const { $cursor: s } = o.state.selection;
        return s ? Na({
          editor: t,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function C_(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function Ma(e) {
  return C_(e) !== "Object" ? !1 : e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype;
}
function oE(e, t) {
  const n = { ...e };
  return Ma(e) && Ma(t) && Object.keys(t).forEach((r) => {
    Ma(t[r]) && Ma(e[r]) ? n[r] = oE(e[r], t[r]) : n[r] = t[r];
  }), n;
}
var Lh = class {
  constructor(t = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...t
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...We(
        te(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...We(
        te(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(t = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => oE(this.options, t)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(t = {}) {
    const n = new this.constructor({ ...this.config, ...t });
    return n.parent = this, this.child = n, n.name = "name" in t ? t.name : n.parent.name, n;
  }
}, Hn = class iE extends Lh {
  constructor() {
    super(...arguments), this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new iE(n);
  }
  static handleExit({ editor: t, mark: n }) {
    const { tr: r } = t.state, o = t.state.selection.$from;
    if (o.pos === o.end()) {
      const s = o.marks();
      if (!!!s.find((c) => (c == null ? void 0 : c.type.name) === n.name))
        return !1;
      const l = s.find((c) => (c == null ? void 0 : c.type.name) === n.name);
      return l && r.removeStoredMark(l), r.insertText(" ", o.pos), t.view.dispatch(r), !0;
    }
    return !1;
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
};
function T_(e) {
  return typeof e == "number";
}
var x_ = class {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}, w_ = (e, t, n) => {
  if (vh(t))
    return [...e.matchAll(t)];
  const r = t(e, n);
  return r ? r.map((o) => {
    const i = [o.text];
    return i.index = o.index, i.input = e, i.data = o.data, o.replaceWith && (o.text.includes(o.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(o.replaceWith)), i;
  }) : [];
};
function v_(e) {
  const { editor: t, state: n, from: r, to: o, rule: i, pasteEvent: s, dropEvent: a } = e, { commands: l, chain: c, can: u } = new Nc({
    editor: t,
    state: n
  }), d = [];
  return n.doc.nodesBetween(r, o, (h, p) => {
    var m, b, y, k, C;
    if ((b = (m = h.type) == null ? void 0 : m.spec) != null && b.code || !(h.isText || h.isTextblock || h.isInline))
      return;
    const _ = (C = (k = (y = h.content) == null ? void 0 : y.size) != null ? k : h.nodeSize) != null ? C : 0, w = Math.max(r, p), T = Math.min(o, p + _);
    if (w >= T)
      return;
    const M = h.isText ? h.text || "" : h.textBetween(w - p, T - p, void 0, "");
    w_(M, i.find, s).forEach((R) => {
      if (R.index === void 0)
        return;
      const N = w + R.index + 1, B = N + R[0].length, F = {
        from: n.tr.mapping.map(N),
        to: n.tr.mapping.map(B)
      }, W = i.handler({
        state: n,
        range: F,
        match: R,
        commands: l,
        chain: c,
        can: u,
        pasteEvent: s,
        dropEvent: a
      });
      d.push(W);
    });
  }), d.every((h) => h !== null);
}
var La = null, S_ = (e) => {
  var t;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (t = n.clipboardData) == null || t.setData("text/html", e), n;
};
function __(e) {
  const { editor: t, rules: n } = e;
  let r = null, o = !1, i = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({
    state: u,
    from: d,
    to: f,
    rule: h,
    pasteEvt: p
  }) => {
    const m = u.tr, b = Ic({
      state: u,
      transaction: m
    });
    if (!(!v_({
      editor: t,
      state: b,
      from: Math.max(d - 1, 0),
      to: f.b - 1,
      rule: h,
      pasteEvent: p,
      dropEvent: a
    }) || !m.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m;
    }
  };
  return n.map((u) => new me({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const f = (p) => {
        var m;
        r = (m = d.dom.parentElement) != null && m.contains(p.target) ? d.dom.parentElement : null, r && (La = t);
      }, h = () => {
        La && (La = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", h), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", h);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, f) => {
          if (i = r === d.dom.parentElement, a = f, !i) {
            const h = La;
            h != null && h.isEditable && setTimeout(() => {
              const p = h.state.selection;
              p && h.commands.deleteRange({ from: p.from, to: p.to });
            }, 10);
          }
          return !1;
        },
        paste: (d, f) => {
          var h;
          const p = (h = f.clipboardData) == null ? void 0 : h.getData("text/html");
          return s = f, o = !!(p != null && p.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (d, f, h) => {
      const p = d[0], m = p.getMeta("uiEvent") === "paste" && !o, b = p.getMeta("uiEvent") === "drop" && !i, y = p.getMeta("applyPasteRules"), k = !!y;
      if (!m && !b && !k)
        return;
      if (k) {
        let { text: w } = y;
        typeof w == "string" ? w = w : w = _h(be.from(w), h.schema);
        const { from: T } = y, M = T + w.length, D = S_(w);
        return l({
          rule: u,
          state: h,
          from: T,
          to: { b: M },
          pasteEvt: D
        });
      }
      const C = f.doc.content.findDiffStart(h.doc.content), _ = f.doc.content.findDiffEnd(h.doc.content);
      if (!(!T_(C) || !_ || C === _.b))
        return l({
          rule: u,
          state: h,
          from: C,
          to: _,
          pasteEvt: s
        });
    }
  }));
}
var Rc = class {
  constructor(e, t) {
    this.splittableMarks = [], this.editor = t, this.baseExtensions = e, this.extensions = Ah(e), this.schema = Zy(this.extensions, t), this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, t) => {
      const n = {
        name: t.name,
        options: t.options,
        storage: this.editor.extensionStorage[t.name],
        editor: this.editor,
        type: Ia(t.name, this.schema)
      }, r = te(t, "addCommands", n);
      return r ? {
        ...e,
        ...r()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this;
    return Pl([...this.extensions].reverse()).flatMap((r) => {
      const o = {
        name: r.name,
        options: r.options,
        storage: this.editor.extensionStorage[r.name],
        editor: e,
        type: Ia(r.name, this.schema)
      }, i = [], s = te(
        r,
        "addKeyboardShortcuts",
        o
      );
      let a = {};
      if (r.type === "mark" && te(r, "exitable", o) && (a.ArrowRight = () => Hn.handleExit({ editor: e, mark: r })), s) {
        const f = Object.fromEntries(
          Object.entries(s()).map(([h, p]) => [h, () => p({ editor: e })])
        );
        a = { ...a, ...f };
      }
      const l = My(a);
      i.push(l);
      const c = te(r, "addInputRules", o);
      if (o0(r, e.options.enableInputRules) && c) {
        const f = c();
        if (f && f.length) {
          const h = k_({
            editor: e,
            rules: f
          }), p = Array.isArray(h) ? h : [h];
          i.push(...p);
        }
      }
      const u = te(r, "addPasteRules", o);
      if (o0(r, e.options.enablePasteRules) && u) {
        const f = u();
        if (f && f.length) {
          const h = __({ editor: e, rules: f });
          i.push(...h);
        }
      }
      const d = te(
        r,
        "addProseMirrorPlugins",
        o
      );
      if (d) {
        const f = d();
        i.push(...f);
      }
      return i;
    });
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return Qy(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: t } = vi(this.extensions);
    return Object.fromEntries(
      t.filter((n) => !!te(n, "addNodeView")).map((n) => {
        const r = this.attributes.filter((l) => l.type === n.name), o = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: e,
          type: St(n.name, this.schema)
        }, i = te(n, "addNodeView", o);
        if (!i)
          return [];
        const s = i();
        if (!s)
          return [];
        const a = (l, c, u, d, f) => {
          const h = Rl(l, r);
          return s({
            // pass-through
            node: l,
            view: c,
            getPos: u,
            decorations: d,
            innerDecorations: f,
            // tiptap-specific
            editor: e,
            extension: n,
            HTMLAttributes: h
          });
        };
        return [n.name, a];
      })
    );
  }
  /**
   * Get the composed dispatchTransaction function from all extensions.
   * @param baseDispatch The base dispatch function (e.g. from the editor or user props)
   * @returns A composed dispatch function
   */
  dispatchTransaction(e) {
    const { editor: t } = this;
    return Pl([...this.extensions].reverse()).reduceRight((r, o) => {
      const i = {
        name: o.name,
        options: o.options,
        storage: this.editor.extensionStorage[o.name],
        editor: t,
        type: Ia(o.name, this.schema)
      }, s = te(
        o,
        "dispatchTransaction",
        i
      );
      return s ? (a) => {
        s.call(i, { transaction: a, next: r });
      } : r;
    }, e);
  }
  get markViews() {
    const { editor: e } = this, { markExtensions: t } = vi(this.extensions);
    return Object.fromEntries(
      t.filter((n) => !!te(n, "addMarkView")).map((n) => {
        const r = this.attributes.filter((a) => a.type === n.name), o = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: e,
          type: jr(n.name, this.schema)
        }, i = te(n, "addMarkView", o);
        if (!i)
          return [];
        const s = (a, l, c) => {
          const u = Rl(a, r);
          return i()({
            // pass-through
            mark: a,
            view: l,
            inline: c,
            // tiptap-specific
            editor: e,
            extension: n,
            HTMLAttributes: u,
            updateAttributes: (d) => {
              F_(a, e, d);
            }
          });
        };
        return [n.name, s];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const e = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      e.map((t) => [t.name, t.storage])
    ), e.forEach((t) => {
      var n;
      const r = {
        name: t.name,
        options: t.options,
        storage: this.editor.extensionStorage[t.name],
        editor: this.editor,
        type: Ia(t.name, this.schema)
      };
      t.type === "mark" && ((n = We(te(t, "keepOnSplit", r))) == null || n) && this.splittableMarks.push(t.name);
      const o = te(t, "onBeforeCreate", r), i = te(t, "onCreate", r), s = te(t, "onUpdate", r), a = te(
        t,
        "onSelectionUpdate",
        r
      ), l = te(t, "onTransaction", r), c = te(t, "onFocus", r), u = te(t, "onBlur", r), d = te(t, "onDestroy", r);
      o && this.editor.on("beforeCreate", o), i && this.editor.on("create", i), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
    });
  }
};
Rc.resolve = Ah;
Rc.sort = Pl;
Rc.flatten = Sh;
var ui = {};
wh(ui, {
  ClipboardTextSerializer: () => aE,
  Commands: () => lE,
  Delete: () => cE,
  Drop: () => uE,
  Editable: () => dE,
  FocusEvents: () => hE,
  Keymap: () => pE,
  Paste: () => mE,
  Tabindex: () => gE,
  TextDirection: () => bE,
  focusEventsPluginKey: () => fE
});
var ut = class sE extends Lh {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new sE(n);
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
}, aE = ut.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: e } = this, { state: t, schema: n } = e, { doc: r, selection: o } = t, { ranges: i } = o, s = Math.min(...i.map((u) => u.$from.pos)), a = Math.max(...i.map((u) => u.$to.pos)), l = Jy(n);
            return Xy(r, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), lE = ut.create({
  name: "commands",
  addCommands() {
    return {
      ...Fy
    };
  }
}), cE = ut.create({
  name: "delete",
  onUpdate({ transaction: e, appendedTransactions: t }) {
    var n, r, o;
    const i = () => {
      var s, a, l, c;
      if ((c = (l = (a = (s = this.editor.options.coreExtensionOptions) == null ? void 0 : s.delete) == null ? void 0 : a.filterTransaction) == null ? void 0 : l.call(a, e)) != null ? c : e.getMeta("y-sync$"))
        return;
      const u = Oc(e.before, [e, ...t]);
      Ih(u).forEach((h) => {
        u.mapping.mapResult(h.oldRange.from).deletedAfter && u.mapping.mapResult(h.oldRange.to).deletedBefore && u.before.nodesBetween(h.oldRange.from, h.oldRange.to, (p, m) => {
          const b = m + p.nodeSize - 2, y = h.oldRange.from <= m && b <= h.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: p,
            from: m,
            to: b,
            newFrom: u.mapping.map(m),
            newTo: u.mapping.map(b),
            deletedRange: h.oldRange,
            newRange: h.newRange,
            partial: !y,
            editor: this.editor,
            transaction: e,
            combinedTransform: u
          });
        });
      });
      const f = u.mapping;
      u.steps.forEach((h, p) => {
        var m, b;
        if (h instanceof Ly) {
          const y = f.slice(p).map(h.from, -1), k = f.slice(p).map(h.to), C = f.invert().map(y, -1), _ = f.invert().map(k), w = (m = u.doc.nodeAt(y - 1)) == null ? void 0 : m.marks.some((M) => M.eq(h.mark)), T = (b = u.doc.nodeAt(k)) == null ? void 0 : b.marks.some((M) => M.eq(h.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: h.mark,
            from: h.from,
            to: h.to,
            deletedRange: {
              from: C,
              to: _
            },
            newRange: {
              from: y,
              to: k
            },
            partial: !!(T || w),
            editor: this.editor,
            transaction: e,
            combinedTransform: u
          });
        }
      });
    };
    (o = (r = (n = this.editor.options.coreExtensionOptions) == null ? void 0 : n.delete) == null ? void 0 : r.async) == null || o ? setTimeout(i, 0) : i();
  }
}), uE = ut.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("tiptapDrop"),
        props: {
          handleDrop: (e, t, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: t,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), dE = ut.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), fE = new we("focusEvents"), hE = ut.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: e } = this;
    return [
      new me({
        key: fE,
        props: {
          handleDOMEvents: {
            focus: (t, n) => {
              e.isFocused = !0;
              const r = e.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            },
            blur: (t, n) => {
              e.isFocused = !1;
              const r = e.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), pE = ut.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: u, $anchor: d } = l, { pos: f, parent: h } = d, p = d.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : d, m = p.parent.type.spec.isolating, b = d.pos - d.parentOffset, y = m && p.parent.childCount === 1 ? b === d.pos : ot.atStart(c).from === f;
        return !u || !h.type.isTextblock || h.textContent.length || !y || y && d.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: e,
      "Mod-Backspace": e,
      "Shift-Backspace": e,
      Delete: t,
      "Mod-Delete": t,
      "Mod-a": () => this.editor.commands.selectAll()
    }, o = {
      ...r
    }, i = {
      ...r,
      "Ctrl-h": e,
      "Alt-Backspace": e,
      "Ctrl-d": t,
      "Ctrl-Alt-Backspace": t,
      "Alt-Delete": t,
      "Alt-d": t,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Ol() || Wy() ? i : o;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new me({
        key: new we("clearDocument"),
        appendTransaction: (e, t, n) => {
          if (e.some((m) => m.getMeta("composition")))
            return;
          const r = e.some((m) => m.docChanged) && !t.doc.eq(n.doc), o = e.some((m) => m.getMeta("preventClearDocument"));
          if (!r || o)
            return;
          const { empty: i, from: s, to: a } = t.selection, l = ot.atStart(t.doc).from, c = ot.atEnd(t.doc).to;
          if (i || !(s === l && a === c) || !Mh(n.doc))
            return;
          const f = n.tr, h = Ic({
            state: n,
            transaction: f
          }), { commands: p } = new Nc({
            editor: this.editor,
            state: h
          });
          if (p.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), mE = ut.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("tiptapPaste"),
        props: {
          handlePaste: (e, t, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: t,
              slice: n
            });
          }
        }
      })
    ];
  }
}), gE = ut.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), bE = ut.create({
  name: "textDirection",
  addOptions() {
    return {
      direction: void 0
    };
  },
  addGlobalAttributes() {
    if (!this.options.direction)
      return [];
    const { nodeExtensions: e } = vi(this.extensions);
    return [
      {
        types: e.filter((t) => t.name !== "text").map((t) => t.name),
        attributes: {
          dir: {
            default: this.options.direction,
            parseHTML: (t) => {
              const n = t.getAttribute("dir");
              return n && (n === "ltr" || n === "rtl" || n === "auto") ? n : this.options.direction;
            },
            renderHTML: (t) => t.dir ? {
              dir: t.dir
            } : {}
          }
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("textDirection"),
        props: {
          attributes: () => {
            const e = this.options.direction;
            return e ? {
              dir: e
            } : {};
          }
        }
      })
    ];
  }
}), A_ = class hs {
  constructor(t, n, r = !1, o = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = t, this.editor = n, this.currentNode = o;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var t;
    return (t = this.actualDepth) != null ? t : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(t) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, t);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const t = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(t);
    return new hs(n, this.editor);
  }
  get before() {
    let t = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.from - 3)), new hs(t, this.editor);
  }
  get after() {
    let t = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.to + 3)), new hs(t, this.editor);
  }
  get children() {
    const t = [];
    return this.node.content.forEach((n, r) => {
      const o = n.isBlock && !n.isTextblock, i = n.isAtom && !n.isText, s = n.isInline, a = this.pos + r + (i ? 0 : 1);
      if (a < 0 || a > this.resolvedPos.doc.nodeSize - 2)
        return;
      const l = this.resolvedPos.doc.resolve(a);
      if (!o && !s && l.depth <= this.depth)
        return;
      const c = new hs(l, this.editor, o, o || s ? n : null);
      o && (c.actualDepth = this.depth + 1), t.push(c);
    }), t;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const t = this.children;
    return t[t.length - 1] || null;
  }
  closest(t, n = {}) {
    let r = null, o = this.parent;
    for (; o && !r; ) {
      if (o.node.type.name === t)
        if (Object.keys(n).length > 0) {
          const i = o.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const l = s[a];
            if (i[l] !== n[l])
              break;
          }
        } else
          r = o;
      o = o.parent;
    }
    return r;
  }
  querySelector(t, n = {}) {
    return this.querySelectorAll(t, n, !0)[0] || null;
  }
  querySelectorAll(t, n = {}, r = !1) {
    let o = [];
    if (!this.children || this.children.length === 0)
      return o;
    const i = Object.keys(n);
    return this.children.forEach((s) => {
      r && o.length > 0 || (s.node.type.name === t && i.every((l) => n[l] === s.node.attrs[l]) && o.push(s), !(r && o.length > 0) && (o = o.concat(s.querySelectorAll(t, n, r))));
    }), o;
  }
  setAttribute(t) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...t
    }), this.editor.view.dispatch(n);
  }
}, I_ = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function N_(e, t, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const o = document.createElement("style");
  return t && o.setAttribute("nonce", t), o.setAttribute("data-tiptap-style", ""), o.innerHTML = e, document.getElementsByTagName("head")[0].appendChild(o), o;
}
var M_ = class extends b_ {
  constructor(e = {}) {
    super(), this.css = null, this.className = "tiptap", this.editorView = null, this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.instanceId = Math.random().toString(36).slice(2, 9), this.options = {
      element: typeof document < "u" ? document.createElement("div") : null,
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      textDirection: void 0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: r }) => {
        throw r;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null,
      enableExtensionDispatchTransaction: !0
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.utils = {
      getUpdatedPosition: YS,
      createMappablePosition: KS
    }, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("mount", this.options.onMount), this.on("unmount", this.options.onUnmount), this.on("contentError", this.options.onContentError), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: r, slice: o, moved: i }) => this.options.onDrop(r, o, i)), this.on("paste", ({ event: r, slice: o }) => this.options.onPaste(r, o)), this.on("delete", this.options.onDelete);
    const t = this.createDoc(), n = Vy(t, this.options.autofocus);
    this.editorState = fv.create({
      doc: t,
      schema: this.schema,
      selection: n || void 0
    }), this.options.element && this.mount(this.options.element);
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(e) {
    if (typeof document > "u")
      throw new Error(
        "[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment."
      );
    this.createView(e), this.emit("mount", { editor: this }), this.css && !document.head.contains(this.css) && document.head.appendChild(this.css), window.setTimeout(() => {
      this.isDestroyed || (this.options.autofocus !== !1 && this.options.autofocus !== null && this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const e = this.editorView.dom;
      e != null && e.editor && delete e.editor, this.editorView.destroy();
    }
    if (this.editorView = null, this.isInitialized = !1, this.css && !document.querySelectorAll(`.${this.className}`).length)
      try {
        typeof this.css.remove == "function" ? this.css.remove() : this.css.parentNode && this.css.parentNode.removeChild(this.css);
      } catch (e) {
        console.warn("Failed to remove CSS element:", e);
      }
    this.css = null, this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && typeof document < "u" && (this.css = N_(I_, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.editorView || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, t = !0) {
    this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    return this.editorView ? this.editorView : new Proxy(
      {
        state: this.editorState,
        updateState: (e) => {
          this.editorState = e;
        },
        dispatch: (e) => {
          this.dispatchTransaction(e);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: !1,
        dragging: null,
        editable: !0,
        isDestroyed: !1
      },
      {
        get: (e, t) => {
          if (this.editorView)
            return this.editorView[t];
          if (t === "state")
            return this.editorState;
          if (t in e)
            return Reflect.get(e, t);
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${t}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.editorView && (this.editorState = this.view.state), this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, t) {
    const n = Ky(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: n });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const t = this.state.plugins;
    let n = t;
    if ([].concat(e).forEach((o) => {
      const i = typeof o == "string" ? `${o}$` : o.key;
      n = n.filter((s) => !s.key.startsWith(i));
    }), t.length === n.length)
      return;
    const r = this.state.reconfigure({
      plugins: n
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, t;
    const r = [...this.options.enableCoreExtensions ? [
      dE,
      aE.configure({
        blockSeparator: (t = (e = this.options.coreExtensionOptions) == null ? void 0 : e.clipboardTextSerializer) == null ? void 0 : t.blockSeparator
      }),
      lE,
      hE,
      pE,
      gE,
      uE,
      mE,
      cE,
      bE.configure({
        direction: this.options.textDirection
      })
    ].filter((o) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[o.name] !== !1 : !0) : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o == null ? void 0 : o.type));
    this.extensionManager = new Rc(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Nc({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let e;
    try {
      e = Dl(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (t) {
      if (!(t instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(t.message))
        throw t;
      this.emit("contentError", {
        editor: this,
        error: t,
        disableCollaboration: () => {
          "collaboration" in this.storage && typeof this.storage.collaboration == "object" && this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((n) => n.name !== "collaboration"), this.createExtensionManager();
        }
      }), e = Dl(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: !1
      });
    }
    return e;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(e) {
    const { editorProps: t, enableExtensionDispatchTransaction: n } = this.options, r = t.dispatchTransaction || this.dispatchTransaction.bind(this), o = n ? this.extensionManager.dispatchTransaction(r) : r;
    this.editorView = new hv(e, {
      ...t,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...t == null ? void 0 : t.attributes
      },
      dispatchTransaction: o,
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.prependClass(), this.injectCSS();
    const s = this.view.dom;
    s.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `${this.className} ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const t = this.capturedTransaction;
    return this.capturedTransaction = null, t;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((c) => {
        var u;
        return (u = this.capturedTransaction) == null ? void 0 : u.step(c);
      });
      return;
    }
    const { state: t, transactions: n } = this.state.applyTransaction(e), r = !this.state.selection.eq(t.selection), o = n.includes(e), i = this.state;
    if (this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: t
    }), !o)
      return;
    this.view.updateState(t), this.emit("transaction", {
      editor: this,
      transaction: e,
      appendedTransactions: n.slice(1)
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const s = n.findLast((c) => c.getMeta("focus") || c.getMeta("blur")), a = s == null ? void 0 : s.getMeta("focus"), l = s == null ? void 0 : s.getMeta("blur");
    a && this.emit("focus", {
      editor: this,
      event: a.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), l && this.emit("blur", {
      editor: this,
      event: l.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), !(e.getMeta("preventUpdate") || !n.some((c) => c.docChanged) || i.doc.eq(t.doc)) && this.emit("update", {
      editor: this,
      transaction: e,
      appendedTransactions: n.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return eE(this.state, e);
  }
  isActive(e, t) {
    const n = typeof e == "string" ? e : null, r = typeof e == "string" ? t : e;
    return WS(this.state, n, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return _h(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: t = `

`, textSerializers: n = {} } = e || {};
    return US(this.state.doc, {
      blockSeparator: t,
      textSerializers: {
        ...Jy(this.schema),
        ...n
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return Mh(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.unmount(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e, t;
    return (t = (e = this.editorView) == null ? void 0 : e.isDestroyed) != null ? t : !0;
  }
  $node(e, t) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelector(e, t)) || null;
  }
  $nodes(e, t) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelectorAll(e, t)) || null;
  }
  $pos(e) {
    const t = this.state.doc.resolve(e);
    return new A_(t, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Si(e) {
  return new y_({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const o = We(e.getAttributes, void 0, r);
      if (o === !1 || o === null)
        return null;
      const { tr: i } = t, s = r[r.length - 1], a = r[0];
      if (s) {
        const l = a.search(/\S/), c = n.from + a.indexOf(s), u = c + s.length;
        if (Nh(n.from, n.to, t.doc).filter((h) => h.mark.type.excluded.find((m) => m === e.type && m !== h.mark.type)).filter((h) => h.to > c).length)
          return null;
        u < n.to && i.delete(u, n.to), c > n.from && i.delete(n.from + l, c);
        const f = n.from + l + s.length;
        i.addMark(n.from + l, f, e.type.create(o || {})), i.removeStoredMark(e.type);
      }
    },
    undoable: e.undoable
  });
}
var L_ = {};
wh(L_, {
  createAtomBlockMarkdownSpec: () => O_,
  createBlockMarkdownSpec: () => D_,
  createInlineMarkdownSpec: () => B_,
  parseAttributes: () => Oh,
  parseIndentedBlocks: () => $_,
  renderNestedMarkdownContent: () => H_,
  serializeAttributes: () => Dh
});
function Oh(e) {
  if (!(e != null && e.trim()))
    return {};
  const t = {}, n = [], r = e.replace(/["']([^"']*)["']/g, (c) => (n.push(c), `__QUOTED_${n.length - 1}__`)), o = r.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (o) {
    const c = o.map((u) => u.trim().slice(1));
    t.class = c.join(" ");
  }
  const i = r.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  i && (t.id = i[1]);
  const s = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  Array.from(r.matchAll(s)).forEach(([, c, u]) => {
    var d;
    const f = parseInt(((d = u.match(/__QUOTED_(\d+)__/)) == null ? void 0 : d[1]) || "0", 10), h = n[f];
    h && (t[c] = h.slice(1, -1));
  });
  const l = r.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  return l && l.split(/\s+/).filter(Boolean).forEach((u) => {
    u.match(/^[a-zA-Z][\w-]*$/) && (t[u] = !0);
  }), t;
}
function Dh(e) {
  if (!e || Object.keys(e).length === 0)
    return "";
  const t = [];
  return e.class && String(e.class).split(/\s+/).filter(Boolean).forEach((r) => t.push(`.${r}`)), e.id && t.push(`#${e.id}`), Object.entries(e).forEach(([n, r]) => {
    n === "class" || n === "id" || (r === !0 ? t.push(n) : r !== !1 && r != null && t.push(`${n}="${String(r)}"`));
  }), t.join(" ");
}
function O_(e) {
  const {
    nodeName: t,
    name: n,
    parseAttributes: r = Oh,
    serializeAttributes: o = Dh,
    defaultAttributes: i = {},
    requiredAttributes: s = [],
    allowedAttributes: a
  } = e, l = n || t, c = (u) => {
    if (!a)
      return u;
    const d = {};
    return a.forEach((f) => {
      f in u && (d[f] = u[f]);
    }), d;
  };
  return {
    parseMarkdown: (u, d) => {
      const f = { ...i, ...u.attributes };
      return d.createNode(t, f, []);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(u) {
        var d;
        const f = new RegExp(`^:::${l}(?:\\s|$)`, "m"), h = (d = u.match(f)) == null ? void 0 : d.index;
        return h !== void 0 ? h : -1;
      },
      tokenize(u, d, f) {
        const h = new RegExp(`^:::${l}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`), p = u.match(h);
        if (!p)
          return;
        const m = p[1] || "", b = r(m);
        if (!s.find((k) => !(k in b)))
          return {
            type: t,
            raw: p[0],
            attributes: b
          };
      }
    },
    renderMarkdown: (u) => {
      const d = c(u.attrs || {}), f = o(d), h = f ? ` {${f}}` : "";
      return `:::${l}${h} :::`;
    }
  };
}
function D_(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: o = Oh,
    serializeAttributes: i = Dh,
    defaultAttributes: s = {},
    content: a = "block",
    allowedAttributes: l
  } = e, c = n || t, u = (d) => {
    if (!l)
      return d;
    const f = {};
    return l.forEach((h) => {
      h in d && (f[h] = d[h]);
    }), f;
  };
  return {
    parseMarkdown: (d, f) => {
      let h;
      if (r) {
        const m = r(d);
        h = typeof m == "string" ? [{ type: "text", text: m }] : m;
      } else a === "block" ? h = f.parseChildren(d.tokens || []) : h = f.parseInline(d.tokens || []);
      const p = { ...s, ...d.attributes };
      return f.createNode(t, p, h);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(d) {
        var f;
        const h = new RegExp(`^:::${c}`, "m"), p = (f = d.match(h)) == null ? void 0 : f.index;
        return p !== void 0 ? p : -1;
      },
      tokenize(d, f, h) {
        var p;
        const m = new RegExp(`^:::${c}(?:\\s+\\{([^}]*)\\})?\\s*\\n`), b = d.match(m);
        if (!b)
          return;
        const [y, k = ""] = b, C = o(k);
        let _ = 1;
        const w = y.length;
        let T = "";
        const M = /^:::([\w-]*)(\s.*)?/gm, D = d.slice(w);
        for (M.lastIndex = 0; ; ) {
          const R = M.exec(D);
          if (R === null)
            break;
          const N = R.index, B = R[1];
          if (!((p = R[2]) != null && p.endsWith(":::"))) {
            if (B)
              _ += 1;
            else if (_ -= 1, _ === 0) {
              const F = D.slice(0, N);
              T = F.trim();
              const W = d.slice(0, w + N + R[0].length);
              let L = [];
              if (T)
                if (a === "block")
                  for (L = h.blockTokens(F), L.forEach((H) => {
                    H.text && (!H.tokens || H.tokens.length === 0) && (H.tokens = h.inlineTokens(H.text));
                  }); L.length > 0; ) {
                    const H = L[L.length - 1];
                    if (H.type === "paragraph" && (!H.text || H.text.trim() === ""))
                      L.pop();
                    else
                      break;
                  }
                else
                  L = h.inlineTokens(T);
              return {
                type: t,
                raw: W,
                attributes: C,
                content: T,
                tokens: L
              };
            }
          }
        }
      }
    },
    renderMarkdown: (d, f) => {
      const h = u(d.attrs || {}), p = i(h), m = p ? ` {${p}}` : "", b = f.renderChildren(d.content || [], `

`);
      return `:::${c}${m}

${b}

:::`;
    }
  };
}
function R_(e) {
  if (!e.trim())
    return {};
  const t = {}, n = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let r = n.exec(e);
  for (; r !== null; ) {
    const [, o, i, s] = r;
    t[o] = i || s, r = n.exec(e);
  }
  return t;
}
function P_(e) {
  return Object.entries(e).filter(([, t]) => t != null).map(([t, n]) => `${t}="${n}"`).join(" ");
}
function B_(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: o = R_,
    serializeAttributes: i = P_,
    defaultAttributes: s = {},
    selfClosing: a = !1,
    allowedAttributes: l
  } = e, c = n || t, u = (f) => {
    if (!l)
      return f;
    const h = {};
    return l.forEach((p) => {
      const m = typeof p == "string" ? p : p.name, b = typeof p == "string" ? void 0 : p.skipIfDefault;
      if (m in f) {
        const y = f[m];
        if (b !== void 0 && y === b)
          return;
        h[m] = y;
      }
    }), h;
  }, d = c.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (f, h) => {
      const p = { ...s, ...f.attributes };
      if (a)
        return h.createNode(t, p);
      const m = r ? r(f) : f.content || "";
      return m ? h.createNode(t, p, [h.createTextNode(m)]) : h.createNode(t, p, []);
    },
    markdownTokenizer: {
      name: t,
      level: "inline",
      start(f) {
        const h = a ? new RegExp(`\\[${d}\\s*[^\\]]*\\]`) : new RegExp(`\\[${d}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${d}\\]`), p = f.match(h), m = p == null ? void 0 : p.index;
        return m !== void 0 ? m : -1;
      },
      tokenize(f, h, p) {
        const m = a ? new RegExp(`^\\[${d}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${d}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${d}\\]`), b = f.match(m);
        if (!b)
          return;
        let y = "", k = "";
        if (a) {
          const [, _] = b;
          k = _;
        } else {
          const [, _, w] = b;
          k = _, y = w || "";
        }
        const C = o(k.trim());
        return {
          type: t,
          raw: b[0],
          content: y.trim(),
          attributes: C
        };
      }
    },
    renderMarkdown: (f) => {
      let h = "";
      r ? h = r(f) : f.content && f.content.length > 0 && (h = f.content.filter((y) => y.type === "text").map((y) => y.text).join(""));
      const p = u(f.attrs || {}), m = i(p), b = m ? ` ${m}` : "";
      return a ? `[${c}${b}]` : `[${c}${b}]${h}[/${c}]`;
    }
  };
}
function $_(e, t, n) {
  var r, o, i, s;
  const a = e.split(`
`), l = [];
  let c = "", u = 0;
  const d = t.baseIndentSize || 2;
  for (; u < a.length; ) {
    const f = a[u], h = f.match(t.itemPattern);
    if (!h) {
      if (l.length > 0)
        break;
      if (f.trim() === "") {
        u += 1, c = `${c}${f}
`;
        continue;
      } else
        return;
    }
    const p = t.extractItemData(h), { indentLevel: m, mainContent: b } = p;
    c = `${c}${f}
`;
    const y = [b];
    for (u += 1; u < a.length; ) {
      const w = a[u];
      if (w.trim() === "") {
        const M = a.slice(u + 1).findIndex((N) => N.trim() !== "");
        if (M === -1)
          break;
        if ((((o = (r = a[u + 1 + M].match(/^(\s*)/)) == null ? void 0 : r[1]) == null ? void 0 : o.length) || 0) > m) {
          y.push(w), c = `${c}${w}
`, u += 1;
          continue;
        } else
          break;
      }
      if ((((s = (i = w.match(/^(\s*)/)) == null ? void 0 : i[1]) == null ? void 0 : s.length) || 0) > m)
        y.push(w), c = `${c}${w}
`, u += 1;
      else
        break;
    }
    let k;
    const C = y.slice(1);
    if (C.length > 0) {
      const w = C.map((T) => T.slice(m + d)).join(`
`);
      w.trim() && (t.customNestedParser ? k = t.customNestedParser(w) : k = n.blockTokens(w));
    }
    const _ = t.createToken(p, k);
    l.push(_);
  }
  if (l.length !== 0)
    return {
      items: l,
      raw: c
    };
}
function H_(e, t, n, r) {
  if (!e || !Array.isArray(e.content))
    return "";
  const o = typeof n == "function" ? n(r) : n, [i, ...s] = e.content, a = t.renderChildren([i]), l = [`${o}${a}`];
  return s && s.length > 0 && s.forEach((c) => {
    const u = t.renderChildren([c]);
    if (u) {
      const d = u.split(`
`).map((f) => f ? t.indent(f) : "").join(`
`);
      l.push(d);
    }
  }), l.join(`
`);
}
function F_(e, t, n = {}) {
  const { state: r } = t, { doc: o, tr: i } = r, s = e;
  o.descendants((a, l) => {
    const c = i.mapping.map(l), u = i.mapping.map(l) + a.nodeSize;
    let d = null;
    if (a.marks.forEach((h) => {
      if (h !== s)
        return !1;
      d = h;
    }), !d)
      return;
    let f = !1;
    if (Object.keys(n).forEach((h) => {
      n[h] !== d.attrs[h] && (f = !0);
    }), f) {
      const h = e.type.create({
        ...e.attrs,
        ...n
      });
      i.removeMark(c, u, e.type), i.addMark(c, u, h);
    }
  }), i.docChanged && t.view.dispatch(i);
}
var Jn = class yE extends Lh {
  constructor() {
    super(...arguments), this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new yE(n);
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
};
function Bo(e) {
  return new x_({
    find: e.find,
    handler: ({ state: t, range: n, match: r, pasteEvent: o }) => {
      const i = We(e.getAttributes, void 0, r, o);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = t, a = r[r.length - 1], l = r[0];
      let c = n.to;
      if (a) {
        const u = l.search(/\S/), d = n.from + l.indexOf(a), f = d + a.length;
        if (Nh(n.from, n.to, t.doc).filter((p) => p.mark.type.excluded.find((b) => b === e.type && b !== p.mark.type)).filter((p) => p.to > d).length)
          return null;
        f < n.to && s.delete(f, n.to), d > n.from && s.delete(n.from + u, d), c = n.from + u + a.length, s.addMark(n.from + u, c, e.type.create(i || {})), s.removeStoredMark(e.type);
      }
    }
  });
}
var Oa, U_ = new Uint8Array(16);
function j_() {
  if (!Oa && (Oa = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Oa))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Oa(U_);
}
const V_ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function z_(e) {
  return typeof e == "string" && V_.test(e);
}
var It = [];
for (var Wu = 0; Wu < 256; ++Wu)
  It.push((Wu + 256).toString(16).substr(1));
function q_(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = (It[e[t + 0]] + It[e[t + 1]] + It[e[t + 2]] + It[e[t + 3]] + "-" + It[e[t + 4]] + It[e[t + 5]] + "-" + It[e[t + 6]] + It[e[t + 7]] + "-" + It[e[t + 8]] + It[e[t + 9]] + "-" + It[e[t + 10]] + It[e[t + 11]] + It[e[t + 12]] + It[e[t + 13]] + It[e[t + 14]] + It[e[t + 15]]).toLowerCase();
  if (!z_(n))
    throw TypeError("Stringified UUID is invalid");
  return n;
}
function EE(e, t, n) {
  e = e || {};
  var r = e.random || (e.rng || j_)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, q_(r);
}
function W_(e, t = JSON.stringify) {
  const n = {};
  return e.filter((r) => {
    const o = t(r);
    return Object.prototype.hasOwnProperty.call(n, o) ? !1 : n[o] = !0;
  });
}
function G_(e) {
  const t = e.filter(
    (n, r) => e.indexOf(n) !== r
  );
  return W_(t);
}
const Pc = ut.create({
  name: "uniqueID",
  // well set a very high priority to make sure this runs first
  // and is compatible with `appendTransaction` hooks of other extensions
  priority: 1e4,
  addOptions() {
    return {
      attributeName: "id",
      types: [],
      setIdAttribute: !1,
      generateID: () => {
        if (typeof window < "u" && window.__TEST_OPTIONS) {
          const e = window.__TEST_OPTIONS;
          return e.mockID === void 0 ? e.mockID = 0 : e.mockID++, e.mockID.toString();
        }
        return EE();
      },
      filterTransaction: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          [this.options.attributeName]: {
            default: null,
            parseHTML: (e) => e.getAttribute(`data-${this.options.attributeName}`),
            renderHTML: (e) => {
              const t = {
                [`data-${this.options.attributeName}`]: e[this.options.attributeName]
              };
              return this.options.setIdAttribute ? {
                ...t,
                id: e[this.options.attributeName]
              } : t;
            }
          }
        }
      }
    ];
  },
  // check initial content for missing ids
  // onCreate() {
  //   // Dont do this when the collaboration extension is active
  //   // because this may update the content, so Y.js tries to merge these changes.
  //   // This leads to empty block nodes.
  //   // See: https://github.com/ueberdosis/tiptap/issues/2400
  //   if (
  //     this.editor.extensionManager.extensions.find(
  //       (extension) => extension.name === "collaboration"
  //     )
  //   ) {
  //     return;
  //   }
  //   const { view, state } = this.editor;
  //   const { tr, doc } = state;
  //   const { types, attributeName, generateID } = this.options;
  //   const nodesWithoutId = findChildren(doc, (node) => {
  //     return (
  //       types.includes(node.type.name) && node.attrs[attributeName] === null
  //     );
  //   });
  //   nodesWithoutId.forEach(({ node, pos }) => {
  //     tr.setNodeMarkup(pos, undefined, {
  //       ...node.attrs,
  //       [attributeName]: generateID(),
  //     });
  //   });
  //   tr.setMeta("addToHistory", false);
  //   view.dispatch(tr);
  // },
  addProseMirrorPlugins() {
    let e = null, t = !1;
    return [
      new me({
        key: new we("uniqueID"),
        appendTransaction: (n, r, o) => {
          const i = n.some((h) => h.docChanged) && !r.doc.eq(o.doc), s = this.options.filterTransaction && n.some((h) => {
            var p, m;
            return !((m = (p = this.options).filterTransaction) != null && m.call(p, h));
          });
          if (!i || s)
            return;
          const { tr: a } = o, { types: l, attributeName: c, generateID: u } = this.options, d = Oc(
            r.doc,
            n
          ), { mapping: f } = d;
          if (Ih(d).forEach(({ newRange: h }) => {
            const p = Yy(
              o.doc,
              h,
              (y) => l.includes(y.type.name)
            ), m = p.map(({ node: y }) => y.attrs[c]).filter((y) => y !== null), b = G_(m);
            p.forEach(({ node: y, pos: k }) => {
              var C;
              const _ = (C = a.doc.nodeAt(k)) == null ? void 0 : C.attrs[c];
              if (_ === null) {
                const T = r.doc.type.createAndFill().content;
                if (r.doc.content.findDiffStart(T) === null) {
                  const M = JSON.parse(
                    JSON.stringify(o.doc.toJSON())
                  );
                  if (M.content[0].content[0].attrs.id = "initialBlockId", JSON.stringify(M.content) === JSON.stringify(T.toJSON())) {
                    a.setNodeMarkup(k, void 0, {
                      ...y.attrs,
                      [c]: "initialBlockId"
                    });
                    return;
                  }
                }
                a.setNodeMarkup(k, void 0, {
                  ...y.attrs,
                  [c]: u()
                });
                return;
              }
              const { deleted: w } = f.invert().mapResult(k);
              w && b.includes(_) && a.setNodeMarkup(k, void 0, {
                ...y.attrs,
                [c]: u()
              });
            });
          }), !!a.steps.length)
            return a.setMeta("uniqueID", !0), a;
        },
        // we register a global drag handler to track the current drag source element
        view(n) {
          const r = (o) => {
            let i;
            e = !((i = n.dom.parentElement) === null || i === void 0) && i.contains(o.target) ? n.dom.parentElement : null;
          };
          return window.addEventListener("dragstart", r), {
            destroy() {
              window.removeEventListener("dragstart", r);
            }
          };
        },
        props: {
          // `handleDOMEvents` is called before `transformPasted` so we can do
          // some checks before. However, `transformPasted` only runs when
          // editor content is pasted - not external content.
          handleDOMEvents: {
            // only create new ids for dropped content while holding `alt`
            // or content is dragged from another editor
            drop: (n, r) => {
              let o;
              return e !== n.dom.parentElement || ((o = r.dataTransfer) === null || o === void 0 ? void 0 : o.effectAllowed) === "copy" ? t = !0 : t = !1, e = null, !1;
            },
            // always create new ids on pasted content
            paste: () => (t = !0, !1)
          },
          // well remove ids for every pasted node
          // so we can create a new one within `appendTransaction`
          transformPasted: (n) => {
            if (!t)
              return n;
            const { types: r, attributeName: o } = this.options, i = (s) => {
              const a = [];
              return s.forEach((l) => {
                if (l.isText) {
                  a.push(l);
                  return;
                }
                if (!r.includes(l.type.name)) {
                  a.push(l.copy(i(l.content)));
                  return;
                }
                const c = l.type.create(
                  {
                    ...l.attrs,
                    [o]: null
                  },
                  i(l.content),
                  l.marks
                );
                a.push(c);
              }), be.from(a);
            };
            return t = !1, new lt(
              i(n.content),
              n.openStart,
              n.openEnd
            );
          }
        }
      })
    ];
  }
});
function a0(e) {
  return e.type === "link";
}
function kE(e) {
  return typeof e != "string" && e.type === "link";
}
function $o(e) {
  return typeof e != "string" && e.type === "text";
}
function oo(e) {
  var t, n, r, o, i;
  return io(e) ? { ...e } : Ls(e) ? {
    type: "tableCell",
    content: [].concat(e.content),
    props: {
      backgroundColor: ((t = e.props) == null ? void 0 : t.backgroundColor) ?? "default",
      textColor: ((n = e.props) == null ? void 0 : n.textColor) ?? "default",
      textAlignment: ((r = e.props) == null ? void 0 : r.textAlignment) ?? "left",
      colspan: ((o = e.props) == null ? void 0 : o.colspan) ?? 1,
      rowspan: ((i = e.props) == null ? void 0 : i.rowspan) ?? 1
    }
  } : {
    type: "tableCell",
    content: [].concat(e),
    props: {
      backgroundColor: "default",
      textColor: "default",
      textAlignment: "left",
      colspan: 1,
      rowspan: 1
    }
  };
}
function Ls(e) {
  return e != null && typeof e != "string" && !Array.isArray(e) && e.type === "tableCell";
}
function io(e) {
  return Ls(e) && e.props !== void 0 && e.content !== void 0;
}
function Ho(e) {
  return io(e) ? e.props.colspan ?? 1 : 1;
}
function Os(e) {
  return io(e) ? e.props.rowspan ?? 1 : 1;
}
let br = class extends Error {
  constructor(t) {
    super(`Unreachable case: ${t}`);
  }
};
function xe(e, t = !0) {
  const { "data-test": n, ...r } = e;
  if (Object.keys(r).length > 0 && t)
    throw new Error("Object must be empty " + JSON.stringify(e));
}
function so(e, t) {
  const n = e.resolve(t);
  if (n.nodeAfter && n.nodeAfter.type.isInGroup("bnBlock"))
    return {
      posBeforeNode: n.pos,
      node: n.nodeAfter
    };
  let r = n.depth, o = n.node(r);
  for (; r > 0; ) {
    if (o.type.isInGroup("bnBlock"))
      return {
        posBeforeNode: n.before(r),
        node: o
      };
    r--, o = n.node(r);
  }
  const i = [];
  e.descendants((a, l) => {
    a.type.isInGroup("bnBlock") && i.push(l);
  }), console.warn(`Position ${t} is not within a blockContainer node.`);
  const s = e.resolve(
    i.find((a) => a >= t) || i[i.length - 1]
  );
  return {
    posBeforeNode: s.pos,
    node: s.nodeAfter
  };
}
function Rh(e, t) {
  if (!e.type.isInGroup("bnBlock"))
    throw new Error(
      `Attempted to get bnBlock node at position but found node of different type ${e.type.name}`
    );
  const n = e, r = t, o = r + n.nodeSize, i = {
    node: n,
    beforePos: r,
    afterPos: o
  };
  if (n.type.name === "blockContainer") {
    let s, a;
    if (n.forEach((l, c) => {
      if (l.type.spec.group === "blockContent") {
        const u = l, d = r + c + 1, f = d + l.nodeSize;
        s = {
          node: u,
          beforePos: d,
          afterPos: f
        };
      } else if (l.type.name === "blockGroup") {
        const u = l, d = r + c + 1, f = d + l.nodeSize;
        a = {
          node: u,
          beforePos: d,
          afterPos: f
        };
      }
    }), !s)
      throw new Error(
        `blockContainer node does not contain a blockContent node in its children: ${n}`
      );
    return {
      isBlockContainer: !0,
      bnBlock: i,
      blockContent: s,
      childContainer: a,
      blockNoteType: s.node.type.name
    };
  } else {
    if (!i.node.type.isInGroup("childContainer"))
      throw new Error(
        `bnBlock node is not in the childContainer group: ${i.node}`
      );
    return {
      isBlockContainer: !1,
      bnBlock: i,
      childContainer: i,
      blockNoteType: i.node.type.name
    };
  }
}
function ao(e) {
  return Rh(e.node, e.posBeforeNode);
}
function Bc(e) {
  if (!e.nodeAfter)
    throw new Error(
      `Attempted to get blockContainer node at position ${e.pos} but a node at this position does not exist`
    );
  return Rh(e.nodeAfter, e.pos);
}
function Jt(e) {
  const t = so(e.doc, e.selection.anchor);
  return ao(t);
}
function ra(e) {
  const t = so(e.doc, e.selection.anchor);
  return ao(t);
}
function ht(e) {
  return "doc" in e ? e.doc.type.schema : e.type.schema;
}
function CE(e) {
  return e.cached.blockNoteEditor;
}
function oa(e) {
  return CE(e).schema;
}
function Ph(e) {
  return oa(e).blockSchema;
}
function Bh(e) {
  return oa(e).inlineContentSchema;
}
function Hi(e) {
  return oa(e).styleSchema;
}
function $h(e) {
  return CE(e).blockCache;
}
function TE(e, t, n) {
  var r, o;
  const i = {
    type: "tableContent",
    columnWidths: [],
    headerRows: void 0,
    headerCols: void 0,
    rows: []
  }, s = [];
  e.content.forEach((a, l, c) => {
    const u = {
      cells: []
    };
    c === 0 && a.content.forEach((d) => {
      let f = d.attrs.colwidth;
      f == null && (f = new Array(d.attrs.colspan ?? 1).fill(void 0)), i.columnWidths.push(...f);
    }), u.cells = a.content.content.map((d, f) => (s[c] || (s[c] = []), s[c][f] = d.type.name === "tableHeader", {
      type: "tableCell",
      content: d.content.content.map(
        (h) => $c(h, t, n)
      ).reduce(
        (h, p) => {
          if (!h.length)
            return p;
          const m = h[h.length - 1], b = p[0];
          return b && $o(m) && $o(b) && JSON.stringify(m.styles) === JSON.stringify(b.styles) ? (m.text += `
` + b.text, h.push(...p.slice(1)), h) : (h.push(...p), h);
        },
        []
      ),
      props: {
        colspan: d.attrs.colspan,
        rowspan: d.attrs.rowspan,
        backgroundColor: d.attrs.backgroundColor,
        textColor: d.attrs.textColor,
        textAlignment: d.attrs.textAlignment
      }
    })), i.rows.push(u);
  });
  for (let a = 0; a < s.length; a++)
    (r = s[a]) != null && r.every((l) => l) && (i.headerRows = (i.headerRows ?? 0) + 1);
  for (let a = 0; a < ((o = s[0]) == null ? void 0 : o.length); a++)
    s != null && s.every((l) => l[a]) && (i.headerCols = (i.headerCols ?? 0) + 1);
  return i;
}
function $c(e, t, n) {
  const r = [];
  let o;
  return e.content.forEach((i) => {
    if (i.type.name === "hardBreak") {
      if (o)
        if ($o(o))
          o.text += `
`;
        else if (a0(o))
          o.content[o.content.length - 1].text += `
`;
        else
          throw new Error("unexpected");
      else
        o = {
          type: "text",
          text: `
`,
          styles: {}
        };
      return;
    }
    if (i.type.name !== "link" && i.type.name !== "text") {
      if (!t[i.type.name]) {
        console.warn("unrecognized inline content type", i.type.name);
        return;
      }
      o && (r.push(o), o = void 0), r.push(
        Hh(i, t, n)
      );
      return;
    }
    const s = {};
    let a;
    for (const l of i.marks)
      if (l.type.name === "link")
        a = l;
      else {
        const c = n[l.type.name];
        if (!c) {
          if (l.type.spec.blocknoteIgnore)
            continue;
          throw new Error(`style ${l.type.name} not found in styleSchema`);
        }
        if (c.propSchema === "boolean")
          s[c.type] = !0;
        else if (c.propSchema === "string")
          s[c.type] = l.attrs.stringValue;
        else
          throw new br(c.propSchema);
      }
    o ? $o(o) ? a ? (r.push(o), o = {
      type: "link",
      href: a.attrs.href,
      content: [
        {
          type: "text",
          text: i.textContent,
          styles: s
        }
      ]
    }) : JSON.stringify(o.styles) === JSON.stringify(s) ? o.text += i.textContent : (r.push(o), o = {
      type: "text",
      text: i.textContent,
      styles: s
    }) : a0(o) && (a ? o.href === a.attrs.href ? JSON.stringify(
      o.content[o.content.length - 1].styles
    ) === JSON.stringify(s) ? o.content[o.content.length - 1].text += i.textContent : o.content.push({
      type: "text",
      text: i.textContent,
      styles: s
    }) : (r.push(o), o = {
      type: "link",
      href: a.attrs.href,
      content: [
        {
          type: "text",
          text: i.textContent,
          styles: s
        }
      ]
    }) : (r.push(o), o = {
      type: "text",
      text: i.textContent,
      styles: s
    })) : a ? o = {
      type: "link",
      href: a.attrs.href,
      content: [
        {
          type: "text",
          text: i.textContent,
          styles: s
        }
      ]
    } : o = {
      type: "text",
      text: i.textContent,
      styles: s
    };
  }), o && r.push(o), r;
}
function Hh(e, t, n) {
  if (e.type.name === "text" || e.type.name === "link")
    throw new Error("unexpected");
  const r = {}, o = t[e.type.name];
  for (const [s, a] of Object.entries(e.attrs)) {
    if (!o)
      throw Error("ic node is of an unrecognized type: " + e.type.name);
    const l = o.propSchema;
    s in l && (r[s] = a);
  }
  let i;
  return o.content === "styled" ? i = $c(
    e,
    t,
    n
  ) : i = void 0, {
    type: e.type.name,
    props: r,
    content: i
  };
}
function ct(e, t, n = Ph(t), r = Bh(t), o = Hi(t), i = $h(t)) {
  var s;
  if (!e.type.isInGroup("bnBlock"))
    throw Error("Node should be a bnBlock, but is instead: " + e.type.name);
  const a = i == null ? void 0 : i.get(e);
  if (a)
    return a;
  const l = Rh(e, 0);
  let c = l.bnBlock.node.attrs.id;
  c === null && (c = Pc.options.generateID());
  const u = n[l.blockNoteType];
  if (!u)
    throw Error("Block is of an unrecognized type: " + l.blockNoteType);
  const d = {};
  for (const [b, y] of Object.entries({
    ...e.attrs,
    ...l.isBlockContainer ? l.blockContent.node.attrs : {}
  })) {
    const k = u.propSchema;
    b in k && !(k[b].default === void 0 && y === void 0) && (d[b] = y);
  }
  const f = n[l.blockNoteType], h = [];
  (s = l.childContainer) == null || s.node.forEach((b) => {
    h.push(
      ct(
        b,
        t,
        n,
        r,
        o,
        i
      )
    );
  });
  let p;
  if (f.content === "inline") {
    if (!l.isBlockContainer)
      throw new Error("impossible");
    p = $c(
      l.blockContent.node,
      r,
      o
    );
  } else if (f.content === "table") {
    if (!l.isBlockContainer)
      throw new Error("impossible");
    p = TE(
      l.blockContent.node,
      r,
      o
    );
  } else if (f.content === "none")
    p = void 0;
  else
    throw new br(f.content);
  const m = {
    id: c,
    type: f.type,
    props: d,
    content: p,
    children: h
  };
  return i == null || i.set(e, m), m;
}
function Y_(e, t = ht(e), n = Ph(t), r = Bh(t), o = Hi(t), i = $h(t)) {
  const s = [];
  return e.firstChild && e.firstChild.descendants((a) => (s.push(
    ct(
      a,
      t,
      n,
      r,
      o,
      i
    )
  ), !1)), s;
}
function K_(e, t, n = Ph(t), r = Bh(t), o = Hi(t), i = $h(t)) {
  function s(a, l, c) {
    if (a.type.name !== "blockGroup")
      throw new Error("unexpected");
    const u = [];
    let d, f;
    return a.forEach((h, p, m) => {
      if (h.type.name !== "blockContainer")
        throw new Error("unexpected");
      if (h.childCount === 0)
        return;
      if (h.childCount === 0 || h.childCount > 2)
        throw new Error(
          "unexpected, blockContainer.childCount: " + h.childCount
        );
      const b = m === 0, y = m === a.childCount - 1;
      if (h.firstChild.type.name === "blockGroup") {
        if (!b)
          throw new Error("unexpected");
        const w = s(
          h.firstChild,
          Math.max(0, l - 1),
          y ? Math.max(0, c - 1) : 0
        );
        d = w.blockCutAtStart, y && (f = w.blockCutAtEnd), u.push(...w.blocks);
        return;
      }
      const k = ct(
        h,
        t,
        n,
        r,
        o,
        i
      ), C = h.childCount > 1 ? h.child(1) : void 0;
      let _ = [];
      if (C) {
        const w = s(
          C,
          0,
          // TODO: can this be anything other than 0?
          y ? Math.max(0, c - 1) : 0
        );
        _ = w.blocks, y && (f = w.blockCutAtEnd);
      }
      y && !C && c > 1 && (f = k.id), b && l > 1 && (d = k.id), u.push({
        ...k,
        children: _
      });
    }), { blocks: u, blockCutAtStart: d, blockCutAtEnd: f };
  }
  if (e.content.childCount === 0)
    return {
      blocks: [],
      blockCutAtStart: void 0,
      blockCutAtEnd: void 0
    };
  if (e.content.childCount !== 1)
    throw new Error(
      "slice must be a single block, did you forget includeParents=true?"
    );
  return s(
    e.content.firstChild,
    Math.max(e.openStart - 1, 0),
    Math.max(e.openEnd - 1, 0)
  );
}
function go(e) {
  const { height: t, width: n } = Fh(e), r = new Array(t).fill(!1).map(() => new Array(n).fill(null)), o = (i, s) => {
    for (let a = i; a < t; a++)
      for (let l = s; l < n; l++)
        if (!r[a][l])
          return { row: a, col: l };
    throw new Error(
      "Unable to create occupancy grid for table, no more available cells"
    );
  };
  for (let i = 0; i < e.content.rows.length; i++)
    for (let s = 0; s < e.content.rows[i].cells.length; s++) {
      const a = oo(e.content.rows[i].cells[s]), l = Os(a), c = Ho(a), { row: u, col: d } = o(i, s);
      for (let f = u; f < u + l; f++)
        for (let h = d; h < d + c; h++) {
          if (r[f][h])
            throw new Error(
              `Unable to create occupancy grid for table, cell at ${f},${h} is already occupied`
            );
          r[f][h] = {
            row: i,
            col: s,
            rowspan: l,
            colspan: c,
            cell: a
          };
        }
    }
  return r;
}
function Ds(e) {
  const t = /* @__PURE__ */ new Set();
  return e.map((n) => ({
    cells: n.map((r) => t.has(r.row + ":" + r.col) ? !1 : (t.add(r.row + ":" + r.col), r.cell)).filter((r) => r !== !1)
  }));
}
function Fo(e, t, n = go(t)) {
  for (let r = 0; r < n.length; r++)
    for (let o = 0; o < n[r].length; o++) {
      const i = n[r][o];
      if (i && i.row === e.row && i.col === e.col)
        return { row: r, col: o, cell: i.cell };
    }
  throw new Error(
    `Unable to resolve relative table cell indices for table, cell at ${e.row},${e.col} is not occupied`
  );
}
function Fh(e) {
  const t = e.content.rows.length;
  let n = 0;
  return e.content.rows.forEach((r) => {
    let o = 0;
    r.cells.forEach((i) => {
      o += Ho(i);
    }), n = Math.max(n, o);
  }), { height: t, width: n };
}
function xE(e, t, n = go(t)) {
  var r;
  const o = (r = n[e.row]) == null ? void 0 : r[e.col];
  if (o)
    return {
      row: o.row,
      col: o.col,
      cell: o.cell
    };
}
function rf(e, t) {
  var n;
  const r = go(e);
  if (t < 0 || t >= r.length)
    return [];
  let o = 0;
  for (let s = 0; s < t; s++) {
    const a = (n = r[o]) == null ? void 0 : n[0];
    if (!a)
      return [];
    o += a.rowspan;
  }
  const i = new Array(r[0].length).fill(!1).map((s, a) => xE(
    { row: o, col: a },
    e,
    r
  )).filter(
    (s) => s !== void 0
  );
  return i.filter((s, a) => i.findIndex((l) => l.row === s.row && l.col === s.col) === a);
}
function of(e, t) {
  var n;
  const r = go(e);
  if (t < 0 || t >= r[0].length)
    return [];
  let o = 0;
  for (let s = 0; s < t; s++) {
    const a = (n = r[0]) == null ? void 0 : n[o];
    if (!a)
      return [];
    o += a.colspan;
  }
  const i = new Array(r.length).fill(!1).map((s, a) => xE(
    { row: a, col: o },
    e,
    r
  )).filter(
    (s) => s !== void 0
  );
  return i.filter((s, a) => i.findIndex((l) => l.row === s.row && l.col === s.col) === a);
}
function Q_(e, t, n, r = go(e)) {
  const { col: o } = Fo(
    {
      row: 0,
      col: t
    },
    e,
    r
  ), { col: i } = Fo(
    {
      row: 0,
      col: n
    },
    e,
    r
  );
  return r.forEach((s) => {
    const [a] = s.splice(o, 1);
    s.splice(i, 0, a);
  }), Ds(r);
}
function Z_(e, t, n, r = go(e)) {
  const { row: o } = Fo(
    {
      row: t,
      col: 0
    },
    e,
    r
  ), { row: i } = Fo(
    {
      row: n,
      col: 0
    },
    e,
    r
  ), [s] = r.splice(o, 1);
  return r.splice(i, 0, s), Ds(r);
}
function sf(e) {
  return e ? Ls(e) ? sf(e.content) : typeof e == "string" ? e.length === 0 : Array.isArray(e) ? e.every(
    (t) => typeof t == "string" ? t.length === 0 : $o(t) ? t.text.length === 0 : kE(t) ? typeof t.content == "string" ? t.content.length === 0 : t.content.every((n) => n.text.length === 0) : !1
  ) : !1 : !0;
}
function X_(e, t, n = go(e)) {
  if (t === "columns") {
    let i = 0;
    for (let s = n[0].length - 1; s >= 0 && n.every(
      (a) => sf(a[s].cell) && a[s].colspan === 1
    ); s--)
      i++;
    for (let s = n.length - 1; s >= 0; s--) {
      const a = Math.max(
        n[s].length - i,
        1
      );
      n[s] = n[s].slice(0, a);
    }
    return Ds(n);
  }
  let r = 0;
  for (let i = n.length - 1; i >= 0 && n[i].every(
    (s) => sf(s.cell) && s.rowspan === 1
  ); i--)
    r++;
  const o = Math.min(r, n.length - 1);
  return n.splice(n.length - o, o), Ds(n);
}
function J_(e, t, n, r = go(e)) {
  const { width: o, height: i } = Fh(e);
  if (t === "columns")
    r.forEach((s, a) => {
      if (n >= 0)
        for (let l = 0; l < n; l++)
          s.push({
            row: a,
            col: Math.max(...s.map((c) => c.col)) + 1,
            rowspan: 1,
            colspan: 1,
            cell: oo("")
          });
      else
        s.splice(o + n, -1 * n);
    });
  else if (n > 0)
    for (let s = 0; s < n; s++) {
      const a = new Array(o).fill(null).map((l, c) => ({
        row: i + s,
        col: c,
        rowspan: 1,
        colspan: 1,
        cell: oo("")
      }));
      r.push(a);
    }
  else n < 0 && r.splice(i + n, -1 * n);
  return Ds(r);
}
function wE(e, t, n) {
  const r = rf(e, n);
  if (!r.some((s) => Os(s.cell) > 1))
    return !0;
  let o = n, i = n;
  return r.forEach((s) => {
    const a = Os(s.cell);
    o = Math.max(o, s.row + a - 1), i = Math.min(i, s.row);
  }), t < n ? n === o : n === i;
}
function vE(e, t, n) {
  const r = of(e, n);
  if (!r.some((s) => Ho(s.cell) > 1))
    return !0;
  let o = n, i = n;
  return r.forEach((s) => {
    const a = Ho(s.cell);
    o = Math.max(o, s.col + a - 1), i = Math.min(i, s.col);
  }), t < n ? n === o : n === i;
}
function eA(e, t, n) {
  const r = Fo(e, n), o = Fo(t, n);
  return r.col === o.col;
}
function l0(e, t, n, r) {
  const o = [];
  for (const [i, s] of Object.entries(e.styles || {})) {
    const a = n[i];
    if (!a)
      throw new Error(`style ${i} not found in styleSchema`);
    if (a.propSchema === "boolean")
      s && o.push(t.mark(i));
    else if (a.propSchema === "string")
      s && o.push(t.mark(i, { stringValue: s }));
    else
      throw new br(a.propSchema);
  }
  return !r || !t.nodes[r].spec.code ? e.text.split(/(\n)/g).filter((i) => i.length > 0).map((i) => i === `
` ? t.nodes.hardBreak.createChecked() : t.text(i, o)) : e.text.length > 0 ? [t.text(e.text, o)] : [];
}
function tA(e, t, n) {
  const r = t.marks.link.create({
    href: e.href
  });
  return af(e.content, t, n).map(
    (o) => {
      if (o.type.name === "text")
        return o.mark([...o.marks, r]);
      if (o.type.name === "hardBreak")
        return o;
      throw new Error("unexpected node type");
    }
  );
}
function af(e, t, n, r) {
  const o = [];
  if (typeof e == "string")
    return o.push(
      ...l0(
        { text: e, styles: {} },
        t,
        n,
        r
      )
    ), o;
  for (const i of e)
    o.push(
      ...l0(i, t, n, r)
    );
  return o;
}
function Gn(e, t, n, r = Hi(t)) {
  const o = [];
  for (const i of e)
    typeof i == "string" ? o.push(
      ...af(i, t, r, n)
    ) : kE(i) ? o.push(...tA(i, t, r)) : $o(i) ? o.push(
      ...af([i], t, r, n)
    ) : o.push(
      SE(i, t, r)
    );
  return o;
}
function Hc(e, t, n = Hi(t)) {
  const r = [], o = new Array(e.headerRows ?? 0).fill(!0), i = new Array(e.headerCols ?? 0).fill(!0), s = e.columnWidths ?? [];
  for (let a = 0; a < e.rows.length; a++) {
    const l = e.rows[a], c = [], u = o[a];
    for (let f = 0; f < l.cells.length; f++) {
      const h = l.cells[f], p = i[f], m = void 0;
      let b = null;
      const y = Fo(
        {
          row: a,
          col: f
        },
        { content: e }
      );
      let k = s[y.col] ? [s[y.col]] : null;
      if (h) if (typeof h == "string")
        b = t.text(h);
      else if (Ls(h)) {
        h.content && (b = Gn(
          h.content,
          t,
          "tableParagraph",
          n
        ));
        const _ = Ho(h);
        _ > 1 && (k = new Array(_).fill(!1).map((w, T) => s[y.col + T] ?? void 0));
      } else
        b = Gn(
          h,
          t,
          "tableParagraph",
          n
        );
      const C = t.nodes[p || u ? "tableHeader" : "tableCell"].createChecked(
        {
          ...Ls(h) ? h.props : {},
          colwidth: k
        },
        t.nodes.tableParagraph.createChecked(m, b)
      );
      c.push(C);
    }
    const d = t.nodes.tableRow.createChecked({}, c);
    r.push(d);
  }
  return r;
}
function SE(e, t, n) {
  let r, o = e.type;
  if (o === void 0 && (o = "paragraph"), !t.nodes[o])
    throw new Error(`node type ${o} not found in schema`);
  if (!e.content)
    r = t.nodes[o].createChecked(e.props);
  else if (typeof e.content == "string") {
    const i = Gn(
      [e.content],
      t,
      o,
      n
    );
    r = t.nodes[o].createChecked(e.props, i);
  } else if (Array.isArray(e.content)) {
    const i = Gn(
      e.content,
      t,
      o,
      n
    );
    r = t.nodes[o].createChecked(e.props, i);
  } else if (e.content.type === "tableContent") {
    const i = Hc(e.content, t, n);
    r = t.nodes[o].createChecked(e.props, i);
  } else
    throw new br(e.content.type);
  return r;
}
function Ko(e, t, n = Hi(t)) {
  let r = e.id;
  r === void 0 && (r = Pc.options.generateID());
  const o = [];
  if (e.children)
    for (const i of e.children)
      o.push(Ko(i, t, n));
  if (!e.type || // can happen if block.type is not defined (this should create the default node)
  t.nodes[e.type].isInGroup("blockContent")) {
    const i = SE(
      e,
      t,
      n
    ), s = o.length > 0 ? t.nodes.blockGroup.createChecked({}, o) : void 0;
    return t.nodes.blockContainer.createChecked(
      {
        id: r,
        ...e.props
      },
      s ? [i, s] : i
    );
  } else {
    if (t.nodes[e.type].isInGroup("bnBlock"))
      return t.nodes[e.type].createChecked(
        {
          id: r,
          ...e.props
        },
        o
      );
    throw new Error(
      `block type ${e.type} doesn't match blockContent or bnBlock group`
    );
  }
}
let lf, cf;
if (typeof WeakMap < "u") {
  let e = /* @__PURE__ */ new WeakMap();
  lf = (t) => e.get(t), cf = (t, n) => (e.set(t, n), n);
} else {
  const e = [];
  let n = 0;
  lf = (r) => {
    for (let o = 0; o < e.length; o += 2) if (e[o] == r) return e[o + 1];
  }, cf = (r, o) => (n == 10 && (n = 0), e[n++] = r, e[n++] = o);
}
var Je = class {
  constructor(e, t, n, r) {
    this.width = e, this.height = t, this.map = n, this.problems = r;
  }
  findCell(e) {
    for (let t = 0; t < this.map.length; t++) {
      const n = this.map[t];
      if (n != e) continue;
      const r = t % this.width, o = t / this.width | 0;
      let i = r + 1, s = o + 1;
      for (let a = 1; i < this.width && this.map[t + a] == n; a++) i++;
      for (let a = 1; s < this.height && this.map[t + this.width * a] == n; a++) s++;
      return {
        left: r,
        top: o,
        right: i,
        bottom: s
      };
    }
    throw new RangeError(`No cell with offset ${e} found`);
  }
  colCount(e) {
    for (let t = 0; t < this.map.length; t++) if (this.map[t] == e) return t % this.width;
    throw new RangeError(`No cell with offset ${e} found`);
  }
  nextCell(e, t, n) {
    const { left: r, right: o, top: i, bottom: s } = this.findCell(e);
    return t == "horiz" ? (n < 0 ? r == 0 : o == this.width) ? null : this.map[i * this.width + (n < 0 ? r - 1 : o)] : (n < 0 ? i == 0 : s == this.height) ? null : this.map[r + this.width * (n < 0 ? i - 1 : s)];
  }
  rectBetween(e, t) {
    const { left: n, right: r, top: o, bottom: i } = this.findCell(e), { left: s, right: a, top: l, bottom: c } = this.findCell(t);
    return {
      left: Math.min(n, s),
      top: Math.min(o, l),
      right: Math.max(r, a),
      bottom: Math.max(i, c)
    };
  }
  cellsInRect(e) {
    const t = [], n = {};
    for (let r = e.top; r < e.bottom; r++) for (let o = e.left; o < e.right; o++) {
      const i = r * this.width + o, s = this.map[i];
      n[s] || (n[s] = !0, !(o == e.left && o && this.map[i - 1] == s || r == e.top && r && this.map[i - this.width] == s) && t.push(s));
    }
    return t;
  }
  positionAt(e, t, n) {
    for (let r = 0, o = 0; ; r++) {
      const i = o + n.child(r).nodeSize;
      if (r == e) {
        let s = t + e * this.width;
        const a = (e + 1) * this.width;
        for (; s < a && this.map[s] < o; ) s++;
        return s == a ? i - 1 : this.map[s];
      }
      o = i;
    }
  }
  static get(e) {
    return lf(e) || cf(e, nA(e));
  }
};
function nA(e) {
  if (e.type.spec.tableRole != "table") throw new RangeError("Not a table node: " + e.type.name);
  const t = rA(e), n = e.childCount, r = [];
  let o = 0, i = null;
  const s = [];
  for (let c = 0, u = t * n; c < u; c++) r[c] = 0;
  for (let c = 0, u = 0; c < n; c++) {
    const d = e.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; o < r.length && r[o] != 0; ) o++;
      if (p == d.childCount) break;
      const m = d.child(p), { colspan: b, rowspan: y, colwidth: k } = m.attrs;
      for (let C = 0; C < y; C++) {
        if (C + c >= n) {
          (i || (i = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: y - C
          });
          break;
        }
        const _ = o + C * t;
        for (let w = 0; w < b; w++) {
          r[_ + w] == 0 ? r[_ + w] = u : (i || (i = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: b - w
          });
          const T = k && k[w];
          if (T) {
            const M = (_ + w) % t * 2, D = s[M];
            D == null || D != T && s[M + 1] == 1 ? (s[M] = T, s[M + 1] = 1) : D == T && s[M + 1]++;
          }
        }
      }
      o += b, u += m.nodeSize;
    }
    const f = (c + 1) * t;
    let h = 0;
    for (; o < f; ) r[o++] == 0 && h++;
    h && (i || (i = [])).push({
      type: "missing",
      row: c,
      n: h
    }), u++;
  }
  (t === 0 || n === 0) && (i || (i = [])).push({ type: "zero_sized" });
  const a = new Je(t, n, r, i);
  let l = !1;
  for (let c = 0; !l && c < s.length; c += 2) s[c] != null && s[c + 1] < n && (l = !0);
  return l && oA(a, s, e), a;
}
function rA(e) {
  let t = -1, n = !1;
  for (let r = 0; r < e.childCount; r++) {
    const o = e.child(r);
    let i = 0;
    if (n) for (let s = 0; s < r; s++) {
      const a = e.child(s);
      for (let l = 0; l < a.childCount; l++) {
        const c = a.child(l);
        s + c.attrs.rowspan > r && (i += c.attrs.colspan);
      }
    }
    for (let s = 0; s < o.childCount; s++) {
      const a = o.child(s);
      i += a.attrs.colspan, a.attrs.rowspan > 1 && (n = !0);
    }
    t == -1 ? t = i : t != i && (t = Math.max(t, i));
  }
  return t;
}
function oA(e, t, n) {
  e.problems || (e.problems = []);
  const r = {};
  for (let o = 0; o < e.map.length; o++) {
    const i = e.map[o];
    if (r[i]) continue;
    r[i] = !0;
    const s = n.nodeAt(i);
    if (!s) throw new RangeError(`No cell with offset ${i} found`);
    let a = null;
    const l = s.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const u = t[(o + c) % e.width * 2];
      u != null && (!l.colwidth || l.colwidth[c] != u) && ((a || (a = iA(l)))[c] = u);
    }
    a && e.problems.unshift({
      type: "colwidth mismatch",
      pos: i,
      colwidth: a
    });
  }
}
function iA(e) {
  if (e.colwidth) return e.colwidth.slice();
  const t = [];
  for (let n = 0; n < e.colspan; n++) t.push(0);
  return t;
}
function $t(e) {
  let t = e.cached.tableNodeTypes;
  if (!t) {
    t = e.cached.tableNodeTypes = {};
    for (const n in e.nodes) {
      const r = e.nodes[n], o = r.spec.tableRole;
      o && (t[o] = r);
    }
  }
  return t;
}
const Zr = new we("selectingCells");
function Uo(e) {
  for (let t = e.depth - 1; t > 0; t--) if (e.node(t).type.spec.tableRole == "row") return e.node(0).resolve(e.before(t + 1));
  return null;
}
function sA(e) {
  for (let t = e.depth; t > 0; t--) {
    const n = e.node(t).type.spec.tableRole;
    if (n === "cell" || n === "header_cell") return e.node(t);
  }
  return null;
}
function kr(e) {
  const t = e.selection.$head;
  for (let n = t.depth; n > 0; n--) if (t.node(n).type.spec.tableRole == "row") return !0;
  return !1;
}
function Uh(e) {
  const t = e.selection;
  if ("$anchorCell" in t && t.$anchorCell) return t.$anchorCell.pos > t.$headCell.pos ? t.$anchorCell : t.$headCell;
  if ("node" in t && t.node && t.node.type.spec.tableRole == "cell") return t.$anchor;
  const n = Uo(t.$head) || aA(t.$head);
  if (n) return n;
  throw new RangeError(`No cell found around position ${t.head}`);
}
function aA(e) {
  for (let t = e.nodeAfter, n = e.pos; t; t = t.firstChild, n++) {
    const r = t.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return e.doc.resolve(n);
  }
  for (let t = e.nodeBefore, n = e.pos; t; t = t.lastChild, n--) {
    const r = t.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return e.doc.resolve(n - t.nodeSize);
  }
}
function uf(e) {
  return e.parent.type.spec.tableRole == "row" && !!e.nodeAfter;
}
function lA(e) {
  return e.node(0).resolve(e.pos + e.nodeAfter.nodeSize);
}
function jh(e, t) {
  return e.depth == t.depth && e.pos >= t.start(-1) && e.pos <= t.end(-1);
}
function _E(e, t, n) {
  const r = e.node(-1), o = Je.get(r), i = e.start(-1), s = o.nextCell(e.pos - i, t, n);
  return s == null ? null : e.node(0).resolve(i + s);
}
function jo(e, t, n = 1) {
  const r = {
    ...e,
    colspan: e.colspan - n
  };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(t, n), r.colwidth.some((o) => o > 0) || (r.colwidth = null)), r;
}
function AE(e, t, n = 1) {
  const r = {
    ...e,
    colspan: e.colspan + n
  };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let o = 0; o < n; o++) r.colwidth.splice(t, 0, 0);
  }
  return r;
}
function cA(e, t, n) {
  const r = $t(t.type.schema).header_cell;
  for (let o = 0; o < e.height; o++) if (t.nodeAt(e.map[n + o * e.width]).type != r) return !1;
  return !0;
}
var qe = class Lr extends ot {
  constructor(t, n = t) {
    const r = t.node(-1), o = Je.get(r), i = t.start(-1), s = o.rectBetween(t.pos - i, n.pos - i), a = t.node(0), l = o.cellsInRect(s).filter((u) => u != n.pos - i);
    l.unshift(n.pos - i);
    const c = l.map((u) => {
      const d = r.nodeAt(u);
      if (!d) throw new RangeError(`No cell with offset ${u} found`);
      const f = i + u + 1;
      return new mv(a.resolve(f), a.resolve(f + d.content.size));
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = t, this.$headCell = n;
  }
  map(t, n) {
    const r = t.resolve(n.map(this.$anchorCell.pos)), o = t.resolve(n.map(this.$headCell.pos));
    if (uf(r) && uf(o) && jh(r, o)) {
      const i = this.$anchorCell.node(-1) != r.node(-1);
      return i && this.isRowSelection() ? Lr.rowSelection(r, o) : i && this.isColSelection() ? Lr.colSelection(r, o) : new Lr(r, o);
    }
    return pe.between(r, o);
  }
  content() {
    const t = this.$anchorCell.node(-1), n = Je.get(t), r = this.$anchorCell.start(-1), o = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r), i = {}, s = [];
    for (let l = o.top; l < o.bottom; l++) {
      const c = [];
      for (let u = l * n.width + o.left, d = o.left; d < o.right; d++, u++) {
        const f = n.map[u];
        if (i[f]) continue;
        i[f] = !0;
        const h = n.findCell(f);
        let p = t.nodeAt(f);
        if (!p) throw new RangeError(`No cell with offset ${f} found`);
        const m = o.left - h.left, b = h.right - o.right;
        if (m > 0 || b > 0) {
          let y = p.attrs;
          if (m > 0 && (y = jo(y, 0, m)), b > 0 && (y = jo(y, y.colspan - b, b)), h.left < o.left) {
            if (p = p.type.createAndFill(y), !p) throw new RangeError(`Could not create cell with attrs ${JSON.stringify(y)}`);
          } else p = p.type.create(y, p.content);
        }
        if (h.top < o.top || h.bottom > o.bottom) {
          const y = {
            ...p.attrs,
            rowspan: Math.min(h.bottom, o.bottom) - Math.max(h.top, o.top)
          };
          h.top < o.top ? p = p.type.createAndFill(y) : p = p.type.create(y, p.content);
        }
        c.push(p);
      }
      s.push(t.child(l).copy(be.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? t : s;
    return new lt(be.from(a), 1, 1);
  }
  replace(t, n = lt.empty) {
    const r = t.steps.length, o = this.ranges;
    for (let s = 0; s < o.length; s++) {
      const { $from: a, $to: l } = o[s], c = t.mapping.slice(r);
      t.replace(c.map(a.pos), c.map(l.pos), s ? lt.empty : n);
    }
    const i = ot.findFrom(t.doc.resolve(t.mapping.slice(r).map(this.to)), -1);
    i && t.setSelection(i);
  }
  replaceWith(t, n) {
    this.replace(t, new lt(be.from(n), 0, 0));
  }
  forEachCell(t) {
    const n = this.$anchorCell.node(-1), r = Je.get(n), o = this.$anchorCell.start(-1), i = r.cellsInRect(r.rectBetween(this.$anchorCell.pos - o, this.$headCell.pos - o));
    for (let s = 0; s < i.length; s++) t(n.nodeAt(i[s]), o + i[s]);
  }
  isColSelection() {
    const t = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(t, n) > 0) return !1;
    const r = t + this.$anchorCell.nodeAfter.attrs.rowspan, o = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, o) == this.$headCell.node(-1).childCount;
  }
  static colSelection(t, n = t) {
    const r = t.node(-1), o = Je.get(r), i = t.start(-1), s = o.findCell(t.pos - i), a = o.findCell(n.pos - i), l = t.node(0);
    return s.top <= a.top ? (s.top > 0 && (t = l.resolve(i + o.map[s.left])), a.bottom < o.height && (n = l.resolve(i + o.map[o.width * (o.height - 1) + a.right - 1]))) : (a.top > 0 && (n = l.resolve(i + o.map[a.left])), s.bottom < o.height && (t = l.resolve(i + o.map[o.width * (o.height - 1) + s.right - 1]))), new Lr(t, n);
  }
  isRowSelection() {
    const t = this.$anchorCell.node(-1), n = Je.get(t), r = this.$anchorCell.start(-1), o = n.colCount(this.$anchorCell.pos - r), i = n.colCount(this.$headCell.pos - r);
    if (Math.min(o, i) > 0) return !1;
    const s = o + this.$anchorCell.nodeAfter.attrs.colspan, a = i + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(s, a) == n.width;
  }
  eq(t) {
    return t instanceof Lr && t.$anchorCell.pos == this.$anchorCell.pos && t.$headCell.pos == this.$headCell.pos;
  }
  static rowSelection(t, n = t) {
    const r = t.node(-1), o = Je.get(r), i = t.start(-1), s = o.findCell(t.pos - i), a = o.findCell(n.pos - i), l = t.node(0);
    return s.left <= a.left ? (s.left > 0 && (t = l.resolve(i + o.map[s.top * o.width])), a.right < o.width && (n = l.resolve(i + o.map[o.width * (a.top + 1) - 1]))) : (a.left > 0 && (n = l.resolve(i + o.map[a.top * o.width])), s.right < o.width && (t = l.resolve(i + o.map[o.width * (s.top + 1) - 1]))), new Lr(t, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(t, n) {
    return new Lr(t.resolve(n.anchor), t.resolve(n.head));
  }
  static create(t, n, r = n) {
    return new Lr(t.resolve(n), t.resolve(r));
  }
  getBookmark() {
    return new uA(this.$anchorCell.pos, this.$headCell.pos);
  }
};
qe.prototype.visible = !1;
ot.jsonID("cell", qe);
var uA = class IE {
  constructor(t, n) {
    this.anchor = t, this.head = n;
  }
  map(t) {
    return new IE(t.map(this.anchor), t.map(this.head));
  }
  resolve(t) {
    const n = t.resolve(this.anchor), r = t.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && jh(n, r) ? new qe(n, r) : ot.near(r, 1);
  }
};
function dA(e) {
  if (!(e.selection instanceof qe)) return null;
  const t = [];
  return e.selection.forEachCell((n, r) => {
    t.push(Lt.node(r, r + n.nodeSize, { class: "selectedCell" }));
  }), kt.create(e.doc, t);
}
function fA({ $from: e, $to: t }) {
  if (e.pos == t.pos || e.pos < t.pos - 6) return !1;
  let n = e.pos, r = t.pos, o = e.depth;
  for (; o >= 0 && !(e.after(o + 1) < e.end(o)); o--, n++) ;
  for (let i = t.depth; i >= 0 && !(t.before(i + 1) > t.start(i)); i--, r--) ;
  return n == r && /row|table/.test(e.node(o).type.spec.tableRole);
}
function hA({ $from: e, $to: t }) {
  let n, r;
  for (let o = e.depth; o > 0; o--) {
    const i = e.node(o);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      n = i;
      break;
    }
  }
  for (let o = t.depth; o > 0; o--) {
    const i = t.node(o);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      r = i;
      break;
    }
  }
  return n !== r && t.parentOffset === 0;
}
function pA(e, t, n) {
  const r = (t || e).selection, o = (t || e).doc;
  let i, s;
  if (r instanceof cn && (s = r.node.type.spec.tableRole)) {
    if (s == "cell" || s == "header_cell") i = qe.create(o, r.from);
    else if (s == "row") {
      const a = o.resolve(r.from + 1);
      i = qe.rowSelection(a, a);
    } else if (!n) {
      const a = Je.get(r.node), l = r.from + 1, c = l + a.map[a.width * a.height - 1];
      i = qe.create(o, l + 1, c);
    }
  } else r instanceof pe && fA(r) ? i = pe.create(o, r.from) : r instanceof pe && hA(r) && (i = pe.create(o, r.$from.start(), r.$from.end()));
  return i && (t || (t = e.tr)).setSelection(i), t;
}
const mA = new we("fix-tables");
function NE(e, t, n, r) {
  const o = e.childCount, i = t.childCount;
  e: for (let s = 0, a = 0; s < i; s++) {
    const l = t.child(s);
    for (let c = a, u = Math.min(o, s + 3); c < u; c++) if (e.child(c) == l) {
      a = c + 1, n += l.nodeSize;
      continue e;
    }
    r(l, n), a < o && e.child(a).sameMarkup(l) ? NE(e.child(a), l, n + 1, r) : l.nodesBetween(0, l.content.size, r, n + 1), n += l.nodeSize;
  }
}
function gA(e, t) {
  let n;
  const r = (o, i) => {
    o.type.spec.tableRole == "table" && (n = bA(e, o, i, n));
  };
  return t ? t.doc != e.doc && NE(t.doc, e.doc, 0, r) : e.doc.descendants(r), n;
}
function bA(e, t, n, r) {
  const o = Je.get(t);
  if (!o.problems) return r;
  r || (r = e.tr);
  const i = [];
  for (let l = 0; l < o.height; l++) i.push(0);
  for (let l = 0; l < o.problems.length; l++) {
    const c = o.problems[l];
    if (c.type == "collision") {
      const u = t.nodeAt(c.pos);
      if (!u) continue;
      const d = u.attrs;
      for (let f = 0; f < d.rowspan; f++) i[c.row + f] += c.n;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, jo(d, d.colspan - c.n, c.n));
    } else if (c.type == "missing") i[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = t.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = t.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = r.mapping.map(n);
      r.delete(u, u + t.nodeSize);
    }
  }
  let s, a;
  for (let l = 0; l < i.length; l++) i[l] && (s == null && (s = l), a = l);
  for (let l = 0, c = n + 1; l < o.height; l++) {
    const u = t.child(l), d = c + u.nodeSize, f = i[l];
    if (f > 0) {
      let h = "cell";
      u.firstChild && (h = u.firstChild.type.spec.tableRole);
      const p = [];
      for (let b = 0; b < f; b++) {
        const y = $t(e.schema)[h].createAndFill();
        y && p.push(y);
      }
      const m = (l == 0 || s == l - 1) && a == l ? c + 1 : d - 1;
      r.insert(r.mapping.map(m), p);
    }
    c = d;
  }
  return r.setMeta(mA, { fixTables: !0 });
}
function Cr(e) {
  const t = e.selection, n = Uh(e), r = n.node(-1), o = n.start(-1), i = Je.get(r);
  return {
    ...t instanceof qe ? i.rectBetween(t.$anchorCell.pos - o, t.$headCell.pos - o) : i.findCell(n.pos - o),
    tableStart: o,
    map: i,
    table: r
  };
}
function ME(e, { map: t, tableStart: n, table: r }, o) {
  let i = o > 0 ? -1 : 0;
  cA(t, r, o + i) && (i = o == 0 || o == t.width ? null : 0);
  for (let s = 0; s < t.height; s++) {
    const a = s * t.width + o;
    if (o > 0 && o < t.width && t.map[a - 1] == t.map[a]) {
      const l = t.map[a], c = r.nodeAt(l);
      e.setNodeMarkup(e.mapping.map(n + l), null, AE(c.attrs, o - t.colCount(l))), s += c.attrs.rowspan - 1;
    } else {
      const l = i == null ? $t(r.type.schema).cell : r.nodeAt(t.map[a + i]).type, c = t.positionAt(s, o, r);
      e.insert(e.mapping.map(n + c), l.createAndFill());
    }
  }
  return e;
}
function yA(e, t) {
  if (!kr(e)) return !1;
  if (t) {
    const n = Cr(e);
    t(ME(e.tr, n, n.left));
  }
  return !0;
}
function EA(e, t) {
  if (!kr(e)) return !1;
  if (t) {
    const n = Cr(e);
    t(ME(e.tr, n, n.right));
  }
  return !0;
}
function kA(e, { map: t, table: n, tableStart: r }, o) {
  const i = e.mapping.maps.length;
  for (let s = 0; s < t.height; ) {
    const a = s * t.width + o, l = t.map[a], c = n.nodeAt(l), u = c.attrs;
    if (o > 0 && t.map[a - 1] == l || o < t.width - 1 && t.map[a + 1] == l) e.setNodeMarkup(e.mapping.slice(i).map(r + l), null, jo(u, o - t.colCount(l)));
    else {
      const d = e.mapping.slice(i).map(r + l);
      e.delete(d, d + c.nodeSize);
    }
    s += u.rowspan;
  }
}
function CA(e, t) {
  if (!kr(e)) return !1;
  if (t) {
    const n = Cr(e), r = e.tr;
    if (n.left == 0 && n.right == n.map.width) return !1;
    for (let o = n.right - 1; kA(r, n, o), o != n.left; o--) {
      const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!i) throw new RangeError("No table found");
      n.table = i, n.map = Je.get(i);
    }
    t(r);
  }
  return !0;
}
function TA(e, t, n) {
  var r;
  const o = $t(t.type.schema).header_cell;
  for (let i = 0; i < e.width; i++) if (((r = t.nodeAt(e.map[i + n * e.width])) === null || r === void 0 ? void 0 : r.type) != o) return !1;
  return !0;
}
function LE(e, { map: t, tableStart: n, table: r }, o) {
  let i = n;
  for (let c = 0; c < o; c++) i += r.child(c).nodeSize;
  const s = [];
  let a = o > 0 ? -1 : 0;
  TA(t, r, o + a) && (a = o == 0 || o == t.height ? null : 0);
  for (let c = 0, u = t.width * o; c < t.width; c++, u++) if (o > 0 && o < t.height && t.map[u] == t.map[u - t.width]) {
    const d = t.map[u], f = r.nodeAt(d).attrs;
    e.setNodeMarkup(n + d, null, {
      ...f,
      rowspan: f.rowspan + 1
    }), c += f.colspan - 1;
  } else {
    var l;
    const d = a == null ? $t(r.type.schema).cell : (l = r.nodeAt(t.map[u + a * t.width])) === null || l === void 0 ? void 0 : l.type, f = d == null ? void 0 : d.createAndFill();
    f && s.push(f);
  }
  return e.insert(i, $t(r.type.schema).row.create(null, s)), e;
}
function xA(e, t) {
  if (!kr(e)) return !1;
  if (t) {
    const n = Cr(e);
    t(LE(e.tr, n, n.top));
  }
  return !0;
}
function wA(e, t) {
  if (!kr(e)) return !1;
  if (t) {
    const n = Cr(e);
    t(LE(e.tr, n, n.bottom));
  }
  return !0;
}
function vA(e, { map: t, table: n, tableStart: r }, o) {
  let i = 0;
  for (let c = 0; c < o; c++) i += n.child(c).nodeSize;
  const s = i + n.child(o).nodeSize, a = e.mapping.maps.length;
  e.delete(i + r, s + r);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, u = o * t.width; c < t.width; c++, u++) {
    const d = t.map[u];
    if (!l.has(d)) {
      if (l.add(d), o > 0 && d == t.map[u - t.width]) {
        const f = n.nodeAt(d).attrs;
        e.setNodeMarkup(e.mapping.slice(a).map(d + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (o < t.height && d == t.map[u + t.width]) {
        const f = n.nodeAt(d), h = f.attrs, p = f.type.create({
          ...h,
          rowspan: f.attrs.rowspan - 1
        }, f.content), m = t.positionAt(o + 1, c, n);
        e.insert(e.mapping.slice(a).map(r + m), p), c += h.colspan - 1;
      }
    }
  }
}
function SA(e, t) {
  if (!kr(e)) return !1;
  if (t) {
    const n = Cr(e), r = e.tr;
    if (n.top == 0 && n.bottom == n.map.height) return !1;
    for (let o = n.bottom - 1; vA(r, n, o), o != n.top; o--) {
      const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!i) throw new RangeError("No table found");
      n.table = i, n.map = Je.get(n.table);
    }
    t(r);
  }
  return !0;
}
function c0(e) {
  const t = e.content;
  return t.childCount == 1 && t.child(0).isTextblock && t.child(0).childCount == 0;
}
function _A({ width: e, height: t, map: n }, r) {
  let o = r.top * e + r.left, i = o, s = (r.bottom - 1) * e + r.left, a = o + (r.right - r.left - 1);
  for (let l = r.top; l < r.bottom; l++) {
    if (r.left > 0 && n[i] == n[i - 1] || r.right < e && n[a] == n[a + 1]) return !0;
    i += e, a += e;
  }
  for (let l = r.left; l < r.right; l++) {
    if (r.top > 0 && n[o] == n[o - e] || r.bottom < t && n[s] == n[s + e]) return !0;
    o++, s++;
  }
  return !1;
}
function AA(e, t) {
  const n = e.selection;
  if (!(n instanceof qe) || n.$anchorCell.pos == n.$headCell.pos) return !1;
  const r = Cr(e), { map: o } = r;
  if (_A(o, r)) return !1;
  if (t) {
    const i = e.tr, s = {};
    let a = be.empty, l, c;
    for (let u = r.top; u < r.bottom; u++) for (let d = r.left; d < r.right; d++) {
      const f = o.map[u * o.width + d], h = r.table.nodeAt(f);
      if (!(s[f] || !h))
        if (s[f] = !0, l == null)
          l = f, c = h;
        else {
          c0(h) || (a = a.append(h.content));
          const p = i.mapping.map(f + r.tableStart);
          i.delete(p, p + h.nodeSize);
        }
    }
    if (l == null || c == null) return !0;
    if (i.setNodeMarkup(l + r.tableStart, null, {
      ...AE(c.attrs, c.attrs.colspan, r.right - r.left - c.attrs.colspan),
      rowspan: r.bottom - r.top
    }), a.size > 0) {
      const u = l + 1 + c.content.size, d = c0(c) ? l + 1 : u;
      i.replaceWith(d + r.tableStart, u + r.tableStart, a);
    }
    i.setSelection(new qe(i.doc.resolve(l + r.tableStart))), t(i);
  }
  return !0;
}
function IA(e, t) {
  const n = $t(e.schema);
  return NA(({ node: r }) => n[r.type.spec.tableRole])(e, t);
}
function NA(e) {
  return (t, n) => {
    const r = t.selection;
    let o, i;
    if (r instanceof qe) {
      if (r.$anchorCell.pos != r.$headCell.pos) return !1;
      o = r.$anchorCell.nodeAfter, i = r.$anchorCell.pos;
    } else {
      var s;
      if (o = sA(r.$from), !o) return !1;
      i = (s = Uo(r.$from)) === null || s === void 0 ? void 0 : s.pos;
    }
    if (o == null || i == null || o.attrs.colspan == 1 && o.attrs.rowspan == 1) return !1;
    if (n) {
      let a = o.attrs;
      const l = [], c = a.colwidth;
      a.rowspan > 1 && (a = {
        ...a,
        rowspan: 1
      }), a.colspan > 1 && (a = {
        ...a,
        colspan: 1
      });
      const u = Cr(t), d = t.tr;
      for (let h = 0; h < u.right - u.left; h++) l.push(c ? {
        ...a,
        colwidth: c && c[h] ? [c[h]] : null
      } : a);
      let f;
      for (let h = u.top; h < u.bottom; h++) {
        let p = u.map.positionAt(h, u.left, u.table);
        h == u.top && (p += o.nodeSize);
        for (let m = u.left, b = 0; m < u.right; m++, b++)
          m == u.left && h == u.top || d.insert(f = d.mapping.map(p + u.tableStart, 1), e({
            node: o,
            row: h,
            col: m
          }).createAndFill(l[b]));
      }
      d.setNodeMarkup(i, e({
        node: o,
        row: u.top,
        col: u.left
      }), l[0]), r instanceof qe && d.setSelection(new qe(d.doc.resolve(r.$anchorCell.pos), f ? d.doc.resolve(f) : void 0)), n(d);
    }
    return !0;
  };
}
function MA(e) {
  return function(t, n) {
    if (!kr(t)) return !1;
    if (n) {
      const r = $t(t.schema), o = Cr(t), i = t.tr, s = o.map.cellsInRect(e == "column" ? {
        left: o.left,
        top: 0,
        right: o.right,
        bottom: o.map.height
      } : e == "row" ? {
        left: 0,
        top: o.top,
        right: o.map.width,
        bottom: o.bottom
      } : o), a = s.map((l) => o.table.nodeAt(l));
      for (let l = 0; l < s.length; l++) a[l].type == r.header_cell && i.setNodeMarkup(o.tableStart + s[l], r.cell, a[l].attrs);
      if (i.steps.length === 0) for (let l = 0; l < s.length; l++) i.setNodeMarkup(o.tableStart + s[l], r.header_cell, a[l].attrs);
      n(i);
    }
    return !0;
  };
}
function u0(e, t, n) {
  const r = t.map.cellsInRect({
    left: 0,
    top: 0,
    right: e == "row" ? t.map.width : 1,
    bottom: e == "column" ? t.map.height : 1
  });
  for (let o = 0; o < r.length; o++) {
    const i = t.table.nodeAt(r[o]);
    if (i && i.type !== n.header_cell) return !1;
  }
  return !0;
}
function Vh(e, t) {
  return t = t || { useDeprecatedLogic: !1 }, t.useDeprecatedLogic ? MA(e) : function(n, r) {
    if (!kr(n)) return !1;
    if (r) {
      const o = $t(n.schema), i = Cr(n), s = n.tr, a = u0("row", i, o), l = u0("column", i, o), c = (e === "column" ? a : e === "row" && l) ? 1 : 0, u = e == "column" ? {
        left: 0,
        top: c,
        right: 1,
        bottom: i.map.height
      } : e == "row" ? {
        left: c,
        top: 0,
        right: i.map.width,
        bottom: 1
      } : i, d = e == "column" ? l ? o.cell : o.header_cell : e == "row" ? a ? o.cell : o.header_cell : o.cell;
      i.map.cellsInRect(u).forEach((f) => {
        const h = f + i.tableStart, p = s.doc.nodeAt(h);
        p && s.setNodeMarkup(h, d, p.attrs);
      }), r(s);
    }
    return !0;
  };
}
Vh("row", { useDeprecatedLogic: !0 });
Vh("column", { useDeprecatedLogic: !0 });
Vh("cell", { useDeprecatedLogic: !0 });
function LA(e, t) {
  if (t < 0) {
    const n = e.nodeBefore;
    if (n) return e.pos - n.nodeSize;
    for (let r = e.index(-1) - 1, o = e.before(); r >= 0; r--) {
      const i = e.node(-1).child(r), s = i.lastChild;
      if (s) return o - 1 - s.nodeSize;
      o -= i.nodeSize;
    }
  } else {
    if (e.index() < e.parent.childCount - 1) return e.pos + e.nodeAfter.nodeSize;
    const n = e.node(-1);
    for (let r = e.indexAfter(-1), o = e.after(); r < n.childCount; r++) {
      const i = n.child(r);
      if (i.childCount) return o + 1;
      o += i.nodeSize;
    }
  }
  return null;
}
function d0(e) {
  return function(t, n) {
    if (!kr(t)) return !1;
    const r = LA(Uh(t), e);
    if (r == null) return !1;
    if (n) {
      const o = t.doc.resolve(r);
      n(t.tr.setSelection(pe.between(o, lA(o))).scrollIntoView());
    }
    return !0;
  };
}
function Da(e, t) {
  const n = e.selection;
  if (!(n instanceof qe)) return !1;
  if (t) {
    const r = e.tr, o = $t(e.schema).cell.createAndFill().content;
    n.forEachCell((i, s) => {
      i.content.eq(o) || r.replace(r.mapping.map(s + 1), r.mapping.map(s + i.nodeSize - 1), new lt(o, 0, 0));
    }), r.docChanged && t(r);
  }
  return !0;
}
function OA(e) {
  if (e.size === 0) return null;
  let { content: t, openStart: n, openEnd: r } = e;
  for (; t.childCount == 1 && (n > 0 && r > 0 || t.child(0).type.spec.tableRole == "table"); )
    n--, r--, t = t.child(0).content;
  const o = t.child(0), i = o.type.spec.tableRole, s = o.type.schema, a = [];
  if (i == "row") for (let l = 0; l < t.childCount; l++) {
    let c = t.child(l).content;
    const u = l ? 0 : Math.max(0, n - 1), d = l < t.childCount - 1 ? 0 : Math.max(0, r - 1);
    (u || d) && (c = df($t(s).row, new lt(c, u, d)).content), a.push(c);
  }
  else if (i == "cell" || i == "header_cell") a.push(n || r ? df($t(s).row, new lt(t, n, r)).content : t);
  else return null;
  return DA(s, a);
}
function DA(e, t) {
  const n = [];
  for (let o = 0; o < t.length; o++) {
    const i = t[o];
    for (let s = i.childCount - 1; s >= 0; s--) {
      const { rowspan: a, colspan: l } = i.child(s).attrs;
      for (let c = o; c < o + a; c++) n[c] = (n[c] || 0) + l;
    }
  }
  let r = 0;
  for (let o = 0; o < n.length; o++) r = Math.max(r, n[o]);
  for (let o = 0; o < n.length; o++)
    if (o >= t.length && t.push(be.empty), n[o] < r) {
      const i = $t(e).cell.createAndFill(), s = [];
      for (let a = n[o]; a < r; a++) s.push(i);
      t[o] = t[o].append(be.from(s));
    }
  return {
    height: t.length,
    width: r,
    rows: t
  };
}
function df(e, t) {
  const n = e.createAndFill();
  return new Eh(n).replace(0, n.content.size, t).doc;
}
function RA({ width: e, height: t, rows: n }, r, o) {
  if (e != r) {
    const i = [], s = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = [];
      for (let u = i[a] || 0, d = 0; u < r; d++) {
        let f = l.child(d % l.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(jo(f.attrs, f.attrs.colspan, u + f.attrs.colspan - r), f.content)), c.push(f), u += f.attrs.colspan;
        for (let h = 1; h < f.attrs.rowspan; h++) i[a + h] = (i[a + h] || 0) + f.attrs.colspan;
      }
      s.push(be.from(c));
    }
    n = s, e = r;
  }
  if (t != o) {
    const i = [];
    for (let s = 0, a = 0; s < o; s++, a++) {
      const l = [], c = n[a % t];
      for (let u = 0; u < c.childCount; u++) {
        let d = c.child(u);
        s + d.attrs.rowspan > o && (d = d.type.create({
          ...d.attrs,
          rowspan: Math.max(1, o - d.attrs.rowspan)
        }, d.content)), l.push(d);
      }
      i.push(be.from(l));
    }
    n = i, t = o;
  }
  return {
    width: e,
    height: t,
    rows: n
  };
}
function PA(e, t, n, r, o, i, s) {
  const a = e.doc.type.schema, l = $t(a);
  let c, u;
  if (o > t.width) for (let d = 0, f = 0; d < t.height; d++) {
    const h = n.child(d);
    f += h.nodeSize;
    const p = [];
    let m;
    h.lastChild == null || h.lastChild.type == l.cell ? m = c || (c = l.cell.createAndFill()) : m = u || (u = l.header_cell.createAndFill());
    for (let b = t.width; b < o; b++) p.push(m);
    e.insert(e.mapping.slice(s).map(f - 1 + r), p);
  }
  if (i > t.height) {
    const d = [];
    for (let p = 0, m = (t.height - 1) * t.width; p < Math.max(t.width, o); p++) {
      const b = p >= t.width ? !1 : n.nodeAt(t.map[m + p]).type == l.header_cell;
      d.push(b ? u || (u = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill()));
    }
    const f = l.row.create(null, be.from(d)), h = [];
    for (let p = t.height; p < i; p++) h.push(f);
    e.insert(e.mapping.slice(s).map(r + n.nodeSize - 2), h);
  }
  return !!(c || u);
}
function f0(e, t, n, r, o, i, s, a) {
  if (s == 0 || s == t.height) return !1;
  let l = !1;
  for (let c = o; c < i; c++) {
    const u = s * t.width + c, d = t.map[u];
    if (t.map[u - t.width] == d) {
      l = !0;
      const f = n.nodeAt(d), { top: h, left: p } = t.findCell(d);
      e.setNodeMarkup(e.mapping.slice(a).map(d + r), null, {
        ...f.attrs,
        rowspan: s - h
      }), e.insert(e.mapping.slice(a).map(t.positionAt(s, p, n)), f.type.createAndFill({
        ...f.attrs,
        rowspan: h + f.attrs.rowspan - s
      })), c += f.attrs.colspan - 1;
    }
  }
  return l;
}
function h0(e, t, n, r, o, i, s, a) {
  if (s == 0 || s == t.width) return !1;
  let l = !1;
  for (let c = o; c < i; c++) {
    const u = c * t.width + s, d = t.map[u];
    if (t.map[u - 1] == d) {
      l = !0;
      const f = n.nodeAt(d), h = t.colCount(d), p = e.mapping.slice(a).map(d + r);
      e.setNodeMarkup(p, null, jo(f.attrs, s - h, f.attrs.colspan - (s - h))), e.insert(p + f.nodeSize, f.type.createAndFill(jo(f.attrs, 0, s - h))), c += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function p0(e, t, n, r, o) {
  let i = n ? e.doc.nodeAt(n - 1) : e.doc;
  if (!i) throw new Error("No table found");
  let s = Je.get(i);
  const { top: a, left: l } = r, c = l + o.width, u = a + o.height, d = e.tr;
  let f = 0;
  function h() {
    if (i = n ? d.doc.nodeAt(n - 1) : d.doc, !i) throw new Error("No table found");
    s = Je.get(i), f = d.mapping.maps.length;
  }
  PA(d, s, i, n, c, u, f) && h(), f0(d, s, i, n, l, c, a, f) && h(), f0(d, s, i, n, l, c, u, f) && h(), h0(d, s, i, n, a, u, l, f) && h(), h0(d, s, i, n, a, u, c, f) && h();
  for (let p = a; p < u; p++) {
    const m = s.positionAt(p, l, i), b = s.positionAt(p, c, i);
    d.replace(d.mapping.slice(f).map(m + n), d.mapping.slice(f).map(b + n), new lt(o.rows[p - a], 0, 0));
  }
  h(), d.setSelection(new qe(d.doc.resolve(n + s.positionAt(a, l, i)), d.doc.resolve(n + s.positionAt(u - 1, c - 1, i)))), t(d);
}
const BA = pv({
  ArrowLeft: Ra("horiz", -1),
  ArrowRight: Ra("horiz", 1),
  ArrowUp: Ra("vert", -1),
  ArrowDown: Ra("vert", 1),
  "Shift-ArrowLeft": Pa("horiz", -1),
  "Shift-ArrowRight": Pa("horiz", 1),
  "Shift-ArrowUp": Pa("vert", -1),
  "Shift-ArrowDown": Pa("vert", 1),
  Backspace: Da,
  "Mod-Backspace": Da,
  Delete: Da,
  "Mod-Delete": Da
});
function ul(e, t, n) {
  return n.eq(e.selection) ? !1 : (t && t(e.tr.setSelection(n).scrollIntoView()), !0);
}
function Ra(e, t) {
  return (n, r, o) => {
    if (!o) return !1;
    const i = n.selection;
    if (i instanceof qe) return ul(n, r, ot.near(i.$headCell, t));
    if (e != "horiz" && !i.empty) return !1;
    const s = OE(o, e, t);
    if (s == null) return !1;
    if (e == "horiz") return ul(n, r, ot.near(n.doc.resolve(i.head + t), t));
    {
      const a = n.doc.resolve(s), l = _E(a, e, t);
      let c;
      return l ? c = ot.near(l, 1) : t < 0 ? c = ot.near(n.doc.resolve(a.before(-1)), -1) : c = ot.near(n.doc.resolve(a.after(-1)), 1), ul(n, r, c);
    }
  };
}
function Pa(e, t) {
  return (n, r, o) => {
    if (!o) return !1;
    const i = n.selection;
    let s;
    if (i instanceof qe) s = i;
    else {
      const l = OE(o, e, t);
      if (l == null) return !1;
      s = new qe(n.doc.resolve(l));
    }
    const a = _E(s.$headCell, e, t);
    return a ? ul(n, r, new qe(s.$anchorCell, a)) : !1;
  };
}
function $A(e, t) {
  const n = e.state.doc, r = Uo(n.resolve(t));
  return r ? (e.dispatch(e.state.tr.setSelection(new qe(r))), !0) : !1;
}
function HA(e, t, n) {
  if (!kr(e.state)) return !1;
  let r = OA(n);
  const o = e.state.selection;
  if (o instanceof qe) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [be.from(df($t(e.state.schema).cell, n))]
    });
    const i = o.$anchorCell.node(-1), s = o.$anchorCell.start(-1), a = Je.get(i).rectBetween(o.$anchorCell.pos - s, o.$headCell.pos - s);
    return r = RA(r, a.right - a.left, a.bottom - a.top), p0(e.state, e.dispatch, s, a, r), !0;
  } else if (r) {
    const i = Uh(e.state), s = i.start(-1);
    return p0(e.state, e.dispatch, s, Je.get(i.node(-1)).findCell(i.pos - s), r), !0;
  } else return !1;
}
function FA(e, t) {
  var n;
  if (t.button != 0 || t.ctrlKey || t.metaKey) return;
  const r = m0(e, t.target);
  let o;
  if (t.shiftKey && e.state.selection instanceof qe)
    i(e.state.selection.$anchorCell, t), t.preventDefault();
  else if (t.shiftKey && r && (o = Uo(e.state.selection.$anchor)) != null && ((n = Gu(e, t)) === null || n === void 0 ? void 0 : n.pos) != o.pos)
    i(o, t), t.preventDefault();
  else if (!r) return;
  function i(l, c) {
    let u = Gu(e, c);
    const d = Zr.getState(e.state) == null;
    if (!u || !jh(l, u)) if (d) u = l;
    else return;
    const f = new qe(l, u);
    if (d || !e.state.selection.eq(f)) {
      const h = e.state.tr.setSelection(f);
      d && h.setMeta(Zr, l.pos), e.dispatch(h);
    }
  }
  function s() {
    e.root.removeEventListener("mouseup", s), e.root.removeEventListener("dragstart", s), e.root.removeEventListener("mousemove", a), Zr.getState(e.state) != null && e.dispatch(e.state.tr.setMeta(Zr, -1));
  }
  function a(l) {
    const c = l, u = Zr.getState(e.state);
    let d;
    if (u != null) d = e.state.doc.resolve(u);
    else if (m0(e, c.target) != r && (d = Gu(e, t), !d))
      return s();
    d && i(d, c);
  }
  e.root.addEventListener("mouseup", s), e.root.addEventListener("dragstart", s), e.root.addEventListener("mousemove", a);
}
function OE(e, t, n) {
  if (!(e.state.selection instanceof pe)) return null;
  const { $head: r } = e.state.selection;
  for (let o = r.depth - 1; o >= 0; o--) {
    const i = r.node(o);
    if ((n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i.childCount)) return null;
    if (i.type.spec.tableRole == "cell" || i.type.spec.tableRole == "header_cell") {
      const s = r.before(o), a = t == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return e.endOfTextblock(a) ? s : null;
    }
  }
  return null;
}
function m0(e, t) {
  for (; t && t != e.dom; t = t.parentNode) if (t.nodeName == "TD" || t.nodeName == "TH") return t;
  return null;
}
function Gu(e, t) {
  const n = e.posAtCoords({
    left: t.clientX,
    top: t.clientY
  });
  if (!n) return null;
  let { inside: r, pos: o } = n;
  return r >= 0 && Uo(e.state.doc.resolve(r)) || Uo(e.state.doc.resolve(o));
}
var DE = class {
  constructor(e, t) {
    this.node = e, this.defaultCellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty("--default-cell-min-width", `${t}px`), this.colgroup = this.table.appendChild(document.createElement("colgroup")), ff(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, ff(e, this.colgroup, this.table, this.defaultCellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function ff(e, t, n, r, o, i) {
  let s = 0, a = !0, l = t.firstChild;
  const c = e.firstChild;
  if (c) {
    for (let d = 0, f = 0; d < c.childCount; d++) {
      const { colspan: h, colwidth: p } = c.child(d).attrs;
      for (let m = 0; m < h; m++, f++) {
        const b = o == f ? i : p && p[m], y = b ? b + "px" : "";
        if (s += b || r, b || (a = !1), l)
          l.style.width != y && (l.style.width = y), l = l.nextSibling;
        else {
          const k = document.createElement("col");
          k.style.width = y, t.appendChild(k);
        }
      }
    }
    for (; l; ) {
      var u;
      const d = l.nextSibling;
      (u = l.parentNode) === null || u === void 0 || u.removeChild(l), l = d;
    }
    a ? (n.style.width = s + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = s + "px");
  }
}
const bn = new we("tableColumnResizing");
function UA({ handleWidth: e = 5, cellMinWidth: t = 25, defaultCellMinWidth: n = 100, View: r = DE, lastColumnResizable: o = !0 } = {}) {
  const i = new me({
    key: bn,
    state: {
      init(s, a) {
        var l;
        const c = (l = i.spec) === null || l === void 0 || (l = l.props) === null || l === void 0 ? void 0 : l.nodeViews, u = $t(a.schema).table.name;
        return r && c && (c[u] = (d, f) => new r(d, n, f)), new jA(-1, !1);
      },
      apply(s, a) {
        return a.apply(s);
      }
    },
    props: {
      attributes: (s) => {
        const a = bn.getState(s);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, a) => {
          VA(s, a, e, o);
        },
        mouseleave: (s) => {
          zA(s);
        },
        mousedown: (s, a) => {
          qA(s, a, t, n);
        }
      },
      decorations: (s) => {
        const a = bn.getState(s);
        if (a && a.activeHandle > -1) return QA(s, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return i;
}
var jA = class dl {
  constructor(t, n) {
    this.activeHandle = t, this.dragging = n;
  }
  apply(t) {
    const n = this, r = t.getMeta(bn);
    if (r && r.setHandle != null) return new dl(r.setHandle, !1);
    if (r && r.setDragging !== void 0) return new dl(n.activeHandle, r.setDragging);
    if (n.activeHandle > -1 && t.docChanged) {
      let o = t.mapping.map(n.activeHandle, -1);
      return uf(t.doc.resolve(o)) || (o = -1), new dl(o, n.dragging);
    }
    return n;
  }
};
function VA(e, t, n, r) {
  if (!e.editable) return;
  const o = bn.getState(e.state);
  if (o && !o.dragging) {
    const i = GA(t.target);
    let s = -1;
    if (i) {
      const { left: a, right: l } = i.getBoundingClientRect();
      t.clientX - a <= n ? s = g0(e, t, "left", n) : l - t.clientX <= n && (s = g0(e, t, "right", n));
    }
    if (s != o.activeHandle) {
      if (!r && s !== -1) {
        const a = e.state.doc.resolve(s), l = a.node(-1), c = Je.get(l), u = a.start(-1);
        if (c.colCount(a.pos - u) + a.nodeAfter.attrs.colspan - 1 == c.width - 1) return;
      }
      RE(e, s);
    }
  }
}
function zA(e) {
  if (!e.editable) return;
  const t = bn.getState(e.state);
  t && t.activeHandle > -1 && !t.dragging && RE(e, -1);
}
function qA(e, t, n, r) {
  var o;
  if (!e.editable) return !1;
  const i = (o = e.dom.ownerDocument.defaultView) !== null && o !== void 0 ? o : window, s = bn.getState(e.state);
  if (!s || s.activeHandle == -1 || s.dragging) return !1;
  const a = e.state.doc.nodeAt(s.activeHandle), l = WA(e, s.activeHandle, a.attrs);
  e.dispatch(e.state.tr.setMeta(bn, { setDragging: {
    startX: t.clientX,
    startWidth: l
  } }));
  function c(d) {
    i.removeEventListener("mouseup", c), i.removeEventListener("mousemove", u);
    const f = bn.getState(e.state);
    f != null && f.dragging && (YA(e, f.activeHandle, b0(f.dragging, d, n)), e.dispatch(e.state.tr.setMeta(bn, { setDragging: null })));
  }
  function u(d) {
    if (!d.which) return c(d);
    const f = bn.getState(e.state);
    if (f && f.dragging) {
      const h = b0(f.dragging, d, n);
      y0(e, f.activeHandle, h, r);
    }
  }
  return y0(e, s.activeHandle, l, r), i.addEventListener("mouseup", c), i.addEventListener("mousemove", u), t.preventDefault(), !0;
}
function WA(e, t, { colspan: n, colwidth: r }) {
  const o = r && r[r.length - 1];
  if (o) return o;
  const i = e.domAtPos(t);
  let s = i.node.childNodes[i.offset].offsetWidth, a = n;
  if (r)
    for (let l = 0; l < n; l++) r[l] && (s -= r[l], a--);
  return s / a;
}
function GA(e) {
  for (; e && e.nodeName != "TD" && e.nodeName != "TH"; ) e = e.classList && e.classList.contains("ProseMirror") ? null : e.parentNode;
  return e;
}
function g0(e, t, n, r) {
  const o = n == "right" ? -r : r, i = e.posAtCoords({
    left: t.clientX + o,
    top: t.clientY
  });
  if (!i) return -1;
  const { pos: s } = i, a = Uo(e.state.doc.resolve(s));
  if (!a) return -1;
  if (n == "right") return a.pos;
  const l = Je.get(a.node(-1)), c = a.start(-1), u = l.map.indexOf(a.pos - c);
  return u % l.width == 0 ? -1 : c + l.map[u - 1];
}
function b0(e, t, n) {
  const r = t.clientX - e.startX;
  return Math.max(n, e.startWidth + r);
}
function RE(e, t) {
  e.dispatch(e.state.tr.setMeta(bn, { setHandle: t }));
}
function YA(e, t, n) {
  const r = e.state.doc.resolve(t), o = r.node(-1), i = Je.get(o), s = r.start(-1), a = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1, l = e.state.tr;
  for (let c = 0; c < i.height; c++) {
    const u = c * i.width + a;
    if (c && i.map[u] == i.map[u - i.width]) continue;
    const d = i.map[u], f = o.nodeAt(d).attrs, h = f.colspan == 1 ? 0 : a - i.colCount(d);
    if (f.colwidth && f.colwidth[h] == n) continue;
    const p = f.colwidth ? f.colwidth.slice() : KA(f.colspan);
    p[h] = n, l.setNodeMarkup(s + d, null, {
      ...f,
      colwidth: p
    });
  }
  l.docChanged && e.dispatch(l);
}
function y0(e, t, n, r) {
  const o = e.state.doc.resolve(t), i = o.node(-1), s = o.start(-1), a = Je.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
  let l = e.domAtPos(o.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; ) l = l.parentNode;
  l && ff(i, l.firstChild, l, r, a, n);
}
function KA(e) {
  return Array(e).fill(0);
}
function QA(e, t) {
  const n = [], r = e.doc.resolve(t), o = r.node(-1);
  if (!o) return kt.empty;
  const i = Je.get(o), s = r.start(-1), a = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < i.height; c++) {
    const u = a + c * i.width;
    if ((a == i.width - 1 || i.map[u] != i.map[u + 1]) && (c == 0 || i.map[u] != i.map[u - i.width])) {
      var l;
      const d = i.map[u], f = s + d + o.nodeAt(d).nodeSize - 1, h = document.createElement("div");
      h.className = "column-resize-handle", !((l = bn.getState(e)) === null || l === void 0) && l.dragging && n.push(Lt.node(s + d, s + d + o.nodeAt(d).nodeSize, { class: "column-resize-dragging" })), n.push(Lt.widget(f, h));
    }
  }
  return kt.create(e.doc, n);
}
function ZA({ allowTableNodeSelection: e = !1 } = {}) {
  return new me({
    key: Zr,
    state: {
      init() {
        return null;
      },
      apply(t, n) {
        const r = t.getMeta(Zr);
        if (r != null) return r == -1 ? null : r;
        if (n == null || !t.docChanged) return n;
        const { deleted: o, pos: i } = t.mapping.mapResult(n);
        return o ? null : i;
      }
    },
    props: {
      decorations: dA,
      handleDOMEvents: { mousedown: FA },
      createSelectionBetween(t) {
        return Zr.getState(t.state) != null ? t.state.selection : null;
      },
      handleTripleClick: $A,
      handleKeyDown: BA,
      handlePaste: HA
    },
    appendTransaction(t, n, r) {
      return pA(r, gA(r, n), e);
    }
  });
}
const On = () => /* @__PURE__ */ new Map(), hf = (e) => {
  const t = On();
  return e.forEach((n, r) => {
    t.set(r, n);
  }), t;
}, Tr = (e, t, n) => {
  let r = e.get(t);
  return r === void 0 && e.set(t, r = n()), r;
}, XA = (e, t) => {
  const n = [];
  for (const [r, o] of e)
    n.push(t(o, r));
  return n;
}, JA = (e, t) => {
  for (const [n, r] of e)
    if (t(r, n))
      return !0;
  return !1;
}, Vo = () => /* @__PURE__ */ new Set(), Yu = (e) => e[e.length - 1], e3 = (e, t) => {
  for (let n = 0; n < t.length; n++)
    e.push(t[n]);
}, lo = Array.from, zh = (e, t) => {
  for (let n = 0; n < e.length; n++)
    if (!t(e[n], n, e))
      return !1;
  return !0;
}, qh = (e, t) => {
  for (let n = 0; n < e.length; n++)
    if (t(e[n], n, e))
      return !0;
  return !1;
}, t3 = (e, t) => {
  const n = new Array(e);
  for (let r = 0; r < e; r++)
    n[r] = t(r, n);
  return n;
}, _i = Array.isArray;
class PE {
  constructor() {
    this._observers = On();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(t, n) {
    return Tr(
      this._observers,
      /** @type {string} */
      t,
      Vo
    ).add(n), n;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(t, n) {
    const r = (...o) => {
      this.off(
        t,
        /** @type {any} */
        r
      ), n(...o);
    };
    this.on(
      t,
      /** @type {any} */
      r
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(t, n) {
    const r = this._observers.get(t);
    r !== void 0 && (r.delete(n), r.size === 0 && this._observers.delete(t));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(t, n) {
    return lo((this._observers.get(t) || On()).values()).forEach((r) => r(...n));
  }
  destroy() {
    this._observers = On();
  }
}
const Yn = Math.floor, fl = Math.abs, Br = (e, t) => e < t ? e : t, Kn = (e, t) => e > t ? e : t, BE = (e) => e !== 0 ? e < 0 : 1 / e < 0, E0 = 1, k0 = 2, Ku = 4, Qu = 8, Rs = 32, $r = 64, Wt = 128, n3 = 1 << 29, Fc = 31, pf = 63, Oo = 127, r3 = 2147483647, Bl = Number.MAX_SAFE_INTEGER, C0 = Number.MIN_SAFE_INTEGER, o3 = Number.isInteger || ((e) => typeof e == "number" && isFinite(e) && Yn(e) === e), $E = String.fromCharCode, i3 = (e) => e.toLowerCase(), s3 = /^\s*/g, a3 = (e) => e.replace(s3, ""), l3 = /([A-Z])/g, T0 = (e, t) => a3(e.replace(l3, (n) => `${t}${i3(n)}`)), c3 = (e) => {
  const t = unescape(encodeURIComponent(e)), n = t.length, r = new Uint8Array(n);
  for (let o = 0; o < n; o++)
    r[o] = /** @type {number} */
    t.codePointAt(o);
  return r;
}, Ps = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), u3 = (e) => Ps.encode(e), d3 = Ps ? u3 : c3;
let bs = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
bs && bs.decode(new Uint8Array()).length === 1 && (bs = null);
const f3 = (e, t) => t3(t, () => e).join("");
class ia {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const sa = () => new ia(), h3 = (e) => {
  const t = sa();
  return e(t), Vn(t);
}, p3 = (e) => {
  let t = e.cpos;
  for (let n = 0; n < e.bufs.length; n++)
    t += e.bufs[n].length;
  return t;
}, Vn = (e) => {
  const t = new Uint8Array(p3(e));
  let n = 0;
  for (let r = 0; r < e.bufs.length; r++) {
    const o = e.bufs[r];
    t.set(o, n), n += o.length;
  }
  return t.set(new Uint8Array(e.cbuf.buffer, 0, e.cpos), n), t;
}, m3 = (e, t) => {
  const n = e.cbuf.length;
  n - e.cpos < t && (e.bufs.push(new Uint8Array(e.cbuf.buffer, 0, e.cpos)), e.cbuf = new Uint8Array(Kn(n, t) * 2), e.cpos = 0);
}, xt = (e, t) => {
  const n = e.cbuf.length;
  e.cpos === n && (e.bufs.push(e.cbuf), e.cbuf = new Uint8Array(n * 2), e.cpos = 0), e.cbuf[e.cpos++] = t;
}, mf = xt, Le = (e, t) => {
  for (; t > Oo; )
    xt(e, Wt | Oo & t), t = Yn(t / 128);
  xt(e, Oo & t);
}, Wh = (e, t) => {
  const n = BE(t);
  for (n && (t = -t), xt(e, (t > pf ? Wt : 0) | (n ? $r : 0) | pf & t), t = Yn(t / 64); t > 0; )
    xt(e, (t > Oo ? Wt : 0) | Oo & t), t = Yn(t / 128);
}, gf = new Uint8Array(3e4), g3 = gf.length / 3, b3 = (e, t) => {
  if (t.length < g3) {
    const n = Ps.encodeInto(t, gf).written || 0;
    Le(e, n);
    for (let r = 0; r < n; r++)
      xt(e, gf[r]);
  } else
    mn(e, d3(t));
}, y3 = (e, t) => {
  const n = unescape(encodeURIComponent(t)), r = n.length;
  Le(e, r);
  for (let o = 0; o < r; o++)
    xt(
      e,
      /** @type {number} */
      n.codePointAt(o)
    );
}, mi = Ps && /** @type {any} */
Ps.encodeInto ? b3 : y3, Uc = (e, t) => {
  const n = e.cbuf.length, r = e.cpos, o = Br(n - r, t.length), i = t.length - o;
  e.cbuf.set(t.subarray(0, o), r), e.cpos += o, i > 0 && (e.bufs.push(e.cbuf), e.cbuf = new Uint8Array(Kn(n * 2, i)), e.cbuf.set(t.subarray(o)), e.cpos = i);
}, mn = (e, t) => {
  Le(e, t.byteLength), Uc(e, t);
}, Gh = (e, t) => {
  m3(e, t);
  const n = new DataView(e.cbuf.buffer, e.cpos, t);
  return e.cpos += t, n;
}, E3 = (e, t) => Gh(e, 4).setFloat32(0, t, !1), k3 = (e, t) => Gh(e, 8).setFloat64(0, t, !1), C3 = (e, t) => (
  /** @type {any} */
  Gh(e, 8).setBigInt64(0, t, !1)
), x0 = new DataView(new ArrayBuffer(4)), T3 = (e) => (x0.setFloat32(0, e), x0.getFloat32(0) === e), Ai = (e, t) => {
  switch (typeof t) {
    case "string":
      xt(e, 119), mi(e, t);
      break;
    case "number":
      o3(t) && fl(t) <= r3 ? (xt(e, 125), Wh(e, t)) : T3(t) ? (xt(e, 124), E3(e, t)) : (xt(e, 123), k3(e, t));
      break;
    case "bigint":
      xt(e, 122), C3(e, t);
      break;
    case "object":
      if (t === null)
        xt(e, 126);
      else if (_i(t)) {
        xt(e, 117), Le(e, t.length);
        for (let n = 0; n < t.length; n++)
          Ai(e, t[n]);
      } else if (t instanceof Uint8Array)
        xt(e, 116), mn(e, t);
      else {
        xt(e, 118);
        const n = Object.keys(t);
        Le(e, n.length);
        for (let r = 0; r < n.length; r++) {
          const o = n[r];
          mi(e, o), Ai(e, t[o]);
        }
      }
      break;
    case "boolean":
      xt(e, t ? 120 : 121);
      break;
    default:
      xt(e, 127);
  }
};
class w0 extends ia {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(t) {
    super(), this.w = t, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(t) {
    this.s === t ? this.count++ : (this.count > 0 && Le(this, this.count - 1), this.count = 1, this.w(this, t), this.s = t);
  }
}
const v0 = (e) => {
  e.count > 0 && (Wh(e.encoder, e.count === 1 ? e.s : -e.s), e.count > 1 && Le(e.encoder, e.count - 2));
};
class hl {
  constructor() {
    this.encoder = new ia(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(t) {
    this.s === t ? this.count++ : (v0(this), this.count = 1, this.s = t);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return v0(this), Vn(this.encoder);
  }
}
const S0 = (e) => {
  if (e.count > 0) {
    const t = e.diff * 2 + (e.count === 1 ? 0 : 1);
    Wh(e.encoder, t), e.count > 1 && Le(e.encoder, e.count - 2);
  }
};
class Zu {
  constructor() {
    this.encoder = new ia(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(t) {
    this.diff === t - this.s ? (this.s = t, this.count++) : (S0(this), this.count = 1, this.diff = t - this.s, this.s = t);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return S0(this), Vn(this.encoder);
  }
}
class x3 {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new hl();
  }
  /**
   * @param {string} string
   */
  write(t) {
    this.s += t, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(t.length);
  }
  toUint8Array() {
    const t = new ia();
    return this.sarr.push(this.s), this.s = "", mi(t, this.sarr.join("")), Uc(t, this.lensE.toUint8Array()), Vn(t);
  }
}
const yr = (e) => new Error(e), Dn = () => {
  throw yr("Method unimplemented");
}, Gt = () => {
  throw yr("Unexpected case");
}, HE = yr("Unexpected end of array"), FE = yr("Integer out of Range");
class jc {
  /**
   * @param {Uint8Array<Buf>} uint8Array Binary data to decode
   */
  constructor(t) {
    this.arr = t, this.pos = 0;
  }
}
const Fi = (e) => new jc(e), w3 = (e) => e.pos !== e.arr.length, v3 = (e, t) => {
  const n = new Uint8Array(e.arr.buffer, e.pos + e.arr.byteOffset, t);
  return e.pos += t, n;
}, gn = (e) => v3(e, _e(e)), Ii = (e) => e.arr[e.pos++], _e = (e) => {
  let t = 0, n = 1;
  const r = e.arr.length;
  for (; e.pos < r; ) {
    const o = e.arr[e.pos++];
    if (t = t + (o & Oo) * n, n *= 128, o < Wt)
      return t;
    if (t > Bl)
      throw FE;
  }
  throw HE;
}, Yh = (e) => {
  let t = e.arr[e.pos++], n = t & pf, r = 64;
  const o = (t & $r) > 0 ? -1 : 1;
  if (!(t & Wt))
    return o * n;
  const i = e.arr.length;
  for (; e.pos < i; ) {
    if (t = e.arr[e.pos++], n = n + (t & Oo) * r, r *= 128, t < Wt)
      return o * n;
    if (n > Bl)
      throw FE;
  }
  throw HE;
}, S3 = (e) => {
  let t = _e(e);
  if (t === 0)
    return "";
  {
    let n = String.fromCodePoint(Ii(e));
    if (--t < 100)
      for (; t--; )
        n += String.fromCodePoint(Ii(e));
    else
      for (; t > 0; ) {
        const r = t < 1e4 ? t : 1e4, o = e.arr.subarray(e.pos, e.pos + r);
        e.pos += r, n += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          o
        ), t -= r;
      }
    return decodeURIComponent(escape(n));
  }
}, _3 = (e) => (
  /** @type any */
  bs.decode(gn(e))
), gi = bs ? _3 : S3, Kh = (e, t) => {
  const n = new DataView(e.arr.buffer, e.arr.byteOffset + e.pos, t);
  return e.pos += t, n;
}, A3 = (e) => Kh(e, 4).getFloat32(0, !1), I3 = (e) => Kh(e, 8).getFloat64(0, !1), N3 = (e) => (
  /** @type {any} */
  Kh(e, 8).getBigInt64(0, !1)
), M3 = [
  (e) => {
  },
  // CASE 127: undefined
  (e) => null,
  // CASE 126: null
  Yh,
  // CASE 125: integer
  A3,
  // CASE 124: float32
  I3,
  // CASE 123: float64
  N3,
  // CASE 122: bigint
  (e) => !1,
  // CASE 121: boolean (false)
  (e) => !0,
  // CASE 120: boolean (true)
  gi,
  // CASE 119: string
  (e) => {
    const t = _e(e), n = {};
    for (let r = 0; r < t; r++) {
      const o = gi(e);
      n[o] = Bs(e);
    }
    return n;
  },
  (e) => {
    const t = _e(e), n = [];
    for (let r = 0; r < t; r++)
      n.push(Bs(e));
    return n;
  },
  gn
  // CASE 116: Uint8Array
], Bs = (e) => M3[127 - Ii(e)](e);
class _0 extends jc {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(t, n) {
    super(t), this.reader = n, this.s = null, this.count = 0;
  }
  read() {
    return this.count === 0 && (this.s = this.reader(this), w3(this) ? this.count = _e(this) + 1 : this.count = -1), this.count--, /** @type {T} */
    this.s;
  }
}
class pl extends jc {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(t) {
    super(t), this.s = 0, this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = Yh(this);
      const t = BE(this.s);
      this.count = 1, t && (this.s = -this.s, this.count = _e(this) + 2);
    }
    return this.count--, /** @type {number} */
    this.s;
  }
}
class Xu extends jc {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(t) {
    super(t), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const t = Yh(this), n = t & 1;
      this.diff = Yn(t / 2), this.count = 1, n && (this.count = _e(this) + 2);
    }
    return this.s += this.diff, this.count--, this.s;
  }
}
class L3 {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(t) {
    this.decoder = new pl(t), this.str = gi(this.decoder), this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const t = this.spos + this.decoder.read(), n = this.str.slice(this.spos, t);
    return this.spos = t, n;
  }
}
const O3 = crypto.getRandomValues.bind(crypto), D3 = Math.random, UE = () => O3(new Uint32Array(1))[0], R3 = (e) => e[Yn(D3() * e.length)], P3 = "10000000-1000-4000-8000" + -1e11, B3 = () => P3.replace(
  /[018]/g,
  /** @param {number} c */
  (e) => (e ^ UE() & 15 >> e / 4).toString(16)
), $3 = Date.now, A0 = (e) => (
  /** @type {Promise<T>} */
  new Promise(e)
);
Promise.all.bind(Promise);
const I0 = (e) => e === void 0 ? null : e;
class H3 {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(t, n) {
    this.map.set(t, n);
  }
  /**
   * @param {string} key
   */
  getItem(t) {
    return this.map.get(t);
  }
}
let jE = new H3(), F3 = !0;
try {
  typeof localStorage < "u" && localStorage && (jE = localStorage, F3 = !1);
} catch {
}
const U3 = jE, $s = Symbol("Equality"), VE = (e, t) => {
  var n;
  return e === t || !!((n = e == null ? void 0 : e[$s]) != null && n.call(e, t)) || !1;
}, j3 = (e) => typeof e == "object", V3 = Object.assign, zE = Object.keys, z3 = (e, t) => {
  for (const n in e)
    t(e[n], n);
}, $l = (e) => zE(e).length, q3 = (e) => {
  for (const t in e)
    return !1;
  return !0;
}, Ui = (e, t) => {
  for (const n in e)
    if (!t(e[n], n))
      return !1;
  return !0;
}, Qh = (e, t) => Object.prototype.hasOwnProperty.call(e, t), W3 = (e, t) => e === t || $l(e) === $l(t) && Ui(e, (n, r) => (n !== void 0 || Qh(t, r)) && VE(t[r], n)), G3 = Object.freeze, qE = (e) => {
  for (const t in e) {
    const n = e[t];
    (typeof n == "object" || typeof n == "function") && qE(e[t]);
  }
  return G3(e);
}, Zh = (e, t, n = 0) => {
  try {
    for (; n < e.length; n++)
      e[n](...t);
  } finally {
    n < e.length && Zh(e, t, n + 1);
  }
}, Y3 = (e) => e, ml = (e, t) => {
  if (e === t)
    return !0;
  if (e == null || t == null || e.constructor !== t.constructor && (e.constructor || Object) !== (t.constructor || Object))
    return !1;
  if (e[$s] != null)
    return e[$s](t);
  switch (e.constructor) {
    case ArrayBuffer:
      e = new Uint8Array(e), t = new Uint8Array(t);
    case Uint8Array: {
      if (e.byteLength !== t.byteLength)
        return !1;
      for (let n = 0; n < e.length; n++)
        if (e[n] !== t[n])
          return !1;
      break;
    }
    case Set: {
      if (e.size !== t.size)
        return !1;
      for (const n of e)
        if (!t.has(n))
          return !1;
      break;
    }
    case Map: {
      if (e.size !== t.size)
        return !1;
      for (const n of e.keys())
        if (!t.has(n) || !ml(e.get(n), t.get(n)))
          return !1;
      break;
    }
    case void 0:
    case Object:
      if ($l(e) !== $l(t))
        return !1;
      for (const n in e)
        if (!Qh(e, n) || !ml(e[n], t[n]))
          return !1;
      break;
    case Array:
      if (e.length !== t.length)
        return !1;
      for (let n = 0; n < e.length; n++)
        if (!ml(e[n], t[n]))
          return !1;
      break;
    default:
      return !1;
  }
  return !0;
}, K3 = (e, t) => t.includes(e), Ni = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]", WE = typeof window < "u" && typeof document < "u" && !Ni;
let lr;
const Q3 = () => {
  if (lr === void 0)
    if (Ni) {
      lr = On();
      const e = process.argv;
      let t = null;
      for (let n = 0; n < e.length; n++) {
        const r = e[n];
        r[0] === "-" ? (t !== null && lr.set(t, ""), t = r) : t !== null && (lr.set(t, r), t = null);
      }
      t !== null && lr.set(t, "");
    } else typeof location == "object" ? (lr = On(), (location.search || "?").slice(1).split("&").forEach((e) => {
      if (e.length !== 0) {
        const [t, n] = e.split("=");
        lr.set(`--${T0(t, "-")}`, n), lr.set(`-${T0(t, "-")}`, n);
      }
    })) : lr = On();
  return lr;
}, bf = (e) => Q3().has(e), Hl = (e) => I0(Ni ? process.env[e.toUpperCase().replaceAll("-", "_")] : U3.getItem(e)), GE = (e) => bf("--" + e) || Hl(e) !== null, Z3 = GE("production"), X3 = Ni && K3(process.env.FORCE_COLOR, ["true", "1", "2"]), J3 = X3 || !bf("--no-colors") && // @todo deprecate --no-colors
!GE("no-color") && (!Ni || process.stdout.isTTY) && (!Ni || bf("--color") || Hl("COLORTERM") !== null || (Hl("TERM") || "").includes("color")), eI = (e) => new Uint8Array(e), tI = (e) => {
  let t = "";
  for (let n = 0; n < e.byteLength; n++)
    t += $E(e[n]);
  return btoa(t);
}, nI = (e) => Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("base64"), rI = WE ? tI : nI, oI = (e) => {
  const t = eI(e.byteLength);
  return t.set(e), t;
}, iI = (e) => h3((t) => Ai(t, e));
class sI {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(t, n) {
    this.left = t, this.right = n;
  }
}
const Nr = (e, t) => new sI(e, t), N0 = (e) => e.next() >= 0.5, Ju = (e, t, n) => Yn(e.next() * (n + 1 - t) + t), YE = (e, t, n) => Yn(e.next() * (n + 1 - t) + t), Xh = (e, t, n) => YE(e, t, n), aI = (e) => $E(Xh(e, 97, 122)), lI = (e, t = 0, n = 20) => {
  const r = Xh(e, t, n);
  let o = "";
  for (let i = 0; i < r; i++)
    o += aI(e);
  return o;
}, ed = (e, t) => t[Xh(e, 0, t.length - 1)], cI = Symbol("0schema");
class uI {
  constructor() {
    this._rerrs = [];
  }
  /**
   * @param {string?} path
   * @param {string} expected
   * @param {string} has
   * @param {string?} message
   */
  extend(t, n, r, o = null) {
    this._rerrs.push({ path: t, expected: n, has: r, message: o });
  }
  toString() {
    const t = [];
    for (let n = this._rerrs.length - 1; n > 0; n--) {
      const r = this._rerrs[n];
      t.push(f3(" ", (this._rerrs.length - n) * 2) + `${r.path != null ? `[${r.path}] ` : ""}${r.has} doesn't match ${r.expected}. ${r.message}`);
    }
    return t.join(`
`);
  }
}
const yf = (e, t) => e === t ? !0 : e == null || t == null || e.constructor !== t.constructor ? !1 : e[$s] ? VE(e, t) : _i(e) ? zh(
  e,
  (n) => qh(t, (r) => yf(n, r))
) : j3(e) ? Ui(
  e,
  (n, r) => yf(n, t[r])
) : !1;
var tf;
let Kt = (tf = class {
  /**
   * @param {Schema<any>} other
   */
  extends(t) {
    let [n, r] = [
      /** @type {any} */
      this.shape,
      /** @type {any} */
      t.shape
    ];
    return (
      /** @type {typeof Schema<any>} */
      this.constructor._dilutes && ([r, n] = [n, r]), yf(n, r)
    );
  }
  /**
   * Overwrite this when necessary. By default, we only check the `shape` property which every shape
   * should have.
   * @param {Schema<any>} other
   */
  equals(t) {
    return this.constructor === t.constructor && ml(this.shape, t.shape);
  }
  [cI]() {
    return !0;
  }
  /**
   * @param {object} other
   */
  [$s](t) {
    return this.equals(
      /** @type {any} */
      t
    );
  }
  /**
   * Use `schema.validate(obj)` with a typed parameter that is already of typed to be an instance of
   * Schema. Validate will check the structure of the parameter and return true iff the instance
   * really is an instance of Schema.
   *
   * @param {T} o
   * @return {boolean}
   */
  validate(t) {
    return this.check(t);
  }
  /* c8 ignore start */
  /**
   * Similar to validate, but this method accepts untyped parameters.
   *
   * @param {any} _o
   * @param {ValidationError} [_err]
   * @return {_o is T}
   */
  check(t, n) {
    Dn();
  }
  /* c8 ignore stop */
  /**
   * @type {Schema<T?>}
   */
  get nullable() {
    return ji(this, Gc);
  }
  /**
   * @type {$Optional<Schema<T>>}
   */
  get optional() {
    return new ZE(
      /** @type {Schema<T>} */
      this
    );
  }
  /**
   * Cast a variable to a specific type. Returns the casted value, or throws an exception otherwise.
   * Use this if you know that the type is of a specific type and you just want to convince the type
   * system.
   *
   * **Do not rely on these error messages!**
   * Performs an assertion check only if not in a production environment.
   *
   * @template OO
   * @param {OO} o
   * @return {Extract<OO, T> extends never ? T : (OO extends Array<never> ? T : Extract<OO,T>)}
   */
  cast(t) {
    return M0(t, this), /** @type {any} */
    t;
  }
  /**
   * EXPECTO PATRONUM!! 
   * This function protects against type errors. Though it may not work in the real world.
   *
   * "After all this time?"
   * "Always." - Snape, talking about type safety
   *
   * Ensures that a variable is a a specific type. Returns the value, or throws an exception if the assertion check failed.
   * Use this if you know that the type is of a specific type and you just want to convince the type
   * system.
   *
   * Can be useful when defining lambdas: `s.lambda(s.$number, s.$void).expect((n) => n + 1)`
   *
   * **Do not rely on these error messages!**
   * Performs an assertion check if not in a production environment.
   *
   * @param {T} o
   * @return {o extends T ? T : never}
   */
  expect(t) {
    return M0(t, this), t;
  }
}, // this.shape must not be defined on Schema. Otherwise typecheck on metatypes (e.g. $$object) won't work as expected anymore
/**
 * If true, the more things are added to the shape the more objects this schema will accept (e.g.
 * union). By default, the more objects are added, the the fewer objects this schema will accept.
 * @protected
 */
Ir(tf, "_dilutes", !1), tf);
class Jh extends Kt {
  /**
   * @param {C} c
   * @param {((o:Instance<C>)=>boolean)|null} check
   */
  constructor(t, n) {
    super(), this.shape = t, this._c = n;
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is C extends ((...args:any[]) => infer T) ? T : (C extends (new (...args:any[]) => any) ? InstanceType<C> : never)} o
   */
  check(t, n = void 0) {
    const r = (t == null ? void 0 : t.constructor) === this.shape && (this._c == null || this._c(t));
    return !r && (n == null || n.extend(null, this.shape.name, t == null ? void 0 : t.constructor.name, (t == null ? void 0 : t.constructor) !== this.shape ? "Constructor match failed" : "Check failed")), r;
  }
}
const Et = (e, t = null) => new Jh(e, t);
Et(Jh);
class ep extends Kt {
  /**
   * @param {(o:any) => boolean} check
   */
  constructor(t) {
    super(), this.shape = t;
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is any}
   */
  check(t, n) {
    const r = this.shape(t);
    return !r && (n == null || n.extend(null, "custom prop", t == null ? void 0 : t.constructor.name, "failed to check custom prop")), r;
  }
}
const At = (e) => new ep(e);
Et(ep);
class Vc extends Kt {
  /**
   * @param {Array<T>} literals
   */
  constructor(t) {
    super(), this.shape = t;
  }
  /**
   *
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is T}
   */
  check(t, n) {
    const r = this.shape.some((o) => o === t);
    return !r && (n == null || n.extend(null, this.shape.join(" | "), t.toString())), r;
  }
}
const zc = (...e) => new Vc(e), KE = Et(Vc), dI = (
  /** @type {any} */
  RegExp.escape || /** @type {(str:string) => string} */
  ((e) => e.replace(/[().|&,$^[\]]/g, (t) => "\\" + t))
), QE = (e) => {
  if (Mi.check(e))
    return [dI(e)];
  if (KE.check(e))
    return (
      /** @type {Array<string|number>} */
      e.shape.map((t) => t + "")
    );
  if (sk.check(e))
    return ["[+-]?\\d+.?\\d*"];
  if (ak.check(e))
    return [".*"];
  if (Ul.check(e))
    return e.shape.map(QE).flat(1);
  Gt();
};
class fI extends Kt {
  /**
   * @param {T} shape
   */
  constructor(t) {
    super(), this.shape = t, this._r = new RegExp("^" + t.map(QE).map((n) => `(${n.join("|")})`).join("") + "$");
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is CastStringTemplateArgsToTemplate<T>}
   */
  check(t, n) {
    const r = this._r.exec(t) != null;
    return !r && (n == null || n.extend(null, this._r.toString(), t.toString(), "String doesn't match string template.")), r;
  }
}
Et(fI);
const hI = Symbol("optional");
class ZE extends Kt {
  /**
   * @param {S} shape
   */
  constructor(t) {
    super(), this.shape = t;
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is (Unwrap<S>|undefined)}
   */
  check(t, n) {
    const r = t === void 0 || this.shape.check(t);
    return !r && (n == null || n.extend(null, "undefined (optional)", "()")), r;
  }
  get [hI]() {
    return !0;
  }
}
const pI = Et(ZE);
class mI extends Kt {
  /**
   * @param {any} _o
   * @param {ValidationError} [err]
   * @return {_o is never}
   */
  check(t, n) {
    return n == null || n.extend(null, "never", typeof t), !1;
  }
}
Et(mI);
const wc = class wc extends Kt {
  /**
   * @param {S} shape
   * @param {boolean} partial
   */
  constructor(t, n = !1) {
    super(), this.shape = t, this._isPartial = n;
  }
  /**
   * @type {Schema<Partial<$ObjectToType<S>>>}
   */
  get partial() {
    return new wc(this.shape, !0);
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is $ObjectToType<S>}
   */
  check(t, n) {
    return t == null ? (n == null || n.extend(null, "object", "null"), !1) : Ui(this.shape, (r, o) => {
      const i = this._isPartial && !Qh(t, o) || r.check(t[o], n);
      return !i && (n == null || n.extend(o.toString(), r.toString(), typeof t[o], "Object property does not match")), i;
    });
  }
};
Ir(wc, "_dilutes", !0);
let Fl = wc;
const gI = (e) => (
  /** @type {any} */
  new Fl(e)
), bI = Et(Fl), yI = At((e) => e != null && (e.constructor === Object || e.constructor == null));
class XE extends Kt {
  /**
   * @param {Keys} keys
   * @param {Values} values
   */
  constructor(t, n) {
    super(), this.shape = {
      keys: t,
      values: n
    };
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is { [key in Unwrap<Keys>]: Unwrap<Values> }}
   */
  check(t, n) {
    return t != null && Ui(t, (r, o) => {
      const i = this.shape.keys.check(o, n);
      return !i && (n == null || n.extend(o + "", "Record", typeof t, i ? "Key doesn't match schema" : "Value doesn't match value")), i && this.shape.values.check(r, n);
    });
  }
}
const JE = (e, t) => new XE(e, t), EI = Et(XE);
class ek extends Kt {
  /**
   * @param {S} shape
   */
  constructor(t) {
    super(), this.shape = t;
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is { [K in keyof S]: S[K] extends Schema<infer Type> ? Type : never }}
   */
  check(t, n) {
    return t != null && Ui(this.shape, (r, o) => {
      const i = (
        /** @type {Schema<any>} */
        r.check(t[o], n)
      );
      return !i && (n == null || n.extend(o.toString(), "Tuple", typeof r)), i;
    });
  }
}
const kI = (...e) => new ek(e);
Et(ek);
class tk extends Kt {
  /**
   * @param {Array<S>} v
   */
  constructor(t) {
    super(), this.shape = t.length === 1 ? t[0] : new qc(t);
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is Array<S extends Schema<infer T> ? T : never>} o
   */
  check(t, n) {
    const r = _i(t) && zh(t, (o) => this.shape.check(o));
    return !r && (n == null || n.extend(null, "Array", "")), r;
  }
}
const nk = (...e) => new tk(e), CI = Et(tk), TI = At((e) => _i(e));
class rk extends Kt {
  /**
   * @param {new (...args:any) => T} constructor
   * @param {((o:T) => boolean)|null} check
   */
  constructor(t, n) {
    super(), this.shape = t, this._c = n;
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is T}
   */
  check(t, n) {
    const r = t instanceof this.shape && (this._c == null || this._c(t));
    return !r && (n == null || n.extend(null, this.shape.name, t == null ? void 0 : t.constructor.name)), r;
  }
}
const xI = (e, t = null) => new rk(e, t);
Et(rk);
const wI = xI(Kt);
class vI extends Kt {
  /**
   * @param {Args} args
   */
  constructor(t) {
    super(), this.len = t.length - 1, this.args = kI(...t.slice(-1)), this.res = t[this.len];
  }
  /**
   * @param {any} f
   * @param {ValidationError} err
   * @return {f is _LArgsToLambdaDef<Args>}
   */
  check(t, n) {
    const r = t.constructor === Function && t.length <= this.len;
    return !r && (n == null || n.extend(null, "function", typeof t)), r;
  }
}
const SI = Et(vI), _I = At((e) => typeof e == "function");
class AI extends Kt {
  /**
   * @param {T} v
   */
  constructor(t) {
    super(), this.shape = t;
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is Intersect<UnwrapArray<T>>}
   */
  check(t, n) {
    const r = zh(this.shape, (o) => o.check(t, n));
    return !r && (n == null || n.extend(null, "Intersectinon", typeof t)), r;
  }
}
Et(AI, (e) => e.shape.length > 0);
class qc extends Kt {
  /**
   * @param {Array<Schema<S>>} v
   */
  constructor(t) {
    super(), this.shape = t;
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is S}
   */
  check(t, n) {
    const r = qh(this.shape, (o) => o.check(t, n));
    return n == null || n.extend(null, "Union", typeof t), r;
  }
}
Ir(qc, "_dilutes", !0);
const ji = (...e) => e.findIndex((t) => Ul.check(t)) >= 0 ? ji(...e.map((t) => Hs(t)).map((t) => Ul.check(t) ? t.shape : [t]).flat(1)) : e.length === 1 ? e[0] : new qc(e), Ul = (
  /** @type {Schema<$Union<any>>} */
  Et(qc)
), ok = () => !0, jl = At(ok), II = (
  /** @type {Schema<Schema<any>>} */
  Et(ep, (e) => e.shape === ok)
), tp = At((e) => typeof e == "bigint"), NI = (
  /** @type {Schema<Schema<BigInt>>} */
  At((e) => e === tp)
), ik = At((e) => typeof e == "symbol");
At((e) => e === ik);
const bi = At((e) => typeof e == "number"), sk = (
  /** @type {Schema<Schema<number>>} */
  At((e) => e === bi)
), Mi = At((e) => typeof e == "string"), ak = (
  /** @type {Schema<Schema<string>>} */
  At((e) => e === Mi)
), Wc = At((e) => typeof e == "boolean"), MI = (
  /** @type {Schema<Schema<Boolean>>} */
  At((e) => e === Wc)
), lk = zc(void 0);
Et(Vc, (e) => e.shape.length === 1 && e.shape[0] === void 0);
zc(void 0);
const Gc = zc(null), LI = (
  /** @type {Schema<Schema<null>>} */
  Et(Vc, (e) => e.shape.length === 1 && e.shape[0] === null)
);
Et(Uint8Array);
Et(Jh, (e) => e.shape === Uint8Array);
const OI = ji(bi, Mi, Gc, lk, tp, Wc, ik);
(() => {
  const e = (
    /** @type {$Array<$any>} */
    nk(jl)
  ), t = (
    /** @type {$Record<$string,$any>} */
    JE(Mi, jl)
  ), n = ji(bi, Mi, Gc, Wc, e, t);
  return e.shape = n, t.shape.values = n, n;
})();
const Hs = (e) => {
  if (wI.check(e))
    return (
      /** @type {any} */
      e
    );
  if (yI.check(e)) {
    const t = {};
    for (const n in e)
      t[n] = Hs(e[n]);
    return (
      /** @type {any} */
      gI(t)
    );
  } else {
    if (TI.check(e))
      return (
        /** @type {any} */
        ji(...e.map(Hs))
      );
    if (OI.check(e))
      return (
        /** @type {any} */
        zc(e)
      );
    if (_I.check(e))
      return (
        /** @type {any} */
        Et(
          /** @type {any} */
          e
        )
      );
  }
  Gt();
}, M0 = Z3 ? () => {
} : (e, t) => {
  const n = new uI();
  if (!t.check(e, n))
    throw yr(`Expected value to be of type ${t.constructor.name}.
${n.toString()}`);
};
class DI {
  /**
   * @param {Schema<State>} [$state]
   */
  constructor(t) {
    this.patterns = [], this.$state = t;
  }
  /**
   * @template P
   * @template R
   * @param {P} pattern
   * @param {(o:NoInfer<Unwrap<ReadSchema<P>>>,s:State)=>R} handler
   * @return {PatternMatcher<State,Patterns|Pattern<Unwrap<ReadSchema<P>>,R>>}
   */
  if(t, n) {
    return this.patterns.push({ if: Hs(t), h: n }), this;
  }
  /**
   * @template R
   * @param {(o:any,s:State)=>R} h
   */
  else(t) {
    return this.if(jl, t);
  }
  /**
   * @return {State extends undefined
   *   ? <In extends Unwrap<Patterns['if']>>(o:In,state?:undefined)=>PatternMatchResult<Patterns,In>
   *   : <In extends Unwrap<Patterns['if']>>(o:In,state:State)=>PatternMatchResult<Patterns,In>}
   */
  done() {
    return (
      /** @type {any} */
      (t, n) => {
        for (let r = 0; r < this.patterns.length; r++) {
          const o = this.patterns[r];
          if (o.if.check(t))
            return o.h(t, n);
        }
        throw yr("Unhandled pattern");
      }
    );
  }
}
const RI = (e) => new DI(
  /** @type {any} */
  e
), ck = (
  /** @type {any} */
  RI(
    /** @type {Schema<prng.PRNG>} */
    jl
  ).if(sk, (e, t) => Ju(t, C0, Bl)).if(ak, (e, t) => lI(t)).if(MI, (e, t) => N0(t)).if(NI, (e, t) => BigInt(Ju(t, C0, Bl))).if(Ul, (e, t) => ri(t, ed(t, e.shape))).if(bI, (e, t) => {
    const n = {};
    for (const r in e.shape) {
      let o = e.shape[r];
      if (pI.check(o)) {
        if (N0(t))
          continue;
        o = o.shape;
      }
      n[r] = ck(o, t);
    }
    return n;
  }).if(CI, (e, t) => {
    const n = [], r = YE(t, 0, 42);
    for (let o = 0; o < r; o++)
      n.push(ri(t, e.shape));
    return n;
  }).if(KE, (e, t) => ed(t, e.shape)).if(LI, (e, t) => null).if(SI, (e, t) => {
    const n = ri(t, e.res);
    return () => n;
  }).if(II, (e, t) => ri(t, ed(t, [
    bi,
    Mi,
    Gc,
    lk,
    tp,
    Wc,
    nk(bi),
    JE(ji("a", "b", "c"), bi)
  ]))).if(EI, (e, t) => {
    const n = {}, r = Ju(t, 0, 3);
    for (let o = 0; o < r; o++) {
      const i = ri(t, e.shape.keys), s = ri(t, e.shape.values);
      n[i] = s;
    }
    return n;
  }).done()
), ri = (e, t) => (
  /** @type {any} */
  ck(Hs(t), e)
), aa = (
  /** @type {Document} */
  typeof document < "u" ? document : {}
);
At((e) => e.nodeType === FI);
typeof DOMParser < "u" && new DOMParser();
At((e) => e.nodeType === BI);
At((e) => e.nodeType === $I);
const PI = (e) => XA(e, (t, n) => `${n}:${t};`).join(""), BI = aa.ELEMENT_NODE, $I = aa.TEXT_NODE, HI = aa.DOCUMENT_NODE, FI = aa.DOCUMENT_FRAGMENT_NODE;
At((e) => e.nodeType === HI);
const UI = (e) => class {
  /**
   * @param {number} timeoutId
   */
  constructor(n) {
    this._ = n;
  }
  destroy() {
    e(this._);
  }
}, jI = UI(clearTimeout), np = (e, t) => new jI(setTimeout(t, e)), Vr = Symbol, uk = Vr(), dk = Vr(), VI = Vr(), zI = Vr(), qI = Vr(), fk = Vr(), WI = Vr(), rp = Vr(), GI = Vr(), YI = (e) => {
  var o;
  e.length === 1 && ((o = e[0]) == null ? void 0 : o.constructor) === Function && (e = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  e[0]());
  const t = [], n = [];
  let r = 0;
  for (; r < e.length; r++) {
    const i = e[r];
    if (i === void 0)
      break;
    if (i.constructor === String || i.constructor === Number)
      t.push(i);
    else if (i.constructor === Object)
      break;
  }
  for (r > 0 && n.push(t.join("")); r < e.length; r++) {
    const i = e[r];
    i instanceof Symbol || n.push(i);
  }
  return n;
}, KI = {
  [uk]: Nr("font-weight", "bold"),
  [dk]: Nr("font-weight", "normal"),
  [VI]: Nr("color", "blue"),
  [qI]: Nr("color", "green"),
  [zI]: Nr("color", "grey"),
  [fk]: Nr("color", "red"),
  [WI]: Nr("color", "purple"),
  [rp]: Nr("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [GI]: Nr("color", "black")
}, QI = (e) => {
  var s;
  e.length === 1 && ((s = e[0]) == null ? void 0 : s.constructor) === Function && (e = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  e[0]());
  const t = [], n = [], r = On();
  let o = [], i = 0;
  for (; i < e.length; i++) {
    const a = e[i], l = KI[a];
    if (l !== void 0)
      r.set(l.left, l.right);
    else {
      if (a === void 0)
        break;
      if (a.constructor === String || a.constructor === Number) {
        const c = PI(r);
        i > 0 || c.length > 0 ? (t.push("%c" + a), n.push(c)) : t.push(a);
      } else
        break;
    }
  }
  for (i > 0 && (o = n, o.unshift(t.join(""))); i < e.length; i++) {
    const a = e[i];
    a instanceof Symbol || o.push(a);
  }
  return o;
}, hk = J3 ? QI : YI, ZI = (...e) => {
  console.log(...hk(e)), mk.forEach((t) => t.print(e));
}, pk = (...e) => {
  console.warn(...hk(e)), e.unshift(rp), mk.forEach((t) => t.print(e));
}, mk = Vo(), gk = (e) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: e
}), XI = (e, t) => gk(() => {
  let n;
  do
    n = e.next();
  while (!n.done && !t(n.value));
  return n;
}), td = (e, t) => gk(() => {
  const { done: n, value: r } = e.next();
  return { done: n, value: n ? void 0 : t(r) };
});
class op {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(t, n) {
    this.clock = t, this.len = n;
  }
}
class Vi {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const co = (e, t, n) => t.clients.forEach((r, o) => {
  const i = (
    /** @type {Array<GC|Item>} */
    e.doc.store.clients.get(o)
  );
  if (i != null) {
    const s = i[i.length - 1], a = s.id.clock + s.length;
    for (let l = 0, c = r[l]; l < r.length && c.clock < a; c = r[++l])
      Nk(e, i, c.clock, c.len, n);
  }
}), JI = (e, t) => {
  let n = 0, r = e.length - 1;
  for (; n <= r; ) {
    const o = Yn((n + r) / 2), i = e[o], s = i.clock;
    if (s <= t) {
      if (t < s + i.len)
        return o;
      n = o + 1;
    } else
      r = o - 1;
  }
  return null;
}, zi = (e, t) => {
  const n = e.clients.get(t.client);
  return n !== void 0 && JI(n, t.clock) !== null;
}, ip = (e) => {
  e.clients.forEach((t) => {
    t.sort((o, i) => o.clock - i.clock);
    let n, r;
    for (n = 1, r = 1; n < t.length; n++) {
      const o = t[r - 1], i = t[n];
      o.clock + o.len >= i.clock ? o.len = Kn(o.len, i.clock + i.len - o.clock) : (r < n && (t[r] = i), r++);
    }
    t.length = r;
  });
}, Ef = (e) => {
  const t = new Vi();
  for (let n = 0; n < e.length; n++)
    e[n].clients.forEach((r, o) => {
      if (!t.clients.has(o)) {
        const i = r.slice();
        for (let s = n + 1; s < e.length; s++)
          e3(i, e[s].clients.get(o) || []);
        t.clients.set(o, i);
      }
    });
  return ip(t), t;
}, Fs = (e, t, n, r) => {
  Tr(e.clients, t, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new op(n, r));
}, bk = () => new Vi(), yk = (e) => {
  const t = bk();
  return e.clients.forEach((n, r) => {
    const o = [];
    for (let i = 0; i < n.length; i++) {
      const s = n[i];
      if (s.deleted) {
        const a = s.id.clock;
        let l = s.length;
        if (i + 1 < n.length)
          for (let c = n[i + 1]; i + 1 < n.length && c.deleted; c = n[++i + 1])
            l += c.length;
        o.push(new op(a, l));
      }
    }
    o.length > 0 && t.clients.set(r, o);
  }), t;
}, qi = (e, t) => {
  Le(e.restEncoder, t.clients.size), lo(t.clients.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
    e.resetDsCurVal(), Le(e.restEncoder, n);
    const o = r.length;
    Le(e.restEncoder, o);
    for (let i = 0; i < o; i++) {
      const s = r[i];
      e.writeDsClock(s.clock), e.writeDsLen(s.len);
    }
  });
}, sp = (e) => {
  const t = new Vi(), n = _e(e.restDecoder);
  for (let r = 0; r < n; r++) {
    e.resetDsCurVal();
    const o = _e(e.restDecoder), i = _e(e.restDecoder);
    if (i > 0) {
      const s = Tr(t.clients, o, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let a = 0; a < i; a++)
        s.push(new op(e.readDsClock(), e.readDsLen()));
    }
  }
  return t;
}, L0 = (e, t, n) => {
  const r = new Vi(), o = _e(e.restDecoder);
  for (let i = 0; i < o; i++) {
    e.resetDsCurVal();
    const s = _e(e.restDecoder), a = _e(e.restDecoder), l = n.clients.get(s) || [], c = ft(n, s);
    for (let u = 0; u < a; u++) {
      const d = e.readDsClock(), f = d + e.readDsLen();
      if (d < c) {
        c < f && Fs(r, s, c, f - c);
        let h = Bn(l, d), p = l[h];
        for (!p.deleted && p.id.clock < d && (l.splice(h + 1, 0, Kl(t, p, d - p.id.clock)), h++); h < l.length && (p = l[h++], p.id.clock < f); )
          p.deleted || (f < p.id.clock + p.length && l.splice(h, 0, Kl(t, p, f - p.id.clock)), p.delete(t));
      } else
        Fs(r, s, d, f - d);
    }
  }
  if (r.clients.size > 0) {
    const i = new zo();
    return Le(i.restEncoder, 0), qi(i, r), i.toUint8Array();
  }
  return null;
}, Ek = UE;
class bo extends PE {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: t = B3(), collectionid: n = null, gc: r = !0, gcFilter: o = () => !0, meta: i = null, autoLoad: s = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = r, this.gcFilter = o, this.clientID = Ek(), this.guid = t, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new Ak(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = s, this.meta = i, this.isLoaded = !1, this.isSynced = !1, this.isDestroyed = !1, this.whenLoaded = A0((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const l = () => A0((c) => {
      const u = (d) => {
        (d === void 0 || d === !0) && (this.off("sync", u), c());
      };
      this.on("sync", u);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const t = this._item;
    t !== null && !this.shouldLoad && Ge(
      /** @type {any} */
      t.parent.doc,
      (n) => {
        n.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(lo(this.subdocs).map((t) => t.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(t, n = null) {
    return Ge(this, t, n);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(t, n = (
    /** @type {any} */
    vt
  )) {
    const r = Tr(this.share, t, () => {
      const i = new n();
      return i._integrate(this, null), i;
    }), o = r.constructor;
    if (n !== vt && o !== n)
      if (o === vt) {
        const i = new n();
        i._map = r._map, r._map.forEach(
          /** @param {Item?} n */
          (s) => {
            for (; s !== null; s = s.left)
              s.parent = i;
          }
        ), i._start = r._start;
        for (let s = i._start; s !== null; s = s.right)
          s.parent = i;
        return i._length = r._length, this.share.set(t, i), i._integrate(this, null), /** @type {InstanceType<Type>} */
        i;
      } else
        throw new Error(`Type with the name ${t} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      r
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(t = "") {
    return (
      /** @type {YArray<T>} */
      this.get(t, ki)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(t = "") {
    return this.get(t, uo);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(t = "") {
    return (
      /** @type {YMap<T>} */
      this.get(t, Oi)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(t = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(t, Nt)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(t = "") {
    return this.get(t, qo);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const t = {};
    return this.share.forEach((n, r) => {
      t[r] = n.toJSON();
    }), t;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = !0, lo(this.subdocs).forEach((n) => n.destroy());
    const t = this._item;
    if (t !== null) {
      this._item = null;
      const n = (
        /** @type {ContentDoc} */
        t.content
      );
      n.doc = new bo({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = t, Ge(
        /** @type {any} */
        t.parent.doc,
        (r) => {
          const o = n.doc;
          t.deleted || r.subdocsAdded.add(o), r.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class kk {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(t) {
    this.restDecoder = t;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return _e(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return _e(this.restDecoder);
  }
}
class Ck extends kk {
  /**
   * @return {ID}
   */
  readLeftID() {
    return ye(_e(this.restDecoder), _e(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return ye(_e(this.restDecoder), _e(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return _e(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return Ii(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return gi(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return _e(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return _e(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return _e(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return Bs(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return oI(gn(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(gi(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return gi(this.restDecoder);
  }
}
class eN {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(t) {
    this.dsCurrVal = 0, this.restDecoder = t;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return this.dsCurrVal += _e(this.restDecoder), this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const t = _e(this.restDecoder) + 1;
    return this.dsCurrVal += t, t;
  }
}
class Li extends eN {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(t) {
    super(t), this.keys = [], _e(t), this.keyClockDecoder = new Xu(gn(t)), this.clientDecoder = new pl(gn(t)), this.leftClockDecoder = new Xu(gn(t)), this.rightClockDecoder = new Xu(gn(t)), this.infoDecoder = new _0(gn(t), Ii), this.stringDecoder = new L3(gn(t)), this.parentInfoDecoder = new _0(gn(t), Ii), this.typeRefDecoder = new pl(gn(t)), this.lenDecoder = new pl(gn(t));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new yi(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new yi(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return Bs(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return gn(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return Bs(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const t = this.keyClockDecoder.read();
    if (t < this.keys.length)
      return this.keys[t];
    {
      const n = this.stringDecoder.read();
      return this.keys.push(n), n;
    }
  }
}
class Tk {
  constructor() {
    this.restEncoder = sa();
  }
  toUint8Array() {
    return Vn(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(t) {
    Le(this.restEncoder, t);
  }
  /**
   * @param {number} len
   */
  writeDsLen(t) {
    Le(this.restEncoder, t);
  }
}
class la extends Tk {
  /**
   * @param {ID} id
   */
  writeLeftID(t) {
    Le(this.restEncoder, t.client), Le(this.restEncoder, t.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(t) {
    Le(this.restEncoder, t.client), Le(this.restEncoder, t.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(t) {
    Le(this.restEncoder, t);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(t) {
    mf(this.restEncoder, t);
  }
  /**
   * @param {string} s
   */
  writeString(t) {
    mi(this.restEncoder, t);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(t) {
    Le(this.restEncoder, t ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(t) {
    Le(this.restEncoder, t);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(t) {
    Le(this.restEncoder, t);
  }
  /**
   * @param {any} any
   */
  writeAny(t) {
    Ai(this.restEncoder, t);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(t) {
    mn(this.restEncoder, t);
  }
  /**
   * @param {any} embed
   */
  writeJSON(t) {
    mi(this.restEncoder, JSON.stringify(t));
  }
  /**
   * @param {string} key
   */
  writeKey(t) {
    mi(this.restEncoder, t);
  }
}
class xk {
  constructor() {
    this.restEncoder = sa(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Vn(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(t) {
    const n = t - this.dsCurrVal;
    this.dsCurrVal = t, Le(this.restEncoder, n);
  }
  /**
   * @param {number} len
   */
  writeDsLen(t) {
    t === 0 && Gt(), Le(this.restEncoder, t - 1), this.dsCurrVal += t;
  }
}
class zo extends xk {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new Zu(), this.clientEncoder = new hl(), this.leftClockEncoder = new Zu(), this.rightClockEncoder = new Zu(), this.infoEncoder = new w0(mf), this.stringEncoder = new x3(), this.parentInfoEncoder = new w0(mf), this.typeRefEncoder = new hl(), this.lenEncoder = new hl();
  }
  toUint8Array() {
    const t = sa();
    return Le(t, 0), mn(t, this.keyClockEncoder.toUint8Array()), mn(t, this.clientEncoder.toUint8Array()), mn(t, this.leftClockEncoder.toUint8Array()), mn(t, this.rightClockEncoder.toUint8Array()), mn(t, Vn(this.infoEncoder)), mn(t, this.stringEncoder.toUint8Array()), mn(t, Vn(this.parentInfoEncoder)), mn(t, this.typeRefEncoder.toUint8Array()), mn(t, this.lenEncoder.toUint8Array()), Uc(t, Vn(this.restEncoder)), Vn(t);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(t) {
    this.clientEncoder.write(t.client), this.leftClockEncoder.write(t.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(t) {
    this.clientEncoder.write(t.client), this.rightClockEncoder.write(t.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(t) {
    this.clientEncoder.write(t);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(t) {
    this.infoEncoder.write(t);
  }
  /**
   * @param {string} s
   */
  writeString(t) {
    this.stringEncoder.write(t);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(t) {
    this.parentInfoEncoder.write(t ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(t) {
    this.typeRefEncoder.write(t);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(t) {
    this.lenEncoder.write(t);
  }
  /**
   * @param {any} any
   */
  writeAny(t) {
    Ai(this.restEncoder, t);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(t) {
    mn(this.restEncoder, t);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(t) {
    Ai(this.restEncoder, t);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(t) {
    const n = this.keyMap.get(t);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(t)) : this.keyClockEncoder.write(n);
  }
}
const tN = (e, t, n, r) => {
  r = Kn(r, t[0].id.clock);
  const o = Bn(t, r);
  Le(e.restEncoder, t.length - o), e.writeClient(n), Le(e.restEncoder, r);
  const i = t[o];
  i.write(e, r - i.id.clock);
  for (let s = o + 1; s < t.length; s++)
    t[s].write(e, 0);
}, ap = (e, t, n) => {
  const r = /* @__PURE__ */ new Map();
  n.forEach((o, i) => {
    ft(t, i) > o && r.set(i, o);
  }), ca(t).forEach((o, i) => {
    n.has(i) || r.set(i, 0);
  }), Le(e.restEncoder, r.size), lo(r.entries()).sort((o, i) => i[0] - o[0]).forEach(([o, i]) => {
    tN(
      e,
      /** @type {Array<GC|Item>} */
      t.clients.get(o),
      o,
      i
    );
  });
}, nN = (e, t) => {
  const n = On(), r = _e(e.restDecoder);
  for (let o = 0; o < r; o++) {
    const i = _e(e.restDecoder), s = new Array(i), a = e.readClient();
    let l = _e(e.restDecoder);
    n.set(a, { i: 0, refs: s });
    for (let c = 0; c < i; c++) {
      const u = e.readInfo();
      switch (Fc & u) {
        case 0: {
          const d = e.readLen();
          s[c] = new In(ye(a, l), d), l += d;
          break;
        }
        case 10: {
          const d = _e(e.restDecoder);
          s[c] = new Nn(ye(a, l), d), l += d;
          break;
        }
        default: {
          const d = (u & ($r | Wt)) === 0, f = new ze(
            ye(a, l),
            null,
            // left
            (u & Wt) === Wt ? e.readLeftID() : null,
            // origin
            null,
            // right
            (u & $r) === $r ? e.readRightID() : null,
            // right origin
            d ? e.readParentInfo() ? t.get(e.readString()) : e.readLeftID() : null,
            // parent
            d && (u & Rs) === Rs ? e.readString() : null,
            // parentSub
            Xk(e, u)
            // item content
          );
          s[c] = f, l += f.length;
        }
      }
    }
  }
  return n;
}, rN = (e, t, n) => {
  const r = [];
  let o = lo(n.keys()).sort((h, p) => h - p);
  if (o.length === 0)
    return null;
  const i = () => {
    if (o.length === 0)
      return null;
    let h = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      n.get(o[o.length - 1])
    );
    for (; h.refs.length === h.i; )
      if (o.pop(), o.length > 0)
        h = /** @type {{i:number,refs:Array<GC|Item>}} */
        n.get(o[o.length - 1]);
      else
        return null;
    return h;
  };
  let s = i();
  if (s === null)
    return null;
  const a = new Ak(), l = /* @__PURE__ */ new Map(), c = (h, p) => {
    const m = l.get(h);
    (m == null || m > p) && l.set(h, p);
  };
  let u = (
    /** @type {any} */
    s.refs[
      /** @type {any} */
      s.i++
    ]
  );
  const d = /* @__PURE__ */ new Map(), f = () => {
    for (const h of r) {
      const p = h.id.client, m = n.get(p);
      m ? (m.i--, a.clients.set(p, m.refs.slice(m.i)), n.delete(p), m.i = 0, m.refs = []) : a.clients.set(p, [h]), o = o.filter((b) => b !== p);
    }
    r.length = 0;
  };
  for (; ; ) {
    if (u.constructor !== Nn) {
      const p = Tr(d, u.id.client, () => ft(t, u.id.client)) - u.id.clock;
      if (p < 0)
        r.push(u), c(u.id.client, u.id.clock - 1), f();
      else {
        const m = u.getMissing(e, t);
        if (m !== null) {
          r.push(u);
          const b = n.get(
            /** @type {number} */
            m
          ) || { refs: [], i: 0 };
          if (b.refs.length === b.i)
            c(
              /** @type {number} */
              m,
              ft(t, m)
            ), f();
          else {
            u = b.refs[b.i++];
            continue;
          }
        } else (p === 0 || p < u.length) && (u.integrate(e, p), d.set(u.id.client, u.id.clock + u.length));
      }
    }
    if (r.length > 0)
      u = /** @type {GC|Item} */
      r.pop();
    else if (s !== null && s.i < s.refs.length)
      u = /** @type {GC|Item} */
      s.refs[s.i++];
    else {
      if (s = i(), s === null)
        break;
      u = /** @type {GC|Item} */
      s.refs[s.i++];
    }
  }
  if (a.clients.size > 0) {
    const h = new zo();
    return ap(h, a, /* @__PURE__ */ new Map()), Le(h.restEncoder, 0), { missing: l, update: h.toUint8Array() };
  }
  return null;
}, oN = (e, t) => ap(e, t.doc.store, t.beforeState), iN = (e, t, n, r = new Li(e)) => Ge(t, (o) => {
  o.local = !1;
  let i = !1;
  const s = o.doc, a = s.store, l = nN(r, s), c = rN(o, a, l), u = a.pendingStructs;
  if (u) {
    for (const [f, h] of u.missing)
      if (h < ft(a, f)) {
        i = !0;
        break;
      }
    if (c) {
      for (const [f, h] of c.missing) {
        const p = u.missing.get(f);
        (p == null || p > h) && u.missing.set(f, h);
      }
      u.update = zl([u.update, c.update]);
    }
  } else
    a.pendingStructs = c;
  const d = L0(r, o, a);
  if (a.pendingDs) {
    const f = new Li(Fi(a.pendingDs));
    _e(f.restDecoder);
    const h = L0(f, o, a);
    d && h ? a.pendingDs = zl([d, h]) : a.pendingDs = d || h;
  } else
    a.pendingDs = d;
  if (i) {
    const f = (
      /** @type {{update: Uint8Array}} */
      a.pendingStructs.update
    );
    a.pendingStructs = null, Vl(o.doc, f);
  }
}, n, !1), Vl = (e, t, n, r = Li) => {
  const o = Fi(t);
  iN(o, e, n, new r(o));
}, O0 = (e, t, n) => Vl(e, t, n, Ck), sN = (e, t, n = /* @__PURE__ */ new Map()) => {
  ap(e, t.store, n), qi(e, yk(t.store));
}, aN = (e, t = new Uint8Array([0]), n = new zo()) => {
  const r = wk(t);
  sN(n, e, r);
  const o = [n.toUint8Array()];
  if (e.store.pendingDs && o.push(e.store.pendingDs), e.store.pendingStructs && o.push(SN(e.store.pendingStructs.update, t)), o.length > 1) {
    if (n.constructor === la)
      return wN(o.map((i, s) => s === 0 ? i : AN(i)));
    if (n.constructor === zo)
      return zl(o);
  }
  return o[0];
}, D0 = (e, t) => aN(e, t, new la()), lN = (e) => {
  const t = /* @__PURE__ */ new Map(), n = _e(e.restDecoder);
  for (let r = 0; r < n; r++) {
    const o = _e(e.restDecoder), i = _e(e.restDecoder);
    t.set(o, i);
  }
  return t;
}, wk = (e) => lN(new kk(Fi(e))), vk = (e, t) => (Le(e.restEncoder, t.size), lo(t.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
  Le(e.restEncoder, n), Le(e.restEncoder, r);
}), e), cN = (e, t) => vk(e, ca(t.store)), uN = (e, t = new xk()) => (e instanceof Map ? vk(t, e) : cN(t, e), t.toUint8Array()), dN = (e) => uN(e, new Tk());
class fN {
  constructor() {
    this.l = [];
  }
}
const R0 = () => new fN(), P0 = (e, t) => e.l.push(t), B0 = (e, t) => {
  const n = e.l, r = n.length;
  e.l = n.filter((o) => t !== o), r === e.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, Sk = (e, t, n) => Zh(e.l, [t, n]);
class yi {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(t, n) {
    this.client = t, this.clock = n;
  }
}
const hi = (e, t) => e === t || e !== null && t !== null && e.client === t.client && e.clock === t.clock, ye = (e, t) => new yi(e, t), Us = (e) => {
  for (const [t, n] of e.doc.share.entries())
    if (n === e)
      return t;
  throw Gt();
}, js = (e, t) => {
  for (; t !== null; ) {
    if (t.parent === e)
      return !0;
    t = /** @type {AbstractType<any>} */
    t.parent._item;
  }
  return !1;
};
class Vs {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(t, n, r, o = 0) {
    this.type = t, this.tname = n, this.item = r, this.assoc = o;
  }
}
const ys = (e) => new Vs(e.type == null ? null : ye(e.type.client, e.type.clock), e.tname ?? null, e.item == null ? null : ye(e.item.client, e.item.clock), e.assoc == null ? 0 : e.assoc);
class hN {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(t, n, r = 0) {
    this.type = t, this.index = n, this.assoc = r;
  }
}
const pN = (e, t, n = 0) => new hN(e, t, n), Ba = (e, t, n) => {
  let r = null, o = null;
  return e._item === null ? o = Us(e) : r = ye(e._item.id.client, e._item.id.clock), new Vs(r, o, t, n);
}, nd = (e, t, n = 0) => {
  let r = e._start;
  if (n < 0) {
    if (t === 0)
      return Ba(e, null, n);
    t--;
  }
  for (; r !== null; ) {
    if (!r.deleted && r.countable) {
      if (r.length > t)
        return Ba(e, ye(r.id.client, r.id.clock + t), n);
      t -= r.length;
    }
    if (r.right === null && n < 0)
      return Ba(e, r.lastId, n);
    r = r.right;
  }
  return Ba(e, null, n);
}, mN = (e, t) => {
  const n = Ei(e, t), r = t.clock - n.id.clock;
  return {
    item: n,
    diff: r
  };
}, gN = (e, t, n = !0) => {
  const r = t.store, o = e.item, i = e.type, s = e.tname, a = e.assoc;
  let l = null, c = 0;
  if (o !== null) {
    if (ft(r, o.client) <= o.clock)
      return null;
    const u = n ? xf(r, o) : mN(r, o), d = u.item;
    if (!(d instanceof ze))
      return null;
    if (l = /** @type {AbstractType<any>} */
    d.parent, l._item === null || !l._item.deleted) {
      c = d.deleted || !d.countable ? 0 : u.diff + (a >= 0 ? 0 : 1);
      let f = d.left;
      for (; f !== null; )
        !f.deleted && f.countable && (c += f.length), f = f.left;
    }
  } else {
    if (s !== null)
      l = t.get(s);
    else if (i !== null) {
      if (ft(r, i.client) <= i.clock)
        return null;
      const { item: u } = n ? xf(r, i) : { item: Ei(r, i) };
      if (u instanceof ze && u.content instanceof er)
        l = u.content.type;
      else
        return null;
    } else
      throw Gt();
    a >= 0 ? c = l._length : c = 0;
  }
  return pN(l, c, e.assoc);
}, $0 = (e, t) => e === t || e !== null && t !== null && e.tname === t.tname && hi(e.item, t.item) && hi(e.type, t.type) && e.assoc === t.assoc;
class lp {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(t, n) {
    this.ds = t, this.sv = n;
  }
}
const _k = (e, t) => new lp(e, t), rd = (e) => _k(yk(e.store), ca(e.store)), No = (e, t) => t === void 0 ? !e.deleted : t.sv.has(e.id.client) && (t.sv.get(e.id.client) || 0) > e.id.clock && !zi(t.ds, e.id), kf = (e, t) => {
  const n = Tr(e.meta, kf, Vo), r = e.doc.store;
  n.has(t) || (t.sv.forEach((o, i) => {
    o < ft(r, i) && nn(e, ye(i, o));
  }), co(e, t.ds, (o) => {
  }), n.add(t));
};
class Ak {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const ca = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.clients.forEach((n, r) => {
    const o = n[n.length - 1];
    t.set(r, o.id.clock + o.length);
  }), t;
}, ft = (e, t) => {
  const n = e.clients.get(t);
  if (n === void 0)
    return 0;
  const r = n[n.length - 1];
  return r.id.clock + r.length;
}, Ik = (e, t) => {
  let n = e.clients.get(t.id.client);
  if (n === void 0)
    n = [], e.clients.set(t.id.client, n);
  else {
    const r = n[n.length - 1];
    if (r.id.clock + r.length !== t.id.clock)
      throw Gt();
  }
  n.push(t);
}, Bn = (e, t) => {
  let n = 0, r = e.length - 1, o = e[r], i = o.id.clock;
  if (i === t)
    return r;
  let s = Yn(t / (i + o.length - 1) * r);
  for (; n <= r; ) {
    if (o = e[s], i = o.id.clock, i <= t) {
      if (t < i + o.length)
        return s;
      n = s + 1;
    } else
      r = s - 1;
    s = Yn((n + r) / 2);
  }
  throw Gt();
}, bN = (e, t) => {
  const n = e.clients.get(t.client);
  return n[Bn(n, t.clock)];
}, Ei = (
  /** @type {function(StructStore,ID):Item} */
  bN
), Cf = (e, t, n) => {
  const r = Bn(t, n), o = t[r];
  return o.id.clock < n && o instanceof ze ? (t.splice(r + 1, 0, Kl(e, o, n - o.id.clock)), r + 1) : r;
}, nn = (e, t) => {
  const n = (
    /** @type {Array<Item>} */
    e.doc.store.clients.get(t.client)
  );
  return n[Cf(e, n, t.clock)];
}, H0 = (e, t, n) => {
  const r = t.clients.get(n.client), o = Bn(r, n.clock), i = r[o];
  return n.clock !== i.id.clock + i.length - 1 && i.constructor !== In && r.splice(o + 1, 0, Kl(e, i, n.clock - i.id.clock + 1)), i;
}, yN = (e, t, n) => {
  const r = (
    /** @type {Array<GC|Item>} */
    e.clients.get(t.id.client)
  );
  r[Bn(r, t.id.clock)] = n;
}, Nk = (e, t, n, r, o) => {
  if (r === 0)
    return;
  const i = n + r;
  let s = Cf(e, t, n), a;
  do
    a = t[s++], i < a.id.clock + a.length && Cf(e, t, i), o(a);
  while (s < t.length && t[s].id.clock < i);
};
class EN {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(t, n, r) {
    this.doc = t, this.deleteSet = new Vi(), this.beforeState = ca(t.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = r, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const F0 = (e, t) => t.deleteSet.clients.size === 0 && !JA(t.afterState, (n, r) => t.beforeState.get(r) !== n) ? !1 : (ip(t.deleteSet), oN(e, t), qi(e, t.deleteSet), !0), U0 = (e, t, n) => {
  const r = t._item;
  (r === null || r.id.clock < (e.beforeState.get(r.id.client) || 0) && !r.deleted) && Tr(e.changed, t, Vo).add(n);
}, gl = (e, t) => {
  let n = e[t], r = e[t - 1], o = t;
  for (; o > 0; n = r, r = e[--o - 1]) {
    if (r.deleted === n.deleted && r.constructor === n.constructor && r.mergeWith(n)) {
      n instanceof ze && n.parentSub !== null && /** @type {AbstractType<any>} */
      n.parent._map.get(n.parentSub) === n && n.parent._map.set(
        n.parentSub,
        /** @type {Item} */
        r
      );
      continue;
    }
    break;
  }
  const i = t - o;
  return i && e.splice(t + 1 - i, i), i;
}, kN = (e, t, n) => {
  for (const [r, o] of e.clients.entries()) {
    const i = (
      /** @type {Array<GC|Item>} */
      t.clients.get(r)
    );
    for (let s = o.length - 1; s >= 0; s--) {
      const a = o[s], l = a.clock + a.len;
      for (let c = Bn(i, a.clock), u = i[c]; c < i.length && u.id.clock < l; u = i[++c]) {
        const d = i[c];
        if (a.clock + a.len <= d.id.clock)
          break;
        d instanceof ze && d.deleted && !d.keep && n(d) && d.gc(t, !1);
      }
    }
  }
}, CN = (e, t) => {
  e.clients.forEach((n, r) => {
    const o = (
      /** @type {Array<GC|Item>} */
      t.clients.get(r)
    );
    for (let i = n.length - 1; i >= 0; i--) {
      const s = n[i], a = Br(o.length - 1, 1 + Bn(o, s.clock + s.len - 1));
      for (let l = a, c = o[l]; l > 0 && c.id.clock >= s.clock; c = o[l])
        l -= 1 + gl(o, l);
    }
  });
}, Mk = (e, t) => {
  if (t < e.length) {
    const n = e[t], r = n.doc, o = r.store, i = n.deleteSet, s = n._mergeStructs;
    try {
      ip(i), n.afterState = ca(n.doc.store), r.emit("beforeObserverCalls", [n, r]);
      const a = [];
      n.changed.forEach(
        (l, c) => a.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(n, l);
        })
      ), a.push(() => {
        n.changedParentTypes.forEach((l, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (l = l.filter(
            (u) => u.target._item === null || !u.target._item.deleted
          ), l.forEach((u) => {
            u.currentTarget = c, u._path = null;
          }), l.sort((u, d) => u.path.length - d.path.length), a.push(() => {
            Sk(c._dEH, l, n);
          }));
        }), a.push(() => r.emit("afterTransaction", [n, r])), a.push(() => {
          n._needFormattingCleanup && jN(n);
        });
      }), Zh(a, []);
    } finally {
      r.gc && kN(i, o, r.gcFilter), CN(i, o), n.afterState.forEach((u, d) => {
        const f = n.beforeState.get(d) || 0;
        if (f !== u) {
          const h = (
            /** @type {Array<GC|Item>} */
            o.clients.get(d)
          ), p = Kn(Bn(h, f), 1);
          for (let m = h.length - 1; m >= p; )
            m -= 1 + gl(h, m);
        }
      });
      for (let u = s.length - 1; u >= 0; u--) {
        const { client: d, clock: f } = s[u].id, h = (
          /** @type {Array<GC|Item>} */
          o.clients.get(d)
        ), p = Bn(h, f);
        p + 1 < h.length && gl(h, p + 1) > 1 || p > 0 && gl(h, p);
      }
      if (!n.local && n.afterState.get(r.clientID) !== n.beforeState.get(r.clientID) && (ZI(rp, uk, "[yjs] ", dk, fk, "Changed the client-id because another client seems to be using it."), r.clientID = Ek()), r.emit("afterTransactionCleanup", [n, r]), r._observers.has("update")) {
        const u = new la();
        F0(u, n) && r.emit("update", [u.toUint8Array(), n.origin, r, n]);
      }
      if (r._observers.has("updateV2")) {
        const u = new zo();
        F0(u, n) && r.emit("updateV2", [u.toUint8Array(), n.origin, r, n]);
      }
      const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: c } = n;
      (a.size > 0 || c.size > 0 || l.size > 0) && (a.forEach((u) => {
        u.clientID = r.clientID, u.collectionid == null && (u.collectionid = r.collectionid), r.subdocs.add(u);
      }), c.forEach((u) => r.subdocs.delete(u)), r.emit("subdocs", [{ loaded: l, added: a, removed: c }, r, n]), c.forEach((u) => u.destroy())), e.length <= t + 1 ? (r._transactionCleanups = [], r.emit("afterAllTransactions", [r, e])) : Mk(e, t + 1);
    }
  }
}, Ge = (e, t, n = null, r = !0) => {
  const o = e._transactionCleanups;
  let i = !1, s = null;
  e._transaction === null && (i = !0, e._transaction = new EN(e, n, r), o.push(e._transaction), o.length === 1 && e.emit("beforeAllTransactions", [e]), e.emit("beforeTransaction", [e._transaction, e]));
  try {
    s = t(e._transaction);
  } finally {
    if (i) {
      const a = e._transaction === o[0];
      e._transaction = null, a && Mk(o, 0);
    }
  }
  return s;
};
class TN {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(t, n) {
    this.insertions = n, this.deletions = t, this.meta = /* @__PURE__ */ new Map();
  }
}
const j0 = (e, t, n) => {
  co(e, n.deletions, (r) => {
    r instanceof ze && t.scope.some((o) => o === e.doc || js(
      /** @type {AbstractType<any>} */
      o,
      r
    )) && gp(r, !1);
  });
}, V0 = (e, t, n) => {
  let r = null;
  const o = e.doc, i = e.scope;
  Ge(o, (a) => {
    for (; t.length > 0 && e.currStackItem === null; ) {
      const l = o.store, c = (
        /** @type {StackItem} */
        t.pop()
      ), u = /* @__PURE__ */ new Set(), d = [];
      let f = !1;
      co(a, c.insertions, (h) => {
        if (h instanceof ze) {
          if (h.redone !== null) {
            let { item: p, diff: m } = xf(l, h.id);
            m > 0 && (p = nn(a, ye(p.id.client, p.id.clock + m))), h = p;
          }
          !h.deleted && i.some((p) => p === a.doc || js(
            /** @type {AbstractType<any>} */
            p,
            /** @type {Item} */
            h
          )) && d.push(h);
        }
      }), co(a, c.deletions, (h) => {
        h instanceof ze && i.some((p) => p === a.doc || js(
          /** @type {AbstractType<any>} */
          p,
          h
        )) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !zi(c.insertions, h.id) && u.add(h);
      }), u.forEach((h) => {
        f = Zk(a, h, u, c.insertions, e.ignoreRemoteMapChanges, e) !== null || f;
      });
      for (let h = d.length - 1; h >= 0; h--) {
        const p = d[h];
        e.deleteFilter(p) && (p.delete(a), f = !0);
      }
      e.currStackItem = f ? c : null;
    }
    a.changed.forEach((l, c) => {
      l.has(null) && c._searchMarker && (c._searchMarker.length = 0);
    }), r = a;
  }, e);
  const s = e.currStackItem;
  if (s != null) {
    const a = r.changedParentTypes;
    e.emit("stack-item-popped", [{ stackItem: s, type: n, changedParentTypes: a, origin: e }, e]), e.currStackItem = null;
  }
  return s;
};
class Lk extends PE {
  /**
   * @param {Doc|AbstractType<any>|Array<AbstractType<any>>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.
   * @param {UndoManagerOptions} options
   */
  constructor(t, {
    captureTimeout: n = 500,
    captureTransaction: r = (l) => !0,
    deleteFilter: o = () => !0,
    trackedOrigins: i = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges: s = !1,
    doc: a = (
      /** @type {Doc} */
      _i(t) ? t[0].doc : t instanceof bo ? t : t.doc
    )
  } = {}) {
    super(), this.scope = [], this.doc = a, this.addToScope(t), this.deleteFilter = o, i.add(this), this.trackedOrigins = i, this.captureTransaction = r, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.currStackItem = null, this.lastChange = 0, this.ignoreRemoteMapChanges = s, this.captureTimeout = n, this.afterTransactionHandler = (l) => {
      if (!this.captureTransaction(l) || !this.scope.some((b) => l.changedParentTypes.has(
        /** @type {AbstractType<any>} */
        b
      ) || b === this.doc) || !this.trackedOrigins.has(l.origin) && (!l.origin || !this.trackedOrigins.has(l.origin.constructor)))
        return;
      const c = this.undoing, u = this.redoing, d = c ? this.redoStack : this.undoStack;
      c ? this.stopCapturing() : u || this.clear(!1, !0);
      const f = new Vi();
      l.afterState.forEach((b, y) => {
        const k = l.beforeState.get(y) || 0, C = b - k;
        C > 0 && Fs(f, y, k, C);
      });
      const h = $3();
      let p = !1;
      if (this.lastChange > 0 && h - this.lastChange < this.captureTimeout && d.length > 0 && !c && !u) {
        const b = d[d.length - 1];
        b.deletions = Ef([b.deletions, l.deleteSet]), b.insertions = Ef([b.insertions, f]);
      } else
        d.push(new TN(l.deleteSet, f)), p = !0;
      !c && !u && (this.lastChange = h), co(
        l,
        l.deleteSet,
        /** @param {Item|GC} item */
        (b) => {
          b instanceof ze && this.scope.some((y) => y === l.doc || js(
            /** @type {AbstractType<any>} */
            y,
            b
          )) && gp(b, !0);
        }
      );
      const m = [{ stackItem: d[d.length - 1], origin: l.origin, type: c ? "redo" : "undo", changedParentTypes: l.changedParentTypes }, this];
      p ? this.emit("stack-item-added", m) : this.emit("stack-item-updated", m);
    }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * Extend the scope.
   *
   * @param {Array<AbstractType<any> | Doc> | AbstractType<any> | Doc} ytypes
   */
  addToScope(t) {
    const n = new Set(this.scope);
    t = _i(t) ? t : [t], t.forEach((r) => {
      n.has(r) || (n.add(r), (r instanceof vt ? r.doc !== this.doc : r !== this.doc) && pk("[yjs#509] Not same Y.Doc"), this.scope.push(r));
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(t) {
    this.trackedOrigins.add(t);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(t) {
    this.trackedOrigins.delete(t);
  }
  clear(t = !0, n = !0) {
    (t && this.canUndo() || n && this.canRedo()) && this.doc.transact((r) => {
      t && (this.undoStack.forEach((o) => j0(r, this, o)), this.undoStack = []), n && (this.redoStack.forEach((o) => j0(r, this, o)), this.redoStack = []), this.emit("stack-cleared", [{ undoStackCleared: t, redoStackCleared: n }]);
    });
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = !0;
    let t;
    try {
      t = V0(this, this.undoStack, "undo");
    } finally {
      this.undoing = !1;
    }
    return t;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = !0;
    let t;
    try {
      t = V0(this, this.redoStack, "redo");
    } finally {
      this.redoing = !1;
    }
    return t;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy();
  }
}
function* xN(e) {
  const t = _e(e.restDecoder);
  for (let n = 0; n < t; n++) {
    const r = _e(e.restDecoder), o = e.readClient();
    let i = _e(e.restDecoder);
    for (let s = 0; s < r; s++) {
      const a = e.readInfo();
      if (a === 10) {
        const l = _e(e.restDecoder);
        yield new Nn(ye(o, i), l), i += l;
      } else if (Fc & a) {
        const l = (a & ($r | Wt)) === 0, c = new ze(
          ye(o, i),
          null,
          // left
          (a & Wt) === Wt ? e.readLeftID() : null,
          // origin
          null,
          // right
          (a & $r) === $r ? e.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          l ? e.readParentInfo() ? e.readString() : e.readLeftID() : null,
          // parent
          l && (a & Rs) === Rs ? e.readString() : null,
          // parentSub
          Xk(e, a)
          // item content
        );
        yield c, i += c.length;
      } else {
        const l = e.readLen();
        yield new In(ye(o, i), l), i += l;
      }
    }
  }
}
class cp {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(t, n) {
    this.gen = xN(t), this.curr = null, this.done = !1, this.filterSkips = n, this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do
      this.curr = this.gen.next().value || null;
    while (this.filterSkips && this.curr !== null && this.curr.constructor === Nn);
    return this.curr;
  }
}
class up {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(t) {
    this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = t, this.clientStructs = [];
  }
}
const wN = (e) => zl(e, Ck, la), vN = (e, t) => {
  if (e.constructor === In) {
    const { client: n, clock: r } = e.id;
    return new In(ye(n, r + t), e.length - t);
  } else if (e.constructor === Nn) {
    const { client: n, clock: r } = e.id;
    return new Nn(ye(n, r + t), e.length - t);
  } else {
    const n = (
      /** @type {Item} */
      e
    ), { client: r, clock: o } = n.id;
    return new ze(
      ye(r, o + t),
      null,
      ye(r, o + t - 1),
      null,
      n.rightOrigin,
      n.parent,
      n.parentSub,
      n.content.splice(t)
    );
  }
}, zl = (e, t = Li, n = zo) => {
  if (e.length === 1)
    return e[0];
  const r = e.map((u) => new t(Fi(u)));
  let o = r.map((u) => new cp(u, !0)), i = null;
  const s = new n(), a = new up(s);
  for (; o = o.filter((f) => f.curr !== null), o.sort(
    /** @type {function(any,any):number} */
    (f, h) => {
      if (f.curr.id.client === h.curr.id.client) {
        const p = f.curr.id.clock - h.curr.id.clock;
        return p === 0 ? f.curr.constructor === h.curr.constructor ? 0 : f.curr.constructor === Nn ? 1 : -1 : p;
      } else
        return h.curr.id.client - f.curr.id.client;
    }
  ), o.length !== 0; ) {
    const u = o[0], d = (
      /** @type {Item | GC} */
      u.curr.id.client
    );
    if (i !== null) {
      let f = (
        /** @type {Item | GC | null} */
        u.curr
      ), h = !1;
      for (; f !== null && f.id.clock + f.length <= i.struct.id.clock + i.struct.length && f.id.client >= i.struct.id.client; )
        f = u.next(), h = !0;
      if (f === null || // current decoder is empty
      f.id.client !== d || // check whether there is another decoder that has has updates from `firstClient`
      h && f.id.clock > i.struct.id.clock + i.struct.length)
        continue;
      if (d !== i.struct.id.client)
        Xr(a, i.struct, i.offset), i = { struct: f, offset: 0 }, u.next();
      else if (i.struct.id.clock + i.struct.length < f.id.clock)
        if (i.struct.constructor === Nn)
          i.struct.length = f.id.clock + f.length - i.struct.id.clock;
        else {
          Xr(a, i.struct, i.offset);
          const p = f.id.clock - i.struct.id.clock - i.struct.length;
          i = { struct: new Nn(ye(d, i.struct.id.clock + i.struct.length), p), offset: 0 };
        }
      else {
        const p = i.struct.id.clock + i.struct.length - f.id.clock;
        p > 0 && (i.struct.constructor === Nn ? i.struct.length -= p : f = vN(f, p)), i.struct.mergeWith(
          /** @type {any} */
          f
        ) || (Xr(a, i.struct, i.offset), i = { struct: f, offset: 0 }, u.next());
      }
    } else
      i = { struct: (
        /** @type {Item | GC} */
        u.curr
      ), offset: 0 }, u.next();
    for (let f = u.curr; f !== null && f.id.client === d && f.id.clock === i.struct.id.clock + i.struct.length && f.constructor !== Nn; f = u.next())
      Xr(a, i.struct, i.offset), i = { struct: f, offset: 0 };
  }
  i !== null && (Xr(a, i.struct, i.offset), i = null), dp(a);
  const l = r.map((u) => sp(u)), c = Ef(l);
  return qi(s, c), s.toUint8Array();
}, SN = (e, t, n = Li, r = zo) => {
  const o = wk(t), i = new r(), s = new up(i), a = new n(Fi(e)), l = new cp(a, !1);
  for (; l.curr; ) {
    const u = l.curr, d = u.id.client, f = o.get(d) || 0;
    if (l.curr.constructor === Nn) {
      l.next();
      continue;
    }
    if (u.id.clock + u.length > f)
      for (Xr(s, u, Kn(f - u.id.clock, 0)), l.next(); l.curr && l.curr.id.client === d; )
        Xr(s, l.curr, 0), l.next();
    else
      for (; l.curr && l.curr.id.client === d && l.curr.id.clock + l.curr.length <= f; )
        l.next();
  }
  dp(s);
  const c = sp(a);
  return qi(i, c), i.toUint8Array();
}, Ok = (e) => {
  e.written > 0 && (e.clientStructs.push({ written: e.written, restEncoder: Vn(e.encoder.restEncoder) }), e.encoder.restEncoder = sa(), e.written = 0);
}, Xr = (e, t, n) => {
  e.written > 0 && e.currClient !== t.id.client && Ok(e), e.written === 0 && (e.currClient = t.id.client, e.encoder.writeClient(t.id.client), Le(e.encoder.restEncoder, t.id.clock + n)), t.write(e.encoder, n), e.written++;
}, dp = (e) => {
  Ok(e);
  const t = e.encoder.restEncoder;
  Le(t, e.clientStructs.length);
  for (let n = 0; n < e.clientStructs.length; n++) {
    const r = e.clientStructs[n];
    Le(t, r.written), Uc(t, r.restEncoder);
  }
}, _N = (e, t, n, r) => {
  const o = new n(Fi(e)), i = new cp(o, !1), s = new r(), a = new up(s);
  for (let c = i.curr; c !== null; c = i.next())
    Xr(a, t(c), 0);
  dp(a);
  const l = sp(o);
  return qi(s, l), s.toUint8Array();
}, AN = (e) => _N(e, Y3, Li, la), z0 = "You must not compute changes after the event-handler fired.";
class Yc {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(t, n) {
    this.target = t, this.currentTarget = t, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = IN(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(t) {
    return zi(this.transaction.deleteSet, t.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw yr(z0);
      const t = /* @__PURE__ */ new Map(), n = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(n).forEach((o) => {
        if (o !== null) {
          const i = (
            /** @type {Item} */
            n._map.get(o)
          );
          let s, a;
          if (this.adds(i)) {
            let l = i.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(i))
              if (l !== null && this.deletes(l))
                s = "delete", a = Yu(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (s = "update", a = Yu(l.content.getContent())) : (s = "add", a = void 0);
          } else if (this.deletes(i))
            s = "delete", a = Yu(
              /** @type {Item} */
              i.content.getContent()
            );
          else
            return;
          t.set(o, { action: s, oldValue: a });
        }
      }), this._keys = t;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(t) {
    return t.id.clock >= (this.transaction.beforeState.get(t.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let t = this._changes;
    if (t === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw yr(z0);
      const n = this.target, r = Vo(), o = Vo(), i = [];
      if (t = {
        added: r,
        deleted: o,
        delta: i,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(n).has(null)) {
        let a = null;
        const l = () => {
          a && i.push(a);
        };
        for (let c = n._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((a === null || a.delete === void 0) && (l(), a = { delete: 0 }), a.delete += c.length, o.add(c)) : this.adds(c) ? ((a === null || a.insert === void 0) && (l(), a = { insert: [] }), a.insert = a.insert.concat(c.content.getContent()), r.add(c)) : ((a === null || a.retain === void 0) && (l(), a = { retain: 0 }), a.retain += c.length);
        a !== null && a.retain === void 0 && l();
      }
      this._changes = t;
    }
    return (
      /** @type {any} */
      t
    );
  }
}
const IN = (e, t) => {
  const n = [];
  for (; t._item !== null && t !== e; ) {
    if (t._item.parentSub !== null)
      n.unshift(t._item.parentSub);
    else {
      let r = 0, o = (
        /** @type {AbstractType<any>} */
        t._item.parent._start
      );
      for (; o !== t._item && o !== null; )
        !o.deleted && o.countable && (r += o.length), o = o.right;
      n.unshift(r);
    }
    t = /** @type {AbstractType<any>} */
    t._item.parent;
  }
  return n;
}, Bt = () => {
  pk("Invalid access: Add Yjs type to a document before reading data.");
}, Dk = 80;
let fp = 0;
class NN {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(t, n) {
    t.marker = !0, this.p = t, this.index = n, this.timestamp = fp++;
  }
}
const MN = (e) => {
  e.timestamp = fp++;
}, Rk = (e, t, n) => {
  e.p.marker = !1, e.p = t, t.marker = !0, e.index = n, e.timestamp = fp++;
}, LN = (e, t, n) => {
  if (e.length >= Dk) {
    const r = e.reduce((o, i) => o.timestamp < i.timestamp ? o : i);
    return Rk(r, t, n), r;
  } else {
    const r = new NN(t, n);
    return e.push(r), r;
  }
}, Kc = (e, t) => {
  if (e._start === null || t === 0 || e._searchMarker === null)
    return null;
  const n = e._searchMarker.length === 0 ? null : e._searchMarker.reduce((i, s) => fl(t - i.index) < fl(t - s.index) ? i : s);
  let r = e._start, o = 0;
  for (n !== null && (r = n.p, o = n.index, MN(n)); r.right !== null && o < t; ) {
    if (!r.deleted && r.countable) {
      if (t < o + r.length)
        break;
      o += r.length;
    }
    r = r.right;
  }
  for (; r.left !== null && o > t; )
    r = r.left, !r.deleted && r.countable && (o -= r.length);
  for (; r.left !== null && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock; )
    r = r.left, !r.deleted && r.countable && (o -= r.length);
  return n !== null && fl(n.index - o) < /** @type {YText|YArray<any>} */
  r.parent.length / Dk ? (Rk(n, r, o), n) : LN(e._searchMarker, r, o);
}, zs = (e, t, n) => {
  for (let r = e.length - 1; r >= 0; r--) {
    const o = e[r];
    if (n > 0) {
      let i = o.p;
      for (i.marker = !1; i && (i.deleted || !i.countable); )
        i = i.left, i && !i.deleted && i.countable && (o.index -= i.length);
      if (i === null || i.marker === !0) {
        e.splice(r, 1);
        continue;
      }
      o.p = i, i.marker = !0;
    }
    (t < o.index || n > 0 && t === o.index) && (o.index = Kn(t, o.index + n));
  }
}, Qc = (e, t, n) => {
  const r = e, o = t.changedParentTypes;
  for (; Tr(o, e, () => []).push(n), e._item !== null; )
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  Sk(r._eH, n, t);
};
class vt {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = R0(), this._dEH = R0(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(t, n) {
    this.doc = t, this._item = n;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw Dn();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw Dn();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(t) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let t = this._start;
    for (; t !== null && t.deleted; )
      t = t.right;
    return t;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, n) {
    !t.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(t) {
    P0(this._eH, t);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(t) {
    P0(this._dEH, t);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(t) {
    B0(this._eH, t);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(t) {
    B0(this._dEH, t);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const Pk = (e, t, n) => {
  e.doc ?? Bt(), t < 0 && (t = e._length + t), n < 0 && (n = e._length + n);
  let r = n - t;
  const o = [];
  let i = e._start;
  for (; i !== null && r > 0; ) {
    if (i.countable && !i.deleted) {
      const s = i.content.getContent();
      if (s.length <= t)
        t -= s.length;
      else {
        for (let a = t; a < s.length && r > 0; a++)
          o.push(s[a]), r--;
        t = 0;
      }
    }
    i = i.right;
  }
  return o;
}, Bk = (e) => {
  e.doc ?? Bt();
  const t = [];
  let n = e._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const r = n.content.getContent();
      for (let o = 0; o < r.length; o++)
        t.push(r[o]);
    }
    n = n.right;
  }
  return t;
}, $k = (e, t) => {
  const n = [];
  let r = e._start;
  for (; r !== null; ) {
    if (r.countable && No(r, t)) {
      const o = r.content.getContent();
      for (let i = 0; i < o.length; i++)
        n.push(o[i]);
    }
    r = r.right;
  }
  return n;
}, qs = (e, t) => {
  let n = 0, r = e._start;
  for (e.doc ?? Bt(); r !== null; ) {
    if (r.countable && !r.deleted) {
      const o = r.content.getContent();
      for (let i = 0; i < o.length; i++)
        t(o[i], n++, e);
    }
    r = r.right;
  }
}, Hk = (e, t) => {
  const n = [];
  return qs(e, (r, o) => {
    n.push(t(r, o, e));
  }), n;
}, ON = (e) => {
  let t = e._start, n = null, r = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; t !== null && t.deleted; )
          t = t.right;
        if (t === null)
          return {
            done: !0,
            value: void 0
          };
        n = t.content.getContent(), r = 0, t = t.right;
      }
      const o = n[r++];
      return n.length <= r && (n = null), {
        done: !1,
        value: o
      };
    }
  };
}, Fk = (e, t) => {
  e.doc ?? Bt();
  const n = Kc(e, t);
  let r = e._start;
  for (n !== null && (r = n.p, t -= n.index); r !== null; r = r.right)
    if (!r.deleted && r.countable) {
      if (t < r.length)
        return r.content.getContent()[t];
      t -= r.length;
    }
}, ql = (e, t, n, r) => {
  let o = n;
  const i = e.doc, s = i.clientID, a = i.store, l = n === null ? t._start : n.right;
  let c = [];
  const u = () => {
    c.length > 0 && (o = new ze(ye(s, ft(a, s)), o, o && o.lastId, l, l && l.id, t, null, new Wo(c)), o.integrate(e, 0), c = []);
  };
  r.forEach((d) => {
    if (d === null)
      c.push(d);
    else
      switch (d.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(d);
          break;
        default:
          switch (u(), d.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              o = new ze(ye(s, ft(a, s)), o, o && o.lastId, l, l && l.id, t, null, new ua(new Uint8Array(
                /** @type {Uint8Array} */
                d
              ))), o.integrate(e, 0);
              break;
            case bo:
              o = new ze(ye(s, ft(a, s)), o, o && o.lastId, l, l && l.id, t, null, new da(
                /** @type {Doc} */
                d
              )), o.integrate(e, 0);
              break;
            default:
              if (d instanceof vt)
                o = new ze(ye(s, ft(a, s)), o, o && o.lastId, l, l && l.id, t, null, new er(d)), o.integrate(e, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), u();
}, Uk = () => yr("Length exceeded!"), jk = (e, t, n, r) => {
  if (n > t._length)
    throw Uk();
  if (n === 0)
    return t._searchMarker && zs(t._searchMarker, n, r.length), ql(e, t, null, r);
  const o = n, i = Kc(t, n);
  let s = t._start;
  for (i !== null && (s = i.p, n -= i.index, n === 0 && (s = s.prev, n += s && s.countable && !s.deleted ? s.length : 0)); s !== null; s = s.right)
    if (!s.deleted && s.countable) {
      if (n <= s.length) {
        n < s.length && nn(e, ye(s.id.client, s.id.clock + n));
        break;
      }
      n -= s.length;
    }
  return t._searchMarker && zs(t._searchMarker, o, r.length), ql(e, t, s, r);
}, DN = (e, t, n) => {
  let o = (t._searchMarker || []).reduce((i, s) => s.index > i.index ? s : i, { index: 0, p: t._start }).p;
  if (o)
    for (; o.right; )
      o = o.right;
  return ql(e, t, o, n);
}, Vk = (e, t, n, r) => {
  if (r === 0)
    return;
  const o = n, i = r, s = Kc(t, n);
  let a = t._start;
  for (s !== null && (a = s.p, n -= s.index); a !== null && n > 0; a = a.right)
    !a.deleted && a.countable && (n < a.length && nn(e, ye(a.id.client, a.id.clock + n)), n -= a.length);
  for (; r > 0 && a !== null; )
    a.deleted || (r < a.length && nn(e, ye(a.id.client, a.id.clock + r)), a.delete(e), r -= a.length), a = a.right;
  if (r > 0)
    throw Uk();
  t._searchMarker && zs(
    t._searchMarker,
    o,
    -i + r
    /* in case we remove the above exception */
  );
}, Wl = (e, t, n) => {
  const r = t._map.get(n);
  r !== void 0 && r.delete(e);
}, hp = (e, t, n, r) => {
  const o = t._map.get(n) || null, i = e.doc, s = i.clientID;
  let a;
  if (r == null)
    a = new Wo([r]);
  else
    switch (r.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
      case Date:
      case BigInt:
        a = new Wo([r]);
        break;
      case Uint8Array:
        a = new ua(
          /** @type {Uint8Array} */
          r
        );
        break;
      case bo:
        a = new da(
          /** @type {Doc} */
          r
        );
        break;
      default:
        if (r instanceof vt)
          a = new er(r);
        else
          throw new Error("Unexpected content type");
    }
  new ze(ye(s, ft(i.store, s)), o, o && o.lastId, null, null, t, n, a).integrate(e, 0);
}, pp = (e, t) => {
  e.doc ?? Bt();
  const n = e._map.get(t);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, zk = (e) => {
  const t = {};
  return e.doc ?? Bt(), e._map.forEach((n, r) => {
    n.deleted || (t[r] = n.content.getContent()[n.length - 1]);
  }), t;
}, qk = (e, t) => {
  e.doc ?? Bt();
  const n = e._map.get(t);
  return n !== void 0 && !n.deleted;
}, RN = (e, t) => {
  const n = {};
  return e._map.forEach((r, o) => {
    let i = r;
    for (; i !== null && (!t.sv.has(i.id.client) || i.id.clock >= (t.sv.get(i.id.client) || 0)); )
      i = i.left;
    i !== null && No(i, t) && (n[o] = i.content.getContent()[i.length - 1]);
  }), n;
}, $a = (e) => (e.doc ?? Bt(), XI(
  e._map.entries(),
  /** @param {any} entry */
  (t) => !t[1].deleted
));
class PN extends Yc {
}
class ki extends vt {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(t) {
    const n = new ki();
    return n.push(t), n;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(t, n) {
    super._integrate(t, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new ki();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const t = new ki();
    return t.insert(0, this.toArray().map(
      (n) => n instanceof vt ? (
        /** @type {typeof el} */
        n.clone()
      ) : n
    )), t;
  }
  get length() {
    return this.doc ?? Bt(), this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, n) {
    super._callObserver(t, n), Qc(this, t, new PN(this, t));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(t, n) {
    this.doc !== null ? Ge(this.doc, (r) => {
      jk(
        r,
        this,
        t,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.splice(t, 0, ...n);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(t) {
    this.doc !== null ? Ge(this.doc, (n) => {
      DN(
        n,
        this,
        /** @type {any} */
        t
      );
    }) : this._prelimContent.push(...t);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(t) {
    this.insert(0, t);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(t, n = 1) {
    this.doc !== null ? Ge(this.doc, (r) => {
      Vk(r, this, t, n);
    }) : this._prelimContent.splice(t, n);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(t) {
    return Fk(this, t);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return Bk(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(t = 0, n = this.length) {
    return Pk(this, t, n);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((t) => t instanceof vt ? t.toJSON() : t);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(t) {
    return Hk(
      this,
      /** @type {any} */
      t
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(t) {
    qs(this, t);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return ON(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(t) {
    t.writeTypeRef(a4);
  }
}
const BN = (e) => new ki();
class $N extends Yc {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(t, n, r) {
    super(t, n), this.keysChanged = r;
  }
}
class Oi extends vt {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(t) {
    super(), this._prelimContent = null, t === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(t);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(t, n) {
    super._integrate(t, n), this._prelimContent.forEach((r, o) => {
      this.set(o, r);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new Oi();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const t = new Oi();
    return this.forEach((n, r) => {
      t.set(r, n instanceof vt ? (
        /** @type {typeof value} */
        n.clone()
      ) : n);
    }), t;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, n) {
    Qc(this, t, new $N(this, t, n));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? Bt();
    const t = {};
    return this._map.forEach((n, r) => {
      if (!n.deleted) {
        const o = n.content.getContent()[n.length - 1];
        t[r] = o instanceof vt ? o.toJSON() : o;
      }
    }), t;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...$a(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return td(
      $a(this),
      /** @param {any} v */
      (t) => t[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return td(
      $a(this),
      /** @param {any} v */
      (t) => t[1].content.getContent()[t[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return td(
      $a(this),
      /** @param {any} v */
      (t) => (
        /** @type {any} */
        [t[0], t[1].content.getContent()[t[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(t) {
    this.doc ?? Bt(), this._map.forEach((n, r) => {
      n.deleted || t(n.content.getContent()[n.length - 1], r, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(t) {
    this.doc !== null ? Ge(this.doc, (n) => {
      Wl(n, this, t);
    }) : this._prelimContent.delete(t);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(t, n) {
    return this.doc !== null ? Ge(this.doc, (r) => {
      hp(
        r,
        this,
        t,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.set(t, n), n;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(t) {
    return (
      /** @type {any} */
      pp(this, t)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(t) {
    return qk(this, t);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? Ge(this.doc, (t) => {
      this.forEach(function(n, r, o) {
        Wl(t, o, r);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(t) {
    t.writeTypeRef(l4);
  }
}
const HN = (e) => new Oi(), Jr = (e, t) => e === t || typeof e == "object" && typeof t == "object" && e && t && W3(e, t);
class Tf {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(t, n, r, o) {
    this.left = t, this.right = n, this.index = r, this.currentAttributes = o;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && Gt(), this.right.content.constructor) {
      case yt:
        this.right.deleted || Wi(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const q0 = (e, t, n) => {
  for (; t.right !== null && n > 0; ) {
    switch (t.right.content.constructor) {
      case yt:
        t.right.deleted || Wi(
          t.currentAttributes,
          /** @type {ContentFormat} */
          t.right.content
        );
        break;
      default:
        t.right.deleted || (n < t.right.length && nn(e, ye(t.right.id.client, t.right.id.clock + n)), t.index += t.right.length, n -= t.right.length);
        break;
    }
    t.left = t.right, t.right = t.right.right;
  }
  return t;
}, Ha = (e, t, n, r) => {
  const o = /* @__PURE__ */ new Map(), i = r ? Kc(t, n) : null;
  if (i) {
    const s = new Tf(i.p.left, i.p, i.index, o);
    return q0(e, s, n - i.index);
  } else {
    const s = new Tf(null, t._start, 0, o);
    return q0(e, s, n);
  }
}, Wk = (e, t, n, r) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === yt && Jr(
    r.get(
      /** @type {ContentFormat} */
      n.right.content.key
    ),
    /** @type {ContentFormat} */
    n.right.content.value
  )); )
    n.right.deleted || r.delete(
      /** @type {ContentFormat} */
      n.right.content.key
    ), n.forward();
  const o = e.doc, i = o.clientID;
  r.forEach((s, a) => {
    const l = n.left, c = n.right, u = new ze(ye(i, ft(o.store, i)), l, l && l.lastId, c, c && c.id, t, null, new yt(a, s));
    u.integrate(e, 0), n.right = u, n.forward();
  });
}, Wi = (e, t) => {
  const { key: n, value: r } = t;
  r === null ? e.delete(n) : e.set(n, r);
}, Gk = (e, t) => {
  for (; e.right !== null; ) {
    if (!(e.right.deleted || e.right.content.constructor === yt && Jr(
      t[
        /** @type {ContentFormat} */
        e.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      e.right.content.value
    ))) break;
    e.forward();
  }
}, Yk = (e, t, n, r) => {
  const o = e.doc, i = o.clientID, s = /* @__PURE__ */ new Map();
  for (const a in r) {
    const l = r[a], c = n.currentAttributes.get(a) ?? null;
    if (!Jr(c, l)) {
      s.set(a, c);
      const { left: u, right: d } = n;
      n.right = new ze(ye(i, ft(o.store, i)), u, u && u.lastId, d, d && d.id, t, null, new yt(a, l)), n.right.integrate(e, 0), n.forward();
    }
  }
  return s;
}, od = (e, t, n, r, o) => {
  n.currentAttributes.forEach((f, h) => {
    o[h] === void 0 && (o[h] = null);
  });
  const i = e.doc, s = i.clientID;
  Gk(n, o);
  const a = Yk(e, t, n, o), l = r.constructor === String ? new Qn(
    /** @type {string} */
    r
  ) : r instanceof vt ? new er(r) : new Qo(r);
  let { left: c, right: u, index: d } = n;
  t._searchMarker && zs(t._searchMarker, n.index, l.getLength()), u = new ze(ye(s, ft(i.store, s)), c, c && c.lastId, u, u && u.id, t, null, l), u.integrate(e, 0), n.right = u, n.index = d, n.forward(), Wk(e, t, n, a);
}, W0 = (e, t, n, r, o) => {
  const i = e.doc, s = i.clientID;
  Gk(n, o);
  const a = Yk(e, t, n, o);
  e: for (; n.right !== null && (r > 0 || a.size > 0 && (n.right.deleted || n.right.content.constructor === yt)); ) {
    if (!n.right.deleted)
      switch (n.right.content.constructor) {
        case yt: {
          const { key: l, value: c } = (
            /** @type {ContentFormat} */
            n.right.content
          ), u = o[l];
          if (u !== void 0) {
            if (Jr(u, c))
              a.delete(l);
            else {
              if (r === 0)
                break e;
              a.set(l, c);
            }
            n.right.delete(e);
          } else
            n.currentAttributes.set(l, c);
          break;
        }
        default:
          r < n.right.length && nn(e, ye(n.right.id.client, n.right.id.clock + r)), r -= n.right.length;
          break;
      }
    n.forward();
  }
  if (r > 0) {
    let l = "";
    for (; r > 0; r--)
      l += `
`;
    n.right = new ze(ye(s, ft(i.store, s)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, t, null, new Qn(l)), n.right.integrate(e, 0), n.forward();
  }
  Wk(e, t, n, a);
}, Kk = (e, t, n, r, o) => {
  let i = t;
  const s = On();
  for (; i && (!i.countable || i.deleted); ) {
    if (!i.deleted && i.content.constructor === yt) {
      const c = (
        /** @type {ContentFormat} */
        i.content
      );
      s.set(c.key, c);
    }
    i = i.right;
  }
  let a = 0, l = !1;
  for (; t !== i; ) {
    if (n === t && (l = !0), !t.deleted) {
      const c = t.content;
      switch (c.constructor) {
        case yt: {
          const { key: u, value: d } = (
            /** @type {ContentFormat} */
            c
          ), f = r.get(u) ?? null;
          (s.get(u) !== c || f === d) && (t.delete(e), a++, !l && (o.get(u) ?? null) === d && f !== d && (f === null ? o.delete(u) : o.set(u, f))), !l && !t.deleted && Wi(
            o,
            /** @type {ContentFormat} */
            c
          );
          break;
        }
      }
    }
    t = /** @type {Item} */
    t.right;
  }
  return a;
}, FN = (e, t) => {
  for (; t && t.right && (t.right.deleted || !t.right.countable); )
    t = t.right;
  const n = /* @__PURE__ */ new Set();
  for (; t && (t.deleted || !t.countable); ) {
    if (!t.deleted && t.content.constructor === yt) {
      const r = (
        /** @type {ContentFormat} */
        t.content.key
      );
      n.has(r) ? t.delete(e) : n.add(r);
    }
    t = t.left;
  }
}, UN = (e) => {
  let t = 0;
  return Ge(
    /** @type {Doc} */
    e.doc,
    (n) => {
      let r = (
        /** @type {Item} */
        e._start
      ), o = e._start, i = On();
      const s = hf(i);
      for (; o; ) {
        if (o.deleted === !1)
          switch (o.content.constructor) {
            case yt:
              Wi(
                s,
                /** @type {ContentFormat} */
                o.content
              );
              break;
            default:
              t += Kk(n, r, o, i, s), i = hf(s), r = o;
              break;
          }
        o = o.right;
      }
    }
  ), t;
}, jN = (e) => {
  const t = /* @__PURE__ */ new Set(), n = e.doc;
  for (const [r, o] of e.afterState.entries()) {
    const i = e.beforeState.get(r) || 0;
    o !== i && Nk(
      e,
      /** @type {Array<Item|GC>} */
      n.store.clients.get(r),
      i,
      o,
      (s) => {
        !s.deleted && /** @type {Item} */
        s.content.constructor === yt && s.constructor !== In && t.add(
          /** @type {any} */
          s.parent
        );
      }
    );
  }
  Ge(n, (r) => {
    co(e, e.deleteSet, (o) => {
      if (o instanceof In || !/** @type {YText} */
      o.parent._hasFormatting || t.has(
        /** @type {YText} */
        o.parent
      ))
        return;
      const i = (
        /** @type {YText} */
        o.parent
      );
      o.content.constructor === yt ? t.add(i) : FN(r, o);
    });
    for (const o of t)
      UN(o);
  });
}, G0 = (e, t, n) => {
  const r = n, o = hf(t.currentAttributes), i = t.right;
  for (; n > 0 && t.right !== null; ) {
    if (t.right.deleted === !1)
      switch (t.right.content.constructor) {
        case er:
        case Qo:
        case Qn:
          n < t.right.length && nn(e, ye(t.right.id.client, t.right.id.clock + n)), n -= t.right.length, t.right.delete(e);
          break;
      }
    t.forward();
  }
  i && Kk(e, i, t.right, o, t.currentAttributes);
  const s = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (t.left || t.right).parent
  );
  return s._searchMarker && zs(s._searchMarker, t.index, -r + n), t;
};
class VN extends Yc {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(t, n, r) {
    super(t, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), r.forEach((o) => {
      o === null ? this.childListChanged = !0 : this.keysChanged.add(o);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const t = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = t;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const t = (
        /** @type {Doc} */
        this.target.doc
      ), n = [];
      Ge(t, (r) => {
        const o = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
        let s = this.target._start, a = null;
        const l = {};
        let c = "", u = 0, d = 0;
        const f = () => {
          if (a !== null) {
            let h = null;
            switch (a) {
              case "delete":
                d > 0 && (h = { delete: d }), d = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (h = { insert: c }, o.size > 0 && (h.attributes = {}, o.forEach((p, m) => {
                  p !== null && (h.attributes[m] = p);
                }))), c = "";
                break;
              case "retain":
                u > 0 && (h = { retain: u }, q3(l) || (h.attributes = V3({}, l))), u = 0;
                break;
            }
            h && n.push(h), a = null;
          }
        };
        for (; s !== null; ) {
          switch (s.content.constructor) {
            case er:
            case Qo:
              this.adds(s) ? this.deletes(s) || (f(), a = "insert", c = s.content.getContent()[0], f()) : this.deletes(s) ? (a !== "delete" && (f(), a = "delete"), d += 1) : s.deleted || (a !== "retain" && (f(), a = "retain"), u += 1);
              break;
            case Qn:
              this.adds(s) ? this.deletes(s) || (a !== "insert" && (f(), a = "insert"), c += /** @type {ContentString} */
              s.content.str) : this.deletes(s) ? (a !== "delete" && (f(), a = "delete"), d += s.length) : s.deleted || (a !== "retain" && (f(), a = "retain"), u += s.length);
              break;
            case yt: {
              const { key: h, value: p } = (
                /** @type {ContentFormat} */
                s.content
              );
              if (this.adds(s)) {
                if (!this.deletes(s)) {
                  const m = o.get(h) ?? null;
                  Jr(m, p) ? p !== null && s.delete(r) : (a === "retain" && f(), Jr(p, i.get(h) ?? null) ? delete l[h] : l[h] = p);
                }
              } else if (this.deletes(s)) {
                i.set(h, p);
                const m = o.get(h) ?? null;
                Jr(m, p) || (a === "retain" && f(), l[h] = m);
              } else if (!s.deleted) {
                i.set(h, p);
                const m = l[h];
                m !== void 0 && (Jr(m, p) ? m !== null && s.delete(r) : (a === "retain" && f(), p === null ? delete l[h] : l[h] = p));
              }
              s.deleted || (a === "insert" && f(), Wi(
                o,
                /** @type {ContentFormat} */
                s.content
              ));
              break;
            }
          }
          s = s.right;
        }
        for (f(); n.length > 0; ) {
          const h = n[n.length - 1];
          if (h.retain !== void 0 && h.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class uo extends vt {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(t) {
    super(), this._pending = t !== void 0 ? [() => this.insert(0, t)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this.doc ?? Bt(), this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(t, n) {
    super._integrate(t, n);
    try {
      this._pending.forEach((r) => r());
    } catch (r) {
      console.error(r);
    }
    this._pending = null;
  }
  _copy() {
    return new uo();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const t = new uo();
    return t.applyDelta(this.toDelta()), t;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, n) {
    super._callObserver(t, n);
    const r = new VN(this, t, n);
    Qc(this, t, r), !t.local && this._hasFormatting && (t._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? Bt();
    let t = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === Qn && (t += /** @type {ContentString} */
      n.content.str), n = n.right;
    return t;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(t, { sanitize: n = !0 } = {}) {
    this.doc !== null ? Ge(this.doc, (r) => {
      const o = new Tf(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        if (s.insert !== void 0) {
          const a = !n && typeof s.insert == "string" && i === t.length - 1 && o.right === null && s.insert.slice(-1) === `
` ? s.insert.slice(0, -1) : s.insert;
          (typeof a != "string" || a.length > 0) && od(r, this, o, a, s.attributes || {});
        } else s.retain !== void 0 ? W0(r, this, o, s.retain, s.attributes || {}) : s.delete !== void 0 && G0(r, o, s.delete);
      }
    }) : this._pending.push(() => this.applyDelta(t));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(t, n, r) {
    this.doc ?? Bt();
    const o = [], i = /* @__PURE__ */ new Map(), s = (
      /** @type {Doc} */
      this.doc
    );
    let a = "", l = this._start;
    function c() {
      if (a.length > 0) {
        const d = {};
        let f = !1;
        i.forEach((p, m) => {
          f = !0, d[m] = p;
        });
        const h = { insert: a };
        f && (h.attributes = d), o.push(h), a = "";
      }
    }
    const u = () => {
      for (; l !== null; ) {
        if (No(l, t) || n !== void 0 && No(l, n))
          switch (l.content.constructor) {
            case Qn: {
              const d = i.get("ychange");
              t !== void 0 && !No(l, t) ? (d === void 0 || d.user !== l.id.client || d.type !== "removed") && (c(), i.set("ychange", r ? r("removed", l.id) : { type: "removed" })) : n !== void 0 && !No(l, n) ? (d === void 0 || d.user !== l.id.client || d.type !== "added") && (c(), i.set("ychange", r ? r("added", l.id) : { type: "added" })) : d !== void 0 && (c(), i.delete("ychange")), a += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case er:
            case Qo: {
              c();
              const d = {
                insert: l.content.getContent()[0]
              };
              if (i.size > 0) {
                const f = (
                  /** @type {Object<string,any>} */
                  {}
                );
                d.attributes = f, i.forEach((h, p) => {
                  f[p] = h;
                });
              }
              o.push(d);
              break;
            }
            case yt:
              No(l, t) && (c(), Wi(
                i,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      c();
    };
    return t || n ? Ge(s, (d) => {
      t && kf(d, t), n && kf(d, n), u();
    }, "cleanup") : u(), o;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(t, n, r) {
    if (n.length <= 0)
      return;
    const o = this.doc;
    o !== null ? Ge(o, (i) => {
      const s = Ha(i, this, t, !r);
      r || (r = {}, s.currentAttributes.forEach((a, l) => {
        r[l] = a;
      })), od(i, this, s, n, r);
    }) : this._pending.push(() => this.insert(t, n, r));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(t, n, r) {
    const o = this.doc;
    o !== null ? Ge(o, (i) => {
      const s = Ha(i, this, t, !r);
      od(i, this, s, n, r || {});
    }) : this._pending.push(() => this.insertEmbed(t, n, r || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(t, n) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? Ge(r, (o) => {
      G0(o, Ha(o, this, t, !0), n);
    }) : this._pending.push(() => this.delete(t, n));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(t, n, r) {
    if (n === 0)
      return;
    const o = this.doc;
    o !== null ? Ge(o, (i) => {
      const s = Ha(i, this, t, !1);
      s.right !== null && W0(i, this, s, n, r);
    }) : this._pending.push(() => this.format(t, n, r));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(t) {
    this.doc !== null ? Ge(this.doc, (n) => {
      Wl(n, this, t);
    }) : this._pending.push(() => this.removeAttribute(t));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(t, n) {
    this.doc !== null ? Ge(this.doc, (r) => {
      hp(r, this, t, n);
    }) : this._pending.push(() => this.setAttribute(t, n));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(t) {
    return (
      /** @type {any} */
      pp(this, t)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return zk(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(t) {
    t.writeTypeRef(c4);
  }
}
const zN = (e) => new uo();
class id {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(t, n = () => !0) {
    this._filter = n, this._root = t, this._currentNode = /** @type {Item} */
    t._start, this._firstCall = !0, t.doc ?? Bt();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let t = this._currentNode, n = t && t.content && /** @type {any} */
    t.content.type;
    if (t !== null && (!this._firstCall || t.deleted || !this._filter(n)))
      do
        if (n = /** @type {any} */
        t.content.type, !t.deleted && (n.constructor === Nt || n.constructor === qo) && n._start !== null)
          t = n._start;
        else
          for (; t !== null; ) {
            const r = t.next;
            if (r !== null) {
              t = r;
              break;
            } else t.parent === this._root ? t = null : t = /** @type {AbstractType<any>} */
            t.parent._item;
          }
      while (t !== null && (t.deleted || !this._filter(
        /** @type {ContentType} */
        t.content.type
      )));
    return this._firstCall = !1, t === null ? { value: void 0, done: !0 } : (this._currentNode = t, { value: (
      /** @type {any} */
      t.content.type
    ), done: !1 });
  }
}
class qo extends vt {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const t = this._first;
    return t ? t.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(t, n) {
    super._integrate(t, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new qo();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const t = new qo();
    return t.insert(0, this.toArray().map((n) => n instanceof vt ? n.clone() : n)), t;
  }
  get length() {
    return this.doc ?? Bt(), this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(t) {
    return new id(this, t);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(t) {
    t = t.toUpperCase();
    const r = new id(this, (o) => o.nodeName && o.nodeName.toUpperCase() === t).next();
    return r.done ? null : r.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(t) {
    return t = t.toUpperCase(), lo(new id(this, (n) => n.nodeName && n.nodeName.toUpperCase() === t));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(t, n) {
    Qc(this, t, new GN(this, n, t));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return Hk(this, (t) => t.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(t = document, n = {}, r) {
    const o = t.createDocumentFragment();
    return r !== void 0 && r._createAssociation(o, this), qs(this, (i) => {
      o.insertBefore(i.toDOM(t, n, r), null);
    }), o;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(t, n) {
    this.doc !== null ? Ge(this.doc, (r) => {
      jk(r, this, t, n);
    }) : this._prelimContent.splice(t, 0, ...n);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(t, n) {
    if (this.doc !== null)
      Ge(this.doc, (r) => {
        const o = t && t instanceof vt ? t._item : t;
        ql(r, this, o, n);
      });
    else {
      const r = (
        /** @type {Array<any>} */
        this._prelimContent
      ), o = t === null ? 0 : r.findIndex((i) => i === t) + 1;
      if (o === 0 && t !== null)
        throw yr("Reference item not found");
      r.splice(o, 0, ...n);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(t, n = 1) {
    this.doc !== null ? Ge(this.doc, (r) => {
      Vk(r, this, t, n);
    }) : this._prelimContent.splice(t, n);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return Bk(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(t) {
    this.insert(this.length, t);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(t) {
    this.insert(0, t);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(t) {
    return Fk(this, t);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(t = 0, n = this.length) {
    return Pk(this, t, n);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(t) {
    qs(this, t);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(t) {
    t.writeTypeRef(d4);
  }
}
const qN = (e) => new qo();
class Nt extends qo {
  constructor(t = "UNDEFINED") {
    super(), this.nodeName = t, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const t = this._item ? this._item.next : null;
    return t ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      t.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const t = this._item ? this._item.prev : null;
    return t ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      t.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(t, n) {
    super._integrate(t, n), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((r, o) => {
      this.setAttribute(o, r);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new Nt(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const t = new Nt(this.nodeName), n = this.getAttributes();
    return z3(n, (r, o) => {
      t.setAttribute(
        o,
        /** @type {any} */
        r
      );
    }), t.insert(0, this.toArray().map((r) => r instanceof vt ? r.clone() : r)), t;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const t = this.getAttributes(), n = [], r = [];
    for (const a in t)
      r.push(a);
    r.sort();
    const o = r.length;
    for (let a = 0; a < o; a++) {
      const l = r[a];
      n.push(l + '="' + t[l] + '"');
    }
    const i = this.nodeName.toLocaleLowerCase(), s = n.length > 0 ? " " + n.join(" ") : "";
    return `<${i}${s}>${super.toString()}</${i}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(t) {
    this.doc !== null ? Ge(this.doc, (n) => {
      Wl(n, this, t);
    }) : this._prelimAttrs.delete(t);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(t, n) {
    this.doc !== null ? Ge(this.doc, (r) => {
      hp(r, this, t, n);
    }) : this._prelimAttrs.set(t, n);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(t) {
    return (
      /** @type {any} */
      pp(this, t)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(t) {
    return (
      /** @type {any} */
      qk(this, t)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(t) {
    return (
      /** @type {any} */
      t ? RN(this, t) : zk(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(t = document, n = {}, r) {
    const o = t.createElement(this.nodeName), i = this.getAttributes();
    for (const s in i) {
      const a = i[s];
      typeof a == "string" && o.setAttribute(s, a);
    }
    return qs(this, (s) => {
      o.appendChild(s.toDOM(t, n, r));
    }), r !== void 0 && r._createAssociation(o, this), o;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(t) {
    t.writeTypeRef(u4), t.writeKey(this.nodeName);
  }
}
const WN = (e) => new Nt(e.readKey());
class GN extends Yc {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */
  constructor(t, n, r) {
    super(t, r), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((o) => {
      o === null ? this.childListChanged = !0 : this.attributesChanged.add(o);
    });
  }
}
class Gl extends Oi {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(t) {
    super(), this.hookName = t;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new Gl(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const t = new Gl(this.hookName);
    return this.forEach((n, r) => {
      t.set(r, n);
    }), t;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(t = document, n = {}, r) {
    const o = n[this.hookName];
    let i;
    return o !== void 0 ? i = o.createDom(this) : i = document.createElement(this.hookName), i.setAttribute("data-yjs-hook", this.hookName), r !== void 0 && r._createAssociation(i, this), i;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(t) {
    t.writeTypeRef(f4), t.writeKey(this.hookName);
  }
}
const YN = (e) => new Gl(e.readKey());
class yn extends uo {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const t = this._item ? this._item.next : null;
    return t ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      t.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const t = this._item ? this._item.prev : null;
    return t ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      t.content.type
    ) : null;
  }
  _copy() {
    return new yn();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const t = new yn();
    return t.applyDelta(this.toDelta()), t;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(t = document, n, r) {
    const o = t.createTextNode(this.toString());
    return r !== void 0 && r._createAssociation(o, this), o;
  }
  toString() {
    return this.toDelta().map((t) => {
      const n = [];
      for (const o in t.attributes) {
        const i = [];
        for (const s in t.attributes[o])
          i.push({ key: s, value: t.attributes[o][s] });
        i.sort((s, a) => s.key < a.key ? -1 : 1), n.push({ nodeName: o, attrs: i });
      }
      n.sort((o, i) => o.nodeName < i.nodeName ? -1 : 1);
      let r = "";
      for (let o = 0; o < n.length; o++) {
        const i = n[o];
        r += `<${i.nodeName}`;
        for (let s = 0; s < i.attrs.length; s++) {
          const a = i.attrs[s];
          r += ` ${a.key}="${a.value}"`;
        }
        r += ">";
      }
      r += t.insert;
      for (let o = n.length - 1; o >= 0; o--)
        r += `</${n[o].nodeName}>`;
      return r;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(t) {
    t.writeTypeRef(h4);
  }
}
const KN = (e) => new yn();
class mp {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(t, n) {
    this.id = t, this.length = n;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw Dn();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(t, n, r) {
    throw Dn();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(t, n) {
    throw Dn();
  }
}
const QN = 0;
class In extends mp {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.constructor !== t.constructor ? !1 : (this.length += t.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(t, n) {
    n > 0 && (this.id.clock += n, this.length -= n), Ik(t.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    t.writeInfo(QN), t.writeLen(this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(t, n) {
    return null;
  }
}
class ua {
  /**
   * @param {Uint8Array} content
   */
  constructor(t) {
    this.content = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ua(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(t) {
    throw Dn();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    t.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
const ZN = (e) => new ua(e.readBuf());
class Ws {
  /**
   * @param {number} len
   */
  constructor(t) {
    this.len = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new Ws(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(t) {
    const n = new Ws(this.len - t);
    return this.len = t, n;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.len += t.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, n) {
    Fs(t.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    t.writeLen(this.len - n);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const XN = (e) => new Ws(e.readLen()), Qk = (e, t) => new bo({ guid: e, ...t, shouldLoad: t.shouldLoad || t.autoLoad || !1 });
class da {
  /**
   * @param {Doc} doc
   */
  constructor(t) {
    t._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = t;
    const n = {};
    this.opts = n, t.gc || (n.gc = !1), t.autoLoad && (n.autoLoad = !0), t.meta !== null && (n.meta = t.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new da(Qk(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(t) {
    throw Dn();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, n) {
    this.doc._item = n, t.subdocsAdded.add(this.doc), this.doc.shouldLoad && t.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
    t.subdocsAdded.has(this.doc) ? t.subdocsAdded.delete(this.doc) : t.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    t.writeString(this.doc.guid), t.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
const JN = (e) => new da(Qk(e.readString(), e.readAny()));
class Qo {
  /**
   * @param {Object} embed
   */
  constructor(t) {
    this.embed = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new Qo(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(t) {
    throw Dn();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    t.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
const e4 = (e) => new Qo(e.readJSON());
class yt {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(t, n) {
    this.key = t, this.value = n;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new yt(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(t) {
    throw Dn();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(t, n) {
    const r = (
      /** @type {YText} */
      n.parent
    );
    r._searchMarker = null, r._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    t.writeKey(this.key), t.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const t4 = (e) => new yt(e.readKey(), e.readJSON());
class Yl {
  /**
   * @param {Array<any>} arr
   */
  constructor(t) {
    this.arr = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new Yl(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(t) {
    const n = new Yl(this.arr.slice(t));
    return this.arr = this.arr.slice(0, t), n;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.arr = this.arr.concat(t.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    const r = this.arr.length;
    t.writeLen(r - n);
    for (let o = n; o < r; o++) {
      const i = this.arr[o];
      t.writeString(i === void 0 ? "undefined" : JSON.stringify(i));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
}
const n4 = (e) => {
  const t = e.readLen(), n = [];
  for (let r = 0; r < t; r++) {
    const o = e.readString();
    o === "undefined" ? n.push(void 0) : n.push(JSON.parse(o));
  }
  return new Yl(n);
}, r4 = Hl("node_env") === "development";
class Wo {
  /**
   * @param {Array<any>} arr
   */
  constructor(t) {
    this.arr = t, r4 && qE(t);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new Wo(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(t) {
    const n = new Wo(this.arr.slice(t));
    return this.arr = this.arr.slice(0, t), n;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.arr = this.arr.concat(t.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    const r = this.arr.length;
    t.writeLen(r - n);
    for (let o = n; o < r; o++) {
      const i = this.arr[o];
      t.writeAny(i);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
const o4 = (e) => {
  const t = e.readLen(), n = [];
  for (let r = 0; r < t; r++)
    n.push(e.readAny());
  return new Wo(n);
};
class Qn {
  /**
   * @param {string} str
   */
  constructor(t) {
    this.str = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new Qn(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(t) {
    const n = new Qn(this.str.slice(t));
    this.str = this.str.slice(0, t);
    const r = this.str.charCodeAt(t - 1);
    return r >= 55296 && r <= 56319 && (this.str = this.str.slice(0, t - 1) + "", n.str = "" + n.str.slice(1)), n;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.str += t.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    t.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const i4 = (e) => new Qn(e.readString()), s4 = [
  BN,
  HN,
  zN,
  WN,
  qN,
  YN,
  KN
], a4 = 0, l4 = 1, c4 = 2, u4 = 3, d4 = 4, f4 = 5, h4 = 6;
class er {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(t) {
    this.type = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new er(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(t) {
    throw Dn();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(t) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(t, n) {
    this.type._integrate(t.doc, n);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(t) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (t.beforeState.get(n.id.client) || 0) && t._mergeStructs.push(n) : n.delete(t), n = n.right;
    this.type._map.forEach((r) => {
      r.deleted ? r.id.clock < (t.beforeState.get(r.id.client) || 0) && t._mergeStructs.push(r) : r.delete(t);
    }), t.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(t) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(t, !0), n = n.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (r) => {
        for (; r !== null; )
          r.gc(t, !0), r = r.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    this.type._write(t);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const p4 = (e) => new er(s4[e.readTypeRef()](e)), xf = (e, t) => {
  let n = t, r = 0, o;
  do
    r > 0 && (n = ye(n.client, n.clock + r)), o = Ei(e, n), r = n.clock - o.id.clock, n = o.redone;
  while (n !== null && o instanceof ze);
  return {
    item: o,
    diff: r
  };
}, gp = (e, t) => {
  for (; e !== null && e.keep !== t; )
    e.keep = t, e = /** @type {AbstractType<any>} */
    e.parent._item;
}, Kl = (e, t, n) => {
  const { client: r, clock: o } = t.id, i = new ze(
    ye(r, o + n),
    t,
    ye(r, o + n - 1),
    t.right,
    t.rightOrigin,
    t.parent,
    t.parentSub,
    t.content.splice(n)
  );
  return t.deleted && i.markDeleted(), t.keep && (i.keep = !0), t.redone !== null && (i.redone = ye(t.redone.client, t.redone.clock + n)), t.right = i, i.right !== null && (i.right.left = i), e._mergeStructs.push(i), i.parentSub !== null && i.right === null && i.parent._map.set(i.parentSub, i), t.length = n, i;
}, Y0 = (e, t) => qh(
  e,
  /** @param {StackItem} s */
  (n) => zi(n.deletions, t)
), Zk = (e, t, n, r, o, i) => {
  const s = e.doc, a = s.store, l = s.clientID, c = t.redone;
  if (c !== null)
    return nn(e, c);
  let u = (
    /** @type {AbstractType<any>} */
    t.parent._item
  ), d = null, f;
  if (u !== null && u.deleted === !0) {
    if (u.redone === null && (!n.has(u) || Zk(e, u, n, r, o, i) === null))
      return null;
    for (; u.redone !== null; )
      u = nn(e, u.redone);
  }
  const h = u === null ? (
    /** @type {AbstractType<any>} */
    t.parent
  ) : (
    /** @type {ContentType} */
    u.content.type
  );
  if (t.parentSub === null) {
    for (d = t.left, f = t; d !== null; ) {
      let y = d;
      for (; y !== null && /** @type {AbstractType<any>} */
      y.parent._item !== u; )
        y = y.redone === null ? null : nn(e, y.redone);
      if (y !== null && /** @type {AbstractType<any>} */
      y.parent._item === u) {
        d = y;
        break;
      }
      d = d.left;
    }
    for (; f !== null; ) {
      let y = f;
      for (; y !== null && /** @type {AbstractType<any>} */
      y.parent._item !== u; )
        y = y.redone === null ? null : nn(e, y.redone);
      if (y !== null && /** @type {AbstractType<any>} */
      y.parent._item === u) {
        f = y;
        break;
      }
      f = f.right;
    }
  } else if (f = null, t.right && !o) {
    for (d = t; d !== null && d.right !== null && (d.right.redone || zi(r, d.right.id) || Y0(i.undoStack, d.right.id) || Y0(i.redoStack, d.right.id)); )
      for (d = d.right; d.redone; ) d = nn(e, d.redone);
    if (d && d.right !== null)
      return null;
  } else
    d = h._map.get(t.parentSub) || null;
  const p = ft(a, l), m = ye(l, p), b = new ze(
    m,
    d,
    d && d.lastId,
    f,
    f && f.id,
    h,
    t.parentSub,
    t.content.copy()
  );
  return t.redone = m, gp(b, !0), b.integrate(e, 0), b;
};
class ze extends mp {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(t, n, r, o, i, s, a, l) {
    super(t, l.getLength()), this.origin = r, this.left = n, this.right = o, this.rightOrigin = i, this.parent = s, this.parentSub = a, this.redone = null, this.content = l, this.info = this.content.isCountable() ? k0 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(t) {
    (this.info & Qu) > 0 !== t && (this.info ^= Qu);
  }
  get marker() {
    return (this.info & Qu) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & E0) > 0;
  }
  set keep(t) {
    this.keep !== t && (this.info ^= E0);
  }
  get countable() {
    return (this.info & k0) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & Ku) > 0;
  }
  set deleted(t) {
    this.deleted !== t && (this.info ^= Ku);
  }
  markDeleted() {
    this.info |= Ku;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(t, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= ft(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= ft(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === yi && this.id.client !== this.parent.client && this.parent.clock >= ft(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = H0(t, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = nn(t, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === In || this.right && this.right.constructor === In)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === ze ? (this.parent = this.left.parent, this.parentSub = this.left.parentSub) : this.right && this.right.constructor === ze && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === yi) {
      const r = Ei(n, this.parent);
      r.constructor === In ? this.parent = null : this.parent = /** @type {ContentType} */
      r.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(t, n) {
    if (n > 0 && (this.id.clock += n, this.left = H0(t, t.doc.store, ye(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let r = this.left, o;
        if (r !== null)
          o = r.right;
        else if (this.parentSub !== null)
          for (o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; o !== null && o.left !== null; )
            o = o.left;
        else
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        const i = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
        for (; o !== null && o !== this.right; ) {
          if (s.add(o), i.add(o), hi(this.origin, o.origin)) {
            if (o.id.client < this.id.client)
              r = o, i.clear();
            else if (hi(this.rightOrigin, o.rightOrigin))
              break;
          } else if (o.origin !== null && s.has(Ei(t.doc.store, o.origin)))
            i.has(Ei(t.doc.store, o.origin)) || (r = o, i.clear());
          else
            break;
          o = o.right;
        }
        this.left = r;
      }
      if (this.left !== null) {
        const r = this.left.right;
        this.right = r, this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null)
          for (r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = r;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(t)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), Ik(t.doc.store, this), this.content.integrate(t, this), U0(
        t,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(t);
    } else
      new In(this.id, this.length).integrate(t, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let t = this.right;
    for (; t !== null && t.deleted; )
      t = t.right;
    return t;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let t = this.left;
    for (; t !== null && t.deleted; )
      t = t.left;
    return t;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : ye(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(t) {
    if (this.constructor === t.constructor && hi(t.origin, this.lastId) && this.right === t && hi(this.rightOrigin, t.rightOrigin) && this.id.client === t.id.client && this.id.clock + this.length === t.id.clock && this.deleted === t.deleted && this.redone === null && t.redone === null && this.content.constructor === t.content.constructor && this.content.mergeWith(t.content)) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return n && n.forEach((r) => {
        r.p === t && (r.p = this, !this.deleted && this.countable && (r.index -= this.length));
      }), t.keep && (this.keep = !0), this.right = t.right, this.right !== null && (this.right.left = this), this.length += t.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(t) {
    if (!this.deleted) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), Fs(t.deleteSet, this.id.client, this.id.clock, this.length), U0(t, n, this.parentSub), this.content.delete(t);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(t, n) {
    if (!this.deleted)
      throw Gt();
    this.content.gc(t), n ? yN(t, this, new In(this.id, this.length)) : this.content = new Ws(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(t, n) {
    const r = n > 0 ? ye(this.id.client, this.id.clock + n - 1) : this.origin, o = this.rightOrigin, i = this.parentSub, s = this.content.getRef() & Fc | (r === null ? 0 : Wt) | // origin is defined
    (o === null ? 0 : $r) | // right origin is defined
    (i === null ? 0 : Rs);
    if (t.writeInfo(s), r !== null && t.writeLeftID(r), o !== null && t.writeRightID(o), r === null && o === null) {
      const a = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (a._item !== void 0) {
        const l = a._item;
        if (l === null) {
          const c = Us(a);
          t.writeParentInfo(!0), t.writeString(c);
        } else
          t.writeParentInfo(!1), t.writeLeftID(l.id);
      } else a.constructor === String ? (t.writeParentInfo(!0), t.writeString(a)) : a.constructor === yi ? (t.writeParentInfo(!1), t.writeLeftID(a)) : Gt();
      i !== null && t.writeString(i);
    }
    this.content.write(t, n);
  }
}
const Xk = (e, t) => m4[t & Fc](e), m4 = [
  () => {
    Gt();
  },
  // GC is not ItemContent
  XN,
  // 1
  n4,
  // 2
  ZN,
  // 3
  i4,
  // 4
  e4,
  // 5
  t4,
  // 6
  p4,
  // 7
  o4,
  // 8
  JN,
  // 9
  () => {
    Gt();
  }
  // 10 - Skip is not ItemContent
], g4 = 10;
class Nn extends mp {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(t) {
    return this.constructor !== t.constructor ? !1 : (this.length += t.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(t, n) {
    Gt();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(t, n) {
    t.writeInfo(g4), Le(t.restEncoder, this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(t, n) {
    return null;
  }
}
const Jk = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), e2 = "__ $YJS$ __";
Jk[e2] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
Jk[e2] = !0;
const b4 = () => {
  let e = !0;
  return (t, n) => {
    if (e) {
      e = !1;
      try {
        t();
      } finally {
        e = !0;
      }
    } else n !== void 0 && n();
  };
}, y4 = /[\uD800-\uDBFF]/, E4 = /[\uDC00-\uDFFF]/, k4 = (e, t) => {
  let n = 0, r = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; )
    n++;
  for (n > 0 && y4.test(e[n - 1]) && n--; r + n < e.length && r + n < t.length && e[e.length - r - 1] === t[t.length - r - 1]; )
    r++;
  return r > 0 && E4.test(e[e.length - r]) && r--, {
    index: n,
    remove: e.length - n - r,
    insert: t.slice(n, t.length - r)
  };
}, C4 = k4, Xe = new we("y-sync"), pr = new we("y-undo"), Fa = new we("yjs-cursor"), mr = (e, t) => e >>> t | e << 32 - t, T4 = (e) => mr(e, 2) ^ mr(e, 13) ^ mr(e, 22), x4 = (e) => mr(e, 6) ^ mr(e, 11) ^ mr(e, 25), w4 = (e) => mr(e, 7) ^ mr(e, 18) ^ e >>> 3, v4 = (e) => mr(e, 17) ^ mr(e, 19) ^ e >>> 10, S4 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), _4 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
class A4 {
  constructor() {
    const t = new ArrayBuffer(320);
    this._H = new Uint32Array(t, 0, 8), this._H.set(_4), this._W = new Uint32Array(t, 64, 64);
  }
  _updateHash() {
    const t = this._H, n = this._W;
    for (let d = 16; d < 64; d++)
      n[d] = v4(n[d - 2]) + n[d - 7] + w4(n[d - 15]) + n[d - 16];
    let r = t[0], o = t[1], i = t[2], s = t[3], a = t[4], l = t[5], c = t[6], u = t[7];
    for (let d = 0, f, h; d < 64; d++)
      f = u + x4(a) + (a & l ^ ~a & c) + S4[d] + n[d] >>> 0, h = T4(r) + (r & o ^ r & i ^ o & i) >>> 0, u = c, c = l, l = a, a = s + f >>> 0, s = i, i = o, o = r, r = f + h >>> 0;
    t[0] += r, t[1] += o, t[2] += i, t[3] += s, t[4] += a, t[5] += l, t[6] += c, t[7] += u;
  }
  /**
   * Returns a 32-byte hash.
   *
   * @param {Uint8Array} data
   */
  digest(t) {
    let n = 0;
    for (; n + 56 <= t.length; ) {
      let s = 0;
      for (; s < 16 && n + 3 < t.length; s++)
        this._W[s] = t[n++] << 24 | t[n++] << 16 | t[n++] << 8 | t[n++];
      if (n % 64 !== 0) {
        for (this._W.fill(0, s, 16); n < t.length; )
          this._W[s] |= t[n] << (3 - n % 4) * 8, n++;
        this._W[s] |= Wt << (3 - n % 4) * 8;
      }
      this._updateHash();
    }
    const r = n % 64 !== 0;
    this._W.fill(0, 0, 16);
    let o = 0;
    for (; n < t.length; o++)
      for (let s = 3; s >= 0 && n < t.length; s--)
        this._W[o] |= t[n++] << s * 8;
    r || (this._W[o - (n % 4 === 0 ? 0 : 1)] |= Wt << (3 - n % 4) * 8), this._W[14] = t.byteLength / n3, this._W[15] = t.byteLength * 8, this._updateHash();
    const i = new Uint8Array(32);
    for (let s = 0; s < this._H.length; s++)
      for (let a = 0; a < 4; a++)
        i[s * 4 + a] = this._H[s] >>> (3 - a) * 8;
    return i;
  }
}
const I4 = (e) => new A4().digest(e), N4 = (e) => {
  for (let n = 6; n < e.length; n++)
    e[n % 6] = e[n % 6] ^ e[n];
  return e.slice(0, 6);
}, M4 = (e) => rI(N4(I4(iI(e)))), Ql = (e, t) => t === void 0 ? !e.deleted : t.sv.has(e.id.client) && /** @type {number} */
t.sv.get(e.id.client) > e.id.clock && !zi(t.ds, e.id), L4 = [{ light: "#ecd44433", dark: "#ecd444" }], O4 = (e, t, n) => {
  if (!e.has(n)) {
    if (e.size < t.length) {
      const r = Vo();
      e.forEach((o) => r.add(o)), t = t.filter((o) => !r.has(o));
    }
    e.set(n, R3(t));
  }
  return (
    /** @type {ColorDef} */
    e.get(n)
  );
}, D4 = (e, {
  colors: t = L4,
  colorMapping: n = /* @__PURE__ */ new Map(),
  permanentUserData: r = null,
  onFirstRender: o = () => {
  },
  mapping: i
} = {}) => {
  let s = !1;
  const a = new P4(e, i), l = new me({
    props: {
      editable: (c) => {
        const u = Xe.getState(c);
        return u.snapshot == null && u.prevSnapshot == null;
      }
    },
    key: Xe,
    state: {
      /**
       * @returns {any}
       */
      init: (c, u) => ({
        type: e,
        doc: e.doc,
        binding: a,
        snapshot: null,
        prevSnapshot: null,
        isChangeOrigin: !1,
        isUndoRedoOperation: !1,
        addToHistory: !0,
        colors: t,
        colorMapping: n,
        permanentUserData: r
      }),
      apply: (c, u) => {
        const d = c.getMeta(Xe);
        if (d !== void 0) {
          u = Object.assign({}, u);
          for (const f in d)
            u[f] = d[f];
        }
        return u.addToHistory = c.getMeta("addToHistory") !== !1, u.isChangeOrigin = d !== void 0 && !!d.isChangeOrigin, u.isUndoRedoOperation = d !== void 0 && !!d.isChangeOrigin && !!d.isUndoRedoOperation, a.prosemirrorView !== null && d !== void 0 && (d.snapshot != null || d.prevSnapshot != null) && np(0, () => {
          a.prosemirrorView != null && (d.restore == null ? a._renderSnapshot(
            d.snapshot,
            d.prevSnapshot,
            u
          ) : (a._renderSnapshot(
            d.snapshot,
            d.snapshot,
            u
          ), delete u.restore, delete u.snapshot, delete u.prevSnapshot, a.mux(() => {
            a._prosemirrorChanged(
              a.prosemirrorView.state.doc
            );
          })));
        }), u;
      }
    },
    view: (c) => (a.initView(c), i == null && a._forceRerender(), o(), {
      update: () => {
        const u = l.getState(c.state);
        if (u.snapshot == null && u.prevSnapshot == null && // If the content doesn't change initially, we don't render anything to Yjs
        // If the content was cleared by a user action, we want to catch the change and
        // represent it in Yjs
        (s || c.state.doc.content.findDiffStart(
          c.state.doc.type.createAndFill().content
        ) !== null)) {
          if (s = !0, u.addToHistory === !1 && !u.isChangeOrigin) {
            const d = pr.getState(c.state), f = d && d.undoManager;
            f && f.stopCapturing();
          }
          a.mux(() => {
            u.doc.transact((d) => {
              d.meta.set("addToHistory", u.addToHistory), a._prosemirrorChanged(c.state.doc);
            }, Xe);
          });
        }
      },
      destroy: () => {
        a.destroy();
      }
    })
  });
  return l;
}, R4 = (e, t, n) => {
  if (t !== null && t.anchor !== null && t.head !== null)
    if (t.type === "all")
      e.setSelection(new yh(e.doc));
    else if (t.type === "node") {
      const r = Do(
        n.doc,
        n.type,
        t.anchor,
        n.mapping
      );
      e.setSelection(cn.create(e.doc, r));
    } else {
      const r = Do(
        n.doc,
        n.type,
        t.anchor,
        n.mapping
      ), o = Do(
        n.doc,
        n.type,
        t.head,
        n.mapping
      );
      if (r !== null && o !== null) {
        const i = pe.between(e.doc.resolve(r), e.doc.resolve(o));
        e.setSelection(i);
      }
    }
}, Zl = (e, t) => ({
  type: (
    /** @type {any} */
    t.selection.jsonID
  ),
  anchor: Ys(
    t.selection.anchor,
    e.type,
    e.mapping
  ),
  head: Ys(
    t.selection.head,
    e.type,
    e.mapping
  )
});
class P4 {
  /**
   * @param {Y.XmlFragment} yXmlFragment The bind source
   * @param {ProsemirrorMapping} mapping
   */
  constructor(t, n = /* @__PURE__ */ new Map()) {
    this.type = t, this.prosemirrorView = null, this.mux = b4(), this.mapping = n, this.isOMark = /* @__PURE__ */ new Map(), this._observeFunction = this._typeChanged.bind(this), this.doc = t.doc, this.beforeTransactionSelection = null, this.beforeAllTransactions = () => {
      this.beforeTransactionSelection === null && this.prosemirrorView != null && (this.beforeTransactionSelection = Zl(
        this,
        this.prosemirrorView.state
      ));
    }, this.afterAllTransactions = () => {
      this.beforeTransactionSelection = null;
    }, this._domSelectionInView = null;
  }
  /**
   * Create a transaction for changing the prosemirror state.
   *
   * @returns
   */
  get _tr() {
    return this.prosemirrorView.state.tr.setMeta("addToHistory", !1);
  }
  _isLocalCursorInView() {
    return this.prosemirrorView.hasFocus() ? (WE && this._domSelectionInView === null && (np(0, () => {
      this._domSelectionInView = null;
    }), this._domSelectionInView = this._isDomSelectionInView()), this._domSelectionInView) : !1;
  }
  _isDomSelectionInView() {
    const t = this.prosemirrorView._root.getSelection();
    if (t == null || t.anchorNode == null) return !1;
    const n = this.prosemirrorView._root.createRange();
    n.setStart(t.anchorNode, t.anchorOffset), n.setEnd(t.focusNode, t.focusOffset), n.getClientRects().length === 0 && n.startContainer && n.collapsed && n.selectNodeContents(n.startContainer);
    const o = n.getBoundingClientRect(), i = aa.documentElement;
    return o.bottom >= 0 && o.right >= 0 && o.left <= (window.innerWidth || i.clientWidth || 0) && o.top <= (window.innerHeight || i.clientHeight || 0);
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   */
  renderSnapshot(t, n) {
    n || (n = _k(bk(), /* @__PURE__ */ new Map())), this.prosemirrorView.dispatch(
      this._tr.setMeta(Xe, { snapshot: t, prevSnapshot: n })
    );
  }
  unrenderSnapshot() {
    this.mapping.clear(), this.mux(() => {
      const t = this.type.toArray().map(
        (r) => bl(
          /** @type {Y.XmlElement} */
          r,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((r) => r !== null), n = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new lt(be.from(t), 0, 0)
      );
      n.setMeta(Xe, { snapshot: null, prevSnapshot: null }), this.prosemirrorView.dispatch(n);
    });
  }
  _forceRerender() {
    this.mapping.clear(), this.mux(() => {
      const t = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection, n = this.type.toArray().map(
        (o) => bl(
          /** @type {Y.XmlElement} */
          o,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((o) => o !== null), r = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new lt(be.from(n), 0, 0)
      );
      if (t) {
        const o = Br(Kn(t.anchor, 0), r.doc.content.size), i = Br(Kn(t.head, 0), r.doc.content.size);
        r.setSelection(pe.create(r.doc, o, i));
      }
      this.prosemirrorView.dispatch(
        r.setMeta(Xe, { isChangeOrigin: !0, binding: this })
      );
    });
  }
  /**
   * @param {Y.Snapshot|Uint8Array} snapshot
   * @param {Y.Snapshot|Uint8Array} prevSnapshot
   * @param {Object} pluginState
   */
  _renderSnapshot(t, n, r) {
    let o = this.doc, i = this.type;
    if (t || (t = rd(this.doc)), t instanceof Uint8Array || n instanceof Uint8Array)
      if ((!(t instanceof Uint8Array) || !(n instanceof Uint8Array)) && Gt(), o = new bo({ gc: !1 }), Vl(o, n), n = rd(o), Vl(o, t), t = rd(o), i._item === null) {
        const s = Array.from(this.doc.share.keys()).find(
          (a) => this.doc.share.get(a) === this.type
        );
        i = o.getXmlFragment(s);
      } else {
        const s = o.store.clients.get(i._item.id.client) ?? [], a = Bn(
          s,
          i._item.id.clock
        );
        i = /** @type {Y.XmlFragment} */
        /** @type {Y.ContentType} */
        /** @type {Y.Item} */
        s[a].content.type;
      }
    this.mapping.clear(), this.mux(() => {
      o.transact((s) => {
        const a = r.permanentUserData;
        a && a.dss.forEach((d) => {
          co(s, d, (f) => {
          });
        });
        const l = (d, f) => {
          const h = d === "added" ? a.getUserByClientId(f.client) : a.getUserByDeletedId(f);
          return {
            user: h,
            type: d,
            color: O4(
              r.colorMapping,
              r.colors,
              h
            )
          };
        }, c = $k(
          i,
          new lp(n.ds, t.sv)
        ).map((d) => !d._item.deleted || Ql(d._item, t) || Ql(d._item, n) ? bl(
          d,
          this.prosemirrorView.state.schema,
          { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() },
          t,
          n,
          l
        ) : null).filter((d) => d !== null), u = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new lt(be.from(c), 0, 0)
        );
        this.prosemirrorView.dispatch(
          u.setMeta(Xe, { isChangeOrigin: !0 })
        );
      }, Xe);
    });
  }
  /**
   * @param {Array<Y.YEvent<any>>} events
   * @param {Y.Transaction} transaction
   */
  _typeChanged(t, n) {
    if (this.prosemirrorView == null) return;
    const r = Xe.getState(this.prosemirrorView.state);
    if (t.length === 0 || r.snapshot != null || r.prevSnapshot != null) {
      this.renderSnapshot(r.snapshot, r.prevSnapshot);
      return;
    }
    this.mux(() => {
      const o = (a, l) => this.mapping.delete(l);
      co(
        n,
        n.deleteSet,
        (a) => {
          if (a.constructor === ze) {
            const l = (
              /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              a.content.type
            );
            l && this.mapping.delete(l);
          }
        }
      ), n.changed.forEach(o), n.changedParentTypes.forEach(o);
      const i = this.type.toArray().map(
        (a) => t2(
          /** @type {Y.XmlElement | Y.XmlHook} */
          a,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((a) => a !== null);
      let s = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new lt(be.from(i), 0, 0)
      );
      R4(s, this.beforeTransactionSelection, this), s = s.setMeta(Xe, { isChangeOrigin: !0, isUndoRedoOperation: n.origin instanceof Lk }), this.beforeTransactionSelection !== null && this._isLocalCursorInView() && s.scrollIntoView(), this.prosemirrorView.dispatch(s);
    });
  }
  /**
   * @param {import('prosemirror-model').Node} doc
   */
  _prosemirrorChanged(t) {
    this.doc.transact(() => {
      vf(this.doc, this.type, t, this), this.beforeTransactionSelection = Zl(
        this,
        this.prosemirrorView.state
      );
    }, Xe);
  }
  /**
   * View is ready to listen to changes. Register observers.
   * @param {any} prosemirrorView
   */
  initView(t) {
    this.prosemirrorView != null && this.destroy(), this.prosemirrorView = t, this.doc.on("beforeAllTransactions", this.beforeAllTransactions), this.doc.on("afterAllTransactions", this.afterAllTransactions), this.type.observeDeep(this._observeFunction);
  }
  destroy() {
    this.prosemirrorView != null && (this.prosemirrorView = null, this.type.unobserveDeep(this._observeFunction), this.doc.off("beforeAllTransactions", this.beforeAllTransactions), this.doc.off("afterAllTransactions", this.afterAllTransactions));
  }
}
const t2 = (e, t, n, r, o, i) => {
  const s = (
    /** @type {PModel.Node} */
    n.mapping.get(e)
  );
  if (s === void 0) {
    if (e instanceof Nt)
      return bl(
        e,
        t,
        n,
        r,
        o,
        i
      );
    throw Dn();
  }
  return s;
}, bl = (e, t, n, r, o, i) => {
  const s = [], a = (l) => {
    var c, u;
    if (l instanceof Nt) {
      const d = t2(
        l,
        t,
        n,
        r,
        o,
        i
      );
      d !== null && s.push(d);
    } else {
      const d = (
        /** @type {Y.ContentType} */
        (u = (c = l._item.right) == null ? void 0 : c.content) == null ? void 0 : u.type
      );
      d instanceof uo && !d._item.deleted && d._item.id.client === d.doc.clientID && (l.applyDelta([
        { retain: l.length },
        ...d.toDelta()
      ]), d.doc.transact((h) => {
        d._item.delete(h);
      }));
      const f = B4(
        l,
        t,
        n,
        r,
        o,
        i
      );
      f !== null && f.forEach((h) => {
        h !== null && s.push(h);
      });
    }
  };
  r === void 0 || o === void 0 ? e.toArray().forEach(a) : $k(e, new lp(o.ds, r.sv)).forEach(a);
  try {
    const l = e.getAttributes(r);
    r !== void 0 && (Ql(
      /** @type {Y.Item} */
      e._item,
      r
    ) ? Ql(
      /** @type {Y.Item} */
      e._item,
      o
    ) || (l.ychange = i ? i(
      "added",
      /** @type {Y.Item} */
      e._item.id
    ) : { type: "added" }) : l.ychange = i ? i(
      "removed",
      /** @type {Y.Item} */
      e._item.id
    ) : { type: "removed" });
    const c = t.node(e.nodeName, l, s);
    return n.mapping.set(e, c), c;
  } catch {
    return e.doc.transact((c) => {
      e._item.delete(c);
    }, Xe), n.mapping.delete(e), null;
  }
}, B4 = (e, t, n, r, o, i) => {
  const s = [], a = e.toDelta(r, o, i);
  try {
    for (let l = 0; l < a.length; l++) {
      const c = a[l];
      s.push(t.text(c.insert, V4(c.attributes, t)));
    }
  } catch {
    return e.doc.transact((c) => {
      e._item.delete(c);
    }, Xe), null;
  }
  return s;
}, $4 = (e, t) => {
  const n = new yn(), r = e.map((o) => ({
    // @ts-ignore
    insert: o.text,
    attributes: o2(o.marks, t)
  }));
  return n.applyDelta(r), t.mapping.set(n, e), n;
}, H4 = (e, t) => {
  const n = new Nt(e.type.name);
  for (const r in e.attrs) {
    const o = e.attrs[r];
    o !== null && r !== "ychange" && n.setAttribute(r, o);
  }
  return n.insert(
    0,
    Zc(e).map(
      (r) => wf(r, t)
    )
  ), t.mapping.set(n, e), n;
}, wf = (e, t) => e instanceof Array ? $4(e, t) : H4(e, t), K0 = (e) => typeof e == "object" && e !== null, bp = (e, t) => {
  const n = Object.keys(e).filter((o) => e[o] !== null);
  let r = n.length === (t == null ? 0 : Object.keys(t).filter((o) => t[o] !== null).length);
  for (let o = 0; o < n.length && r; o++) {
    const i = n[o], s = e[i], a = t[i];
    r = i === "ychange" || s === a || K0(s) && K0(a) && bp(s, a);
  }
  return r;
}, Zc = (e) => {
  const t = e.content.content, n = [];
  for (let r = 0; r < t.length; r++) {
    const o = t[r];
    if (o.isText) {
      const i = [];
      for (let s = t[r]; r < t.length && s.isText; s = t[++r])
        i.push(s);
      r--, n.push(i);
    } else
      n.push(o);
  }
  return n;
}, n2 = (e, t) => {
  const n = e.toDelta();
  return n.length === t.length && n.every(
    /** @type {(d:any,i:number) => boolean} */
    (r, o) => r.insert === /** @type {any} */
    t[o].text && zE(r.attributes || {}).length === t[o].marks.length && Ui(r.attributes, (i, s) => {
      var c;
      const a = r2(s), l = t[o].marks;
      return bp(i, (c = l.find(
        /** @param {any} mark */
        (u) => u.type.name === a
      )) == null ? void 0 : c.attrs);
    })
  );
}, Gs = (e, t) => {
  if (e instanceof Nt && !(t instanceof Array) && Sf(e, t)) {
    const n = Zc(t);
    return e._length === n.length && bp(e.getAttributes(), t.attrs) && e.toArray().every(
      (r, o) => Gs(r, n[o])
    );
  }
  return e instanceof yn && t instanceof Array && n2(e, t);
}, Xl = (e, t) => e === t || e instanceof Array && t instanceof Array && e.length === t.length && e.every(
  (n, r) => t[r] === n
), Q0 = (e, t, n) => {
  const r = e.toArray(), o = Zc(t), i = o.length, s = r.length, a = Br(s, i);
  let l = 0, c = 0, u = !1;
  for (; l < a; l++) {
    const d = r[l], f = o[l];
    if (Xl(n.mapping.get(d), f))
      u = !0;
    else if (!Gs(d, f))
      break;
  }
  for (; l + c < a; c++) {
    const d = r[s - c - 1], f = o[i - c - 1];
    if (Xl(n.mapping.get(d), f))
      u = !0;
    else if (!Gs(d, f))
      break;
  }
  return {
    equalityFactor: l + c,
    foundMappedChild: u
  };
}, F4 = (e) => {
  let t = "", n = e._start;
  const r = {};
  for (; n !== null; )
    n.deleted || (n.countable && n.content instanceof Qn ? t += n.content.str : n.content instanceof yt && (r[n.content.key] = null)), n = n.right;
  return {
    str: t,
    nAttrs: r
  };
}, U4 = (e, t, n) => {
  n.mapping.set(e, t);
  const { nAttrs: r, str: o } = F4(e), i = t.map((c) => ({
    insert: (
      /** @type {any} */
      c.text
    ),
    attributes: Object.assign({}, r, o2(c.marks, n))
  })), { insert: s, remove: a, index: l } = C4(
    o,
    i.map((c) => c.insert).join("")
  );
  e.delete(l, a), e.insert(l, s), e.applyDelta(
    i.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))
  );
}, j4 = /(.*)(--[a-zA-Z0-9+/=]{8})$/, r2 = (e) => {
  var t;
  return ((t = j4.exec(e)) == null ? void 0 : t[1]) ?? e;
}, V4 = (e, t) => {
  const n = [];
  for (const r in e)
    n.push(t.mark(r2(r), e[r]));
  return n;
}, o2 = (e, t) => {
  const n = {};
  return e.forEach((r) => {
    if (r.type.name !== "ychange") {
      const o = Tr(t.isOMark, r.type, () => !r.type.excludes(r.type));
      n[o ? `${r.type.name}--${M4(r.toJSON())}` : r.type.name] = r.attrs;
    }
  }), n;
}, vf = (e, t, n, r) => {
  if (t instanceof Nt && t.nodeName !== n.type.name)
    throw new Error("node name mismatch!");
  if (r.mapping.set(t, n), t instanceof Nt) {
    const d = t.getAttributes(), f = n.attrs;
    for (const h in f)
      f[h] !== null ? d[h] !== f[h] && h !== "ychange" && t.setAttribute(h, f[h]) : t.removeAttribute(h);
    for (const h in d)
      f[h] === void 0 && t.removeAttribute(h);
  }
  const o = Zc(n), i = o.length, s = t.toArray(), a = s.length, l = Br(i, a);
  let c = 0, u = 0;
  for (; c < l; c++) {
    const d = s[c], f = o[c];
    if (!Xl(r.mapping.get(d), f))
      if (Gs(d, f))
        r.mapping.set(d, f);
      else
        break;
  }
  for (; u + c < l; u++) {
    const d = s[a - u - 1], f = o[i - u - 1];
    if (!Xl(r.mapping.get(d), f))
      if (Gs(d, f))
        r.mapping.set(d, f);
      else
        break;
  }
  e.transact(() => {
    for (; a - c - u > 0 && i - c - u > 0; ) {
      const f = s[c], h = o[c], p = s[a - u - 1], m = o[i - u - 1];
      if (f instanceof yn && h instanceof Array)
        n2(f, h) || U4(f, h, r), c += 1;
      else {
        let b = f instanceof Nt && Sf(f, h), y = p instanceof Nt && Sf(p, m);
        if (b && y) {
          const k = Q0(
            /** @type {Y.XmlElement} */
            f,
            /** @type {PModel.Node} */
            h,
            r
          ), C = Q0(
            /** @type {Y.XmlElement} */
            p,
            /** @type {PModel.Node} */
            m,
            r
          );
          k.foundMappedChild && !C.foundMappedChild ? y = !1 : !k.foundMappedChild && C.foundMappedChild || k.equalityFactor < C.equalityFactor ? b = !1 : y = !1;
        }
        b ? (vf(
          e,
          /** @type {Y.XmlFragment} */
          f,
          /** @type {PModel.Node} */
          h,
          r
        ), c += 1) : y ? (vf(
          e,
          /** @type {Y.XmlFragment} */
          p,
          /** @type {PModel.Node} */
          m,
          r
        ), u += 1) : (r.mapping.delete(t.get(c)), t.delete(c, 1), t.insert(c, [
          wf(h, r)
        ]), c += 1);
      }
    }
    const d = a - c - u;
    if (a === 1 && i === 0 && s[0] instanceof yn ? (r.mapping.delete(s[0]), s[0].delete(0, s[0].length)) : d > 0 && (t.slice(c, c + d).forEach((f) => r.mapping.delete(f)), t.delete(c, d)), c + u < i) {
      const f = [];
      for (let h = c; h < i - u; h++)
        f.push(wf(o[h], r));
      t.insert(c, f);
    }
  }, Xe);
}, Sf = (e, t) => !(t instanceof Array) && e.nodeName === t.type.name;
let Es = null;
const z4 = () => {
  const e = (
    /** @type {Map<EditorView, Map<any, any>>} */
    Es
  );
  Es = null, e.forEach((t, n) => {
    const r = n.state.tr, o = Xe.getState(n.state);
    o && o.binding && !o.binding.isDestroyed && (t.forEach((i, s) => {
      r.setMeta(s, i);
    }), n.dispatch(r));
  });
}, q4 = (e, t, n) => {
  Es || (Es = /* @__PURE__ */ new Map(), np(0, z4)), Tr(Es, e, On).set(t, n);
}, Ys = (e, t, n) => {
  if (e === 0)
    return nd(t, 0, t.length === 0 ? -1 : 0);
  let r = t._first === null ? null : (
    /** @type {Y.ContentType} */
    t._first.content.type
  );
  for (; r !== null && t !== r; ) {
    if (r instanceof yn) {
      if (r._length >= e)
        return nd(r, e, t.length === 0 ? -1 : 0);
      if (e -= r._length, r._item !== null && r._item.next !== null)
        r = /** @type {Y.ContentType} */
        r._item.next.content.type;
      else {
        do
          r = r._item === null ? null : r._item.parent, e--;
        while (r !== t && r !== null && r._item !== null && r._item.next === null);
        r !== null && r !== t && (r = r._item === null ? null : (
          /** @type {Y.ContentType} */
          /** @type Y.Item */
          r._item.next.content.type
        ));
      }
    } else {
      const o = (
        /** @type {any} */
        (n.get(r) || { nodeSize: 0 }).nodeSize
      );
      if (r._first !== null && e < o)
        r = /** @type {Y.ContentType} */
        r._first.content.type, e--;
      else {
        if (e === 1 && r._length === 0 && o > 1)
          return new Vs(r._item === null ? null : r._item.id, r._item === null ? Us(r) : null, null);
        if (e -= o, r._item !== null && r._item.next !== null)
          r = /** @type {Y.ContentType} */
          r._item.next.content.type;
        else {
          if (e === 0)
            return r = r._item === null ? r : r._item.parent, new Vs(r._item === null ? null : r._item.id, r._item === null ? Us(r) : null, null);
          do
            r = /** @type {Y.Item} */
            r._item.parent, e--;
          while (r !== t && /** @type {Y.Item} */
          r._item.next === null);
          r !== t && (r = /** @type {Y.ContentType} */
          /** @type {Y.Item} */
          /** @type {Y.Item} */
          r._item.next.content.type);
        }
      }
    }
    if (r === null)
      throw Gt();
    if (e === 0 && r.constructor !== yn && r !== t)
      return W4(r._item.parent, r._item);
  }
  return nd(t, t._length, t.length === 0 ? -1 : 0);
}, W4 = (e, t) => {
  let n = null, r = null;
  return e._item === null ? r = Us(e) : n = ye(e._item.id.client, e._item.id.clock), new Vs(n, r, t.id);
}, Do = (e, t, n, r) => {
  const o = gN(n, e);
  if (o === null || o.type !== t && !js(t, o.type._item))
    return null;
  let i = o.type, s = 0;
  if (i.constructor === yn)
    s = o.index;
  else if (i._item === null || !i._item.deleted) {
    let a = i._first, l = 0;
    for (; l < i._length && l < o.index && a !== null; ) {
      if (!a.deleted) {
        const c = (
          /** @type {Y.ContentType} */
          a.content.type
        );
        l++, c instanceof yn ? s += c._length : s += /** @type {any} */
        r.get(c).nodeSize;
      }
      a = /** @type {Y.Item} */
      a.right;
    }
    s += 1;
  }
  for (; i !== t && i._item !== null; ) {
    const a = i._item.parent;
    if (a._item === null || !a._item.deleted) {
      s += 1;
      let l = (
        /** @type {Y.AbstractType} */
        a._first
      );
      for (; l !== null; ) {
        const c = (
          /** @type {Y.ContentType} */
          l.content.type
        );
        if (c === i)
          break;
        l.deleted || (c instanceof yn ? s += c._length : s += /** @type {any} */
        r.get(c).nodeSize), l = l.right;
      }
    }
    i = /** @type {Y.AbstractType} */
    a;
  }
  return s - 1;
}, G4 = (e, t, n) => e !== t, Y4 = (e) => {
  const t = document.createElement("span");
  t.classList.add("ProseMirror-yjs-cursor"), t.setAttribute("style", `border-color: ${e.color}`);
  const n = document.createElement("div");
  n.setAttribute("style", `background-color: ${e.color}`), n.insertBefore(document.createTextNode(e.name), null);
  const r = document.createTextNode(""), o = document.createTextNode("");
  return t.insertBefore(r, null), t.insertBefore(n, null), t.insertBefore(o, null), t;
}, i2 = (e) => ({
  style: `background-color: ${e.color}70`,
  class: "ProseMirror-yjs-selection"
}), K4 = /^#[0-9a-fA-F]{6}$/, Z0 = (e, t, n, r, o) => {
  const i = Xe.getState(e), s = i.doc, a = [];
  return i.snapshot != null || i.prevSnapshot != null || i.binding.mapping.size === 0 ? kt.create(e.doc, []) : (t.getStates().forEach((l, c) => {
    if (n(s.clientID, c, l) && l.cursor != null) {
      const u = l.user || {};
      u.color == null ? u.color = "#ffa500" : K4.test(u.color) || console.warn("A user uses an unsupported color format", u), u.name == null && (u.name = `User: ${c}`);
      let d = Do(
        s,
        i.type,
        ys(l.cursor.anchor),
        i.binding.mapping
      ), f = Do(
        s,
        i.type,
        ys(l.cursor.head),
        i.binding.mapping
      );
      if (d !== null && f !== null) {
        const h = Kn(e.doc.content.size - 1, 0);
        d = Br(d, h), f = Br(f, h), a.push(
          Lt.widget(f, () => r(u, c), {
            key: c + "",
            side: 10
          })
        );
        const p = Br(d, f), m = Kn(d, f);
        a.push(
          Lt.inline(p, m, o(u, c), {
            inclusiveEnd: !0,
            inclusiveStart: !1
          })
        );
      }
    }
  }), kt.create(e.doc, a));
}, Q4 = (e, {
  awarenessStateFilter: t = G4,
  cursorBuilder: n = Y4,
  selectionBuilder: r = i2,
  getSelection: o = (s) => s.selection
} = {}, i = "cursor") => new me({
  key: Fa,
  state: {
    init(s, a) {
      return Z0(
        a,
        e,
        t,
        n,
        r
      );
    },
    apply(s, a, l, c) {
      const u = Xe.getState(c), d = s.getMeta(Fa);
      return u && u.isChangeOrigin || d && d.awarenessUpdated ? Z0(
        c,
        e,
        t,
        n,
        r
      ) : a.map(s.mapping, s.doc);
    }
  },
  props: {
    decorations: (s) => Fa.getState(s)
  },
  view: (s) => {
    const a = () => {
      s.docView && q4(s, Fa, { awarenessUpdated: !0 });
    }, l = () => {
      const c = Xe.getState(s.state), u = e.getLocalState() || {};
      if (s.hasFocus()) {
        const d = o(s.state), f = Ys(
          d.anchor,
          c.type,
          c.binding.mapping
        ), h = Ys(
          d.head,
          c.type,
          c.binding.mapping
        );
        (u.cursor == null || !$0(
          ys(u.cursor.anchor),
          f
        ) || !$0(
          ys(u.cursor.head),
          h
        )) && e.setLocalStateField(i, {
          anchor: f,
          head: h
        });
      } else u.cursor != null && Do(
        c.doc,
        c.type,
        ys(u.cursor.anchor),
        c.binding.mapping
      ) !== null && e.setLocalStateField(i, null);
    };
    return e.on("change", a), s.dom.addEventListener("focusin", l), s.dom.addEventListener("focusout", l), {
      update: l,
      destroy: () => {
        s.dom.removeEventListener("focusin", l), s.dom.removeEventListener("focusout", l), e.off("change", a), e.setLocalStateField(i, null);
      }
    };
  }
}), Z4 = (e) => {
  var t, n;
  return ((n = (t = pr.getState(e)) == null ? void 0 : t.undoManager) == null ? void 0 : n.undo()) != null;
}, X4 = (e) => {
  var t, n;
  return ((n = (t = pr.getState(e)) == null ? void 0 : t.undoManager) == null ? void 0 : n.redo()) != null;
}, J4 = (e, t) => {
  var n, r;
  return t == null ? (r = (n = pr.getState(e)) == null ? void 0 : n.undoManager) == null ? void 0 : r.canUndo() : Z4(e);
}, eM = (e, t) => {
  var n, r;
  return t == null ? (r = (n = pr.getState(e)) == null ? void 0 : n.undoManager) == null ? void 0 : r.canRedo() : X4(e);
}, tM = /* @__PURE__ */ new Set(["paragraph"]), nM = (e, t) => !(e instanceof ze) || !(e.content instanceof er) || !(e.content.type instanceof uo || e.content.type instanceof Nt && t.has(e.content.type.nodeName)) || e.content.type._length === 0, rM = ({ protectedNodes: e = tM, trackedOrigins: t = [], undoManager: n = null } = {}) => new me({
  key: pr,
  state: {
    init: (r, o) => {
      const i = Xe.getState(o), s = n || new Lk(i.type, {
        trackedOrigins: new Set([Xe].concat(t)),
        deleteFilter: (a) => nM(a, e),
        captureTransaction: (a) => a.meta.get("addToHistory") !== !1
      });
      return {
        undoManager: s,
        prevSel: null,
        hasUndoOps: s.undoStack.length > 0,
        hasRedoOps: s.redoStack.length > 0
      };
    },
    apply: (r, o, i, s) => {
      const a = Xe.getState(s).binding, l = o.undoManager, c = l.undoStack.length > 0, u = l.redoStack.length > 0;
      return a ? {
        undoManager: l,
        prevSel: Zl(a, i),
        hasUndoOps: c,
        hasRedoOps: u
      } : c !== o.hasUndoOps || u !== o.hasRedoOps ? Object.assign({}, o, {
        hasUndoOps: l.undoStack.length > 0,
        hasRedoOps: l.redoStack.length > 0
      }) : o;
    }
  },
  view: (r) => {
    const o = Xe.getState(r.state), i = pr.getState(r.state).undoManager;
    return i.on("stack-item-added", ({ stackItem: s }) => {
      const a = o.binding;
      a && s.meta.set(a, pr.getState(r.state).prevSel);
    }), i.on("stack-item-popped", ({ stackItem: s }) => {
      const a = o.binding;
      a && (a.beforeTransactionSelection = s.meta.get(a) || a.beforeTransactionSelection);
    }), {
      destroy: () => {
        i.destroy();
      }
    };
  }
}), Ci = /* @__PURE__ */ new WeakMap(), yl = /* @__PURE__ */ new WeakMap(), Jl = {
  current: []
};
let sd = !1;
const Ua = /* @__PURE__ */ new Set(), X0 = /* @__PURE__ */ new Map();
function s2(e) {
  const t = Array.from(e).sort((n, r) => n instanceof Ti && n.options.deps.includes(r) ? 1 : r instanceof Ti && r.options.deps.includes(n) ? -1 : 0);
  for (const n of t) {
    if (Jl.current.includes(n))
      continue;
    Jl.current.push(n), n.recompute();
    const r = yl.get(n);
    if (r)
      for (const o of r) {
        const i = Ci.get(o);
        i && s2(i);
      }
  }
}
function oM(e) {
  const t = {
    prevVal: e.prevState,
    currentVal: e.state
  };
  for (const n of e.listeners)
    n(t);
}
function iM(e) {
  const t = {
    prevVal: e.prevState,
    currentVal: e.state
  };
  for (const n of e.listeners)
    n(t);
}
function sM(e) {
  if (Ua.add(e), !sd)
    try {
      for (sd = !0; Ua.size > 0; ) {
        const t = Array.from(Ua);
        Ua.clear();
        for (const n of t) {
          const r = X0.get(n) ?? n.prevState;
          n.prevState = r, oM(n);
        }
        for (const n of t) {
          const r = Ci.get(n);
          r && (Jl.current.push(n), s2(r));
        }
        for (const n of t) {
          const r = Ci.get(n);
          if (r)
            for (const o of r)
              iM(o);
        }
      }
    } finally {
      sd = !1, Jl.current = [], X0.clear();
    }
}
function aM(e) {
  return typeof e == "function";
}
class _f {
  constructor(t, n) {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = (r) => {
      var o, i;
      this.listeners.add(r);
      const s = (i = (o = this.options) == null ? void 0 : o.onSubscribe) == null ? void 0 : i.call(o, r, this);
      return () => {
        this.listeners.delete(r), s == null || s();
      };
    }, this.prevState = t, this.state = t, this.options = n;
  }
  setState(t) {
    var n, r, o;
    this.prevState = this.state, (n = this.options) != null && n.updateFn ? this.state = this.options.updateFn(this.prevState)(t) : aM(t) ? this.state = t(this.prevState) : this.state = t, (o = (r = this.options) == null ? void 0 : r.onUpdate) == null || o.call(r), sM(this);
  }
}
class Ti {
  constructor(t) {
    this.listeners = /* @__PURE__ */ new Set(), this._subscriptions = [], this.lastSeenDepValues = [], this.getDepVals = () => {
      const n = this.options.deps.length, r = new Array(n), o = new Array(n);
      for (let i = 0; i < n; i++) {
        const s = this.options.deps[i];
        r[i] = s.prevState, o[i] = s.state;
      }
      return this.lastSeenDepValues = o, {
        prevDepVals: r,
        currDepVals: o,
        prevVal: this.prevState ?? void 0
      };
    }, this.recompute = () => {
      var n, r;
      this.prevState = this.state;
      const o = this.getDepVals();
      this.state = this.options.fn(o), (r = (n = this.options).onUpdate) == null || r.call(n);
    }, this.checkIfRecalculationNeededDeeply = () => {
      for (const i of this.options.deps)
        i instanceof Ti && i.checkIfRecalculationNeededDeeply();
      let n = !1;
      const r = this.lastSeenDepValues, { currDepVals: o } = this.getDepVals();
      for (let i = 0; i < o.length; i++)
        if (o[i] !== r[i]) {
          n = !0;
          break;
        }
      n && this.recompute();
    }, this.mount = () => (this.registerOnGraph(), this.checkIfRecalculationNeededDeeply(), () => {
      this.unregisterFromGraph();
      for (const n of this._subscriptions)
        n();
    }), this.subscribe = (n) => {
      var r, o;
      this.listeners.add(n);
      const i = (o = (r = this.options).onSubscribe) == null ? void 0 : o.call(r, n, this);
      return () => {
        this.listeners.delete(n), i == null || i();
      };
    }, this.options = t, this.state = t.fn({
      prevDepVals: void 0,
      prevVal: void 0,
      currDepVals: this.getDepVals().currDepVals
    });
  }
  registerOnGraph(t = this.options.deps) {
    for (const n of t)
      if (n instanceof Ti)
        n.registerOnGraph(), this.registerOnGraph(n.options.deps);
      else if (n instanceof _f) {
        let r = Ci.get(n);
        r || (r = /* @__PURE__ */ new Set(), Ci.set(n, r)), r.add(this);
        let o = yl.get(this);
        o || (o = /* @__PURE__ */ new Set(), yl.set(this, o)), o.add(n);
      }
  }
  unregisterFromGraph(t = this.options.deps) {
    for (const n of t)
      if (n instanceof Ti)
        this.unregisterFromGraph(n.options.deps);
      else if (n instanceof _f) {
        const r = Ci.get(n);
        r && r.delete(this);
        const o = yl.get(this);
        o && o.delete(n);
      }
  }
}
const Af = Symbol("originalFactory");
function He(e) {
  if (typeof e == "object" && "key" in e)
    return function t() {
      return e[Af] = t, e;
    };
  if (typeof e != "function")
    throw new Error("factory must be a function");
  return function t(n) {
    return (r) => {
      const o = e({ editor: r.editor, options: n });
      return o[Af] = t, o;
    };
  };
}
function yo(e, t) {
  return new _f(e, t);
}
var J0 = (e, t) => {
  if (e === "slot")
    return 0;
  if (e instanceof Function)
    return e(t);
  const { children: n, ...r } = t ?? {};
  if (e === "svg")
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  return [e, r, n];
}, lM = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, cM = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, uM = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, dM = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, fM = Hn.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (e) => e.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return /* @__PURE__ */ J0("strong", { ...kn(this.options.HTMLAttributes, e), children: /* @__PURE__ */ J0("slot", {}) });
  },
  markdownTokenName: "strong",
  parseMarkdown: (e, t) => t.applyMark("bold", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `**${t.renderChildren(e)}**`,
  addCommands() {
    return {
      setBold: () => ({ commands: e }) => e.setMark(this.name),
      toggleBold: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetBold: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Si({
        find: lM,
        type: this.type
      }),
      Si({
        find: uM,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Bo({
        find: cM,
        type: this.type
      }),
      Bo({
        find: dM,
        type: this.type
      })
    ];
  }
}), hM = fM, pM = /(^|[^`])`([^`]+)`(?!`)$/, mM = /(^|[^`])`([^`]+)`(?!`)/g, gM = Hn.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["code", kn(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "codespan",
  parseMarkdown: (e, t) => t.applyMark("code", [{ type: "text", text: e.text || "" }]),
  renderMarkdown: (e, t) => e.content ? `\`${t.renderChildren(e.content)}\`` : "",
  addCommands() {
    return {
      setCode: () => ({ commands: e }) => e.setMark(this.name),
      toggleCode: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetCode: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Si({
        find: pM,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Bo({
        find: mM,
        type: this.type
      })
    ];
  }
}), bM = gM, yM = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, EM = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, kM = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, CM = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, TM = Hn.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (e) => e.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["em", kn(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: e }) => e.setMark(this.name),
      toggleItalic: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetItalic: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  markdownTokenName: "em",
  parseMarkdown: (e, t) => t.applyMark("italic", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `*${t.renderChildren(e)}*`,
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Si({
        find: yM,
        type: this.type
      }),
      Si({
        find: kM,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Bo({
        find: EM,
        type: this.type
      }),
      Bo({
        find: CM,
        type: this.type
      })
    ];
  }
}), xM = TM, wM = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, vM = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, SM = Hn.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["s", kn(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "del",
  parseMarkdown: (e, t) => t.applyMark("strike", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `~~${t.renderChildren(e)}~~`,
  addCommands() {
    return {
      setStrike: () => ({ commands: e }) => e.setMark(this.name),
      toggleStrike: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetStrike: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Si({
        find: wM,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Bo({
        find: vM,
        type: this.type
      })
    ];
  }
}), _M = SM, AM = Hn.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["u", kn(this.options.HTMLAttributes, e), 0];
  },
  parseMarkdown(e, t) {
    return t.applyMark(this.name || "underline", t.parseInline(e.tokens || []));
  },
  renderMarkdown(e, t) {
    return `++${t.renderChildren(e)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(e) {
      return e.indexOf("++");
    },
    tokenize(e, t, n) {
      const o = /^(\+\+)([\s\S]+?)(\+\+)/.exec(e);
      if (!o)
        return;
      const i = o[2].trim();
      return {
        type: "underline",
        raw: o[0],
        text: i,
        tokens: n.inlineTokens(i)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: e }) => e.setMark(this.name),
      toggleUnderline: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetUnderline: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), IM = AM, NM = class a2 {
  constructor(t) {
    this.cache = new Map(t);
  }
  /**
   * Gets the cache entry at the given doc position, or null if it doesn't exist
   * @param pos The doc position of the node you want the cache for
   */
  get(t) {
    return this.cache.get(t);
  }
  /**
   * Sets the cache entry at the given position with the give node/decoration
   * values
   * @param pos The doc position of the node to set the cache for
   * @param node The node to place in cache
   * @param decorations The decorations to place in cache
   */
  set(t, n, r) {
    t < 0 || this.cache.set(t, [n, r]);
  }
  /**
   * Removes the value at the oldPos (if it exists) and sets the new position to
   * the given values
   * @param oldPos The old node position to overwrite
   * @param newPos The new node position to set the cache for
   * @param node The new node to place in cache
   * @param decorations The new decorations to place in cache
   */
  replace(t, n, r, o) {
    this.remove(t), this.set(n, r, o);
  }
  /**
   * Removes the cache entry at the given position
   * @param pos The doc position to remove from cache
   */
  remove(t) {
    this.cache.delete(t);
  }
  /**
   * Invalidates the cache by removing all decoration entries on nodes that have
   * changed, updating the positions of the nodes that haven't and removing all
   * the entries that have been deleted; NOTE: this does not affect the current
   * cache, but returns an entirely new one
   * @param tr A transaction to map the current cache to
   */
  invalidate(t) {
    const n = new a2(this.cache), r = t.mapping;
    return this.cache.forEach(([o, i], s) => {
      if (s < 0)
        return;
      const a = r.mapResult(s), l = t.doc.nodeAt(a.pos);
      if (a.deleted || !(l != null && l.eq(o)))
        n.remove(s);
      else if (s !== a.pos) {
        const c = i.map((u) => u.map(r, 0, 0)).filter((u) => u != null);
        n.replace(s, a.pos, l, c);
      }
    }), n;
  }
};
function MM({
  parser: e,
  nodeTypes: t = ["code_block", "codeBlock"],
  languageExtractor: n = (r) => r.attrs.language
}) {
  const r = new we("prosemirror-highlight");
  return new me({
    key: r,
    state: {
      init(o, i) {
        const s = new NM(), [a, l] = eg(
          i.doc,
          e,
          t,
          n,
          s
        );
        return { cache: s, decorations: a, promises: l };
      },
      apply: (o, i) => {
        const s = i.cache.invalidate(o), a = !!o.getMeta("prosemirror-highlight-refresh");
        if (!o.docChanged && !a) {
          const u = i.decorations.map(o.mapping, o.doc), d = i.promises;
          return { cache: s, decorations: u, promises: d };
        }
        const [l, c] = eg(
          o.doc,
          e,
          t,
          n,
          s
        );
        return { cache: s, decorations: l, promises: c };
      }
    },
    view: (o) => {
      const i = /* @__PURE__ */ new Set(), s = () => {
        if (i.size > 0)
          return;
        const l = o.state.tr.setMeta("prosemirror-highlight-refresh", !0);
        o.dispatch(l);
      }, a = () => {
        var l;
        const c = r.getState(o.state);
        for (const u of (l = c == null ? void 0 : c.promises) != null ? l : [])
          i.add(u), u.then(() => {
            i.delete(u), s();
          }).catch(() => {
            i.delete(u);
          });
      };
      return a(), {
        update: () => {
          a();
        }
      };
    },
    props: {
      decorations(o) {
        var i;
        return (i = this.getState(o)) == null ? void 0 : i.decorations;
      }
    }
  });
}
function eg(e, t, n, r, o) {
  const i = [], s = [];
  return e.descendants((a, l) => {
    if (!a.type.isTextblock)
      return !0;
    if (n.includes(a.type.name)) {
      const c = r(a), u = o.get(l);
      if (u) {
        const [d, f] = u;
        i.push(...f);
      } else {
        const d = t({
          content: a.textContent,
          language: c || void 0,
          pos: l,
          size: a.nodeSize
        });
        d && Array.isArray(d) ? (o.set(l, a, d), i.push(...d)) : d instanceof Promise && (o.remove(l), s.push(d));
      }
    }
    return !1;
  }), [kt.create(e, i), s];
}
function LM(e, t) {
  return function({ content: r, language: o, pos: i, size: s }) {
    var a;
    const l = [], { tokens: c, fg: u, bg: d, rootStyle: f } = e.codeToTokens(r, {
      lang: o,
      theme: e.getLoadedThemes()[0]
    }), h = f || (u && d ? `--prosemirror-highlight:${u};--prosemirror-highlight-bg:${d}` : "");
    if (h) {
      const m = Lt.node(i, i + s, { style: h });
      l.push(m);
    }
    let p = i + 1;
    for (const m of c) {
      for (const b of m) {
        const y = p + b.content.length, k = Lt.inline(p, y, {
          // When using `options.themes` the `htmlStyle` field will be set, otherwise `color` will be set
          style: OM(
            (a = b.htmlStyle) != null ? a : `color: ${b.color}`
          ),
          class: "shiki"
        });
        l.push(k), p = y;
      }
      p += 1;
    }
    return l;
  };
}
function OM(e) {
  return typeof e == "string" ? e : Object.entries(e).map(([t, n]) => `${t}:${n}`).join(";");
}
var DM = Object.defineProperty, RM = (e, t, n) => t in e ? DM(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, So = (e, t, n) => RM(e, typeof t != "symbol" ? t + "" : t, n);
const PM = () => typeof navigator < "u" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent));
function Sn(e, t = "Ctrl") {
  return PM() ? e.replace("Mod", "") : e.replace("Mod", t);
}
function dt(...e) {
  return [
    // Converts to & from set to remove duplicates.
    ...new Set(
      e.filter((t) => t).join(" ").split(" ")
    )
  ].join(" ");
}
const If = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
function BM(e, t, n, r) {
  const o = document.createElement("div");
  o.className = dt(
    "bn-block-content",
    n.class
  ), o.setAttribute("data-content-type", e);
  for (const [s, a] of Object.entries(n))
    s !== "class" && o.setAttribute(s, a);
  const i = document.createElement(t);
  i.className = dt(
    "bn-inline-content",
    r.class
  );
  for (const [s, a] of Object.entries(
    r
  ))
    s !== "class" && i.setAttribute(s, a);
  return o.appendChild(i), {
    dom: o,
    contentDOM: i
  };
}
const tg = (e, t) => {
  let n = Ko(e, t.pmSchema);
  n.type.name === "blockContainer" && (n = n.firstChild);
  const r = t.pmSchema.nodes[n.type.name].spec.toDOM;
  if (r === void 0)
    throw new Error(
      "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
    );
  const o = r(n);
  if (typeof o != "object" || !("dom" in o))
    throw new Error(
      "Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property."
    );
  return o;
};
function $M(e, t = "<br>") {
  const n = e.querySelectorAll("p");
  if (n.length > 1) {
    const r = n[0];
    for (let o = 1; o < n.length; o++) {
      const i = n[o];
      r.innerHTML += t + i.innerHTML, i.remove();
    }
  }
}
function Nf(e) {
  return "data-" + e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function ng(e) {
  const t = e.split("/");
  return !t.length || // invalid?
  t[t.length - 1] === "" ? e : t[t.length - 1];
}
function HM(e) {
  var t;
  const n = [
    "mp4",
    "webm",
    "ogg",
    "mov",
    "mkv",
    "flv",
    "avi",
    "wmv",
    "m4v"
  ];
  try {
    const r = ((t = new URL(e).pathname.split(".").pop()) == null ? void 0 : t.toLowerCase()) || "";
    return n.includes(r);
  } catch {
    return !1;
  }
}
function FM(e) {
  const t = {};
  return Object.entries(e).forEach(([n, r]) => {
    t[n] = {
      default: r.default,
      keepOnSplit: !0,
      // Props are displayed in kebab-case as HTML attributes. If a prop's
      // value is the same as its default, we don't display an HTML
      // attribute for it.
      parseHTML: (o) => {
        const i = o.getAttribute(Nf(n));
        if (i === null)
          return null;
        if (r.default === void 0 && r.type === "boolean" || r.default !== void 0 && typeof r.default == "boolean")
          return i === "true" ? !0 : i === "false" ? !1 : null;
        if (r.default === void 0 && r.type === "number" || r.default !== void 0 && typeof r.default == "number") {
          const s = parseFloat(i);
          return !Number.isNaN(s) && Number.isFinite(s) ? s : null;
        }
        return i;
      },
      renderHTML: (o) => o[n] !== r.default ? {
        [Nf(n)]: o[n]
      } : {}
    };
  }), t;
}
function UM(e, t, n, r) {
  const o = e();
  if (o === void 0)
    throw new Error("Cannot find node position");
  const i = n.state.doc.resolve(o).node().attrs.id;
  if (!i)
    throw new Error("Block doesn't have id");
  const s = t.getBlock(i);
  if (s.type !== r)
    throw new Error("Block type does not match");
  return s;
}
function Mf(e, t, n, r, o = !1, i) {
  const s = document.createElement("div");
  if (i !== void 0)
    for (const [a, l] of Object.entries(i))
      a !== "class" && s.setAttribute(a, l);
  s.className = dt(
    "bn-block-content",
    (i == null ? void 0 : i.class) || ""
  ), s.setAttribute("data-content-type", t);
  for (const [a, l] of Object.entries(n)) {
    const c = r[a].default;
    l !== c && s.setAttribute(Nf(a), l);
  }
  return o && s.setAttribute("data-file-block", ""), s.appendChild(e.dom), e.contentDOM && (e.contentDOM.className = dt(
    "bn-inline-content",
    e.contentDOM.className
  )), {
    ...e,
    dom: s
  };
}
function jM(e, t, n) {
  return {
    config: {
      type: e.type,
      content: e.content,
      propSchema: t
    },
    implementation: {
      node: e.node,
      render: tg,
      toExternalHTML: tg
    },
    extensions: n
  };
}
function VM(e, t) {
  e.stopEvent = (n) => (n.type === "mousedown" && setTimeout(() => {
    t.view.dom.blur();
  }, 10), !0);
}
function zM(e, t) {
  const n = [
    {
      tag: "[data-content-type=" + e.type + "]",
      contentElement: ".bn-inline-content"
    }
  ];
  return t.parse && n.push({
    tag: "*",
    getAttrs(r) {
      var o;
      if (typeof r == "string")
        return !1;
      const i = (o = t.parse) == null ? void 0 : o.call(t, r);
      return i === void 0 ? !1 : i;
    },
    // Because we do the parsing ourselves, we want to preserve whitespace for content we've parsed
    preserveWhitespace: !0,
    getContent: e.content === "inline" || e.content === "none" ? (r, o) => {
      var i;
      if (t.parseContent)
        return t.parseContent({
          el: r,
          schema: o
        });
      if (e.content === "inline") {
        const s = r.cloneNode(!0);
        return $M(
          s,
          (i = t.meta) != null && i.code ? `
` : "<br>"
        ), Mn.fromSchema(o).parse(s, {
          topNode: o.nodes.paragraph.create(),
          preserveWhitespace: !0
        }).content;
      }
      return be.empty;
    } : void 0
  }), n;
}
function qM(e, t, n, r) {
  var o, i, s, a;
  const l = t.node || Jn.create({
    name: e.type,
    content: e.content === "inline" ? "inline*" : e.content === "none" ? "" : e.content,
    group: "blockContent",
    selectable: ((o = t.meta) == null ? void 0 : o.selectable) ?? !0,
    isolating: ((i = t.meta) == null ? void 0 : i.isolating) ?? !0,
    code: ((s = t.meta) == null ? void 0 : s.code) ?? !1,
    defining: ((a = t.meta) == null ? void 0 : a.defining) ?? !0,
    priority: r,
    addAttributes() {
      return FM(e.propSchema);
    },
    parseHTML() {
      return zM(e, t);
    },
    renderHTML({ HTMLAttributes: c }) {
      var u;
      const d = document.createElement("div");
      return Mf(
        {
          dom: d,
          contentDOM: e.content === "inline" ? d : void 0
        },
        e.type,
        {},
        e.propSchema,
        ((u = t.meta) == null ? void 0 : u.fileBlockAccept) !== void 0,
        c
      );
    },
    addNodeView() {
      return (c) => {
        var u, d;
        const f = this.options.editor, h = UM(
          c.getPos,
          f,
          this.editor,
          e.type
        ), p = ((u = this.options.domAttributes) == null ? void 0 : u.blockContent) || {}, m = t.render.call(
          { blockContentDOMAttributes: p, props: c, renderType: "nodeView" },
          h,
          f
        );
        return ((d = t.meta) == null ? void 0 : d.selectable) === !1 && VM(m, this.editor), m;
      };
    }
  });
  if (l.name !== e.type)
    throw new Error(
      "Node name does not match block type. This is a bug in BlockNote."
    );
  return {
    config: e,
    implementation: {
      ...t,
      node: l,
      render(c, u) {
        var d;
        const f = ((d = l.options.domAttributes) == null ? void 0 : d.blockContent) || {};
        return t.render.call(
          {
            blockContentDOMAttributes: f,
            props: void 0,
            renderType: "dom"
          },
          c,
          u
        );
      },
      // TODO: this should not have wrapInBlockStructure and generally be a lot simpler
      // post-processing in externalHTMLExporter should not be necessary
      toExternalHTML: (c, u, d) => {
        var f, h;
        const p = ((f = l.options.domAttributes) == null ? void 0 : f.blockContent) || {};
        return ((h = t.toExternalHTML) == null ? void 0 : h.call(
          { blockContentDOMAttributes: p },
          c,
          u,
          d
        )) ?? t.render.call(
          { blockContentDOMAttributes: p, renderType: "dom", props: void 0 },
          c,
          u
        );
      }
    },
    extensions: n
  };
}
function xn(e, t, n) {
  return (r = {}) => {
    const o = typeof e == "function" ? e(r) : e, i = typeof t == "function" ? t(r) : t, s = n ? typeof n == "function" ? n(r) : n : void 0;
    return {
      config: o,
      implementation: {
        ...i,
        // TODO: this should not have wrapInBlockStructure and generally be a lot simpler
        // post-processing in externalHTMLExporter should not be necessary
        toExternalHTML(a, l, c) {
          var u, d;
          const f = (u = i.toExternalHTML) == null ? void 0 : u.call(
            { blockContentDOMAttributes: this.blockContentDOMAttributes },
            a,
            l,
            c
          );
          if (f !== void 0)
            return Mf(
              f,
              a.type,
              a.props,
              o.propSchema,
              ((d = i.meta) == null ? void 0 : d.fileBlockAccept) !== void 0
            );
        },
        render(a, l) {
          var c;
          const u = i.render.call(
            {
              blockContentDOMAttributes: this.blockContentDOMAttributes,
              renderType: this.renderType,
              props: this.props
            },
            a,
            l
          );
          return Mf(
            u,
            a.type,
            a.props,
            o.propSchema,
            ((c = i.meta) == null ? void 0 : c.fileBlockAccept) !== void 0,
            this.blockContentDOMAttributes
          );
        }
      },
      extensions: s
    };
  };
}
function l2(e) {
  return Object.fromEntries(
    Object.entries(e).map(([t, n]) => [t, n.config])
  );
}
function WM(e) {
  return e === "boolean" ? {} : {
    stringValue: {
      default: void 0,
      keepOnSplit: !0,
      parseHTML: (t) => t.getAttribute("data-value"),
      renderHTML: (t) => t.stringValue !== void 0 ? {
        "data-value": t.stringValue
      } : {}
    }
  };
}
function ja(e, t, n, r) {
  return e.dom.setAttribute("data-style-type", t), r === "string" && e.dom.setAttribute("data-value", n), e.contentDOM && e.contentDOM.setAttribute("data-editable", ""), e;
}
function c2(e, t) {
  return {
    config: e,
    implementation: t
  };
}
function os(e, t) {
  return c2(
    {
      type: e.name,
      propSchema: t
    },
    {
      mark: e,
      render(n, r) {
        const o = r.pmSchema.marks[e.name].spec.toDOM;
        if (o === void 0)
          throw new Error(
            "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
          );
        const i = r.pmSchema.mark(e.name, {
          stringValue: n
        }), s = Po.renderSpec(
          document,
          o(i, !0)
        );
        if (typeof s != "object" || !("dom" in s))
          throw new Error(
            "Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property."
          );
        return s;
      },
      toExternalHTML(n, r) {
        const o = r.pmSchema.marks[e.name].spec.toDOM;
        if (o === void 0)
          throw new Error(
            "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
          );
        const i = r.pmSchema.mark(e.name, {
          stringValue: n
        }), s = Po.renderSpec(
          document,
          o(i, !0)
        );
        if (typeof s != "object" || !("dom" in s))
          throw new Error(
            "Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property."
          );
        return s;
      }
    }
  );
}
function u2(e) {
  return Object.fromEntries(
    Object.entries(e).map(([t, n]) => [t, n.config])
  );
}
function GM(e, t) {
  const n = [
    {
      tag: `[data-style-type="${e.type}"]`,
      contentElement: (r) => {
        const o = r;
        return o.matches("[data-editable]") ? o : o.querySelector("[data-editable]") || o;
      }
    }
  ];
  return t && n.push({
    tag: "*",
    // By default, styles can overlap each other, so the rules should not
    // completely consume the element they parse (which can have multiple
    // styles).
    consuming: !1,
    getAttrs(r) {
      if (typeof r == "string")
        return !1;
      const o = t == null ? void 0 : t(r);
      return o === void 0 ? !1 : { stringValue: o };
    }
  }), n;
}
function d2(e, t) {
  const n = Hn.create({
    name: e.type,
    addAttributes() {
      return WM(e.propSchema);
    },
    parseHTML() {
      return GM(e, t.parse);
    },
    renderHTML({ mark: r }) {
      const o = (t.toExternalHTML || t.render)(r.attrs.stringValue);
      return ja(
        o,
        e.type,
        r.attrs.stringValue,
        e.propSchema
      );
    },
    addMarkView() {
      return ({ mark: r }) => {
        const o = t.render(r.attrs.stringValue);
        return ja(
          o,
          e.type,
          r.attrs.stringValue,
          e.propSchema
        );
      };
    }
  });
  return c2(e, {
    ...t,
    mark: n,
    render: (r) => {
      const o = t.render(r);
      return ja(
        o,
        e.type,
        r,
        e.propSchema
      );
    },
    toExternalHTML: (r) => {
      const o = (t.toExternalHTML || t.render)(r);
      return ja(
        o,
        e.type,
        r,
        e.propSchema
      );
    }
  });
}
function Yt(e, t) {
  let n, r;
  if (t.firstChild.descendants((o, i) => n ? !1 : !yp(o) || o.attrs.id !== e ? !0 : (n = o, r = i + 1, !1)), !(n === void 0 || r === void 0))
    return {
      node: n,
      posBeforeNode: r
    };
}
function yp(e) {
  return e.type.isInGroup("bnBlock");
}
const YM = (e, t) => ({
  tr: n,
  dispatch: r
}) => (r && Xc(n, e, t), !0);
function Xc(e, t, n, r, o) {
  const i = Bc(e.doc.resolve(t));
  let s = null;
  i.blockNoteType === "table" && (s = ZM(e));
  const a = ht(e), l = a.nodes[i.blockNoteType], c = a.nodes[n.type || i.blockNoteType], u = c.isInGroup("bnBlock") ? c : a.nodes.blockContainer;
  if (i.isBlockContainer && c.isInGroup("blockContent"))
    rg(n, e, i), KM(
      n,
      e,
      l,
      c,
      i
    );
  else if (!i.isBlockContainer && c.isInGroup("bnBlock"))
    rg(n, e, i);
  else {
    const d = ct(i.bnBlock.node, a);
    e.replaceWith(
      i.bnBlock.beforePos,
      i.bnBlock.afterPos,
      Ko(
        {
          children: d.children,
          // if no children are passed in, use existing children
          ...n
        },
        a
      )
    );
    return;
  }
  e.setNodeMarkup(i.bnBlock.beforePos, u, {
    ...i.bnBlock.node.attrs,
    ...n.props
  }), s && XM(e, i, s);
}
function KM(e, t, n, r, o, i, s) {
  const a = ht(t);
  let l = "keep";
  if (e.content)
    if (typeof e.content == "string")
      l = Gn(
        [e.content],
        a,
        r.name
      );
    else if (Array.isArray(e.content))
      l = Gn(e.content, a, r.name);
    else if (e.content.type === "tableContent")
      l = Hc(e.content, a);
    else
      throw new br(e.content.type);
  else
    n.spec.content === "" || r.spec.content !== n.spec.content && (l = []);
  l === "keep" ? t.setNodeMarkup(o.blockContent.beforePos, r, {
    ...o.blockContent.node.attrs,
    ...e.props
  }) : t.replaceWith(
    o.blockContent.beforePos,
    o.blockContent.afterPos,
    r.createChecked(
      {
        ...o.blockContent.node.attrs,
        ...e.props
      },
      l
    )
  );
}
function rg(e, t, n) {
  const r = ht(t);
  if (e.children !== void 0 && e.children.length > 0) {
    const o = e.children.map((i) => Ko(i, r));
    if (n.childContainer)
      t.step(
        new Sc(
          n.childContainer.beforePos + 1,
          n.childContainer.afterPos - 1,
          new lt(be.from(o), 0, 0)
        )
      );
    else {
      if (!n.isBlockContainer)
        throw new Error("impossible");
      t.insert(
        n.blockContent.afterPos,
        r.nodes.blockGroup.createChecked({}, o)
      );
    }
  }
}
function QM(e, t, n, r, o) {
  const i = typeof t == "string" ? t : t.id, s = Yt(i, e.doc);
  if (!s)
    throw new Error(`Block with ID ${i} not found`);
  Xc(
    e,
    s.posBeforeNode,
    n
  );
  const a = e.doc.resolve(s.posBeforeNode + 1).node(), l = ht(e);
  return ct(a, l);
}
function ZM(e) {
  const t = "selection" in e ? e.selection : null;
  if (!(t instanceof pe))
    return null;
  const n = e.doc.resolve(t.head);
  let r = -1, o = -1;
  for (let m = n.depth; m >= 0; m--) {
    const b = n.node(m).type.name;
    if (r < 0 && (b === "tableCell" || b === "tableHeader") && (r = m), b === "table") {
      o = m;
      break;
    }
  }
  if (r < 0 || o < 0)
    return null;
  const i = n.before(r), s = n.before(o), a = e.doc.nodeAt(s);
  if (!a || a.type.name !== "table")
    return null;
  const l = Je.get(a), c = i - (s + 1), u = l.map.indexOf(c);
  if (u < 0)
    return null;
  const d = Math.floor(u / l.width), f = u % l.width, h = i + 1 + 1, p = Math.max(0, t.head - h);
  return { row: d, col: f, offset: p };
}
function XM(e, t, n) {
  var r;
  if (t.blockNoteType !== "table")
    return !1;
  let o = -1;
  if (t.isBlockContainer)
    o = e.mapping.map(t.blockContent.beforePos);
  else {
    const b = e.mapping.map(t.bnBlock.beforePos), y = b + (((r = e.doc.nodeAt(b)) == null ? void 0 : r.nodeSize) || 0);
    e.doc.nodesBetween(b, y, (k, C) => k.type.name === "table" ? (o = C, !1) : !0);
  }
  const i = o >= 0 ? e.doc.nodeAt(o) : null;
  if (!i || i.type.name !== "table")
    return !1;
  const s = Je.get(i), a = Math.max(0, Math.min(n.row, s.height - 1)), l = Math.max(0, Math.min(n.col, s.width - 1)), c = a * s.width + l, u = s.map[c];
  if (u == null)
    return !1;
  const d = o + 1 + u + 1, f = e.doc.nodeAt(d), h = d + 1, p = f ? f.content.size : 0, m = h + Math.max(0, Math.min(n.offset, p));
  return "selection" in e && e.setSelection(pe.create(e.doc, m)), !0;
}
const eo = {
  gray: {
    text: "#9b9a97",
    background: "#ebeced"
  },
  brown: {
    text: "#64473a",
    background: "#e9e5e3"
  },
  red: {
    text: "#e03e3e",
    background: "#fbe4e4"
  },
  orange: {
    text: "#d9730d",
    background: "#f6e9d9"
  },
  yellow: {
    text: "#dfab01",
    background: "#fbf3db"
  },
  green: {
    text: "#4d6461",
    background: "#ddedea"
  },
  blue: {
    text: "#0b6e99",
    background: "#ddebf1"
  },
  purple: {
    text: "#6940a5",
    background: "#eae4f2"
  },
  pink: {
    text: "#ad1a72",
    background: "#f4dfeb"
  }
}, $e = {
  backgroundColor: {
    default: "default"
  },
  textColor: {
    default: "default"
  },
  textAlignment: {
    default: "left",
    values: ["left", "center", "right", "justify"]
  }
}, ln = (e) => {
  const t = {};
  return e.hasAttribute("data-background-color") ? t.backgroundColor = e.getAttribute("data-background-color") : e.style.backgroundColor && (t.backgroundColor = e.style.backgroundColor), e.hasAttribute("data-text-color") ? t.textColor = e.getAttribute("data-text-color") : e.style.color && (t.textColor = e.style.color), t.textAlignment = $e.textAlignment.values.includes(
    e.style.textAlign
  ) ? e.style.textAlign : void 0, t;
}, Zo = (e, t) => {
  e.backgroundColor && e.backgroundColor !== $e.backgroundColor.default && (t.style.backgroundColor = e.backgroundColor in eo ? eo[e.backgroundColor].background : e.backgroundColor), e.textColor && e.textColor !== $e.textColor.default && (t.style.color = e.textColor in eo ? eo[e.textColor].text : e.textColor), e.textAlignment && e.textAlignment !== $e.textAlignment.default && (t.style.textAlign = e.textAlignment);
}, JM = (e = "backgroundColor") => ({
  default: $e.backgroundColor.default,
  parseHTML: (t) => t.hasAttribute("data-background-color") ? t.getAttribute("data-background-color") : t.style.backgroundColor ? t.style.backgroundColor : $e.backgroundColor.default,
  renderHTML: (t) => t[e] === $e.backgroundColor.default ? {} : {
    "data-background-color": t[e]
  }
}), e6 = (e = "textColor") => ({
  default: $e.textColor.default,
  parseHTML: (t) => t.hasAttribute("data-text-color") ? t.getAttribute("data-text-color") : t.style.color ? t.style.color : $e.textColor.default,
  renderHTML: (t) => t[e] === $e.textColor.default ? {} : {
    "data-text-color": t[e]
  }
}), Jc = (e, t) => {
  const n = e.querySelector(
    t
  );
  if (!n)
    return;
  const r = e.querySelector("figcaption"), o = (r == null ? void 0 : r.textContent) ?? void 0;
  return { targetElement: n, caption: o };
}, zn = He(({ editor: e }) => {
  const t = yo(void 0);
  function n() {
    t.setState(void 0);
  }
  return {
    key: "filePanel",
    store: t,
    mount({ signal: r }) {
      const o = e.onChange(
        n,
        // Don't trigger if the changes are caused by a remote user.
        !1
      ), i = e.onSelectionChange(
        n,
        // Don't trigger if the changes are caused by a remote user.
        !1
      );
      r.addEventListener("abort", () => {
        o(), i();
      });
    },
    closeMenu: n,
    showMenu(r) {
      t.setState(r);
    }
  };
}), t6 = (e, t, n) => {
  const r = document.createElement("div");
  r.className = "bn-add-file-button";
  const o = document.createElement("div");
  o.className = "bn-add-file-button-icon", n ? o.appendChild(n) : o.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>', r.appendChild(o);
  const i = document.createElement("p");
  i.className = "bn-add-file-button-text", i.innerHTML = e.type in t.dictionary.file_blocks.add_button_text ? t.dictionary.file_blocks.add_button_text[e.type] : t.dictionary.file_blocks.add_button_text.file, r.appendChild(i);
  const s = (l) => {
    l.preventDefault(), l.stopPropagation();
  }, a = () => {
    var l;
    t.isEditable && ((l = t.getExtension(zn)) == null || l.showMenu(e.id));
  };
  return r.addEventListener(
    "mousedown",
    s,
    !0
  ), r.addEventListener("click", a, !0), {
    dom: r,
    destroy: () => {
      r.removeEventListener(
        "mousedown",
        s,
        !0
      ), r.removeEventListener(
        "click",
        a,
        !0
      );
    }
  };
}, n6 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>', r6 = (e) => {
  const t = document.createElement("div");
  t.className = "bn-file-name-with-icon";
  const n = document.createElement("div");
  n.className = "bn-file-icon", n.innerHTML = n6, t.appendChild(n);
  const r = document.createElement("p");
  return r.className = "bn-file-name", r.textContent = e.props.name, t.appendChild(r), {
    dom: t
  };
}, Ep = (e, t, n, r) => {
  const o = document.createElement("div");
  if (o.className = "bn-file-block-content-wrapper", e.props.url === "") {
    const s = t6(e, t, r);
    o.appendChild(s.dom);
    const a = t.onUploadStart((l) => {
      if (l === e.id) {
        o.removeChild(s.dom);
        const c = document.createElement("div");
        c.className = "bn-file-loading-preview", c.textContent = "Loading...", o.appendChild(c);
      }
    });
    return {
      dom: o,
      destroy: () => {
        a(), s.destroy();
      }
    };
  }
  const i = { dom: o };
  if (e.props.showPreview === !1 || !n) {
    const s = r6(e);
    o.appendChild(s.dom), i.destroy = () => {
      var a;
      (a = s.destroy) == null || a.call(s);
    };
  } else
    o.appendChild(n.dom);
  if (e.props.caption) {
    const s = document.createElement("p");
    s.className = "bn-file-caption", s.textContent = e.props.caption, o.appendChild(s);
  }
  return i;
}, kp = (e, t) => {
  const n = document.createElement("figure"), r = document.createElement("figcaption");
  return r.textContent = t, n.appendChild(e), n.appendChild(r), { dom: n };
}, eu = (e, t) => {
  const n = document.createElement("div"), r = document.createElement("p");
  return r.textContent = t, n.appendChild(e), n.appendChild(r), {
    dom: n
  };
}, og = (e) => ({ url: e.src || void 0 }), o6 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z"></path></svg>', i6 = (e) => ({
  type: "audio",
  propSchema: {
    backgroundColor: $e.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    },
    showPreview: {
      default: !0
    }
  },
  content: "none"
}), s6 = (e = {}) => (t) => {
  if (t.tagName === "AUDIO") {
    if (t.closest("figure"))
      return;
    const { backgroundColor: n } = ln(t);
    return {
      ...og(t),
      backgroundColor: n
    };
  }
  if (t.tagName === "FIGURE") {
    const n = Jc(t, "audio");
    if (!n)
      return;
    const { targetElement: r, caption: o } = n, { backgroundColor: i } = ln(t);
    return {
      ...og(r),
      backgroundColor: i,
      caption: o
    };
  }
}, a6 = (e = {}) => (t, n) => {
  const r = document.createElement("div");
  r.innerHTML = e.icon ?? o6;
  const o = document.createElement("audio");
  return o.className = "bn-audio", n.resolveFileUrl ? n.resolveFileUrl(t.props.url).then((i) => {
    o.src = i;
  }) : o.src = t.props.url, o.controls = !0, o.contentEditable = "false", o.draggable = !1, Ep(
    t,
    n,
    { dom: o },
    r.firstElementChild
  );
}, l6 = (e = {}) => (t, n) => {
  if (!t.props.url) {
    const o = document.createElement("p");
    return o.textContent = "Add audio", {
      dom: o
    };
  }
  let r;
  return t.props.showPreview ? (r = document.createElement("audio"), r.src = t.props.url) : (r = document.createElement("a"), r.href = t.props.url, r.textContent = t.props.name || t.props.url), t.props.caption ? t.props.showPreview ? kp(r, t.props.caption) : eu(r, t.props.caption) : {
    dom: r
  };
}, c6 = xn(
  i6,
  (e) => ({
    meta: {
      fileBlockAccept: ["audio/*"]
    },
    parse: s6(e),
    render: a6(e),
    toExternalHTML: l6(e),
    runsBefore: ["file"]
  })
), ig = Symbol.for("blocknote.shikiParser"), ad = Symbol.for(
  "blocknote.shikiHighlighterPromise"
);
function u6(e) {
  const t = globalThis;
  let n, r, o = !1;
  return MM({
    parser: (i) => {
      if (!e.createHighlighter)
        return process.env.NODE_ENV === "development" && !o && (console.log(
          "For syntax highlighting of code blocks, you must provide a `createCodeBlockSpec({ createHighlighter: () => ... })` function"
        ), o = !0), [];
      if (!n)
        return t[ad] = t[ad] || e.createHighlighter(), t[ad].then(
          (a) => {
            n = a;
          }
        );
      const s = f2(e, i.language);
      return !s || s === "text" || s === "none" || s === "plaintext" || s === "txt" ? [] : n.getLoadedLanguages().includes(s) ? (r || (r = t[ig] || LM(n), t[ig] = r), r(i)) : n.loadLanguage(s);
    },
    languageExtractor: (i) => i.attrs.language,
    nodeTypes: ["codeBlock"]
  });
}
const d6 = ({ defaultLanguage: e = "text" }) => ({
  type: "codeBlock",
  propSchema: {
    language: {
      default: e
    }
  },
  content: "inline"
}), f6 = xn(
  d6,
  (e) => ({
    meta: {
      code: !0,
      defining: !0,
      isolating: !1
    },
    parse: (t) => {
      var n, r;
      if (t.tagName !== "PRE" || t.childElementCount !== 1 || ((n = t.firstElementChild) == null ? void 0 : n.tagName) !== "CODE")
        return;
      const o = t.firstElementChild;
      return { language: o.getAttribute("data-language") || ((r = o.className.split(" ").find((i) => i.includes("language-"))) == null ? void 0 : r.replace("language-", "")) };
    },
    parseContent: ({ el: t, schema: n }) => {
      const r = Mn.fromSchema(n), o = t.firstElementChild;
      return r.parse(o, {
        preserveWhitespace: "full",
        topNode: n.nodes.codeBlock.create()
      }).content;
    },
    render(t, n) {
      const r = document.createDocumentFragment(), o = document.createElement("pre"), i = document.createElement("code");
      o.appendChild(i);
      let s;
      if (e.supportedLanguages) {
        const a = document.createElement("select");
        if (Object.entries(e.supportedLanguages ?? {}).forEach(
          ([c, { name: u }]) => {
            const d = document.createElement("option");
            d.value = c, d.text = u, a.appendChild(d);
          }
        ), a.value = t.props.language || e.defaultLanguage || "text", n.isEditable) {
          const c = (u) => {
            const d = u.target.value;
            n.updateBlock(t.id, { props: { language: d } });
          };
          a.addEventListener("change", c), s = () => a.removeEventListener("change", c);
        } else
          a.disabled = !0;
        const l = document.createElement("div");
        l.contentEditable = "false", l.appendChild(a), r.appendChild(l);
      }
      return r.appendChild(o), {
        dom: r,
        contentDOM: i,
        destroy: () => {
          s == null || s();
        }
      };
    },
    toExternalHTML(t) {
      const n = document.createElement("pre"), r = document.createElement("code");
      return r.className = `language-${t.props.language}`, r.dataset.language = t.props.language, n.appendChild(r), {
        dom: n,
        contentDOM: r
      };
    }
  }),
  (e) => [
    He({
      key: "code-block-highlighter",
      prosemirrorPlugins: [u6(e)]
    }),
    He({
      key: "code-block-keyboard-shortcuts",
      keyboardShortcuts: {
        Delete: ({ editor: t }) => t.transact((n) => {
          const { block: r } = t.getTextCursorPosition();
          if (r.type !== "codeBlock")
            return !1;
          const { $from: o } = n.selection;
          return o.parent.textContent ? !1 : (t.removeBlocks([r]), !0);
        }),
        Tab: ({ editor: t }) => e.indentLineWithTab === !1 ? !1 : t.transact((n) => {
          const { block: r } = t.getTextCursorPosition();
          return r.type === "codeBlock" ? (n.insertText("  "), !0) : !1;
        }),
        Enter: ({ editor: t }) => t.transact((n) => {
          const { block: r, nextBlock: o } = t.getTextCursorPosition();
          if (r.type !== "codeBlock")
            return !1;
          const { $from: i } = n.selection, s = i.parentOffset === i.parent.nodeSize - 2, a = i.parent.textContent.endsWith(`

`);
          if (s && a) {
            if (n.delete(i.pos - 2, i.pos), o)
              return t.setTextCursorPosition(o, "start"), !0;
            const [l] = t.insertBlocks(
              [{ type: "paragraph" }],
              r,
              "after"
            );
            return t.setTextCursorPosition(l, "start"), !0;
          }
          return n.insertText(`
`), !0;
        }),
        "Shift-Enter": ({ editor: t }) => t.transact(() => {
          const { block: n } = t.getTextCursorPosition();
          if (n.type !== "codeBlock")
            return !1;
          const [r] = t.insertBlocks(
            // insert a new paragraph
            [{ type: "paragraph" }],
            n,
            "after"
          );
          return t.setTextCursorPosition(r, "start"), !0;
        })
      },
      inputRules: [
        {
          find: /^```(.*?)\s$/,
          replace: ({ match: t }) => {
            const n = t[1].trim();
            return {
              type: "codeBlock",
              props: {
                language: {
                  language: f2(e, n) ?? n
                }.language
              },
              content: []
            };
          }
        }
      ]
    })
  ]
);
function f2(e, t) {
  var n;
  return (n = Object.entries(e.supportedLanguages ?? {}).find(
    ([r, { aliases: o }]) => (o == null ? void 0 : o.includes(t)) || r === t
  )) == null ? void 0 : n[0];
}
const h6 = () => ({
  type: "divider",
  propSchema: {},
  content: "none"
}), p6 = xn(
  h6,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      if (e.tagName === "HR")
        return {};
    },
    render() {
      return {
        dom: document.createElement("hr")
      };
    }
  },
  [
    He({
      key: "divider-block-shortcuts",
      inputRules: [
        {
          find: new RegExp("^---$"),
          replace() {
            return { type: "divider", props: {}, content: [] };
          }
        }
      ]
    })
  ]
), sg = (e) => ({ url: e.src || void 0 }), m6 = () => ({
  type: "file",
  propSchema: {
    backgroundColor: $e.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    }
  },
  content: "none"
}), g6 = () => (e) => {
  if (e.tagName === "EMBED") {
    if (e.closest("figure"))
      return;
    const { backgroundColor: t } = ln(e);
    return {
      ...sg(e),
      backgroundColor: t
    };
  }
  if (e.tagName === "FIGURE") {
    const t = Jc(e, "embed");
    if (!t)
      return;
    const { targetElement: n, caption: r } = t, { backgroundColor: o } = ln(e);
    return {
      ...sg(n),
      backgroundColor: o,
      caption: r
    };
  }
}, b6 = xn(m6, {
  meta: {
    fileBlockAccept: ["*/*"]
  },
  parse: g6(),
  render(e, t) {
    return Ep(e, t);
  },
  toExternalHTML(e) {
    if (!e.props.url) {
      const n = document.createElement("p");
      return n.textContent = "Add file", {
        dom: n
      };
    }
    const t = document.createElement("a");
    return t.href = e.props.url, t.textContent = e.props.name || e.props.url, e.props.caption ? eu(t, e.props.caption) : {
      dom: t
    };
  }
}), y6 = {
  set: (e, t) => window.localStorage.setItem(
    `toggle-${e.id}`,
    t ? "true" : "false"
  ),
  get: (e) => window.localStorage.getItem(`toggle-${e.id}`) === "true"
}, h2 = (e, t, n, r = y6) => {
  if ("isToggleable" in e.props && !e.props.isToggleable)
    return {
      dom: n
    };
  const o = document.createElement("div"), i = document.createElement("div");
  i.className = "bn-toggle-wrapper";
  const s = document.createElement("button");
  s.className = "bn-toggle-button", s.type = "button", s.innerHTML = // https://fonts.google.com/icons?selected=Material+Symbols+Rounded:chevron_right:FILL@0;wght@700;GRAD@0;opsz@24&icon.query=chevron&icon.style=Rounded&icon.size=24&icon.color=%23e8eaed
  '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="CURRENTCOLOR"><path d="M320-200v-560l440 280-440 280Z"/></svg>';
  const a = (p) => p.preventDefault();
  s.addEventListener("mousedown", a);
  const l = () => {
    var p;
    i.getAttribute("data-show-children") === "true" ? (i.setAttribute("data-show-children", "false"), r.set(t.getBlock(e), !1), o.contains(c) && o.removeChild(c)) : (i.setAttribute("data-show-children", "true"), r.set(t.getBlock(e), !0), t.isEditable && ((p = t.getBlock(e)) == null ? void 0 : p.children.length) === 0 && !o.contains(c) && o.appendChild(c));
  };
  s.addEventListener("click", l), i.appendChild(s), i.appendChild(n);
  const c = document.createElement("button");
  c.className = "bn-toggle-add-block-button", c.type = "button", c.textContent = t.dictionary.toggle_blocks.add_block_button;
  const u = (p) => p.preventDefault();
  c.addEventListener(
    "mousedown",
    u
  );
  const d = () => {
    t.transact(() => {
      const p = t.updateBlock(e, {
        // Single empty block with default type.
        children: [{}]
      });
      t.setTextCursorPosition(p.children[0].id, "end"), t.focus();
    });
  };
  c.addEventListener("click", d), o.appendChild(i);
  let f = e.children.length;
  const h = t.onChange(() => {
    var p;
    const m = ((p = t.getBlock(e)) == null ? void 0 : p.children.length) ?? 0;
    m > f ? (i.getAttribute("data-show-children") === "false" && (i.setAttribute("data-show-children", "true"), r.set(t.getBlock(e), !0)), o.contains(c) && o.removeChild(c)) : m === 0 && m < f && (i.getAttribute("data-show-children") === "true" && (i.setAttribute("data-show-children", "false"), r.set(t.getBlock(e), !1)), o.contains(c) && o.removeChild(c)), f = m;
  });
  return r.get(e) ? (i.setAttribute("data-show-children", "true"), t.isEditable && e.children.length === 0 && o.appendChild(c)) : i.setAttribute("data-show-children", "false"), {
    dom: o,
    // Prevents re-renders when the toggle button is clicked.
    ignoreMutation: (p) => p instanceof MutationRecord && // We want to prevent re-renders when the view changes, so we ignore
    // all mutations where the `data-show-children` attribute is changed
    // or the "add block" button is added/removed.
    (p.type === "attributes" && p.target === i && p.attributeName === "data-show-children" || p.type === "childList" && (p.addedNodes[0] === c || p.removedNodes[0] === c)),
    destroy: () => {
      s.removeEventListener("mousedown", a), s.removeEventListener("click", l), c.removeEventListener(
        "mousedown",
        u
      ), c.removeEventListener(
        "click",
        d
      ), h == null || h();
    }
  };
}, p2 = [1, 2, 3, 4, 5, 6], E6 = (e) => ({ editor: t }) => {
  const n = t.getTextCursorPosition();
  return t.schema.blockSchema[n.block.type].content !== "inline" ? !1 : (t.updateBlock(n.block, {
    type: "heading",
    props: { level: e }
  }), !0);
}, k6 = ({
  defaultLevel: e = 1,
  levels: t = p2,
  allowToggleHeadings: n = !0
} = {}) => ({
  type: "heading",
  propSchema: {
    ...$e,
    level: { default: e, values: t },
    ...n ? { isToggleable: { default: !1, optional: !0 } } : {}
  },
  content: "inline"
}), C6 = xn(
  k6,
  ({ allowToggleHeadings: e = !0 } = {}) => ({
    meta: {
      isolating: !1
    },
    parse(t) {
      let n;
      switch (t.tagName) {
        case "H1":
          n = 1;
          break;
        case "H2":
          n = 2;
          break;
        case "H3":
          n = 3;
          break;
        case "H4":
          n = 4;
          break;
        case "H5":
          n = 5;
          break;
        case "H6":
          n = 6;
          break;
        default:
          return;
      }
      return {
        ...ln(t),
        level: n
      };
    },
    render(t, n) {
      const r = document.createElement(`h${t.props.level}`);
      return e ? { ...h2(t, n, r), contentDOM: r } : {
        dom: r,
        contentDOM: r
      };
    },
    toExternalHTML(t) {
      const n = document.createElement(`h${t.props.level}`);
      return Zo(t.props, n), {
        dom: n,
        contentDOM: n
      };
    }
  }),
  ({ levels: e = p2 } = {}) => [
    He({
      key: "heading-shortcuts",
      keyboardShortcuts: Object.fromEntries(
        e.map((t) => [
          `Mod-Alt-${t}`,
          E6(t)
        ]) ?? []
      ),
      inputRules: e.map((t) => ({
        find: new RegExp(`^(#{${t}})\\s$`),
        replace({ match: n }) {
          return {
            type: "heading",
            props: {
              level: n[1].length
            }
          };
        }
      }))
    })
  ]
), m2 = (e, t, n, r, o) => {
  const { dom: i, destroy: s } = Ep(
    e,
    t,
    n,
    o
  ), a = i;
  a.style.position = "relative", e.props.url && e.props.showPreview && (e.props.previewWidth ? a.style.width = `${e.props.previewWidth}px` : a.style.width = "fit-content");
  const l = document.createElement("div");
  l.className = "bn-resize-handle", l.style.left = "4px";
  const c = document.createElement("div");
  c.className = "bn-resize-handle", c.style.right = "4px";
  const u = document.createElement("div");
  u.style.position = "absolute", u.style.height = "100%", u.style.width = "100%";
  let d, f = e.props.previewWidth;
  const h = (C) => {
    var _, w;
    if (!d) {
      !t.isEditable && r.contains(l) && r.contains(c) && (r.removeChild(l), r.removeChild(c));
      return;
    }
    let T;
    const M = "touches" in C ? C.touches[0].clientX : C.clientX;
    e.props.textAlignment === "center" ? d.handleUsed === "left" ? T = d.initialWidth + (d.initialClientX - M) * 2 : T = d.initialWidth + (M - d.initialClientX) * 2 : d.handleUsed === "left" ? T = d.initialWidth + d.initialClientX - M : T = d.initialWidth + M - d.initialClientX, f = Math.min(
      Math.max(T, 64),
      ((w = (_ = t.domElement) == null ? void 0 : _.firstElementChild) == null ? void 0 : w.clientWidth) || Number.MAX_VALUE
    ), a.style.width = `${f}px`;
  }, p = (C) => {
    (!C.target || !a.contains(C.target) || !t.isEditable) && r.contains(l) && r.contains(c) && (r.removeChild(l), r.removeChild(c)), d && (d = void 0, a.contains(u) && a.removeChild(u), t.updateBlock(e, {
      props: {
        previewWidth: f
      }
    }));
  }, m = () => {
    t.isEditable && (r.appendChild(l), r.appendChild(c));
  }, b = (C) => {
    C.relatedTarget === l || C.relatedTarget === c || d || t.isEditable && r.contains(l) && r.contains(c) && (r.removeChild(l), r.removeChild(c));
  }, y = (C) => {
    C.preventDefault(), a.contains(u) || a.appendChild(u);
    const _ = "touches" in C ? C.touches[0].clientX : C.clientX;
    d = {
      handleUsed: "left",
      initialWidth: a.clientWidth,
      initialClientX: _
    };
  }, k = (C) => {
    C.preventDefault(), a.contains(u) || a.appendChild(u);
    const _ = "touches" in C ? C.touches[0].clientX : C.clientX;
    d = {
      handleUsed: "right",
      initialWidth: a.clientWidth,
      initialClientX: _
    };
  };
  return window.addEventListener("mousemove", h), window.addEventListener("touchmove", h), window.addEventListener("mouseup", p), window.addEventListener("touchend", p), a.addEventListener("mouseenter", m), a.addEventListener("mouseleave", b), l.addEventListener(
    "mousedown",
    y
  ), l.addEventListener(
    "touchstart",
    y
  ), c.addEventListener(
    "mousedown",
    k
  ), c.addEventListener(
    "touchstart",
    k
  ), {
    dom: a,
    destroy: () => {
      s == null || s(), window.removeEventListener("mousemove", h), window.removeEventListener("touchmove", h), window.removeEventListener("mouseup", p), window.removeEventListener("touchend", p), a.removeEventListener("mouseenter", m), a.removeEventListener("mouseleave", b), l.removeEventListener(
        "mousedown",
        y
      ), l.removeEventListener(
        "touchstart",
        y
      ), c.removeEventListener(
        "mousedown",
        k
      ), c.removeEventListener(
        "touchstart",
        k
      );
    }
  };
}, ag = (e) => {
  const t = e.src || void 0, n = e.width || void 0, r = e.alt || void 0;
  return { url: t, previewWidth: n, name: r };
}, T6 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z"></path></svg>', x6 = (e = {}) => ({
  type: "image",
  propSchema: {
    textAlignment: $e.textAlignment,
    backgroundColor: $e.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    },
    showPreview: {
      default: !0
    },
    // File preview width in px.
    previewWidth: {
      default: void 0,
      type: "number"
    }
  },
  content: "none"
}), w6 = (e = {}) => (t) => {
  if (t.tagName === "IMG") {
    if (t.closest("figure"))
      return;
    const { backgroundColor: n } = ln(t);
    return {
      ...ag(t),
      backgroundColor: n
    };
  }
  if (t.tagName === "FIGURE") {
    const n = Jc(t, "img");
    if (!n)
      return;
    const { targetElement: r, caption: o } = n, { backgroundColor: i } = ln(t);
    return {
      ...ag(r),
      backgroundColor: i,
      caption: o
    };
  }
}, v6 = (e = {}) => (t, n) => {
  const r = document.createElement("div");
  r.innerHTML = e.icon ?? T6;
  const o = document.createElement("div");
  o.className = "bn-visual-media-wrapper";
  const i = document.createElement("img");
  return i.className = "bn-visual-media", n.resolveFileUrl ? n.resolveFileUrl(t.props.url).then((s) => {
    i.src = s;
  }) : i.src = t.props.url, i.alt = t.props.name || t.props.caption || "BlockNote image", i.contentEditable = "false", i.draggable = !1, o.appendChild(i), m2(
    t,
    n,
    { dom: o },
    o,
    r.firstElementChild
  );
}, S6 = (e = {}) => (t, n) => {
  if (!t.props.url) {
    const o = document.createElement("p");
    return o.textContent = "Add image", {
      dom: o
    };
  }
  let r;
  return t.props.showPreview ? (r = document.createElement("img"), r.src = t.props.url, r.alt = t.props.name || t.props.caption || "BlockNote image", t.props.previewWidth && (r.width = t.props.previewWidth)) : (r = document.createElement("a"), r.href = t.props.url, r.textContent = t.props.name || t.props.url), t.props.caption ? t.props.showPreview ? kp(r, t.props.caption) : eu(r, t.props.caption) : {
    dom: r
  };
}, _6 = xn(
  x6,
  (e) => ({
    meta: {
      fileBlockAccept: ["image/*"]
    },
    parse: w6(e),
    render: v6(e),
    toExternalHTML: S6(e),
    runsBefore: ["file"]
  })
), A6 = (e, t, n) => ({
  state: r,
  dispatch: o
}) => o ? g2(r.tr, e, t, n) : !0, g2 = (e, t, n, r) => {
  const o = so(e.doc, t), i = ao(o);
  if (!i.isBlockContainer)
    return !1;
  const s = ht(e), a = [
    {
      type: i.bnBlock.node.type,
      // always keep blockcontainer type
      attrs: r ? { ...i.bnBlock.node.attrs, id: void 0 } : {}
    },
    {
      type: n ? i.blockContent.node.type : s.nodes.paragraph,
      attrs: r ? { ...i.blockContent.node.attrs } : {}
    }
  ];
  return e.split(t, 2, a), !0;
}, tu = (e, t) => {
  const { blockInfo: n, selectionEmpty: r } = e.transact((s) => ({
    blockInfo: ra(s),
    selectionEmpty: s.selection.anchor === s.selection.head
  }));
  if (!n.isBlockContainer)
    return !1;
  const { bnBlock: o, blockContent: i } = n;
  return i.node.type.name !== t || !r ? !1 : i.node.childCount === 0 ? (e.transact((s) => {
    Xc(s, o.beforePos, {
      type: "paragraph",
      props: {}
    });
  }), !0) : i.node.childCount > 0 ? e.transact((s) => (s.deleteSelection(), g2(s, s.selection.from, !0))) : !1;
};
function Cp(e, t, n) {
  var r, o, i;
  const s = Mn.fromSchema(t), a = e, l = document.createElement("div");
  l.setAttribute("data-node-type", "blockGroup");
  for (const h of Array.from(a.childNodes))
    l.appendChild(h.cloneNode(!0));
  let c = s.parse(l, {
    topNode: t.nodes.blockGroup.create()
  });
  ((o = (r = c.firstChild) == null ? void 0 : r.firstChild) == null ? void 0 : o.type.name) === "checkListItem" && (c = c.copy(
    c.content.cut(
      c.firstChild.firstChild.nodeSize + 2
    )
  ));
  const u = (i = c.firstChild) == null ? void 0 : i.firstChild;
  if (!(u != null && u.isTextblock))
    return be.from(c);
  const d = t.nodes[n].create(
    {},
    u.content
  ), f = c.content.cut(
    // +2 for the `blockGroup` node's start and end markers
    u.nodeSize + 2
  );
  if (f.size > 0) {
    const h = c.copy(f);
    return d.content.addToEnd(h);
  }
  return d.content;
}
const I6 = () => ({
  type: "bulletListItem",
  propSchema: {
    ...$e
  },
  content: "inline"
}), N6 = xn(
  I6,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      var t;
      if (e.tagName !== "LI")
        return;
      const n = e.parentElement;
      if (n !== null && (n.tagName === "UL" || n.tagName === "DIV" && ((t = n.parentElement) == null ? void 0 : t.tagName) === "UL"))
        return ln(e);
    },
    // As `li` elements can contain multiple paragraphs, we need to merge their contents
    // into a single one so that ProseMirror can parse everything correctly.
    parseContent: ({ el: e, schema: t }) => Cp(e, t, "bulletListItem"),
    render() {
      const e = document.createElement("p");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("p");
      return Zo(e.props, t), t.appendChild(n), {
        dom: t,
        contentDOM: n
      };
    }
  },
  [
    He({
      key: "bullet-list-item-shortcuts",
      keyboardShortcuts: {
        Enter: ({ editor: e }) => tu(e, "bulletListItem"),
        "Mod-Shift-8": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "bulletListItem",
            props: {}
          }), !0);
        }
      },
      inputRules: [
        {
          find: /^\s?[-+*]\s$/,
          replace({ editor: e }) {
            if (Jt(
              e.prosemirrorState
            ).blockNoteType !== "heading")
              return {
                type: "bulletListItem",
                props: {}
              };
          }
        }
      ]
    })
  ]
), M6 = () => ({
  type: "checkListItem",
  propSchema: {
    ...$e,
    checked: { default: !1, type: "boolean" }
  },
  content: "inline"
}), L6 = xn(
  M6,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      var t;
      if (e.tagName === "input")
        return e.closest("[data-content-type]") || e.closest("li") ? void 0 : e.type === "checkbox" ? { checked: e.checked } : void 0;
      if (e.tagName !== "LI")
        return;
      const n = e.parentElement;
      if (n !== null && (n.tagName === "UL" || n.tagName === "DIV" && ((t = n.parentElement) == null ? void 0 : t.tagName) === "UL")) {
        const r = e.querySelector("input[type=checkbox]") || null;
        return r === null ? void 0 : { ...ln(e), checked: r.checked };
      }
    },
    // As `li` elements can contain multiple paragraphs, we need to merge their contents
    // into a single one so that ProseMirror can parse everything correctly.
    parseContent: ({ el: e, schema: t }) => Cp(e, t, "checkListItem"),
    render(e, t) {
      const n = document.createDocumentFragment(), r = document.createElement("input");
      r.type = "checkbox", r.checked = e.props.checked, e.props.checked && r.setAttribute("checked", ""), r.addEventListener("change", () => {
        t.updateBlock(e, { props: { checked: !e.props.checked } });
      });
      const o = document.createElement("p"), i = document.createElement("div");
      return i.contentEditable = "false", i.appendChild(r), n.appendChild(i), n.appendChild(o), {
        dom: n,
        contentDOM: o
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("input");
      n.type = "checkbox", n.checked = e.props.checked, e.props.checked && n.setAttribute("checked", "");
      const r = document.createElement("p");
      return Zo(e.props, t), t.appendChild(n), t.appendChild(r), {
        dom: t,
        contentDOM: r
      };
    },
    runsBefore: ["bulletListItem"]
  },
  [
    He({
      key: "check-list-item-shortcuts",
      keyboardShortcuts: {
        Enter: ({ editor: e }) => tu(e, "checkListItem"),
        "Mod-Shift-9": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "checkListItem",
            props: {}
          }), !0);
        }
      },
      inputRules: [
        {
          find: /^\s?\[\s*\]\s$/,
          replace() {
            return {
              type: "checkListItem",
              props: {
                checked: !1
              }
            };
          }
        },
        {
          find: /^\s?\[[Xx]\]\s$/,
          replace() {
            return {
              type: "checkListItem",
              props: {
                checked: !0
              }
            };
          }
        }
      ]
    })
  ]
);
function b2(e, t, n, r) {
  let o = e.firstChild.attrs.start || 1, i = !0;
  const s = !!e.firstChild.attrs.start, a = ao({
    posBeforeNode: t,
    node: e
  });
  if (!a.isBlockContainer)
    throw new Error("impossible");
  const l = n.doc.resolve(a.bnBlock.beforePos).nodeBefore, c = l ? r.get(l) : void 0;
  return c !== void 0 ? (o = c + 1, i = !1) : l && ao({
    posBeforeNode: a.bnBlock.beforePos - l.nodeSize,
    node: l
  }).blockNoteType === "numberedListItem" && (o = b2(
    l,
    a.bnBlock.beforePos - l.nodeSize,
    n,
    r
  ).index + 1, i = !1), r.set(e, o), { index: o, isFirst: i, hasStart: s };
}
function lg(e, t) {
  const n = /* @__PURE__ */ new Map(), r = t.decorations.map(
    e.mapping,
    e.doc
  ), o = [];
  e.doc.nodesBetween(0, e.doc.nodeSize - 2, (s, a) => {
    if (s.type.name === "blockContainer" && s.firstChild.type.name === "numberedListItem") {
      const { index: l, isFirst: c, hasStart: u } = b2(
        s,
        a,
        e,
        n
      );
      if (r.find(
        a,
        a + s.nodeSize,
        (d) => d.index === l && d.isFirst === c && d.hasStart === u
      ).length === 0) {
        const d = e.doc.nodeAt(a + 1);
        o.push(
          // move in by 1 to account for the block container
          Lt.node(a + 1, a + 1 + d.nodeSize, {
            "data-index": l.toString()
          })
        );
      }
    }
  });
  const i = o.flatMap(
    (s) => r.find(s.from, s.to)
  );
  return {
    decorations: r.remove(i).add(e.doc, o)
  };
}
const O6 = () => new me({
  key: new we("numbered-list-indexing-decorations"),
  state: {
    init(e, t) {
      return lg(t.tr, {
        decorations: kt.empty
      });
    },
    apply(e, t) {
      return !e.docChanged && !e.selectionSet && t.decorations ? t : lg(e, t);
    }
  },
  props: {
    decorations(e) {
      var t;
      return ((t = this.getState(e)) == null ? void 0 : t.decorations) ?? kt.empty;
    }
  }
}), D6 = () => ({
  type: "numberedListItem",
  propSchema: {
    ...$e,
    start: { default: void 0, type: "number" }
  },
  content: "inline"
}), R6 = xn(
  D6,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      var t;
      if (e.tagName !== "LI")
        return;
      const n = e.parentElement;
      if (n !== null && (n.tagName === "OL" || n.tagName === "DIV" && ((t = n.parentElement) == null ? void 0 : t.tagName) === "OL")) {
        const r = parseInt(n.getAttribute("start") || "1"), o = ln(e);
        return e.previousElementSibling || r === 1 ? o : {
          ...o,
          start: r
        };
      }
    },
    // As `li` elements can contain multiple paragraphs, we need to merge their contents
    // into a single one so that ProseMirror can parse everything correctly.
    parseContent: ({ el: e, schema: t }) => Cp(e, t, "numberedListItem"),
    render() {
      const e = document.createElement("p");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("p");
      return Zo(e.props, t), t.appendChild(n), {
        dom: t,
        contentDOM: n
      };
    }
  },
  [
    He({
      key: "numbered-list-item-shortcuts",
      inputRules: [
        {
          find: /^\s?(\d+)\.\s$/,
          replace({ match: e, editor: t }) {
            if (Jt(
              t.prosemirrorState
            ).blockNoteType === "heading")
              return;
            const n = parseInt(e[1]);
            return {
              type: "numberedListItem",
              props: {
                start: n !== 1 ? n : void 0
              }
            };
          }
        }
      ],
      keyboardShortcuts: {
        Enter: ({ editor: e }) => tu(e, "numberedListItem"),
        "Mod-Shift-7": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "numberedListItem",
            props: {}
          }), !0);
        }
      },
      prosemirrorPlugins: [O6()]
    })
  ]
), P6 = () => ({
  type: "toggleListItem",
  propSchema: {
    ...$e
  },
  content: "inline"
}), B6 = xn(
  P6,
  {
    meta: {
      isolating: !1
    },
    render(e, t) {
      const n = document.createElement("p");
      return { ...h2(
        e,
        t,
        n
      ), contentDOM: n };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("p");
      return Zo(e.props, t), t.appendChild(n), {
        dom: t,
        contentDOM: n
      };
    }
  },
  [
    He({
      key: "toggle-list-item-shortcuts",
      keyboardShortcuts: {
        Enter: ({ editor: e }) => tu(e, "toggleListItem"),
        "Mod-Shift-6": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "toggleListItem",
            props: {}
          }), !0);
        }
      }
    })
  ]
), $6 = () => ({
  type: "paragraph",
  propSchema: $e,
  content: "inline"
}), y2 = xn(
  $6,
  {
    meta: {
      isolating: !1
    },
    parse: (e) => {
      var t;
      if (e.tagName === "P" && (t = e.textContent) != null && t.trim())
        return ln(e);
    },
    render: () => {
      const e = document.createElement("p");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML: (e) => {
      const t = document.createElement("p");
      return Zo(e.props, t), {
        dom: t,
        contentDOM: t
      };
    },
    runsBefore: ["default"]
  },
  [
    He({
      key: "paragraph-shortcuts",
      keyboardShortcuts: {
        "Mod-Alt-0": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "paragraph",
            props: {}
          }), !0);
        }
      }
    })
  ]
), H6 = () => ({
  type: "quote",
  propSchema: {
    backgroundColor: $e.backgroundColor,
    textColor: $e.textColor
  },
  content: "inline"
}), F6 = xn(
  H6,
  {
    meta: {
      isolating: !1
    },
    parse(e) {
      if (e.tagName === "BLOCKQUOTE") {
        const { backgroundColor: t, textColor: n } = ln(e);
        return { backgroundColor: t, textColor: n };
      }
    },
    render() {
      const e = document.createElement("blockquote");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("blockquote");
      return Zo(e.props, t), {
        dom: t,
        contentDOM: t
      };
    }
  },
  [
    He({
      key: "quote-block-shortcuts",
      keyboardShortcuts: {
        "Mod-Alt-q": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? !1 : (e.updateBlock(t.block, {
            type: "quote",
            props: {}
          }), !0);
        }
      },
      inputRules: [
        {
          find: new RegExp("^>\\s$"),
          replace() {
            return {
              type: "quote",
              props: {}
            };
          }
        }
      ]
    })
  ]
), U6 = 35, nu = 120, j6 = 31, V6 = ut.create({
  name: "BlockNoteTableExtension",
  addProseMirrorPlugins: () => [
    UA({
      cellMinWidth: U6,
      defaultCellMinWidth: nu,
      // We set this to null as we implement our own node view in the table
      // block content. This node view is the same as what's used by default,
      // but is wrapped in a `blockContent` HTML element.
      View: null
    }),
    ZA()
  ],
  addKeyboardShortcuts() {
    return {
      // Makes enter create a new line within the cell.
      Enter: () => this.editor.state.selection.empty && this.editor.state.selection.$head.parent.type.name === "tableParagraph" ? (this.editor.commands.insertContent({ type: "hardBreak" }), !0) : !1,
      // Ensures that backspace won't delete the table if the text cursor is at
      // the start of a cell and the selection is empty.
      Backspace: () => {
        const e = this.editor.state.selection, t = e.empty, n = e.$head.parentOffset === 0, r = e.$head.node().type.name === "tableParagraph";
        return t && n && r;
      },
      // Enables navigating cells using the tab key.
      Tab: () => this.editor.commands.command(
        ({ state: e, dispatch: t, view: n }) => d0(1)(e, t, n)
      ),
      "Shift-Tab": () => this.editor.commands.command(
        ({ state: e, dispatch: t, view: n }) => d0(-1)(e, t, n)
      )
    };
  },
  extendNodeSchema(e) {
    const t = {
      name: e.name,
      options: e.options,
      storage: e.storage
    };
    return {
      tableRole: We(
        te(e, "tableRole", t)
      )
    };
  }
}), z6 = {
  textColor: $e.textColor
}, q6 = Jn.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  /**
   * We allow table headers and cells to have multiple tableContent nodes because
   * when merging cells, prosemirror-tables will concat the contents of the cells naively.
   * This would cause that content to overflow into other cells when prosemirror tries to enforce the cell structure.
   *
   * So, we manually fix this up when reading back in the `nodeToBlock` and only ever place a single tableContent back into the cell.
   */
  content: "tableContent+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (e) => {
          const t = e.getAttribute("colwidth");
          return t ? t.split(",").map((n) => parseInt(n, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      {
        tag: "th",
        // As `th` elements can contain multiple paragraphs, we need to merge their contents
        // into a single one so that ProseMirror can parse everything correctly.
        getContent: (e, t) => E2(e, t)
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "th",
      kn(this.options.HTMLAttributes, e),
      0
    ];
  }
}), W6 = Jn.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "tableContent+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (e) => {
          const t = e.getAttribute("colwidth");
          return t ? t.split(",").map((n) => parseInt(n, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      {
        tag: "td",
        // As `td` elements can contain multiple paragraphs, we need to merge their contents
        // into a single one so that ProseMirror can parse everything correctly.
        getContent: (e, t) => E2(e, t)
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "td",
      kn(this.options.HTMLAttributes, e),
      0
    ];
  }
}), G6 = Jn.create({
  name: "table",
  content: "tableRow+",
  group: "blockContent",
  tableRole: "table",
  marks: "deletion insertion modification",
  isolating: !0,
  parseHTML() {
    return [
      {
        tag: "table"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    var n, r, o;
    const i = BM(
      this.name,
      "table",
      {
        ...((n = this.options.domAttributes) == null ? void 0 : n.blockContent) || {},
        ...t
      },
      ((r = this.options.domAttributes) == null ? void 0 : r.inlineContent) || {}
    ), s = document.createElement("colgroup");
    for (const a of e.children[0].children)
      if (a.attrs.colwidth)
        for (const l of a.attrs.colwidth) {
          const c = document.createElement("col");
          l && (c.style = `width: ${l}px`), s.appendChild(c);
        }
      else
        s.appendChild(document.createElement("col"));
    return (o = i.dom.firstChild) == null || o.appendChild(s), i;
  },
  // This node view is needed for the `columnResizing` plugin. By default, the
  // plugin adds its own node view, which overrides how the node is rendered vs
  // `renderHTML`. This means that the wrapping `blockContent` HTML element is
  // no longer rendered. The `columnResizing` plugin uses the `TableView` as its
  // default node view. `BlockNoteTableView` extends it by wrapping it in a
  // `blockContent` element, so the DOM structure is consistent with other block
  // types.
  addNodeView() {
    return ({ node: e, HTMLAttributes: t }) => {
      var n;
      class r extends DE {
        constructor(i, s, a) {
          super(i, s), this.node = i, this.cellMinWidth = s, this.blockContentHTMLAttributes = a;
          const l = document.createElement("div");
          l.className = dt(
            "bn-block-content",
            a.class
          ), l.setAttribute("data-content-type", "table");
          for (const [f, h] of Object.entries(
            a
          ))
            f !== "class" && l.setAttribute(f, h);
          const c = this.dom, u = document.createElement("div");
          u.className = "tableWrapper-inner", u.appendChild(c.firstChild), c.appendChild(u), l.appendChild(c);
          const d = document.createElement("div");
          d.className = "table-widgets-container", d.style.position = "relative", c.appendChild(d), this.dom = l;
        }
        ignoreMutation(i) {
          return !i.target.closest(".tableWrapper-inner") || super.ignoreMutation(i);
        }
      }
      return new r(e, nu, {
        ...((n = this.options.domAttributes) == null ? void 0 : n.blockContent) || {},
        ...t
      });
    };
  }
}), Y6 = Jn.create({
  name: "tableParagraph",
  group: "tableContent",
  content: "inline*",
  parseHTML() {
    return [
      {
        tag: "p",
        getAttrs: (e) => {
          if (typeof e == "string" || !e.textContent || !e.closest("[data-content-type]"))
            return !1;
          const t = e.parentElement;
          return t === null ? !1 : t.tagName === "TD" || t.tagName === "TH" ? {} : !1;
        },
        node: "tableParagraph"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["p", e, 0];
  }
}), K6 = Jn.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)+",
  tableRole: "row",
  marks: "deletion insertion modification",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "tr",
      kn(this.options.HTMLAttributes, e),
      0
    ];
  }
});
function E2(e, t) {
  const n = Mn.fromSchema(t).parse(e, {
    topNode: t.nodes.blockGroup.create()
  }), r = [];
  return n.content.descendants((o) => {
    if (o.isInline)
      return r.push(o), !1;
  }), be.fromArray(r);
}
const Q6 = () => jM(
  { node: G6, type: "table", content: "table" },
  z6,
  [
    He({
      key: "table-extensions",
      tiptapExtensions: [
        V6,
        Y6,
        q6,
        W6,
        K6
      ]
    }),
    // Extension for keyboard shortcut which deletes the table if it's empty
    // and all cells are selected. Uses a separate extension as it needs
    // priority over keyboard handlers in the `TableExtension`'s
    // `tableEditing` plugin.
    He({
      key: "table-keyboard-delete",
      keyboardShortcuts: {
        Backspace: ({ editor: e }) => {
          if (!(e.prosemirrorState.selection instanceof qe))
            return !1;
          const t = e.getTextCursorPosition().block, n = t.content;
          let r = 0;
          for (const i of n.rows)
            for (const s of i.cells) {
              if ("type" in s && s.content.length > 0 || !("type" in s) && s.length > 0)
                return !1;
              r++;
            }
          let o = 0;
          return e.prosemirrorState.selection.forEachCell(() => {
            o++;
          }), o < r ? !1 : (e.transact(() => {
            (e.getPrevBlock(t) || e.getNextBlock(t)) && e.setTextCursorPosition(t), e.removeBlocks([t]);
          }), !0);
        }
      }
    })
  ]
), cg = (e) => {
  const t = e.src || void 0, n = e.width || void 0;
  return { url: t, previewWidth: n };
}, Z6 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z"></path></svg>', X6 = (e) => ({
  type: "video",
  propSchema: {
    textAlignment: $e.textAlignment,
    backgroundColor: $e.backgroundColor,
    name: { default: "" },
    url: { default: "" },
    caption: { default: "" },
    showPreview: { default: !0 },
    previewWidth: { default: void 0, type: "number" }
  },
  content: "none"
}), J6 = (e) => (t) => {
  if (t.tagName === "VIDEO") {
    if (t.closest("figure"))
      return;
    const { backgroundColor: n } = ln(t);
    return {
      ...cg(t),
      backgroundColor: n
    };
  }
  if (t.tagName === "FIGURE") {
    const n = Jc(t, "video");
    if (!n)
      return;
    const { targetElement: r, caption: o } = n, { backgroundColor: i } = ln(t);
    return {
      ...cg(r),
      backgroundColor: i,
      caption: o
    };
  }
}, eL = xn(
  X6,
  (e) => ({
    meta: {
      fileBlockAccept: ["video/*"]
    },
    parse: J6(),
    render(t, n) {
      const r = document.createElement("div");
      r.innerHTML = e.icon ?? Z6;
      const o = document.createElement("div");
      o.className = "bn-visual-media-wrapper";
      const i = document.createElement("video");
      return i.className = "bn-visual-media", n.resolveFileUrl ? n.resolveFileUrl(t.props.url).then((s) => {
        i.src = s;
      }) : i.src = t.props.url, i.controls = !0, i.contentEditable = "false", i.draggable = !1, i.width = t.props.previewWidth, o.appendChild(i), m2(
        t,
        n,
        { dom: o },
        o,
        r.firstElementChild
      );
    },
    toExternalHTML(t) {
      if (!t.props.url) {
        const r = document.createElement("p");
        return r.textContent = "Add video", {
          dom: r
        };
      }
      let n;
      return t.props.showPreview ? (n = document.createElement("video"), n.src = t.props.url, t.props.previewWidth && (n.width = t.props.previewWidth)) : (n = document.createElement("a"), n.href = t.props.url, n.textContent = t.props.name || t.props.url), t.props.caption ? t.props.showPreview ? kp(n, t.props.caption) : eu(n, t.props.caption) : {
        dom: n
      };
    },
    runsBefore: ["file"]
  })
);
function rt(e, t, n) {
  if (!(t in e.schema.blockSpecs))
    return !1;
  if (!n)
    return !0;
  for (const [r, o] of Object.entries(n)) {
    if (!(r in e.schema.blockSpecs[t].config.propSchema))
      return !1;
    if (typeof o == "string") {
      if (e.schema.blockSpecs[t].config.propSchema[r].default !== void 0 && typeof e.schema.blockSpecs[t].config.propSchema[r].default !== o || e.schema.blockSpecs[t].config.propSchema[r].type !== void 0 && e.schema.blockSpecs[t].config.propSchema[r].type !== o)
        return !1;
    } else {
      if (e.schema.blockSpecs[t].config.propSchema[r].default !== o.default || e.schema.blockSpecs[t].config.propSchema[r].default === void 0 && o.default === void 0 && e.schema.blockSpecs[t].config.propSchema[r].type !== o.type || typeof e.schema.blockSpecs[t].config.propSchema[r].values != typeof o.values)
        return !1;
      if (typeof e.schema.blockSpecs[t].config.propSchema[r].values == "object" && typeof o.values == "object") {
        for (const i of o.values)
          if (!e.schema.blockSpecs[t].config.propSchema[r].values.includes(i))
            return !1;
      }
    }
  }
  return !0;
}
function on(e, t, n, r) {
  return rt(t, n, r) && e.type === n;
}
function Lf(e) {
  return e instanceof qe;
}
const Va = /* @__PURE__ */ new Map();
function tL(e) {
  if (Va.has(e))
    return Va.get(e);
  const t = new gv();
  return e._tiptapEditor.on("transaction", ({ transaction: n }) => {
    t.appendMapping(n.mapping);
  }), e._tiptapEditor.on("destroy", () => {
    Va.delete(e);
  }), Va.set(e, t), t;
}
function nL(e, t, n = "left") {
  const r = Xe.getState(e.prosemirrorState);
  if (!r) {
    const i = tL(e), s = i.maps.length;
    return () => i.slice(s).map(t, n === "left" ? -1 : 1);
  }
  const o = Ys(
    // Track the position after the position if we are on the right side
    t + (n === "right" ? 1 : -1),
    r.binding.type,
    r.binding.mapping
  );
  return () => {
    const i = Xe.getState(
      e.prosemirrorState
    ), s = Do(
      i.doc,
      i.binding.type,
      o,
      i.binding.mapping
    );
    if (s === null)
      throw new Error("Position not found, cannot track positions");
    return s + (n === "right" ? -1 : 1);
  };
}
const rL = Dc((e) => e.type.name === "blockContainer");
class oL {
  constructor(t, n, r) {
    So(this, "state"), So(this, "emitUpdate"), So(this, "rootEl"), So(this, "pluginState"), So(this, "handleScroll", () => {
      var i, s;
      if ((i = this.state) != null && i.show) {
        const a = (s = this.rootEl) == null ? void 0 : s.querySelector(
          `[data-decoration-id="${this.pluginState.decorationId}"]`
        );
        if (!a)
          return;
        this.state.referencePos = a.getBoundingClientRect().toJSON(), this.emitUpdate(this.pluginState.triggerCharacter);
      }
    }), So(this, "closeMenu", () => {
      this.editor.transact((i) => i.setMeta(Mo, null));
    }), So(this, "clearQuery", () => {
      this.pluginState !== void 0 && this.editor._tiptapEditor.chain().focus().deleteRange({
        from: this.pluginState.queryStartPos() - (this.pluginState.deleteTriggerCharacter ? this.pluginState.triggerCharacter.length : 0),
        to: this.editor.transact((i) => i.selection.from)
      }).run();
    });
    var o;
    this.editor = t, this.pluginState = void 0, this.emitUpdate = (i) => {
      var s;
      if (!this.state)
        throw new Error("Attempting to update uninitialized suggestions menu");
      n(i, {
        ...this.state,
        ignoreQueryLength: (s = this.pluginState) == null ? void 0 : s.ignoreQueryLength
      });
    }, this.rootEl = r.root, (o = this.rootEl) == null || o.addEventListener("scroll", this.handleScroll, !0);
  }
  update(t, n) {
    var r;
    const o = Mo.getState(n), i = Mo.getState(
      t.state
    ), s = o === void 0 && i !== void 0, a = o !== void 0 && i === void 0;
    if (!s && !(o !== void 0 && i !== void 0) && !a)
      return;
    if (this.pluginState = a ? o : i, a || !this.editor.isEditable) {
      this.state && (this.state.show = !1), this.emitUpdate(this.pluginState.triggerCharacter);
      return;
    }
    const l = (r = this.rootEl) == null ? void 0 : r.querySelector(
      `[data-decoration-id="${this.pluginState.decorationId}"]`
    );
    this.editor.isEditable && l && (this.state = {
      show: !0,
      referencePos: l.getBoundingClientRect().toJSON(),
      query: this.pluginState.query
    }, this.emitUpdate(this.pluginState.triggerCharacter));
  }
  destroy() {
    var t;
    (t = this.rootEl) == null || t.removeEventListener("scroll", this.handleScroll, !0);
  }
}
const Mo = new we("SuggestionMenuPlugin"), Rn = He(({ editor: e }) => {
  const t = [];
  let n;
  const r = yo(void 0);
  return {
    key: "suggestionMenu",
    store: r,
    addTriggerCharacter: (o) => {
      t.push(o);
    },
    removeTriggerCharacter: (o) => {
      t.splice(t.indexOf(o), 1);
    },
    closeMenu: () => {
      n == null || n.closeMenu();
    },
    clearQuery: () => {
      n == null || n.clearQuery();
    },
    shown: () => {
      var o;
      return ((o = n == null ? void 0 : n.state) == null ? void 0 : o.show) || !1;
    },
    openSuggestionMenu: (o, i) => {
      e.headless || (e.focus(), e.transact((s) => {
        i != null && i.deleteTriggerCharacter && s.insertText(o), s.scrollIntoView().setMeta(Mo, {
          triggerCharacter: o,
          deleteTriggerCharacter: (i == null ? void 0 : i.deleteTriggerCharacter) || !1,
          ignoreQueryLength: (i == null ? void 0 : i.ignoreQueryLength) || !1
        });
      }));
    },
    // TODO this whole plugin needs to be refactored (but I've done the minimal)
    prosemirrorPlugins: [
      new me({
        key: Mo,
        view: (o) => (n = new oL(
          e,
          (i, s) => {
            r.setState({ ...s, triggerCharacter: i });
          },
          o
        ), n),
        state: {
          // Initialize the plugin's internal state.
          init() {
          },
          // Apply changes to the plugin state from an editor transaction.
          apply: (o, i, s, a) => {
            if (o.selection.$from.parent.type.spec.code)
              return i;
            const l = o.getMeta(Mo);
            if (typeof l == "object" && l !== null) {
              i && (n == null || n.closeMenu());
              const u = nL(
                e,
                a.selection.from - // Need to account for the trigger char that was inserted, so we offset the position by the length of the trigger character.
                l.triggerCharacter.length
              );
              return {
                triggerCharacter: l.triggerCharacter,
                deleteTriggerCharacter: l.deleteTriggerCharacter !== !1,
                // When reading the queryStartPos, we offset the result by the length of the trigger character, to make it easy on the caller
                queryStartPos: () => u() + l.triggerCharacter.length,
                query: "",
                decorationId: `id_${Math.floor(Math.random() * 4294967295)}`,
                ignoreQueryLength: l == null ? void 0 : l.ignoreQueryLength
              };
            }
            if (i === void 0)
              return i;
            if (
              // Highlighting text should hide the menu.
              a.selection.from !== a.selection.to || // Transactions with plugin metadata should hide the menu.
              l === null || // Certain mouse events should hide the menu.
              // TODO: Change to global mousedown listener.
              o.getMeta("focus") || o.getMeta("blur") || o.getMeta("pointer") || // Moving the caret before the character which triggered the menu should hide it.
              i.triggerCharacter !== void 0 && a.selection.from < i.queryStartPos() || // Moving the caret to a new block should hide the menu.
              !a.selection.$from.sameParent(
                a.doc.resolve(i.queryStartPos())
              )
            )
              return;
            const c = { ...i };
            return c.query = a.doc.textBetween(
              i.queryStartPos(),
              a.selection.from
            ), c;
          }
        },
        props: {
          handleTextInput(o, i, s, a) {
            if (i === s) {
              const l = o.state.doc;
              for (const c of t) {
                const u = c.length > 1 ? l.textBetween(i - c.length, i) + a : a;
                if (c === u)
                  return o.dispatch(o.state.tr.insertText(a)), o.dispatch(
                    o.state.tr.setMeta(Mo, {
                      triggerCharacter: u
                    }).scrollIntoView()
                  ), !0;
              }
            }
            return !1;
          },
          // Setup decorator on the currently active suggestion.
          decorations(o) {
            const i = this.getState(o);
            if (i === void 0)
              return null;
            if (!i.deleteTriggerCharacter) {
              const s = rL(o.selection);
              if (s)
                return kt.create(o.doc, [
                  Lt.node(
                    s.pos,
                    s.pos + s.node.nodeSize,
                    {
                      nodeName: "span",
                      class: "bn-suggestion-decorator",
                      "data-decoration-id": i.decorationId
                    }
                  )
                ]);
            }
            return kt.create(o.doc, [
              Lt.inline(
                i.queryStartPos() - i.triggerCharacter.length,
                i.queryStartPos(),
                {
                  nodeName: "span",
                  class: "bn-suggestion-decorator",
                  "data-decoration-id": i.decorationId
                }
              )
            ]);
          }
        }
      })
    ]
  };
});
function iL(e) {
  let t = e.getTextCursorPosition().block, n = e.schema.blockSchema[t.type].content;
  for (; n === "none"; ) {
    if (t = e.getTextCursorPosition().nextBlock, t === void 0)
      return;
    n = e.schema.blockSchema[t.type].content, e.setTextCursorPosition(t, "end");
  }
}
function Dt(e, t) {
  const n = e.getTextCursorPosition().block;
  if (n.content === void 0)
    throw new Error("Slash Menu open in a block that doesn't contain content.");
  let r;
  return Array.isArray(n.content) && (n.content.length === 1 && $o(n.content[0]) && n.content[0].type === "text" && n.content[0].text === "/" || n.content.length === 0) ? (r = e.updateBlock(n, t), e.setTextCursorPosition(r)) : (r = e.insertBlocks([t], n, "after")[0], e.setTextCursorPosition(e.getTextCursorPosition().nextBlock)), iL(e), r;
}
function sL(e) {
  const t = [];
  return rt(e, "heading", { level: "number" }) && (e.schema.blockSchema.heading.propSchema.level.values || []).filter((n) => n <= 3).forEach((n) => {
    t.push({
      onItemClick: () => {
        Dt(e, {
          type: "heading",
          props: { level: n }
        });
      },
      badge: Sn(`Mod-Alt-${n}`),
      key: n === 1 ? "heading" : `heading_${n}`,
      ...e.dictionary.slash_menu[n === 1 ? "heading" : `heading_${n}`]
    });
  }), rt(e, "quote") && t.push({
    onItemClick: () => {
      Dt(e, {
        type: "quote"
      });
    },
    key: "quote",
    ...e.dictionary.slash_menu.quote
  }), rt(e, "toggleListItem") && t.push({
    onItemClick: () => {
      Dt(e, {
        type: "toggleListItem"
      });
    },
    badge: Sn("Mod-Shift-6"),
    key: "toggle_list",
    ...e.dictionary.slash_menu.toggle_list
  }), rt(e, "numberedListItem") && t.push({
    onItemClick: () => {
      Dt(e, {
        type: "numberedListItem"
      });
    },
    badge: Sn("Mod-Shift-7"),
    key: "numbered_list",
    ...e.dictionary.slash_menu.numbered_list
  }), rt(e, "bulletListItem") && t.push({
    onItemClick: () => {
      Dt(e, {
        type: "bulletListItem"
      });
    },
    badge: Sn("Mod-Shift-8"),
    key: "bullet_list",
    ...e.dictionary.slash_menu.bullet_list
  }), rt(e, "checkListItem") && t.push({
    onItemClick: () => {
      Dt(e, {
        type: "checkListItem"
      });
    },
    badge: Sn("Mod-Shift-9"),
    key: "check_list",
    ...e.dictionary.slash_menu.check_list
  }), rt(e, "paragraph") && t.push({
    onItemClick: () => {
      Dt(e, {
        type: "paragraph"
      });
    },
    badge: Sn("Mod-Alt-0"),
    key: "paragraph",
    ...e.dictionary.slash_menu.paragraph
  }), rt(e, "codeBlock") && t.push({
    onItemClick: () => {
      Dt(e, {
        type: "codeBlock"
      });
    },
    badge: Sn("Mod-Alt-c"),
    key: "code_block",
    ...e.dictionary.slash_menu.code_block
  }), rt(e, "divider") && t.push({
    onItemClick: () => {
      Dt(e, { type: "divider" });
    },
    key: "divider",
    ...e.dictionary.slash_menu.divider
  }), rt(e, "table") && t.push({
    onItemClick: () => {
      Dt(e, {
        type: "table",
        content: {
          type: "tableContent",
          rows: [
            {
              cells: ["", "", ""]
            },
            {
              cells: ["", "", ""]
            }
          ]
        }
      });
    },
    badge: void 0,
    key: "table",
    ...e.dictionary.slash_menu.table
  }), rt(e, "image", { url: "string" }) && t.push({
    onItemClick: () => {
      var n;
      const r = Dt(e, {
        type: "image"
      });
      (n = e.getExtension(zn)) == null || n.showMenu(r.id);
    },
    key: "image",
    ...e.dictionary.slash_menu.image
  }), rt(e, "video", { url: "string" }) && t.push({
    onItemClick: () => {
      var n;
      const r = Dt(e, {
        type: "video"
      });
      (n = e.getExtension(zn)) == null || n.showMenu(r.id);
    },
    key: "video",
    ...e.dictionary.slash_menu.video
  }), rt(e, "audio", { url: "string" }) && t.push({
    onItemClick: () => {
      var n;
      const r = Dt(e, {
        type: "audio"
      });
      (n = e.getExtension(zn)) == null || n.showMenu(r.id);
    },
    key: "audio",
    ...e.dictionary.slash_menu.audio
  }), rt(e, "file", { url: "string" }) && t.push({
    onItemClick: () => {
      var n;
      const r = Dt(e, {
        type: "file"
      });
      (n = e.getExtension(zn)) == null || n.showMenu(r.id);
    },
    key: "file",
    ...e.dictionary.slash_menu.file
  }), rt(e, "heading", {
    level: "number",
    isToggleable: "boolean"
  }) && (e.schema.blockSchema.heading.propSchema.level.values || []).filter((n) => n <= 3).forEach((n) => {
    t.push({
      onItemClick: () => {
        Dt(e, {
          type: "heading",
          props: { level: n, isToggleable: !0 }
        });
      },
      key: n === 1 ? "toggle_heading" : `toggle_heading_${n}`,
      ...e.dictionary.slash_menu[n === 1 ? "toggle_heading" : `toggle_heading_${n}`]
    });
  }), rt(e, "heading", { level: "number" }) && (e.schema.blockSchema.heading.propSchema.level.values || []).filter((n) => n > 3).forEach((n) => {
    t.push({
      onItemClick: () => {
        Dt(e, {
          type: "heading",
          props: { level: n }
        });
      },
      badge: Sn(`Mod-Alt-${n}`),
      key: `heading_${n}`,
      ...e.dictionary.slash_menu[`heading_${n}`]
    });
  }), t.push({
    onItemClick: () => {
      var n;
      (n = e.getExtension(Rn)) == null || n.openSuggestionMenu(":", {
        deleteTriggerCharacter: !0,
        ignoreQueryLength: !0
      });
    },
    key: "emoji",
    ...e.dictionary.slash_menu.emoji
  }), t;
}
function aL(e, t) {
  return e.filter(
    ({ title: n, aliases: r }) => n.toLowerCase().includes(t.toLowerCase()) || r && r.filter(
      (o) => o.toLowerCase().includes(t.toLowerCase())
    ).length !== 0
  );
}
const lL = {
  audio: c6(),
  bulletListItem: N6(),
  checkListItem: L6(),
  codeBlock: f6(),
  divider: p6(),
  file: b6(),
  heading: C6(),
  image: _6(),
  numberedListItem: R6(),
  paragraph: y2(),
  quote: F6(),
  table: Q6(),
  toggleListItem: B6(),
  video: eL()
}, cL = d2(
  {
    type: "textColor",
    propSchema: "string"
  },
  {
    render: () => {
      const e = document.createElement("span");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML: (e) => {
      const t = document.createElement("span");
      return e !== $e.textColor.default && (t.style.color = e in eo ? eo[e].text : e), {
        dom: t,
        contentDOM: t
      };
    },
    parse: (e) => {
      if (e.tagName === "SPAN" && e.style.color)
        return e.style.color;
    }
  }
), uL = d2(
  {
    type: "backgroundColor",
    propSchema: "string"
  },
  {
    render: () => {
      const e = document.createElement("span");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML: (e) => {
      const t = document.createElement("span");
      return e !== $e.backgroundColor.default && (t.style.backgroundColor = e in eo ? eo[e].background : e), {
        dom: t,
        contentDOM: t
      };
    },
    parse: (e) => {
      if (e.tagName === "SPAN" && e.style.backgroundColor)
        return e.style.backgroundColor;
    }
  }
), Tp = {
  bold: os(hM, "boolean"),
  italic: os(xM, "boolean"),
  underline: os(IM, "boolean"),
  strike: os(_M, "boolean"),
  code: os(bM, "boolean"),
  textColor: cL,
  backgroundColor: uL
};
u2(Tp);
const k2 = {
  text: { config: "text", implementation: {} },
  link: { config: "link", implementation: {} }
}, dL = l2(
  k2
);
var fL = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
};
const hL = /* @__PURE__ */ Oy(fL);
class fa {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
fa.prototype.normal = {};
fa.prototype.property = {};
fa.prototype.space = void 0;
function C2(e, t) {
  const n = {}, r = {};
  for (const o of e)
    Object.assign(n, o.property), Object.assign(r, o.normal);
  return new fa(n, r, t);
}
function Ks(e) {
  return e.toLowerCase();
}
class un {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
un.prototype.attribute = "";
un.prototype.booleanish = !1;
un.prototype.boolean = !1;
un.prototype.commaOrSpaceSeparated = !1;
un.prototype.commaSeparated = !1;
un.prototype.defined = !1;
un.prototype.mustUseProperty = !1;
un.prototype.number = !1;
un.prototype.overloadedBoolean = !1;
un.prototype.property = "";
un.prototype.spaceSeparated = !1;
un.prototype.space = void 0;
let pL = 0;
const ke = Xo(), bt = Xo(), Of = Xo(), G = Xo(), Ze = Xo(), xi = Xo(), pn = Xo();
function Xo() {
  return 2 ** ++pL;
}
const Df = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: ke,
  booleanish: bt,
  commaOrSpaceSeparated: pn,
  commaSeparated: xi,
  number: G,
  overloadedBoolean: Of,
  spaceSeparated: Ze
}, Symbol.toStringTag, { value: "Module" })), ld = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(Df)
);
class xp extends un {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, o) {
    let i = -1;
    if (super(t, n), ug(this, "space", o), typeof r == "number")
      for (; ++i < ld.length; ) {
        const s = ld[i];
        ug(this, ld[i], (r & Df[s]) === Df[s]);
      }
  }
}
xp.prototype.defined = !0;
function ug(e, t, n) {
  n && (e[t] = n);
}
function Gi(e) {
  const t = {}, n = {};
  for (const [r, o] of Object.entries(e.properties)) {
    const i = new xp(
      r,
      e.transform(e.attributes || {}, r),
      o,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0), t[r] = i, n[Ks(r)] = r, n[Ks(i.attribute)] = r;
  }
  return new fa(t, n, e.space);
}
const T2 = Gi({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: bt,
    ariaAutoComplete: null,
    ariaBusy: bt,
    ariaChecked: bt,
    ariaColCount: G,
    ariaColIndex: G,
    ariaColSpan: G,
    ariaControls: Ze,
    ariaCurrent: null,
    ariaDescribedBy: Ze,
    ariaDetails: null,
    ariaDisabled: bt,
    ariaDropEffect: Ze,
    ariaErrorMessage: null,
    ariaExpanded: bt,
    ariaFlowTo: Ze,
    ariaGrabbed: bt,
    ariaHasPopup: null,
    ariaHidden: bt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Ze,
    ariaLevel: G,
    ariaLive: null,
    ariaModal: bt,
    ariaMultiLine: bt,
    ariaMultiSelectable: bt,
    ariaOrientation: null,
    ariaOwns: Ze,
    ariaPlaceholder: null,
    ariaPosInSet: G,
    ariaPressed: bt,
    ariaReadOnly: bt,
    ariaRelevant: null,
    ariaRequired: bt,
    ariaRoleDescription: Ze,
    ariaRowCount: G,
    ariaRowIndex: G,
    ariaRowSpan: G,
    ariaSelected: bt,
    ariaSetSize: G,
    ariaSort: null,
    ariaValueMax: G,
    ariaValueMin: G,
    ariaValueNow: G,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function x2(e, t) {
  return t in e ? e[t] : t;
}
function w2(e, t) {
  return x2(e, t.toLowerCase());
}
const mL = Gi({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: xi,
    acceptCharset: Ze,
    accessKey: Ze,
    action: null,
    allow: null,
    allowFullScreen: ke,
    allowPaymentRequest: ke,
    allowUserMedia: ke,
    alt: null,
    as: null,
    async: ke,
    autoCapitalize: null,
    autoComplete: Ze,
    autoFocus: ke,
    autoPlay: ke,
    blocking: Ze,
    capture: null,
    charSet: null,
    checked: ke,
    cite: null,
    className: Ze,
    cols: G,
    colSpan: null,
    content: null,
    contentEditable: bt,
    controls: ke,
    controlsList: Ze,
    coords: G | xi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: ke,
    defer: ke,
    dir: null,
    dirName: null,
    disabled: ke,
    download: Of,
    draggable: bt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: ke,
    formTarget: null,
    headers: Ze,
    height: G,
    hidden: Of,
    high: G,
    href: null,
    hrefLang: null,
    htmlFor: Ze,
    httpEquiv: Ze,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: ke,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: ke,
    itemId: null,
    itemProp: Ze,
    itemRef: Ze,
    itemScope: ke,
    itemType: Ze,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: ke,
    low: G,
    manifest: null,
    max: null,
    maxLength: G,
    media: null,
    method: null,
    min: null,
    minLength: G,
    multiple: ke,
    muted: ke,
    name: null,
    nonce: null,
    noModule: ke,
    noValidate: ke,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: ke,
    optimum: G,
    pattern: null,
    ping: Ze,
    placeholder: null,
    playsInline: ke,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: ke,
    referrerPolicy: null,
    rel: Ze,
    required: ke,
    reversed: ke,
    rows: G,
    rowSpan: G,
    sandbox: Ze,
    scope: null,
    scoped: ke,
    seamless: ke,
    selected: ke,
    shadowRootClonable: ke,
    shadowRootDelegatesFocus: ke,
    shadowRootMode: null,
    shape: null,
    size: G,
    sizes: null,
    slot: null,
    span: G,
    spellCheck: bt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: G,
    step: null,
    style: null,
    tabIndex: G,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: ke,
    useMap: null,
    value: bt,
    width: G,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Ze,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: G,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: G,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: ke,
    // Lists. Use CSS to reduce space between items instead
    declare: ke,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: G,
    // `<img>` and `<object>`
    leftMargin: G,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: G,
    // `<body>`
    marginWidth: G,
    // `<body>`
    noResize: ke,
    // `<frame>`
    noHref: ke,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: ke,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: ke,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: G,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: bt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: G,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: G,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: ke,
    disableRemotePlayback: ke,
    prefix: null,
    property: null,
    results: G,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: w2
}), gL = Gi({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: pn,
    accentHeight: G,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: G,
    amplitude: G,
    arabicForm: null,
    ascent: G,
    attributeName: null,
    attributeType: null,
    azimuth: G,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: G,
    by: null,
    calcMode: null,
    capHeight: G,
    className: Ze,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: G,
    diffuseConstant: G,
    direction: null,
    display: null,
    dur: null,
    divisor: G,
    dominantBaseline: null,
    download: ke,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: G,
    enableBackground: null,
    end: null,
    event: null,
    exponent: G,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: G,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: xi,
    g2: xi,
    glyphName: xi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: G,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: G,
    horizOriginX: G,
    horizOriginY: G,
    id: null,
    ideographic: G,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: G,
    k: G,
    k1: G,
    k2: G,
    k3: G,
    k4: G,
    kernelMatrix: pn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: G,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: G,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: G,
    overlineThickness: G,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: G,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Ze,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: G,
    pointsAtY: G,
    pointsAtZ: G,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: pn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: pn,
    rev: pn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: pn,
    requiredFeatures: pn,
    requiredFonts: pn,
    requiredFormats: pn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: G,
    specularExponent: G,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: G,
    strikethroughThickness: G,
    string: null,
    stroke: null,
    strokeDashArray: pn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: G,
    strokeOpacity: G,
    strokeWidth: null,
    style: null,
    surfaceScale: G,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: pn,
    tabIndex: G,
    tableValues: null,
    target: null,
    targetX: G,
    targetY: G,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: pn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: G,
    underlineThickness: G,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: G,
    values: null,
    vAlphabetic: G,
    vMathematical: G,
    vectorEffect: null,
    vHanging: G,
    vIdeographic: G,
    version: null,
    vertAdvY: G,
    vertOriginX: G,
    vertOriginY: G,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: G,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: x2
}), v2 = Gi({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), S2 = Gi({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: w2
}), _2 = Gi({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), bL = /[A-Z]/g, dg = /-[a-z]/g, yL = /^data[-\w.:]+$/i;
function wp(e, t) {
  const n = Ks(t);
  let r = t, o = un;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && yL.test(t)) {
    if (t.charAt(4) === "-") {
      const i = t.slice(5).replace(dg, kL);
      r = "data" + i.charAt(0).toUpperCase() + i.slice(1);
    } else {
      const i = t.slice(4);
      if (!dg.test(i)) {
        let s = i.replace(bL, EL);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    o = xp;
  }
  return new o(r, t);
}
function EL(e) {
  return "-" + e.toLowerCase();
}
function kL(e) {
  return e.charAt(1).toUpperCase();
}
const ru = C2([T2, mL, v2, S2, _2], "html"), ha = C2([T2, gL, v2, S2, _2], "svg");
function fg(e) {
  const t = [], n = String(e || "");
  let r = n.indexOf(","), o = 0, i = !1;
  for (; !i; ) {
    r === -1 && (r = n.length, i = !0);
    const s = n.slice(o, r).trim();
    (s || !i) && t.push(s), o = r + 1, r = n.indexOf(",", o);
  }
  return t;
}
function CL(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const hg = /[#.]/g;
function TL(e, t) {
  const n = e || "", r = {};
  let o = 0, i, s;
  for (; o < n.length; ) {
    hg.lastIndex = o;
    const a = hg.exec(n), l = n.slice(o, a ? a.index : n.length);
    l && (i ? i === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : s = l, o += l.length), a && (i = a[0], o++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: s || t || "div",
    properties: r,
    children: []
  };
}
function pg(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function xL(e) {
  return e.join(" ").trim();
}
function A2(e, t, n) {
  const r = n ? _L(n) : void 0;
  function o(i, s, ...a) {
    let l;
    if (i == null) {
      l = { type: "root", children: [] };
      const c = (
        /** @type {Child} */
        s
      );
      a.unshift(c);
    } else {
      l = TL(i, t);
      const c = l.tagName.toLowerCase(), u = r ? r.get(c) : void 0;
      if (l.tagName = u || c, wL(s))
        a.unshift(s);
      else
        for (const [d, f] of Object.entries(s))
          vL(e, l.properties, d, f);
    }
    for (const c of a)
      Rf(l.children, c);
    return l.type === "element" && l.tagName === "template" && (l.content = { type: "root", children: l.children }, l.children = []), l;
  }
  return o;
}
function wL(e) {
  if (e === null || typeof e != "object" || Array.isArray(e))
    return !0;
  if (typeof e.type != "string") return !1;
  const t = (
    /** @type {Record<string, unknown>} */
    e
  ), n = Object.keys(e);
  for (const r of n) {
    const o = t[r];
    if (o && typeof o == "object") {
      if (!Array.isArray(o)) return !0;
      const i = (
        /** @type {ReadonlyArray<unknown>} */
        o
      );
      for (const s of i)
        if (typeof s != "number" && typeof s != "string")
          return !0;
    }
  }
  return !!("children" in e && Array.isArray(e.children));
}
function vL(e, t, n, r) {
  const o = wp(e, n);
  let i;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      i = r;
    } else typeof r == "boolean" ? i = r : typeof r == "string" ? o.spaceSeparated ? i = pg(r) : o.commaSeparated ? i = fg(r) : o.commaOrSpaceSeparated ? i = pg(fg(r).join(" ")) : i = mg(o, o.property, r) : Array.isArray(r) ? i = [...r] : i = o.property === "style" ? SL(r) : String(r);
    if (Array.isArray(i)) {
      const s = [];
      for (const a of i)
        s.push(
          /** @type {number | string} */
          mg(o, o.property, a)
        );
      i = s;
    }
    o.property === "className" && Array.isArray(t.className) && (i = t.className.concat(
      /** @type {Array<number | string> | number | string} */
      i
    )), t[o.property] = i;
  }
}
function Rf(e, t) {
  if (t != null) if (typeof t == "number" || typeof t == "string")
    e.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (const n of t)
      Rf(e, n);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? Rf(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function mg(e, t, n) {
  if (typeof n == "string") {
    if (e.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e.boolean || e.overloadedBoolean) && (n === "" || Ks(n) === Ks(t)))
      return !0;
  }
  return n;
}
function SL(e) {
  const t = [];
  for (const [n, r] of Object.entries(e))
    t.push([n, r].join(": "));
  return t.join("; ");
}
function _L(e) {
  const t = /* @__PURE__ */ new Map();
  for (const n of e)
    t.set(n.toLowerCase(), n);
  return t;
}
const AL = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], I2 = A2(ru, "div"), N2 = A2(ha, "g", AL);
function IL(e) {
  const t = String(e), n = [];
  return { toOffset: o, toPoint: r };
  function r(i) {
    if (typeof i == "number" && i > -1 && i <= t.length) {
      let s = 0;
      for (; ; ) {
        let a = n[s];
        if (a === void 0) {
          const l = gg(t, n[s - 1]);
          a = l === -1 ? t.length + 1 : l + 1, n[s] = a;
        }
        if (a > i)
          return {
            line: s + 1,
            column: i - (s > 0 ? n[s - 1] : 0) + 1,
            offset: i
          };
        s++;
      }
    }
  }
  function o(i) {
    if (i && typeof i.line == "number" && typeof i.column == "number" && !Number.isNaN(i.line) && !Number.isNaN(i.column)) {
      for (; n.length < i.line; ) {
        const a = n[n.length - 1], l = gg(t, a), c = l === -1 ? t.length + 1 : l + 1;
        if (a === c) break;
        n.push(c);
      }
      const s = (i.line > 1 ? n[i.line - 2] : 0) + i.column - 1;
      if (s < n[i.line - 1]) return s;
    }
  }
}
function gg(e, t) {
  const n = e.indexOf("\r", t), r = e.indexOf(`
`, t);
  return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r;
}
const El = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, M2 = {}.hasOwnProperty, NL = Object.prototype;
function ML(e, t) {
  const n = t || {};
  return vp(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? ha : ru,
      verbose: n.verbose || !1
    },
    e
  );
}
function vp(e, t) {
  let n;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        t
      );
      return n = { type: "comment", value: r.data }, kl(e, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        t
      ), o = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: L2(e, t.childNodes),
        data: { quirksMode: o }
      }, e.file && e.location) {
        const i = String(e.file), s = IL(i), a = s.toPoint(0), l = s.toPoint(i.length);
        n.position = { start: a, end: l };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        t
      );
      return n = { type: "doctype" }, kl(e, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        t
      );
      return n = { type: "text", value: r.value }, kl(e, r, n), n;
    }
    default:
      return n = LL(
        e,
        /** @type {DefaultTreeAdapterMap['element']} */
        t
      ), n;
  }
}
function L2(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; ) {
    const o = (
      /** @type {RootContent} */
      vp(e, t[n])
    );
    r.push(o);
  }
  return r;
}
function LL(e, t) {
  const n = e.schema;
  e.schema = t.namespaceURI === El.svg ? ha : ru;
  let r = -1;
  const o = {};
  for (; ++r < t.attrs.length; ) {
    const a = t.attrs[r], l = (a.prefix ? a.prefix + ":" : "") + a.name;
    M2.call(NL, l) || (o[l] = a.value);
  }
  const s = (e.schema.space === "svg" ? N2 : I2)(t.tagName, o, L2(e, t.childNodes));
  if (kl(e, t, s), s.tagName === "template") {
    const a = (
      /** @type {DefaultTreeAdapterMap['template']} */
      t
    ), l = a.sourceCodeLocation, c = l && l.startTag && pi(l.startTag), u = l && l.endTag && pi(l.endTag), d = (
      /** @type {Root} */
      vp(e, a.content)
    );
    c && u && e.file && (d.position = { start: c.end, end: u.start }), s.content = d;
  }
  return e.schema = n, s;
}
function kl(e, t, n) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const r = OL(e, n, t.sourceCodeLocation);
    r && (e.location = !0, n.position = r);
  }
}
function OL(e, t, n) {
  const r = pi(n);
  if (t.type === "element") {
    const o = t.children[t.children.length - 1];
    if (r && !n.endTag && o && o.position && o.position.end && (r.end = Object.assign({}, o.position.end)), e.verbose) {
      const i = {};
      let s;
      if (n.attrs)
        for (s in n.attrs)
          M2.call(n.attrs, s) && (i[wp(e.schema, s).property] = pi(
            n.attrs[s]
          ));
      n.startTag;
      const a = pi(n.startTag), l = n.endTag ? pi(n.endTag) : void 0, c = { opening: a };
      l && (c.closing = l), c.properties = i, t.data = { position: c };
    }
  }
  return r;
}
function pi(e) {
  const t = bg({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), n = bg({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || n ? { start: t, end: n } : void 0;
}
function bg(e) {
  return e.line && e.column ? e : void 0;
}
const DL = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), at = "";
var x;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(x || (x = {}));
const Zt = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function O2(e) {
  return e >= 55296 && e <= 57343;
}
function RL(e) {
  return e >= 56320 && e <= 57343;
}
function PL(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function D2(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function R2(e) {
  return e >= 64976 && e <= 65007 || DL.has(e);
}
var P;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(P || (P = {}));
const BL = 65536;
class $L {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = BL, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t, n) {
    const { line: r, col: o, offset: i } = this, s = o + n, a = i + n;
    return {
      code: t,
      startLine: r,
      endLine: r,
      startCol: s,
      endCol: s,
      startOffset: a,
      endOffset: a
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (RL(n))
        return this.pos++, this._addGap(), PL(t, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, x.EOF;
    return this._err(P.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, n) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, n) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(t) {
    const n = this.pos + t;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, x.EOF;
    const r = this.html.charCodeAt(n);
    return r === x.CARRIAGE_RETURN ? x.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, x.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === x.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, x.LINE_FEED) : t === x.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, O2(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === x.LINE_FEED || t === x.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    D2(t) ? this._err(P.controlCharacterInInputStream) : R2(t) && this._err(P.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var Be;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(Be || (Be = {}));
function P2(e, t) {
  for (let n = e.attrs.length - 1; n >= 0; n--)
    if (e.attrs[n].name === t)
      return e.attrs[n].value;
  return null;
}
const HL = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((e) => e.charCodeAt(0))
), FL = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
function UL(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = FL.get(e)) !== null && t !== void 0 ? t : e;
}
var wt;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(wt || (wt = {}));
const jL = 32;
var to;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(to || (to = {}));
function Pf(e) {
  return e >= wt.ZERO && e <= wt.NINE;
}
function VL(e) {
  return e >= wt.UPPER_A && e <= wt.UPPER_F || e >= wt.LOWER_A && e <= wt.LOWER_F;
}
function zL(e) {
  return e >= wt.UPPER_A && e <= wt.UPPER_Z || e >= wt.LOWER_A && e <= wt.LOWER_Z || Pf(e);
}
function qL(e) {
  return e === wt.EQUALS || zL(e);
}
var Tt;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(Tt || (Tt = {}));
var Or;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(Or || (Or = {}));
class WL {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = Tt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Or.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = Tt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case Tt.EntityStart:
        return t.charCodeAt(n) === wt.NUM ? (this.state = Tt.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = Tt.NamedEntity, this.stateNamedEntity(t, n));
      case Tt.NumericStart:
        return this.stateNumericStart(t, n);
      case Tt.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case Tt.NumericHex:
        return this.stateNumericHex(t, n);
      case Tt.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | jL) === wt.LOWER_X ? (this.state = Tt.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = Tt.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, o) {
    if (n !== r) {
      const i = r - n;
      this.result = this.result * Math.pow(o, i) + Number.parseInt(t.substr(n, i), o), this.consumed += i;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const o = t.charCodeAt(n);
      if (Pf(o) || VL(o))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(o, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const o = t.charCodeAt(n);
      if (Pf(o))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(o, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === wt.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Or.Strict)
      return 0;
    return this.emitCodePoint(UL(this.result), this.consumed), this.errors && (t !== wt.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let o = r[this.treeIndex], i = (o & to.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const s = t.charCodeAt(n);
      if (this.treeIndex = GL(r, o, this.treeIndex + Math.max(1, i), s), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Or.Attribute && // We shouldn't have consumed any characters after the entity,
        (i === 0 || // And there should be no invalid characters.
        qL(s)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (o = r[this.treeIndex], i = (o & to.VALUE_LENGTH) >> 14, i !== 0) {
        if (s === wt.SEMI)
          return this.emitNamedEntityData(this.treeIndex, i, this.consumed + this.excess);
        this.decodeMode !== Or.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, o = (r[n] & to.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, o, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: o } = this;
    return this.emitCodePoint(n === 1 ? o[t] & ~to.VALUE_LENGTH : o[t + 1], r), n === 3 && this.emitCodePoint(o[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case Tt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Or.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case Tt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Tt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Tt.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Tt.EntityStart:
        return 0;
    }
  }
}
function GL(e, t, n, r) {
  const o = (t & to.BRANCH_LENGTH) >> 7, i = t & to.JUMP_TABLE;
  if (o === 0)
    return i !== 0 && r === i ? n : -1;
  if (i) {
    const l = r - i;
    return l < 0 || l >= o ? -1 : e[n + l] - 1;
  }
  let s = n, a = s + o - 1;
  for (; s <= a; ) {
    const l = s + a >>> 1, c = e[l];
    if (c < r)
      s = l + 1;
    else if (c > r)
      a = l - 1;
    else
      return e[l + o];
  }
  return -1;
}
var j;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(j || (j = {}));
var Ro;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(Ro || (Ro = {}));
var _n;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(_n || (_n = {}));
var O;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SEARCH = "search", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(O || (O = {}));
var g;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SEARCH = 94] = "SEARCH", e[e.SECTION = 95] = "SECTION", e[e.SELECT = 96] = "SELECT", e[e.SOURCE = 97] = "SOURCE", e[e.SMALL = 98] = "SMALL", e[e.SPAN = 99] = "SPAN", e[e.STRIKE = 100] = "STRIKE", e[e.STRONG = 101] = "STRONG", e[e.STYLE = 102] = "STYLE", e[e.SUB = 103] = "SUB", e[e.SUMMARY = 104] = "SUMMARY", e[e.SUP = 105] = "SUP", e[e.TABLE = 106] = "TABLE", e[e.TBODY = 107] = "TBODY", e[e.TEMPLATE = 108] = "TEMPLATE", e[e.TEXTAREA = 109] = "TEXTAREA", e[e.TFOOT = 110] = "TFOOT", e[e.TD = 111] = "TD", e[e.TH = 112] = "TH", e[e.THEAD = 113] = "THEAD", e[e.TITLE = 114] = "TITLE", e[e.TR = 115] = "TR", e[e.TRACK = 116] = "TRACK", e[e.TT = 117] = "TT", e[e.U = 118] = "U", e[e.UL = 119] = "UL", e[e.SVG = 120] = "SVG", e[e.VAR = 121] = "VAR", e[e.WBR = 122] = "WBR", e[e.XMP = 123] = "XMP";
})(g || (g = {}));
const YL = /* @__PURE__ */ new Map([
  [O.A, g.A],
  [O.ADDRESS, g.ADDRESS],
  [O.ANNOTATION_XML, g.ANNOTATION_XML],
  [O.APPLET, g.APPLET],
  [O.AREA, g.AREA],
  [O.ARTICLE, g.ARTICLE],
  [O.ASIDE, g.ASIDE],
  [O.B, g.B],
  [O.BASE, g.BASE],
  [O.BASEFONT, g.BASEFONT],
  [O.BGSOUND, g.BGSOUND],
  [O.BIG, g.BIG],
  [O.BLOCKQUOTE, g.BLOCKQUOTE],
  [O.BODY, g.BODY],
  [O.BR, g.BR],
  [O.BUTTON, g.BUTTON],
  [O.CAPTION, g.CAPTION],
  [O.CENTER, g.CENTER],
  [O.CODE, g.CODE],
  [O.COL, g.COL],
  [O.COLGROUP, g.COLGROUP],
  [O.DD, g.DD],
  [O.DESC, g.DESC],
  [O.DETAILS, g.DETAILS],
  [O.DIALOG, g.DIALOG],
  [O.DIR, g.DIR],
  [O.DIV, g.DIV],
  [O.DL, g.DL],
  [O.DT, g.DT],
  [O.EM, g.EM],
  [O.EMBED, g.EMBED],
  [O.FIELDSET, g.FIELDSET],
  [O.FIGCAPTION, g.FIGCAPTION],
  [O.FIGURE, g.FIGURE],
  [O.FONT, g.FONT],
  [O.FOOTER, g.FOOTER],
  [O.FOREIGN_OBJECT, g.FOREIGN_OBJECT],
  [O.FORM, g.FORM],
  [O.FRAME, g.FRAME],
  [O.FRAMESET, g.FRAMESET],
  [O.H1, g.H1],
  [O.H2, g.H2],
  [O.H3, g.H3],
  [O.H4, g.H4],
  [O.H5, g.H5],
  [O.H6, g.H6],
  [O.HEAD, g.HEAD],
  [O.HEADER, g.HEADER],
  [O.HGROUP, g.HGROUP],
  [O.HR, g.HR],
  [O.HTML, g.HTML],
  [O.I, g.I],
  [O.IMG, g.IMG],
  [O.IMAGE, g.IMAGE],
  [O.INPUT, g.INPUT],
  [O.IFRAME, g.IFRAME],
  [O.KEYGEN, g.KEYGEN],
  [O.LABEL, g.LABEL],
  [O.LI, g.LI],
  [O.LINK, g.LINK],
  [O.LISTING, g.LISTING],
  [O.MAIN, g.MAIN],
  [O.MALIGNMARK, g.MALIGNMARK],
  [O.MARQUEE, g.MARQUEE],
  [O.MATH, g.MATH],
  [O.MENU, g.MENU],
  [O.META, g.META],
  [O.MGLYPH, g.MGLYPH],
  [O.MI, g.MI],
  [O.MO, g.MO],
  [O.MN, g.MN],
  [O.MS, g.MS],
  [O.MTEXT, g.MTEXT],
  [O.NAV, g.NAV],
  [O.NOBR, g.NOBR],
  [O.NOFRAMES, g.NOFRAMES],
  [O.NOEMBED, g.NOEMBED],
  [O.NOSCRIPT, g.NOSCRIPT],
  [O.OBJECT, g.OBJECT],
  [O.OL, g.OL],
  [O.OPTGROUP, g.OPTGROUP],
  [O.OPTION, g.OPTION],
  [O.P, g.P],
  [O.PARAM, g.PARAM],
  [O.PLAINTEXT, g.PLAINTEXT],
  [O.PRE, g.PRE],
  [O.RB, g.RB],
  [O.RP, g.RP],
  [O.RT, g.RT],
  [O.RTC, g.RTC],
  [O.RUBY, g.RUBY],
  [O.S, g.S],
  [O.SCRIPT, g.SCRIPT],
  [O.SEARCH, g.SEARCH],
  [O.SECTION, g.SECTION],
  [O.SELECT, g.SELECT],
  [O.SOURCE, g.SOURCE],
  [O.SMALL, g.SMALL],
  [O.SPAN, g.SPAN],
  [O.STRIKE, g.STRIKE],
  [O.STRONG, g.STRONG],
  [O.STYLE, g.STYLE],
  [O.SUB, g.SUB],
  [O.SUMMARY, g.SUMMARY],
  [O.SUP, g.SUP],
  [O.TABLE, g.TABLE],
  [O.TBODY, g.TBODY],
  [O.TEMPLATE, g.TEMPLATE],
  [O.TEXTAREA, g.TEXTAREA],
  [O.TFOOT, g.TFOOT],
  [O.TD, g.TD],
  [O.TH, g.TH],
  [O.THEAD, g.THEAD],
  [O.TITLE, g.TITLE],
  [O.TR, g.TR],
  [O.TRACK, g.TRACK],
  [O.TT, g.TT],
  [O.U, g.U],
  [O.UL, g.UL],
  [O.SVG, g.SVG],
  [O.VAR, g.VAR],
  [O.WBR, g.WBR],
  [O.XMP, g.XMP]
]);
function ou(e) {
  var t;
  return (t = YL.get(e)) !== null && t !== void 0 ? t : g.UNKNOWN;
}
const q = g, KL = {
  [j.HTML]: /* @__PURE__ */ new Set([
    q.ADDRESS,
    q.APPLET,
    q.AREA,
    q.ARTICLE,
    q.ASIDE,
    q.BASE,
    q.BASEFONT,
    q.BGSOUND,
    q.BLOCKQUOTE,
    q.BODY,
    q.BR,
    q.BUTTON,
    q.CAPTION,
    q.CENTER,
    q.COL,
    q.COLGROUP,
    q.DD,
    q.DETAILS,
    q.DIR,
    q.DIV,
    q.DL,
    q.DT,
    q.EMBED,
    q.FIELDSET,
    q.FIGCAPTION,
    q.FIGURE,
    q.FOOTER,
    q.FORM,
    q.FRAME,
    q.FRAMESET,
    q.H1,
    q.H2,
    q.H3,
    q.H4,
    q.H5,
    q.H6,
    q.HEAD,
    q.HEADER,
    q.HGROUP,
    q.HR,
    q.HTML,
    q.IFRAME,
    q.IMG,
    q.INPUT,
    q.LI,
    q.LINK,
    q.LISTING,
    q.MAIN,
    q.MARQUEE,
    q.MENU,
    q.META,
    q.NAV,
    q.NOEMBED,
    q.NOFRAMES,
    q.NOSCRIPT,
    q.OBJECT,
    q.OL,
    q.P,
    q.PARAM,
    q.PLAINTEXT,
    q.PRE,
    q.SCRIPT,
    q.SECTION,
    q.SELECT,
    q.SOURCE,
    q.STYLE,
    q.SUMMARY,
    q.TABLE,
    q.TBODY,
    q.TD,
    q.TEMPLATE,
    q.TEXTAREA,
    q.TFOOT,
    q.TH,
    q.THEAD,
    q.TITLE,
    q.TR,
    q.TRACK,
    q.UL,
    q.WBR,
    q.XMP
  ]),
  [j.MATHML]: /* @__PURE__ */ new Set([q.MI, q.MO, q.MN, q.MS, q.MTEXT, q.ANNOTATION_XML]),
  [j.SVG]: /* @__PURE__ */ new Set([q.TITLE, q.FOREIGN_OBJECT, q.DESC]),
  [j.XLINK]: /* @__PURE__ */ new Set(),
  [j.XML]: /* @__PURE__ */ new Set(),
  [j.XMLNS]: /* @__PURE__ */ new Set()
}, Bf = /* @__PURE__ */ new Set([q.H1, q.H2, q.H3, q.H4, q.H5, q.H6]);
O.STYLE, O.SCRIPT, O.XMP, O.IFRAME, O.NOEMBED, O.NOFRAMES, O.PLAINTEXT;
var v;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(v || (v = {}));
const rn = {
  DATA: v.DATA,
  RCDATA: v.RCDATA,
  RAWTEXT: v.RAWTEXT,
  SCRIPT_DATA: v.SCRIPT_DATA,
  PLAINTEXT: v.PLAINTEXT,
  CDATA_SECTION: v.CDATA_SECTION
};
function QL(e) {
  return e >= x.DIGIT_0 && e <= x.DIGIT_9;
}
function ps(e) {
  return e >= x.LATIN_CAPITAL_A && e <= x.LATIN_CAPITAL_Z;
}
function ZL(e) {
  return e >= x.LATIN_SMALL_A && e <= x.LATIN_SMALL_Z;
}
function Kr(e) {
  return ZL(e) || ps(e);
}
function yg(e) {
  return Kr(e) || QL(e);
}
function za(e) {
  return e + 32;
}
function B2(e) {
  return e === x.SPACE || e === x.LINE_FEED || e === x.TABULATION || e === x.FORM_FEED;
}
function Eg(e) {
  return B2(e) || e === x.SOLIDUS || e === x.GREATER_THAN_SIGN;
}
function XL(e) {
  return e === x.NULL ? P.nullCharacterReference : e > 1114111 ? P.characterReferenceOutsideUnicodeRange : O2(e) ? P.surrogateCharacterReference : R2(e) ? P.noncharacterCharacterReference : D2(e) || e === x.CARRIAGE_RETURN ? P.controlCharacterReference : null;
}
class JL {
  constructor(t, n) {
    this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = v.DATA, this.returnState = v.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new $L(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new WL(HL, (r, o) => {
      this.preprocessor.pos = this.entityStartPos + o - 1, this._flushCodePointConsumedAsCharacterReference(r);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(P.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r) => {
        this._err(P.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r);
      },
      validateNumericCharacterReference: (r) => {
        const o = XL(r);
        o && this._err(o, 1);
      }
    } : void 0);
  }
  //Errors
  _err(t, n = 0) {
    var r, o;
    (o = (r = this.handler).onParseError) === null || o === void 0 || o.call(r, this.preprocessor.getError(t, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, n, r) {
    this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let n = 0; n < t; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, n) {
    return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: Be.START_TAG,
      tagName: "",
      tagID: g.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: Be.END_TAG,
      tagName: "",
      tagID: g.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: Be.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: Be.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, n) {
    this.currentCharacterToken = {
      type: t,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, n;
    const r = this.currentToken;
    if (P2(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const o = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = /* @__PURE__ */ Object.create(null);
        o[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(P.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = ou(t.tagName), t.type === Be.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(P.endTagWithAttributes), t.selfClosing && this._err(P.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case Be.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case Be.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case Be.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: Be.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === t) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(t, n);
  }
  _emitCodePoint(t) {
    const n = B2(t) ? Be.WHITESPACE_CHARACTER : t === x.NULL ? Be.NULL_CHARACTER : Be.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(Be.CHARACTER, t);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = v.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? Or.Attribute : Or.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === v.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === v.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === v.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case v.DATA: {
        this._stateData(t);
        break;
      }
      case v.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case v.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case v.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case v.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case v.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case v.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case v.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case v.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case v.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case v.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case v.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case v.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case v.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case v.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case v.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case v.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case v.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case v.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case v.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case v.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case v.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case v.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case v.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case v.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case v.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case v.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case v.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case v.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case v.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case v.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case v.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case v.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case v.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case v.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case v.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case v.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case v.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case v.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case v.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case v.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case v.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case v.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case v.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case v.COMMENT: {
        this._stateComment(t);
        break;
      }
      case v.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case v.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case v.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case v.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case v.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case v.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case v.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case v.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case v.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case v.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case v.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case v.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case v.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case v.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case v.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case v.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case v.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case v.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case v.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case v.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case v.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case v.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case v.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case v.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case v.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case v.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case v.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case v.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case x.LESS_THAN_SIGN: {
        this.state = v.TAG_OPEN;
        break;
      }
      case x.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case x.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case x.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case x.LESS_THAN_SIGN: {
        this.state = v.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case x.LESS_THAN_SIGN: {
        this.state = v.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case x.LESS_THAN_SIGN: {
        this.state = v.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (Kr(t))
      this._createStartTagToken(), this.state = v.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case x.EXCLAMATION_MARK: {
          this.state = v.MARKUP_DECLARATION_OPEN;
          break;
        }
        case x.SOLIDUS: {
          this.state = v.END_TAG_OPEN;
          break;
        }
        case x.QUESTION_MARK: {
          this._err(P.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = v.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case x.EOF: {
          this._err(P.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(P.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = v.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (Kr(t))
      this._createEndTagToken(), this.state = v.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case x.GREATER_THAN_SIGN: {
          this._err(P.missingEndTagName), this.state = v.DATA;
          break;
        }
        case x.EOF: {
          this._err(P.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(P.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = v.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED: {
        this.state = v.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case x.SOLIDUS: {
        this.state = v.SELF_CLOSING_START_TAG;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this.state = v.DATA, this.emitCurrentTagToken();
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), n.tagName += at;
        break;
      }
      case x.EOF: {
        this._err(P.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(ps(t) ? za(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === x.SOLIDUS ? this.state = v.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = v.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    Kr(t) ? (this.state = v.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = v.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = v.BEFORE_ATTRIBUTE_NAME, !1;
      case x.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = v.SELF_CLOSING_START_TAG, !1;
      case x.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = v.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = v.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === x.SOLIDUS ? this.state = v.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = v.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    Kr(t) ? (this.state = v.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = v.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = v.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case x.SOLIDUS: {
        this.state = v.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case x.EXCLAMATION_MARK: {
        this.state = v.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = v.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    Kr(t) ? (this.state = v.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = v.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = v.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === x.HYPHEN_MINUS ? (this.state = v.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = v.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === x.HYPHEN_MINUS ? (this.state = v.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = v.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case x.HYPHEN_MINUS: {
        this.state = v.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case x.LESS_THAN_SIGN: {
        this.state = v.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._err(P.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case x.HYPHEN_MINUS: {
        this.state = v.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case x.LESS_THAN_SIGN: {
        this.state = v.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this.state = v.SCRIPT_DATA_ESCAPED, this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._err(P.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = v.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case x.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case x.LESS_THAN_SIGN: {
        this.state = v.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this.state = v.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this.state = v.SCRIPT_DATA_ESCAPED, this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._err(P.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = v.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === x.SOLIDUS ? this.state = v.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Kr(t) ? (this._emitChars("<"), this.state = v.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = v.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    Kr(t) ? (this.state = v.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = v.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = v.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(Zt.SCRIPT, !1) && Eg(this.preprocessor.peek(Zt.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < Zt.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = v.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case x.HYPHEN_MINUS: {
        this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case x.LESS_THAN_SIGN: {
        this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._err(P.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case x.HYPHEN_MINUS: {
        this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case x.LESS_THAN_SIGN: {
        this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._err(P.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case x.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case x.LESS_THAN_SIGN: {
        this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this.state = v.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(at);
        break;
      }
      case x.EOF: {
        this._err(P.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === x.SOLIDUS ? (this.state = v.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(Zt.SCRIPT, !1) && Eg(this.preprocessor.peek(Zt.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < Zt.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = v.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = v.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
        break;
      case x.SOLIDUS:
      case x.GREATER_THAN_SIGN:
      case x.EOF: {
        this.state = v.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case x.EQUALS_SIGN: {
        this._err(P.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = v.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = v.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
      case x.SOLIDUS:
      case x.GREATER_THAN_SIGN:
      case x.EOF: {
        this._leaveAttrName(), this.state = v.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case x.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = v.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case x.QUOTATION_MARK:
      case x.APOSTROPHE:
      case x.LESS_THAN_SIGN: {
        this._err(P.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this.currentAttr.name += at;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(ps(t) ? za(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
        break;
      case x.SOLIDUS: {
        this.state = v.SELF_CLOSING_START_TAG;
        break;
      }
      case x.EQUALS_SIGN: {
        this.state = v.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this.state = v.DATA, this.emitCurrentTagToken();
        break;
      }
      case x.EOF: {
        this._err(P.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = v.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
        break;
      case x.QUOTATION_MARK: {
        this.state = v.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case x.APOSTROPHE: {
        this.state = v.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.missingAttributeValue), this.state = v.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = v.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case x.QUOTATION_MARK: {
        this.state = v.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case x.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this.currentAttr.value += at;
        break;
      }
      case x.EOF: {
        this._err(P.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case x.APOSTROPHE: {
        this.state = v.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case x.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this.currentAttr.value += at;
        break;
      }
      case x.EOF: {
        this._err(P.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED: {
        this._leaveAttrValue(), this.state = v.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case x.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = v.DATA, this.emitCurrentTagToken();
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), this.currentAttr.value += at;
        break;
      }
      case x.QUOTATION_MARK:
      case x.APOSTROPHE:
      case x.LESS_THAN_SIGN:
      case x.EQUALS_SIGN:
      case x.GRAVE_ACCENT: {
        this._err(P.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case x.EOF: {
        this._err(P.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED: {
        this._leaveAttrValue(), this.state = v.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case x.SOLIDUS: {
        this._leaveAttrValue(), this.state = v.SELF_CLOSING_START_TAG;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = v.DATA, this.emitCurrentTagToken();
        break;
      }
      case x.EOF: {
        this._err(P.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.missingWhitespaceBetweenAttributes), this.state = v.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case x.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = v.DATA, this.emitCurrentTagToken();
        break;
      }
      case x.EOF: {
        this._err(P.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.unexpectedSolidusInTag), this.state = v.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const n = this.currentToken;
    switch (t) {
      case x.GREATER_THAN_SIGN: {
        this.state = v.DATA, this.emitCurrentComment(n);
        break;
      }
      case x.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), n.data += at;
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(Zt.DASH_DASH, !0) ? (this._createCommentToken(Zt.DASH_DASH.length + 1), this.state = v.COMMENT_START) : this._consumeSequenceIfMatch(Zt.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(Zt.DOCTYPE.length + 1), this.state = v.DOCTYPE) : this._consumeSequenceIfMatch(Zt.CDATA_START, !0) ? this.inForeignNode ? this.state = v.CDATA_SECTION : (this._err(P.cdataInHtmlContent), this._createCommentToken(Zt.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = v.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(P.incorrectlyOpenedComment), this._createCommentToken(2), this.state = v.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case x.HYPHEN_MINUS: {
        this.state = v.COMMENT_START_DASH;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.abruptClosingOfEmptyComment), this.state = v.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = v.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const n = this.currentToken;
    switch (t) {
      case x.HYPHEN_MINUS: {
        this.state = v.COMMENT_END;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.abruptClosingOfEmptyComment), this.state = v.DATA, this.emitCurrentComment(n);
        break;
      }
      case x.EOF: {
        this._err(P.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = v.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const n = this.currentToken;
    switch (t) {
      case x.HYPHEN_MINUS: {
        this.state = v.COMMENT_END_DASH;
        break;
      }
      case x.LESS_THAN_SIGN: {
        n.data += "<", this.state = v.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), n.data += at;
        break;
      }
      case x.EOF: {
        this._err(P.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const n = this.currentToken;
    switch (t) {
      case x.EXCLAMATION_MARK: {
        n.data += "!", this.state = v.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case x.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = v.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === x.HYPHEN_MINUS ? this.state = v.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = v.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === x.HYPHEN_MINUS ? this.state = v.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = v.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== x.GREATER_THAN_SIGN && t !== x.EOF && this._err(P.nestedComment), this.state = v.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const n = this.currentToken;
    switch (t) {
      case x.HYPHEN_MINUS: {
        this.state = v.COMMENT_END;
        break;
      }
      case x.EOF: {
        this._err(P.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = v.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const n = this.currentToken;
    switch (t) {
      case x.GREATER_THAN_SIGN: {
        this.state = v.DATA, this.emitCurrentComment(n);
        break;
      }
      case x.EXCLAMATION_MARK: {
        this.state = v.COMMENT_END_BANG;
        break;
      }
      case x.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case x.EOF: {
        this._err(P.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = v.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const n = this.currentToken;
    switch (t) {
      case x.HYPHEN_MINUS: {
        n.data += "--!", this.state = v.COMMENT_END_DASH;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.incorrectlyClosedComment), this.state = v.DATA, this.emitCurrentComment(n);
        break;
      }
      case x.EOF: {
        this._err(P.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = v.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED: {
        this.state = v.BEFORE_DOCTYPE_NAME;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this.state = v.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.missingWhitespaceBeforeDoctypeName), this.state = v.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (ps(t))
      this._createDoctypeToken(String.fromCharCode(za(t))), this.state = v.DOCTYPE_NAME;
    else
      switch (t) {
        case x.SPACE:
        case x.LINE_FEED:
        case x.TABULATION:
        case x.FORM_FEED:
          break;
        case x.NULL: {
          this._err(P.unexpectedNullCharacter), this._createDoctypeToken(at), this.state = v.DOCTYPE_NAME;
          break;
        }
        case x.GREATER_THAN_SIGN: {
          this._err(P.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = v.DATA;
          break;
        }
        case x.EOF: {
          this._err(P.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = v.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED: {
        this.state = v.AFTER_DOCTYPE_NAME;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this.state = v.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), n.name += at;
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(ps(t) ? za(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
        break;
      case x.GREATER_THAN_SIGN: {
        this.state = v.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(Zt.PUBLIC, !1) ? this.state = v.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(Zt.SYSTEM, !1) ? this.state = v.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(P.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = v.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED: {
        this.state = v.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case x.QUOTATION_MARK: {
        this._err(P.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = v.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case x.APOSTROPHE: {
        this._err(P.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = v.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = v.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = v.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
        break;
      case x.QUOTATION_MARK: {
        n.publicId = "", this.state = v.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case x.APOSTROPHE: {
        n.publicId = "", this.state = v.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = v.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = v.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case x.QUOTATION_MARK: {
        this.state = v.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), n.publicId += at;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = v.DATA;
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case x.APOSTROPHE: {
        this.state = v.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), n.publicId += at;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = v.DATA;
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED: {
        this.state = v.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this.state = v.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case x.QUOTATION_MARK: {
        this._err(P.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = v.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case x.APOSTROPHE: {
        this._err(P.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = v.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = v.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
        break;
      case x.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = v.DATA;
        break;
      }
      case x.QUOTATION_MARK: {
        n.systemId = "", this.state = v.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case x.APOSTROPHE: {
        n.systemId = "", this.state = v.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = v.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED: {
        this.state = v.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case x.QUOTATION_MARK: {
        this._err(P.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = v.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case x.APOSTROPHE: {
        this._err(P.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = v.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = v.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = v.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
        break;
      case x.QUOTATION_MARK: {
        n.systemId = "", this.state = v.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case x.APOSTROPHE: {
        n.systemId = "", this.state = v.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = v.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = v.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case x.QUOTATION_MARK: {
        this.state = v.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), n.systemId += at;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = v.DATA;
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case x.APOSTROPHE: {
        this.state = v.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter), n.systemId += at;
        break;
      }
      case x.GREATER_THAN_SIGN: {
        this._err(P.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = v.DATA;
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case x.SPACE:
      case x.LINE_FEED:
      case x.TABULATION:
      case x.FORM_FEED:
        break;
      case x.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = v.DATA;
        break;
      }
      case x.EOF: {
        this._err(P.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(P.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = v.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const n = this.currentToken;
    switch (t) {
      case x.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = v.DATA;
        break;
      }
      case x.NULL: {
        this._err(P.unexpectedNullCharacter);
        break;
      }
      case x.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case x.RIGHT_SQUARE_BRACKET: {
        this.state = v.CDATA_SECTION_BRACKET;
        break;
      }
      case x.EOF: {
        this._err(P.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === x.RIGHT_SQUARE_BRACKET ? this.state = v.CDATA_SECTION_END : (this._emitChars("]"), this.state = v.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case x.GREATER_THAN_SIGN: {
        this.state = v.DATA;
        break;
      }
      case x.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = v.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (t < 0)
      if (this.preprocessor.lastChunkWritten)
        t = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    t === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(x.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && yg(this.preprocessor.peek(1)) ? v.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    yg(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === x.SEMICOLON && this._err(P.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t));
  }
}
const $2 = /* @__PURE__ */ new Set([g.DD, g.DT, g.LI, g.OPTGROUP, g.OPTION, g.P, g.RB, g.RP, g.RT, g.RTC]), kg = /* @__PURE__ */ new Set([
  ...$2,
  g.CAPTION,
  g.COLGROUP,
  g.TBODY,
  g.TD,
  g.TFOOT,
  g.TH,
  g.THEAD,
  g.TR
]), ec = /* @__PURE__ */ new Set([
  g.APPLET,
  g.CAPTION,
  g.HTML,
  g.MARQUEE,
  g.OBJECT,
  g.TABLE,
  g.TD,
  g.TEMPLATE,
  g.TH
]), eO = /* @__PURE__ */ new Set([...ec, g.OL, g.UL]), tO = /* @__PURE__ */ new Set([...ec, g.BUTTON]), Cg = /* @__PURE__ */ new Set([g.ANNOTATION_XML, g.MI, g.MN, g.MO, g.MS, g.MTEXT]), Tg = /* @__PURE__ */ new Set([g.DESC, g.FOREIGN_OBJECT, g.TITLE]), nO = /* @__PURE__ */ new Set([g.TR, g.TEMPLATE, g.HTML]), rO = /* @__PURE__ */ new Set([g.TBODY, g.TFOOT, g.THEAD, g.TEMPLATE, g.HTML]), oO = /* @__PURE__ */ new Set([g.TABLE, g.TEMPLATE, g.HTML]), iO = /* @__PURE__ */ new Set([g.TD, g.TH]);
class sO {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = g.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === g.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === j.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, n) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, n) {
    const r = this._indexOf(t);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(t, n, r) {
    const o = this._indexOf(t) + 1;
    this.items.splice(o, 0, n), this.tagIDs.splice(o, 0, r), this.stackTop++, o === this.stackTop && this._updateCurrentElement(), this.current && this.currentTagId !== void 0 && this.handler.onItemPush(this.current, this.currentTagId, o === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(t, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== j.HTML);
    this.shortenToLength(Math.max(n, 0));
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const n = this._indexOf(t);
    this.shortenToLength(Math.max(n, 0));
  }
  popUntilPopped(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(Math.max(r, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(Bf, j.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(iO, j.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(oO, j.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(rO, j.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(nO, j.HTML);
  }
  remove(t) {
    const n = this._indexOf(t);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === g.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const n = this._indexOf(t) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === g.HTML;
  }
  //Element in scope
  hasInDynamicScope(t, n) {
    for (let r = this.stackTop; r >= 0; r--) {
      const o = this.tagIDs[r];
      switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
        case j.HTML: {
          if (o === t)
            return !0;
          if (n.has(o))
            return !1;
          break;
        }
        case j.SVG: {
          if (Tg.has(o))
            return !1;
          break;
        }
        case j.MATHML: {
          if (Cg.has(o))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(t) {
    return this.hasInDynamicScope(t, ec);
  }
  hasInListItemScope(t) {
    return this.hasInDynamicScope(t, eO);
  }
  hasInButtonScope(t) {
    return this.hasInDynamicScope(t, tO);
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t];
      switch (this.treeAdapter.getNamespaceURI(this.items[t])) {
        case j.HTML: {
          if (Bf.has(n))
            return !0;
          if (ec.has(n))
            return !1;
          break;
        }
        case j.SVG: {
          if (Tg.has(n))
            return !1;
          break;
        }
        case j.MATHML: {
          if (Cg.has(n))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === j.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case g.TABLE:
          case g.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--)
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === j.HTML)
        switch (this.tagIDs[t]) {
          case g.TBODY:
          case g.THEAD:
          case g.TFOOT:
            return !0;
          case g.TABLE:
          case g.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === j.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case g.OPTION:
          case g.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; this.currentTagId !== void 0 && $2.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; this.currentTagId !== void 0 && kg.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== void 0 && this.currentTagId !== t && kg.has(this.currentTagId); )
      this.pop();
  }
}
const cd = 3;
var dr;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(dr || (dr = {}));
const xg = { type: dr.Marker };
class aO {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, n) {
    const r = [], o = n.length, i = this.treeAdapter.getTagName(t), s = this.treeAdapter.getNamespaceURI(t);
    for (let a = 0; a < this.entries.length; a++) {
      const l = this.entries[a];
      if (l.type === dr.Marker)
        break;
      const { element: c } = l;
      if (this.treeAdapter.getTagName(c) === i && this.treeAdapter.getNamespaceURI(c) === s) {
        const u = this.treeAdapter.getAttrList(c);
        u.length === o && r.push({ idx: a, attrs: u });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < cd)
      return;
    const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n);
    if (r.length < cd)
      return;
    const o = new Map(n.map((s) => [s.name, s.value]));
    let i = 0;
    for (let s = 0; s < r.length; s++) {
      const a = r[s];
      a.attrs.every((l) => o.get(l.name) === l.value) && (i += 1, i >= cd && this.entries.splice(a.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(xg);
  }
  pushElement(t, n) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: dr.Element,
      element: t,
      token: n
    });
  }
  insertElementAfterBookmark(t, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: dr.Element,
      element: t,
      token: n
    });
  }
  removeEntry(t) {
    const n = this.entries.indexOf(t);
    n !== -1 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(xg);
    t === -1 ? this.entries.length = 0 : this.entries.splice(0, t + 1);
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const n = this.entries.find((r) => r.type === dr.Marker || this.treeAdapter.getTagName(r.element) === t);
    return n && n.type === dr.Element ? n : null;
  }
  getElementEntry(t) {
    return this.entries.find((n) => n.type === dr.Element && n.element === t);
  }
}
const Qr = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: _n.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, n) {
    return {
      nodeName: e,
      tagName: e,
      attrs: n,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  createTextNode(e) {
    return {
      nodeName: "#text",
      value: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, n) {
    const r = e.childNodes.indexOf(n);
    e.childNodes.splice(r, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, n, r) {
    const o = e.childNodes.find((i) => i.nodeName === "#documentType");
    if (o)
      o.name = t, o.publicId = n, o.systemId = r;
    else {
      const i = {
        nodeName: "#documentType",
        name: t,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      Qr.appendChild(e, i);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const n = e.childNodes[e.childNodes.length - 1];
      if (Qr.isTextNode(n)) {
        n.value += t;
        return;
      }
    }
    Qr.appendChild(e, Qr.createTextNode(t));
  },
  insertTextBefore(e, t, n) {
    const r = e.childNodes[e.childNodes.indexOf(n) - 1];
    r && Qr.isTextNode(r) ? r.value += t : Qr.insertBefore(e, Qr.createTextNode(t), n);
  },
  adoptAttributes(e, t) {
    const n = new Set(e.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      n.has(t[r].name) || e.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, H2 = "html", lO = "about:legacy-compat", cO = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", F2 = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], uO = [
  ...F2,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], dO = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), U2 = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], fO = [
  ...U2,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function wg(e, t) {
  return t.some((n) => e.startsWith(n));
}
function hO(e) {
  return e.name === H2 && e.publicId === null && (e.systemId === null || e.systemId === lO);
}
function pO(e) {
  if (e.name !== H2)
    return _n.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === cO)
    return _n.QUIRKS;
  let { publicId: n } = e;
  if (n !== null) {
    if (n = n.toLowerCase(), dO.has(n))
      return _n.QUIRKS;
    let r = t === null ? uO : F2;
    if (wg(n, r))
      return _n.QUIRKS;
    if (r = t === null ? U2 : fO, wg(n, r))
      return _n.LIMITED_QUIRKS;
  }
  return _n.NO_QUIRKS;
}
const vg = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, mO = "definitionurl", gO = "definitionURL", bO = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), yO = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: j.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: j.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: j.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: j.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: j.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: j.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: j.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: j.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: j.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: j.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: j.XMLNS }]
]), EO = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), kO = /* @__PURE__ */ new Set([
  g.B,
  g.BIG,
  g.BLOCKQUOTE,
  g.BODY,
  g.BR,
  g.CENTER,
  g.CODE,
  g.DD,
  g.DIV,
  g.DL,
  g.DT,
  g.EM,
  g.EMBED,
  g.H1,
  g.H2,
  g.H3,
  g.H4,
  g.H5,
  g.H6,
  g.HEAD,
  g.HR,
  g.I,
  g.IMG,
  g.LI,
  g.LISTING,
  g.MENU,
  g.META,
  g.NOBR,
  g.OL,
  g.P,
  g.PRE,
  g.RUBY,
  g.S,
  g.SMALL,
  g.SPAN,
  g.STRONG,
  g.STRIKE,
  g.SUB,
  g.SUP,
  g.TABLE,
  g.TT,
  g.U,
  g.UL,
  g.VAR
]);
function CO(e) {
  const t = e.tagID;
  return t === g.FONT && e.attrs.some(({ name: r }) => r === Ro.COLOR || r === Ro.SIZE || r === Ro.FACE) || kO.has(t);
}
function j2(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === mO) {
      e.attrs[t].name = gO;
      break;
    }
}
function V2(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = bO.get(e.attrs[t].name);
    n != null && (e.attrs[t].name = n);
  }
}
function Sp(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = yO.get(e.attrs[t].name);
    n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace);
  }
}
function TO(e) {
  const t = EO.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = ou(e.tagName));
}
function xO(e, t) {
  return t === j.MATHML && (e === g.MI || e === g.MO || e === g.MN || e === g.MS || e === g.MTEXT);
}
function wO(e, t, n) {
  if (t === j.MATHML && e === g.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === Ro.ENCODING) {
        const o = n[r].value.toLowerCase();
        return o === vg.TEXT_HTML || o === vg.APPLICATION_XML;
      }
  }
  return t === j.SVG && (e === g.FOREIGN_OBJECT || e === g.DESC || e === g.TITLE);
}
function vO(e, t, n, r) {
  return (!r || r === j.HTML) && wO(e, t, n) || (!r || r === j.MATHML) && xO(e, t);
}
const SO = "hidden", _O = 8, AO = 3;
var I;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(I || (I = {}));
const IO = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, z2 = /* @__PURE__ */ new Set([g.TABLE, g.TBODY, g.TFOOT, g.THEAD, g.TR]), Sg = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: Qr,
  onParseError: null
};
class q2 {
  constructor(t, n, r = null, o = null) {
    this.fragmentContext = r, this.scriptHandler = o, this.currentToken = null, this.stopped = !1, this.insertionMode = I.INITIAL, this.originalInsertionMode = I.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...Sg,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new JL(this.options, this), this.activeFormattingElements = new aO(this.treeAdapter), this.fragmentContextID = r ? ou(this.treeAdapter.getTagName(r)) : g.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new sO(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, n) {
    const r = new this(n);
    return r.tokenizer.write(t, !0), r.document;
  }
  static getFragmentParser(t, n) {
    const r = {
      ...Sg,
      ...n
    };
    t ?? (t = r.treeAdapter.createElement(O.TEMPLATE, j.HTML, []));
    const o = r.treeAdapter.createElement("documentmock", j.HTML, []), i = new this(r, o, t);
    return i.fragmentContextID === g.TEMPLATE && i.tmplInsertionModeStack.unshift(I.IN_TEMPLATE), i._initTokenizerForFragmentParsing(), i._insertFakeRootElement(), i._resetInsertionMode(), i._findFormInFragmentContext(), i;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, n), n;
  }
  //Errors
  /** @internal */
  _err(t, n, r) {
    var o;
    if (!this.onParseError)
      return;
    const i = (o = t.location) !== null && o !== void 0 ? o : IO, s = {
      code: n,
      startLine: i.startLine,
      startCol: i.startCol,
      startOffset: i.startOffset,
      endLine: r ? i.startLine : i.endLine,
      endCol: r ? i.startCol : i.endCol,
      endOffset: r ? i.startOffset : i.endOffset
    };
    this.onParseError(s);
  }
  //Stack events
  /** @internal */
  onItemPush(t, n, r) {
    var o, i;
    (i = (o = this.treeAdapter).onItemPush) === null || i === void 0 || i.call(o, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n);
  }
  /** @internal */
  onItemPop(t, n) {
    var r, o;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (o = (r = this.treeAdapter).onItemPop) === null || o === void 0 || o.call(r, t, this.openElements.current), n) {
      let i, s;
      this.openElements.stackTop === 0 && this.fragmentContext ? (i = this.fragmentContext, s = this.fragmentContextID) : { current: i, currentTagId: s } = this.openElements, this._setContextModes(i, s);
    }
  }
  _setContextModes(t, n) {
    const r = t === this.document || t && this.treeAdapter.getNamespaceURI(t) === j.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && t !== void 0 && n !== void 0 && !this._isIntegrationPoint(n, t);
  }
  /** @protected */
  _switchToTextParsing(t, n) {
    this._insertElement(t, j.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = I.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = I.TEXT, this.originalInsertionMode = I.IN_BODY, this.tokenizer.state = rn.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === O.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== j.HTML))
      switch (this.fragmentContextID) {
        case g.TITLE:
        case g.TEXTAREA: {
          this.tokenizer.state = rn.RCDATA;
          break;
        }
        case g.STYLE:
        case g.XMP:
        case g.IFRAME:
        case g.NOEMBED:
        case g.NOFRAMES:
        case g.NOSCRIPT: {
          this.tokenizer.state = rn.RAWTEXT;
          break;
        }
        case g.SCRIPT: {
          this.tokenizer.state = rn.SCRIPT_DATA;
          break;
        }
        case g.PLAINTEXT: {
          this.tokenizer.state = rn.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(t) {
    const n = t.name || "", r = t.publicId || "", o = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, o), t.location) {
      const s = this.treeAdapter.getChildNodes(this.document).find((a) => this.treeAdapter.isDocumentTypeNode(a));
      s && this.treeAdapter.setNodeSourceCodeLocation(s, t.location);
    }
  }
  /** @protected */
  _attachElementToTree(t, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r ?? this.document, t);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  /** @protected */
  _insertElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  /** @protected */
  _insertFakeElement(t, n) {
    const r = this.treeAdapter.createElement(t, j.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  /** @protected */
  _insertTemplate(t) {
    const n = this.treeAdapter.createElement(t.tagName, j.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(O.HTML, j.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, g.HTML);
  }
  /** @protected */
  _appendCommentNode(t, n) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  /** @protected */
  _insertCharacters(t) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location)
      return;
    const o = this.treeAdapter.getChildNodes(n), i = r ? o.lastIndexOf(r) : o.length, s = o[i - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(s)) {
      const { endLine: l, endCol: c, endOffset: u } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(s, { endLine: l, endCol: c, endOffset: u });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(s, t.location);
  }
  /** @protected */
  _adoptNodes(t, n) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  /** @protected */
  _setEndLocation(t, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) {
      const r = n.location, o = this.treeAdapter.getTagName(t), i = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === Be.END_TAG && o === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, i);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === g.SVG && this.treeAdapter.getTagName(n) === O.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === j.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === g.MGLYPH || t.tagID === g.MALIGNMARK) && r !== void 0 && !this._isIntegrationPoint(r, n, j.HTML)
    );
  }
  /** @protected */
  _processToken(t) {
    switch (t.type) {
      case Be.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case Be.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case Be.COMMENT: {
        this.onComment(t);
        break;
      }
      case Be.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case Be.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case Be.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case Be.EOF: {
        this.onEof(t);
        break;
      }
      case Be.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(t, n, r) {
    const o = this.treeAdapter.getNamespaceURI(n), i = this.treeAdapter.getAttrList(n);
    return vO(t, o, i, r);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const n = this.activeFormattingElements.entries.findIndex((o) => o.type === dr.Marker || this.openElements.contains(o.element)), r = n === -1 ? t - 1 : n - 1;
      for (let o = r; o >= 0; o--) {
        const i = this.activeFormattingElements.entries[o];
        this._insertElement(i.token, this.treeAdapter.getNamespaceURI(i.element)), i.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = I.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(g.P), this.openElements.popUntilTagNamePopped(g.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case g.TR: {
          this.insertionMode = I.IN_ROW;
          return;
        }
        case g.TBODY:
        case g.THEAD:
        case g.TFOOT: {
          this.insertionMode = I.IN_TABLE_BODY;
          return;
        }
        case g.CAPTION: {
          this.insertionMode = I.IN_CAPTION;
          return;
        }
        case g.COLGROUP: {
          this.insertionMode = I.IN_COLUMN_GROUP;
          return;
        }
        case g.TABLE: {
          this.insertionMode = I.IN_TABLE;
          return;
        }
        case g.BODY: {
          this.insertionMode = I.IN_BODY;
          return;
        }
        case g.FRAMESET: {
          this.insertionMode = I.IN_FRAMESET;
          return;
        }
        case g.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case g.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case g.HTML: {
          this.insertionMode = this.headElement ? I.AFTER_HEAD : I.BEFORE_HEAD;
          return;
        }
        case g.TD:
        case g.TH: {
          if (t > 0) {
            this.insertionMode = I.IN_CELL;
            return;
          }
          break;
        }
        case g.HEAD: {
          if (t > 0) {
            this.insertionMode = I.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = I.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let n = t - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === g.TEMPLATE)
          break;
        if (r === g.TABLE) {
          this.insertionMode = I.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = I.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(t) {
    return z2.has(t);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const n = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case g.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === j.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case g.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(t) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(t, n) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return KL[r].has(n);
  }
  /** @internal */
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      i8(this, t);
      return;
    }
    switch (this.insertionMode) {
      case I.INITIAL: {
        is(this, t);
        break;
      }
      case I.BEFORE_HTML: {
        ks(this, t);
        break;
      }
      case I.BEFORE_HEAD: {
        Cs(this, t);
        break;
      }
      case I.IN_HEAD: {
        Ts(this, t);
        break;
      }
      case I.IN_HEAD_NO_SCRIPT: {
        xs(this, t);
        break;
      }
      case I.AFTER_HEAD: {
        ws(this, t);
        break;
      }
      case I.IN_BODY:
      case I.IN_CAPTION:
      case I.IN_CELL:
      case I.IN_TEMPLATE: {
        G2(this, t);
        break;
      }
      case I.TEXT:
      case I.IN_SELECT:
      case I.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case I.IN_TABLE:
      case I.IN_TABLE_BODY:
      case I.IN_ROW: {
        ud(this, t);
        break;
      }
      case I.IN_TABLE_TEXT: {
        J2(this, t);
        break;
      }
      case I.IN_COLUMN_GROUP: {
        tc(this, t);
        break;
      }
      case I.AFTER_BODY: {
        nc(this, t);
        break;
      }
      case I.AFTER_AFTER_BODY: {
        Cl(this, t);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      o8(this, t);
      return;
    }
    switch (this.insertionMode) {
      case I.INITIAL: {
        is(this, t);
        break;
      }
      case I.BEFORE_HTML: {
        ks(this, t);
        break;
      }
      case I.BEFORE_HEAD: {
        Cs(this, t);
        break;
      }
      case I.IN_HEAD: {
        Ts(this, t);
        break;
      }
      case I.IN_HEAD_NO_SCRIPT: {
        xs(this, t);
        break;
      }
      case I.AFTER_HEAD: {
        ws(this, t);
        break;
      }
      case I.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case I.IN_TABLE:
      case I.IN_TABLE_BODY:
      case I.IN_ROW: {
        ud(this, t);
        break;
      }
      case I.IN_COLUMN_GROUP: {
        tc(this, t);
        break;
      }
      case I.AFTER_BODY: {
        nc(this, t);
        break;
      }
      case I.AFTER_AFTER_BODY: {
        Cl(this, t);
        break;
      }
    }
  }
  /** @internal */
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      $f(this, t);
      return;
    }
    switch (this.insertionMode) {
      case I.INITIAL:
      case I.BEFORE_HTML:
      case I.BEFORE_HEAD:
      case I.IN_HEAD:
      case I.IN_HEAD_NO_SCRIPT:
      case I.AFTER_HEAD:
      case I.IN_BODY:
      case I.IN_TABLE:
      case I.IN_CAPTION:
      case I.IN_COLUMN_GROUP:
      case I.IN_TABLE_BODY:
      case I.IN_ROW:
      case I.IN_CELL:
      case I.IN_SELECT:
      case I.IN_SELECT_IN_TABLE:
      case I.IN_TEMPLATE:
      case I.IN_FRAMESET:
      case I.AFTER_FRAMESET: {
        $f(this, t);
        break;
      }
      case I.IN_TABLE_TEXT: {
        ss(this, t);
        break;
      }
      case I.AFTER_BODY: {
        PO(this, t);
        break;
      }
      case I.AFTER_AFTER_BODY:
      case I.AFTER_AFTER_FRAMESET: {
        BO(this, t);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case I.INITIAL: {
        $O(this, t);
        break;
      }
      case I.BEFORE_HEAD:
      case I.IN_HEAD:
      case I.IN_HEAD_NO_SCRIPT:
      case I.AFTER_HEAD: {
        this._err(t, P.misplacedDoctype);
        break;
      }
      case I.IN_TABLE_TEXT: {
        ss(this, t);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, P.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? s8(this, t) : this._startTagOutsideForeignContent(t);
  }
  /** @protected */
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case I.INITIAL: {
        is(this, t);
        break;
      }
      case I.BEFORE_HTML: {
        HO(this, t);
        break;
      }
      case I.BEFORE_HEAD: {
        UO(this, t);
        break;
      }
      case I.IN_HEAD: {
        tr(this, t);
        break;
      }
      case I.IN_HEAD_NO_SCRIPT: {
        zO(this, t);
        break;
      }
      case I.AFTER_HEAD: {
        WO(this, t);
        break;
      }
      case I.IN_BODY: {
        Ft(this, t);
        break;
      }
      case I.IN_TABLE: {
        Di(this, t);
        break;
      }
      case I.IN_TABLE_TEXT: {
        ss(this, t);
        break;
      }
      case I.IN_CAPTION: {
        j5(this, t);
        break;
      }
      case I.IN_COLUMN_GROUP: {
        Ip(this, t);
        break;
      }
      case I.IN_TABLE_BODY: {
        au(this, t);
        break;
      }
      case I.IN_ROW: {
        lu(this, t);
        break;
      }
      case I.IN_CELL: {
        q5(this, t);
        break;
      }
      case I.IN_SELECT: {
        nC(this, t);
        break;
      }
      case I.IN_SELECT_IN_TABLE: {
        G5(this, t);
        break;
      }
      case I.IN_TEMPLATE: {
        K5(this, t);
        break;
      }
      case I.AFTER_BODY: {
        Z5(this, t);
        break;
      }
      case I.IN_FRAMESET: {
        X5(this, t);
        break;
      }
      case I.AFTER_FRAMESET: {
        e8(this, t);
        break;
      }
      case I.AFTER_AFTER_BODY: {
        n8(this, t);
        break;
      }
      case I.AFTER_AFTER_FRAMESET: {
        r8(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? a8(this, t) : this._endTagOutsideForeignContent(t);
  }
  /** @protected */
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case I.INITIAL: {
        is(this, t);
        break;
      }
      case I.BEFORE_HTML: {
        FO(this, t);
        break;
      }
      case I.BEFORE_HEAD: {
        jO(this, t);
        break;
      }
      case I.IN_HEAD: {
        VO(this, t);
        break;
      }
      case I.IN_HEAD_NO_SCRIPT: {
        qO(this, t);
        break;
      }
      case I.AFTER_HEAD: {
        GO(this, t);
        break;
      }
      case I.IN_BODY: {
        su(this, t);
        break;
      }
      case I.TEXT: {
        L5(this, t);
        break;
      }
      case I.IN_TABLE: {
        Qs(this, t);
        break;
      }
      case I.IN_TABLE_TEXT: {
        ss(this, t);
        break;
      }
      case I.IN_CAPTION: {
        V5(this, t);
        break;
      }
      case I.IN_COLUMN_GROUP: {
        z5(this, t);
        break;
      }
      case I.IN_TABLE_BODY: {
        Hf(this, t);
        break;
      }
      case I.IN_ROW: {
        tC(this, t);
        break;
      }
      case I.IN_CELL: {
        W5(this, t);
        break;
      }
      case I.IN_SELECT: {
        rC(this, t);
        break;
      }
      case I.IN_SELECT_IN_TABLE: {
        Y5(this, t);
        break;
      }
      case I.IN_TEMPLATE: {
        Q5(this, t);
        break;
      }
      case I.AFTER_BODY: {
        iC(this, t);
        break;
      }
      case I.IN_FRAMESET: {
        J5(this, t);
        break;
      }
      case I.AFTER_FRAMESET: {
        t8(this, t);
        break;
      }
      case I.AFTER_AFTER_BODY: {
        Cl(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEof(t) {
    switch (this.insertionMode) {
      case I.INITIAL: {
        is(this, t);
        break;
      }
      case I.BEFORE_HTML: {
        ks(this, t);
        break;
      }
      case I.BEFORE_HEAD: {
        Cs(this, t);
        break;
      }
      case I.IN_HEAD: {
        Ts(this, t);
        break;
      }
      case I.IN_HEAD_NO_SCRIPT: {
        xs(this, t);
        break;
      }
      case I.AFTER_HEAD: {
        ws(this, t);
        break;
      }
      case I.IN_BODY:
      case I.IN_TABLE:
      case I.IN_CAPTION:
      case I.IN_COLUMN_GROUP:
      case I.IN_TABLE_BODY:
      case I.IN_ROW:
      case I.IN_CELL:
      case I.IN_SELECT:
      case I.IN_SELECT_IN_TABLE: {
        Z2(this, t);
        break;
      }
      case I.TEXT: {
        O5(this, t);
        break;
      }
      case I.IN_TABLE_TEXT: {
        ss(this, t);
        break;
      }
      case I.IN_TEMPLATE: {
        oC(this, t);
        break;
      }
      case I.AFTER_BODY:
      case I.IN_FRAMESET:
      case I.AFTER_FRAMESET:
      case I.AFTER_AFTER_BODY:
      case I.AFTER_AFTER_FRAMESET: {
        Ap(this, t);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === x.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case I.IN_HEAD:
      case I.IN_HEAD_NO_SCRIPT:
      case I.AFTER_HEAD:
      case I.TEXT:
      case I.IN_COLUMN_GROUP:
      case I.IN_SELECT:
      case I.IN_SELECT_IN_TABLE:
      case I.IN_FRAMESET:
      case I.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case I.IN_BODY:
      case I.IN_CAPTION:
      case I.IN_CELL:
      case I.IN_TEMPLATE:
      case I.AFTER_BODY:
      case I.AFTER_AFTER_BODY:
      case I.AFTER_AFTER_FRAMESET: {
        W2(this, t);
        break;
      }
      case I.IN_TABLE:
      case I.IN_TABLE_BODY:
      case I.IN_ROW: {
        ud(this, t);
        break;
      }
      case I.IN_TABLE_TEXT: {
        X2(this, t);
        break;
      }
    }
  }
}
function NO(e, t) {
  let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : Q2(e, t), n;
}
function MO(e, t) {
  let n = null, r = e.openElements.stackTop;
  for (; r >= 0; r--) {
    const o = e.openElements.items[r];
    if (o === t.element)
      break;
    e._isSpecialElement(o, e.openElements.tagIDs[r]) && (n = o);
  }
  return n || (e.openElements.shortenToLength(Math.max(r, 0)), e.activeFormattingElements.removeEntry(t)), n;
}
function LO(e, t, n) {
  let r = t, o = e.openElements.getCommonAncestor(t);
  for (let i = 0, s = o; s !== n; i++, s = o) {
    o = e.openElements.getCommonAncestor(s);
    const a = e.activeFormattingElements.getElementEntry(s), l = a && i >= AO;
    !a || l ? (l && e.activeFormattingElements.removeEntry(a), e.openElements.remove(s)) : (s = OO(e, a), r === t && (e.activeFormattingElements.bookmark = a), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(s, r), r = s);
  }
  return r;
}
function OO(e, t) {
  const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
  return e.openElements.replace(t.element, r), t.element = r, r;
}
function DO(e, t, n) {
  const r = e.treeAdapter.getTagName(t), o = ou(r);
  if (e._isElementCausesFosterParenting(o))
    e._fosterParentElement(n);
  else {
    const i = e.treeAdapter.getNamespaceURI(t);
    o === g.TEMPLATE && i === j.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n);
  }
}
function RO(e, t, n) {
  const r = e.treeAdapter.getNamespaceURI(n.element), { token: o } = n, i = e.treeAdapter.createElement(o.tagName, r, o.attrs);
  e._adoptNodes(t, i), e.treeAdapter.appendChild(t, i), e.activeFormattingElements.insertElementAfterBookmark(i, o), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, i, o.tagID);
}
function _p(e, t) {
  for (let n = 0; n < _O; n++) {
    const r = NO(e, t);
    if (!r)
      break;
    const o = MO(e, r);
    if (!o)
      break;
    e.activeFormattingElements.bookmark = r;
    const i = LO(e, o, r.element), s = e.openElements.getCommonAncestor(r.element);
    e.treeAdapter.detachNode(i), s && DO(e, s, i), RO(e, o, r);
  }
}
function $f(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function PO(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function BO(e, t) {
  e._appendCommentNode(t, e.document);
}
function Ap(e, t) {
  if (e.stopped = !0, t.location) {
    const n = e.fragmentContext ? 0 : 2;
    for (let r = e.openElements.stackTop; r >= n; r--)
      e._setEndLocation(e.openElements.items[r], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const r = e.openElements.items[0], o = e.treeAdapter.getNodeSourceCodeLocation(r);
      if (o && !o.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
        const i = e.openElements.items[1], s = e.treeAdapter.getNodeSourceCodeLocation(i);
        s && !s.endTag && e._setEndLocation(i, t);
      }
    }
  }
}
function $O(e, t) {
  e._setDocumentType(t);
  const n = t.forceQuirks ? _n.QUIRKS : pO(t);
  hO(t) || e._err(t, P.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = I.BEFORE_HTML;
}
function is(e, t) {
  e._err(t, P.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, _n.QUIRKS), e.insertionMode = I.BEFORE_HTML, e._processToken(t);
}
function HO(e, t) {
  t.tagID === g.HTML ? (e._insertElement(t, j.HTML), e.insertionMode = I.BEFORE_HEAD) : ks(e, t);
}
function FO(e, t) {
  const n = t.tagID;
  (n === g.HTML || n === g.HEAD || n === g.BODY || n === g.BR) && ks(e, t);
}
function ks(e, t) {
  e._insertFakeRootElement(), e.insertionMode = I.BEFORE_HEAD, e._processToken(t);
}
function UO(e, t) {
  switch (t.tagID) {
    case g.HTML: {
      Ft(e, t);
      break;
    }
    case g.HEAD: {
      e._insertElement(t, j.HTML), e.headElement = e.openElements.current, e.insertionMode = I.IN_HEAD;
      break;
    }
    default:
      Cs(e, t);
  }
}
function jO(e, t) {
  const n = t.tagID;
  n === g.HEAD || n === g.BODY || n === g.HTML || n === g.BR ? Cs(e, t) : e._err(t, P.endTagWithoutMatchingOpenElement);
}
function Cs(e, t) {
  e._insertFakeElement(O.HEAD, g.HEAD), e.headElement = e.openElements.current, e.insertionMode = I.IN_HEAD, e._processToken(t);
}
function tr(e, t) {
  switch (t.tagID) {
    case g.HTML: {
      Ft(e, t);
      break;
    }
    case g.BASE:
    case g.BASEFONT:
    case g.BGSOUND:
    case g.LINK:
    case g.META: {
      e._appendElement(t, j.HTML), t.ackSelfClosing = !0;
      break;
    }
    case g.TITLE: {
      e._switchToTextParsing(t, rn.RCDATA);
      break;
    }
    case g.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, rn.RAWTEXT) : (e._insertElement(t, j.HTML), e.insertionMode = I.IN_HEAD_NO_SCRIPT);
      break;
    }
    case g.NOFRAMES:
    case g.STYLE: {
      e._switchToTextParsing(t, rn.RAWTEXT);
      break;
    }
    case g.SCRIPT: {
      e._switchToTextParsing(t, rn.SCRIPT_DATA);
      break;
    }
    case g.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = I.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(I.IN_TEMPLATE);
      break;
    }
    case g.HEAD: {
      e._err(t, P.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Ts(e, t);
  }
}
function VO(e, t) {
  switch (t.tagID) {
    case g.HEAD: {
      e.openElements.pop(), e.insertionMode = I.AFTER_HEAD;
      break;
    }
    case g.BODY:
    case g.BR:
    case g.HTML: {
      Ts(e, t);
      break;
    }
    case g.TEMPLATE: {
      Jo(e, t);
      break;
    }
    default:
      e._err(t, P.endTagWithoutMatchingOpenElement);
  }
}
function Jo(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== g.TEMPLATE && e._err(t, P.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(g.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, P.endTagWithoutMatchingOpenElement);
}
function Ts(e, t) {
  e.openElements.pop(), e.insertionMode = I.AFTER_HEAD, e._processToken(t);
}
function zO(e, t) {
  switch (t.tagID) {
    case g.HTML: {
      Ft(e, t);
      break;
    }
    case g.BASEFONT:
    case g.BGSOUND:
    case g.HEAD:
    case g.LINK:
    case g.META:
    case g.NOFRAMES:
    case g.STYLE: {
      tr(e, t);
      break;
    }
    case g.NOSCRIPT: {
      e._err(t, P.nestedNoscriptInHead);
      break;
    }
    default:
      xs(e, t);
  }
}
function qO(e, t) {
  switch (t.tagID) {
    case g.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = I.IN_HEAD;
      break;
    }
    case g.BR: {
      xs(e, t);
      break;
    }
    default:
      e._err(t, P.endTagWithoutMatchingOpenElement);
  }
}
function xs(e, t) {
  const n = t.type === Be.EOF ? P.openElementsLeftAfterEof : P.disallowedContentInNoscriptInHead;
  e._err(t, n), e.openElements.pop(), e.insertionMode = I.IN_HEAD, e._processToken(t);
}
function WO(e, t) {
  switch (t.tagID) {
    case g.HTML: {
      Ft(e, t);
      break;
    }
    case g.BODY: {
      e._insertElement(t, j.HTML), e.framesetOk = !1, e.insertionMode = I.IN_BODY;
      break;
    }
    case g.FRAMESET: {
      e._insertElement(t, j.HTML), e.insertionMode = I.IN_FRAMESET;
      break;
    }
    case g.BASE:
    case g.BASEFONT:
    case g.BGSOUND:
    case g.LINK:
    case g.META:
    case g.NOFRAMES:
    case g.SCRIPT:
    case g.STYLE:
    case g.TEMPLATE:
    case g.TITLE: {
      e._err(t, P.abandonedHeadElementChild), e.openElements.push(e.headElement, g.HEAD), tr(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case g.HEAD: {
      e._err(t, P.misplacedStartTagForHeadElement);
      break;
    }
    default:
      ws(e, t);
  }
}
function GO(e, t) {
  switch (t.tagID) {
    case g.BODY:
    case g.HTML:
    case g.BR: {
      ws(e, t);
      break;
    }
    case g.TEMPLATE: {
      Jo(e, t);
      break;
    }
    default:
      e._err(t, P.endTagWithoutMatchingOpenElement);
  }
}
function ws(e, t) {
  e._insertFakeElement(O.BODY, g.BODY), e.insertionMode = I.IN_BODY, iu(e, t);
}
function iu(e, t) {
  switch (t.type) {
    case Be.CHARACTER: {
      G2(e, t);
      break;
    }
    case Be.WHITESPACE_CHARACTER: {
      W2(e, t);
      break;
    }
    case Be.COMMENT: {
      $f(e, t);
      break;
    }
    case Be.START_TAG: {
      Ft(e, t);
      break;
    }
    case Be.END_TAG: {
      su(e, t);
      break;
    }
    case Be.EOF: {
      Z2(e, t);
      break;
    }
  }
}
function W2(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function G2(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function YO(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function KO(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs));
}
function QO(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, j.HTML), e.insertionMode = I.IN_FRAMESET);
}
function ZO(e, t) {
  e.openElements.hasInButtonScope(g.P) && e._closePElement(), e._insertElement(t, j.HTML);
}
function XO(e, t) {
  e.openElements.hasInButtonScope(g.P) && e._closePElement(), e.openElements.currentTagId !== void 0 && Bf.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, j.HTML);
}
function JO(e, t) {
  e.openElements.hasInButtonScope(g.P) && e._closePElement(), e._insertElement(t, j.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function e5(e, t) {
  const n = e.openElements.tmplCount > 0;
  (!e.formElement || n) && (e.openElements.hasInButtonScope(g.P) && e._closePElement(), e._insertElement(t, j.HTML), n || (e.formElement = e.openElements.current));
}
function t5(e, t) {
  e.framesetOk = !1;
  const n = t.tagID;
  for (let r = e.openElements.stackTop; r >= 0; r--) {
    const o = e.openElements.tagIDs[r];
    if (n === g.LI && o === g.LI || (n === g.DD || n === g.DT) && (o === g.DD || o === g.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(o), e.openElements.popUntilTagNamePopped(o);
      break;
    }
    if (o !== g.ADDRESS && o !== g.DIV && o !== g.P && e._isSpecialElement(e.openElements.items[r], o))
      break;
  }
  e.openElements.hasInButtonScope(g.P) && e._closePElement(), e._insertElement(t, j.HTML);
}
function n5(e, t) {
  e.openElements.hasInButtonScope(g.P) && e._closePElement(), e._insertElement(t, j.HTML), e.tokenizer.state = rn.PLAINTEXT;
}
function r5(e, t) {
  e.openElements.hasInScope(g.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(g.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, j.HTML), e.framesetOk = !1;
}
function o5(e, t) {
  const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(O.A);
  n && (_p(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, j.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function i5(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, j.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function s5(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(g.NOBR) && (_p(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, j.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function a5(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, j.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function l5(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== _n.QUIRKS && e.openElements.hasInButtonScope(g.P) && e._closePElement(), e._insertElement(t, j.HTML), e.framesetOk = !1, e.insertionMode = I.IN_TABLE;
}
function Y2(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, j.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function K2(e) {
  const t = P2(e, Ro.TYPE);
  return t != null && t.toLowerCase() === SO;
}
function c5(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, j.HTML), K2(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function u5(e, t) {
  e._appendElement(t, j.HTML), t.ackSelfClosing = !0;
}
function d5(e, t) {
  e.openElements.hasInButtonScope(g.P) && e._closePElement(), e._appendElement(t, j.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function f5(e, t) {
  t.tagName = O.IMG, t.tagID = g.IMG, Y2(e, t);
}
function h5(e, t) {
  e._insertElement(t, j.HTML), e.skipNextNewLine = !0, e.tokenizer.state = rn.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = I.TEXT;
}
function p5(e, t) {
  e.openElements.hasInButtonScope(g.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, rn.RAWTEXT);
}
function m5(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, rn.RAWTEXT);
}
function _g(e, t) {
  e._switchToTextParsing(t, rn.RAWTEXT);
}
function g5(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, j.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === I.IN_TABLE || e.insertionMode === I.IN_CAPTION || e.insertionMode === I.IN_TABLE_BODY || e.insertionMode === I.IN_ROW || e.insertionMode === I.IN_CELL ? I.IN_SELECT_IN_TABLE : I.IN_SELECT;
}
function b5(e, t) {
  e.openElements.currentTagId === g.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, j.HTML);
}
function y5(e, t) {
  e.openElements.hasInScope(g.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, j.HTML);
}
function E5(e, t) {
  e.openElements.hasInScope(g.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(g.RTC), e._insertElement(t, j.HTML);
}
function k5(e, t) {
  e._reconstructActiveFormattingElements(), j2(t), Sp(t), t.selfClosing ? e._appendElement(t, j.MATHML) : e._insertElement(t, j.MATHML), t.ackSelfClosing = !0;
}
function C5(e, t) {
  e._reconstructActiveFormattingElements(), V2(t), Sp(t), t.selfClosing ? e._appendElement(t, j.SVG) : e._insertElement(t, j.SVG), t.ackSelfClosing = !0;
}
function Ag(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, j.HTML);
}
function Ft(e, t) {
  switch (t.tagID) {
    case g.I:
    case g.S:
    case g.B:
    case g.U:
    case g.EM:
    case g.TT:
    case g.BIG:
    case g.CODE:
    case g.FONT:
    case g.SMALL:
    case g.STRIKE:
    case g.STRONG: {
      i5(e, t);
      break;
    }
    case g.A: {
      o5(e, t);
      break;
    }
    case g.H1:
    case g.H2:
    case g.H3:
    case g.H4:
    case g.H5:
    case g.H6: {
      XO(e, t);
      break;
    }
    case g.P:
    case g.DL:
    case g.OL:
    case g.UL:
    case g.DIV:
    case g.DIR:
    case g.NAV:
    case g.MAIN:
    case g.MENU:
    case g.ASIDE:
    case g.CENTER:
    case g.FIGURE:
    case g.FOOTER:
    case g.HEADER:
    case g.HGROUP:
    case g.DIALOG:
    case g.DETAILS:
    case g.ADDRESS:
    case g.ARTICLE:
    case g.SEARCH:
    case g.SECTION:
    case g.SUMMARY:
    case g.FIELDSET:
    case g.BLOCKQUOTE:
    case g.FIGCAPTION: {
      ZO(e, t);
      break;
    }
    case g.LI:
    case g.DD:
    case g.DT: {
      t5(e, t);
      break;
    }
    case g.BR:
    case g.IMG:
    case g.WBR:
    case g.AREA:
    case g.EMBED:
    case g.KEYGEN: {
      Y2(e, t);
      break;
    }
    case g.HR: {
      d5(e, t);
      break;
    }
    case g.RB:
    case g.RTC: {
      y5(e, t);
      break;
    }
    case g.RT:
    case g.RP: {
      E5(e, t);
      break;
    }
    case g.PRE:
    case g.LISTING: {
      JO(e, t);
      break;
    }
    case g.XMP: {
      p5(e, t);
      break;
    }
    case g.SVG: {
      C5(e, t);
      break;
    }
    case g.HTML: {
      YO(e, t);
      break;
    }
    case g.BASE:
    case g.LINK:
    case g.META:
    case g.STYLE:
    case g.TITLE:
    case g.SCRIPT:
    case g.BGSOUND:
    case g.BASEFONT:
    case g.TEMPLATE: {
      tr(e, t);
      break;
    }
    case g.BODY: {
      KO(e, t);
      break;
    }
    case g.FORM: {
      e5(e, t);
      break;
    }
    case g.NOBR: {
      s5(e, t);
      break;
    }
    case g.MATH: {
      k5(e, t);
      break;
    }
    case g.TABLE: {
      l5(e, t);
      break;
    }
    case g.INPUT: {
      c5(e, t);
      break;
    }
    case g.PARAM:
    case g.TRACK:
    case g.SOURCE: {
      u5(e, t);
      break;
    }
    case g.IMAGE: {
      f5(e, t);
      break;
    }
    case g.BUTTON: {
      r5(e, t);
      break;
    }
    case g.APPLET:
    case g.OBJECT:
    case g.MARQUEE: {
      a5(e, t);
      break;
    }
    case g.IFRAME: {
      m5(e, t);
      break;
    }
    case g.SELECT: {
      g5(e, t);
      break;
    }
    case g.OPTION:
    case g.OPTGROUP: {
      b5(e, t);
      break;
    }
    case g.NOEMBED:
    case g.NOFRAMES: {
      _g(e, t);
      break;
    }
    case g.FRAMESET: {
      QO(e, t);
      break;
    }
    case g.TEXTAREA: {
      h5(e, t);
      break;
    }
    case g.NOSCRIPT: {
      e.options.scriptingEnabled ? _g(e, t) : Ag(e, t);
      break;
    }
    case g.PLAINTEXT: {
      n5(e, t);
      break;
    }
    case g.COL:
    case g.TH:
    case g.TD:
    case g.TR:
    case g.HEAD:
    case g.FRAME:
    case g.TBODY:
    case g.TFOOT:
    case g.THEAD:
    case g.CAPTION:
    case g.COLGROUP:
      break;
    default:
      Ag(e, t);
  }
}
function T5(e, t) {
  if (e.openElements.hasInScope(g.BODY) && (e.insertionMode = I.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const n = e.openElements.tryPeekProperlyNestedBodyElement();
    n && e._setEndLocation(n, t);
  }
}
function x5(e, t) {
  e.openElements.hasInScope(g.BODY) && (e.insertionMode = I.AFTER_BODY, iC(e, t));
}
function w5(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n));
}
function v5(e) {
  const t = e.openElements.tmplCount > 0, { formElement: n } = e;
  t || (e.formElement = null), (n || t) && e.openElements.hasInScope(g.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(g.FORM) : n && e.openElements.remove(n));
}
function S5(e) {
  e.openElements.hasInButtonScope(g.P) || e._insertFakeElement(O.P, g.P), e._closePElement();
}
function _5(e) {
  e.openElements.hasInListItemScope(g.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(g.LI), e.openElements.popUntilTagNamePopped(g.LI));
}
function A5(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n));
}
function I5(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function N5(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker());
}
function M5(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(O.BR, g.BR), e.openElements.pop(), e.framesetOk = !1;
}
function Q2(e, t) {
  const n = t.tagName, r = t.tagID;
  for (let o = e.openElements.stackTop; o > 0; o--) {
    const i = e.openElements.items[o], s = e.openElements.tagIDs[o];
    if (r === s && (r !== g.UNKNOWN || e.treeAdapter.getTagName(i) === n)) {
      e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= o && e.openElements.shortenToLength(o);
      break;
    }
    if (e._isSpecialElement(i, s))
      break;
  }
}
function su(e, t) {
  switch (t.tagID) {
    case g.A:
    case g.B:
    case g.I:
    case g.S:
    case g.U:
    case g.EM:
    case g.TT:
    case g.BIG:
    case g.CODE:
    case g.FONT:
    case g.NOBR:
    case g.SMALL:
    case g.STRIKE:
    case g.STRONG: {
      _p(e, t);
      break;
    }
    case g.P: {
      S5(e);
      break;
    }
    case g.DL:
    case g.UL:
    case g.OL:
    case g.DIR:
    case g.DIV:
    case g.NAV:
    case g.PRE:
    case g.MAIN:
    case g.MENU:
    case g.ASIDE:
    case g.BUTTON:
    case g.CENTER:
    case g.FIGURE:
    case g.FOOTER:
    case g.HEADER:
    case g.HGROUP:
    case g.DIALOG:
    case g.ADDRESS:
    case g.ARTICLE:
    case g.DETAILS:
    case g.SEARCH:
    case g.SECTION:
    case g.SUMMARY:
    case g.LISTING:
    case g.FIELDSET:
    case g.BLOCKQUOTE:
    case g.FIGCAPTION: {
      w5(e, t);
      break;
    }
    case g.LI: {
      _5(e);
      break;
    }
    case g.DD:
    case g.DT: {
      A5(e, t);
      break;
    }
    case g.H1:
    case g.H2:
    case g.H3:
    case g.H4:
    case g.H5:
    case g.H6: {
      I5(e);
      break;
    }
    case g.BR: {
      M5(e);
      break;
    }
    case g.BODY: {
      T5(e, t);
      break;
    }
    case g.HTML: {
      x5(e, t);
      break;
    }
    case g.FORM: {
      v5(e);
      break;
    }
    case g.APPLET:
    case g.OBJECT:
    case g.MARQUEE: {
      N5(e, t);
      break;
    }
    case g.TEMPLATE: {
      Jo(e, t);
      break;
    }
    default:
      Q2(e, t);
  }
}
function Z2(e, t) {
  e.tmplInsertionModeStack.length > 0 ? oC(e, t) : Ap(e, t);
}
function L5(e, t) {
  var n;
  t.tagID === g.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function O5(e, t) {
  e._err(t, P.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function ud(e, t) {
  if (e.openElements.currentTagId !== void 0 && z2.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = I.IN_TABLE_TEXT, t.type) {
      case Be.CHARACTER: {
        J2(e, t);
        break;
      }
      case Be.WHITESPACE_CHARACTER: {
        X2(e, t);
        break;
      }
    }
  else
    pa(e, t);
}
function D5(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, j.HTML), e.insertionMode = I.IN_CAPTION;
}
function R5(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, j.HTML), e.insertionMode = I.IN_COLUMN_GROUP;
}
function P5(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(O.COLGROUP, g.COLGROUP), e.insertionMode = I.IN_COLUMN_GROUP, Ip(e, t);
}
function B5(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, j.HTML), e.insertionMode = I.IN_TABLE_BODY;
}
function $5(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(O.TBODY, g.TBODY), e.insertionMode = I.IN_TABLE_BODY, au(e, t);
}
function H5(e, t) {
  e.openElements.hasInTableScope(g.TABLE) && (e.openElements.popUntilTagNamePopped(g.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function F5(e, t) {
  K2(t) ? e._appendElement(t, j.HTML) : pa(e, t), t.ackSelfClosing = !0;
}
function U5(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, j.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function Di(e, t) {
  switch (t.tagID) {
    case g.TD:
    case g.TH:
    case g.TR: {
      $5(e, t);
      break;
    }
    case g.STYLE:
    case g.SCRIPT:
    case g.TEMPLATE: {
      tr(e, t);
      break;
    }
    case g.COL: {
      P5(e, t);
      break;
    }
    case g.FORM: {
      U5(e, t);
      break;
    }
    case g.TABLE: {
      H5(e, t);
      break;
    }
    case g.TBODY:
    case g.TFOOT:
    case g.THEAD: {
      B5(e, t);
      break;
    }
    case g.INPUT: {
      F5(e, t);
      break;
    }
    case g.CAPTION: {
      D5(e, t);
      break;
    }
    case g.COLGROUP: {
      R5(e, t);
      break;
    }
    default:
      pa(e, t);
  }
}
function Qs(e, t) {
  switch (t.tagID) {
    case g.TABLE: {
      e.openElements.hasInTableScope(g.TABLE) && (e.openElements.popUntilTagNamePopped(g.TABLE), e._resetInsertionMode());
      break;
    }
    case g.TEMPLATE: {
      Jo(e, t);
      break;
    }
    case g.BODY:
    case g.CAPTION:
    case g.COL:
    case g.COLGROUP:
    case g.HTML:
    case g.TBODY:
    case g.TD:
    case g.TFOOT:
    case g.TH:
    case g.THEAD:
    case g.TR:
      break;
    default:
      pa(e, t);
  }
}
function pa(e, t) {
  const n = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, iu(e, t), e.fosterParentingEnabled = n;
}
function X2(e, t) {
  e.pendingCharacterTokens.push(t);
}
function J2(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function ss(e, t) {
  let n = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; n < e.pendingCharacterTokens.length; n++)
      pa(e, e.pendingCharacterTokens[n]);
  else
    for (; n < e.pendingCharacterTokens.length; n++)
      e._insertCharacters(e.pendingCharacterTokens[n]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const eC = /* @__PURE__ */ new Set([g.CAPTION, g.COL, g.COLGROUP, g.TBODY, g.TD, g.TFOOT, g.TH, g.THEAD, g.TR]);
function j5(e, t) {
  const n = t.tagID;
  eC.has(n) ? e.openElements.hasInTableScope(g.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(g.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = I.IN_TABLE, Di(e, t)) : Ft(e, t);
}
function V5(e, t) {
  const n = t.tagID;
  switch (n) {
    case g.CAPTION:
    case g.TABLE: {
      e.openElements.hasInTableScope(g.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(g.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = I.IN_TABLE, n === g.TABLE && Qs(e, t));
      break;
    }
    case g.BODY:
    case g.COL:
    case g.COLGROUP:
    case g.HTML:
    case g.TBODY:
    case g.TD:
    case g.TFOOT:
    case g.TH:
    case g.THEAD:
    case g.TR:
      break;
    default:
      su(e, t);
  }
}
function Ip(e, t) {
  switch (t.tagID) {
    case g.HTML: {
      Ft(e, t);
      break;
    }
    case g.COL: {
      e._appendElement(t, j.HTML), t.ackSelfClosing = !0;
      break;
    }
    case g.TEMPLATE: {
      tr(e, t);
      break;
    }
    default:
      tc(e, t);
  }
}
function z5(e, t) {
  switch (t.tagID) {
    case g.COLGROUP: {
      e.openElements.currentTagId === g.COLGROUP && (e.openElements.pop(), e.insertionMode = I.IN_TABLE);
      break;
    }
    case g.TEMPLATE: {
      Jo(e, t);
      break;
    }
    case g.COL:
      break;
    default:
      tc(e, t);
  }
}
function tc(e, t) {
  e.openElements.currentTagId === g.COLGROUP && (e.openElements.pop(), e.insertionMode = I.IN_TABLE, e._processToken(t));
}
function au(e, t) {
  switch (t.tagID) {
    case g.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, j.HTML), e.insertionMode = I.IN_ROW;
      break;
    }
    case g.TH:
    case g.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(O.TR, g.TR), e.insertionMode = I.IN_ROW, lu(e, t);
      break;
    }
    case g.CAPTION:
    case g.COL:
    case g.COLGROUP:
    case g.TBODY:
    case g.TFOOT:
    case g.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = I.IN_TABLE, Di(e, t));
      break;
    }
    default:
      Di(e, t);
  }
}
function Hf(e, t) {
  const n = t.tagID;
  switch (t.tagID) {
    case g.TBODY:
    case g.TFOOT:
    case g.THEAD: {
      e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = I.IN_TABLE);
      break;
    }
    case g.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = I.IN_TABLE, Qs(e, t));
      break;
    }
    case g.BODY:
    case g.CAPTION:
    case g.COL:
    case g.COLGROUP:
    case g.HTML:
    case g.TD:
    case g.TH:
    case g.TR:
      break;
    default:
      Qs(e, t);
  }
}
function lu(e, t) {
  switch (t.tagID) {
    case g.TH:
    case g.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, j.HTML), e.insertionMode = I.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case g.CAPTION:
    case g.COL:
    case g.COLGROUP:
    case g.TBODY:
    case g.TFOOT:
    case g.THEAD:
    case g.TR: {
      e.openElements.hasInTableScope(g.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = I.IN_TABLE_BODY, au(e, t));
      break;
    }
    default:
      Di(e, t);
  }
}
function tC(e, t) {
  switch (t.tagID) {
    case g.TR: {
      e.openElements.hasInTableScope(g.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = I.IN_TABLE_BODY);
      break;
    }
    case g.TABLE: {
      e.openElements.hasInTableScope(g.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = I.IN_TABLE_BODY, Hf(e, t));
      break;
    }
    case g.TBODY:
    case g.TFOOT:
    case g.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(g.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = I.IN_TABLE_BODY, Hf(e, t));
      break;
    }
    case g.BODY:
    case g.CAPTION:
    case g.COL:
    case g.COLGROUP:
    case g.HTML:
    case g.TD:
    case g.TH:
      break;
    default:
      Qs(e, t);
  }
}
function q5(e, t) {
  const n = t.tagID;
  eC.has(n) ? (e.openElements.hasInTableScope(g.TD) || e.openElements.hasInTableScope(g.TH)) && (e._closeTableCell(), lu(e, t)) : Ft(e, t);
}
function W5(e, t) {
  const n = t.tagID;
  switch (n) {
    case g.TD:
    case g.TH: {
      e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = I.IN_ROW);
      break;
    }
    case g.TABLE:
    case g.TBODY:
    case g.TFOOT:
    case g.THEAD:
    case g.TR: {
      e.openElements.hasInTableScope(n) && (e._closeTableCell(), tC(e, t));
      break;
    }
    case g.BODY:
    case g.CAPTION:
    case g.COL:
    case g.COLGROUP:
    case g.HTML:
      break;
    default:
      su(e, t);
  }
}
function nC(e, t) {
  switch (t.tagID) {
    case g.HTML: {
      Ft(e, t);
      break;
    }
    case g.OPTION: {
      e.openElements.currentTagId === g.OPTION && e.openElements.pop(), e._insertElement(t, j.HTML);
      break;
    }
    case g.OPTGROUP: {
      e.openElements.currentTagId === g.OPTION && e.openElements.pop(), e.openElements.currentTagId === g.OPTGROUP && e.openElements.pop(), e._insertElement(t, j.HTML);
      break;
    }
    case g.HR: {
      e.openElements.currentTagId === g.OPTION && e.openElements.pop(), e.openElements.currentTagId === g.OPTGROUP && e.openElements.pop(), e._appendElement(t, j.HTML), t.ackSelfClosing = !0;
      break;
    }
    case g.INPUT:
    case g.KEYGEN:
    case g.TEXTAREA:
    case g.SELECT: {
      e.openElements.hasInSelectScope(g.SELECT) && (e.openElements.popUntilTagNamePopped(g.SELECT), e._resetInsertionMode(), t.tagID !== g.SELECT && e._processStartTag(t));
      break;
    }
    case g.SCRIPT:
    case g.TEMPLATE: {
      tr(e, t);
      break;
    }
  }
}
function rC(e, t) {
  switch (t.tagID) {
    case g.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === g.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === g.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === g.OPTGROUP && e.openElements.pop();
      break;
    }
    case g.OPTION: {
      e.openElements.currentTagId === g.OPTION && e.openElements.pop();
      break;
    }
    case g.SELECT: {
      e.openElements.hasInSelectScope(g.SELECT) && (e.openElements.popUntilTagNamePopped(g.SELECT), e._resetInsertionMode());
      break;
    }
    case g.TEMPLATE: {
      Jo(e, t);
      break;
    }
  }
}
function G5(e, t) {
  const n = t.tagID;
  n === g.CAPTION || n === g.TABLE || n === g.TBODY || n === g.TFOOT || n === g.THEAD || n === g.TR || n === g.TD || n === g.TH ? (e.openElements.popUntilTagNamePopped(g.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : nC(e, t);
}
function Y5(e, t) {
  const n = t.tagID;
  n === g.CAPTION || n === g.TABLE || n === g.TBODY || n === g.TFOOT || n === g.THEAD || n === g.TR || n === g.TD || n === g.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(g.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : rC(e, t);
}
function K5(e, t) {
  switch (t.tagID) {
    case g.BASE:
    case g.BASEFONT:
    case g.BGSOUND:
    case g.LINK:
    case g.META:
    case g.NOFRAMES:
    case g.SCRIPT:
    case g.STYLE:
    case g.TEMPLATE:
    case g.TITLE: {
      tr(e, t);
      break;
    }
    case g.CAPTION:
    case g.COLGROUP:
    case g.TBODY:
    case g.TFOOT:
    case g.THEAD: {
      e.tmplInsertionModeStack[0] = I.IN_TABLE, e.insertionMode = I.IN_TABLE, Di(e, t);
      break;
    }
    case g.COL: {
      e.tmplInsertionModeStack[0] = I.IN_COLUMN_GROUP, e.insertionMode = I.IN_COLUMN_GROUP, Ip(e, t);
      break;
    }
    case g.TR: {
      e.tmplInsertionModeStack[0] = I.IN_TABLE_BODY, e.insertionMode = I.IN_TABLE_BODY, au(e, t);
      break;
    }
    case g.TD:
    case g.TH: {
      e.tmplInsertionModeStack[0] = I.IN_ROW, e.insertionMode = I.IN_ROW, lu(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = I.IN_BODY, e.insertionMode = I.IN_BODY, Ft(e, t);
  }
}
function Q5(e, t) {
  t.tagID === g.TEMPLATE && Jo(e, t);
}
function oC(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(g.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : Ap(e, t);
}
function Z5(e, t) {
  t.tagID === g.HTML ? Ft(e, t) : nc(e, t);
}
function iC(e, t) {
  var n;
  if (t.tagID === g.HTML) {
    if (e.fragmentContext || (e.insertionMode = I.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === g.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const r = e.openElements.items[1];
      r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t);
    }
  } else
    nc(e, t);
}
function nc(e, t) {
  e.insertionMode = I.IN_BODY, iu(e, t);
}
function X5(e, t) {
  switch (t.tagID) {
    case g.HTML: {
      Ft(e, t);
      break;
    }
    case g.FRAMESET: {
      e._insertElement(t, j.HTML);
      break;
    }
    case g.FRAME: {
      e._appendElement(t, j.HTML), t.ackSelfClosing = !0;
      break;
    }
    case g.NOFRAMES: {
      tr(e, t);
      break;
    }
  }
}
function J5(e, t) {
  t.tagID === g.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== g.FRAMESET && (e.insertionMode = I.AFTER_FRAMESET));
}
function e8(e, t) {
  switch (t.tagID) {
    case g.HTML: {
      Ft(e, t);
      break;
    }
    case g.NOFRAMES: {
      tr(e, t);
      break;
    }
  }
}
function t8(e, t) {
  t.tagID === g.HTML && (e.insertionMode = I.AFTER_AFTER_FRAMESET);
}
function n8(e, t) {
  t.tagID === g.HTML ? Ft(e, t) : Cl(e, t);
}
function Cl(e, t) {
  e.insertionMode = I.IN_BODY, iu(e, t);
}
function r8(e, t) {
  switch (t.tagID) {
    case g.HTML: {
      Ft(e, t);
      break;
    }
    case g.NOFRAMES: {
      tr(e, t);
      break;
    }
  }
}
function o8(e, t) {
  t.chars = at, e._insertCharacters(t);
}
function i8(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function sC(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== j.HTML && e.openElements.currentTagId !== void 0 && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function s8(e, t) {
  if (CO(t))
    sC(e), e._startTagOutsideForeignContent(t);
  else {
    const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n);
    r === j.MATHML ? j2(t) : r === j.SVG && (TO(t), V2(t)), Sp(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0;
  }
}
function a8(e, t) {
  if (t.tagID === g.P || t.tagID === g.BR) {
    sC(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const r = e.openElements.items[n];
    if (e.treeAdapter.getNamespaceURI(r) === j.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const o = e.treeAdapter.getTagName(r);
    if (o.toLowerCase() === t.tagName) {
      t.tagName = o, e.openElements.shortenToLength(n);
      break;
    }
  }
}
O.AREA, O.BASE, O.BASEFONT, O.BGSOUND, O.BR, O.COL, O.EMBED, O.FRAME, O.HR, O.IMG, O.INPUT, O.KEYGEN, O.LINK, O.META, O.PARAM, O.SOURCE, O.TRACK, O.WBR;
function l8(e, t) {
  return q2.parse(e, t);
}
function c8(e, t, n) {
  typeof e == "string" && (n = t, t = e, e = null);
  const r = q2.getFragmentParser(e, n);
  return r.tokenizer.write(t, !0), r.getFragment();
}
function vs(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Ig(e.position) : "start" in e || "end" in e ? Ig(e) : "line" in e || "column" in e ? Ff(e) : "";
}
function Ff(e) {
  return Ng(e && e.line) + ":" + Ng(e && e.column);
}
function Ig(e) {
  return Ff(e && e.start) + "-" + Ff(e && e.end);
}
function Ng(e) {
  return e && typeof e == "number" ? e : 1;
}
class Qt extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let o = "", i = {}, s = !1;
    if (n && ("line" in n && "column" in n ? i = { place: n } : "start" in n && "end" in n ? i = { place: n } : "type" in n ? i = {
      ancestors: [n],
      place: n.position
    } : i = { ...n }), typeof t == "string" ? o = t : !i.cause && t && (s = !0, o = t.message, i.cause = t), !i.ruleId && !i.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? i.ruleId = r : (i.source = r.slice(0, l), i.ruleId = r.slice(l + 1));
    }
    if (!i.place && i.ancestors && i.ancestors) {
      const l = i.ancestors[i.ancestors.length - 1];
      l && (i.place = l.position);
    }
    const a = i.place && "start" in i.place ? i.place.start : i.place;
    this.ancestors = i.ancestors || void 0, this.cause = i.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.file = "", this.message = o, this.line = a ? a.line : void 0, this.name = vs(i.place) || "1:1", this.place = i.place || void 0, this.reason = this.message, this.ruleId = i.ruleId || void 0, this.source = i.source || void 0, this.stack = s && i.cause && typeof i.cause.stack == "string" ? i.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
Qt.prototype.file = "";
Qt.prototype.name = "";
Qt.prototype.reason = "";
Qt.prototype.message = "";
Qt.prototype.stack = "";
Qt.prototype.column = void 0;
Qt.prototype.line = void 0;
Qt.prototype.ancestors = void 0;
Qt.prototype.cause = void 0;
Qt.prototype.fatal = void 0;
Qt.prototype.place = void 0;
Qt.prototype.ruleId = void 0;
Qt.prototype.source = void 0;
const cr = { basename: u8, dirname: d8, extname: f8, join: h8, sep: "/" };
function u8(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  ma(e);
  let n = 0, r = -1, o = e.length, i;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (i) {
          n = o + 1;
          break;
        }
      } else r < 0 && (i = !0, r = o + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, a = t.length - 1;
  for (; o--; )
    if (e.codePointAt(o) === 47) {
      if (i) {
        n = o + 1;
        break;
      }
    } else
      s < 0 && (i = !0, s = o + 1), a > -1 && (e.codePointAt(o) === t.codePointAt(a--) ? a < 0 && (r = o) : (a = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function d8(e) {
  if (ma(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function f8(e) {
  ma(e);
  let t = e.length, n = -1, r = 0, o = -1, i = 0, s;
  for (; t--; ) {
    const a = e.codePointAt(t);
    if (a === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), a === 46 ? o < 0 ? o = t : i !== 1 && (i = 1) : o > -1 && (i = -1);
  }
  return o < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  i === 0 || // The (right-most) trimmed path component is exactly `..`.
  i === 1 && o === n - 1 && o === r + 1 ? "" : e.slice(o, n);
}
function h8(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    ma(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : p8(n);
}
function p8(e) {
  ma(e);
  const t = e.codePointAt(0) === 47;
  let n = m8(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function m8(e, t) {
  let n = "", r = 0, o = -1, i = 0, s = -1, a, l;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      a = e.codePointAt(s);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(o === s - 1 || i === 1)) if (o !== s - 1 && i === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), o = s, i = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, o = s, i = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(o + 1, s) : n = e.slice(o + 1, s), r = s - o - 1;
      o = s, i = 0;
    } else a === 46 && i > -1 ? i++ : i = -1;
  }
  return n;
}
function ma(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const g8 = { cwd: b8 };
function b8() {
  return "/";
}
function Uf(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function y8(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Uf(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return E8(e);
}
function E8(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const o = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
      }
    }
  return decodeURIComponent(t);
}
const dd = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class jf {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Uf(t) ? n = { path: t } : typeof t == "string" || k8(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : g8.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < dd.length; ) {
      const i = dd[r];
      i in n && n[i] !== void 0 && n[i] !== null && (this[i] = i === "history" ? [...n[i]] : n[i]);
    }
    let o;
    for (o in n)
      dd.includes(o) || (this[o] = n[o]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? cr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    hd(t, "basename"), fd(t, "basename"), this.path = cr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? cr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Mg(this.basename, "dirname"), this.path = cr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? cr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (fd(t, "extname"), Mg(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = cr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Uf(t) && (t = y8(t)), hd(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? cr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    hd(t, "stem"), fd(t, "stem"), this.path = cr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const o = this.message(t, n, r);
    throw o.fatal = !0, o;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const o = this.message(t, n, r);
    return o.fatal = void 0, o;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const o = new Qt(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function fd(e, t) {
  if (e && e.includes(cr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + cr.sep + "`"
    );
}
function hd(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Mg(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function k8(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const C8 = {
  /** @type {ErrorInfo} */
  abandonedHeadElementChild: {
    reason: "Unexpected metadata element after head",
    description: "Unexpected element after head. Expected the element before `</head>`",
    url: !1
  },
  /** @type {ErrorInfo} */
  abruptClosingOfEmptyComment: {
    reason: "Unexpected abruptly closed empty comment",
    description: "Unexpected `>` or `->`. Expected `-->` to close comments"
  },
  /** @type {ErrorInfo} */
  abruptDoctypePublicIdentifier: {
    reason: "Unexpected abruptly closed public identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
  },
  /** @type {ErrorInfo} */
  abruptDoctypeSystemIdentifier: {
    reason: "Unexpected abruptly closed system identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
  },
  /** @type {ErrorInfo} */
  absenceOfDigitsInNumericCharacterReference: {
    reason: "Unexpected non-digit at start of numeric character reference",
    description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
  },
  /** @type {ErrorInfo} */
  cdataInHtmlContent: {
    reason: "Unexpected CDATA section in HTML",
    description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
  },
  /** @type {ErrorInfo} */
  characterReferenceOutsideUnicodeRange: {
    reason: "Unexpected too big numeric character reference",
    description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
  },
  /** @type {ErrorInfo} */
  closingOfElementWithOpenChildElements: {
    reason: "Unexpected closing tag with open child elements",
    description: "Unexpectedly closing tag. Expected other tags to be closed first",
    url: !1
  },
  /** @type {ErrorInfo} */
  controlCharacterInInputStream: {
    reason: "Unexpected control character",
    description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  /** @type {ErrorInfo} */
  controlCharacterReference: {
    reason: "Unexpected control character reference",
    description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  /** @type {ErrorInfo} */
  disallowedContentInNoscriptInHead: {
    reason: "Disallowed content inside `<noscript>` in `<head>`",
    description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
    url: !1
  },
  /** @type {ErrorInfo} */
  duplicateAttribute: {
    reason: "Unexpected duplicate attribute",
    description: "Unexpectedly double attribute. Expected attributes to occur only once"
  },
  /** @type {ErrorInfo} */
  endTagWithAttributes: {
    reason: "Unexpected attribute on closing tag",
    description: "Unexpected attribute. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  endTagWithTrailingSolidus: {
    reason: "Unexpected slash at end of closing tag",
    description: "Unexpected `%c-1`. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  endTagWithoutMatchingOpenElement: {
    reason: "Unexpected unopened end tag",
    description: "Unexpected end tag. Expected no end tag or another end tag",
    url: !1
  },
  /** @type {ErrorInfo} */
  eofBeforeTagName: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected tag name instead"
  },
  /** @type {ErrorInfo} */
  eofInCdata: {
    reason: "Unexpected end of file in CDATA",
    description: "Unexpected end of file. Expected `]]>` to close the CDATA"
  },
  /** @type {ErrorInfo} */
  eofInComment: {
    reason: "Unexpected end of file in comment",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  eofInDoctype: {
    reason: "Unexpected end of file in doctype",
    description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
  },
  /** @type {ErrorInfo} */
  eofInElementThatCanContainOnlyText: {
    reason: "Unexpected end of file in element that can only contain text",
    description: "Unexpected end of file. Expected text or a closing tag",
    url: !1
  },
  /** @type {ErrorInfo} */
  eofInScriptHtmlCommentLikeText: {
    reason: "Unexpected end of file in comment inside script",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  eofInTag: {
    reason: "Unexpected end of file in tag",
    description: "Unexpected end of file. Expected `>` to close the tag"
  },
  /** @type {ErrorInfo} */
  incorrectlyClosedComment: {
    reason: "Incorrectly closed comment",
    description: "Unexpected `%c-1`. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  incorrectlyOpenedComment: {
    reason: "Incorrectly opened comment",
    description: "Unexpected `%c`. Expected `<!--` to open the comment"
  },
  /** @type {ErrorInfo} */
  invalidCharacterSequenceAfterDoctypeName: {
    reason: "Invalid sequence after doctype name",
    description: "Unexpected sequence at `%c`. Expected `public` or `system`"
  },
  /** @type {ErrorInfo} */
  invalidFirstCharacterOfTagName: {
    reason: "Invalid first character in tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  misplacedDoctype: {
    reason: "Misplaced doctype",
    description: "Unexpected doctype. Expected doctype before head",
    url: !1
  },
  /** @type {ErrorInfo} */
  misplacedStartTagForHeadElement: {
    reason: "Misplaced `<head>` start tag",
    description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
    url: !1
  },
  /** @type {ErrorInfo} */
  missingAttributeValue: {
    reason: "Missing attribute value",
    description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctype: {
    reason: "Missing doctype before other content",
    description: "Expected a `<!doctype html>` before anything else",
    url: !1
  },
  /** @type {ErrorInfo} */
  missingDoctypeName: {
    reason: "Missing doctype name",
    description: "Unexpected doctype end at `%c`. Expected `html` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctypePublicIdentifier: {
    reason: "Missing public identifier in doctype",
    description: "Unexpected `%c`. Expected identifier for `public` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctypeSystemIdentifier: {
    reason: "Missing system identifier in doctype",
    description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
  },
  /** @type {ErrorInfo} */
  missingEndTagName: {
    reason: "Missing name in end tag",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  missingQuoteBeforeDoctypePublicIdentifier: {
    reason: "Missing quote before public identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  /** @type {ErrorInfo} */
  missingQuoteBeforeDoctypeSystemIdentifier: {
    reason: "Missing quote before system identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  /** @type {ErrorInfo} */
  missingSemicolonAfterCharacterReference: {
    reason: "Missing semicolon after character reference",
    description: "Unexpected `%c`. Expected `;` instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceAfterDoctypePublicKeyword: {
    reason: "Missing whitespace after public identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceAfterDoctypeSystemKeyword: {
    reason: "Missing whitespace after system identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBeforeDoctypeName: {
    reason: "Missing whitespace before doctype name",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBetweenAttributes: {
    reason: "Missing whitespace between attributes",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
    reason: "Missing whitespace between public and system identifiers in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  nestedComment: {
    reason: "Unexpected nested comment",
    description: "Unexpected `<!--`. Expected `-->`"
  },
  /** @type {ErrorInfo} */
  nestedNoscriptInHead: {
    reason: "Unexpected nested `<noscript>` in `<head>`",
    description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
    url: !1
  },
  /** @type {ErrorInfo} */
  nonConformingDoctype: {
    reason: "Unexpected non-conforming doctype declaration",
    description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
    url: !1
  },
  /** @type {ErrorInfo} */
  nonVoidHtmlElementStartTagWithTrailingSolidus: {
    reason: "Unexpected trailing slash on start tag of non-void element",
    description: "Unexpected `/`. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  noncharacterCharacterReference: {
    reason: "Unexpected noncharacter code point referenced by character reference",
    description: "Unexpected code point. Do not use noncharacters in HTML"
  },
  /** @type {ErrorInfo} */
  noncharacterInInputStream: {
    reason: "Unexpected noncharacter character",
    description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
  },
  /** @type {ErrorInfo} */
  nullCharacterReference: {
    reason: "Unexpected NULL character referenced by character reference",
    description: "Unexpected code point. Do not use NULL characters in HTML"
  },
  /** @type {ErrorInfo} */
  openElementsLeftAfterEof: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected closing tag instead",
    url: !1
  },
  /** @type {ErrorInfo} */
  surrogateCharacterReference: {
    reason: "Unexpected surrogate character referenced by character reference",
    description: "Unexpected code point. Do not use lone surrogate characters in HTML"
  },
  /** @type {ErrorInfo} */
  surrogateInInputStream: {
    reason: "Unexpected surrogate character",
    description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterAfterDoctypeSystemIdentifier: {
    reason: "Invalid character after system identifier in doctype",
    description: "Unexpected character at `%c`. Expected `>`"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterInAttributeName: {
    reason: "Unexpected character in attribute name",
    description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterInUnquotedAttributeValue: {
    reason: "Unexpected character in unquoted attribute value",
    description: "Unexpected `%c`. Quote the attribute value to include it"
  },
  /** @type {ErrorInfo} */
  unexpectedEqualsSignBeforeAttributeName: {
    reason: "Unexpected equals sign before attribute name",
    description: "Unexpected `%c`. Add an attribute name before it"
  },
  /** @type {ErrorInfo} */
  unexpectedNullCharacter: {
    reason: "Unexpected NULL character",
    description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
  },
  /** @type {ErrorInfo} */
  unexpectedQuestionMarkInsteadOfTagName: {
    reason: "Unexpected question mark instead of tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  unexpectedSolidusInTag: {
    reason: "Unexpected slash in tag",
    description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
  },
  /** @type {ErrorInfo} */
  unknownNamedCharacterReference: {
    reason: "Unexpected unknown named character reference",
    description: "Unexpected character reference. Expected known named character references"
  }
}, T8 = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-", x8 = /-[a-z]/g, w8 = /%c(?:([-+])(\d+))?/g, v8 = /%x/g, S8 = { 2: !0, 1: !1, 0: null }, _8 = {};
function A8(e, t) {
  const n = t || _8, r = n.onerror, o = e instanceof jf ? e : new jf(e), i = n.fragment ? c8 : l8, s = String(o), a = i(s, {
    sourceCodeLocationInfo: !0,
    // Note `parse5` types currently do not allow `undefined`.
    onParseError: n.onerror ? l : null,
    scriptingEnabled: !1
  });
  return (
    /** @type {Root} */
    ML(a, {
      file: o,
      space: n.space,
      verbose: n.verbose
    })
  );
  function l(c) {
    const u = c.code, d = I8(u), f = n[d], h = f ?? !0, p = typeof h == "number" ? h : h ? 1 : 0;
    if (p) {
      const b = C8[d], y = new Qt(m(b.reason), {
        place: {
          start: {
            line: c.startLine,
            column: c.startCol,
            offset: c.startOffset
          },
          end: {
            line: c.endLine,
            column: c.endCol,
            offset: c.endOffset
          }
        },
        ruleId: u,
        source: "hast-util-from-html"
      });
      o.path && (y.file = o.path, y.name = o.path + ":" + y.name), y.fatal = S8[p], y.note = m(b.description), y.url = b.url === !1 ? void 0 : T8 + u, r(y);
    }
    function m(b) {
      return b.replace(w8, y).replace(v8, k);
      function y(C, _, w) {
        const T = (w ? Number.parseInt(w, 10) : 0) * (_ === "-" ? -1 : 1), M = s.charAt(c.startOffset + T);
        return M8(M);
      }
      function k() {
        return L8(s.charCodeAt(c.startOffset));
      }
    }
  }
}
function I8(e) {
  return (
    /** @type {ErrorCode} */
    e.replace(x8, N8)
  );
}
function N8(e) {
  return e.charAt(1).toUpperCase();
}
function M8(e) {
  return e === "`" ? "` ` `" : e;
}
function L8(e) {
  return "0x" + e.toString(16).toUpperCase();
}
function O8(e) {
  const t = this, { emitParseErrors: n, ...r } = { ...t.data("settings"), ...e };
  t.parser = o;
  function o(i, s) {
    return A8(i, {
      ...r,
      onerror: n ? function(a) {
        s.path && (a.name = s.path + ":" + a.name, a.file = s.path), s.messages.push(a);
      } : void 0
    });
  }
}
const aC = -1, cu = 0, Ss = 1, rc = 2, Np = 3, Mp = 4, Lp = 5, Op = 6, lC = 7, cC = 8, Lg = typeof self == "object" ? self : globalThis, D8 = (e, t) => {
  const n = (o, i) => (e.set(i, o), o), r = (o) => {
    if (e.has(o))
      return e.get(o);
    const [i, s] = t[o];
    switch (i) {
      case cu:
      case aC:
        return n(s, o);
      case Ss: {
        const a = n([], o);
        for (const l of s)
          a.push(r(l));
        return a;
      }
      case rc: {
        const a = n({}, o);
        for (const [l, c] of s)
          a[r(l)] = r(c);
        return a;
      }
      case Np:
        return n(new Date(s), o);
      case Mp: {
        const { source: a, flags: l } = s;
        return n(new RegExp(a, l), o);
      }
      case Lp: {
        const a = n(/* @__PURE__ */ new Map(), o);
        for (const [l, c] of s)
          a.set(r(l), r(c));
        return a;
      }
      case Op: {
        const a = n(/* @__PURE__ */ new Set(), o);
        for (const l of s)
          a.add(r(l));
        return a;
      }
      case lC: {
        const { name: a, message: l } = s;
        return n(new Lg[a](l), o);
      }
      case cC:
        return n(BigInt(s), o);
      case "BigInt":
        return n(Object(BigInt(s)), o);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: a } = new Uint8Array(s);
        return n(new DataView(a), s);
      }
    }
    return n(new Lg[i](s), o);
  };
  return r;
}, Og = (e) => D8(/* @__PURE__ */ new Map(), e)(0), oi = "", { toString: R8 } = {}, { keys: P8 } = Object, as = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [cu, t];
  const n = R8.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Ss, oi];
    case "Object":
      return [rc, oi];
    case "Date":
      return [Np, oi];
    case "RegExp":
      return [Mp, oi];
    case "Map":
      return [Lp, oi];
    case "Set":
      return [Op, oi];
    case "DataView":
      return [Ss, n];
  }
  return n.includes("Array") ? [Ss, n] : n.includes("Error") ? [lC, n] : [rc, n];
}, qa = ([e, t]) => e === cu && (t === "function" || t === "symbol"), B8 = (e, t, n, r) => {
  const o = (s, a) => {
    const l = r.push(s) - 1;
    return n.set(a, l), l;
  }, i = (s) => {
    if (n.has(s))
      return n.get(s);
    let [a, l] = as(s);
    switch (a) {
      case cu: {
        let u = s;
        switch (l) {
          case "bigint":
            a = cC, u = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            u = null;
            break;
          case "undefined":
            return o([aC], s);
        }
        return o([a, u], s);
      }
      case Ss: {
        if (l) {
          let f = s;
          return l === "DataView" ? f = new Uint8Array(s.buffer) : l === "ArrayBuffer" && (f = new Uint8Array(s)), o([l, [...f]], s);
        }
        const u = [], d = o([a, u], s);
        for (const f of s)
          u.push(i(f));
        return d;
      }
      case rc: {
        if (l)
          switch (l) {
            case "BigInt":
              return o([l, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return o([l, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return i(s.toJSON());
        const u = [], d = o([a, u], s);
        for (const f of P8(s))
          (e || !qa(as(s[f]))) && u.push([i(f), i(s[f])]);
        return d;
      }
      case Np:
        return o([a, s.toISOString()], s);
      case Mp: {
        const { source: u, flags: d } = s;
        return o([a, { source: u, flags: d }], s);
      }
      case Lp: {
        const u = [], d = o([a, u], s);
        for (const [f, h] of s)
          (e || !(qa(as(f)) || qa(as(h)))) && u.push([i(f), i(h)]);
        return d;
      }
      case Op: {
        const u = [], d = o([a, u], s);
        for (const f of s)
          (e || !qa(as(f))) && u.push(i(f));
        return d;
      }
    }
    const { message: c } = s;
    return o([a, { name: l, message: c }], s);
  };
  return i;
}, Dg = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return B8(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Ri = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? Og(Dg(e, t)) : structuredClone(e)
) : (e, t) => Og(Dg(e, t)), Dp = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((element?: null | undefined) => false) &
   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [element]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parents | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  function(e, t, n, r, o) {
    const i = nr(t);
    return uC(e) ? i.call(o, e, n, r) : !1;
  }
), nr = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return F8;
    if (typeof e == "string")
      return H8(e);
    if (typeof e == "object")
      return $8(e);
    if (typeof e == "function")
      return Rp(e);
    throw new Error("Expected function, string, or array as `test`");
  }
);
function $8(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = nr(e[n]);
  return Rp(r);
  function r(...o) {
    let i = -1;
    for (; ++i < t.length; )
      if (t[i].apply(this, o)) return !0;
    return !1;
  }
}
function H8(e) {
  return Rp(t);
  function t(n) {
    return n.tagName === e;
  }
}
function Rp(e) {
  return t;
  function t(n, r, o) {
    return !!(uC(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      o || void 0
    ));
  }
}
function F8(e) {
  return !!(e && typeof e == "object" && "type" in e && e.type === "element" && "tagName" in e && typeof e.tagName == "string");
}
function uC(e) {
  return e !== null && typeof e == "object" && "type" in e && "tagName" in e;
}
const dC = nr(
  /**
   * @param element
   * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}
   */
  function(e) {
    return e.tagName === "audio" || e.tagName === "canvas" || e.tagName === "embed" || e.tagName === "iframe" || e.tagName === "img" || e.tagName === "math" || e.tagName === "object" || e.tagName === "picture" || e.tagName === "svg" || e.tagName === "video";
  }
), U8 = /[ \t\n\f\r]/g;
function ga(e) {
  return typeof e == "object" ? e.type === "text" ? Rg(e.value) : !1 : Rg(e);
}
function Rg(e) {
  return e.replace(U8, "") === "";
}
const Yi = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return q8;
    if (typeof e == "function")
      return uu(e);
    if (typeof e == "object")
      return Array.isArray(e) ? j8(e) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        V8(
          /** @type {Props} */
          e
        )
      );
    if (typeof e == "string")
      return z8(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function j8(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Yi(e[n]);
  return uu(r);
  function r(...o) {
    let i = -1;
    for (; ++i < t.length; )
      if (t[i].apply(this, o)) return !0;
    return !1;
  }
}
function V8(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return uu(n);
  function n(r) {
    const o = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let i;
    for (i in e)
      if (o[i] !== t[i]) return !1;
    return !0;
  }
}
function z8(e) {
  return uu(t);
  function t(n) {
    return n && n.type === e;
  }
}
function uu(e) {
  return t;
  function t(n, r, o) {
    return !!(W8(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      o || void 0
    ));
  }
}
function q8() {
  return !0;
}
function W8(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const G8 = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
], Y8 = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
], K8 = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
], Q8 = {}, Pp = Yi(["comment", "doctype"]);
function Z8(e, t) {
  fC(e, {
    collapse: oD(
      (t || Q8).newlines ? nD : rD
    ),
    whitespace: "normal"
  });
}
function fC(e, t) {
  if ("children" in e) {
    const n = { ...t };
    return (e.type === "root" || mC(e)) && (n.before = !0, n.after = !0), n.whitespace = iD(e, t), J8(e, n);
  }
  if (e.type === "text") {
    if (t.whitespace === "normal")
      return X8(e, t);
    t.whitespace === "nowrap" && (e.value = t.collapse(e.value));
  }
  return { ignore: Pp(e), stripAtStart: !1, remove: !1 };
}
function X8(e, t) {
  const n = t.collapse(e.value), r = { ignore: !1, stripAtStart: !1, remove: !1 };
  let o = 0, i = n.length;
  return t.before && Pg(n.charAt(0)) && o++, o !== i && Pg(n.charAt(i - 1)) && (t.after ? i-- : r.stripAtStart = !0), o === i ? r.remove = !0 : e.value = n.slice(o, i), r;
}
function J8(e, t) {
  let n = t.before;
  const r = t.after, o = e.children;
  let i = o.length, s = -1;
  for (; ++s < i; ) {
    const a = fC(o[s], {
      ...t,
      after: hC(o, s, r),
      before: n
    });
    a.remove ? (o.splice(s, 1), s--, i--) : a.ignore || (n = a.stripAtStart), pC(o[s]) && (n = !1);
  }
  return { ignore: !1, stripAtStart: !!(n || r), remove: !1 };
}
function hC(e, t, n) {
  for (; ++t < e.length; ) {
    const r = e[t];
    let o = eD(r);
    if (o === void 0 && "children" in r && !tD(r) && (o = hC(r.children, -1)), typeof o == "boolean")
      return o;
  }
  return n;
}
function eD(e) {
  if (e.type === "element") {
    if (pC(e))
      return !1;
    if (mC(e))
      return !0;
  } else if (e.type === "text") {
    if (!ga(e))
      return !1;
  } else if (!Pp(e))
    return !1;
}
function pC(e) {
  return dC(e) || Dp(e, Y8);
}
function mC(e) {
  return Dp(e, G8);
}
function tD(e) {
  return !!(e.type === "element" && e.properties.hidden) || Pp(e) || Dp(e, K8);
}
function Pg(e) {
  return e === " " || e === `
`;
}
function nD(e) {
  const t = /\r?\n|\r/.exec(e);
  return t ? t[0] : " ";
}
function rD() {
  return " ";
}
function oD(e) {
  return t;
  function t(n) {
    return String(n).replace(/[\t\n\v\f\r ]+/g, e);
  }
}
function iD(e, t) {
  if ("tagName" in e && e.properties)
    switch (e.tagName) {
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return e.properties.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return e.properties.noWrap ? "nowrap" : t.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  return t.whitespace;
}
function sD(e) {
  return function(t) {
    Z8(t, e);
  };
}
const gC = [], aD = !0, oc = !1, bC = "skip";
function yC(e, t, n, r) {
  let o;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : o = t;
  const i = Yi(o), s = r ? -1 : 1;
  a(e, void 0, [])();
  function a(l, c, u) {
    const d = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof d.type == "string") {
      const h = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + (l.type + (h ? "<" + h + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let h = gC, p, m, b;
      if ((!t || i(l, c, u[u.length - 1] || void 0)) && (h = lD(n(l, u)), h[0] === oc))
        return h;
      if ("children" in l && l.children) {
        const y = (
          /** @type {UnistParent} */
          l
        );
        if (y.children && h[0] !== bC)
          for (m = (r ? y.children.length : -1) + s, b = u.concat(y); m > -1 && m < y.children.length; ) {
            const k = y.children[m];
            if (p = a(k, m, b)(), p[0] === oc)
              return p;
            m = typeof p[1] == "number" ? p[1] : m + s;
          }
      }
      return h;
    }
  }
}
function lD(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [aD, e] : e == null ? gC : [e];
}
function Go(e, t, n, r) {
  let o, i, s;
  typeof t == "function" && typeof n != "function" ? (i = void 0, s = t, o = n) : (i = t, s = n, o = r), yC(e, i, a, o);
  function a(l, c) {
    const u = c[c.length - 1], d = u ? u.children.indexOf(l) : void 0;
    return s(l, d, u);
  }
}
const EC = CC("end"), kC = CC("start");
function CC(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function TC(e) {
  const t = kC(e), n = EC(e);
  if (t && n)
    return { start: t, end: n };
}
function cD(e, t) {
  const n = t.properties || {}, r = (
    /** @type {Array<PhrasingContent>} */
    e.all(t)
  ), o = {
    type: "link",
    url: e.resolve(String(n.href || "") || null),
    title: n.title ? String(n.title) : null,
    children: r
  };
  return e.patch(t, o), o;
}
function uD(e, t) {
  e.baseFound || (e.frozenBaseUrl = String(t.properties && t.properties.href || "") || void 0, e.baseFound = !0);
}
function dD(e, t) {
  const n = { type: "blockquote", children: e.toFlow(e.all(t)) };
  return e.patch(t, n), n;
}
function fD(e, t) {
  const n = { type: "break" };
  return e.patch(t, n), n;
}
const Bg = (
  // Note: overloads like this are needed to support optional generics.
  /**
   * @type {(
   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
   * )}
   */
  /**
   * @param {UnistParent} parent
   * @param {UnistNode | number} index
   * @param {Test} [test]
   * @returns {UnistNode | undefined}
   */
  function(e, t, n) {
    const r = Yi(n);
    if (!e || !e.type || !e.children)
      throw new Error("Expected parent node");
    if (typeof t == "number") {
      if (t < 0 || t === Number.POSITIVE_INFINITY)
        throw new Error("Expected positive finite number as index");
    } else if (t = e.children.indexOf(t), t < 0)
      throw new Error("Expected child node or index");
    for (; ++t < e.children.length; )
      if (r(e.children[t], t, e))
        return e.children[t];
  }
), $g = /\n/g, Hg = /[\t ]+/g, Vf = nr("br"), Fg = nr(ED), hD = nr("p"), Ug = nr("tr"), pD = nr([
  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  yD,
  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
  kD
]), xC = nr([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "li",
  // Lists (as `display: list-item`)
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function ba(e, t) {
  const n = {}, r = "children" in e ? e.children : [], o = xC(e), i = SC(e, {
    whitespace: n.whitespace || "normal",
    breakBefore: !1,
    breakAfter: !1
  }), s = [];
  (e.type === "text" || e.type === "comment") && s.push(
    ...vC(e, {
      whitespace: i,
      breakBefore: !0,
      breakAfter: !0
    })
  );
  let a = -1;
  for (; ++a < r.length; )
    s.push(
      ...wC(
        r[a],
        // @ts-expect-error: `tree` is a parent if were here.
        e,
        {
          whitespace: i,
          breakBefore: a ? void 0 : o,
          breakAfter: a < r.length - 1 ? Vf(r[a + 1]) : o
        }
      )
    );
  const l = [];
  let c;
  for (a = -1; ++a < s.length; ) {
    const u = s[a];
    typeof u == "number" ? c !== void 0 && u > c && (c = u) : u && (c !== void 0 && c > -1 && l.push(`
`.repeat(c) || " "), c = -1, l.push(u));
  }
  return l.join("");
}
function wC(e, t, n) {
  return e.type === "element" ? mD(e, t, n) : e.type === "text" ? n.whitespace === "normal" ? vC(e, n) : gD(e) : [];
}
function mD(e, t, n) {
  const r = SC(e, n), o = e.children || [];
  let i = -1, s = [];
  if (pD(e))
    return s;
  let a, l;
  for (Vf(e) || Ug(e) && // @ts-expect-error: something up with types of parents.
  Bg(t, e, Ug) ? l = `
` : hD(e) ? (a = 2, l = 2) : xC(e) && (a = 1, l = 1); ++i < o.length; )
    s = s.concat(
      wC(o[i], e, {
        whitespace: r,
        breakBefore: i ? void 0 : a,
        breakAfter: i < o.length - 1 ? Vf(o[i + 1]) : l
      })
    );
  return Fg(e) && // @ts-expect-error: something up with types of parents.
  Bg(t, e, Fg) && s.push("	"), a && s.unshift(a), l && s.push(l), s;
}
function vC(e, t) {
  const n = String(e.value), r = [], o = [];
  let i = 0;
  for (; i <= n.length; ) {
    $g.lastIndex = i;
    const l = $g.exec(n), c = l && "index" in l ? l.index : n.length;
    r.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      bD(
        // [] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        n.slice(i, c).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        i === 0 ? t.breakBefore : !0,
        c === n.length ? t.breakAfter : !0
      )
    ), i = c + 1;
  }
  let s = -1, a;
  for (; ++s < r.length; )
    r[s].charCodeAt(r[s].length - 1) === 8203 || s < r.length - 1 && r[s + 1].charCodeAt(0) === 8203 ? (o.push(r[s]), a = void 0) : r[s] ? (typeof a == "number" && o.push(a), o.push(r[s]), a = 0) : (s === 0 || s === r.length - 1) && o.push(0);
  return o;
}
function gD(e) {
  return [String(e.value)];
}
function bD(e, t, n) {
  const r = [];
  let o = 0, i;
  for (; o < e.length; ) {
    Hg.lastIndex = o;
    const s = Hg.exec(e);
    i = s ? s.index : e.length, !o && !i && s && !t && r.push(""), o !== i && r.push(e.slice(o, i)), o = s ? i + s[0].length : i;
  }
  return o !== i && !n && r.push(""), r.join(" ");
}
function SC(e, t) {
  if (e.type === "element") {
    const n = e.properties || {};
    switch (e.tagName) {
      case "listing":
      case "plaintext":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return n.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return n.noWrap ? "nowrap" : t.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  }
  return t.whitespace;
}
function yD(e) {
  return !!(e.properties || {}).hidden;
}
function ED(e) {
  return e.tagName === "td" || e.tagName === "th";
}
function kD(e) {
  return e.tagName === "dialog" && !(e.properties || {}).open;
}
function CD(e) {
  const t = String(e);
  let n = t.length;
  for (; n > 0; ) {
    const r = t.codePointAt(n - 1);
    if (r !== void 0 && (r === 10 || r === 13))
      n--;
    else
      break;
  }
  return t.slice(0, n);
}
const pd = "language-";
function Wa(e, t) {
  const n = t.children;
  let r = -1, o, i;
  if (t.tagName === "pre")
    for (; ++r < n.length; ) {
      const a = n[r];
      if (a.type === "element" && a.tagName === "code" && a.properties && a.properties.className && Array.isArray(a.properties.className)) {
        o = a.properties.className;
        break;
      }
    }
  if (o) {
    for (r = -1; ++r < o.length; )
      if (String(o[r]).slice(0, pd.length) === pd) {
        i = String(o[r]).slice(pd.length);
        break;
      }
  }
  const s = {
    type: "code",
    lang: i || null,
    meta: null,
    value: CD(ba(t))
  };
  return e.patch(t, s), s;
}
function TD(e, t) {
  const n = {
    type: "html",
    value: "<!--" + t.value + "-->"
  };
  return e.patch(t, n), n;
}
function md(e, t) {
  const r = { type: "delete", children: (
    /** @type {Array<PhrasingContent>} */
    e.all(t)
  ) };
  return e.patch(t, r), r;
}
function Bp(e) {
  let t = -1;
  if (e.length > 1) {
    for (; ++t < e.length; )
      if (e[t].spread)
        return !0;
  }
  return !1;
}
function xD(e, t) {
  const n = [], r = [];
  let o = -1;
  for (; ++o < t.children.length; ) {
    const a = t.children[o];
    a.type === "element" && a.tagName === "div" ? n.push(...a.children) : n.push(a);
  }
  let i = { definitions: [], titles: [] };
  for (o = -1; ++o < n.length; ) {
    const a = n[o];
    if (a.type === "element" && a.tagName === "dt") {
      const l = n[o - 1];
      l && l.type === "element" && l.tagName === "dd" && (r.push(i), i = { definitions: [], titles: [] }), i.titles.push(a);
    } else
      i.definitions.push(a);
  }
  r.push(i), o = -1;
  const s = [];
  for (; ++o < r.length; ) {
    const a = [
      ...jg(e, r[o].titles),
      ...jg(e, r[o].definitions)
    ];
    a.length > 0 && s.push({
      type: "listItem",
      spread: a.length > 1,
      checked: null,
      children: a
    });
  }
  if (s.length > 0) {
    const a = {
      type: "list",
      ordered: !1,
      start: null,
      spread: Bp(s),
      children: s
    };
    return e.patch(t, a), a;
  }
}
function jg(e, t) {
  const n = e.all({ type: "root", children: t }), r = e.toSpecificContent(n, wD);
  return r.length === 0 ? [] : r.length === 1 ? r[0].children : [
    {
      type: "list",
      ordered: !1,
      start: null,
      spread: Bp(r),
      children: r
    }
  ];
}
function wD() {
  return { type: "listItem", spread: !1, checked: null, children: [] };
}
function Ga(e, t) {
  const r = { type: "emphasis", children: (
    /** @type {Array<PhrasingContent>} */
    e.all(t)
  ) };
  return e.patch(t, r), r;
}
function $p(e) {
  let t = 0, n = e.length;
  for (; t < n && e[t].type === "break"; ) t++;
  for (; n > t && e[n - 1].type === "break"; ) n--;
  return t === 0 && n === e.length ? e : e.slice(t, n);
}
function ii(e, t) {
  const n = (
    /** @type {Heading['depth']} */
    /* c8 ignore next */
    Number(t.tagName.charAt(1)) || 1
  ), r = $p(
    /** @type {Array<PhrasingContent>} */
    e.all(t)
  ), o = { type: "heading", depth: n, children: r };
  return e.patch(t, o), o;
}
function vD(e, t) {
  const n = { type: "thematicBreak" };
  return e.patch(t, n), n;
}
function SD(e, t) {
  const n = t.properties || {}, r = String(n.src || ""), o = String(n.title || "");
  if (r && o) {
    const i = {
      type: "link",
      title: null,
      url: e.resolve(r),
      children: [{ type: "text", value: o }]
    };
    return e.patch(t, i), i;
  }
}
function Vg(e, t) {
  const n = t.properties || {}, r = {
    type: "image",
    url: e.resolve(String(n.src || "") || null),
    title: n.title ? String(n.title) : null,
    alt: n.alt ? String(n.alt) : ""
  };
  return e.patch(t, r), r;
}
function ls(e, t) {
  const n = { type: "inlineCode", value: ba(t) };
  return e.patch(t, n), n;
}
function _C(e, t) {
  const n = [], r = [], o = t || e.properties || {}, i = AC(e), s = Math.min(Number.parseInt(String(o.size), 10), 0) || (o.multiple ? 4 : 1);
  let a = -1;
  for (; ++a < i.length; ) {
    const u = i[a];
    u && u.properties && u.properties.selected && n.push(u);
  }
  const l = n.length > 0 ? n : i, c = Math.min(l.length, s);
  for (a = -1; ++a < c; ) {
    const u = l[a], d = u.properties || {}, f = ba(u), h = f || String(d.label || ""), p = String(d.value || "") || f;
    r.push([p, h === p ? void 0 : h]);
  }
  return r;
}
function AC(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.children.length; ) {
    const r = e.children[n];
    "children" in r && Array.isArray(r.children) && t.push(...AC(r)), r.type === "element" && r.tagName === "option" && (!r.properties || !r.properties.disabled) && t.push(r);
  }
  return t;
}
const _D = "[x]", AD = "[ ]";
function ID(e, t) {
  const n = t.properties || {}, r = String(n.value || n.placeholder || "");
  if (n.disabled || n.type === "hidden" || n.type === "file")
    return;
  if (n.type === "checkbox" || n.type === "radio") {
    const l = {
      type: "text",
      value: n.checked ? e.options.checked || _D : e.options.unchecked || AD
    };
    return e.patch(t, l), l;
  }
  if (n.type === "image") {
    const l = n.alt || r;
    if (l) {
      const c = {
        type: "image",
        url: e.resolve(String(n.src || "") || null),
        title: String(n.title || "") || null,
        alt: String(l)
      };
      return e.patch(t, c), c;
    }
    return;
  }
  let o = [];
  if (r)
    o = [[r, void 0]];
  else if (
    // `list` is not supported on these types:
    n.type !== "button" && n.type !== "file" && n.type !== "password" && n.type !== "reset" && n.type !== "submit" && n.list
  ) {
    const l = String(n.list), c = e.elementById.get(l);
    c && c.tagName === "datalist" && (o = _C(c, n));
  }
  if (o.length === 0)
    return;
  if (n.type === "password" && (o[0] = ["".repeat(o[0][0].length), void 0]), n.type === "email" || n.type === "url") {
    const l = [];
    let c = -1;
    for (; ++c < o.length; ) {
      const u = e.resolve(o[c][0]), d = {
        type: "link",
        title: null,
        url: n.type === "email" ? "mailto:" + u : u,
        children: [{ type: "text", value: o[c][1] || u }]
      };
      l.push(d), c !== o.length - 1 && l.push({ type: "text", value: ", " });
    }
    return l;
  }
  const i = [];
  let s = -1;
  for (; ++s < o.length; )
    i.push(
      o[s][1] ? o[s][1] + " (" + o[s][0] + ")" : o[s][0]
    );
  const a = { type: "text", value: i.join(", ") };
  return e.patch(t, a), a;
}
const ND = {}.hasOwnProperty;
function MD(e, t) {
  const n = e.type === "element" && ND.call(e.properties, t) && e.properties[t];
  return n != null && n !== !1;
}
const LD = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
function OD(e) {
  if (e.type !== "element" || e.tagName !== "link")
    return !1;
  if (e.properties.itemProp)
    return !0;
  const t = e.properties.rel;
  let n = -1;
  if (!Array.isArray(t) || t.length === 0)
    return !1;
  for (; ++n < t.length; )
    if (!LD.has(String(t[n])))
      return !1;
  return !0;
}
const DD = nr([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and its
  // a rather involved check, its ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]), RD = nr("meta");
function IC(e) {
  return !!(e.type === "text" || DD(e) || dC(e) || OD(e) || RD(e) && MD(e, "itemProp"));
}
function gd(e, t) {
  const { rest: n, checkbox: r } = MC(t), o = r ? !!r.properties.checked : null, i = NC(n), s = e.toFlow(e.all(n)), a = { type: "listItem", spread: i, checked: o, children: s };
  return e.patch(t, a), a;
}
function NC(e) {
  let t = -1, n = !1;
  for (; ++t < e.children.length; ) {
    const r = e.children[t];
    if (r.type === "element") {
      if (IC(r)) continue;
      if (r.tagName === "p" || n || NC(r))
        return !0;
      n = !0;
    }
  }
  return !1;
}
function MC(e) {
  const t = e.children[0];
  if (t && t.type === "element" && t.tagName === "input" && t.properties && (t.properties.type === "checkbox" || t.properties.type === "radio")) {
    const n = { ...e, children: e.children.slice(1) };
    return { checkbox: t, rest: n };
  }
  if (t && t.type === "element" && t.tagName === "p") {
    const { checkbox: n, rest: r } = MC(t);
    if (n) {
      const o = { ...e, children: [r, ...e.children.slice(1)] };
      return { checkbox: n, rest: o };
    }
  }
  return { checkbox: void 0, rest: e };
}
function bd(e, t) {
  const n = t.tagName === "ol", r = e.toSpecificContent(e.all(t), PD);
  let o = null;
  n && (o = t.properties && t.properties.start ? Number.parseInt(String(t.properties.start), 10) : 1);
  const i = {
    type: "list",
    ordered: n,
    start: o,
    spread: Bp(r),
    children: r
  };
  return e.patch(t, i), i;
}
function PD() {
  return { type: "listItem", spread: !1, checked: null, children: [] };
}
const BD = {};
function du(e, t) {
  const n = BD, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, o = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return LC(e, r, o);
}
function LC(e, t, n) {
  if ($D(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return zg(e.children, t, n);
  }
  return Array.isArray(e) ? zg(e, t, n) : "";
}
function zg(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; )
    r[o] = LC(e[o], t, n);
  return r.join("");
}
function $D(e) {
  return !!(e && typeof e == "object");
}
const OC = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Yi([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function fu(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t];
    if (!PC(n) || "children" in n && fu(n.children))
      return !0;
  }
  return !1;
}
function DC(e) {
  return RC(e, t, function(n) {
    return n;
  });
  function t(n) {
    return n.every(function(r) {
      return r.type === "text" ? ga(r.value) : !1;
    }) ? [] : [{ type: "paragraph", children: $p(n) }];
  }
}
function HD(e) {
  return RC(e.children, t, n);
  function t(r) {
    const o = yd(e);
    return o.children = r, [o];
  }
  function n(r) {
    if ("children" in r && "children" in e) {
      const o = yd(e), i = yd(r);
      return o.children = r.children, i.children.push(o), i;
    }
    return { ...r };
  }
}
function RC(e, t, n) {
  const r = FD(e), o = [];
  let i = [], s = -1;
  for (; ++s < r.length; ) {
    const a = r[s];
    PC(a) ? i.push(a) : (i.length > 0 && (o.push(...t(i)), i = []), o.push(n(a)));
  }
  return i.length > 0 && (o.push(...t(i)), i = []), o;
}
function FD(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; ) {
    const r = e[n];
    (r.type === "delete" || r.type === "link") && fu(r.children) ? t.push(...HD(r)) : t.push(r);
  }
  return t;
}
function PC(e) {
  const t = e.data && e.data.hName;
  return t ? IC({ type: "element", tagName: t, properties: {}, children: [] }) : OC(e);
}
function yd(e) {
  return Ri({ ...e, children: [] });
}
function qg(e, t) {
  const n = t.properties || {}, r = t.tagName === "video" ? String(n.poster || "") : "";
  let o = String(n.src || ""), i = -1, s = !1, a = e.all(t);
  if (Go({ type: "root", children: a }, function(d) {
    if (d.type === "link")
      return s = !0, oc;
  }), s || fu(a))
    return a;
  for (; !o && ++i < t.children.length; ) {
    const d = t.children[i];
    d.type === "element" && d.tagName === "source" && d.properties && (o = String(d.properties.src || ""));
  }
  if (r) {
    const d = {
      type: "image",
      title: null,
      url: e.resolve(r),
      alt: du(a)
    };
    e.patch(t, d), a = [d];
  }
  const c = (
    /** @type {Array<PhrasingContent>} */
    a
  ), u = {
    type: "link",
    title: n.title ? String(n.title) : null,
    url: e.resolve(o),
    children: c
  };
  return e.patch(t, u), u;
}
function Wg(e, t) {
  const n = $p(
    // Allow potentially invalid nodes, they might be unknown.
    // We also support straddling later.
    /** @type {Array<PhrasingContent>} */
    e.all(t)
  );
  if (n.length > 0) {
    const r = { type: "paragraph", children: n };
    return e.patch(t, r), r;
  }
}
const UD = ['"'];
function jD(e, t) {
  const n = e.options.quotes || UD;
  e.qNesting++;
  const r = e.all(t);
  e.qNesting--;
  const o = n[e.qNesting % n.length], i = r[0], s = r[r.length - 1], a = o.charAt(0), l = o.length > 1 ? o.charAt(1) : o;
  return i && i.type === "text" ? i.value = a + i.value : r.unshift({ type: "text", value: a }), s && s.type === "text" ? s.value += l : r.push({ type: "text", value: l }), r;
}
function VD(e, t) {
  let n = e.all(t);
  (e.options.document || fu(n)) && (n = DC(n));
  const r = { type: "root", children: n };
  return e.patch(t, r), r;
}
function zD(e, t) {
  const n = _C(t);
  let r = -1;
  const o = [];
  for (; ++r < n.length; ) {
    const i = n[r];
    o.push(i[1] ? i[1] + " (" + i[0] + ")" : i[0]);
  }
  if (o.length > 0) {
    const i = { type: "text", value: o.join(", ") };
    return e.patch(t, i), i;
  }
}
function Gg(e, t) {
  const r = { type: "strong", children: (
    /** @type {Array<PhrasingContent>} */
    e.all(t)
  ) };
  return e.patch(t, r), r;
}
function Yg(e, t) {
  const r = { type: "tableCell", children: (
    /** @type {Array<PhrasingContent>} */
    e.all(t)
  ) };
  if (e.patch(t, r), t.properties) {
    const o = t.properties.rowSpan, i = t.properties.colSpan;
    if (o || i) {
      const s = (
        /** @type {Record<string, unknown>} */
        r.data || (r.data = {})
      );
      o && (s.hastUtilToMdastTemporaryRowSpan = o), i && (s.hastUtilToMdastTemporaryColSpan = i);
    }
  }
  return r;
}
function qD(e, t) {
  const r = { type: "tableRow", children: e.toSpecificContent(e.all(t), WD) };
  return e.patch(t, r), r;
}
function WD() {
  return { type: "tableCell", children: [] };
}
function GD(e, t) {
  if (e.inTable) {
    const c = { type: "text", value: ba(t) };
    return e.patch(t, c), c;
  }
  e.inTable = !0;
  const { align: n, headless: r } = YD(t), o = e.toSpecificContent(e.all(t), Kg);
  r && o.unshift(Kg());
  let i = -1;
  for (; ++i < o.length; ) {
    const c = o[i], u = e.toSpecificContent(c.children, KD);
    c.children = u;
  }
  let s = 1;
  for (i = -1; ++i < o.length; ) {
    const c = o[i].children;
    let u = -1;
    for (; ++u < c.length; ) {
      const d = c[u];
      if (d.data) {
        const f = (
          /** @type {Record<string, unknown>} */
          d.data
        ), h = Number.parseInt(String(f.hastUtilToMdastTemporaryColSpan), 10) || 1, p = Number.parseInt(String(f.hastUtilToMdastTemporaryRowSpan), 10) || 1;
        if (h > 1 || p > 1) {
          let m = i - 1;
          for (; ++m < i + p; ) {
            let b = u - 1;
            for (; ++b < u + h && o[m]; ) {
              const y = [];
              (m !== i || b !== u) && y.push({ type: "tableCell", children: [] }), o[m].children.splice(b, 0, ...y);
            }
          }
        }
        "hastUtilToMdastTemporaryColSpan" in d.data && delete d.data.hastUtilToMdastTemporaryColSpan, "hastUtilToMdastTemporaryRowSpan" in d.data && delete d.data.hastUtilToMdastTemporaryRowSpan, Object.keys(d.data).length === 0 && delete d.data;
      }
    }
    c.length > s && (s = c.length);
  }
  for (i = -1; ++i < o.length; ) {
    const c = o[i].children;
    let u = c.length - 1;
    for (; ++u < s; )
      c.push({ type: "tableCell", children: [] });
  }
  let a = n.length - 1;
  for (; ++a < s; )
    n.push(null);
  e.inTable = !1;
  const l = { type: "table", align: n, children: o };
  return e.patch(t, l), l;
}
function YD(e) {
  const t = { align: [null], headless: !0 };
  let n = 0, r = 0;
  return Go(e, function(o) {
    if (o.type === "element") {
      if (o.tagName === "table" && e !== o)
        return bC;
      if ((o.tagName === "th" || o.tagName === "td") && o.properties) {
        if (!t.align[r]) {
          const i = String(o.properties.align || "") || null;
          (i === "center" || i === "left" || i === "right" || i === null) && (t.align[r] = i);
        }
        t.headless && n < 2 && o.tagName === "th" && (t.headless = !1), r++;
      } else o.tagName === "thead" ? t.headless = !1 : o.tagName === "tr" && (n++, r = 0);
    }
  }), t;
}
function KD() {
  return { type: "tableCell", children: [] };
}
function Kg() {
  return { type: "tableRow", children: [] };
}
function QD(e, t) {
  const n = { type: "text", value: t.value };
  return e.patch(t, n), n;
}
function ZD(e, t) {
  const n = { type: "text", value: ba(t) };
  return e.patch(t, n), n;
}
function XD(e, t) {
  const n = { type: "text", value: "" };
  return e.patch(t, n), n;
}
const JD = {
  comment: TD,
  doctype: Se,
  root: VD,
  text: QD
}, eR = {
  // Ignore:
  applet: Se,
  area: Se,
  basefont: Se,
  bgsound: Se,
  caption: Se,
  col: Se,
  colgroup: Se,
  command: Se,
  content: Se,
  datalist: Se,
  dialog: Se,
  element: Se,
  embed: Se,
  frame: Se,
  frameset: Se,
  isindex: Se,
  keygen: Se,
  link: Se,
  math: Se,
  menu: Se,
  menuitem: Se,
  meta: Se,
  nextid: Se,
  noembed: Se,
  noframes: Se,
  optgroup: Se,
  option: Se,
  param: Se,
  script: Se,
  shadow: Se,
  source: Se,
  spacer: Se,
  style: Se,
  svg: Se,
  template: Se,
  title: Se,
  track: Se,
  // Use children:
  abbr: ve,
  acronym: ve,
  bdi: ve,
  bdo: ve,
  big: ve,
  blink: ve,
  button: ve,
  canvas: ve,
  cite: ve,
  data: ve,
  details: ve,
  dfn: ve,
  font: ve,
  ins: ve,
  label: ve,
  map: ve,
  marquee: ve,
  meter: ve,
  nobr: ve,
  noscript: ve,
  object: ve,
  output: ve,
  progress: ve,
  rb: ve,
  rbc: ve,
  rp: ve,
  rt: ve,
  rtc: ve,
  ruby: ve,
  slot: ve,
  small: ve,
  span: ve,
  sup: ve,
  sub: ve,
  tbody: ve,
  tfoot: ve,
  thead: ve,
  time: ve,
  // Use children as flow.
  address: gt,
  article: gt,
  aside: gt,
  body: gt,
  center: gt,
  div: gt,
  fieldset: gt,
  figcaption: gt,
  figure: gt,
  form: gt,
  footer: gt,
  header: gt,
  hgroup: gt,
  html: gt,
  legend: gt,
  main: gt,
  multicol: gt,
  nav: gt,
  picture: gt,
  section: gt,
  // Handle.
  a: cD,
  audio: qg,
  b: Gg,
  base: uD,
  blockquote: dD,
  br: fD,
  code: ls,
  dir: bd,
  dl: xD,
  dt: gd,
  dd: gd,
  del: md,
  em: Ga,
  h1: ii,
  h2: ii,
  h3: ii,
  h4: ii,
  h5: ii,
  h6: ii,
  hr: vD,
  i: Ga,
  iframe: SD,
  img: Vg,
  image: Vg,
  input: ID,
  kbd: ls,
  li: gd,
  listing: Wa,
  mark: Ga,
  ol: bd,
  p: Wg,
  plaintext: Wa,
  pre: Wa,
  q: jD,
  s: md,
  samp: ls,
  select: zD,
  strike: md,
  strong: Gg,
  summary: Wg,
  table: GD,
  td: Yg,
  textarea: ZD,
  th: Yg,
  tr: qD,
  tt: ls,
  u: Ga,
  ul: bd,
  var: ls,
  video: qg,
  wbr: XD,
  xmp: Wa
};
function ve(e, t) {
  return e.all(t);
}
function gt(e, t) {
  return e.toFlow(e.all(t));
}
function Se() {
}
const Qg = {}.hasOwnProperty;
function tR(e) {
  return {
    all: nR,
    baseFound: !1,
    elementById: /* @__PURE__ */ new Map(),
    frozenBaseUrl: void 0,
    handlers: { ...eR, ...e.handlers },
    inTable: !1,
    nodeHandlers: { ...JD, ...e.nodeHandlers },
    one: rR,
    options: e,
    patch: oR,
    qNesting: 0,
    resolve: iR,
    toFlow: sR,
    toSpecificContent: aR
  };
}
function nR(e) {
  const t = e.children || [], n = [];
  let r = -1;
  for (; ++r < t.length; ) {
    const o = t[r], i = (
      /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */
      this.one(o, e)
    );
    Array.isArray(i) ? n.push(...i) : i && n.push(i);
  }
  return n;
}
function rR(e, t) {
  if (e.type === "element") {
    if (e.properties && e.properties.dataMdast === "ignore")
      return;
    if (Qg.call(this.handlers, e.tagName))
      return this.handlers[e.tagName](this, e, t) || void 0;
  } else if (Qg.call(this.nodeHandlers, e.type))
    return this.nodeHandlers[e.type](this, e, t) || void 0;
  if ("value" in e && typeof e.value == "string") {
    const n = { type: "text", value: e.value };
    return this.patch(e, n), n;
  }
  if ("children" in e)
    return this.all(e);
}
function oR(e, t) {
  e.position && (t.position = TC(e));
}
function iR(e) {
  const t = this.frozenBaseUrl;
  return e == null ? "" : t ? String(new URL(e, t)) : e;
}
function sR(e) {
  return DC(e);
}
function aR(e, t) {
  const n = t(), r = [];
  let o = [], i = -1;
  for (; ++i < e.length; ) {
    const a = e[i];
    if (s(a))
      o.length > 0 && (a.children.unshift(...o), o = []), r.push(a);
    else {
      const l = (
        /** @type {ChildType} */
        a
      );
      o.push(l);
    }
  }
  if (o.length > 0) {
    let a = r[r.length - 1];
    a || (a = t(), r.push(a)), a.children.push(...o), o = [];
  }
  return r;
  function s(a) {
    return a.type === n.type;
  }
}
const lR = {};
function Zg(e, t) {
  const n = Ri(e), r = t || lR, o = sD({
    newlines: r.newlines === !0
  }), i = tR(r);
  let s;
  o(n), Go(n, function(l) {
    if (l && l.type === "element" && l.properties) {
      const c = String(l.properties.id || "") || void 0;
      c && !i.elementById.has(c) && i.elementById.set(c, l);
    }
  });
  const a = i.one(n, void 0);
  return a ? Array.isArray(a) ? s = { type: "root", children: (
    /** @type {Array<MdastRootContent>} */
    a
  ) } : s = a : s = { type: "root", children: [] }, Go(s, function(l, c, u) {
    if (l.type === "text" && c !== void 0 && u) {
      const d = u.children[c - 1];
      if (d && d.type === l.type)
        return d.value += l.value, u.children.splice(c, 1), d.position && l.position && (d.position.end = l.position.end), c - 1;
      if (l.value = l.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, "$1"), u && (u.type === "heading" || u.type === "paragraph" || u.type === "root") && (c || (l.value = l.value.replace(/^[\t ]+/, "")), c === u.children.length - 1 && (l.value = l.value.replace(/[\t ]+$/, ""))), !l.value)
        return u.children.splice(c, 1), c;
    }
  }), s;
}
const Xg = { document: !0 };
function cR(e, t) {
  return e && "run" in e ? async function(n, r) {
    const o = Zg(n, { ...Xg, ...t });
    await e.run(o, r);
  } : function(n) {
    return (
      /** @type {MdastRoot} */
      Zg(n, { ...Xg, ...e })
    );
  };
}
function ic(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, o = n.indexOf(t);
  for (; o !== -1; )
    r++, o = n.indexOf(t, o + t.length);
  return r;
}
const qt = Eo(/[A-Za-z]/), Pt = Eo(/[\dA-Za-z]/), uR = Eo(/[#-'*+\--9=?A-Z^-~]/);
function sc(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const zf = Eo(/\d/), dR = Eo(/[\dA-Fa-f]/), fR = Eo(/[!-/:-@[-`{-~]/);
function oe(e) {
  return e !== null && e < -2;
}
function Ye(e) {
  return e !== null && (e < 0 || e === 32);
}
function Ne(e) {
  return e === -2 || e === -1 || e === 32;
}
const hu = Eo(new RegExp("\\p{P}|\\p{S}", "u")), Yo = Eo(/\s/);
function Eo(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function hR(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function pR(e, t, n) {
  const o = Yi((n || {}).ignore || []), i = mR(t);
  let s = -1;
  for (; ++s < i.length; )
    yC(e, "text", a);
  function a(c, u) {
    let d = -1, f;
    for (; ++d < u.length; ) {
      const h = u[d], p = f ? f.children : void 0;
      if (o(
        h,
        p ? p.indexOf(h) : void 0,
        f
      ))
        return;
      f = h;
    }
    if (f)
      return l(c, u);
  }
  function l(c, u) {
    const d = u[u.length - 1], f = i[s][0], h = i[s][1];
    let p = 0;
    const b = d.children.indexOf(c);
    let y = !1, k = [];
    f.lastIndex = 0;
    let C = f.exec(c.value);
    for (; C; ) {
      const _ = C.index, w = {
        index: C.index,
        input: C.input,
        stack: [...u, c]
      };
      let T = h(...C, w);
      if (typeof T == "string" && (T = T.length > 0 ? { type: "text", value: T } : void 0), T === !1 ? f.lastIndex = _ + 1 : (p !== _ && k.push({
        type: "text",
        value: c.value.slice(p, _)
      }), Array.isArray(T) ? k.push(...T) : T && k.push(T), p = _ + C[0].length, y = !0), !f.global)
        break;
      C = f.exec(c.value);
    }
    return y ? (p < c.value.length && k.push({ type: "text", value: c.value.slice(p) }), d.children.splice(b, 1, ...k)) : k = [c], b + k.length;
  }
}
function mR(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const o = n[r];
    t.push([gR(o[0]), bR(o[1])]);
  }
  return t;
}
function gR(e) {
  return typeof e == "string" ? new RegExp(hR(e), "g") : e;
}
function bR(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const Ed = "phrasing", kd = ["autolink", "link", "image", "label"];
function yR() {
  return {
    transforms: [vR],
    enter: {
      literalAutolink: kR,
      literalAutolinkEmail: Cd,
      literalAutolinkHttp: Cd,
      literalAutolinkWww: Cd
    },
    exit: {
      literalAutolink: wR,
      literalAutolinkEmail: xR,
      literalAutolinkHttp: CR,
      literalAutolinkWww: TR
    }
  };
}
function ER() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Ed,
        notInConstruct: kd
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Ed,
        notInConstruct: kd
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Ed,
        notInConstruct: kd
      }
    ]
  };
}
function kR(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function Cd(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function CR(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function TR(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function xR(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function wR(e) {
  this.exit(e);
}
function vR(e) {
  pR(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, SR],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), _R]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function SR(e, t, n, r, o) {
  let i = "";
  if (!BC(o) || (/^w/i.test(t) && (n = t + n, t = "", i = "http://"), !AR(n)))
    return !1;
  const s = IR(n + r);
  if (!s[0]) return !1;
  const a = {
    type: "link",
    title: null,
    url: i + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [a, { type: "text", value: s[1] }] : a;
}
function _R(e, t, n, r) {
  return (
    // Not an expected previous character.
    !BC(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function AR(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function IR(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const o = ic(e, "(");
  let i = ic(e, ")");
  for (; r !== -1 && o > i; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++;
  return [e, n];
}
function BC(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || Yo(n) || hu(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
function Wn(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
$C.peek = $R;
function NR() {
  this.buffer();
}
function MR(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function LR() {
  this.buffer();
}
function OR(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function DR(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Wn(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function RR(e) {
  this.exit(e);
}
function PR(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Wn(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function BR(e) {
  this.exit(e);
}
function $R() {
  return "[";
}
function $C(e, t, n, r) {
  const o = n.createTracker(r);
  let i = o.move("[^");
  const s = n.enter("footnoteReference"), a = n.enter("reference");
  return i += o.move(
    n.safe(n.associationId(e), { after: "]", before: i })
  ), a(), s(), i += o.move("]"), i;
}
function HR() {
  return {
    enter: {
      gfmFootnoteCallString: NR,
      gfmFootnoteCall: MR,
      gfmFootnoteDefinitionLabelString: LR,
      gfmFootnoteDefinition: OR
    },
    exit: {
      gfmFootnoteCallString: DR,
      gfmFootnoteCall: RR,
      gfmFootnoteDefinitionLabelString: PR,
      gfmFootnoteDefinition: BR
    }
  };
}
function FR(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: $C },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, o, i, s) {
    const a = i.createTracker(s);
    let l = a.move("[^");
    const c = i.enter("footnoteDefinition"), u = i.enter("label");
    return l += a.move(
      i.safe(i.associationId(r), { before: l, after: "]" })
    ), u(), l += a.move("]:"), r.children && r.children.length > 0 && (a.shift(4), l += a.move(
      (t ? `
` : " ") + i.indentLines(
        i.containerFlow(r, a.current()),
        t ? HC : UR
      )
    )), c(), l;
  }
}
function UR(e, t, n) {
  return t === 0 ? e : HC(e, t, n);
}
function HC(e, t, n) {
  return (n ? "" : "    ") + e;
}
const jR = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
FC.peek = GR;
function VR() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: qR },
    exit: { strikethrough: WR }
  };
}
function zR() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: jR
      }
    ],
    handlers: { delete: FC }
  };
}
function qR(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function WR(e) {
  this.exit(e);
}
function FC(e, t, n, r) {
  const o = n.createTracker(r), i = n.enter("strikethrough");
  let s = o.move("~~");
  return s += n.containerPhrasing(e, {
    ...o.current(),
    before: s,
    after: "~"
  }), s += o.move("~~"), i(), s;
}
function GR() {
  return "~";
}
function YR(e) {
  return e.length;
}
function KR(e, t) {
  const n = t || {}, r = (n.align || []).concat(), o = n.stringLength || YR, i = [], s = [], a = [], l = [];
  let c = 0, u = -1;
  for (; ++u < e.length; ) {
    const m = [], b = [];
    let y = -1;
    for (e[u].length > c && (c = e[u].length); ++y < e[u].length; ) {
      const k = QR(e[u][y]);
      if (n.alignDelimiters !== !1) {
        const C = o(k);
        b[y] = C, (l[y] === void 0 || C > l[y]) && (l[y] = C);
      }
      m.push(k);
    }
    s[u] = m, a[u] = b;
  }
  let d = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++d < c; )
      i[d] = Jg(r[d]);
  else {
    const m = Jg(r);
    for (; ++d < c; )
      i[d] = m;
  }
  d = -1;
  const f = [], h = [];
  for (; ++d < c; ) {
    const m = i[d];
    let b = "", y = "";
    m === 99 ? (b = ":", y = ":") : m === 108 ? b = ":" : m === 114 && (y = ":");
    let k = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[d] - b.length - y.length
    );
    const C = b + "-".repeat(k) + y;
    n.alignDelimiters !== !1 && (k = b.length + k + y.length, k > l[d] && (l[d] = k), h[d] = k), f[d] = C;
  }
  s.splice(1, 0, f), a.splice(1, 0, h), u = -1;
  const p = [];
  for (; ++u < s.length; ) {
    const m = s[u], b = a[u];
    d = -1;
    const y = [];
    for (; ++d < c; ) {
      const k = m[d] || "";
      let C = "", _ = "";
      if (n.alignDelimiters !== !1) {
        const w = l[d] - (b[d] || 0), T = i[d];
        T === 114 ? C = " ".repeat(w) : T === 99 ? w % 2 ? (C = " ".repeat(w / 2 + 0.5), _ = " ".repeat(w / 2 - 0.5)) : (C = " ".repeat(w / 2), _ = C) : _ = " ".repeat(w);
      }
      n.delimiterStart !== !1 && !d && y.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && k === "") && (n.delimiterStart !== !1 || d) && y.push(" "), n.alignDelimiters !== !1 && y.push(C), y.push(k), n.alignDelimiters !== !1 && y.push(_), n.padding !== !1 && y.push(" "), (n.delimiterEnd !== !1 || d !== c - 1) && y.push("|");
    }
    p.push(
      n.delimiterEnd === !1 ? y.join("").replace(/ +$/, "") : y.join("")
    );
  }
  return p.join(`
`);
}
function QR(e) {
  return e == null ? "" : String(e);
}
function Jg(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
const e1 = {}.hasOwnProperty;
function UC(e, t) {
  const n = t || {};
  function r(o, ...i) {
    let s = r.invalid;
    const a = r.handlers;
    if (o && e1.call(o, e)) {
      const l = String(o[e]);
      s = e1.call(a, l) ? a[l] : r.unknown;
    }
    if (s)
      return s.call(this, o, ...i);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const ZR = {}.hasOwnProperty;
function jC(e, t) {
  let n = -1, r;
  if (t.extensions)
    for (; ++n < t.extensions.length; )
      jC(e, t.extensions[n]);
  for (r in t)
    if (ZR.call(t, r))
      switch (r) {
        case "extensions":
          break;
        case "unsafe": {
          t1(e[r], t[r]);
          break;
        }
        case "join": {
          t1(e[r], t[r]);
          break;
        }
        case "handlers": {
          XR(e[r], t[r]);
          break;
        }
        default:
          e.options[r] = t[r];
      }
  return e;
}
function t1(e, t) {
  t && e.push(...t);
}
function XR(e, t) {
  t && Object.assign(e, t);
}
function JR(e, t, n, r) {
  const o = n.enter("blockquote"), i = n.createTracker(r);
  i.move("> "), i.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, i.current()),
    eP
  );
  return o(), s;
}
function eP(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function VC(e, t) {
  return n1(e, t.inConstruct, !0) && !n1(e, t.notInConstruct, !1);
}
function n1(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function r1(e, t, n, r) {
  let o = -1;
  for (; ++o < n.unsafe.length; )
    if (n.unsafe[o].character === `
` && VC(n.stack, n.unsafe[o]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function tP(e, t) {
  const n = String(e);
  let r = n.indexOf(t), o = r, i = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === o ? ++i > s && (s = i) : i = 1, o = r + t.length, r = n.indexOf(t, o);
  return s;
}
function qf(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function nP(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function rP(e, t, n, r) {
  const o = nP(n), i = e.value || "", s = o === "`" ? "GraveAccent" : "Tilde";
  if (qf(e, n)) {
    const d = n.enter("codeIndented"), f = n.indentLines(i, oP);
    return d(), f;
  }
  const a = n.createTracker(r), l = o.repeat(Math.max(tP(i, o) + 1, 3)), c = n.enter("codeFenced");
  let u = a.move(l);
  if (e.lang) {
    const d = n.enter(`codeFencedLang${s}`);
    u += a.move(
      n.safe(e.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), d();
  }
  if (e.lang && e.meta) {
    const d = n.enter(`codeFencedMeta${s}`);
    u += a.move(" "), u += a.move(
      n.safe(e.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), d();
  }
  return u += a.move(`
`), i && (u += a.move(i + `
`)), u += a.move(l), c(), u;
}
function oP(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Hp(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function iP(e, t, n, r) {
  const o = Hp(n), i = o === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), a(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), a(), e.title && (a = n.enter(`title${i}`), c += l.move(" " + o), c += l.move(
    n.safe(e.title, {
      before: c,
      after: o,
      ...l.current()
    })
  ), c += l.move(o), a()), s(), c;
}
function sP(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function fo(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Pi(e) {
  if (e === null || Ye(e) || Yo(e))
    return 1;
  if (hu(e))
    return 2;
}
function ac(e, t, n) {
  const r = Pi(e), o = Pi(t);
  return r === void 0 ? o === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
zC.peek = aP;
function zC(e, t, n, r) {
  const o = sP(n), i = n.enter("emphasis"), s = n.createTracker(r), a = s.move(o);
  let l = s.move(
    n.containerPhrasing(e, {
      after: o,
      before: a,
      ...s.current()
    })
  );
  const c = l.charCodeAt(0), u = ac(
    r.before.charCodeAt(r.before.length - 1),
    c,
    o
  );
  u.inside && (l = fo(c) + l.slice(1));
  const d = l.charCodeAt(l.length - 1), f = ac(r.after.charCodeAt(0), d, o);
  f.inside && (l = l.slice(0, -1) + fo(d));
  const h = s.move(o);
  return i(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, a + l + h;
}
function aP(e, t, n) {
  return n.options.emphasis || "*";
}
function qC(e, t) {
  let n = !1;
  return Go(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, oc;
  }), !!((!e.depth || e.depth < 3) && du(e) && (t.options.setext || n));
}
function lP(e, t, n, r) {
  const o = Math.max(Math.min(6, e.depth || 1), 1), i = n.createTracker(r);
  if (qC(e, n)) {
    const u = n.enter("headingSetext"), d = n.enter("phrasing"), f = n.containerPhrasing(e, {
      ...i.current(),
      before: `
`,
      after: `
`
    });
    return d(), u(), f + `
` + (o === 1 ? "=" : "-").repeat(
      // The whole size
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(o), a = n.enter("headingAtx"), l = n.enter("phrasing");
  i.move(s + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...i.current()
  });
  return /^[\t ]/.test(c) && (c = fo(c.charCodeAt(0)) + c.slice(1)), c = c ? s + " " + c : s, n.options.closeAtx && (c += " " + s), l(), a(), c;
}
WC.peek = cP;
function WC(e) {
  return e.value || "";
}
function cP() {
  return "<";
}
GC.peek = uP;
function GC(e, t, n, r) {
  const o = Hp(n), i = o === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let a = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(e.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), a(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), a(), e.title && (a = n.enter(`title${i}`), c += l.move(" " + o), c += l.move(
    n.safe(e.title, {
      before: c,
      after: o,
      ...l.current()
    })
  ), c += l.move(o), a()), c += l.move(")"), s(), c;
}
function uP() {
  return "!";
}
YC.peek = dP;
function YC(e, t, n, r) {
  const o = e.referenceType, i = n.enter("imageReference");
  let s = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("![");
  const c = n.safe(e.alt, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), s();
  const u = n.stack;
  n.stack = [], s = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...a.current()
  });
  return s(), n.stack = u, i(), o === "full" || !c || c !== d ? l += a.move(d + "]") : o === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function dP() {
  return "!";
}
KC.peek = fP;
function KC(e, t, n) {
  let r = e.value || "", o = "`", i = -1;
  for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(r); )
    o += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length; ) {
    const s = n.unsafe[i], a = n.compilePattern(s);
    let l;
    if (s.atBreak)
      for (; l = a.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return o + r + o;
}
function fP() {
  return "`";
}
function QC(e, t) {
  const n = du(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
ZC.peek = hP;
function ZC(e, t, n, r) {
  const o = Hp(n), i = o === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let a, l;
  if (QC(e, n)) {
    const u = n.stack;
    n.stack = [], a = n.enter("autolink");
    let d = s.move("<");
    return d += s.move(
      n.containerPhrasing(e, {
        before: d,
        after: ">",
        ...s.current()
      })
    ), d += s.move(">"), a(), n.stack = u, d;
  }
  a = n.enter("link"), l = n.enter("label");
  let c = s.move("[");
  return c += s.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...s.current()
    })
  ), c += s.move("]("), l(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += s.move("<"), c += s.move(
    n.safe(e.url, { before: c, after: ">", ...s.current() })
  ), c += s.move(">")) : (l = n.enter("destinationRaw"), c += s.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), l(), e.title && (l = n.enter(`title${i}`), c += s.move(" " + o), c += s.move(
    n.safe(e.title, {
      before: c,
      after: o,
      ...s.current()
    })
  ), c += s.move(o), l()), c += s.move(")"), a(), c;
}
function hP(e, t, n) {
  return QC(e, n) ? "<" : "[";
}
XC.peek = pP;
function XC(e, t, n, r) {
  const o = e.referenceType, i = n.enter("linkReference");
  let s = n.enter("label");
  const a = n.createTracker(r);
  let l = a.move("[");
  const c = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), s();
  const u = n.stack;
  n.stack = [], s = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...a.current()
  });
  return s(), n.stack = u, i(), o === "full" || !c || c !== d ? l += a.move(d + "]") : o === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function pP() {
  return "[";
}
function Fp(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function mP(e) {
  const t = Fp(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function gP(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function JC(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function bP(e, t, n, r) {
  const o = n.enter("list"), i = n.bulletCurrent;
  let s = e.ordered ? gP(n) : Fp(n);
  const a = e.ordered ? s === "." ? ")" : "." : mP(n);
  let l = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const u = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), JC(n) === s && u
    ) {
      let d = -1;
      for (; ++d < e.children.length; ) {
        const f = e.children[d];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (s = a), n.bulletCurrent = s;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = i, o(), c;
}
function yP(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function EP(e, t, n, r) {
  const o = yP(n);
  let i = n.bulletCurrent || Fp(n);
  t && t.type === "list" && t.ordered && (i = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + i);
  let s = i.length + 1;
  (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const a = n.createTracker(r);
  a.move(i + " ".repeat(s - i.length)), a.shift(s);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, a.current()),
    u
  );
  return l(), c;
  function u(d, f, h) {
    return f ? (h ? "" : " ".repeat(s)) + d : (h ? i : i + " ".repeat(s - i.length)) + d;
  }
}
function kP(e, t, n, r) {
  const o = n.enter("paragraph"), i = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return i(), o(), s;
}
function CP(e, t, n, r) {
  return (e.children.some(function(s) {
    return OC(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function TP(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
eT.peek = xP;
function eT(e, t, n, r) {
  const o = TP(n), i = n.enter("strong"), s = n.createTracker(r), a = s.move(o + o);
  let l = s.move(
    n.containerPhrasing(e, {
      after: o,
      before: a,
      ...s.current()
    })
  );
  const c = l.charCodeAt(0), u = ac(
    r.before.charCodeAt(r.before.length - 1),
    c,
    o
  );
  u.inside && (l = fo(c) + l.slice(1));
  const d = l.charCodeAt(l.length - 1), f = ac(r.after.charCodeAt(0), d, o);
  f.inside && (l = l.slice(0, -1) + fo(d));
  const h = s.move(o + o);
  return i(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, a + l + h;
}
function xP(e, t, n) {
  return n.options.strong || "*";
}
function wP(e, t, n, r) {
  return n.safe(e.value, r);
}
function vP(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function SP(e, t, n) {
  const r = (JC(n) + (n.options.ruleSpaces ? " " : "")).repeat(vP(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Up = {
  blockquote: JR,
  break: r1,
  code: rP,
  definition: iP,
  emphasis: zC,
  hardBreak: r1,
  heading: lP,
  html: WC,
  image: GC,
  imageReference: YC,
  inlineCode: KC,
  link: ZC,
  linkReference: XC,
  list: bP,
  listItem: EP,
  paragraph: kP,
  root: CP,
  strong: eT,
  text: wP,
  thematicBreak: SP
}, _P = [AP];
function AP(e, t, n, r) {
  if (t.type === "code" && qf(t, r) && (e.type === "list" || e.type === t.type && qf(e, r)))
    return !1;
  if ("spread" in n && typeof n.spread == "boolean")
    return e.type === "paragraph" && // Two paragraphs.
    (e.type === t.type || t.type === "definition" || // Paragraph followed by a setext heading.
    t.type === "heading" && qC(t, r)) ? void 0 : n.spread ? 1 : 0;
}
const _o = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
], IP = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: `
`,
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: _o
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: !0, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: _o
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: !0, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: !0, character: "*", after: `(?:[ 	\r
*])` },
  { character: "*", inConstruct: "phrasing", notInConstruct: _o },
  // A plus sign could start a list item.
  { atBreak: !0, character: "+", after: `(?:[ 	\r
])` },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: !0, character: "-", after: `(?:[ 	\r
-])` },
  // A dot could start a list item.
  { atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: _o
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: !0, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: !0, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: !0, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: _o },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: !0, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: _o },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: !0, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: _o },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: !0, character: "~" }
], o1 = document.createElement("i");
function jp(e) {
  const t = "&" + e + ";";
  o1.innerHTML = t;
  const n = o1.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function tT(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
const NP = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function nT(e) {
  return e.replace(NP, MP);
}
function MP(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const o = n.charCodeAt(1), i = o === 120 || o === 88;
    return tT(n.slice(i ? 2 : 1), i ? 16 : 10);
  }
  return jp(n) || e;
}
function LP(e) {
  return e.label || !e.identifier ? e.label || "" : nT(e.identifier);
}
function OP(e) {
  if (!e._compiled) {
    const t = (e.atBreak ? "[\\r\\n][\\t ]*" : "") + (e.before ? "(?:" + e.before + ")" : "");
    e._compiled = new RegExp(
      (t ? "(" + t + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(e.character) ? "\\" : "") + e.character + (e.after ? "(?:" + e.after + ")" : ""),
      "g"
    );
  }
  return e._compiled;
}
function DP(e, t, n) {
  const r = t.indexStack, o = e.children || [], i = [];
  let s = -1, a = n.before, l;
  r.push(-1);
  let c = t.createTracker(n);
  for (; ++s < o.length; ) {
    const u = o[s];
    let d;
    if (r[r.length - 1] = s, s + 1 < o.length) {
      let p = t.handle.handlers[o[s + 1].type];
      p && p.peek && (p = p.peek), d = p ? p(o[s + 1], e, t, {
        before: "",
        after: "",
        ...c.current()
      }).charAt(0) : "";
    } else
      d = n.after;
    i.length > 0 && (a === "\r" || a === `
`) && u.type === "html" && (i[i.length - 1] = i[i.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), a = " ", c = t.createTracker(n), c.move(i.join("")));
    let f = t.handle(u, e, t, {
      ...c.current(),
      after: d,
      before: a
    });
    l && l === f.slice(0, 1) && (f = fo(l.charCodeAt(0)) + f.slice(1));
    const h = t.attentionEncodeSurroundingInfo;
    t.attentionEncodeSurroundingInfo = void 0, l = void 0, h && (i.length > 0 && h.before && a === i[i.length - 1].slice(-1) && (i[i.length - 1] = i[i.length - 1].slice(0, -1) + fo(a.charCodeAt(0))), h.after && (l = d)), c.move(f), i.push(f), a = f.slice(-1);
  }
  return r.pop(), i.join("");
}
function RP(e, t, n) {
  const r = t.indexStack, o = e.children || [], i = t.createTracker(n), s = [];
  let a = -1;
  for (r.push(-1); ++a < o.length; ) {
    const l = o[a];
    r[r.length - 1] = a, s.push(
      i.move(
        t.handle(l, e, t, {
          before: `
`,
          after: `
`,
          ...i.current()
        })
      )
    ), l.type !== "list" && (t.bulletLastUsed = void 0), a < o.length - 1 && s.push(
      i.move(PP(l, o[a + 1], e, t))
    );
  }
  return r.pop(), s.join("");
}
function PP(e, t, n, r) {
  let o = r.join.length;
  for (; o--; ) {
    const i = r.join[o](e, t, n, r);
    if (i === !0 || i === 1)
      break;
    if (typeof i == "number")
      return `
`.repeat(1 + i);
    if (i === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const BP = /\r?\n|\r/g;
function $P(e, t) {
  const n = [];
  let r = 0, o = 0, i;
  for (; i = BP.exec(e); )
    s(e.slice(r, i.index)), n.push(i[0]), r = i.index + i[0].length, o++;
  return s(e.slice(r)), n.join("");
  function s(a) {
    n.push(t(a, o, !a));
  }
}
function HP(e, t, n) {
  const r = (n.before || "") + (t || "") + (n.after || ""), o = [], i = [], s = {};
  let a = -1;
  for (; ++a < e.unsafe.length; ) {
    const u = e.unsafe[a];
    if (!VC(e.stack, u))
      continue;
    const d = e.compilePattern(u);
    let f;
    for (; f = d.exec(r); ) {
      const h = "before" in u || !!u.atBreak, p = "after" in u, m = f.index + (h ? f[1].length : 0);
      o.includes(m) ? (s[m].before && !h && (s[m].before = !1), s[m].after && !p && (s[m].after = !1)) : (o.push(m), s[m] = { before: h, after: p });
    }
  }
  o.sort(FP);
  let l = n.before ? n.before.length : 0;
  const c = r.length - (n.after ? n.after.length : 0);
  for (a = -1; ++a < o.length; ) {
    const u = o[a];
    u < l || u >= c || u + 1 < c && o[a + 1] === u + 1 && s[u].after && !s[u + 1].before && !s[u + 1].after || o[a - 1] === u - 1 && s[u].before && !s[u - 1].before && !s[u - 1].after || (l !== u && i.push(i1(r.slice(l, u), "\\")), l = u, /[!-/:-@[-`{-~]/.test(r.charAt(u)) && (!n.encode || !n.encode.includes(r.charAt(u))) ? i.push("\\") : (i.push(fo(r.charCodeAt(u))), l++));
  }
  return i.push(i1(r.slice(l, c), n.after)), i.join("");
}
function FP(e, t) {
  return e - t;
}
function i1(e, t) {
  const n = /\\(?=[!-/:-@[-`{-~])/g, r = [], o = [], i = e + t;
  let s = -1, a = 0, l;
  for (; l = n.exec(i); )
    r.push(l.index);
  for (; ++s < r.length; )
    a !== r[s] && o.push(e.slice(a, r[s])), o.push("\\"), a = r[s];
  return o.push(e.slice(a)), o.join("");
}
function UP(e) {
  const t = e || {}, n = t.now || {};
  let r = t.lineShift || 0, o = n.line || 1, i = n.column || 1;
  return { move: l, current: s, shift: a };
  function s() {
    return { now: { line: o, column: i }, lineShift: r };
  }
  function a(c) {
    r += c;
  }
  function l(c) {
    const u = c || "", d = u.split(/\r?\n|\r/g), f = d[d.length - 1];
    return o += d.length - 1, i = d.length === 1 ? i + f.length : 1 + f.length + r, u;
  }
}
function jP(e, t) {
  const n = t || {}, r = {
    associationId: LP,
    containerPhrasing: WP,
    containerFlow: GP,
    createTracker: UP,
    compilePattern: OP,
    enter: i,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...Up },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines: $P,
    indexStack: [],
    join: [..._P],
    options: {},
    safe: YP,
    stack: [],
    unsafe: [...IP]
  };
  jC(r, n), r.options.tightDefinitions && r.join.push(qP), r.handle = UC("type", {
    invalid: VP,
    unknown: zP,
    handlers: r.handlers
  });
  let o = r.handle(e, void 0, r, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  return o && o.charCodeAt(o.length - 1) !== 10 && o.charCodeAt(o.length - 1) !== 13 && (o += `
`), o;
  function i(s) {
    return r.stack.push(s), a;
    function a() {
      r.stack.pop();
    }
  }
}
function VP(e) {
  throw new Error("Cannot handle value `" + e + "`, expected node");
}
function zP(e) {
  const t = (
    /** @type {Nodes} */
    e
  );
  throw new Error("Cannot handle unknown node `" + t.type + "`");
}
function qP(e, t) {
  if (e.type === "definition" && e.type === t.type)
    return 0;
}
function WP(e, t) {
  return DP(e, this, t);
}
function GP(e, t) {
  return RP(e, this, t);
}
function YP(e, t) {
  return HP(this, e, t);
}
function KP() {
  return {
    enter: {
      table: QP,
      tableData: s1,
      tableHeader: s1,
      tableRow: XP
    },
    exit: {
      codeText: JP,
      table: ZP,
      tableData: Td,
      tableHeader: Td,
      tableRow: Td
    }
  };
}
function QP(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function ZP(e) {
  this.exit(e), this.data.inTable = void 0;
}
function XP(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Td(e) {
  this.exit(e);
}
function s1(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function JP(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, e9));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function e9(e, t) {
  return t === "|" ? t : e;
}
function t9(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, o = t.stringLength, i = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: f,
      table: s,
      tableCell: l,
      tableRow: a
    }
  };
  function s(h, p, m, b) {
    return c(u(h, m, b), h.align);
  }
  function a(h, p, m, b) {
    const y = d(h, m, b), k = c([y]);
    return k.slice(0, k.indexOf(`
`));
  }
  function l(h, p, m, b) {
    const y = m.enter("tableCell"), k = m.enter("phrasing"), C = m.containerPhrasing(h, {
      ...b,
      before: i,
      after: i
    });
    return k(), y(), C;
  }
  function c(h, p) {
    return KR(h, {
      align: p,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: o
    });
  }
  function u(h, p, m) {
    const b = h.children;
    let y = -1;
    const k = [], C = p.enter("table");
    for (; ++y < b.length; )
      k[y] = d(b[y], p, m);
    return C(), k;
  }
  function d(h, p, m) {
    const b = h.children;
    let y = -1;
    const k = [], C = p.enter("tableRow");
    for (; ++y < b.length; )
      k[y] = l(b[y], h, p, m);
    return C(), k;
  }
  function f(h, p, m) {
    let b = Up.inlineCode(h, p, m);
    return m.stack.includes("tableCell") && (b = b.replace(/\|/g, "\\$&")), b;
  }
}
function n9() {
  return {
    exit: {
      taskListCheckValueChecked: a1,
      taskListCheckValueUnchecked: a1,
      paragraph: o9
    }
  };
}
function r9() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: i9 }
  };
}
function a1(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function o9(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const o = t.children;
      let i = -1, s;
      for (; ++i < o.length; ) {
        const a = o[i];
        if (a.type === "paragraph") {
          s = a;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function i9(e, t, n, r) {
  const o = e.children[0], i = typeof e.checked == "boolean" && o && o.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", a = n.createTracker(r);
  i && a.move(s);
  let l = Up.listItem(e, t, n, {
    ...r,
    ...a.current()
  });
  return i && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(u) {
    return u + s;
  }
}
function s9() {
  return [
    yR(),
    HR(),
    VR(),
    KP(),
    n9()
  ];
}
function a9(e) {
  return {
    extensions: [
      ER(),
      FR(e),
      zR(),
      t9(e),
      r9()
    ]
  };
}
function En(e, t, n, r) {
  const o = e.length;
  let i = 0, s;
  if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); i < r.length; )
      s = r.slice(i, i + 1e4), s.unshift(t, 0), e.splice(...s), i += 1e4, t += 1e4;
}
function An(e, t) {
  return e.length > 0 ? (En(e, e.length, 0, t), e) : t;
}
const l1 = {}.hasOwnProperty;
function rT(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    l9(t, e[n]);
  return t;
}
function l9(e, t) {
  let n;
  for (n in t) {
    const o = (l1.call(e, n) ? e[n] : void 0) || (e[n] = {}), i = t[n];
    let s;
    if (i)
      for (s in i) {
        l1.call(o, s) || (o[s] = []);
        const a = i[s];
        c9(
          // @ts-expect-error Looks like a list.
          o[s],
          Array.isArray(a) ? a : a ? [a] : []
        );
      }
  }
}
function c9(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  En(e, 0, 0, r);
}
const u9 = {
  tokenize: g9,
  partial: !0
}, oT = {
  tokenize: b9,
  partial: !0
}, iT = {
  tokenize: y9,
  partial: !0
}, sT = {
  tokenize: E9,
  partial: !0
}, d9 = {
  tokenize: k9,
  partial: !0
}, aT = {
  name: "wwwAutolink",
  tokenize: p9,
  previous: cT
}, lT = {
  name: "protocolAutolink",
  tokenize: m9,
  previous: uT
}, zr = {
  name: "emailAutolink",
  tokenize: h9,
  previous: dT
}, xr = {};
function f9() {
  return {
    text: xr
  };
}
let Ao = 48;
for (; Ao < 123; )
  xr[Ao] = zr, Ao++, Ao === 58 ? Ao = 65 : Ao === 91 && (Ao = 97);
xr[43] = zr;
xr[45] = zr;
xr[46] = zr;
xr[95] = zr;
xr[72] = [zr, lT];
xr[104] = [zr, lT];
xr[87] = [zr, aT];
xr[119] = [zr, aT];
function h9(e, t, n) {
  const r = this;
  let o, i;
  return s;
  function s(d) {
    return !Wf(d) || !dT.call(r, r.previous) || Vp(r.events) ? n(d) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), a(d));
  }
  function a(d) {
    return Wf(d) ? (e.consume(d), a) : d === 64 ? (e.consume(d), l) : n(d);
  }
  function l(d) {
    return d === 46 ? e.check(d9, u, c)(d) : d === 45 || d === 95 || Pt(d) ? (i = !0, e.consume(d), l) : u(d);
  }
  function c(d) {
    return e.consume(d), o = !0, l;
  }
  function u(d) {
    return i && o && qt(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(d)) : n(d);
  }
}
function p9(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return s !== 87 && s !== 119 || !cT.call(r, r.previous) || Vp(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(u9, e.attempt(oT, e.attempt(iT, i), n), n)(s));
  }
  function i(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function m9(e, t, n) {
  const r = this;
  let o = "", i = !1;
  return s;
  function s(d) {
    return (d === 72 || d === 104) && uT.call(r, r.previous) && !Vp(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(d), e.consume(d), a) : n(d);
  }
  function a(d) {
    if (qt(d) && o.length < 5)
      return o += String.fromCodePoint(d), e.consume(d), a;
    if (d === 58) {
      const f = o.toLowerCase();
      if (f === "http" || f === "https")
        return e.consume(d), l;
    }
    return n(d);
  }
  function l(d) {
    return d === 47 ? (e.consume(d), i ? c : (i = !0, l)) : n(d);
  }
  function c(d) {
    return d === null || sc(d) || Ye(d) || Yo(d) || hu(d) ? n(d) : e.attempt(oT, e.attempt(iT, u), n)(d);
  }
  function u(d) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(d);
  }
}
function g9(e, t, n) {
  let r = 0;
  return o;
  function o(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), o) : s === 46 && r === 3 ? (e.consume(s), i) : n(s);
  }
  function i(s) {
    return s === null ? n(s) : t(s);
  }
}
function b9(e, t, n) {
  let r, o, i;
  return s;
  function s(c) {
    return c === 46 || c === 95 ? e.check(sT, l, a)(c) : c === null || Ye(c) || Yo(c) || c !== 45 && hu(c) ? l(c) : (i = !0, e.consume(c), s);
  }
  function a(c) {
    return c === 95 ? r = !0 : (o = r, r = void 0), e.consume(c), s;
  }
  function l(c) {
    return o || r || !i ? n(c) : t(c);
  }
}
function y9(e, t) {
  let n = 0, r = 0;
  return o;
  function o(s) {
    return s === 40 ? (n++, e.consume(s), o) : s === 41 && r < n ? i(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(sT, t, i)(s) : s === null || Ye(s) || Yo(s) ? t(s) : (e.consume(s), o);
  }
  function i(s) {
    return s === 41 && r++, e.consume(s), o;
  }
}
function E9(e, t, n) {
  return r;
  function r(a) {
    return a === 33 || a === 34 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 63 || a === 95 || a === 126 ? (e.consume(a), r) : a === 38 ? (e.consume(a), i) : a === 93 ? (e.consume(a), o) : (
      // `<` is an end.
      a === 60 || // So is whitespace.
      a === null || Ye(a) || Yo(a) ? t(a) : n(a)
    );
  }
  function o(a) {
    return a === null || a === 40 || a === 91 || Ye(a) || Yo(a) ? t(a) : r(a);
  }
  function i(a) {
    return qt(a) ? s(a) : n(a);
  }
  function s(a) {
    return a === 59 ? (e.consume(a), r) : qt(a) ? (e.consume(a), s) : n(a);
  }
}
function k9(e, t, n) {
  return r;
  function r(i) {
    return e.consume(i), o;
  }
  function o(i) {
    return Pt(i) ? n(i) : t(i);
  }
}
function cT(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Ye(e);
}
function uT(e) {
  return !qt(e);
}
function dT(e) {
  return !(e === 47 || Wf(e));
}
function Wf(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Pt(e);
}
function Vp(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
function Ki(e) {
  const t = [];
  let n = -1, r = 0, o = 0;
  for (; ++n < e.length; ) {
    const i = e.charCodeAt(n);
    let s = "";
    if (i === 37 && Pt(e.charCodeAt(n + 1)) && Pt(e.charCodeAt(n + 2)))
      o = 2;
    else if (i < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (s = String.fromCharCode(i));
    else if (i > 55295 && i < 57344) {
      const a = e.charCodeAt(n + 1);
      i < 56320 && a > 56319 && a < 57344 ? (s = String.fromCharCode(i, a), o = 1) : s = "";
    } else
      s = String.fromCharCode(i);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + o + 1, s = ""), o && (n += o, o = 0);
  }
  return t.join("") + e.slice(r);
}
function pu(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; ) {
    const i = e[o].resolveAll;
    i && !r.includes(i) && (t = i(t, n), r.push(i));
  }
  return t;
}
const Gf = {
  name: "attention",
  resolveAll: C9,
  tokenize: T9
};
function C9(e, t) {
  let n = -1, r, o, i, s, a, l, c, u;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const d = {
            ...e[r][1].end
          }, f = {
            ...e[n][1].start
          };
          c1(d, -l), c1(f, l), s = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: {
              ...e[r][1].end
            }
          }, a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: f
          }, i = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, o = {
            type: l > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...a.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...a.end
          }, c = [], e[r][1].end.offset - e[r][1].start.offset && (c = An(c, [["enter", e[r][1], t], ["exit", e[r][1], t]])), c = An(c, [["enter", o, t], ["enter", s, t], ["exit", s, t], ["enter", i, t]]), c = An(c, pu(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), c = An(c, [["exit", i, t], ["enter", a, t], ["exit", a, t], ["exit", o, t]]), e[n][1].end.offset - e[n][1].start.offset ? (u = 2, c = An(c, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : u = 0, En(e, r - 1, n - r + 3, c), n = r + c.length - u - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function T9(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, o = Pi(r);
  let i;
  return s;
  function s(l) {
    return i = l, e.enter("attentionSequence"), a(l);
  }
  function a(l) {
    if (l === i)
      return e.consume(l), a;
    const c = e.exit("attentionSequence"), u = Pi(l), d = !u || u === 2 && o || n.includes(l), f = !o || o === 2 && u || n.includes(r);
    return c._open = !!(i === 42 ? d : d && (o || !f)), c._close = !!(i === 42 ? f : f && (u || !d)), t(l);
  }
}
function c1(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const x9 = {
  name: "autolink",
  tokenize: w9
};
function w9(e, t, n) {
  let r = 0;
  return o;
  function o(h) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), i;
  }
  function i(h) {
    return qt(h) ? (e.consume(h), s) : h === 64 ? n(h) : c(h);
  }
  function s(h) {
    return h === 43 || h === 45 || h === 46 || Pt(h) ? (r = 1, a(h)) : c(h);
  }
  function a(h) {
    return h === 58 ? (e.consume(h), r = 0, l) : (h === 43 || h === 45 || h === 46 || Pt(h)) && r++ < 32 ? (e.consume(h), a) : (r = 0, c(h));
  }
  function l(h) {
    return h === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : h === null || h === 32 || h === 60 || sc(h) ? n(h) : (e.consume(h), l);
  }
  function c(h) {
    return h === 64 ? (e.consume(h), u) : uR(h) ? (e.consume(h), c) : n(h);
  }
  function u(h) {
    return Pt(h) ? d(h) : n(h);
  }
  function d(h) {
    return h === 46 ? (e.consume(h), r = 0, u) : h === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : f(h);
  }
  function f(h) {
    if ((h === 45 || Pt(h)) && r++ < 63) {
      const p = h === 45 ? f : d;
      return e.consume(h), p;
    }
    return n(h);
  }
}
function Re(e, t, n, r) {
  const o = r ? r - 1 : Number.POSITIVE_INFINITY;
  let i = 0;
  return s;
  function s(l) {
    return Ne(l) ? (e.enter(n), a(l)) : t(l);
  }
  function a(l) {
    return Ne(l) && i++ < o ? (e.consume(l), a) : (e.exit(n), t(l));
  }
}
const ya = {
  partial: !0,
  tokenize: v9
};
function v9(e, t, n) {
  return r;
  function r(i) {
    return Ne(i) ? Re(e, o, "linePrefix")(i) : o(i);
  }
  function o(i) {
    return i === null || oe(i) ? t(i) : n(i);
  }
}
const fT = {
  continuation: {
    tokenize: _9
  },
  exit: A9,
  name: "blockQuote",
  tokenize: S9
};
function S9(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    if (s === 62) {
      const a = r.containerState;
      return a.open || (e.enter("blockQuote", {
        _container: !0
      }), a.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), i;
    }
    return n(s);
  }
  function i(s) {
    return Ne(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function _9(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return Ne(s) ? Re(e, i, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : i(s);
  }
  function i(s) {
    return e.attempt(fT, t, n)(s);
  }
}
function A9(e) {
  e.exit("blockQuote");
}
const hT = {
  name: "characterEscape",
  tokenize: I9
};
function I9(e, t, n) {
  return r;
  function r(i) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(i), e.exit("escapeMarker"), o;
  }
  function o(i) {
    return fR(i) ? (e.enter("characterEscapeValue"), e.consume(i), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(i);
  }
}
const pT = {
  name: "characterReference",
  tokenize: N9
};
function N9(e, t, n) {
  const r = this;
  let o = 0, i, s;
  return a;
  function a(d) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), l;
  }
  function l(d) {
    return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), i = 31, s = Pt, u(d));
  }
  function c(d) {
    return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), i = 6, s = dR, u) : (e.enter("characterReferenceValue"), i = 7, s = zf, u(d));
  }
  function u(d) {
    if (d === 59 && o) {
      const f = e.exit("characterReferenceValue");
      return s === Pt && !jp(r.sliceSerialize(f)) ? n(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(d) && o++ < i ? (e.consume(d), u) : n(d);
  }
}
const u1 = {
  partial: !0,
  tokenize: L9
}, d1 = {
  concrete: !0,
  name: "codeFenced",
  tokenize: M9
};
function M9(e, t, n) {
  const r = this, o = {
    partial: !0,
    tokenize: w
  };
  let i = 0, s = 0, a;
  return l;
  function l(T) {
    return c(T);
  }
  function c(T) {
    const M = r.events[r.events.length - 1];
    return i = M && M[1].type === "linePrefix" ? M[2].sliceSerialize(M[1], !0).length : 0, a = T, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), u(T);
  }
  function u(T) {
    return T === a ? (s++, e.consume(T), u) : s < 3 ? n(T) : (e.exit("codeFencedFenceSequence"), Ne(T) ? Re(e, d, "whitespace")(T) : d(T));
  }
  function d(T) {
    return T === null || oe(T) ? (e.exit("codeFencedFence"), r.interrupt ? t(T) : e.check(u1, m, _)(T)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), f(T));
  }
  function f(T) {
    return T === null || oe(T) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(T)) : Ne(T) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Re(e, h, "whitespace")(T)) : T === 96 && T === a ? n(T) : (e.consume(T), f);
  }
  function h(T) {
    return T === null || oe(T) ? d(T) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), p(T));
  }
  function p(T) {
    return T === null || oe(T) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(T)) : T === 96 && T === a ? n(T) : (e.consume(T), p);
  }
  function m(T) {
    return e.attempt(o, _, b)(T);
  }
  function b(T) {
    return e.enter("lineEnding"), e.consume(T), e.exit("lineEnding"), y;
  }
  function y(T) {
    return i > 0 && Ne(T) ? Re(e, k, "linePrefix", i + 1)(T) : k(T);
  }
  function k(T) {
    return T === null || oe(T) ? e.check(u1, m, _)(T) : (e.enter("codeFlowValue"), C(T));
  }
  function C(T) {
    return T === null || oe(T) ? (e.exit("codeFlowValue"), k(T)) : (e.consume(T), C);
  }
  function _(T) {
    return e.exit("codeFenced"), t(T);
  }
  function w(T, M, D) {
    let R = 0;
    return N;
    function N(H) {
      return T.enter("lineEnding"), T.consume(H), T.exit("lineEnding"), B;
    }
    function B(H) {
      return T.enter("codeFencedFence"), Ne(H) ? Re(T, F, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(H) : F(H);
    }
    function F(H) {
      return H === a ? (T.enter("codeFencedFenceSequence"), W(H)) : D(H);
    }
    function W(H) {
      return H === a ? (R++, T.consume(H), W) : R >= s ? (T.exit("codeFencedFenceSequence"), Ne(H) ? Re(T, L, "whitespace")(H) : L(H)) : D(H);
    }
    function L(H) {
      return H === null || oe(H) ? (T.exit("codeFencedFence"), M(H)) : D(H);
    }
  }
}
function L9(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i);
  }
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const xd = {
  name: "codeIndented",
  tokenize: D9
}, O9 = {
  partial: !0,
  tokenize: R9
};
function D9(e, t, n) {
  const r = this;
  return o;
  function o(c) {
    return e.enter("codeIndented"), Re(e, i, "linePrefix", 5)(c);
  }
  function i(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? s(c) : n(c);
  }
  function s(c) {
    return c === null ? l(c) : oe(c) ? e.attempt(O9, s, l)(c) : (e.enter("codeFlowValue"), a(c));
  }
  function a(c) {
    return c === null || oe(c) ? (e.exit("codeFlowValue"), s(c)) : (e.consume(c), a);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function R9(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : oe(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o) : Re(e, i, "linePrefix", 5)(s);
  }
  function i(s) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : oe(s) ? o(s) : n(s);
  }
}
const P9 = {
  name: "codeText",
  previous: $9,
  resolve: B9,
  tokenize: H9
};
function B9(e) {
  let t = e.length - 4, n = 3, r, o;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    o === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (o = r) : (r === t || e[r][1].type === "lineEnding") && (e[o][1].type = "codeTextData", r !== o + 2 && (e[o][1].end = e[r - 1][1].end, e.splice(o + 2, r - o - 2), t -= r - o - 2, r = o + 2), o = void 0);
  return e;
}
function $9(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function H9(e, t, n) {
  let r = 0, o, i;
  return s;
  function s(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), a(d);
  }
  function a(d) {
    return d === 96 ? (e.consume(d), r++, a) : (e.exit("codeTextSequence"), l(d));
  }
  function l(d) {
    return d === null ? n(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), l) : d === 96 ? (i = e.enter("codeTextSequence"), o = 0, u(d)) : oe(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), l) : (e.enter("codeTextData"), c(d));
  }
  function c(d) {
    return d === null || d === 32 || d === 96 || oe(d) ? (e.exit("codeTextData"), l(d)) : (e.consume(d), c);
  }
  function u(d) {
    return d === 96 ? (e.consume(d), o++, u) : o === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (i.type = "codeTextData", c(d));
  }
}
class F9 {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const o = n || 0;
    this.setCursor(Math.trunc(t));
    const i = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
    return r && cs(this.left, r), i.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), cs(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), cs(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        cs(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        cs(this.left, n.reverse());
      }
  }
}
function cs(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function mT(e) {
  const t = {};
  let n = -1, r, o, i, s, a, l, c;
  const u = new F9(e);
  for (; ++n < u.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = u.get(n), n && r[1].type === "chunkFlow" && u.get(n - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, i = 0, i < l.length && l[i][1].type === "lineEndingBlank" && (i += 2), i < l.length && l[i][1].type === "content"))
      for (; ++i < l.length && l[i][1].type !== "content"; )
        l[i][1].type === "chunkText" && (l[i][1]._isInFirstContentOfListItem = !0, i++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, U9(u, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (i = n, o = void 0; i--; )
        if (s = u.get(i), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (o && (u.get(o)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", o = i);
        else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break;
      o && (r[1].end = {
        ...u.get(o)[1].start
      }, a = u.slice(o, n), a.unshift(r), u.splice(o, n - o + 1, a));
    }
  }
  return En(e, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function U9(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let o = t - 1;
  const i = [];
  let s = n._tokenizer;
  s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0));
  const a = s.events, l = [], c = {};
  let u, d, f = -1, h = n, p = 0, m = 0;
  const b = [m];
  for (; h; ) {
    for (; e.get(++o)[1] !== h; )
      ;
    i.push(o), h._tokenizer || (u = r.sliceStream(h), h.next || u.push(null), d && s.defineSkip(h.start), h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(u), h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), d = h, h = h.next;
  }
  for (h = n; ++f < a.length; )
    // Find a void token that includes a break.
    a[f][0] === "exit" && a[f - 1][0] === "enter" && a[f][1].type === a[f - 1][1].type && a[f][1].start.line !== a[f][1].end.line && (m = f + 1, b.push(m), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (s.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : b.pop(), f = b.length; f--; ) {
    const y = a.slice(b[f], b[f + 1]), k = i.pop();
    l.push([k, k + y.length - 1]), e.splice(k, 2, y);
  }
  for (l.reverse(), f = -1; ++f < l.length; )
    c[p + l[f][0]] = p + l[f][1], p += l[f][1] - l[f][0] - 1;
  return c;
}
const j9 = {
  resolve: z9,
  tokenize: q9
}, V9 = {
  partial: !0,
  tokenize: W9
};
function z9(e) {
  return mT(e), e;
}
function q9(e, t) {
  let n;
  return r;
  function r(a) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), o(a);
  }
  function o(a) {
    return a === null ? i(a) : oe(a) ? e.check(V9, s, i)(a) : (e.consume(a), o);
  }
  function i(a) {
    return e.exit("chunkContent"), e.exit("content"), t(a);
  }
  function s(a) {
    return e.consume(a), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, o;
  }
}
function W9(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Re(e, i, "linePrefix");
  }
  function i(s) {
    if (s === null || oe(s))
      return n(s);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function gT(e, t, n, r, o, i, s, a, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let u = 0;
  return d;
  function d(y) {
    return y === 60 ? (e.enter(r), e.enter(o), e.enter(i), e.consume(y), e.exit(i), f) : y === null || y === 32 || y === 41 || sc(y) ? n(y) : (e.enter(r), e.enter(s), e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), m(y));
  }
  function f(y) {
    return y === 62 ? (e.enter(i), e.consume(y), e.exit(i), e.exit(o), e.exit(r), t) : (e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), h(y));
  }
  function h(y) {
    return y === 62 ? (e.exit("chunkString"), e.exit(a), f(y)) : y === null || y === 60 || oe(y) ? n(y) : (e.consume(y), y === 92 ? p : h);
  }
  function p(y) {
    return y === 60 || y === 62 || y === 92 ? (e.consume(y), h) : h(y);
  }
  function m(y) {
    return !u && (y === null || y === 41 || Ye(y)) ? (e.exit("chunkString"), e.exit(a), e.exit(s), e.exit(r), t(y)) : u < c && y === 40 ? (e.consume(y), u++, m) : y === 41 ? (e.consume(y), u--, m) : y === null || y === 32 || y === 40 || sc(y) ? n(y) : (e.consume(y), y === 92 ? b : m);
  }
  function b(y) {
    return y === 40 || y === 41 || y === 92 ? (e.consume(y), m) : m(y);
  }
}
function bT(e, t, n, r, o, i) {
  const s = this;
  let a = 0, l;
  return c;
  function c(h) {
    return e.enter(r), e.enter(o), e.consume(h), e.exit(o), e.enter(i), u;
  }
  function u(h) {
    return a > 999 || h === null || h === 91 || h === 93 && !l || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    h === 94 && !a && "_hiddenFootnoteSupport" in s.parser.constructs ? n(h) : h === 93 ? (e.exit(i), e.enter(o), e.consume(h), e.exit(o), e.exit(r), t) : oe(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), u) : (e.enter("chunkString", {
      contentType: "string"
    }), d(h));
  }
  function d(h) {
    return h === null || h === 91 || h === 93 || oe(h) || a++ > 999 ? (e.exit("chunkString"), u(h)) : (e.consume(h), l || (l = !Ne(h)), h === 92 ? f : d);
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), a++, d) : d(h);
  }
}
function yT(e, t, n, r, o, i) {
  let s;
  return a;
  function a(f) {
    return f === 34 || f === 39 || f === 40 ? (e.enter(r), e.enter(o), e.consume(f), e.exit(o), s = f === 40 ? 41 : f, l) : n(f);
  }
  function l(f) {
    return f === s ? (e.enter(o), e.consume(f), e.exit(o), e.exit(r), t) : (e.enter(i), c(f));
  }
  function c(f) {
    return f === s ? (e.exit(i), l(s)) : f === null ? n(f) : oe(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), Re(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), u(f));
  }
  function u(f) {
    return f === s || f === null || oe(f) ? (e.exit("chunkString"), c(f)) : (e.consume(f), f === 92 ? d : u);
  }
  function d(f) {
    return f === s || f === 92 ? (e.consume(f), u) : u(f);
  }
}
function _s(e, t) {
  let n;
  return r;
  function r(o) {
    return oe(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), n = !0, r) : Ne(o) ? Re(e, r, n ? "linePrefix" : "lineSuffix")(o) : t(o);
  }
}
const G9 = {
  name: "definition",
  tokenize: K9
}, Y9 = {
  partial: !0,
  tokenize: Q9
};
function K9(e, t, n) {
  const r = this;
  let o;
  return i;
  function i(h) {
    return e.enter("definition"), s(h);
  }
  function s(h) {
    return bT.call(
      r,
      e,
      a,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(h);
  }
  function a(h) {
    return o = Wn(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), l) : n(h);
  }
  function l(h) {
    return Ye(h) ? _s(e, c)(h) : c(h);
  }
  function c(h) {
    return gT(
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(h);
  }
  function u(h) {
    return e.attempt(Y9, d, d)(h);
  }
  function d(h) {
    return Ne(h) ? Re(e, f, "whitespace")(h) : f(h);
  }
  function f(h) {
    return h === null || oe(h) ? (e.exit("definition"), r.parser.defined.push(o), t(h)) : n(h);
  }
}
function Q9(e, t, n) {
  return r;
  function r(a) {
    return Ye(a) ? _s(e, o)(a) : n(a);
  }
  function o(a) {
    return yT(e, i, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a);
  }
  function i(a) {
    return Ne(a) ? Re(e, s, "whitespace")(a) : s(a);
  }
  function s(a) {
    return a === null || oe(a) ? t(a) : n(a);
  }
}
const Z9 = {
  name: "hardBreakEscape",
  tokenize: X9
};
function X9(e, t, n) {
  return r;
  function r(i) {
    return e.enter("hardBreakEscape"), e.consume(i), o;
  }
  function o(i) {
    return oe(i) ? (e.exit("hardBreakEscape"), t(i)) : n(i);
  }
}
const J9 = {
  name: "headingAtx",
  resolve: e7,
  tokenize: t7
};
function e7(e, t) {
  let n = e.length - 2, r = 3, o, i;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (o = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, i = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, En(e, r, n - r + 1, [["enter", o, t], ["enter", i, t], ["exit", i, t], ["exit", o, t]])), e;
}
function t7(e, t, n) {
  let r = 0;
  return o;
  function o(u) {
    return e.enter("atxHeading"), i(u);
  }
  function i(u) {
    return e.enter("atxHeadingSequence"), s(u);
  }
  function s(u) {
    return u === 35 && r++ < 6 ? (e.consume(u), s) : u === null || Ye(u) ? (e.exit("atxHeadingSequence"), a(u)) : n(u);
  }
  function a(u) {
    return u === 35 ? (e.enter("atxHeadingSequence"), l(u)) : u === null || oe(u) ? (e.exit("atxHeading"), t(u)) : Ne(u) ? Re(e, a, "whitespace")(u) : (e.enter("atxHeadingText"), c(u));
  }
  function l(u) {
    return u === 35 ? (e.consume(u), l) : (e.exit("atxHeadingSequence"), a(u));
  }
  function c(u) {
    return u === null || u === 35 || Ye(u) ? (e.exit("atxHeadingText"), a(u)) : (e.consume(u), c);
  }
}
const n7 = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], f1 = ["pre", "script", "style", "textarea"], r7 = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: s7,
  tokenize: a7
}, o7 = {
  partial: !0,
  tokenize: c7
}, i7 = {
  partial: !0,
  tokenize: l7
};
function s7(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function a7(e, t, n) {
  const r = this;
  let o, i, s, a, l;
  return c;
  function c(A) {
    return u(A);
  }
  function u(A) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(A), d;
  }
  function d(A) {
    return A === 33 ? (e.consume(A), f) : A === 47 ? (e.consume(A), i = !0, m) : A === 63 ? (e.consume(A), o = 3, r.interrupt ? t : S) : qt(A) ? (e.consume(A), s = String.fromCharCode(A), b) : n(A);
  }
  function f(A) {
    return A === 45 ? (e.consume(A), o = 2, h) : A === 91 ? (e.consume(A), o = 5, a = 0, p) : qt(A) ? (e.consume(A), o = 4, r.interrupt ? t : S) : n(A);
  }
  function h(A) {
    return A === 45 ? (e.consume(A), r.interrupt ? t : S) : n(A);
  }
  function p(A) {
    const le = "CDATA[";
    return A === le.charCodeAt(a++) ? (e.consume(A), a === le.length ? r.interrupt ? t : F : p) : n(A);
  }
  function m(A) {
    return qt(A) ? (e.consume(A), s = String.fromCharCode(A), b) : n(A);
  }
  function b(A) {
    if (A === null || A === 47 || A === 62 || Ye(A)) {
      const le = A === 47, ge = s.toLowerCase();
      return !le && !i && f1.includes(ge) ? (o = 1, r.interrupt ? t(A) : F(A)) : n7.includes(s.toLowerCase()) ? (o = 6, le ? (e.consume(A), y) : r.interrupt ? t(A) : F(A)) : (o = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(A) : i ? k(A) : C(A));
    }
    return A === 45 || Pt(A) ? (e.consume(A), s += String.fromCharCode(A), b) : n(A);
  }
  function y(A) {
    return A === 62 ? (e.consume(A), r.interrupt ? t : F) : n(A);
  }
  function k(A) {
    return Ne(A) ? (e.consume(A), k) : N(A);
  }
  function C(A) {
    return A === 47 ? (e.consume(A), N) : A === 58 || A === 95 || qt(A) ? (e.consume(A), _) : Ne(A) ? (e.consume(A), C) : N(A);
  }
  function _(A) {
    return A === 45 || A === 46 || A === 58 || A === 95 || Pt(A) ? (e.consume(A), _) : w(A);
  }
  function w(A) {
    return A === 61 ? (e.consume(A), T) : Ne(A) ? (e.consume(A), w) : C(A);
  }
  function T(A) {
    return A === null || A === 60 || A === 61 || A === 62 || A === 96 ? n(A) : A === 34 || A === 39 ? (e.consume(A), l = A, M) : Ne(A) ? (e.consume(A), T) : D(A);
  }
  function M(A) {
    return A === l ? (e.consume(A), l = null, R) : A === null || oe(A) ? n(A) : (e.consume(A), M);
  }
  function D(A) {
    return A === null || A === 34 || A === 39 || A === 47 || A === 60 || A === 61 || A === 62 || A === 96 || Ye(A) ? w(A) : (e.consume(A), D);
  }
  function R(A) {
    return A === 47 || A === 62 || Ne(A) ? C(A) : n(A);
  }
  function N(A) {
    return A === 62 ? (e.consume(A), B) : n(A);
  }
  function B(A) {
    return A === null || oe(A) ? F(A) : Ne(A) ? (e.consume(A), B) : n(A);
  }
  function F(A) {
    return A === 45 && o === 2 ? (e.consume(A), J) : A === 60 && o === 1 ? (e.consume(A), Y) : A === 62 && o === 4 ? (e.consume(A), ue) : A === 63 && o === 3 ? (e.consume(A), S) : A === 93 && o === 5 ? (e.consume(A), Q) : oe(A) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(o7, ee, W)(A)) : A === null || oe(A) ? (e.exit("htmlFlowData"), W(A)) : (e.consume(A), F);
  }
  function W(A) {
    return e.check(i7, L, ee)(A);
  }
  function L(A) {
    return e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), H;
  }
  function H(A) {
    return A === null || oe(A) ? W(A) : (e.enter("htmlFlowData"), F(A));
  }
  function J(A) {
    return A === 45 ? (e.consume(A), S) : F(A);
  }
  function Y(A) {
    return A === 47 ? (e.consume(A), s = "", V) : F(A);
  }
  function V(A) {
    if (A === 62) {
      const le = s.toLowerCase();
      return f1.includes(le) ? (e.consume(A), ue) : F(A);
    }
    return qt(A) && s.length < 8 ? (e.consume(A), s += String.fromCharCode(A), V) : F(A);
  }
  function Q(A) {
    return A === 93 ? (e.consume(A), S) : F(A);
  }
  function S(A) {
    return A === 62 ? (e.consume(A), ue) : A === 45 && o === 2 ? (e.consume(A), S) : F(A);
  }
  function ue(A) {
    return A === null || oe(A) ? (e.exit("htmlFlowData"), ee(A)) : (e.consume(A), ue);
  }
  function ee(A) {
    return e.exit("htmlFlow"), t(A);
  }
}
function l7(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return oe(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : n(s);
  }
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function c7(e, t, n) {
  return r;
  function r(o) {
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(ya, t, n);
  }
}
const u7 = {
  name: "htmlText",
  tokenize: d7
};
function d7(e, t, n) {
  const r = this;
  let o, i, s;
  return a;
  function a(S) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(S), l;
  }
  function l(S) {
    return S === 33 ? (e.consume(S), c) : S === 47 ? (e.consume(S), w) : S === 63 ? (e.consume(S), C) : qt(S) ? (e.consume(S), D) : n(S);
  }
  function c(S) {
    return S === 45 ? (e.consume(S), u) : S === 91 ? (e.consume(S), i = 0, p) : qt(S) ? (e.consume(S), k) : n(S);
  }
  function u(S) {
    return S === 45 ? (e.consume(S), h) : n(S);
  }
  function d(S) {
    return S === null ? n(S) : S === 45 ? (e.consume(S), f) : oe(S) ? (s = d, Y(S)) : (e.consume(S), d);
  }
  function f(S) {
    return S === 45 ? (e.consume(S), h) : d(S);
  }
  function h(S) {
    return S === 62 ? J(S) : S === 45 ? f(S) : d(S);
  }
  function p(S) {
    const ue = "CDATA[";
    return S === ue.charCodeAt(i++) ? (e.consume(S), i === ue.length ? m : p) : n(S);
  }
  function m(S) {
    return S === null ? n(S) : S === 93 ? (e.consume(S), b) : oe(S) ? (s = m, Y(S)) : (e.consume(S), m);
  }
  function b(S) {
    return S === 93 ? (e.consume(S), y) : m(S);
  }
  function y(S) {
    return S === 62 ? J(S) : S === 93 ? (e.consume(S), y) : m(S);
  }
  function k(S) {
    return S === null || S === 62 ? J(S) : oe(S) ? (s = k, Y(S)) : (e.consume(S), k);
  }
  function C(S) {
    return S === null ? n(S) : S === 63 ? (e.consume(S), _) : oe(S) ? (s = C, Y(S)) : (e.consume(S), C);
  }
  function _(S) {
    return S === 62 ? J(S) : C(S);
  }
  function w(S) {
    return qt(S) ? (e.consume(S), T) : n(S);
  }
  function T(S) {
    return S === 45 || Pt(S) ? (e.consume(S), T) : M(S);
  }
  function M(S) {
    return oe(S) ? (s = M, Y(S)) : Ne(S) ? (e.consume(S), M) : J(S);
  }
  function D(S) {
    return S === 45 || Pt(S) ? (e.consume(S), D) : S === 47 || S === 62 || Ye(S) ? R(S) : n(S);
  }
  function R(S) {
    return S === 47 ? (e.consume(S), J) : S === 58 || S === 95 || qt(S) ? (e.consume(S), N) : oe(S) ? (s = R, Y(S)) : Ne(S) ? (e.consume(S), R) : J(S);
  }
  function N(S) {
    return S === 45 || S === 46 || S === 58 || S === 95 || Pt(S) ? (e.consume(S), N) : B(S);
  }
  function B(S) {
    return S === 61 ? (e.consume(S), F) : oe(S) ? (s = B, Y(S)) : Ne(S) ? (e.consume(S), B) : R(S);
  }
  function F(S) {
    return S === null || S === 60 || S === 61 || S === 62 || S === 96 ? n(S) : S === 34 || S === 39 ? (e.consume(S), o = S, W) : oe(S) ? (s = F, Y(S)) : Ne(S) ? (e.consume(S), F) : (e.consume(S), L);
  }
  function W(S) {
    return S === o ? (e.consume(S), o = void 0, H) : S === null ? n(S) : oe(S) ? (s = W, Y(S)) : (e.consume(S), W);
  }
  function L(S) {
    return S === null || S === 34 || S === 39 || S === 60 || S === 61 || S === 96 ? n(S) : S === 47 || S === 62 || Ye(S) ? R(S) : (e.consume(S), L);
  }
  function H(S) {
    return S === 47 || S === 62 || Ye(S) ? R(S) : n(S);
  }
  function J(S) {
    return S === 62 ? (e.consume(S), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(S);
  }
  function Y(S) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), V;
  }
  function V(S) {
    return Ne(S) ? Re(e, Q, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(S) : Q(S);
  }
  function Q(S) {
    return e.enter("htmlTextData"), s(S);
  }
}
const zp = {
  name: "labelEnd",
  resolveAll: m7,
  resolveTo: g7,
  tokenize: b7
}, f7 = {
  tokenize: y7
}, h7 = {
  tokenize: E7
}, p7 = {
  tokenize: k7
};
function m7(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const o = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += o;
    }
  }
  return e.length !== n.length && En(e, 0, e.length, n), e;
}
function g7(e, t) {
  let n = e.length, r = 0, o, i, s, a;
  for (; n--; )
    if (o = e[n][1], i) {
      if (o.type === "link" || o.type === "labelLink" && o._inactive)
        break;
      e[n][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (i = n, o.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else o.type === "labelEnd" && (s = n);
  const l = {
    type: e[i][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[i][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...e[i][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, u = {
    type: "labelText",
    start: {
      ...e[i + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return a = [["enter", l, t], ["enter", c, t]], a = An(a, e.slice(i + 1, i + r + 3)), a = An(a, [["enter", u, t]]), a = An(a, pu(t.parser.constructs.insideSpan.null, e.slice(i + r + 4, s - 3), t)), a = An(a, [["exit", u, t], e[s - 2], e[s - 1], ["exit", c, t]]), a = An(a, e.slice(s + 1)), a = An(a, [["exit", l, t]]), En(e, i, e.length, a), e;
}
function b7(e, t, n) {
  const r = this;
  let o = r.events.length, i, s;
  for (; o--; )
    if ((r.events[o][1].type === "labelImage" || r.events[o][1].type === "labelLink") && !r.events[o][1]._balanced) {
      i = r.events[o][1];
      break;
    }
  return a;
  function a(f) {
    return i ? i._inactive ? d(f) : (s = r.parser.defined.includes(Wn(r.sliceSerialize({
      start: i.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(f), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(f);
  }
  function l(f) {
    return f === 40 ? e.attempt(f7, u, s ? u : d)(f) : f === 91 ? e.attempt(h7, u, s ? c : d)(f) : s ? u(f) : d(f);
  }
  function c(f) {
    return e.attempt(p7, u, d)(f);
  }
  function u(f) {
    return t(f);
  }
  function d(f) {
    return i._balanced = !0, n(f);
  }
}
function y7(e, t, n) {
  return r;
  function r(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), o;
  }
  function o(d) {
    return Ye(d) ? _s(e, i)(d) : i(d);
  }
  function i(d) {
    return d === 41 ? u(d) : gT(e, s, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d);
  }
  function s(d) {
    return Ye(d) ? _s(e, l)(d) : u(d);
  }
  function a(d) {
    return n(d);
  }
  function l(d) {
    return d === 34 || d === 39 || d === 40 ? yT(e, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : u(d);
  }
  function c(d) {
    return Ye(d) ? _s(e, u)(d) : u(d);
  }
  function u(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : n(d);
  }
}
function E7(e, t, n) {
  const r = this;
  return o;
  function o(a) {
    return bT.call(r, e, i, s, "reference", "referenceMarker", "referenceString")(a);
  }
  function i(a) {
    return r.parser.defined.includes(Wn(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(a) : n(a);
  }
  function s(a) {
    return n(a);
  }
}
function k7(e, t, n) {
  return r;
  function r(i) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), o;
  }
  function o(i) {
    return i === 93 ? (e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), e.exit("reference"), t) : n(i);
  }
}
const C7 = {
  name: "labelStartImage",
  resolveAll: zp.resolveAll,
  tokenize: T7
};
function T7(e, t, n) {
  const r = this;
  return o;
  function o(a) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(a), e.exit("labelImageMarker"), i;
  }
  function i(a) {
    return a === 91 ? (e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelImage"), s) : n(a);
  }
  function s(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
  }
}
const x7 = {
  name: "labelStartLink",
  resolveAll: zp.resolveAll,
  tokenize: w7
};
function w7(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), i;
  }
  function i(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const wd = {
  name: "lineEnding",
  tokenize: v7
};
function v7(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Re(e, t, "linePrefix");
  }
}
const Tl = {
  name: "thematicBreak",
  tokenize: S7
};
function S7(e, t, n) {
  let r = 0, o;
  return i;
  function i(c) {
    return e.enter("thematicBreak"), s(c);
  }
  function s(c) {
    return o = c, a(c);
  }
  function a(c) {
    return c === o ? (e.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || oe(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function l(c) {
    return c === o ? (e.consume(c), r++, l) : (e.exit("thematicBreakSequence"), Ne(c) ? Re(e, a, "whitespace")(c) : a(c));
  }
}
const Xt = {
  continuation: {
    tokenize: N7
  },
  exit: L7,
  name: "list",
  tokenize: I7
}, _7 = {
  partial: !0,
  tokenize: O7
}, A7 = {
  partial: !0,
  tokenize: M7
};
function I7(e, t, n) {
  const r = this, o = r.events[r.events.length - 1];
  let i = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, s = 0;
  return a;
  function a(h) {
    const p = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : zf(h)) {
      if (r.containerState.type || (r.containerState.type = p, e.enter(p, {
        _container: !0
      })), p === "listUnordered")
        return e.enter("listItemPrefix"), h === 42 || h === 45 ? e.check(Tl, n, c)(h) : c(h);
      if (!r.interrupt || h === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(h);
    }
    return n(h);
  }
  function l(h) {
    return zf(h) && ++s < 10 ? (e.consume(h), l) : (!r.interrupt || s < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (e.exit("listItemValue"), c(h)) : n(h);
  }
  function c(h) {
    return e.enter("listItemMarker"), e.consume(h), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, e.check(
      ya,
      // Cant be empty when interrupting.
      r.interrupt ? n : u,
      e.attempt(_7, f, d)
    );
  }
  function u(h) {
    return r.containerState.initialBlankLine = !0, i++, f(h);
  }
  function d(h) {
    return Ne(h) ? (e.enter("listItemPrefixWhitespace"), e.consume(h), e.exit("listItemPrefixWhitespace"), f) : n(h);
  }
  function f(h) {
    return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(h);
  }
}
function N7(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(ya, o, i);
  function o(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Re(e, t, "listItemIndent", r.containerState.size + 1)(a);
  }
  function i(a) {
    return r.containerState.furtherBlankLines || !Ne(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(A7, t, s)(a));
  }
  function s(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Re(e, e.attempt(Xt, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a);
  }
}
function M7(e, t, n) {
  const r = this;
  return Re(e, o, "listItemIndent", r.containerState.size + 1);
  function o(i) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(i) : n(i);
  }
}
function L7(e) {
  e.exit(this.containerState.type);
}
function O7(e, t, n) {
  const r = this;
  return Re(e, o, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function o(i) {
    const s = r.events[r.events.length - 1];
    return !Ne(i) && s && s[1].type === "listItemPrefixWhitespace" ? t(i) : n(i);
  }
}
const h1 = {
  name: "setextUnderline",
  resolveTo: D7,
  tokenize: R7
};
function D7(e, t) {
  let n = e.length, r, o, i;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (o = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !i && e[n][1].type === "definition" && (i = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[o][1].type = "setextHeadingText", i ? (e.splice(o, 0, ["enter", s, t]), e.splice(i + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[i][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function R7(e, t, n) {
  const r = this;
  let o;
  return i;
  function i(c) {
    let u = r.events.length, d;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        d = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (e.enter("setextHeadingLine"), o = c, s(c)) : n(c);
  }
  function s(c) {
    return e.enter("setextHeadingLineSequence"), a(c);
  }
  function a(c) {
    return c === o ? (e.consume(c), a) : (e.exit("setextHeadingLineSequence"), Ne(c) ? Re(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || oe(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const P7 = {
  tokenize: z7,
  partial: !0
};
function B7() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: U7,
        continuation: {
          tokenize: j7
        },
        exit: V7
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: F7
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: $7,
        resolveTo: H7
      }
    }
  };
}
function $7(e, t, n) {
  const r = this;
  let o = r.events.length;
  const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; o--; ) {
    const l = r.events[o][1];
    if (l.type === "labelImage") {
      s = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return a;
  function a(l) {
    if (!s || !s._balanced)
      return n(l);
    const c = Wn(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !i.includes(c.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function H7(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, o = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  o.end.column++, o.end.offset++, o.end._bufferIndex++;
  const i = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, o.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, i.start),
    end: Object.assign({}, i.end)
  }, a = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", o, t],
    ["exit", o, t],
    // Everything in between.
    ["enter", i, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", i, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...a), e;
}
function F7(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i = 0, s;
  return a;
  function a(d) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(d) {
    return d !== 94 ? n(d) : (e.enter("gfmFootnoteCallMarker"), e.consume(d), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(d) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      d === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d === null || d === 91 || Ye(d)
    )
      return n(d);
    if (d === 93) {
      e.exit("chunkString");
      const f = e.exit("gfmFootnoteCallString");
      return o.includes(Wn(r.sliceSerialize(f))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(d);
    }
    return Ye(d) || (s = !0), i++, e.consume(d), d === 92 ? u : c;
  }
  function u(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), i++, c) : c(d);
  }
}
function U7(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i, s = 0, a;
  return l;
  function l(p) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(p), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(p) {
    return p === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(p), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", u) : n(p);
  }
  function u(p) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      p === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || Ye(p)
    )
      return n(p);
    if (p === 93) {
      e.exit("chunkString");
      const m = e.exit("gfmFootnoteDefinitionLabelString");
      return i = Wn(r.sliceSerialize(m)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(p), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return Ye(p) || (a = !0), s++, e.consume(p), p === 92 ? d : u;
  }
  function d(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), s++, u) : u(p);
  }
  function f(p) {
    return p === 58 ? (e.enter("definitionMarker"), e.consume(p), e.exit("definitionMarker"), o.includes(i) || o.push(i), Re(e, h, "gfmFootnoteDefinitionWhitespace")) : n(p);
  }
  function h(p) {
    return t(p);
  }
}
function j7(e, t, n) {
  return e.check(ya, t, e.attempt(P7, t, n));
}
function V7(e) {
  e.exit("gfmFootnoteDefinition");
}
function z7(e, t, n) {
  const r = this;
  return Re(e, o, "gfmFootnoteDefinitionIndent", 5);
  function o(i) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(i) : n(i);
  }
}
function q7(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: i,
    resolveAll: o
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function o(s, a) {
    let l = -1;
    for (; ++l < s.length; )
      if (s[l][0] === "enter" && s[l][1].type === "strikethroughSequenceTemporary" && s[l][1]._close) {
        let c = l;
        for (; c--; )
          if (s[c][0] === "exit" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._open && // If the sizes are the same:
          s[l][1].end.offset - s[l][1].start.offset === s[c][1].end.offset - s[c][1].start.offset) {
            s[l][1].type = "strikethroughSequence", s[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, s[c][1].start),
              end: Object.assign({}, s[l][1].end)
            }, d = {
              type: "strikethroughText",
              start: Object.assign({}, s[c][1].end),
              end: Object.assign({}, s[l][1].start)
            }, f = [["enter", u, a], ["enter", s[c][1], a], ["exit", s[c][1], a], ["enter", d, a]], h = a.parser.constructs.insideSpan.null;
            h && En(f, f.length, 0, pu(h, s.slice(c + 1, l), a)), En(f, f.length, 0, [["exit", d, a], ["enter", s[l][1], a], ["exit", s[l][1], a], ["exit", u, a]]), En(s, c - 1, l - c + 3, f), l = c + f.length - 2;
            break;
          }
      }
    for (l = -1; ++l < s.length; )
      s[l][1].type === "strikethroughSequenceTemporary" && (s[l][1].type = "data");
    return s;
  }
  function i(s, a, l) {
    const c = this.previous, u = this.events;
    let d = 0;
    return f;
    function f(p) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? l(p) : (s.enter("strikethroughSequenceTemporary"), h(p));
    }
    function h(p) {
      const m = Pi(c);
      if (p === 126)
        return d > 1 ? l(p) : (s.consume(p), d++, h);
      if (d < 2 && !n) return l(p);
      const b = s.exit("strikethroughSequenceTemporary"), y = Pi(p);
      return b._open = !y || y === 2 && !!m, b._close = !m || m === 2 && !!y, a(p);
    }
  }
}
class W7 {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    G7(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(i, s) {
      return i[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let o = r.pop();
    for (; o; ) {
      for (const i of o)
        t.push(i);
      o = r.pop();
    }
    this.map.length = 0;
  }
}
function G7(e, t, n, r) {
  let o = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; o < e.map.length; ) {
      if (e.map[o][0] === t) {
        e.map[o][1] += n, e.map[o][2].push(...r);
        return;
      }
      o += 1;
    }
    e.map.push([t, n, r]);
  }
}
function Y7(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const o = e[t];
    if (n) {
      if (o[0] === "enter")
        o[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (o[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const i = r.length - 1;
          r[i] = r[i] === "left" ? "center" : "right";
        }
      } else if (o[1].type === "tableDelimiterRow")
        break;
    } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function K7() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: Q7,
        resolveAll: Z7
      }
    }
  };
}
function Q7(e, t, n) {
  const r = this;
  let o = 0, i = 0, s;
  return a;
  function a(N) {
    let B = r.events.length - 1;
    for (; B > -1; ) {
      const L = r.events[B][1].type;
      if (L === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      L === "linePrefix") B--;
      else break;
    }
    const F = B > -1 ? r.events[B][1].type : null, W = F === "tableHead" || F === "tableRow" ? T : l;
    return W === T && r.parser.lazy[r.now().line] ? n(N) : W(N);
  }
  function l(N) {
    return e.enter("tableHead"), e.enter("tableRow"), c(N);
  }
  function c(N) {
    return N === 124 || (s = !0, i += 1), u(N);
  }
  function u(N) {
    return N === null ? n(N) : oe(N) ? i > 1 ? (i = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(N), e.exit("lineEnding"), h) : n(N) : Ne(N) ? Re(e, u, "whitespace")(N) : (i += 1, s && (s = !1, o += 1), N === 124 ? (e.enter("tableCellDivider"), e.consume(N), e.exit("tableCellDivider"), s = !0, u) : (e.enter("data"), d(N)));
  }
  function d(N) {
    return N === null || N === 124 || Ye(N) ? (e.exit("data"), u(N)) : (e.consume(N), N === 92 ? f : d);
  }
  function f(N) {
    return N === 92 || N === 124 ? (e.consume(N), d) : d(N);
  }
  function h(N) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(N) : (e.enter("tableDelimiterRow"), s = !1, Ne(N) ? Re(e, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(N) : p(N));
  }
  function p(N) {
    return N === 45 || N === 58 ? b(N) : N === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(N), e.exit("tableCellDivider"), m) : w(N);
  }
  function m(N) {
    return Ne(N) ? Re(e, b, "whitespace")(N) : b(N);
  }
  function b(N) {
    return N === 58 ? (i += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(N), e.exit("tableDelimiterMarker"), y) : N === 45 ? (i += 1, y(N)) : N === null || oe(N) ? _(N) : w(N);
  }
  function y(N) {
    return N === 45 ? (e.enter("tableDelimiterFiller"), k(N)) : w(N);
  }
  function k(N) {
    return N === 45 ? (e.consume(N), k) : N === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(N), e.exit("tableDelimiterMarker"), C) : (e.exit("tableDelimiterFiller"), C(N));
  }
  function C(N) {
    return Ne(N) ? Re(e, _, "whitespace")(N) : _(N);
  }
  function _(N) {
    return N === 124 ? p(N) : N === null || oe(N) ? !s || o !== i ? w(N) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(N)) : w(N);
  }
  function w(N) {
    return n(N);
  }
  function T(N) {
    return e.enter("tableRow"), M(N);
  }
  function M(N) {
    return N === 124 ? (e.enter("tableCellDivider"), e.consume(N), e.exit("tableCellDivider"), M) : N === null || oe(N) ? (e.exit("tableRow"), t(N)) : Ne(N) ? Re(e, M, "whitespace")(N) : (e.enter("data"), D(N));
  }
  function D(N) {
    return N === null || N === 124 || Ye(N) ? (e.exit("data"), M(N)) : (e.consume(N), N === 92 ? R : D);
  }
  function R(N) {
    return N === 92 || N === 124 ? (e.consume(N), D) : D(N);
  }
}
function Z7(e, t) {
  let n = -1, r = !0, o = 0, i = [0, 0, 0, 0], s = [0, 0, 0, 0], a = !1, l = 0, c, u, d;
  const f = new W7();
  for (; ++n < e.length; ) {
    const h = e[n], p = h[1];
    h[0] === "enter" ? p.type === "tableHead" ? (a = !1, l !== 0 && (p1(f, t, l, c, u), u = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(n, 0, [["enter", c, t]])) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (r = !0, d = void 0, i = [0, 0, 0, 0], s = [0, n + 1, 0, 0], a && (a = !1, u = {
      type: "tableBody",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(n, 0, [["enter", u, t]])), o = p.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : o && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (i[1] !== 0 && (s[0] = s[1], d = Ya(f, t, i, o, void 0, d), i = [0, 0, 0, 0]), s[2] = n)) : p.type === "tableCellDivider" && (r ? r = !1 : (i[1] !== 0 && (s[0] = s[1], d = Ya(f, t, i, o, void 0, d)), i = s, s = [i[1], n, 0, 0])) : p.type === "tableHead" ? (a = !0, l = n) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (l = n, i[1] !== 0 ? (s[0] = s[1], d = Ya(f, t, i, o, n, d)) : s[1] !== 0 && (d = Ya(f, t, s, o, n, d)), o = 0) : o && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (l !== 0 && p1(f, t, l, c, u), f.consume(t.events), n = -1; ++n < t.events.length; ) {
    const h = t.events[n];
    h[0] === "enter" && h[1].type === "table" && (h[1]._align = Y7(t.events, n));
  }
  return e;
}
function Ya(e, t, n, r, o, i) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", a = "tableContent";
  n[0] !== 0 && (i.end = Object.assign({}, di(t.events, n[0])), e.add(n[0], 0, [["exit", i, t]]));
  const l = di(t.events, n[1]);
  if (i = {
    type: s,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", i, t]]), n[2] !== 0) {
    const c = di(t.events, n[2]), u = di(t.events, n[3]), d = {
      type: a,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (e.add(n[2], 0, [["enter", d, t]]), r !== 2) {
      const f = t.events[n[2]], h = t.events[n[3]];
      if (f[1].end = Object.assign({}, h[1].end), f[1].type = "chunkText", f[1].contentType = "text", n[3] > n[2] + 1) {
        const p = n[2] + 1, m = n[3] - n[2] - 1;
        e.add(p, m, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", d, t]]);
  }
  return o !== void 0 && (i.end = Object.assign({}, di(t.events, o)), e.add(o, 0, [["exit", i, t]]), i = void 0), i;
}
function p1(e, t, n, r, o) {
  const i = [], s = di(t.events, n);
  o && (o.end = Object.assign({}, s), i.push(["exit", o, t])), r.end = Object.assign({}, s), i.push(["exit", r, t]), e.add(n + 1, 0, i);
}
function di(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const X7 = {
  name: "tasklistCheck",
  tokenize: eB
};
function J7() {
  return {
    text: {
      91: X7
    }
  };
}
function eB(e, t, n) {
  const r = this;
  return o;
  function o(l) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), i)
    );
  }
  function i(l) {
    return Ye(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), s) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), s) : n(l);
  }
  function s(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), a) : n(l);
  }
  function a(l) {
    return oe(l) ? t(l) : Ne(l) ? e.check({
      tokenize: tB
    }, t, n)(l) : n(l);
  }
}
function tB(e, t, n) {
  return Re(e, r, "whitespace");
  function r(o) {
    return o === null ? n(o) : t(o);
  }
}
function nB(e) {
  return rT([
    f9(),
    B7(),
    q7(e),
    K7(),
    J7()
  ]);
}
const rB = {};
function ET(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || rB, r = t.data(), o = r.micromarkExtensions || (r.micromarkExtensions = []), i = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  o.push(nB(n)), i.push(s9()), s.push(a9(n));
}
function oB(e) {
  const t = this;
  t.compiler = n;
  function n(r) {
    return jP(r, {
      ...t.data("settings"),
      ...e,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("toMarkdownExtensions") || []
    });
  }
}
function m1(e) {
  if (e)
    throw e;
}
var xl = Object.prototype.hasOwnProperty, kT = Object.prototype.toString, g1 = Object.defineProperty, b1 = Object.getOwnPropertyDescriptor, y1 = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : kT.call(t) === "[object Array]";
}, E1 = function(t) {
  if (!t || kT.call(t) !== "[object Object]")
    return !1;
  var n = xl.call(t, "constructor"), r = t.constructor && t.constructor.prototype && xl.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var o;
  for (o in t)
    ;
  return typeof o > "u" || xl.call(t, o);
}, k1 = function(t, n) {
  g1 && n.name === "__proto__" ? g1(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, C1 = function(t, n) {
  if (n === "__proto__")
    if (xl.call(t, n)) {
      if (b1)
        return b1(t, n).value;
    } else return;
  return t[n];
}, iB = function e() {
  var t, n, r, o, i, s, a = arguments[0], l = 1, c = arguments.length, u = !1;
  for (typeof a == "boolean" && (u = a, a = arguments[1] || {}, l = 2), (a == null || typeof a != "object" && typeof a != "function") && (a = {}); l < c; ++l)
    if (t = arguments[l], t != null)
      for (n in t)
        r = C1(a, n), o = C1(t, n), a !== o && (u && o && (E1(o) || (i = y1(o))) ? (i ? (i = !1, s = r && y1(r) ? r : []) : s = r && E1(r) ? r : {}, k1(a, { name: n, newValue: e(u, s, o) })) : typeof o < "u" && k1(a, { name: n, newValue: o }));
  return a;
};
const vd = /* @__PURE__ */ Oy(iB);
function Yf(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function sB() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...o) {
    let i = -1;
    const s = o.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    a(null, ...o);
    function a(l, ...c) {
      const u = e[++i];
      let d = -1;
      if (l) {
        s(l);
        return;
      }
      for (; ++d < o.length; )
        (c[d] === null || c[d] === void 0) && (c[d] = o[d]);
      o = c, u ? aB(u, a)(...c) : s(null, ...c);
    }
  }
  function r(o) {
    if (typeof o != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + o
      );
    return e.push(o), t;
  }
}
function aB(e, t) {
  let n;
  return r;
  function r(...s) {
    const a = e.length > s.length;
    let l;
    a && s.push(o);
    try {
      l = e.apply(this, s);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (a && n)
        throw u;
      return o(u);
    }
    a || (l && l.then && typeof l.then == "function" ? l.then(i, o) : l instanceof Error ? o(l) : i(l));
  }
  function o(s, ...a) {
    n || (n = !0, t(s, ...a));
  }
  function i(s) {
    o(null, s);
  }
}
const lB = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), o = r[e], i = function() {
      return o.apply(i, arguments);
    };
    return Object.setPrototypeOf(i, r), i;
  }
), cB = {}.hasOwnProperty;
class qp extends lB {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = sB();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new qp()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(vd(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Ad("data", this.frozen), this.namespace[t] = n, this) : cB.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Ad("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const o = n.call(t, ...r);
      typeof o == "function" && this.transformers.use(o);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Ka(t), r = this.parser || this.Parser;
    return Sd("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), Sd("process", this.parser || this.Parser), _d("process", this.compiler || this.Compiler), n ? o(void 0, n) : new Promise(o);
    function o(i, s) {
      const a = Ka(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(a)
      );
      r.run(l, a, function(u, d, f) {
        if (u || !d || !f)
          return c(u);
        const h = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), p = r.stringify(h, f);
        dB(p) ? f.value = p : f.result = p, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          f
        );
      });
      function c(u, d) {
        u || !d ? s(u) : i ? i(d) : n(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), Sd("processSync", this.parser || this.Parser), _d("processSync", this.compiler || this.Compiler), this.process(t, o), x1("processSync", "process", n), r;
    function o(i, s) {
      n = !0, m1(i), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    T1(t), this.freeze();
    const o = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? i(void 0, r) : new Promise(i);
    function i(s, a) {
      const l = Ka(n);
      o.run(t, l, c);
      function c(u, d, f) {
        const h = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || t
        );
        u ? a(u) : s ? s(h) : r(void 0, h, f);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, o;
    return this.run(t, n, i), x1("runSync", "run", r), o;
    function i(s, a) {
      m1(s), o = a, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Ka(n), o = this.compiler || this.Compiler;
    return _d("stringify", o), T1(t), o(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, o = this.namespace;
    if (Ad("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? a(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function i(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(u, d);
        } else
          s(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function s(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      a(c.plugins), c.settings && (o.settings = vd(!0, o.settings, c.settings));
    }
    function a(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const d = c[u];
          i(d);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, u) {
      let d = -1, f = -1;
      for (; ++d < r.length; )
        if (r[d][0] === c) {
          f = d;
          break;
        }
      if (f === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [h, ...p] = u;
        const m = r[f][1];
        Yf(m) && Yf(h) && (h = vd(!0, m, h)), r[f] = [c, h, ...p];
      }
    }
  }
}
const CT = new qp().freeze();
function Sd(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function _d(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Ad(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function T1(e) {
  if (!Yf(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function x1(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Ka(e) {
  return uB(e) ? e : new jf(e);
}
function uB(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function dB(e) {
  return typeof e == "string" || fB(e);
}
function fB(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
function hB(e, t) {
  return TT(e, {}) || { type: "root", children: [] };
}
function TT(e, t) {
  const n = pB(e, t);
  return n && t.afterTransform && t.afterTransform(e, n), n;
}
function pB(e, t) {
  switch (e.nodeType) {
    case 1:
      return yB(
        /** @type {Element} */
        e,
        t
      );
    case 3:
      return gB(
        /** @type {Text} */
        e
      );
    case 8:
      return bB(
        /** @type {Comment} */
        e
      );
    case 9:
      return w1(
        /** @type {Document} */
        e,
        t
      );
    case 10:
      return mB();
    case 11:
      return w1(
        /** @type {DocumentFragment} */
        e,
        t
      );
    default:
      return;
  }
}
function w1(e, t) {
  return { type: "root", children: xT(e, t) };
}
function mB() {
  return { type: "doctype" };
}
function gB(e) {
  return { type: "text", value: e.nodeValue || "" };
}
function bB(e) {
  return { type: "comment", value: e.nodeValue || "" };
}
function yB(e, t) {
  const n = e.namespaceURI, r = n === El.svg ? N2 : I2, o = n === El.html ? e.tagName.toLowerCase() : e.tagName, i = (
    // @ts-expect-error: DOM types are wrong, content can exist.
    n === El.html && o === "template" ? e.content : e
  ), s = e.getAttributeNames(), a = {};
  let l = -1;
  for (; ++l < s.length; )
    a[s[l]] = e.getAttribute(s[l]) || "";
  return r(o, a, xT(i, t));
}
function xT(e, t) {
  const n = e.childNodes, r = [];
  let o = -1;
  for (; ++o < n.length; ) {
    const i = TT(n[o], t);
    i !== void 0 && r.push(i);
  }
  return r;
}
var EB = Object.defineProperty, kB = (e, t, n) => t in e ? EB(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Ue = (e, t, n) => kB(e, typeof t != "symbol" ? t + "" : t, n);
function wT(e) {
  const t = Array.from(e.classList).filter(
    (n) => !n.startsWith("bn-")
  ) || [];
  t.length > 0 ? e.className = t.join(" ") : e.removeAttribute("class");
}
function vT(e, t, n, r) {
  var o;
  let i;
  if (t)
    if (typeof t == "string")
      i = Gn([t], e.pmSchema);
    else if (Array.isArray(t))
      i = Gn(t, e.pmSchema);
    else if (t.type === "tableContent")
      i = Hc(t, e.pmSchema);
    else
      throw new br(t.type);
  else throw new Error("blockContent is required");
  const s = ((r == null ? void 0 : r.document) ?? document).createDocumentFragment();
  for (const a of i)
    if (a.type.name !== "text" && e.schema.inlineContentSchema[a.type.name]) {
      const l = e.schema.inlineContentSpecs[a.type.name].implementation;
      if (l) {
        const c = Hh(
          a,
          e.schema.inlineContentSchema,
          e.schema.styleSchema
        ), u = l.toExternalHTML ? l.toExternalHTML(
          c,
          e
        ) : l.render.call(
          {
            renderType: "dom",
            props: void 0
          },
          c,
          () => {
          },
          e
        );
        if (u) {
          if (s.appendChild(u.dom), u.contentDOM) {
            const d = n.serializeFragment(
              a.content,
              r
            );
            u.contentDOM.dataset.editable = "", u.contentDOM.appendChild(d);
          }
          continue;
        }
      }
    } else if (a.type.name === "text") {
      let l = document.createTextNode(
        a.textContent
      );
      for (const c of a.marks.toReversed())
        if (c.type.name in e.schema.styleSpecs) {
          const u = (e.schema.styleSpecs[c.type.name].implementation.toExternalHTML ?? e.schema.styleSpecs[c.type.name].implementation.render)(c.attrs.stringValue, e);
          u.contentDOM.appendChild(l), l = u.dom;
        } else {
          const u = c.type.spec.toDOM(c, !0), d = Po.renderSpec(document, u);
          d.contentDOM.appendChild(l), l = d.dom;
        }
      s.appendChild(l);
    } else {
      const l = n.serializeFragment(
        be.from([a]),
        r
      );
      s.appendChild(l);
    }
  return s.childNodes.length === 1 && ((o = s.firstChild) == null ? void 0 : o.nodeType) === 1 && wT(s.firstChild), s;
}
function CB(e, t, n, r, o, i, s, a) {
  var l, c, u, d, f, h, p, m, b;
  const y = (a == null ? void 0 : a.document) ?? document, k = t.pmSchema.nodes.blockContainer, C = n.props || {};
  for (const [N, B] of Object.entries(
    t.schema.blockSchema[n.type].propSchema
  ))
    !(N in C) && B.default !== void 0 && (C[N] = B.default);
  const _ = (c = (l = k.spec) == null ? void 0 : l.toDOM) == null ? void 0 : c.call(
    l,
    k.create({
      id: n.id,
      ...C
    })
  ), w = Array.from(_.dom.attributes), T = t.blockImplementations[n.type].implementation, M = ((u = T.toExternalHTML) == null ? void 0 : u.call(
    {},
    { ...n, props: C },
    t,
    {
      nestingLevel: s
    }
  )) || T.render.call(
    {},
    { ...n, props: C },
    t
  ), D = y.createDocumentFragment();
  if (M.dom.classList.contains("bn-block-content")) {
    const N = [
      ...w,
      ...Array.from(M.dom.attributes)
    ].filter(
      (B) => B.name.startsWith("data") && B.name !== "data-content-type" && B.name !== "data-file-block" && B.name !== "data-node-view-wrapper" && B.name !== "data-node-type" && B.name !== "data-id" && B.name !== "data-editable"
    );
    for (const B of N)
      M.dom.firstChild.setAttribute(B.name, B.value);
    wT(M.dom.firstChild), s > 0 && M.dom.firstChild.setAttribute(
      "data-nesting-level",
      s.toString()
    ), D.append(...Array.from(M.dom.childNodes));
  } else
    D.append(M.dom), s > 0 && M.dom.setAttribute(
      "data-nesting-level",
      s.toString()
    );
  if (M.contentDOM && n.content) {
    const N = vT(
      t,
      n.content,
      // TODO
      r,
      a
    );
    M.contentDOM.appendChild(N);
  }
  let R;
  if (o.has(n.type) ? R = "OL" : i.has(n.type) && (R = "UL"), R) {
    if (((d = e.lastChild) == null ? void 0 : d.nodeName) !== R) {
      const N = y.createElement(R);
      R === "OL" && "start" in C && C.start && (C == null ? void 0 : C.start) !== 1 && N.setAttribute("start", C.start + ""), e.append(N);
    }
    e.lastChild.appendChild(D);
  } else
    e.append(D);
  if (n.children && n.children.length > 0) {
    const N = y.createDocumentFragment();
    if (ST(
      N,
      t,
      n.children,
      r,
      o,
      i,
      s + 1,
      a
    ), ((f = e.lastChild) == null ? void 0 : f.nodeName) === "UL" || ((h = e.lastChild) == null ? void 0 : h.nodeName) === "OL")
      for (; ((p = N.firstChild) == null ? void 0 : p.nodeName) === "UL" || ((m = N.firstChild) == null ? void 0 : m.nodeName) === "OL"; )
        e.lastChild.lastChild.appendChild(N.firstChild);
    t.pmSchema.nodes[n.type].isInGroup("blockContent") ? e.append(N) : (b = M.contentDOM) == null || b.append(N);
  }
}
const ST = (e, t, n, r, o, i, s = 0, a) => {
  for (const l of n)
    CB(
      e,
      t,
      l,
      r,
      o,
      i,
      s,
      a
    );
}, TB = (e, t, n, r, o, i) => {
  const s = ((i == null ? void 0 : i.document) ?? document).createDocumentFragment();
  return ST(
    s,
    e,
    t,
    n,
    r,
    o,
    0,
    i
  ), s;
}, mu = (e, t) => {
  const n = Po.fromSchema(e);
  return {
    exportBlocks: (r, o) => {
      const i = TB(
        t,
        r,
        n,
        /* @__PURE__ */ new Set(["numberedListItem"]),
        /* @__PURE__ */ new Set(["bulletListItem", "checkListItem", "toggleListItem"]),
        o
      ), s = document.createElement("div");
      return s.append(i), s.innerHTML;
    },
    exportInlineContent: (r, o) => {
      const i = vT(
        t,
        r,
        n,
        o
      ), s = document.createElement("div");
      return s.append(i.cloneNode(!0)), s.innerHTML;
    }
  };
};
function xB(e, t) {
  if (t === 0)
    return;
  const n = e.resolve(t);
  for (let r = n.depth; r > 0; r--) {
    const o = n.node(r);
    if (yp(o))
      return o.attrs.id;
  }
}
function wB(e) {
  return e.getMeta("paste") ? { type: "paste" } : e.getMeta("uiEvent") === "drop" ? { type: "drop" } : e.getMeta("history$") ? {
    type: e.getMeta("history$").redo ? "redo" : "undo"
  } : e.getMeta("y-sync$") ? e.getMeta("y-sync$").isUndoRedoOperation ? { type: "undo-redo" } : { type: "yjs-remote" } : { type: "local" };
}
function v1(e) {
  const t = "__root__", n = {}, r = {}, o = ht(e);
  return e.descendants((i, s) => {
    if (!yp(i))
      return !0;
    const a = xB(e, s), l = a ?? t;
    r[l] || (r[l] = []);
    const c = ct(i, o);
    return n[i.attrs.id] = { block: c, parentId: a }, r[l].push(i.attrs.id), !0;
  }), { byId: n, childrenByParent: r };
}
function vB(e, t) {
  const n = /* @__PURE__ */ new Set();
  if (!e || !t)
    return n;
  const r = new Set(e), o = t.filter((m) => r.has(m)), i = e.filter(
    (m) => o.includes(m)
  );
  if (i.length <= 1 || o.length <= 1)
    return n;
  const s = {};
  for (let m = 0; m < i.length; m++)
    s[i[m]] = m;
  const a = o.map((m) => s[m]), l = a.length, c = [], u = [], d = new Array(l).fill(-1), f = (m, b) => {
    let y = 0, k = m.length;
    for (; y < k; ) {
      const C = y + k >>> 1;
      m[C] < b ? y = C + 1 : k = C;
    }
    return y;
  };
  for (let m = 0; m < l; m++) {
    const b = a[m], y = f(c, b);
    y > 0 && (d[m] = u[y - 1]), y === c.length ? (c.push(b), u.push(m)) : (c[y] = b, u[y] = m);
  }
  const h = /* @__PURE__ */ new Set();
  let p = u[u.length - 1] ?? -1;
  for (; p !== -1; )
    h.add(p), p = d[p];
  for (let m = 0; m < o.length; m++)
    h.has(m) || n.add(o[m]);
  return n;
}
function _T(e, t = []) {
  const n = wB(e), r = Oc(e.before, [
    e,
    ...t
  ]), o = v1(
    r.before
  ), i = v1(
    r.doc
  ), s = [], a = /* @__PURE__ */ new Set();
  Object.keys(i.byId).filter((h) => !(h in o.byId)).forEach((h) => {
    s.push({
      type: "insert",
      block: i.byId[h].block,
      source: n,
      prevBlock: void 0
    }), a.add(h);
  }), Object.keys(o.byId).filter((h) => !(h in i.byId)).forEach((h) => {
    s.push({
      type: "delete",
      block: o.byId[h].block,
      source: n,
      prevBlock: void 0
    }), a.add(h);
  }), Object.keys(i.byId).filter((h) => h in o.byId).forEach((h) => {
    var p, m;
    const b = o.byId[h], y = i.byId[h];
    b.parentId !== y.parentId ? (s.push({
      type: "move",
      block: y.block,
      prevBlock: b.block,
      source: n,
      prevParent: b.parentId ? (p = o.byId[b.parentId]) == null ? void 0 : p.block : void 0,
      currentParent: y.parentId ? (m = i.byId[y.parentId]) == null ? void 0 : m.block : void 0
    }), a.add(h)) : hL(
      { ...b.block, children: void 0 },
      { ...y.block, children: void 0 }
    ) || (s.push({
      type: "update",
      block: y.block,
      prevBlock: b.block,
      source: n
    }), a.add(h));
  });
  const l = o.childrenByParent, c = i.childrenByParent, u = "__root__", d = /* @__PURE__ */ new Set([
    ...Object.keys(l),
    ...Object.keys(c)
  ]), f = /* @__PURE__ */ new Set();
  return d.forEach((h) => {
    const p = vB(
      l[h],
      c[h]
    );
    p.size !== 0 && p.forEach((m) => {
      var b, y;
      const k = o.byId[m], C = i.byId[m];
      !k || !C || k.parentId !== C.parentId || a.has(m) || (k.parentId ?? u) !== h || f.has(m) || (f.add(m), s.push({
        type: "move",
        block: C.block,
        prevBlock: k.block,
        source: n,
        prevParent: k.parentId ? (b = o.byId[k.parentId]) == null ? void 0 : b.block : void 0,
        currentParent: C.parentId ? (y = i.byId[C.parentId]) == null ? void 0 : y.block : void 0
      }), a.add(m));
    });
  }), s;
}
const AT = He(() => {
  const e = [];
  return {
    key: "blockChange",
    prosemirrorPlugins: [
      new me({
        key: new we("blockChange"),
        filterTransaction: (t) => {
          let n;
          return e.reduce((r, o) => r === !1 ? r : o({
            getChanges() {
              return n || (n = _T(t), n);
            },
            tr: t
          }) !== !1, !0);
        }
      })
    ],
    /**
     * Subscribe to the block change events.
     */
    subscribe(t) {
      return e.push(t), () => {
        e.splice(
          e.indexOf(t),
          1
        );
      };
    }
  };
});
function S1(e) {
  const t = e.charAt(0) === "#" ? e.substring(1, 7) : e, n = parseInt(t.substring(0, 2), 16), r = parseInt(t.substring(2, 4), 16), o = parseInt(t.substring(4, 6), 16), i = [n / 255, r / 255, o / 255].map((s) => s <= 0.03928 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4));
  return 0.2126 * i[0] + 0.7152 * i[1] + 0.0722 * i[2] <= 0.179;
}
function SB(e) {
  const t = document.createElement("span");
  t.classList.add("bn-collaboration-cursor__base");
  const n = document.createElement("span");
  n.setAttribute("contentedEditable", "false"), n.classList.add("bn-collaboration-cursor__caret"), n.setAttribute(
    "style",
    `background-color: ${e.color}; color: ${S1(e.color) ? "white" : "black"}`
  );
  const r = document.createElement("span");
  return r.classList.add("bn-collaboration-cursor__label"), r.setAttribute(
    "style",
    `background-color: ${e.color}; color: ${S1(e.color) ? "white" : "black"}`
  ), r.insertBefore(document.createTextNode(e.name), null), n.insertBefore(r, null), t.insertBefore(document.createTextNode(""), null), t.insertBefore(n, null), t.insertBefore(document.createTextNode(""), null), t;
}
const Kf = He(
  ({ options: e }) => {
    const t = /* @__PURE__ */ new Map(), n = e.provider && "awareness" in e.provider && typeof e.provider.awareness == "object" ? e.provider.awareness : void 0;
    return n && ("setLocalStateField" in n && typeof n.setLocalStateField == "function" && n.setLocalStateField("user", e.user), "on" in n && typeof n.on == "function" && e.showCursorLabels !== "always" && n.on(
      "change",
      ({
        updated: r
      }) => {
        for (const o of r) {
          const i = t.get(o);
          i && (i.element.setAttribute("data-active", ""), i.hideTimeout && clearTimeout(i.hideTimeout), t.set(o, {
            element: i.element,
            hideTimeout: setTimeout(() => {
              i.element.removeAttribute("data-active");
            }, 2e3)
          }));
        }
      }
    )), {
      key: "yCursor",
      prosemirrorPlugins: [
        n ? Q4(n, {
          selectionBuilder: i2,
          cursorBuilder(r, o) {
            let i = t.get(o);
            if (!i) {
              const s = (e.renderCursor ?? SB)(r);
              e.showCursorLabels !== "always" && (s.addEventListener("mouseenter", () => {
                const a = t.get(o);
                a.element.setAttribute("data-active", ""), a.hideTimeout && (clearTimeout(a.hideTimeout), t.set(o, {
                  element: a.element,
                  hideTimeout: void 0
                }));
              }), s.addEventListener("mouseleave", () => {
                const a = t.get(o);
                t.set(o, {
                  element: a.element,
                  hideTimeout: setTimeout(() => {
                    a.element.removeAttribute("data-active");
                  }, 2e3)
                });
              })), i = {
                element: s,
                hideTimeout: void 0
              }, t.set(o, i);
            }
            return i.element;
          }
        }) : void 0
      ].filter(Boolean),
      dependsOn: ["ySync"],
      updateUser(r) {
        n == null || n.setLocalStateField("user", r);
      }
    };
  }
), wl = He(
  ({ options: e }) => ({
    key: "ySync",
    prosemirrorPlugins: [D4(e.fragment)],
    runsBefore: ["default"]
  })
), vl = He(() => ({
  key: "yUndo",
  prosemirrorPlugins: [rM()],
  dependsOn: ["yCursor", "ySync"],
  undoCommand: J4,
  redoCommand: eM
}));
function _B(e, t) {
  const n = e.doc;
  if (e._item === null) {
    const r = Array.from(n.share.keys()).find(
      (o) => n.share.get(o) === e
    );
    if (r == null)
      throw new Error("type does not exist in other ydoc");
    return t.get(r, e.constructor);
  } else {
    const r = e._item, o = t.store.clients.get(r.id.client) ?? [], i = Bn(o, r.id.clock);
    return o[i].content.type;
  }
}
const AB = He(
  ({ editor: e, options: t }) => {
    let n;
    const r = yo({ isForked: !1 });
    return {
      key: "yForkDoc",
      store: r,
      /**
       * Fork the Y.js document from syncing to the remote,
       * allowing modifications to the document without affecting the remote.
       * These changes can later be rolled back or applied to the remote.
       */
      fork() {
        if (n)
          return;
        const o = t.fragment;
        if (!o)
          throw new Error("No fragment to fork from");
        const i = new bo();
        O0(i, D0(o.doc));
        const s = _B(o, i);
        n = {
          undoStack: pr.getState(e.prosemirrorState).undoManager.undoStack,
          originalFragment: o,
          forkedFragment: s
        }, e.unregisterExtension([
          vl,
          Kf,
          wl
        ]);
        const a = {
          ...t,
          fragment: s
        };
        e.registerExtension([
          wl(a),
          // No need to register the cursor plugin again, it's a local fork
          vl()
        ]), r.setState({ isForked: !0 });
      },
      /**
       * Resume syncing the Y.js document to the remote
       * If `keepChanges` is true, any changes that have been made to the forked document will be applied to the original document.
       * Otherwise, the original document will be restored and the changes will be discarded.
       */
      merge({ keepChanges: o }) {
        if (!n)
          return;
        e.unregisterExtension(["ySync", "yCursor", "yUndo"]);
        const { originalFragment: i, forkedFragment: s, undoStack: a } = n;
        if (e.registerExtension([
          wl(t),
          Kf(t),
          vl()
        ]), pr.getState(
          e.prosemirrorState
        ).undoManager.undoStack = a, o) {
          const l = D0(
            s.doc,
            dN(i.doc)
          );
          O0(i.doc, l, e);
        }
        n = void 0, r.setState({ isForked: !1 });
      }
    };
  }
), IT = (e, t) => {
  t(e), e.forEach((n) => {
    n instanceof Nt && IT(n, t);
  });
}, IB = (e, t) => {
  const n = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    r instanceof Nt && IT(r, (o) => {
      if (o.nodeName === "blockContainer" && o.hasAttribute("id")) {
        const i = o.getAttribute("textColor"), s = o.getAttribute("backgroundColor"), a = {
          textColor: i === $e.textColor.default ? void 0 : i,
          backgroundColor: s === $e.backgroundColor.default ? void 0 : s
        };
        (a.textColor || a.backgroundColor) && n.set(o.getAttribute("id"), a);
      }
    });
  }), n.size === 0 ? !1 : (t.doc.descendants((r, o) => {
    if (r.type.name === "blockContainer" && n.has(r.attrs.id)) {
      const i = t.doc.nodeAt(o + 1);
      if (!i)
        throw new Error("No element found");
      t.setNodeMarkup(o + 1, void 0, {
        // preserve existing attributes
        ...i.attrs,
        // add the textColor and backgroundColor attributes
        ...n.get(r.attrs.id)
      });
    }
  }), !0);
}, NB = [IB], MB = He(
  ({ options: e }) => {
    let t = !1;
    const n = new we("schemaMigration");
    return {
      key: "schemaMigration",
      prosemirrorPlugins: [
        new me({
          key: n,
          appendTransaction: (r, o, i) => {
            if (t || // If any of the transactions are not due to a yjs sync, we don't need to run the migration
            !r.some((a) => a.getMeta("y-sync$")) || // If none of the transactions result in a document change, we don't need to run the migration
            r.every((a) => !a.docChanged) || // If the fragment is still empty, we can't run the migration (since it has not yet been applied to the Y.Doc)
            !e.fragment.firstChild)
              return;
            const s = i.tr;
            for (const a of NB)
              a(e.fragment, s);
            if (t = !0, !!s.docChanged)
              return s;
          }
        })
      ]
    };
  }
), LB = He(
  ({
    editor: e,
    options: t
  }) => ({
    key: "dropCursor",
    prosemirrorPlugins: [
      (t.dropCursor ?? bv)({
        width: 5,
        color: "#ddeeff",
        editor: e
      })
    ]
  })
), ho = He(({ editor: e }) => {
  const t = yo(!1), n = () => e.transact((r) => {
    var o;
    if (r.selection.empty || r.selection instanceof cn && (r.selection.node.type.spec.content === "inline*" || ((o = r.selection.node.firstChild) == null ? void 0 : o.type.spec.content) === "inline*") || r.selection instanceof pe && r.doc.textBetween(r.selection.from, r.selection.to).length === 0)
      return !1;
    let i = !1;
    return r.selection.content().content.descendants((s) => (s.type.spec.code && (i = !0), !i)), !i;
  });
  return {
    key: "formattingToolbar",
    store: t,
    mount({ dom: r, signal: o }) {
      let i = !1;
      const s = e.onChange(() => {
        i || t.setState(n());
      }), a = e.onSelectionChange(() => {
        i || t.setState(n());
      });
      r.addEventListener(
        "pointerdown",
        () => {
          i = !0, t.setState(!1);
        },
        { signal: o }
      ), e.prosemirrorView.root.addEventListener(
        "pointerup",
        () => {
          i = !1, e.isFocused() && t.setState(n());
        },
        { signal: o, capture: !0 }
      ), r.addEventListener(
        "pointercancel",
        () => {
          i = !1;
        },
        {
          signal: o,
          capture: !0
        }
      ), o.addEventListener("abort", () => {
        s(), a();
      });
    }
  };
}), OB = He(() => ({
  key: "history",
  prosemirrorPlugins: [yv()],
  undoCommand: Ev,
  redoCommand: kv
})), Ea = He(({ editor: e }) => {
  function t(o) {
    let i = e.prosemirrorView.nodeDOM(o);
    for (; i && i.parentElement; ) {
      if (i.nodeName === "A")
        return i;
      i = i.parentElement;
    }
    return null;
  }
  function n(o, i) {
    return e.transact((s) => {
      const a = s.doc.resolve(o), l = a.marks().find((u) => u.type.name === i);
      if (!l)
        return;
      const c = Mc(a, l.type);
      if (c)
        return {
          range: c,
          mark: l,
          get text() {
            return s.doc.textBetween(c.from, c.to);
          },
          get position() {
            return rE(
              e.prosemirrorView,
              c.from,
              c.to
            ).toJSON();
          }
        };
    });
  }
  function r() {
    return e.transact((o) => {
      const i = o.selection;
      if (i.empty)
        return n(i.anchor, "link");
    });
  }
  return {
    key: "linkToolbar",
    getLinkAtSelection: r,
    getLinkElementAtPos: t,
    getMarkAtPos: n,
    getLinkAtElement(o) {
      return e.transact(() => {
        const i = e.prosemirrorView.posAtDOM(o, 0) + 1;
        return n(i, "link");
      });
    },
    editLink(o, i, s = e.transact((a) => a.selection.anchor)) {
      e.transact((a) => {
        const l = ht(a), { range: c } = n(s + 1, "link") || {
          range: {
            from: a.selection.from,
            to: a.selection.to
          }
        };
        c && (a.insertText(i, c.from, c.to), a.addMark(
          c.from,
          c.from + i.length,
          l.mark("link", { href: o })
        ));
      }), e.prosemirrorView.focus();
    },
    deleteLink(o = e.transact((i) => i.selection.anchor)) {
      e.transact((i) => {
        const s = ht(i), { range: a } = n(o + 1, "link") || {
          range: {
            from: i.selection.from,
            to: i.selection.to
          }
        };
        a && i.removeMark(a.from, a.to, s.marks.link).setMeta(
          "preventAutolink",
          !0
        );
      }), e.prosemirrorView.focus();
    }
  };
}), NT = [
  "http",
  "https",
  "ftp",
  "ftps",
  "mailto",
  "tel",
  "callto",
  "sms",
  "cid",
  "xmpp"
], MT = "https", DB = new we("node-selection-keyboard"), RB = He(
  () => ({
    key: "nodeSelectionKeyboard",
    prosemirrorPlugins: [
      new me({
        key: DB,
        props: {
          handleKeyDown: (e, t) => {
            if ("node" in e.state.selection) {
              if (t.ctrlKey || t.metaKey)
                return !1;
              if (t.key.length === 1)
                return t.preventDefault(), !0;
              if (t.key === "Enter" && !t.isComposing && !t.shiftKey && !t.altKey && !t.ctrlKey && !t.metaKey) {
                const n = e.state.tr;
                return e.dispatch(
                  n.insert(
                    e.state.tr.selection.$to.after(),
                    e.state.schema.nodes.paragraph.createChecked()
                  ).setSelection(
                    new pe(
                      n.doc.resolve(
                        e.state.tr.selection.$to.after() + 1
                      )
                    )
                  )
                ), !0;
              }
            }
            return !1;
          }
        }
      })
    ]
  })
), PB = new we("blocknote-placeholder"), BB = He(
  ({
    editor: e,
    options: t
  }) => {
    const n = t.placeholders;
    return {
      key: "placeholder",
      prosemirrorPlugins: [
        new me({
          key: PB,
          view: (r) => {
            const o = `placeholder-selector-${EE()}`;
            r.dom.classList.add(o);
            const i = document.createElement("style"), s = e._tiptapEditor.options.injectNonce;
            s && i.setAttribute("nonce", s), r.root instanceof window.ShadowRoot ? r.root.append(i) : r.root.head.appendChild(i);
            const a = i.sheet, l = (c = "") => `.${o} .bn-block-content${c} .bn-inline-content:has(> .ProseMirror-trailingBreak:only-child):before`;
            try {
              const {
                default: c,
                emptyDocument: u,
                ...d
              } = n || {};
              for (const [p, m] of Object.entries(d)) {
                const b = `[data-content-type="${p}"]`;
                a.insertRule(
                  `${l(b)} { content: ${JSON.stringify(
                    m
                  )}; }`
                );
              }
              a.insertRule(
                `${l("[data-is-only-empty-block]")} { content: ${JSON.stringify(
                  u
                )}; }`
              ), a.insertRule(
                `${l("[data-is-empty-and-focused]")} { content: ${JSON.stringify(
                  c
                )}; }`
              );
            } catch (c) {
              console.warn(
                "Failed to insert placeholder CSS rule - this is likely due to the browser not supporting certain CSS pseudo-element selectors (:has, :only-child:, or :before)",
                c
              );
            }
            return {
              destroy: () => {
                r.root instanceof window.ShadowRoot ? r.root.removeChild(i) : r.root.head.removeChild(i);
              }
            };
          },
          props: {
            decorations: (r) => {
              const { doc: o, selection: i } = r;
              if (!e.isEditable || !i.empty || i.$from.parent.type.spec.code)
                return;
              const s = [];
              r.doc.content.size === 6 && s.push(
                Lt.node(2, 4, {
                  "data-is-only-empty-block": "true"
                })
              );
              const a = i.$anchor, l = a.parent;
              if (l.content.size === 0) {
                const c = a.before();
                s.push(
                  Lt.node(c, c + l.nodeSize, {
                    "data-is-empty-and-focused": "true"
                  })
                );
              }
              return kt.create(o, s);
            }
          }
        })
      ]
    };
  }
), _1 = new we("previous-blocks"), $B = {
  // Numbered List Items
  index: "index",
  // Headings
  level: "level",
  // All Blocks
  type: "type",
  depth: "depth",
  "depth-change": "depth-change"
}, HB = He(() => {
  let e;
  return {
    key: "previousBlockType",
    prosemirrorPlugins: [
      new me({
        key: _1,
        view(t) {
          return {
            update: async (n, r) => {
              var o;
              ((o = this.key) == null ? void 0 : o.getState(n.state).updatedBlocks.size) > 0 && (e = setTimeout(() => {
                n.dispatch(
                  n.state.tr.setMeta(_1, { clearUpdate: !0 })
                );
              }, 0));
            },
            destroy: () => {
              e && clearTimeout(e);
            }
          };
        },
        state: {
          init() {
            return {
              // Block attributes, by block ID, from just before the previous transaction.
              prevTransactionOldBlockAttrs: {},
              // Block attributes, by block ID, from just before the current transaction.
              currentTransactionOldBlockAttrs: {},
              // Set of IDs of blocks whose attributes changed from the current transaction.
              updatedBlocks: /* @__PURE__ */ new Set()
            };
          },
          apply(t, n, r, o) {
            if (n.currentTransactionOldBlockAttrs = {}, n.updatedBlocks.clear(), !t.docChanged || r.doc.eq(o.doc))
              return n;
            const i = {}, s = e0(
              r.doc,
              (c) => c.attrs.id
            ), a = new Map(
              s.map((c) => [c.node.attrs.id, c])
            ), l = e0(
              o.doc,
              (c) => c.attrs.id
            );
            for (const c of l) {
              const u = a.get(c.node.attrs.id), d = u == null ? void 0 : u.node.firstChild, f = c.node.firstChild;
              if (u && d && f) {
                const h = {
                  index: f.attrs.index,
                  level: f.attrs.level,
                  type: f.type.name,
                  depth: o.doc.resolve(c.pos).depth
                }, p = {
                  index: d.attrs.index,
                  level: d.attrs.level,
                  type: d.type.name,
                  depth: r.doc.resolve(u.pos).depth
                };
                i[c.node.attrs.id] = p, n.currentTransactionOldBlockAttrs[c.node.attrs.id] = p, JSON.stringify(p) !== JSON.stringify(h) && (p["depth-change"] = p.depth - h.depth, n.updatedBlocks.add(c.node.attrs.id));
              }
            }
            return n.prevTransactionOldBlockAttrs = i, n;
          }
        },
        props: {
          decorations(t) {
            const n = this.getState(t);
            if (n.updatedBlocks.size === 0)
              return;
            const r = [];
            return t.doc.descendants((o, i) => {
              if (!o.attrs.id || !n.updatedBlocks.has(o.attrs.id))
                return;
              const s = n.currentTransactionOldBlockAttrs[o.attrs.id], a = {};
              for (const [c, u] of Object.entries(s))
                a["data-prev-" + $B[c]] = u || "none";
              const l = Lt.node(i, i + o.nodeSize, {
                ...a
              });
              r.push(l);
            }), kt.create(t.doc, r);
          }
        }
      })
    ]
  };
});
function LT(e, t) {
  for (var n, r; e && e.parentElement && e.parentElement !== t.dom && ((n = e.getAttribute) == null ? void 0 : n.call(e, "data-node-type")) !== "blockContainer"; )
    e = e.parentElement;
  if (((r = e.getAttribute) == null ? void 0 : r.call(e, "data-node-type")) === "blockContainer")
    return { node: e, id: e.getAttribute("data-id") };
}
function FB() {
  const e = (t) => {
    let n = t.children.length;
    for (let r = 0; r < n; r++) {
      const o = t.children[r];
      if (o.type === "element" && (e(o), o.tagName === "u"))
        if (o.children.length > 0) {
          t.children.splice(r, 1, ...o.children);
          const i = o.children.length - 1;
          n += i, r += i;
        } else
          t.children.splice(r, 1), n--, r--;
    }
  };
  return e;
}
function UB() {
  const e = (t) => {
    var n;
    if (t.children && "length" in t.children && t.children.length)
      for (let r = t.children.length - 1; r >= 0; r--) {
        const o = t.children[r], i = r + 1 < t.children.length ? t.children[r + 1] : void 0;
        o.type === "element" && o.tagName === "input" && ((n = o.properties) == null ? void 0 : n.type) === "checkbox" && (i == null ? void 0 : i.type) === "element" && i.tagName === "p" ? (i.tagName = "span", i.children.splice(
          0,
          0,
          hB(document.createTextNode(" "))
        )) : e(o);
      }
  };
  return e;
}
function jB() {
  return (e) => {
    Go(e, "element", (t, n, r) => {
      var o, i, s, a;
      if (r && t.tagName === "video") {
        const l = ((o = t.properties) == null ? void 0 : o.src) || ((i = t.properties) == null ? void 0 : i["data-url"]) || "", c = ((s = t.properties) == null ? void 0 : s.title) || ((a = t.properties) == null ? void 0 : a["data-name"]) || "";
        r.children[n] = {
          type: "text",
          value: `![${c}](${l})`
        };
      }
    });
  };
}
function Wp(e) {
  return CT().use(O8, { fragment: !0 }).use(jB).use(FB).use(UB).use(cR).use(ET).use(oB, {
    handlers: { text: (t) => t.value }
  }).processSync(e).value;
}
function VB(e, t, n, r) {
  const o = mu(t, n).exportBlocks(e, r);
  return Wp(o);
}
function OT(e) {
  const t = [];
  return e.descendants((n) => {
    var r, o;
    const i = ht(n);
    return n.type.name === "blockContainer" && ((r = n.firstChild) == null ? void 0 : r.type.name) === "blockGroup" ? !0 : n.type.name === "columnList" && n.childCount === 1 ? ((o = n.firstChild) == null || o.forEach((s) => {
      t.push(ct(s, i));
    }), !1) : n.type.isInGroup("bnBlock") ? (t.push(ct(n, i)), !1) : !0;
  }), t;
}
let Qf = class Sl extends ot {
  constructor(t, n) {
    super(t, n), Ue(this, "nodes");
    const r = t.node();
    this.nodes = [], t.doc.nodesBetween(t.pos, n.pos, (o, i, s) => {
      if (s !== null && s.eq(r))
        return this.nodes.push(o), !1;
    });
  }
  static create(t, n, r = n) {
    return new Sl(t.resolve(n), t.resolve(r));
  }
  content() {
    return new lt(be.from(this.nodes), 0, 0);
  }
  eq(t) {
    if (!(t instanceof Sl) || this.nodes.length !== t.nodes.length || this.from !== t.from || this.to !== t.to)
      return !1;
    for (let n = 0; n < this.nodes.length; n++)
      if (!this.nodes[n].eq(t.nodes[n]))
        return !1;
    return !0;
  }
  map(t, n) {
    const r = n.mapResult(this.from), o = n.mapResult(this.to);
    return o.deleted ? ot.near(t.resolve(r.pos)) : r.deleted ? ot.near(t.resolve(o.pos)) : new Sl(
      t.resolve(r.pos),
      t.resolve(o.pos)
    );
  }
  toJSON() {
    return { type: "multiple-node", anchor: this.anchor, head: this.head };
  }
};
ot.jsonID("multiple-node", Qf);
let jn;
function zB(e, t) {
  let n, r;
  const o = t.resolve(e.from).node().type.spec.group === "blockContent", i = t.resolve(e.to).node().type.spec.group === "blockContent", s = Math.min(e.$anchor.depth, e.$head.depth);
  if (o && i) {
    const a = e.$from.start(s - 1), l = e.$to.end(s - 1);
    n = t.resolve(a - 1).pos, r = t.resolve(l + 1).pos;
  } else
    n = e.from, r = e.to;
  return { from: n, to: r };
}
function A1(e, t, n = t) {
  t === n && (n += e.state.doc.resolve(t + 1).node().nodeSize);
  const r = e.domAtPos(t).node.cloneNode(!0), o = e.domAtPos(t).node, i = (u, d) => Array.prototype.indexOf.call(u.children, d), s = i(
    o,
    // Expects from position to be just before the first selected block.
    e.domAtPos(t + 1).node.parentElement
  ), a = i(
    o,
    // Expects to position to be just after the last selected block.
    e.domAtPos(n - 1).node.parentElement
  );
  for (let u = o.childElementCount - 1; u >= 0; u--)
    (u > a || u < s) && r.removeChild(r.children[u]);
  DT(e.root), jn = r;
  const l = jn.getElementsByTagName("iframe");
  for (let u = 0; u < l.length; u++) {
    const d = l[u], f = d.parentElement;
    f && f.removeChild(d);
  }
  const c = e.dom.className.split(" ").filter(
    (u) => u !== "ProseMirror" && u !== "bn-root" && u !== "bn-editor"
  ).join(" ");
  jn.className = jn.className + " bn-drag-preview " + c, e.root instanceof ShadowRoot ? e.root.appendChild(jn) : e.root.body.appendChild(jn);
}
function DT(e) {
  jn !== void 0 && (e instanceof ShadowRoot ? e.removeChild(jn) : e.body.removeChild(jn), jn = void 0);
}
function qB(e, t, n) {
  if (!e.dataTransfer || n.headless)
    return;
  const r = n.prosemirrorView, o = Yt(t.id, r.state.doc);
  if (!o)
    throw new Error(`Block with ID ${t.id} not found`);
  const i = o.posBeforeNode;
  if (i != null) {
    const s = r.state.selection, a = r.state.doc, { from: l, to: c } = zB(s, a), u = l <= i && i < c, d = s.$anchor.node() !== s.$head.node() || s instanceof Qf;
    u && d ? (r.dispatch(
      r.state.tr.setSelection(Qf.create(a, l, c))
    ), A1(r, l, c)) : (r.dispatch(
      r.state.tr.setSelection(cn.create(r.state.doc, i))
    ), A1(r, i));
    const f = r.state.selection.content(), h = n.pmSchema, p = r.serializeForClipboard(f).dom.innerHTML, m = mu(h, n), b = OT(f.content), y = m.exportBlocks(b, {}), k = Wp(y);
    e.dataTransfer.clearData(), e.dataTransfer.setData("blocknote/html", p), e.dataTransfer.setData("text/html", y), e.dataTransfer.setData("text/plain", k), e.dataTransfer.effectAllowed = "move", e.dataTransfer.setDragImage(jn, 0, 0);
  }
}
const I1 = 250;
function Zf(e, t, n = !0) {
  const r = e.root.elementsFromPoint(t.left, t.top);
  for (const o of r)
    if (e.dom.contains(o))
      return n && o.closest("[data-node-type=columnList]") ? Zf(
        e,
        {
          // TODO can we do better than this?
          left: t.left + 50,
          // bit hacky, but if we're inside a column, offset x position to right to account for the width of sidemenu itself
          top: t.top
        },
        !1
      ) : LT(o, e);
}
function WB(e, t) {
  if (!t.dom.firstChild)
    return;
  const n = t.dom.firstChild.getBoundingClientRect(), r = {
    // Clamps the x position to the editor's bounding box.
    left: Math.min(
      Math.max(n.left + 10, e.x),
      n.right - 10
    ),
    top: e.y
  }, o = Zf(t, r);
  if (!o)
    return;
  const i = o.node.getBoundingClientRect();
  return Zf(
    t,
    {
      left: i.right - 10,
      top: e.y
    },
    !1
  );
}
let GB = class {
  constructor(t, n, r) {
    Ue(this, "state"), Ue(this, "emitUpdate"), Ue(this, "mousePos"), Ue(this, "hoveredBlock"), Ue(this, "menuFrozen", !1), Ue(this, "isDragOrigin", !1), Ue(this, "updateState", (o) => {
      this.state = o, this.emitUpdate(this.state);
    }), Ue(this, "updateStateFromMousePos", () => {
      var o, i, s, a, l;
      if (this.menuFrozen || !this.mousePos)
        return;
      const c = this.findClosestEditorElement({
        clientX: this.mousePos.x,
        clientY: this.mousePos.y
      });
      if ((c == null ? void 0 : c.element) !== this.pmView.dom || c.distance > I1) {
        (o = this.state) != null && o.show && (this.state.show = !1, this.updateState(this.state));
        return;
      }
      const u = WB(this.mousePos, this.pmView);
      if (!u || !this.editor.isEditable) {
        (i = this.state) != null && i.show && (this.state.show = !1, this.updateState(this.state));
        return;
      }
      if (!((s = this.state) != null && s.show && (a = this.hoveredBlock) != null && a.hasAttribute("data-id") && ((l = this.hoveredBlock) == null ? void 0 : l.getAttribute("data-id")) === u.id) && (this.hoveredBlock = u.node, this.editor.isEditable)) {
        const d = u.node.getBoundingClientRect(), f = u.node.closest("[data-node-type=column]");
        this.state = {
          show: !0,
          referencePos: new DOMRect(
            f ? (
              // We take the first child as column elements have some default
              // padding. This is a little weird since this child element will
              // be the first block, but since it's always non-nested and we
              // only take the x coordinate, it's ok.
              f.firstElementChild.getBoundingClientRect().x
            ) : this.pmView.dom.firstChild.getBoundingClientRect().x,
            d.y,
            d.width,
            d.height
          ),
          block: this.editor.getBlock(
            this.hoveredBlock.getAttribute("data-id")
          )
        }, this.updateState(this.state);
      }
    }), Ue(this, "onDragStart", (o) => {
      var i;
      const s = (i = o.dataTransfer) == null ? void 0 : i.getData("blocknote/html");
      if (!s || this.pmView.dragging)
        return;
      const a = document.createElement("div");
      a.innerHTML = s;
      const l = Mn.fromSchema(this.pmView.state.schema).parse(a, {
        topNode: this.pmView.state.schema.nodes.blockGroup.create()
      });
      this.pmView.dragging = {
        slice: new lt(l.content, 0, 0),
        move: !0
      };
    }), Ue(this, "findClosestEditorElement", (o) => {
      const i = Array.from(this.pmView.root.querySelectorAll(".bn-editor"));
      if (i.length === 0)
        return null;
      let s = i[0], a = Number.MAX_VALUE;
      return i.forEach((l) => {
        const c = l.querySelector(".bn-block-group").getBoundingClientRect(), u = o.clientX < c.left ? c.left - o.clientX : o.clientX > c.right ? o.clientX - c.right : 0, d = o.clientY < c.top ? c.top - o.clientY : o.clientY > c.bottom ? o.clientY - c.bottom : 0, f = Math.sqrt(
          Math.pow(u, 2) + Math.pow(d, 2)
        );
        f < a && (a = f, s = l);
      }), {
        element: s,
        distance: a
      };
    }), Ue(this, "onDragOver", (o) => {
      if (o.synthetic)
        return;
      const i = this.getDragEventContext(o);
      if (!i || !i.isDropPoint) {
        this.closeDropCursor();
        return;
      }
      i.isDropPoint && !i.isDropWithinEditorBounds && this.dispatchSyntheticEvent(o);
    }), Ue(this, "closeDropCursor", () => {
      const o = new Event("dragleave", { bubbles: !1 });
      o.synthetic = !0, this.pmView.dom.dispatchEvent(o);
    }), Ue(this, "getDragEventContext", (o) => {
      var i;
      const s = !((i = o.dataTransfer) != null && i.types.includes("blocknote/html")) && !!this.pmView.dragging, a = !!this.isDragOrigin, l = s || a, c = this.findClosestEditorElement(o);
      if (!c || c.distance > I1)
        return;
      const u = c.element === this.pmView.dom, d = u && c.distance === 0;
      if (!(!u && !l))
        return {
          isDropPoint: u,
          isDropWithinEditorBounds: d,
          isDragOrigin: l
        };
    }), Ue(this, "onDrop", (o) => {
      if (o.synthetic)
        return;
      const i = this.getDragEventContext(o);
      if (!i) {
        this.closeDropCursor();
        return;
      }
      const { isDropPoint: s, isDropWithinEditorBounds: a, isDragOrigin: l } = i;
      if (!a && s && this.dispatchSyntheticEvent(o), s) {
        if (this.pmView.dragging)
          return;
        this.pmView.dispatch(
          this.pmView.state.tr.setSelection(
            pe.create(
              this.pmView.state.tr.doc,
              this.pmView.state.tr.selection.anchor
            )
          )
        );
        return;
      } else if (l) {
        setTimeout(
          () => this.pmView.dispatch(this.pmView.state.tr.deleteSelection()),
          0
        );
        return;
      }
    }), Ue(this, "onDragEnd", (o) => {
      o.synthetic || (this.pmView.dragging = null);
    }), Ue(this, "onKeyDown", (o) => {
      var i;
      (i = this.state) != null && i.show && this.editor.isFocused() && (this.state.show = !1, this.emitUpdate(this.state));
    }), Ue(this, "onMouseMove", (o) => {
      var i;
      if (this.menuFrozen)
        return;
      this.mousePos = { x: o.clientX, y: o.clientY };
      const s = this.pmView.dom.getBoundingClientRect(), a = this.mousePos.x > s.left && this.mousePos.x < s.right && this.mousePos.y > s.top && this.mousePos.y < s.bottom, l = this.pmView.dom.parentElement;
      if (
        // Cursor is within the editor area
        a && // An element is hovered
        o && o.target && // Element is outside the editor
        !(l === o.target || l.contains(o.target))
      ) {
        (i = this.state) != null && i.show && (this.state.show = !1, this.emitUpdate(this.state));
        return;
      }
      this.updateStateFromMousePos();
    }), this.editor = t, this.pmView = n, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized side menu");
      r(this.state);
    }, this.pmView.root.addEventListener(
      "dragstart",
      this.onDragStart
    ), this.pmView.root.addEventListener(
      "dragover",
      this.onDragOver
    ), this.pmView.root.addEventListener(
      "drop",
      this.onDrop,
      !0
    ), this.pmView.root.addEventListener(
      "dragend",
      this.onDragEnd,
      !0
    ), this.pmView.root.addEventListener(
      "mousemove",
      this.onMouseMove,
      !0
    ), this.pmView.root.addEventListener(
      "keydown",
      this.onKeyDown,
      !0
    );
  }
  dispatchSyntheticEvent(t) {
    const n = new Event(t.type, t), r = this.pmView.dom.firstChild.getBoundingClientRect();
    n.clientX = t.clientX, n.clientY = t.clientY, n.clientX = Math.min(
      Math.max(t.clientX, r.left),
      r.left + r.width
    ), n.clientY = Math.min(
      Math.max(t.clientY, r.top),
      r.top + r.height
    ), n.dataTransfer = t.dataTransfer, n.preventDefault = () => t.preventDefault(), n.synthetic = !0, this.pmView.dom.dispatchEvent(n);
  }
  // Needed in cases where the editor state updates without the mouse cursor
  // moving, as some state updates can require a side menu update. For example,
  // adding a button to the side menu which removes the block can cause the
  // block below to jump up into the place of the removed block when clicked,
  // allowing the user to click the button again without moving the cursor. This
  // would otherwise not update the side menu, and so clicking the button again
  // would attempt to remove the same block again, causing an error.
  update(t, n) {
    var r;
    !n.doc.eq(this.pmView.state.doc) && (r = this.state) != null && r.show && this.updateStateFromMousePos();
  }
  destroy() {
    var t;
    (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate(this.state)), this.pmView.root.removeEventListener(
      "mousemove",
      this.onMouseMove,
      !0
    ), this.pmView.root.removeEventListener(
      "dragstart",
      this.onDragStart
    ), this.pmView.root.removeEventListener(
      "dragover",
      this.onDragOver
    ), this.pmView.root.removeEventListener(
      "drop",
      this.onDrop,
      !0
    ), this.pmView.root.removeEventListener(
      "dragend",
      this.onDragEnd,
      !0
    ), this.pmView.root.removeEventListener(
      "keydown",
      this.onKeyDown,
      !0
    );
  }
};
const YB = new we("SideMenuPlugin"), Zn = He(({ editor: e }) => {
  let t;
  const n = yo(
    void 0
  );
  return {
    key: "sideMenu",
    store: n,
    prosemirrorPlugins: [
      new me({
        key: YB,
        view: (r) => (t = new GB(e, r, (o) => {
          n.setState({ ...o });
        }), t)
      })
    ],
    /**
     * Handles drag & drop events for blocks.
     */
    blockDragStart(r, o) {
      t && (t.isDragOrigin = !0), qB(r, o, e);
    },
    /**
     * Handles drag & drop events for blocks.
     */
    blockDragEnd() {
      DT(e.prosemirrorView.root), t && (t.isDragOrigin = !1), e.blur();
    },
    /**
     * Freezes the side menu. When frozen, the side menu will stay
     * attached to the same block regardless of which block is hovered by the
     * mouse cursor.
     */
    freezeMenu() {
      t.menuFrozen = !0, t.state.show = !0, t.emitUpdate(t.state);
    },
    /**
     * Unfreezes the side menu. When frozen, the side menu will stay
     * attached to the same block regardless of which block is hovered by the
     * mouse cursor.
     */
    unfreezeMenu() {
      t.menuFrozen = !1, t.state.show = !1, t.emitUpdate(t.state);
    }
  };
});
let tn;
function N1(e) {
  tn || (tn = document.createElement("div"), tn.innerHTML = "_", tn.style.opacity = "0", tn.style.height = "1px", tn.style.width = "1px", e instanceof Document ? e.body.appendChild(tn) : e.appendChild(tn));
}
function KB(e) {
  tn && (e instanceof Document ? e.body.removeChild(tn) : e.removeChild(tn), tn = void 0);
}
function Qa(e) {
  return Array.prototype.indexOf.call(e.parentElement.childNodes, e);
}
function QB(e) {
  let t = e;
  for (; t && t.nodeName !== "TD" && t.nodeName !== "TH" && !t.classList.contains("tableWrapper"); ) {
    if (t.classList.contains("ProseMirror"))
      return;
    const n = t.parentNode;
    if (!n || !(n instanceof Element))
      return;
    t = n;
  }
  return t.nodeName === "TD" || t.nodeName === "TH" ? {
    type: "cell",
    domNode: t,
    tbodyNode: t.closest("tbody")
  } : {
    type: "wrapper",
    domNode: t,
    tbodyNode: t.querySelector("tbody")
  };
}
function ZB(e, t) {
  const n = t.querySelectorAll(e);
  for (let r = 0; r < n.length; r++)
    n[r].style.visibility = "hidden";
}
let XB = class {
  constructor(t, n, r) {
    Ue(this, "state"), Ue(this, "emitUpdate"), Ue(this, "tableId"), Ue(this, "tablePos"), Ue(this, "tableElement"), Ue(this, "menuFrozen", !1), Ue(this, "mouseState", "up"), Ue(this, "prevWasEditable", null), Ue(this, "viewMousedownHandler", () => {
      this.mouseState = "down";
    }), Ue(this, "mouseUpHandler", (o) => {
      this.mouseState = "up", this.mouseMoveHandler(o);
    }), Ue(this, "mouseMoveHandler", (o) => {
      var i, s, a, l, c, u, d, f;
      if (this.menuFrozen || this.mouseState === "selecting" || !(o.target instanceof Element) || !this.pmView.dom.contains(o.target))
        return;
      const h = QB(o.target);
      if ((h == null ? void 0 : h.type) === "cell" && this.mouseState === "down" && !((i = this.state) != null && i.draggingState)) {
        this.mouseState = "selecting", (s = this.state) != null && s.show && (this.state.show = !1, this.state.showAddOrRemoveRowsButton = !1, this.state.showAddOrRemoveColumnsButton = !1, this.emitUpdate());
        return;
      }
      if (!h || !this.editor.isEditable) {
        (a = this.state) != null && a.show && (this.state.show = !1, this.state.showAddOrRemoveRowsButton = !1, this.state.showAddOrRemoveColumnsButton = !1, this.emitUpdate());
        return;
      }
      if (!h.tbodyNode)
        return;
      const p = h.tbodyNode.getBoundingClientRect(), m = LT(h.domNode, this.pmView);
      if (!m)
        return;
      this.tableElement = m.node;
      let b;
      const y = this.editor.transact(
        (_) => Yt(m.id, _.doc)
      );
      if (!y)
        throw new Error(`Block with ID ${m.id} not found`);
      const k = ct(
        y.node,
        this.editor.pmSchema,
        this.editor.schema.blockSchema,
        this.editor.schema.inlineContentSchema,
        this.editor.schema.styleSchema
      );
      if (rt(this.editor, "table") && (this.tablePos = y.posBeforeNode + 1, b = k), !b)
        return;
      this.tableId = m.id;
      const C = (l = h.domNode.closest(".tableWrapper")) == null ? void 0 : l.querySelector(".table-widgets-container");
      if ((h == null ? void 0 : h.type) === "wrapper") {
        const _ = o.clientY >= p.bottom - 1 && // -1 to account for fractions of pixels in "bottom"
        o.clientY < p.bottom + 20, w = o.clientX >= p.right - 1 && o.clientX < p.right + 20, T = (
          // always hide handles when the actively hovered table changed
          ((c = this.state) == null ? void 0 : c.block.id) !== b.id || // make sure we don't hide existing handles (keep col / row index) when
          // we're hovering just above or to the right of a table
          o.clientX > p.right || o.clientY > p.bottom
        );
        this.state = {
          ...this.state,
          show: !0,
          showAddOrRemoveRowsButton: _,
          showAddOrRemoveColumnsButton: w,
          referencePosTable: p,
          block: b,
          widgetContainer: C,
          colIndex: T || (u = this.state) == null ? void 0 : u.colIndex,
          rowIndex: T || (d = this.state) == null ? void 0 : d.rowIndex,
          referencePosCell: T || (f = this.state) == null ? void 0 : f.referencePosCell
        };
      } else {
        const _ = Qa(h.domNode), w = Qa(h.domNode.parentElement), T = h.domNode.getBoundingClientRect();
        if (this.state !== void 0 && this.state.show && this.tableId === m.id && this.state.rowIndex === w && this.state.colIndex === _)
          return;
        this.state = {
          show: !0,
          showAddOrRemoveColumnsButton: _ === b.content.rows[0].cells.length - 1,
          showAddOrRemoveRowsButton: w === b.content.rows.length - 1,
          referencePosTable: p,
          block: b,
          draggingState: void 0,
          referencePosCell: T,
          colIndex: _,
          rowIndex: w,
          widgetContainer: C
        };
      }
      return this.emitUpdate(), !1;
    }), Ue(this, "dragOverHandler", (o) => {
      var i;
      if (((i = this.state) == null ? void 0 : i.draggingState) === void 0)
        return;
      o.preventDefault(), o.dataTransfer.dropEffect = "move", ZB(
        ".prosemirror-dropcursor-block, .prosemirror-dropcursor-inline",
        this.pmView.root
      );
      const s = {
        left: Math.min(
          Math.max(o.clientX, this.state.referencePosTable.left + 1),
          this.state.referencePosTable.right - 1
        ),
        top: Math.min(
          Math.max(o.clientY, this.state.referencePosTable.top + 1),
          this.state.referencePosTable.bottom - 1
        )
      }, a = this.pmView.root.elementsFromPoint(s.left, s.top).filter(
        (m) => m.tagName === "TD" || m.tagName === "TH"
      );
      if (a.length === 0)
        return;
      const l = a[0];
      let c = !1;
      const u = Qa(l.parentElement), d = Qa(l), f = this.state.draggingState.draggedCellOrientation === "row" ? this.state.rowIndex : this.state.colIndex, h = (this.state.draggingState.draggedCellOrientation === "row" ? u : d) !== f;
      (this.state.rowIndex !== u || this.state.colIndex !== d) && (this.state.rowIndex = u, this.state.colIndex = d, this.state.referencePosCell = l.getBoundingClientRect(), c = !0);
      const p = this.state.draggingState.draggedCellOrientation === "row" ? s.top : s.left;
      this.state.draggingState.mousePos !== p && (this.state.draggingState.mousePos = p, c = !0), c && this.emitUpdate(), h && this.editor.transact((m) => m.setMeta(ms, !0));
    }), Ue(this, "dropHandler", (o) => {
      if (this.mouseState = "up", this.state === void 0 || this.state.draggingState === void 0)
        return !1;
      if (this.state.rowIndex === void 0 || this.state.colIndex === void 0)
        throw new Error(
          "Attempted to drop table row or column, but no table block was hovered prior."
        );
      o.preventDefault();
      const { draggingState: i, colIndex: s, rowIndex: a } = this.state, l = this.state.block.content.columnWidths;
      if (i.draggedCellOrientation === "row") {
        if (!wE(
          this.state.block,
          i.originalIndex,
          a
        ))
          return !1;
        const c = Z_(
          this.state.block,
          i.originalIndex,
          a
        );
        this.editor.updateBlock(this.state.block, {
          type: "table",
          content: {
            ...this.state.block.content,
            rows: c
          }
        });
      } else {
        if (!vE(
          this.state.block,
          i.originalIndex,
          s
        ))
          return !1;
        const c = Q_(
          this.state.block,
          i.originalIndex,
          s
        ), [u] = l.splice(i.originalIndex, 1);
        l.splice(s, 0, u), this.editor.updateBlock(this.state.block, {
          type: "table",
          content: {
            ...this.state.block.content,
            columnWidths: l,
            rows: c
          }
        });
      }
      return this.editor.setTextCursorPosition(this.state.block.id), !0;
    }), this.editor = t, this.pmView = n, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized image toolbar");
      r(this.state);
    }, n.dom.addEventListener("mousemove", this.mouseMoveHandler), n.dom.addEventListener("mousedown", this.viewMousedownHandler), window.addEventListener("mouseup", this.mouseUpHandler), n.root.addEventListener(
      "dragover",
      this.dragOverHandler
    ), n.root.addEventListener(
      "drop",
      this.dropHandler
    );
  }
  // Updates drag handles when the table is modified or removed.
  update() {
    var t;
    if (!this.state || !this.state.show)
      return;
    if (this.state.block = this.editor.getBlock(this.state.block.id), !this.state.block || this.state.block.type !== "table" || // when collaborating, the table element might be replaced and out of date
    // because yjs replaces the element when for example you change the color via the side menu
    !((t = this.tableElement) != null && t.isConnected)) {
      this.state.show = !1, this.state.showAddOrRemoveRowsButton = !1, this.state.showAddOrRemoveColumnsButton = !1, this.emitUpdate();
      return;
    }
    const { height: n, width: r } = Fh(
      this.state.block
    );
    this.state.rowIndex !== void 0 && this.state.colIndex !== void 0 && (this.state.rowIndex >= n && (this.state.rowIndex = n - 1), this.state.colIndex >= r && (this.state.colIndex = r - 1));
    const o = this.tableElement.querySelector("tbody");
    if (!o)
      throw new Error(
        "Table block does not contain a 'tbody' HTML element. This should never happen."
      );
    if (this.state.rowIndex !== void 0 && this.state.colIndex !== void 0) {
      const i = o.children[this.state.rowIndex].children[this.state.colIndex];
      i ? this.state.referencePosCell = i.getBoundingClientRect() : (this.state.rowIndex = void 0, this.state.colIndex = void 0);
    }
    this.state.referencePosTable = o.getBoundingClientRect(), this.emitUpdate();
  }
  destroy() {
    this.pmView.dom.removeEventListener("mousemove", this.mouseMoveHandler), window.removeEventListener("mouseup", this.mouseUpHandler), this.pmView.dom.removeEventListener("mousedown", this.viewMousedownHandler), this.pmView.root.removeEventListener(
      "dragover",
      this.dragOverHandler
    ), this.pmView.root.removeEventListener(
      "drop",
      this.dropHandler
    );
  }
};
const ms = new we("TableHandlesPlugin"), tt = He(({ editor: e }) => {
  let t;
  const n = yo(void 0);
  return {
    key: "tableHandles",
    store: n,
    prosemirrorPlugins: [
      new me({
        key: ms,
        view: (r) => (t = new XB(e, r, (o) => {
          n.setState(
            o.block ? {
              ...o,
              draggingState: o.draggingState ? { ...o.draggingState } : void 0
            } : void 0
          );
        }), t),
        // We use decorations to render the drop cursor when dragging a table row
        // or column. The decorations are updated in the `dragOverHandler` method.
        props: {
          decorations: (r) => {
            if (t === void 0 || t.state === void 0 || t.state.draggingState === void 0 || t.tablePos === void 0)
              return;
            const o = t.state.draggingState.draggedCellOrientation === "row" ? t.state.rowIndex : t.state.colIndex;
            if (o === void 0)
              return;
            const i = [], { block: s, draggingState: a } = t.state, { originalIndex: l, draggedCellOrientation: c } = a;
            if (o === l || !s || c === "row" && !wE(s, l, o) || c === "col" && !vE(s, l, o))
              return kt.create(r.doc, i);
            const u = r.doc.resolve(t.tablePos + 1);
            return t.state.draggingState.draggedCellOrientation === "row" ? rf(
              t.state.block,
              o
            ).forEach(({ row: d, col: f }) => {
              const h = r.doc.resolve(
                u.posAtIndex(d) + 1
              ), p = r.doc.resolve(
                h.posAtIndex(f) + 1
              ), m = p.node(), b = p.pos + (o > l ? m.nodeSize - 2 : 0);
              i.push(
                // The widget is a small bar which spans the width of the cell.
                Lt.widget(b, () => {
                  const y = document.createElement("div");
                  return y.className = "bn-table-drop-cursor", y.style.left = "0", y.style.right = "0", o > l ? y.style.bottom = "-2px" : y.style.top = "-3px", y.style.height = "4px", y;
                })
              );
            }) : of(
              t.state.block,
              o
            ).forEach(({ row: d, col: f }) => {
              const h = r.doc.resolve(
                u.posAtIndex(d) + 1
              ), p = r.doc.resolve(
                h.posAtIndex(f) + 1
              ), m = p.node(), b = p.pos + (o > l ? m.nodeSize - 2 : 0);
              i.push(
                // The widget is a small bar which spans the height of the cell.
                Lt.widget(b, () => {
                  const y = document.createElement("div");
                  return y.className = "bn-table-drop-cursor", y.style.top = "0", y.style.bottom = "0", o > l ? y.style.right = "-2px" : y.style.left = "-3px", y.style.width = "4px", y;
                })
              );
            }), kt.create(r.doc, i);
          }
        }
      })
    ],
    /**
     * Callback that should be set on the `dragStart` event for whichever element
     * is used as the column drag handle.
     */
    colDragStart(r) {
      if (t === void 0 || t.state === void 0 || t.state.colIndex === void 0)
        throw new Error(
          "Attempted to drag table column, but no table block was hovered prior."
        );
      t.state.draggingState = {
        draggedCellOrientation: "col",
        originalIndex: t.state.colIndex,
        mousePos: r.clientX
      }, t.emitUpdate(), e.transact(
        (o) => o.setMeta(ms, {
          draggedCellOrientation: t.state.draggingState.draggedCellOrientation,
          originalIndex: t.state.colIndex,
          newIndex: t.state.colIndex,
          tablePos: t.tablePos
        })
      ), !e.headless && (N1(e.prosemirrorView.root), r.dataTransfer.setDragImage(tn, 0, 0), r.dataTransfer.effectAllowed = "move");
    },
    /**
     * Callback that should be set on the `dragStart` event for whichever element
     * is used as the row drag handle.
     */
    rowDragStart(r) {
      if (t.state === void 0 || t.state.rowIndex === void 0)
        throw new Error(
          "Attempted to drag table row, but no table block was hovered prior."
        );
      t.state.draggingState = {
        draggedCellOrientation: "row",
        originalIndex: t.state.rowIndex,
        mousePos: r.clientY
      }, t.emitUpdate(), e.transact(
        (o) => o.setMeta(ms, {
          draggedCellOrientation: t.state.draggingState.draggedCellOrientation,
          originalIndex: t.state.rowIndex,
          newIndex: t.state.rowIndex,
          tablePos: t.tablePos
        })
      ), !e.headless && (N1(e.prosemirrorView.root), r.dataTransfer.setDragImage(tn, 0, 0), r.dataTransfer.effectAllowed = "copyMove");
    },
    /**
     * Callback that should be set on the `dragEnd` event for both the element
     * used as the row drag handle, and the one used as the column drag handle.
     */
    dragEnd() {
      if (t.state === void 0)
        throw new Error(
          "Attempted to drag table row, but no table block was hovered prior."
        );
      t.state.draggingState = void 0, t.emitUpdate(), e.transact((r) => r.setMeta(ms, null)), !e.headless && KB(e.prosemirrorView.root);
    },
    /**
     * Freezes the drag handles. When frozen, they will stay attached to the same
     * cell regardless of which cell is hovered by the mouse cursor.
     */
    freezeHandles() {
      t.menuFrozen = !0;
    },
    /**
     * Unfreezes the drag handles. When frozen, they will stay attached to the
     * same cell regardless of which cell is hovered by the mouse cursor.
     */
    unfreezeHandles() {
      t.menuFrozen = !1;
    },
    getCellsAtRowHandle(r, o) {
      return rf(r, o);
    },
    /**
     * Get all the cells in a column of the table block.
     */
    getCellsAtColumnHandle(r, o) {
      return of(r, o);
    },
    /**
     * Sets the selection to the given cell or a range of cells.
     * @returns The new state after the selection has been set.
     */
    setCellSelection(r, o, i = o) {
      if (!t)
        throw new Error("Table handles view not initialized");
      const s = r.doc.resolve(t.tablePos + 1), a = r.doc.resolve(
        s.posAtIndex(o.row) + 1
      ), l = r.doc.resolve(
        // No need for +1, since CellSelection expects the position before the cell
        a.posAtIndex(o.col)
      ), c = r.doc.resolve(
        s.posAtIndex(i.row) + 1
      ), u = r.doc.resolve(
        // No need for +1, since CellSelection expects the position before the cell
        c.posAtIndex(i.col)
      ), d = r.tr;
      return d.setSelection(
        new qe(l, u)
      ), r.apply(d);
    },
    /**
     * Adds a row or column to the table using prosemirror-table commands
     */
    addRowOrColumn(r, o) {
      e.exec((i, s) => {
        const a = this.setCellSelection(
          i,
          o.orientation === "row" ? { row: r, col: 0 } : { row: 0, col: r }
        );
        return o.orientation === "row" ? o.side === "above" ? xA(a, s) : wA(a, s) : o.side === "left" ? yA(a, s) : EA(a, s);
      });
    },
    /**
     * Removes a row or column from the table using prosemirror-table commands
     */
    removeRowOrColumn(r, o) {
      return o === "row" ? e.exec((i, s) => {
        const a = this.setCellSelection(i, {
          row: r,
          col: 0
        });
        return SA(a, s);
      }) : e.exec((i, s) => {
        const a = this.setCellSelection(i, {
          row: 0,
          col: r
        });
        return CA(a, s);
      });
    },
    /**
     * Merges the cells in the table block.
     */
    mergeCells(r) {
      return e.exec((o, i) => {
        const s = r ? this.setCellSelection(
          o,
          r.relativeStartCell,
          r.relativeEndCell
        ) : o;
        return AA(s, i);
      });
    },
    /**
     * Splits the cell in the table block.
     * If no cell is provided, the current cell selected will be split.
     */
    splitCell(r) {
      return e.exec((o, i) => {
        const s = r ? this.setCellSelection(o, r) : o;
        return IA(s, i);
      });
    },
    /**
     * Gets the start and end cells of the current cell selection.
     * @returns The start and end cells of the current cell selection.
     */
    getCellSelection() {
      return e.transact((r) => {
        const o = r.selection;
        let i = o.$from, s = o.$to;
        if (Lf(o)) {
          const { ranges: m } = o;
          m.forEach((b) => {
            i = b.$from.min(i ?? b.$from), s = b.$to.max(s ?? b.$to);
          });
        } else if (i = r.doc.resolve(
          o.$from.pos - o.$from.parentOffset - 1
        ), s = r.doc.resolve(
          o.$to.pos - o.$to.parentOffset - 1
        ), i.pos === 0 || s.pos === 0)
          return;
        const a = r.doc.resolve(
          i.pos - i.parentOffset - 1
        ), l = r.doc.resolve(s.pos - s.parentOffset - 1), c = r.doc.resolve(a.pos - a.parentOffset - 1), u = i.index(a.depth), d = a.index(c.depth), f = s.index(l.depth), h = l.index(c.depth), p = [];
        for (let m = d; m <= h; m++)
          for (let b = u; b <= f; b++)
            p.push({ row: m, col: b });
        return {
          from: {
            row: d,
            col: u
          },
          to: {
            row: h,
            col: f
          },
          cells: p
        };
      });
    },
    /**
     * Gets the direction of the merge based on the current cell selection.
     *
     * Returns undefined when there is no cell selection, or the selection is not within a table.
     */
    getMergeDirection(r) {
      return e.transact((o) => {
        const i = Lf(o.selection) ? o.selection : void 0;
        if (!i || !r || // Only offer the merge button if there is more than one cell selected.
        i.ranges.length <= 1)
          return;
        const s = this.getCellSelection();
        if (s)
          return eA(s.from, s.to, r) ? "vertical" : "horizontal";
      });
    },
    cropEmptyRowsOrColumns(r, o) {
      return X_(r, o);
    },
    addRowsOrColumns(r, o, i) {
      return J_(r, o, i);
    }
  };
}), M1 = new we("trailingNode"), JB = He(() => ({
  key: "trailingNode",
  prosemirrorPlugins: [
    new me({
      key: M1,
      appendTransaction: (e, t, n) => {
        const { doc: r, tr: o, schema: i } = n, s = M1.getState(n), a = r.content.size - 2, l = i.nodes.blockContainer, c = i.nodes.paragraph;
        if (s)
          return o.insert(
            a,
            l.create(void 0, c.create())
          );
      },
      state: {
        init: (e, t) => {
        },
        apply: (e, t) => {
          if (!e.docChanged)
            return t;
          let n = e.doc.lastChild;
          if (!n || n.type.name !== "blockGroup")
            throw new Error("Expected blockGroup");
          if (n = n.lastChild, !n || n.type.name !== "blockContainer")
            return !0;
          const r = n.firstChild;
          if (!r)
            throw new Error("Expected blockContent");
          return n.nodeSize > 4 || r.type.spec.content !== "inline*";
        }
      }
    })
  ]
}));
var e$ = Object.defineProperty, t$ = (e, t, n) => t in e ? e$(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Mr = (e, t, n) => t$(e, typeof t != "symbol" ? t + "" : t, n);
function n$(e) {
  const t = o$(e);
  let { roots: n, nonRoots: r } = L1(t);
  const o = [];
  for (; n.size; ) {
    o.push(n);
    const i = /* @__PURE__ */ new Set();
    for (const s of n) {
      const a = e.get(s);
      if (a)
        for (const l of a) {
          const c = t.get(l);
          if (c === void 0)
            continue;
          const u = c - 1;
          t.set(l, u), u === 0 && i.add(l);
        }
    }
    n = i;
  }
  if (r = L1(t).nonRoots, r.size)
    throw new Error(
      `Cycle(s) detected; toposort only works on acyclic graphs. Cyclic nodes: ${Array.from(r).join(", ")}`
    );
  return o;
}
function r$(e) {
  const t = i$(e);
  return n$(t);
}
function o$(e) {
  const t = /* @__PURE__ */ new Map();
  for (const [n, r] of e.entries()) {
    t.has(n) || t.set(n, 0);
    for (const o of r) {
      const i = t.get(o) ?? 0;
      t.set(o, i + 1);
    }
  }
  return t;
}
function L1(e) {
  const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
  for (const [r, o] of e.entries())
    o === 0 ? t.add(r) : n.add(r);
  return { roots: t, nonRoots: n };
}
function i$(e) {
  const t = /* @__PURE__ */ new Map();
  for (const [n, r] of e.entries()) {
    t.has(n) || t.set(n, /* @__PURE__ */ new Set());
    for (const o of r)
      t.has(o) || t.set(o, /* @__PURE__ */ new Set()), t.get(o).add(n);
  }
  return t;
}
function s$() {
  return /* @__PURE__ */ new Map();
}
function O1(e, t, n) {
  return e.has(t) || e.set(t, /* @__PURE__ */ new Set()), e.get(t).add(n), e;
}
function RT(e) {
  const t = s$();
  for (const o of e)
    Array.isArray(o.runsBefore) && o.runsBefore.length > 0 ? o.runsBefore.forEach((i) => {
      O1(t, o.key, i);
    }) : O1(t, "default", o.key);
  const n = r$(t), r = n.findIndex((o) => o.has("default"));
  return (o) => 91 + (n.findIndex((i) => i.has(o)) + r) * 10;
}
function D1(e) {
  return e && Object.fromEntries(
    Object.entries(e).filter(([, t]) => t !== void 0)
  );
}
class a$ {
  constructor(t) {
    Mr(this, "BlockNoteEditor", "only for types"), Mr(this, "Block", "only for types"), Mr(this, "PartialBlock", "only for types"), Mr(this, "inlineContentSpecs"), Mr(this, "styleSpecs"), Mr(this, "blockSpecs"), Mr(this, "blockSchema"), Mr(this, "inlineContentSchema"), Mr(this, "styleSchema"), this.opts = t;
    const {
      blockSpecs: n,
      inlineContentSpecs: r,
      styleSpecs: o,
      blockSchema: i,
      inlineContentSchema: s,
      styleSchema: a
    } = this.init();
    this.blockSpecs = n, this.styleSpecs = o, this.styleSchema = a, this.inlineContentSpecs = r, this.blockSchema = i, this.inlineContentSchema = s;
  }
  init() {
    const t = RT(
      Object.entries({
        ...this.opts.blockSpecs,
        ...this.opts.inlineContentSpecs,
        ...this.opts.styleSpecs
      }).map(([i, s]) => {
        var a;
        return {
          key: i,
          runsBefore: ((a = s.implementation) == null ? void 0 : a.runsBefore) ?? []
        };
      })
    ), n = Object.fromEntries(
      Object.entries(this.opts.blockSpecs).map(([i, s]) => [
        i,
        qM(
          s.config,
          s.implementation,
          s.extensions,
          t(i)
        )
      ])
    ), r = Object.fromEntries(
      Object.entries(this.opts.inlineContentSpecs).map(
        ([i, s]) => {
          var a;
          return typeof s.config != "object" ? [i, s] : [
            i,
            {
              ...s,
              implementation: {
                ...s.implementation,
                node: (a = s.implementation) == null ? void 0 : a.node.extend({
                  priority: t(i)
                })
              }
            }
          ];
        }
      )
    ), o = Object.fromEntries(
      Object.entries(this.opts.styleSpecs).map(([i, s]) => {
        var a;
        return [
          i,
          {
            ...s,
            implementation: {
              ...s.implementation,
              mark: (a = s.implementation) == null ? void 0 : a.mark.extend({
                priority: t(i)
              })
            }
          }
        ];
      })
    );
    return {
      blockSpecs: n,
      blockSchema: Object.fromEntries(
        Object.entries(n).map(([i, s]) => [i, s.config])
      ),
      inlineContentSpecs: D1(r),
      styleSpecs: D1(o),
      inlineContentSchema: l2(
        r
      ),
      styleSchema: u2(o)
    };
  }
  /**
   * Adds additional block specs to the current schema in a builder pattern.
   * This method allows extending the schema after it has been created.
   *
   * @param additionalBlockSpecs - Additional block specs to add to the schema
   * @returns The current schema instance for chaining
   */
  extend(t) {
    Object.assign(this.opts.blockSpecs, t.blockSpecs), Object.assign(this.opts.inlineContentSpecs, t.inlineContentSpecs), Object.assign(this.opts.styleSpecs, t.styleSpecs);
    const {
      blockSpecs: n,
      inlineContentSpecs: r,
      styleSpecs: o,
      blockSchema: i,
      inlineContentSchema: s,
      styleSchema: a
    } = this.init();
    return this.blockSpecs = n, this.styleSpecs = o, this.styleSchema = a, this.inlineContentSpecs = r, this.blockSchema = i, this.inlineContentSchema = s, this;
  }
}
let PT = class BT extends a$ {
  static create(t) {
    return new BT({
      blockSpecs: (t == null ? void 0 : t.blockSpecs) ?? lL,
      inlineContentSpecs: (t == null ? void 0 : t.inlineContentSpecs) ?? k2,
      styleSpecs: (t == null ? void 0 : t.styleSpecs) ?? Tp
    });
  }
};
var l$ = Object.defineProperty, c$ = (e, t, n) => t in e ? l$(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, u$ = (e, t, n) => c$(e, t + "", n);
class Gp {
  constructor() {
    u$(this, "callbacks", {});
  }
  on(t, n) {
    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(n), () => this.off(t, n);
  }
  emit(t, ...n) {
    const r = this.callbacks[t];
    r && r.forEach((o) => o.apply(this, n));
  }
  off(t, n) {
    const r = this.callbacks[t];
    r && (n ? this.callbacks[t] = r.filter((o) => o !== n) : delete this.callbacks[t]);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
const d$ = {
  slash_menu: {
    heading: {
      title: "Heading 1",
      subtext: "Top-level heading",
      aliases: ["h", "heading1", "h1"],
      group: "Headings"
    },
    heading_2: {
      title: "Heading 2",
      subtext: "Key section heading",
      aliases: ["h2", "heading2", "subheading"],
      group: "Headings"
    },
    heading_3: {
      title: "Heading 3",
      subtext: "Subsection and group heading",
      aliases: ["h3", "heading3", "subheading"],
      group: "Headings"
    },
    heading_4: {
      title: "Heading 4",
      subtext: "Minor subsection heading",
      aliases: ["h4", "heading4", "subheading4"],
      group: "Subheadings"
    },
    heading_5: {
      title: "Heading 5",
      subtext: "Small subsection heading",
      aliases: ["h5", "heading5", "subheading5"],
      group: "Subheadings"
    },
    heading_6: {
      title: "Heading 6",
      subtext: "Lowest-level heading",
      aliases: ["h6", "heading6", "subheading6"],
      group: "Subheadings"
    },
    toggle_heading: {
      title: "Toggle Heading 1",
      subtext: "Toggleable top-level heading",
      aliases: ["h", "heading1", "h1", "collapsable"],
      group: "Subheadings"
    },
    toggle_heading_2: {
      title: "Toggle Heading 2",
      subtext: "Toggleable key section heading",
      aliases: ["h2", "heading2", "subheading", "collapsable"],
      group: "Subheadings"
    },
    toggle_heading_3: {
      title: "Toggle Heading 3",
      subtext: "Toggleable subsection and group heading",
      aliases: ["h3", "heading3", "subheading", "collapsable"],
      group: "Subheadings"
    },
    quote: {
      title: "Quote",
      subtext: "Quote or excerpt",
      aliases: ["quotation", "blockquote", "bq"],
      group: "Basic blocks"
    },
    toggle_list: {
      title: "Toggle List",
      subtext: "List with hideable sub-items",
      aliases: ["li", "list", "toggleList", "toggle list", "collapsable list"],
      group: "Basic blocks"
    },
    numbered_list: {
      title: "Numbered List",
      subtext: "List with ordered items",
      aliases: ["ol", "li", "list", "numberedlist", "numbered list"],
      group: "Basic blocks"
    },
    bullet_list: {
      title: "Bullet List",
      subtext: "List with unordered items",
      aliases: ["ul", "li", "list", "bulletlist", "bullet list"],
      group: "Basic blocks"
    },
    check_list: {
      title: "Check List",
      subtext: "List with checkboxes",
      aliases: [
        "ul",
        "li",
        "list",
        "checklist",
        "check list",
        "checked list",
        "checkbox"
      ],
      group: "Basic blocks"
    },
    paragraph: {
      title: "Paragraph",
      subtext: "The body of your document",
      aliases: ["p", "paragraph"],
      group: "Basic blocks"
    },
    code_block: {
      title: "Code Block",
      subtext: "Code block with syntax highlighting",
      aliases: ["code", "pre"],
      group: "Basic blocks"
    },
    page_break: {
      title: "Page Break",
      subtext: "Page separator",
      aliases: ["page", "break", "separator"],
      group: "Basic blocks"
    },
    table: {
      title: "Table",
      subtext: "Table with editable cells",
      aliases: ["table"],
      group: "Advanced"
    },
    image: {
      title: "Image",
      subtext: "Resizable image with caption",
      aliases: [
        "image",
        "imageUpload",
        "upload",
        "img",
        "picture",
        "media",
        "url"
      ],
      group: "Media"
    },
    video: {
      title: "Video",
      subtext: "Resizable video with caption",
      aliases: [
        "video",
        "videoUpload",
        "upload",
        "mp4",
        "film",
        "media",
        "url"
      ],
      group: "Media"
    },
    audio: {
      title: "Audio",
      subtext: "Embedded audio with caption",
      aliases: [
        "audio",
        "audioUpload",
        "upload",
        "mp3",
        "sound",
        "media",
        "url"
      ],
      group: "Media"
    },
    file: {
      title: "File",
      subtext: "Embedded file",
      aliases: ["file", "upload", "embed", "media", "url"],
      group: "Media"
    },
    emoji: {
      title: "Emoji",
      subtext: "Search for and insert an emoji",
      aliases: ["emoji", "emote", "emotion", "face"],
      group: "Others"
    },
    divider: {
      title: "Divider",
      subtext: "Visually divide blocks",
      aliases: ["divider", "hr", "line", "horizontal rule"],
      group: "Basic blocks"
    }
  },
  placeholders: {
    default: "Enter text or type '/' for commands",
    heading: "Heading",
    toggleListItem: "Toggle",
    bulletListItem: "List",
    numberedListItem: "List",
    checkListItem: "List",
    emptyDocument: void 0,
    new_comment: "Write a comment...",
    edit_comment: "Edit comment...",
    comment_reply: "Add comment..."
  },
  file_blocks: {
    add_button_text: {
      image: "Add image",
      video: "Add video",
      audio: "Add audio",
      file: "Add file"
    }
  },
  toggle_blocks: {
    add_block_button: "Empty toggle. Click to add a block."
  },
  // from react package:
  side_menu: {
    add_block_label: "Add block",
    drag_handle_label: "Open block menu"
  },
  drag_handle: {
    delete_menuitem: "Delete",
    colors_menuitem: "Colors",
    header_row_menuitem: "Header row",
    header_column_menuitem: "Header column"
  },
  table_handle: {
    delete_column_menuitem: "Delete column",
    delete_row_menuitem: "Delete row",
    add_left_menuitem: "Add column left",
    add_right_menuitem: "Add column right",
    add_above_menuitem: "Add row above",
    add_below_menuitem: "Add row below",
    split_cell_menuitem: "Split cell",
    merge_cells_menuitem: "Merge cells",
    background_color_menuitem: "Background color"
  },
  suggestion_menu: {
    no_items_title: "No items found"
  },
  color_picker: {
    text_title: "Text",
    background_title: "Background",
    colors: {
      default: "Default",
      gray: "Gray",
      brown: "Brown",
      red: "Red",
      orange: "Orange",
      yellow: "Yellow",
      green: "Green",
      blue: "Blue",
      purple: "Purple",
      pink: "Pink"
    }
  },
  formatting_toolbar: {
    bold: {
      tooltip: "Bold",
      secondary_tooltip: "Mod+B"
    },
    italic: {
      tooltip: "Italic",
      secondary_tooltip: "Mod+I"
    },
    underline: {
      tooltip: "Underline",
      secondary_tooltip: "Mod+U"
    },
    strike: {
      tooltip: "Strike",
      secondary_tooltip: "Mod+Shift+S"
    },
    code: {
      tooltip: "Code",
      secondary_tooltip: ""
    },
    colors: {
      tooltip: "Colors"
    },
    link: {
      tooltip: "Create link",
      secondary_tooltip: "Mod+K"
    },
    file_caption: {
      tooltip: "Edit caption",
      input_placeholder: "Edit caption"
    },
    file_replace: {
      tooltip: {
        image: "Replace image",
        video: "Replace video",
        audio: "Replace audio",
        file: "Replace file"
      }
    },
    file_rename: {
      tooltip: {
        image: "Rename image",
        video: "Rename video",
        audio: "Rename audio",
        file: "Rename file"
      },
      input_placeholder: {
        image: "Rename image",
        video: "Rename video",
        audio: "Rename audio",
        file: "Rename file"
      }
    },
    file_download: {
      tooltip: {
        image: "Download image",
        video: "Download video",
        audio: "Download audio",
        file: "Download file"
      }
    },
    file_delete: {
      tooltip: {
        image: "Delete image",
        video: "Delete video",
        audio: "Delete audio",
        file: "Delete file"
      }
    },
    file_preview_toggle: {
      tooltip: "Toggle preview"
    },
    nest: {
      tooltip: "Nest block",
      secondary_tooltip: "Tab"
    },
    unnest: {
      tooltip: "Unnest block",
      secondary_tooltip: "Shift+Tab"
    },
    align_left: {
      tooltip: "Align text left"
    },
    align_center: {
      tooltip: "Align text center"
    },
    align_right: {
      tooltip: "Align text right"
    },
    align_justify: {
      tooltip: "Justify text"
    },
    table_cell_merge: {
      tooltip: "Merge cells"
    },
    comment: {
      tooltip: "Add comment"
    }
  },
  file_panel: {
    upload: {
      title: "Upload",
      file_placeholder: {
        image: "Upload image",
        video: "Upload video",
        audio: "Upload audio",
        file: "Upload file"
      },
      upload_error: "Error: Upload failed"
    },
    embed: {
      title: "Embed",
      embed_button: {
        image: "Embed image",
        video: "Embed video",
        audio: "Embed audio",
        file: "Embed file"
      },
      url_placeholder: "Enter URL"
    }
  },
  link_toolbar: {
    delete: {
      tooltip: "Remove link"
    },
    edit: {
      text: "Edit link",
      tooltip: "Edit"
    },
    open: {
      tooltip: "Open in new tab"
    },
    form: {
      title_placeholder: "Edit title",
      url_placeholder: "Edit URL"
    }
  },
  comments: {
    edited: "edited",
    save_button_text: "Save",
    cancel_button_text: "Cancel",
    actions: {
      add_reaction: "Add reaction",
      resolve: "Resolve",
      edit_comment: "Edit comment",
      delete_comment: "Delete comment",
      more_actions: "More actions"
    },
    reactions: {
      reacted_by: "Reacted by"
    },
    sidebar: {
      marked_as_resolved: "Marked as resolved",
      more_replies: (e) => `${e} more replies`
    }
  },
  generic: {
    ctrl_shortcut: "Ctrl"
  }
};
class ei {
  /// Create an input rule. The rule applies when the user typed
  /// something and the text directly in front of the cursor matches
  /// `match`, which should end with `$`.
  ///
  /// The `handler` can be a string, in which case the matched text, or
  /// the first matched group in the regexp, is replaced by that
  /// string.
  ///
  /// Or a it can be a function, which will be called with the match
  /// array produced by
  /// [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  /// as well as the start and end of the matched range, and which can
  /// return a [transaction](#state.Transaction) that describes the
  /// rule's effect, or null to indicate the input was not handled.
  constructor(t, n, r = {}) {
    Ir(this, "match");
    /// @internal
    Ir(this, "handler");
    /// @internal
    Ir(this, "undoable");
    Ir(this, "inCode");
    Ir(this, "inCodeMark");
    this.match = t, this.match = t, this.handler = typeof n == "string" ? f$(n) : n, this.undoable = r.undoable !== !1, this.inCode = r.inCode || !1, this.inCodeMark = r.inCodeMark !== !1;
  }
}
function f$(e) {
  return function(t, n, r, o) {
    let i = e;
    if (n[1]) {
      let s = n[0].lastIndexOf(n[1]);
      i += n[0].slice(s + n[1].length), r += s;
      let a = r - o;
      a > 0 && (i = n[0].slice(s - a, s) + i, r = o);
    }
    return t.tr.insertText(i, r, o);
  };
}
const h$ = 500;
function p$({ rules: e }) {
  let t = new me({
    state: {
      init() {
        return null;
      },
      apply(n, r) {
        let o = n.getMeta(this);
        return o || (n.selectionSet || n.docChanged ? null : r);
      }
    },
    props: {
      handleTextInput(n, r, o, i) {
        return R1(n, r, o, i, e, t);
      },
      handleDOMEvents: {
        compositionend: (n) => {
          setTimeout(() => {
            let { $cursor: r } = n.state.selection;
            r && R1(n, r.pos, r.pos, "", e, t);
          });
        }
      }
    },
    isInputRules: !0
  });
  return t;
}
function R1(e, t, n, r, o, i) {
  if (e.composing)
    return !1;
  const s = e.state.tr.insertText(r, t, n), a = s.mapping.map(t), l = s.mapping.map(n);
  let c = null, u = s.doc.resolve(a), d = u.parent.textBetween(Math.max(0, u.parentOffset - h$), u.parentOffset, null, "");
  for (let f = 0; f < o.length; f++) {
    let h = o[f];
    if (!h.inCodeMark && u.marks().some((b) => b.type.spec.code))
      continue;
    if (u.parent.type.spec.code) {
      if (!h.inCode)
        continue;
    } else if (h.inCode === "only")
      continue;
    let p = h.match.exec(d);
    if (!p || p[0].length < r.length)
      continue;
    c ?? (c = e.state.apply(s));
    let m = h.handler(c, p, a - p[0].length, l);
    if (m)
      return e.dispatch(s), e.dispatch(Cv(e.state.tr)), h.undoable && m.setMeta(i, {
        transform: m,
        from: a,
        to: l,
        text: r
      }), e.dispatch(m), !0;
  }
  return !1;
}
new ei(/--$/, "", { inCodeMark: !1 });
new ei(/\.\.\.$/, "", { inCodeMark: !1 });
new ei(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "", { inCodeMark: !1 });
new ei(/"$/, "", { inCodeMark: !1 });
new ei(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "", { inCodeMark: !1 });
new ei(/'$/, "", { inCodeMark: !1 });
var m$ = ut.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [Tv()];
  },
  extendNodeSchema(e) {
    var t;
    const n = {
      name: e.name,
      options: e.options,
      storage: e.storage
    };
    return {
      allowGapCursor: (t = We(te(e, "allowGapCursor", n))) != null ? t : null
    };
  }
}), Yp = "[\0- -\u2029]", g$ = new RegExp(Yp), b$ = new RegExp(`${Yp}$`), y$ = new RegExp(Yp, "g");
function E$(e) {
  return e.length === 1 ? e[0].isLink : e.length === 3 && e[1].isLink ? ["()", "[]"].includes(e[0].value + e[2].value) : !1;
}
function k$(e) {
  return new me({
    key: new we("autolink"),
    appendTransaction: (t, n, r) => {
      const o = t.some((c) => c.docChanged) && !n.doc.eq(r.doc), i = t.some((c) => c.getMeta("preventAutolink"));
      if (!o || i)
        return;
      const { tr: s } = r, a = Oc(n.doc, [...t]);
      if (Ih(a).forEach(({ newRange: c }) => {
        const u = Yy(r.doc, c, (h) => h.isTextblock);
        let d, f;
        if (u.length > 1)
          d = u[0], f = r.doc.textBetween(
            d.pos,
            d.pos + d.node.nodeSize,
            void 0,
            " "
          );
        else if (u.length) {
          const h = r.doc.textBetween(c.from, c.to, " ", " ");
          if (!b$.test(h))
            return;
          d = u[0], f = r.doc.textBetween(d.pos, c.to, void 0, " ");
        }
        if (d && f) {
          const h = f.split(g$).filter(Boolean);
          if (h.length <= 0)
            return !1;
          const p = h[h.length - 1], m = d.pos + f.lastIndexOf(p);
          if (!p)
            return !1;
          const b = wv(p).map((y) => y.toObject(e.defaultProtocol));
          if (!E$(b))
            return !1;
          b.filter((y) => y.isLink).map((y) => ({
            ...y,
            from: m + y.start + 1,
            to: m + y.end + 1
          })).filter((y) => r.schema.marks.code ? !r.doc.rangeHasMark(y.from, y.to, r.schema.marks.code) : !0).filter((y) => e.validate(y.value)).filter((y) => e.shouldAutoLink(y.value)).forEach((y) => {
            Nh(y.from, y.to, r.doc).some((k) => k.mark.type === e.type) || s.addMark(
              y.from,
              y.to,
              e.type.create({
                href: y.href
              })
            );
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function C$(e) {
  return new me({
    key: new we("handleClickLink"),
    props: {
      handleClick: (t, n, r) => {
        var o, i;
        if (r.button !== 0 || !t.editable)
          return !1;
        let s = null;
        if (r.target instanceof HTMLAnchorElement)
          s = r.target;
        else {
          const l = r.target;
          if (!l)
            return !1;
          const c = e.editor.view.dom;
          s = l.closest("a"), s && !c.contains(s) && (s = null);
        }
        if (!s)
          return !1;
        let a = !1;
        if (e.enableClickSelection && (a = e.editor.commands.extendMarkRange(e.type.name)), e.openOnClick) {
          const l = eE(t.state, e.type.name), c = (o = s.href) != null ? o : l.href, u = (i = s.target) != null ? i : l.target;
          c && (window.open(c, u), a = !0);
        }
        return a;
      }
    }
  });
}
function T$(e) {
  return new me({
    key: new we("handlePasteLink"),
    props: {
      handlePaste: (t, n, r) => {
        const { shouldAutoLink: o } = e, { state: i } = t, { selection: s } = i, { empty: a } = s;
        if (a)
          return !1;
        let l = "";
        r.content.forEach((u) => {
          l += u.textContent;
        });
        const c = Dy(l, { defaultProtocol: e.defaultProtocol }).find(
          (u) => u.isLink && u.value === l
        );
        return !l || !c || o !== void 0 && !o(c.value) ? !1 : e.editor.commands.setMark(e.type, {
          href: c.href
        });
      }
    }
  });
}
function Io(e, t) {
  const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return t && t.forEach((r) => {
    const o = typeof r == "string" ? r : r.scheme;
    o && n.push(o);
  }), !e || e.replace(y$, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var x$ = Hn.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((e) => {
      if (typeof e == "string") {
        Km(e);
        return;
      }
      Km(e.scheme, e.optionalSlashes);
    });
  },
  onDestroy() {
    xv();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (e, t) => !!Io(e, t.protocols),
      validate: (e) => !!e,
      shouldAutoLink: (e) => {
        const t = /^[a-z][a-z0-9+.-]*:\/\//i.test(e), n = /^[a-z][a-z0-9+.-]*:/i.test(e);
        if (t || n && !e.includes("@"))
          return !0;
        const o = (e.includes("@") ? e.split("@").pop() : e).split(/[/?#:]/)[0];
        return !(/^\d{1,3}(\.\d{1,3}){3}$/.test(o) || !/\./.test(o));
      }
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(e) {
          return e.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (e) => {
          const t = e.getAttribute("href");
          return !t || !this.options.isAllowedUri(t, {
            defaultValidate: (n) => !!Io(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return this.options.isAllowedUri(e.href, {
      defaultValidate: (t) => !!Io(t, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", kn(this.options.HTMLAttributes, e), 0] : ["a", kn(this.options.HTMLAttributes, { ...e, href: "" }), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (e, t) => t.applyMark("link", t.parseInline(e.tokens || []), {
    href: e.href,
    title: e.title || null
  }),
  renderMarkdown: (e, t) => {
    var n, r, o, i;
    const s = (r = (n = e.attrs) == null ? void 0 : n.href) != null ? r : "", a = (i = (o = e.attrs) == null ? void 0 : o.title) != null ? i : "", l = t.renderChildren(e);
    return a ? `[${l}](${s} "${a}")` : `[${l}](${s})`;
  },
  addCommands() {
    return {
      setLink: (e) => ({ chain: t }) => {
        const { href: n } = e;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Io(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? t().setMark(this.name, e).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (e) => ({ chain: t }) => {
        const { href: n } = e || {};
        return n && !this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Io(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : t().toggleMark(this.name, e, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: e }) => e().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Bo({
        find: (e) => {
          const t = [];
          if (e) {
            const { protocols: n, defaultProtocol: r } = this.options, o = Dy(e).filter(
              (i) => i.isLink && this.options.isAllowedUri(i.value, {
                defaultValidate: (s) => !!Io(s, n),
                protocols: n,
                defaultProtocol: r
              })
            );
            o.length && o.forEach((i) => {
              this.options.shouldAutoLink(i.value) && t.push({
                text: i.value,
                data: {
                  href: i.href
                },
                index: i.start
              });
            });
          }
          return t;
        },
        type: this.type,
        getAttributes: (e) => {
          var t;
          return {
            href: (t = e.data) == null ? void 0 : t.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const e = [], { protocols: t, defaultProtocol: n } = this.options;
    return this.options.autolink && e.push(
      k$({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (r) => this.options.isAllowedUri(r, {
          defaultValidate: (o) => !!Io(o, t),
          protocols: t,
          defaultProtocol: n
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), e.push(
      C$({
        type: this.type,
        editor: this.editor,
        openOnClick: this.options.openOnClick === "whenNotEditable" ? !0 : this.options.openOnClick,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && e.push(
      T$({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type,
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), e;
  }
}), w$ = Jn.create({
  name: "text",
  group: "inline",
  parseMarkdown: (e) => ({
    type: "text",
    text: e.text || ""
  }),
  renderMarkdown: (e) => e.text || ""
});
const P1 = new we("blocknote-show-selection"), lc = He(({ editor: e }) => {
  const t = yo(
    { enabledSet: /* @__PURE__ */ new Set() },
    {
      onUpdate() {
        e.transact((n) => n.setMeta(P1, {}));
      }
    }
  );
  return {
    key: "showSelection",
    store: t,
    prosemirrorPlugins: [
      new me({
        key: P1,
        props: {
          decorations: (n) => {
            const { doc: r, selection: o } = n;
            if (t.state.enabledSet.size === 0)
              return kt.empty;
            const i = Lt.inline(o.from, o.to, {
              "data-show-selection": "true"
            });
            return kt.create(r, [i]);
          }
        }
      })
    ],
    /**
     * Show or hide the selection decoration
     *
     * @param shouldShow - Whether to show the selection decoration
     * @param key - The key of the selection to show or hide,
     * this is necessary to prevent disabling ShowSelection from one place
     * will interfere with other parts of the code that need to show the selection decoration
     * (e.g.: CreateLinkButton and AIExtension)
     */
    showSelection(n, r) {
      t.setState({
        enabledSet: n ? /* @__PURE__ */ new Set([...t.state.enabledSet, r]) : new Set([...t.state.enabledSet].filter((o) => o !== r))
      });
    }
  };
}), v$ = {
  tokenize: S$
};
function S$(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, o);
  let n;
  return t;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), Re(e, t, "linePrefix");
  }
  function o(a) {
    return e.enter("paragraph"), i(a);
  }
  function i(a) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, s(a);
  }
  function s(a) {
    if (a === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(a);
      return;
    }
    return oe(a) ? (e.consume(a), e.exit("chunkText"), i) : (e.consume(a), s);
  }
}
const _$ = {
  tokenize: A$
}, B1 = {
  tokenize: I$
};
function A$(e) {
  const t = this, n = [];
  let r = 0, o, i, s;
  return a;
  function a(C) {
    if (r < n.length) {
      const _ = n[r];
      return t.containerState = _[1], e.attempt(_[0].continuation, l, c)(C);
    }
    return c(C);
  }
  function l(C) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, o && k();
      const _ = t.events.length;
      let w = _, T;
      for (; w--; )
        if (t.events[w][0] === "exit" && t.events[w][1].type === "chunkFlow") {
          T = t.events[w][1].end;
          break;
        }
      y(r);
      let M = _;
      for (; M < t.events.length; )
        t.events[M][1].end = {
          ...T
        }, M++;
      return En(t.events, w + 1, 0, t.events.slice(_)), t.events.length = M, c(C);
    }
    return a(C);
  }
  function c(C) {
    if (r === n.length) {
      if (!o)
        return f(C);
      if (o.currentConstruct && o.currentConstruct.concrete)
        return p(C);
      t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(B1, u, d)(C);
  }
  function u(C) {
    return o && k(), y(r), f(C);
  }
  function d(C) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, p(C);
  }
  function f(C) {
    return t.containerState = {}, e.attempt(B1, h, p)(C);
  }
  function h(C) {
    return r++, n.push([t.currentConstruct, t.containerState]), f(C);
  }
  function p(C) {
    if (C === null) {
      o && k(), y(0), e.consume(C);
      return;
    }
    return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: o,
      contentType: "flow",
      previous: i
    }), m(C);
  }
  function m(C) {
    if (C === null) {
      b(e.exit("chunkFlow"), !0), y(0), e.consume(C);
      return;
    }
    return oe(C) ? (e.consume(C), b(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, a) : (e.consume(C), m);
  }
  function b(C, _) {
    const w = t.sliceStream(C);
    if (_ && w.push(null), C.previous = i, i && (i.next = C), i = C, o.defineSkip(C.start), o.write(w), t.parser.lazy[C.start.line]) {
      let T = o.events.length;
      for (; T--; )
        if (
          // The token starts before the line ending
          o.events[T][1].start.offset < s && // and either is not ended yet
          (!o.events[T][1].end || // or ends after it.
          o.events[T][1].end.offset > s)
        )
          return;
      const M = t.events.length;
      let D = M, R, N;
      for (; D--; )
        if (t.events[D][0] === "exit" && t.events[D][1].type === "chunkFlow") {
          if (R) {
            N = t.events[D][1].end;
            break;
          }
          R = !0;
        }
      for (y(r), T = M; T < t.events.length; )
        t.events[T][1].end = {
          ...N
        }, T++;
      En(t.events, D + 1, 0, t.events.slice(M)), t.events.length = T;
    }
  }
  function y(C) {
    let _ = n.length;
    for (; _-- > C; ) {
      const w = n[_];
      t.containerState = w[1], w[0].exit.call(t, e);
    }
    n.length = C;
  }
  function k() {
    o.write([null]), i = void 0, o = void 0, t.containerState._closeFlow = void 0;
  }
}
function I$(e, t, n) {
  return Re(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
const N$ = {
  tokenize: M$
};
function M$(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    ya,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, o, Re(e, e.attempt(this.parser.constructs.flow, o, e.attempt(j9, o)), "linePrefix"))
  );
  return n;
  function r(i) {
    if (i === null) {
      e.consume(i);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(i), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function o(i) {
    if (i === null) {
      e.consume(i);
      return;
    }
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const L$ = {
  resolveAll: HT()
}, O$ = $T("string"), D$ = $T("text");
function $T(e) {
  return {
    resolveAll: HT(e === "text" ? R$ : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, o = this.parser.constructs[e], i = n.attempt(o, s, a);
    return s;
    function s(u) {
      return c(u) ? i(u) : a(u);
    }
    function a(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), l;
    }
    function l(u) {
      return c(u) ? (n.exit("data"), i(u)) : (n.consume(u), l);
    }
    function c(u) {
      if (u === null)
        return !0;
      const d = o[u];
      let f = -1;
      if (d)
        for (; ++f < d.length; ) {
          const h = d[f];
          if (!h.previous || h.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function HT(e) {
  return t;
  function t(n, r) {
    let o = -1, i;
    for (; ++o <= n.length; )
      i === void 0 ? n[o] && n[o][1].type === "data" && (i = o, o++) : (!n[o] || n[o][1].type !== "data") && (o !== i + 2 && (n[i][1].end = n[o - 1][1].end, n.splice(i + 2, o - i - 2), o = i + 2), i = void 0);
    return e ? e(n, r) : n;
  }
}
function R$(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], o = t.sliceStream(r);
      let i = o.length, s = -1, a = 0, l;
      for (; i--; ) {
        const c = o[i];
        if (typeof c == "string") {
          for (s = c.length; c.charCodeAt(s - 1) === 32; )
            a++, s--;
          if (s) break;
          s = -1;
        } else if (c === -2)
          l = !0, a++;
        else if (c !== -1) {
          i++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (a = 0), a) {
        const c = {
          type: n === e.length || l || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: i ? s : r.start._bufferIndex + s,
            _index: r.start._index + i,
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(n, 0, ["enter", c, t], ["exit", c, t]), n += 2);
      }
      n++;
    }
  return e;
}
const P$ = {
  42: Xt,
  43: Xt,
  45: Xt,
  48: Xt,
  49: Xt,
  50: Xt,
  51: Xt,
  52: Xt,
  53: Xt,
  54: Xt,
  55: Xt,
  56: Xt,
  57: Xt,
  62: fT
}, B$ = {
  91: G9
}, $$ = {
  [-2]: xd,
  [-1]: xd,
  32: xd
}, H$ = {
  35: J9,
  42: Tl,
  45: [h1, Tl],
  60: r7,
  61: h1,
  95: Tl,
  96: d1,
  126: d1
}, F$ = {
  38: pT,
  92: hT
}, U$ = {
  [-5]: wd,
  [-4]: wd,
  [-3]: wd,
  33: C7,
  38: pT,
  42: Gf,
  60: [x9, u7],
  91: x7,
  92: [Z9, hT],
  93: zp,
  95: Gf,
  96: P9
}, j$ = {
  null: [Gf, L$]
}, V$ = {
  null: [42, 95]
}, z$ = {
  null: []
}, q$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: V$,
  contentInitial: B$,
  disable: z$,
  document: P$,
  flow: H$,
  flowInitial: $$,
  insideSpan: j$,
  string: F$,
  text: U$
}, Symbol.toStringTag, { value: "Module" }));
function W$(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const o = {}, i = [];
  let s = [], a = [];
  const l = {
    attempt: M(w),
    check: M(T),
    consume: k,
    enter: C,
    exit: _,
    interrupt: M(T, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: m,
    events: [],
    now: p,
    parser: e,
    previous: null,
    sliceSerialize: f,
    sliceStream: h,
    write: d
  };
  let u = t.tokenize.call(c, l);
  return t.resolveAll && i.push(t), c;
  function d(B) {
    return s = An(s, B), b(), s[s.length - 1] !== null ? [] : (D(t, 0), c.events = pu(i, c.events, c), c.events);
  }
  function f(B, F) {
    return Y$(h(B), F);
  }
  function h(B) {
    return G$(s, B);
  }
  function p() {
    const {
      _bufferIndex: B,
      _index: F,
      line: W,
      column: L,
      offset: H
    } = r;
    return {
      _bufferIndex: B,
      _index: F,
      line: W,
      column: L,
      offset: H
    };
  }
  function m(B) {
    o[B.line] = B.column, N();
  }
  function b() {
    let B;
    for (; r._index < s.length; ) {
      const F = s[r._index];
      if (typeof F == "string")
        for (B = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === B && r._bufferIndex < F.length; )
          y(F.charCodeAt(r._bufferIndex));
      else
        y(F);
    }
  }
  function y(B) {
    u = u(B);
  }
  function k(B) {
    oe(B) ? (r.line++, r.column = 1, r.offset += B === -3 ? 2 : 1, N()) : B !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = B;
  }
  function C(B, F) {
    const W = F || {};
    return W.type = B, W.start = p(), c.events.push(["enter", W, c]), a.push(W), W;
  }
  function _(B) {
    const F = a.pop();
    return F.end = p(), c.events.push(["exit", F, c]), F;
  }
  function w(B, F) {
    D(B, F.from);
  }
  function T(B, F) {
    F.restore();
  }
  function M(B, F) {
    return W;
    function W(L, H, J) {
      let Y, V, Q, S;
      return Array.isArray(L) ? (
        /* c8 ignore next 1 */
        ee(L)
      ) : "tokenize" in L ? (
        // Looks like a construct.
        ee([
          /** @type {Construct} */
          L
        ])
      ) : ue(L);
      function ue(Ee) {
        return Qe;
        function Qe(Te) {
          const ce = Te !== null && Ee[Te], nt = Te !== null && Ee.null, pt = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ce) ? ce : ce ? [ce] : [],
            ...Array.isArray(nt) ? nt : nt ? [nt] : []
          ];
          return ee(pt)(Te);
        }
      }
      function ee(Ee) {
        return Y = Ee, V = 0, Ee.length === 0 ? J : A(Ee[V]);
      }
      function A(Ee) {
        return Qe;
        function Qe(Te) {
          return S = R(), Q = Ee, Ee.partial || (c.currentConstruct = Ee), Ee.name && c.parser.constructs.disable.null.includes(Ee.name) ? ge() : Ee.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            F ? Object.assign(Object.create(c), F) : c,
            l,
            le,
            ge
          )(Te);
        }
      }
      function le(Ee) {
        return B(Q, S), H;
      }
      function ge(Ee) {
        return S.restore(), ++V < Y.length ? A(Y[V]) : J;
      }
    }
  }
  function D(B, F) {
    B.resolveAll && !i.includes(B) && i.push(B), B.resolve && En(c.events, F, c.events.length - F, B.resolve(c.events.slice(F), c)), B.resolveTo && (c.events = B.resolveTo(c.events, c));
  }
  function R() {
    const B = p(), F = c.previous, W = c.currentConstruct, L = c.events.length, H = Array.from(a);
    return {
      from: L,
      restore: J
    };
    function J() {
      r = B, c.previous = F, c.currentConstruct = W, c.events.length = L, a = H, N();
    }
  }
  function N() {
    r.line in o && r.column < 2 && (r.column = o[r.line], r.offset += o[r.line] - 1);
  }
}
function G$(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, o = t.end._index, i = t.end._bufferIndex;
  let s;
  if (n === o)
    s = [e[n].slice(r, i)];
  else {
    if (s = e.slice(n, o), r > -1) {
      const a = s[0];
      typeof a == "string" ? s[0] = a.slice(r) : s.shift();
    }
    i > 0 && s.push(e[o].slice(0, i));
  }
  return s;
}
function Y$(e, t) {
  let n = -1;
  const r = [];
  let o;
  for (; ++n < e.length; ) {
    const i = e[n];
    let s;
    if (typeof i == "string")
      s = i;
    else switch (i) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && o) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(i);
    }
    o = i === -2, r.push(s);
  }
  return r.join("");
}
function K$(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      rT([q$, ...(e || {}).extensions || []])
    ),
    content: o(v$),
    defined: [],
    document: o(_$),
    flow: o(N$),
    lazy: {},
    string: o(O$),
    text: o(D$)
  };
  return r;
  function o(i) {
    return s;
    function s(a) {
      return W$(r, i, a);
    }
  }
}
function Q$(e) {
  for (; !mT(e); )
    ;
  return e;
}
const $1 = /[\0\t\n\r]/g;
function Z$() {
  let e = 1, t = "", n = !0, r;
  return o;
  function o(i, s, a) {
    const l = [];
    let c, u, d, f, h;
    for (i = t + (typeof i == "string" ? i.toString() : new TextDecoder(s || void 0).decode(i)), d = 0, t = "", n && (i.charCodeAt(0) === 65279 && d++, n = void 0); d < i.length; ) {
      if ($1.lastIndex = d, c = $1.exec(i), f = c && c.index !== void 0 ? c.index : i.length, h = i.charCodeAt(f), !c) {
        t = i.slice(d);
        break;
      }
      if (h === 10 && d === f && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), d < f && (l.push(i.slice(d, f)), e += f - d), h) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (u = Math.ceil(e / 4) * 4, l.push(-2); e++ < u; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      d = f + 1;
    }
    return a && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const FT = {}.hasOwnProperty;
function X$(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), J$(n)(Q$(K$(n).document().write(Z$()(e, t, !0))));
}
function J$(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: i(zt),
      autolinkProtocol: R,
      autolinkEmail: R,
      atxHeading: i(Un),
      blockQuote: i(nt),
      characterEscape: R,
      characterReference: R,
      codeFenced: i(pt),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: i(pt, s),
      codeText: i(mt, s),
      codeTextData: R,
      data: R,
      codeFlowValue: R,
      definition: i(je),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: i(Vt),
      hardBreakEscape: i(vr),
      hardBreakTrailing: i(vr),
      htmlFlow: i(Sr, s),
      htmlFlowData: R,
      htmlText: i(Sr, s),
      htmlTextData: R,
      image: i(_r),
      label: s,
      link: i(zt),
      listItem: i(_a),
      listItemValue: f,
      listOrdered: i(qr, d),
      listUnordered: i(qr),
      paragraph: i(Hu),
      reference: A,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: i(Un),
      strong: i(Fu),
      thematicBreak: i(ju)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: w,
      autolink: l(),
      autolinkEmail: ce,
      autolinkProtocol: Te,
      blockQuote: l(),
      characterEscapeValue: N,
      characterReferenceMarkerHexadecimal: ge,
      characterReferenceMarkerNumeric: ge,
      characterReferenceValue: Ee,
      characterReference: Qe,
      codeFenced: l(b),
      codeFencedFence: m,
      codeFencedFenceInfo: h,
      codeFencedFenceMeta: p,
      codeFlowValue: N,
      codeIndented: l(y),
      codeText: l(H),
      codeTextData: N,
      data: N,
      definition: l(),
      definitionDestinationString: _,
      definitionLabelString: k,
      definitionTitleString: C,
      emphasis: l(),
      hardBreakEscape: l(F),
      hardBreakTrailing: l(F),
      htmlFlow: l(W),
      htmlFlowData: N,
      htmlText: l(L),
      htmlTextData: N,
      image: l(Y),
      label: Q,
      labelText: V,
      lineEnding: B,
      link: l(J),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: le,
      resourceDestinationString: S,
      resourceTitleString: ue,
      resource: ee,
      setextHeading: l(D),
      setextHeadingLineSequence: M,
      setextHeadingText: T,
      strong: l(),
      thematicBreak: l()
    }
  };
  UT(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r($) {
    let z = {
      type: "root",
      children: []
    };
    const he = {
      stack: [z],
      tokenStack: [],
      config: t,
      enter: a,
      exit: c,
      buffer: s,
      resume: u,
      data: n
    }, Ie = [];
    let Ve = -1;
    for (; ++Ve < $.length; )
      if ($[Ve][1].type === "listOrdered" || $[Ve][1].type === "listUnordered")
        if ($[Ve][0] === "enter")
          Ie.push(Ve);
        else {
          const fn = Ie.pop();
          Ve = o($, fn, Ve);
        }
    for (Ve = -1; ++Ve < $.length; ) {
      const fn = t[$[Ve][0]];
      FT.call(fn, $[Ve][1].type) && fn[$[Ve][1].type].call(Object.assign({
        sliceSerialize: $[Ve][2].sliceSerialize
      }, he), $[Ve][1]);
    }
    if (he.tokenStack.length > 0) {
      const fn = he.tokenStack[he.tokenStack.length - 1];
      (fn[1] || H1).call(he, void 0, fn[0]);
    }
    for (z.position = {
      start: Yr($.length > 0 ? $[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Yr($.length > 0 ? $[$.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Ve = -1; ++Ve < t.transforms.length; )
      z = t.transforms[Ve](z) || z;
    return z;
  }
  function o($, z, he) {
    let Ie = z - 1, Ve = -1, fn = !1, ar, wn, Wr, Gr;
    for (; ++Ie <= he; ) {
      const Ot = $[Ie];
      switch (Ot[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ot[0] === "enter" ? Ve++ : Ve--, Gr = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ot[0] === "enter" && (ar && !Gr && !Ve && !Wr && (Wr = Ie), Gr = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Gr = void 0;
      }
      if (!Ve && Ot[0] === "enter" && Ot[1].type === "listItemPrefix" || Ve === -1 && Ot[0] === "exit" && (Ot[1].type === "listUnordered" || Ot[1].type === "listOrdered")) {
        if (ar) {
          let Ar = Ie;
          for (wn = void 0; Ar--; ) {
            const vn = $[Ar];
            if (vn[1].type === "lineEnding" || vn[1].type === "lineEndingBlank") {
              if (vn[0] === "exit") continue;
              wn && ($[wn][1].type = "lineEndingBlank", fn = !0), vn[1].type = "lineEnding", wn = Ar;
            } else if (!(vn[1].type === "linePrefix" || vn[1].type === "blockQuotePrefix" || vn[1].type === "blockQuotePrefixWhitespace" || vn[1].type === "blockQuoteMarker" || vn[1].type === "listItemIndent")) break;
          }
          Wr && (!wn || Wr < wn) && (ar._spread = !0), ar.end = Object.assign({}, wn ? $[wn][1].start : Ot[1].end), $.splice(wn || Ie, 0, ["exit", ar, Ot[2]]), Ie++, he++;
        }
        if (Ot[1].type === "listItemPrefix") {
          const Ar = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ot[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          ar = Ar, $.splice(Ie, 0, ["enter", Ar, Ot[2]]), Ie++, he++, Wr = void 0, Gr = !0;
        }
      }
    }
    return $[z][1]._spread = fn, he;
  }
  function i($, z) {
    return he;
    function he(Ie) {
      a.call(this, $(Ie), Ie), z && z.call(this, Ie);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function a($, z, he) {
    this.stack[this.stack.length - 1].children.push($), this.stack.push($), this.tokenStack.push([z, he || void 0]), $.position = {
      start: Yr(z.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l($) {
    return z;
    function z(he) {
      $ && $.call(this, he), c.call(this, he);
    }
  }
  function c($, z) {
    const he = this.stack.pop(), Ie = this.tokenStack.pop();
    if (Ie)
      Ie[0].type !== $.type && (z ? z.call(this, $, Ie[0]) : (Ie[1] || H1).call(this, $, Ie[0]));
    else throw new Error("Cannot close `" + $.type + "` (" + vs({
      start: $.start,
      end: $.end
    }) + "): its not open");
    he.position.end = Yr($.end);
  }
  function u() {
    return du(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f($) {
    if (this.data.expectingFirstListItemValue) {
      const z = this.stack[this.stack.length - 2];
      z.start = Number.parseInt(this.sliceSerialize($), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function h() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.lang = $;
  }
  function p() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.meta = $;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function b() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = $.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function y() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = $.replace(/(\r?\n|\r)$/g, "");
  }
  function k($) {
    const z = this.resume(), he = this.stack[this.stack.length - 1];
    he.label = z, he.identifier = Wn(this.sliceSerialize($)).toLowerCase();
  }
  function C() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.title = $;
  }
  function _() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.url = $;
  }
  function w($) {
    const z = this.stack[this.stack.length - 1];
    if (!z.depth) {
      const he = this.sliceSerialize($).length;
      z.depth = he;
    }
  }
  function T() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function M($) {
    const z = this.stack[this.stack.length - 1];
    z.depth = this.sliceSerialize($).codePointAt(0) === 61 ? 1 : 2;
  }
  function D() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function R($) {
    const he = this.stack[this.stack.length - 1].children;
    let Ie = he[he.length - 1];
    (!Ie || Ie.type !== "text") && (Ie = Uu(), Ie.position = {
      start: Yr($.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, he.push(Ie)), this.stack.push(Ie);
  }
  function N($) {
    const z = this.stack.pop();
    z.value += this.sliceSerialize($), z.position.end = Yr($.end);
  }
  function B($) {
    const z = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const he = z.children[z.children.length - 1];
      he.position.end = Yr($.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(z.type) && (R.call(this, $), N.call(this, $));
  }
  function F() {
    this.data.atHardBreak = !0;
  }
  function W() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = $;
  }
  function L() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = $;
  }
  function H() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.value = $;
  }
  function J() {
    const $ = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const z = this.data.referenceType || "shortcut";
      $.type += "Reference", $.referenceType = z, delete $.url, delete $.title;
    } else
      delete $.identifier, delete $.label;
    this.data.referenceType = void 0;
  }
  function Y() {
    const $ = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const z = this.data.referenceType || "shortcut";
      $.type += "Reference", $.referenceType = z, delete $.url, delete $.title;
    } else
      delete $.identifier, delete $.label;
    this.data.referenceType = void 0;
  }
  function V($) {
    const z = this.sliceSerialize($), he = this.stack[this.stack.length - 2];
    he.label = nT(z), he.identifier = Wn(z).toLowerCase();
  }
  function Q() {
    const $ = this.stack[this.stack.length - 1], z = this.resume(), he = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, he.type === "link") {
      const Ie = $.children;
      he.children = Ie;
    } else
      he.alt = z;
  }
  function S() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.url = $;
  }
  function ue() {
    const $ = this.resume(), z = this.stack[this.stack.length - 1];
    z.title = $;
  }
  function ee() {
    this.data.inReference = void 0;
  }
  function A() {
    this.data.referenceType = "collapsed";
  }
  function le($) {
    const z = this.resume(), he = this.stack[this.stack.length - 1];
    he.label = z, he.identifier = Wn(this.sliceSerialize($)).toLowerCase(), this.data.referenceType = "full";
  }
  function ge($) {
    this.data.characterReferenceType = $.type;
  }
  function Ee($) {
    const z = this.sliceSerialize($), he = this.data.characterReferenceType;
    let Ie;
    he ? (Ie = tT(z, he === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Ie = jp(z);
    const Ve = this.stack[this.stack.length - 1];
    Ve.value += Ie;
  }
  function Qe($) {
    const z = this.stack.pop();
    z.position.end = Yr($.end);
  }
  function Te($) {
    N.call(this, $);
    const z = this.stack[this.stack.length - 1];
    z.url = this.sliceSerialize($);
  }
  function ce($) {
    N.call(this, $);
    const z = this.stack[this.stack.length - 1];
    z.url = "mailto:" + this.sliceSerialize($);
  }
  function nt() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function pt() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function mt() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function je() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Vt() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Un() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function vr() {
    return {
      type: "break"
    };
  }
  function Sr() {
    return {
      type: "html",
      value: ""
    };
  }
  function _r() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function zt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function qr($) {
    return {
      type: "list",
      ordered: $.type === "listOrdered",
      start: null,
      spread: $._spread,
      children: []
    };
  }
  function _a($) {
    return {
      type: "listItem",
      spread: $._spread,
      checked: null,
      children: []
    };
  }
  function Hu() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Fu() {
    return {
      type: "strong",
      children: []
    };
  }
  function Uu() {
    return {
      type: "text",
      value: ""
    };
  }
  function ju() {
    return {
      type: "thematicBreak"
    };
  }
}
function Yr(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function UT(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? UT(e, r) : eH(e, r);
  }
}
function eH(e, t) {
  let n;
  for (n in t)
    if (FT.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function H1(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + vs({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + vs({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + vs({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function tH(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return X$(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function nH(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function rH(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function oH(e, t) {
  const n = t.value ? t.value + `
` : "", r = {}, o = t.lang ? t.lang.split(/\s+/) : [];
  o.length > 0 && (r.className = ["language-" + o[0]]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function iH(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function sH(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function aH(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), o = Ki(r.toLowerCase()), i = e.footnoteOrder.indexOf(r);
  let s, a = e.footnoteCounts.get(r);
  a === void 0 ? (a = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = i + 1, a += 1, e.footnoteCounts.set(r, a);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + o,
      id: n + "fnref-" + o + (a > 1 ? "-" + a : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function lH(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function cH(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function jT(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const o = e.all(t), i = o[0];
  i && i.type === "text" ? i.value = "[" + i.value : o.unshift({ type: "text", value: "[" });
  const s = o[o.length - 1];
  return s && s.type === "text" ? s.value += r : o.push({ type: "text", value: r }), o;
}
function uH(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return jT(e, t);
  const o = { src: Ki(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const i = { type: "element", tagName: "img", properties: o, children: [] };
  return e.patch(t, i), e.applyData(t, i);
}
function dH(e, t) {
  const n = { src: Ki(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function fH(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function hH(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return jT(e, t);
  const o = { href: Ki(r.url || "") };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: o,
    children: e.all(t)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function pH(e, t) {
  const n = { href: Ki(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function mH(e, t, n) {
  const r = e.all(t), o = n ? gH(n) : VT(t), i = {}, s = [];
  if (typeof t.checked == "boolean") {
    const u = r[0];
    let d;
    u && u.type === "element" && u.tagName === "p" ? d = u : (d = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), i.className = ["task-list-item"];
  }
  let a = -1;
  for (; ++a < r.length; ) {
    const u = r[a];
    (o || a !== 0 || u.type !== "element" || u.tagName !== "p") && s.push({ type: "text", value: `
` }), u.type === "element" && u.tagName === "p" && !o ? s.push(...u.children) : s.push(u);
  }
  const l = r[r.length - 1];
  l && (o || l.type !== "element" || l.tagName !== "p") && s.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: i, children: s };
  return e.patch(t, c), e.applyData(t, c);
}
function gH(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = VT(n[r]);
  }
  return t;
}
function VT(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function bH(e, t) {
  const n = {}, r = e.all(t);
  let o = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++o < r.length; ) {
    const s = r[o];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const i = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function yH(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function EH(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function kH(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function CH(e, t) {
  const n = e.all(t), r = n.shift(), o = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), o.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, a = kC(t.children[1]), l = EC(t.children[t.children.length - 1]);
    a && l && (s.position = { start: a, end: l }), o.push(s);
  }
  const i = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(o, !0)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function TH(e, t, n) {
  const r = n ? n.children : void 0, i = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, a = s ? s.length : t.children.length;
  let l = -1;
  const c = [];
  for (; ++l < a; ) {
    const d = t.children[l], f = {}, h = s ? s[l] : void 0;
    h && (f.align = h);
    let p = { type: "element", tagName: i, properties: f, children: [] };
    d && (p.children = e.all(d), e.patch(d, p), p = e.applyData(d, p)), c.push(p);
  }
  const u = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function xH(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const F1 = 9, U1 = 32;
function wH(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), o = 0;
  const i = [];
  for (; r; )
    i.push(
      j1(t.slice(o, r.index), o > 0, !0),
      r[0]
    ), o = r.index + r[0].length, r = n.exec(t);
  return i.push(j1(t.slice(o), o > 0, !1)), i.join("");
}
function j1(e, t, n) {
  let r = 0, o = e.length;
  if (t) {
    let i = e.codePointAt(r);
    for (; i === F1 || i === U1; )
      r++, i = e.codePointAt(r);
  }
  if (n) {
    let i = e.codePointAt(o - 1);
    for (; i === F1 || i === U1; )
      o--, i = e.codePointAt(o - 1);
  }
  return o > r ? e.slice(r, o) : "";
}
function vH(e, t) {
  const n = { type: "text", value: wH(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function SH(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Xf = {
  blockquote: nH,
  break: rH,
  code: oH,
  delete: iH,
  emphasis: sH,
  footnoteReference: aH,
  heading: lH,
  html: cH,
  imageReference: uH,
  image: dH,
  inlineCode: fH,
  linkReference: hH,
  link: pH,
  listItem: mH,
  list: bH,
  paragraph: yH,
  // @ts-expect-error: root is different, but hard to type.
  root: EH,
  strong: kH,
  table: CH,
  tableCell: xH,
  tableRow: TH,
  text: vH,
  thematicBreak: SH,
  toml: Za,
  yaml: Za,
  definition: Za,
  footnoteDefinition: Za
};
function Za() {
}
function _H(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function AH(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function IH(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || _H, r = e.options.footnoteBackLabel || AH, o = e.options.footnoteLabel || "Footnotes", i = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, a = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!c)
      continue;
    const u = e.all(c), d = String(c.identifier).toUpperCase(), f = Ki(d.toLowerCase());
    let h = 0;
    const p = [], m = e.footnoteCounts.get(d);
    for (; m !== void 0 && ++h <= m; ) {
      p.length > 0 && p.push({ type: "text", value: " " });
      let k = typeof n == "string" ? n : n(l, h);
      typeof k == "string" && (k = { type: "text", value: k }), p.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + f + (h > 1 ? "-" + h : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, h),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(k) ? k : [k]
      });
    }
    const b = u[u.length - 1];
    if (b && b.type === "element" && b.tagName === "p") {
      const k = b.children[b.children.length - 1];
      k && k.type === "text" ? k.value += " " : b.children.push({ type: "text", value: " " }), b.children.push(...p);
    } else
      u.push(...p);
    const y = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + f },
      children: e.wrap(u, !0)
    };
    e.patch(c, y), a.push(y);
  }
  if (a.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: i,
          properties: {
            ...Ri(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: o }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(a, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Jf = {}.hasOwnProperty, NH = {};
function MH(e, t) {
  const n = t || NH, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = { ...Xf, ...n.handlers }, a = {
    all: c,
    applyData: OH,
    definitionById: r,
    footnoteById: o,
    footnoteCounts: i,
    footnoteOrder: [],
    handlers: s,
    one: l,
    options: n,
    patch: LH,
    wrap: RH
  };
  return Go(e, function(u) {
    if (u.type === "definition" || u.type === "footnoteDefinition") {
      const d = u.type === "definition" ? r : o, f = String(u.identifier).toUpperCase();
      d.has(f) || d.set(f, u);
    }
  }), a;
  function l(u, d) {
    const f = u.type, h = a.handlers[f];
    if (Jf.call(a.handlers, f) && h)
      return h(a, u, d);
    if (a.options.passThrough && a.options.passThrough.includes(f)) {
      if ("children" in u) {
        const { children: m, ...b } = u, y = Ri(b);
        return y.children = a.all(u), y;
      }
      return Ri(u);
    }
    return (a.options.unknownHandler || DH)(a, u, d);
  }
  function c(u) {
    const d = [];
    if ("children" in u) {
      const f = u.children;
      let h = -1;
      for (; ++h < f.length; ) {
        const p = a.one(f[h], u);
        if (p) {
          if (h && f[h - 1].type === "break" && (!Array.isArray(p) && p.type === "text" && (p.value = V1(p.value)), !Array.isArray(p) && p.type === "element")) {
            const m = p.children[0];
            m && m.type === "text" && (m.value = V1(m.value));
          }
          Array.isArray(p) ? d.push(...p) : d.push(p);
        }
      }
    }
    return d;
  }
}
function LH(e, t) {
  e.position && (t.position = TC(e));
}
function OH(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, o = e.data.hChildren, i = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && i && Object.assign(n.properties, Ri(i)), "children" in n && n.children && o !== null && o !== void 0 && (n.children = o);
  }
  return n;
}
function DH(e, t) {
  const n = t.data || {}, r = "value" in t && !(Jf.call(n, "hProperties") || Jf.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function RH(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function V1(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function z1(e, t) {
  const n = MH(e, t), r = n.one(e, void 0), o = IH(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return o && i.children.push({ type: "text", value: `
` }, o), i;
}
function PH(e, t) {
  return e && "run" in e ? async function(n, r) {
    const o = (
      /** @type {HastRoot} */
      z1(n, { file: r, ...t })
    );
    await e.run(o, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      z1(n, { file: r, ...e || t })
    );
  };
}
const BH = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], $H = /["&'<>`]/g, HH = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, FH = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), UH = /[|\\{}()[\]^$+*?.]/g, q1 = /* @__PURE__ */ new WeakMap();
function jH(e, t) {
  if (e = e.replace(
    t.subset ? VH(t.subset) : $H,
    r
  ), t.subset || t.escapeOnly)
    return e;
  return e.replace(HH, n).replace(FH, r);
  function n(o, i, s) {
    return t.format(
      (o.charCodeAt(0) - 55296) * 1024 + o.charCodeAt(1) - 56320 + 65536,
      s.charCodeAt(i + 2),
      t
    );
  }
  function r(o, i, s) {
    return t.format(
      o.charCodeAt(0),
      s.charCodeAt(i + 1),
      t
    );
  }
}
function VH(e) {
  let t = q1.get(e);
  return t || (t = zH(e), q1.set(e, t)), t;
}
function zH(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t.push(e[n].replace(UH, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
const qH = /[\dA-Fa-f]/;
function WH(e, t, n) {
  const r = "&#x" + e.toString(16).toUpperCase();
  return n && t && !qH.test(String.fromCharCode(t)) ? r : r + ";";
}
const GH = /\d/;
function YH(e, t, n) {
  const r = "&#" + String(e);
  return n && t && !GH.test(String.fromCharCode(t)) ? r : r + ";";
}
const KH = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], Id = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
}, QH = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], zT = {}.hasOwnProperty, eh = {};
let Xa;
for (Xa in Id)
  zT.call(Id, Xa) && (eh[Id[Xa]] = Xa);
const ZH = /[^\dA-Za-z]/;
function XH(e, t, n, r) {
  const o = String.fromCharCode(e);
  if (zT.call(eh, o)) {
    const i = eh[o], s = "&" + i;
    return n && KH.includes(i) && !QH.includes(i) && (!r || t && t !== 61 && ZH.test(String.fromCharCode(t))) ? s : s + ";";
  }
  return "";
}
function JH(e, t, n) {
  let r = WH(e, t, n.omitOptionalSemicolons), o;
  if ((n.useNamedReferences || n.useShortestReferences) && (o = XH(
    e,
    t,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !o) && n.useShortestReferences) {
    const i = YH(e, t, n.omitOptionalSemicolons);
    i.length < r.length && (r = i);
  }
  return o && (!n.useShortestReferences || o.length < r.length) ? o : r;
}
function wi(e, t) {
  return jH(e, Object.assign({ format: JH }, t));
}
const eF = /^>|^->|<!--|-->|--!>|<!-$/g, tF = [">"], nF = ["<", ">"];
function rF(e, t, n, r) {
  return r.settings.bogusComments ? "<?" + wi(
    e.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: tF
    })
  ) + ">" : "<!--" + e.value.replace(eF, o) + "-->";
  function o(i) {
    return wi(
      i,
      Object.assign({}, r.settings.characterReferences, {
        subset: nF
      })
    );
  }
}
function oF(e, t, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
const Ct = WT(1), qT = WT(-1), iF = [];
function WT(e) {
  return t;
  function t(n, r, o) {
    const i = n ? n.children : iF;
    let s = (r || 0) + e, a = i[s];
    if (!o)
      for (; a && ga(a); )
        s += e, a = i[s];
    return a;
  }
}
const sF = {}.hasOwnProperty;
function GT(e) {
  return t;
  function t(n, r, o) {
    return sF.call(e, n.tagName) && e[n.tagName](n, r, o);
  }
}
const Kp = GT({
  body: lF,
  caption: Nd,
  colgroup: Nd,
  dd: fF,
  dt: dF,
  head: Nd,
  html: aF,
  li: uF,
  optgroup: hF,
  option: pF,
  p: cF,
  rp: W1,
  rt: W1,
  tbody: gF,
  td: G1,
  tfoot: bF,
  th: G1,
  thead: mF,
  tr: yF
});
function Nd(e, t, n) {
  const r = Ct(n, t, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && ga(r.value.charAt(0)));
}
function aF(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type !== "comment";
}
function lF(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type !== "comment";
}
function cF(e, t, n) {
  const r = Ct(n, t);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function uF(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type === "element" && r.tagName === "li";
}
function dF(e, t, n) {
  const r = Ct(n, t);
  return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"));
}
function fF(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function W1(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function hF(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function pF(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function mF(e, t, n) {
  const r = Ct(n, t);
  return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"));
}
function gF(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function bF(e, t, n) {
  return !Ct(n, t);
}
function yF(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type === "element" && r.tagName === "tr";
}
function G1(e, t, n) {
  const r = Ct(n, t);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const EF = GT({
  body: TF,
  colgroup: xF,
  head: CF,
  html: kF,
  tbody: wF
});
function kF(e) {
  const t = Ct(e, -1);
  return !t || t.type !== "comment";
}
function CF(e) {
  const t = /* @__PURE__ */ new Set();
  for (const r of e.children)
    if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
      if (t.has(r.tagName)) return !1;
      t.add(r.tagName);
    }
  const n = e.children[0];
  return !n || n.type === "element";
}
function TF(e) {
  const t = Ct(e, -1, !0);
  return !t || t.type !== "comment" && !(t.type === "text" && ga(t.value.charAt(0))) && !(t.type === "element" && (t.tagName === "meta" || t.tagName === "link" || t.tagName === "script" || t.tagName === "style" || t.tagName === "template"));
}
function xF(e, t, n) {
  const r = qT(n, t), o = Ct(e, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && Kp(r, n.children.indexOf(r), n) ? !1 : !!(o && o.type === "element" && o.tagName === "col");
}
function wF(e, t, n) {
  const r = qT(n, t), o = Ct(e, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && Kp(r, n.children.indexOf(r), n) ? !1 : !!(o && o.type === "element" && o.tagName === "tr");
}
const Ja = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function vF(e, t, n, r) {
  const o = r.schema, i = o.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let s = o.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(e.tagName.toLowerCase());
  const a = [];
  let l;
  o.space === "html" && e.tagName === "svg" && (r.schema = ha);
  const c = SF(r, e.properties), u = r.all(
    o.space === "html" && e.tagName === "template" ? e.content : e
  );
  return r.schema = o, u && (s = !1), (c || !i || !EF(e, t, n)) && (a.push("<", e.tagName, c ? " " + c : ""), s && (o.space === "svg" || r.settings.closeSelfClosing) && (l = c.charAt(c.length - 1), (!r.settings.tightSelfClosing || l === "/" || l && l !== '"' && l !== "'") && a.push(" "), a.push("/")), a.push(">")), a.push(u), !s && (!i || !Kp(e, t, n)) && a.push("</" + e.tagName + ">"), a.join("");
}
function SF(e, t) {
  const n = [];
  let r = -1, o;
  if (t) {
    for (o in t)
      if (t[o] !== null && t[o] !== void 0) {
        const i = _F(e, o, t[o]);
        i && n.push(i);
      }
  }
  for (; ++r < n.length; ) {
    const i = e.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
    r !== n.length - 1 && i !== '"' && i !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function _F(e, t, n) {
  const r = wp(e.schema, t), o = e.settings.allowParseErrors && e.schema.space === "html" ? 0 : 1, i = e.settings.allowDangerousCharacters ? 0 : 1;
  let s = e.quote, a;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean) && (typeof n != "string" || n === r.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const l = wi(
    r.attribute,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: Ja.name[o][i]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? CL : xL)(n, {
    padLeft: !e.settings.tightCommaSeparatedLists
  }) : String(n), e.settings.collapseEmptyAttributes && !n) ? l : (e.settings.preferUnquoted && (a = wi(
    n,
    Object.assign({}, e.settings.characterReferences, {
      attribute: !0,
      subset: Ja.unquoted[o][i]
    })
  )), a !== n && (e.settings.quoteSmart && ic(n, s) > ic(n, e.alternative) && (s = e.alternative), a = s + wi(
    n,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (s === "'" ? Ja.single : Ja.double)[o][i],
      attribute: !0
    })
  ) + s), l + (a && "=" + a));
}
const AF = ["<", "&"];
function YT(e, t, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? e.value : wi(
    e.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: AF
    })
  );
}
function IF(e, t, n, r) {
  return r.settings.allowDangerousHtml ? e.value : YT(e, t, n, r);
}
function NF(e, t, n, r) {
  return r.all(e);
}
const MF = UC("type", {
  invalid: LF,
  unknown: OF,
  handlers: { comment: rF, doctype: oF, element: vF, raw: IF, root: NF, text: YT }
});
function LF(e) {
  throw new Error("Expected node, not `" + e + "`");
}
function OF(e) {
  const t = (
    /** @type {Nodes} */
    e
  );
  throw new Error("Cannot compile unknown node `" + t.type + "`");
}
const DF = {}, RF = {}, PF = [];
function BF(e, t) {
  const n = t || DF, r = n.quote || '"', o = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: $F,
    all: HF,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || BH,
      characterReferences: n.characterReferences || RF,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? ha : ru,
    quote: r,
    alternative: o
  }.one(
    Array.isArray(e) ? { type: "root", children: e } : e,
    void 0,
    void 0
  );
}
function $F(e, t, n) {
  return MF(e, t, n, this);
}
function HF(e) {
  const t = [], n = e && e.children || PF;
  let r = -1;
  for (; ++r < n.length; )
    t[r] = this.one(n[r], r, e);
  return t.join("");
}
function FF(e) {
  const t = this, n = { ...t.data("settings"), ...e };
  t.compiler = r;
  function r(o) {
    return BF(o, n);
  }
}
var UF = Object.defineProperty, jF = (e, t, n) => t in e ? UF(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Pe = (e, t, n) => jF(e, typeof t != "symbol" ? t + "" : t, n);
function VF(e, t, n, r = "before") {
  const o = typeof n == "string" ? n : n.id, i = ht(e), s = t.map(
    (c) => Ko(c, i)
  ), a = Yt(o, e.doc);
  if (!a)
    throw new Error(`Block with ID ${o} not found`);
  let l = a.posBeforeNode;
  return r === "after" && (l += a.node.nodeSize), e.step(
    new Sc(l, l, new lt(be.from(s), 0, 0))
  ), s.map(
    (c) => ct(c, i)
  );
}
function th(e) {
  if (!e || e.type.name !== "column")
    throw new Error("Invalid columnPos: does not point to column node.");
  const t = e.firstChild;
  if (!t)
    throw new Error("Invalid column: does not have child node.");
  const n = t.firstChild;
  if (!n)
    throw new Error("Invalid blockContainer: does not have child node.");
  return e.childCount === 1 && t.childCount === 1 && n.type.name === "paragraph" && n.content.content.length === 0;
}
function zF(e, t) {
  const n = e.doc.resolve(t), r = n.nodeAfter;
  if (!r || r.type.name !== "columnList")
    throw new Error(
      "Invalid columnListPos: does not point to columnList node."
    );
  for (let o = r.childCount - 1; o >= 0; o--) {
    const i = e.doc.resolve(n.pos + 1).posAtIndex(o), s = e.doc.resolve(i).nodeAfter;
    if (!s || s.type.name !== "column")
      throw new Error("Invalid columnPos: does not point to column node.");
    th(s) && e.delete(i, i + s.nodeSize);
  }
}
function nh(e, t) {
  zF(e, t);
  const n = e.doc.resolve(t).nodeAfter;
  if (!n || n.type.name !== "columnList")
    throw new Error(
      "Invalid columnListPos: does not point to columnList node."
    );
  if (n.childCount > 2)
    return;
  if (n.childCount < 2)
    throw new Error("Invalid columnList: contains fewer than two children.");
  const r = t + 1, o = e.doc.resolve(r).nodeAfter, i = t + n.nodeSize - 1, s = e.doc.resolve(i).nodeBefore;
  if (!o || !s)
    throw new Error("Invalid columnList: does not contain children.");
  const a = th(o), l = th(s);
  if (a && l) {
    e.delete(t, t + n.nodeSize);
    return;
  }
  if (a) {
    e.step(
      new As(
        // Replaces `columnList`.
        t,
        t + n.nodeSize,
        // Replaces with content of last `column`.
        i - s.nodeSize + 1,
        i - 1,
        // Doesn't append anything.
        lt.empty,
        0,
        !1
      )
    );
    return;
  }
  if (l) {
    e.step(
      new As(
        // Replaces `columnList`.
        t,
        t + n.nodeSize,
        // Replaces with content of first `column`.
        r + 1,
        r + o.nodeSize - 1,
        // Doesn't append anything.
        lt.empty,
        0,
        !1
      )
    );
    return;
  }
}
function Y1(e, t, n) {
  const r = ht(e), o = n.map(
    (u) => Ko(u, r)
  ), i = new Set(
    t.map(
      (u) => typeof u == "string" ? u : u.id
    )
  ), s = [], a = /* @__PURE__ */ new Set(), l = typeof t[0] == "string" ? t[0] : t[0].id;
  let c = 0;
  if (e.doc.descendants((u, d) => {
    if (i.size === 0)
      return !1;
    if (!u.type.isInGroup("bnBlock") || !i.has(u.attrs.id))
      return !0;
    if (s.push(ct(u, r)), i.delete(u.attrs.id), n.length > 0 && u.attrs.id === l) {
      const m = e.doc.nodeSize;
      e.insert(d, o);
      const b = e.doc.nodeSize;
      c += m - b;
    }
    const f = e.doc.nodeSize, h = e.doc.resolve(d - c);
    h.node().type.name === "column" ? a.add(h.before(-1)) : h.node().type.name === "columnList" && a.add(h.before()), h.node().type.name === "blockGroup" && h.node(h.depth - 1).type.name !== "doc" && h.node().childCount === 1 ? e.delete(h.before(), h.after()) : e.delete(d - c, d - c + u.nodeSize);
    const p = e.doc.nodeSize;
    return c += f - p, !1;
  }), i.size > 0) {
    const u = [...i].join(`
`);
    throw Error(
      "Blocks with the following IDs could not be found in the editor: " + u
    );
  }
  return a.forEach((u) => nh(e, u)), { insertedBlocks: o.map(
    (u) => ct(u, r)
  ), removedBlocks: s };
}
function qF(e, t, n, r, o) {
  let i;
  if (t)
    if (typeof t == "string")
      i = Gn([t], e.pmSchema, r);
    else if (Array.isArray(t))
      i = Gn(t, e.pmSchema, r);
    else if (t.type === "tableContent")
      i = Hc(t, e.pmSchema);
    else
      throw new br(t.type);
  else throw new Error("blockContent is required");
  const s = ((o == null ? void 0 : o.document) ?? document).createDocumentFragment();
  for (const a of i)
    if (a.type.name !== "text" && e.schema.inlineContentSchema[a.type.name]) {
      const l = e.schema.inlineContentSpecs[a.type.name].implementation;
      if (l) {
        const c = Hh(
          a,
          e.schema.inlineContentSchema,
          e.schema.styleSchema
        ), u = l.render.call(
          {
            renderType: "dom",
            props: void 0
          },
          c,
          () => {
          },
          e
        );
        if (u) {
          if (s.appendChild(u.dom), u.contentDOM) {
            const d = n.serializeFragment(
              a.content,
              o
            );
            u.contentDOM.dataset.editable = "", u.contentDOM.appendChild(d);
          }
          continue;
        }
      }
    } else if (a.type.name === "text") {
      let l = document.createTextNode(
        a.textContent
      );
      for (const c of a.marks.toReversed())
        if (c.type.name in e.schema.styleSpecs) {
          const u = e.schema.styleSpecs[c.type.name].implementation.render(c.attrs.stringValue, e);
          u.contentDOM.appendChild(l), l = u.dom;
        } else {
          const u = c.type.spec.toDOM(c, !0), d = Po.renderSpec(document, u);
          d.contentDOM.appendChild(l), l = d.dom;
        }
      s.appendChild(l);
    } else {
      const l = n.serializeFragment(
        be.from([a]),
        o
      );
      s.appendChild(l);
    }
  return s;
}
function WF(e, t, n, r) {
  var o, i, s, a, l;
  const c = e.pmSchema.nodes.blockContainer, u = t.props || {};
  for (const [p, m] of Object.entries(
    e.schema.blockSchema[t.type].propSchema
  ))
    !(p in u) && m.default !== void 0 && (u[p] = m.default);
  const d = t.children || [], f = e.blockImplementations[t.type].implementation.render.call(
    {
      renderType: "dom",
      props: void 0
    },
    { ...t, props: u, children: d },
    e
  );
  if (f.contentDOM && t.content) {
    const p = qF(
      e,
      t.content,
      // TODO
      n,
      t.type,
      r
    );
    f.contentDOM.appendChild(p);
  }
  if (e.pmSchema.nodes[t.type].isInGroup("bnBlock")) {
    if (t.children && t.children.length > 0) {
      const p = KT(
        e,
        t.children,
        n,
        r
      );
      (o = f.contentDOM) == null || o.append(p);
    }
    return f.dom;
  }
  const h = (s = (i = c.spec) == null ? void 0 : i.toDOM) == null ? void 0 : s.call(
    i,
    c.create({
      id: t.id,
      ...u
    })
  );
  return (a = h.contentDOM) == null || a.appendChild(f.dom), t.children && t.children.length > 0 && ((l = h.contentDOM) == null || l.appendChild(
    QT(e, t.children, n, r)
  )), h.dom;
}
function KT(e, t, n, r) {
  const o = ((r == null ? void 0 : r.document) ?? document).createDocumentFragment();
  for (const i of t) {
    const s = WF(e, i, n, r);
    o.appendChild(s);
  }
  return o;
}
const QT = (e, t, n, r) => {
  var o;
  const i = e.pmSchema.nodes.blockGroup, s = i.spec.toDOM(i.create({})), a = KT(e, t, n, r);
  return (o = s.contentDOM) == null || o.appendChild(a), s.dom;
}, GF = (e) => (e.querySelectorAll(
  '[data-content-type="numberedListItem"]'
).forEach((t) => {
  var n, r;
  const o = (r = (n = t.closest(".bn-block-outer")) == null ? void 0 : n.previousElementSibling) == null ? void 0 : r.querySelector(
    '[data-content-type="numberedListItem"]'
  );
  if (!o)
    t.setAttribute(
      "data-index",
      t.getAttribute("data-start") || "1"
    );
  else {
    const i = o.getAttribute("data-index");
    t.setAttribute(
      "data-index",
      (parseInt(i || "0") + 1).toString()
    );
  }
}), e), YF = (e) => (e.querySelectorAll(
  '[data-content-type="checkListItem"] input'
).forEach((t) => {
  t.disabled = !0;
}), e), KF = (e) => (e.querySelectorAll(
  '.bn-toggle-wrapper[data-show-children="false"]'
).forEach((t) => {
  t.setAttribute("data-show-children", "true");
}), e), QF = (e) => (e.querySelectorAll('[data-content-type="table"] table').forEach((t) => {
  t.setAttribute(
    "style",
    `--default-cell-min-width: ${nu}px;`
  ), t.setAttribute("data-show-children", "true");
}), e), ZF = (e) => (e.querySelectorAll('[data-content-type="table"] table').forEach((t) => {
  var n;
  const r = document.createElement("div");
  r.className = "tableWrapper";
  const o = document.createElement("div");
  o.className = "tableWrapper-inner", r.appendChild(o), (n = t.parentElement) == null || n.appendChild(r), r.appendChild(t);
}), e), XF = (e) => (e.querySelectorAll(
  ".bn-inline-content:empty"
).forEach((t) => {
  const n = document.createElement("span");
  n.className = "ProseMirror-trailingBreak", n.setAttribute("style", "display: inline-block;"), t.appendChild(n);
}), e), JF = (e, t) => {
  const n = Po.fromSchema(e), r = [
    GF,
    YF,
    KF,
    QF,
    ZF,
    XF
  ];
  return {
    serializeBlocks: (o, i) => {
      let s = QT(
        t,
        o,
        n,
        i
      );
      for (const a of r)
        s = a(s);
      return s.outerHTML;
    }
  };
};
function eU(e) {
  return e.transact((t) => {
    const n = so(t.doc, t.selection.anchor);
    if (t.selection instanceof qe)
      return {
        type: "cell",
        anchorBlockId: n.node.attrs.id,
        anchorCellOffset: t.selection.$anchorCell.pos - n.posBeforeNode,
        headCellOffset: t.selection.$headCell.pos - n.posBeforeNode
      };
    if (t.selection instanceof cn)
      return {
        type: "node",
        anchorBlockId: n.node.attrs.id
      };
    {
      const r = so(t.doc, t.selection.head);
      return {
        type: "text",
        anchorBlockId: n.node.attrs.id,
        headBlockId: r.node.attrs.id,
        anchorOffset: t.selection.anchor - n.posBeforeNode,
        headOffset: t.selection.head - r.posBeforeNode
      };
    }
  });
}
function tU(e, t) {
  var n, r;
  const o = (n = Yt(t.anchorBlockId, e.doc)) == null ? void 0 : n.posBeforeNode;
  if (o === void 0)
    throw new Error(
      `Could not find block with ID ${t.anchorBlockId} to update selection`
    );
  let i;
  if (t.type === "cell")
    i = qe.create(
      e.doc,
      o + t.anchorCellOffset,
      o + t.headCellOffset
    );
  else if (t.type === "node")
    i = cn.create(e.doc, o + 1);
  else {
    const s = (r = Yt(t.headBlockId, e.doc)) == null ? void 0 : r.posBeforeNode;
    if (s === void 0)
      throw new Error(
        `Could not find block with ID ${t.headBlockId} to update selection`
      );
    i = pe.create(
      e.doc,
      o + t.anchorOffset,
      s + t.headOffset
    );
  }
  e.setSelection(i);
}
function rh(e) {
  return e.map((t) => t.type === "columnList" ? t.children.map((n) => rh(n.children)).flat() : {
    ...t,
    children: rh(t.children)
  }).flat();
}
function ZT(e, t, n) {
  e.transact((r) => {
    var o;
    const i = ((o = e.getSelection()) == null ? void 0 : o.blocks) || [
      e.getTextCursorPosition().block
    ], s = eU(e);
    e.removeBlocks(i), e.insertBlocks(rh(i), t, n), tU(r, s);
  });
}
function XT(e) {
  return !e || e.type !== "columnList";
}
function JT(e, t, n) {
  let r, o;
  if (t ? t.children.length > 0 ? (r = t.children[t.children.length - 1], o = "after") : (r = t, o = "before") : n && (r = n, o = "before"), !r || !o)
    return;
  const i = e.getParentBlock(r);
  return XT(i) ? { referenceBlock: r, placement: o } : JT(
    e,
    o === "after" ? r : e.getPrevBlock(r),
    i
  );
}
function ex(e, t, n) {
  let r, o;
  if (t ? t.children.length > 0 ? (r = t.children[0], o = "before") : (r = t, o = "after") : n && (r = n, o = "after"), !r || !o)
    return;
  const i = e.getParentBlock(r);
  return XT(i) ? { referenceBlock: r, placement: o } : ex(
    e,
    o === "before" ? r : e.getNextBlock(r),
    i
  );
}
function nU(e) {
  e.transact(() => {
    const t = e.getSelection(), n = (t == null ? void 0 : t.blocks[0]) || e.getTextCursorPosition().block, r = JT(
      e,
      e.getPrevBlock(n),
      e.getParentBlock(n)
    );
    r && ZT(
      e,
      r.referenceBlock,
      r.placement
    );
  });
}
function rU(e) {
  e.transact(() => {
    const t = e.getSelection(), n = (t == null ? void 0 : t.blocks[(t == null ? void 0 : t.blocks.length) - 1]) || e.getTextCursorPosition().block, r = ex(
      e,
      e.getNextBlock(n),
      e.getParentBlock(n)
    );
    r && ZT(
      e,
      r.referenceBlock,
      r.placement
    );
  });
}
function oU(e, t, n) {
  const { $from: r, $to: o } = e.selection, i = r.blockRange(
    o,
    (h) => h.childCount > 0 && (h.type.name === "blockGroup" || h.type.name === "column")
    // change necessary to not look at first item child type
  );
  if (!i)
    return !1;
  const s = i.startIndex;
  if (s === 0)
    return !1;
  const a = i.parent.child(s - 1);
  if (a.type !== t)
    return !1;
  const l = a.lastChild && a.lastChild.type === n, c = be.from(l ? t.create() : null), u = new lt(
    be.from(
      t.create(null, be.from(n.create(null, c)))
      // change necessary to create "groupType" instead of parent.type
    ),
    l ? 3 : 1,
    0
  ), d = i.start, f = i.end;
  return e.step(
    new As(
      d - (l ? 3 : 1),
      f,
      d,
      f,
      u,
      1,
      !0
    )
  ).scrollIntoView(), !0;
}
function tx(e) {
  return e.transact((t) => oU(
    t,
    e.pmSchema.nodes.blockContainer,
    e.pmSchema.nodes.blockGroup
  ));
}
function iU(e) {
  e._tiptapEditor.commands.liftListItem("blockContainer");
}
function sU(e) {
  return e.transact((t) => {
    const { bnBlock: n } = ra(t);
    return t.doc.resolve(n.beforePos).nodeBefore !== null;
  });
}
function aU(e) {
  return e.transact((t) => {
    const { bnBlock: n } = ra(t);
    return t.doc.resolve(n.beforePos).depth > 1;
  });
}
function lU(e, t) {
  const n = typeof t == "string" ? t : t.id, r = ht(e), o = Yt(n, e);
  if (o)
    return ct(o.node, r);
}
function cU(e, t) {
  const n = typeof t == "string" ? t : t.id, r = Yt(n, e), o = ht(e);
  if (!r)
    return;
  const i = e.resolve(r.posBeforeNode).nodeBefore;
  if (i)
    return ct(i, o);
}
function uU(e, t) {
  const n = typeof t == "string" ? t : t.id, r = Yt(n, e), o = ht(e);
  if (!r)
    return;
  const i = e.resolve(
    r.posBeforeNode + r.node.nodeSize
  ).nodeAfter;
  if (i)
    return ct(i, o);
}
function dU(e, t) {
  const n = typeof t == "string" ? t : t.id, r = ht(e), o = Yt(n, e);
  if (!o)
    return;
  const i = e.resolve(o.posBeforeNode), s = i.node(), a = i.node(-1), l = a.type.name !== "doc" ? s.type.name === "blockGroup" ? a : s : void 0;
  if (l)
    return ct(l, r);
}
let fU = class {
  constructor(t) {
    this.editor = t;
  }
  /**
   * Gets a snapshot of all top-level (non-nested) blocks in the editor.
   * @returns A snapshot of all top-level (non-nested) blocks in the editor.
   */
  get document() {
    return this.editor.transact((t) => Y_(t.doc, this.editor.pmSchema));
  }
  /**
   * Gets a snapshot of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block that should be
   * retrieved.
   * @returns The block that matches the identifier, or `undefined` if no
   * matching block was found.
   */
  getBlock(t) {
    return this.editor.transact((n) => lU(n.doc, t));
  }
  /**
   * Gets a snapshot of the previous sibling of an existing block from the
   * editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * previous sibling should be retrieved.
   * @returns The previous sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the first child/block
   * in the document.
   */
  getPrevBlock(t) {
    return this.editor.transact((n) => cU(n.doc, t));
  }
  /**
   * Gets a snapshot of the next sibling of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * next sibling should be retrieved.
   * @returns The next sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the last child/block in
   * the document.
   */
  getNextBlock(t) {
    return this.editor.transact((n) => uU(n.doc, t));
  }
  /**
   * Gets a snapshot of the parent of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * parent should be retrieved.
   * @returns The parent of the block that matches the identifier. `undefined`
   * if no matching block was found, or the block isn't nested.
   */
  getParentBlock(t) {
    return this.editor.transact(
      (n) => dU(n.doc, t)
    );
  }
  /**
   * Traverses all blocks in the editor depth-first, and executes a callback for each.
   * @param callback The callback to execute for each block. Returning `false` stops the traversal.
   * @param reverse Whether the blocks should be traversed in reverse order.
   */
  forEachBlock(t, n = !1) {
    const r = this.document.slice();
    n && r.reverse();
    function o(i) {
      for (const s of i) {
        if (t(s) === !1)
          return !1;
        const a = n ? s.children.slice().reverse() : s.children;
        if (!o(a))
          return !1;
      }
      return !0;
    }
    o(r);
  }
  /**
   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
   * error if the reference block could not be found.
   * @param blocksToInsert An array of partial blocks that should be inserted.
   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
   * `referenceBlock`.
   */
  insertBlocks(t, n, r = "before") {
    return this.editor.transact(
      (o) => VF(o, t, n, r)
    );
  }
  /**
   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
   * not be found.
   * @param blockToUpdate The block that should be updated.
   * @param update A partial block which defines how the existing block should be changed.
   */
  updateBlock(t, n) {
    return this.editor.transact((r) => QM(r, t, n));
  }
  /**
   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
   */
  removeBlocks(t) {
    return this.editor.transact(
      (n) => Y1(n, t, []).removedBlocks
    );
  }
  /**
   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
   * @param blocksToRemove An array of blocks that should be replaced.
   * @param blocksToInsert An array of partial blocks to replace the old ones with.
   */
  replaceBlocks(t, n) {
    return this.editor.transact(
      (r) => Y1(r, t, n)
    );
  }
  /**
   * Checks if the block containing the text cursor can be nested.
   */
  canNestBlock() {
    return sU(this.editor);
  }
  /**
   * Nests the block containing the text cursor into the block above it.
   */
  nestBlock() {
    tx(this.editor);
  }
  /**
   * Checks if the block containing the text cursor is nested.
   */
  canUnnestBlock() {
    return aU(this.editor);
  }
  /**
   * Lifts the block containing the text cursor out of its parent.
   */
  unnestBlock() {
    iU(this.editor);
  }
  /**
   * Moves the selected blocks up. If the previous block has children, moves
   * them to the end of its children. If there is no previous block, but the
   * current blocks share a common parent, moves them out of & before it.
   */
  moveBlocksUp() {
    return nU(this.editor);
  }
  /**
   * Moves the selected blocks down. If the next block has children, moves
   * them to the start of its children. If there is no next block, but the
   * current blocks share a common parent, moves them out of & after it.
   */
  moveBlocksDown() {
    return rU(this.editor);
  }
}, hU = class extends Gp {
  constructor(t) {
    super(), this.editor = t, t.on("create", () => {
      t._tiptapEditor.on(
        "update",
        ({ transaction: n, appendedTransactions: r }) => {
          this.emit("onChange", { editor: t, transaction: n, appendedTransactions: r });
        }
      ), t._tiptapEditor.on("selectionUpdate", ({ transaction: n }) => {
        this.emit("onSelectionChange", { editor: t, transaction: n });
      }), t._tiptapEditor.on("mount", () => {
        this.emit("onMount", { editor: t });
      }), t._tiptapEditor.on("unmount", () => {
        this.emit("onUnmount", { editor: t });
      });
    });
  }
  /**
   * Register a callback that will be called when the editor changes.
   */
  onChange(t, n = !0) {
    const r = ({
      transaction: o,
      appendedTransactions: i
    }) => {
      !n && K1(o) || t(this.editor, {
        getChanges() {
          return _T(
            o,
            i
          );
        }
      });
    };
    return this.on("onChange", r), () => {
      this.off("onChange", r);
    };
  }
  /**
   * Register a callback that will be called when the selection changes.
   */
  onSelectionChange(t, n = !1) {
    const r = (o) => {
      !n && K1(o.transaction) || t(this.editor);
    };
    return this.on("onSelectionChange", r), () => {
      this.off("onSelectionChange", r);
    };
  }
  /**
   * Register a callback that will be called when the editor is mounted.
   */
  onMount(t) {
    return this.on("onMount", t), () => {
      this.off("onMount", t);
    };
  }
  /**
   * Register a callback that will be called when the editor is unmounted.
   */
  onUnmount(t) {
    return this.on("onUnmount", t), () => {
      this.off("onUnmount", t);
    };
  }
};
function K1(e) {
  return !!e.getMeta("y-sync$");
}
function pU(e) {
  return Array.prototype.indexOf.call(e.parentElement.childNodes, e);
}
function mU(e) {
  return e.nodeType === 3 && !/\S/.test(e.nodeValue || "");
}
function gU(e) {
  e.querySelectorAll("li > ul, li > ol").forEach((t) => {
    const n = pU(t), r = t.parentElement, o = Array.from(r.childNodes).slice(
      n + 1
    );
    t.remove(), o.forEach((i) => {
      i.remove();
    }), r.insertAdjacentElement("afterend", t), o.reverse().forEach((i) => {
      if (mU(i))
        return;
      const s = document.createElement("li");
      s.append(i), t.insertAdjacentElement("afterend", s);
    }), r.childNodes.length === 0 && r.remove();
  });
}
function bU(e) {
  e.querySelectorAll("li + ul, li + ol").forEach((t) => {
    var n, r;
    const o = t.previousElementSibling, i = document.createElement("div");
    o.insertAdjacentElement("afterend", i), i.append(o);
    const s = document.createElement("div");
    for (s.setAttribute("data-node-type", "blockGroup"), i.append(s); ((n = i.nextElementSibling) == null ? void 0 : n.nodeName) === "UL" || ((r = i.nextElementSibling) == null ? void 0 : r.nodeName) === "OL"; )
      s.append(i.nextElementSibling);
  });
}
let Q1 = null;
function yU() {
  return Q1 || (Q1 = document.implementation.createHTMLDocument("title"));
}
function EU(e) {
  if (typeof e == "string") {
    const t = yU().createElement("div");
    t.innerHTML = e, e = t;
  }
  return gU(e), bU(e), e;
}
function nx(e, t) {
  const n = EU(e), r = Mn.fromSchema(t).parse(n, {
    topNode: t.nodes.blockGroup.create()
  }), o = [];
  for (let i = 0; i < r.childCount; i++)
    o.push(ct(r.child(i), t));
  return o;
}
function kU(e, t) {
  const n = t.value ? t.value : "", r = {};
  t.lang && (r["data-language"] = t.lang);
  let o = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = {
    type: "element",
    tagName: "pre",
    properties: {},
    children: [o]
  }, e.patch(t, o), o;
}
function CU(e, t) {
  var n;
  const r = String((t == null ? void 0 : t.url) || ""), o = t != null && t.title ? String(t.title) : void 0;
  let i = {
    type: "element",
    tagName: "video",
    properties: {
      src: r,
      "data-name": o,
      "data-url": r,
      controls: !0
    },
    children: []
  };
  return (n = e.patch) == null || n.call(e, t, i), i = e.applyData ? e.applyData(t, i) : i, i;
}
function rx(e) {
  return CT().use(tH).use(ET).use(PH, {
    handlers: {
      ...Xf,
      image: (t, n) => {
        const r = String((n == null ? void 0 : n.url) || "");
        return HM(r) ? CU(t, n) : Xf.image(t, n);
      },
      code: kU,
      blockquote: (t, n) => {
        const r = {
          type: "element",
          tagName: "blockquote",
          properties: {},
          // The only difference from the original is that we don't wrap the children with line endings
          children: t.wrap(t.all(n), !1)
        };
        return t.patch(n, r), t.applyData(n, r);
      }
    }
  }).use(FF).processSync(e).value;
}
function TU(e, t) {
  const n = rx(e);
  return nx(n, t);
}
let xU = class {
  constructor(t) {
    this.editor = t;
  }
  /**
   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list
   * items are un-nested in the output HTML.
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToHTMLLossy(t = this.editor.document) {
    return mu(
      this.editor.pmSchema,
      this.editor
    ).exportBlocks(t, {});
  }
  /**
   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.
   *
   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)
   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToFullHTML(t = this.editor.document) {
    return JF(
      this.editor.pmSchema,
      this.editor
    ).serializeBlocks(t, {});
  }
  /**
   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
   * @param html The HTML string to parse blocks from.
   * @returns The blocks parsed from the HTML string.
   */
  tryParseHTMLToBlocks(t) {
    return nx(t, this.editor.pmSchema);
  }
  /**
   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
   * @param blocks An array of blocks that should be serialized into Markdown.
   * @returns The blocks, serialized as a Markdown string.
   */
  blocksToMarkdownLossy(t = this.editor.document) {
    return VB(t, this.editor.pmSchema, this.editor, {});
  }
  /**
   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
   * as text.
   * @param markdown The Markdown string to parse blocks from.
   * @returns The blocks parsed from the Markdown string.
   */
  tryParseMarkdownToBlocks(t) {
    return TU(t, this.editor.pmSchema);
  }
  /**
   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.
   * @param html The HTML to paste.
   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.
   */
  pasteHTML(t, n = !1) {
    var r;
    let o = t;
    if (!n) {
      const i = this.tryParseHTMLToBlocks(t);
      o = this.blocksToFullHTML(i);
    }
    o && ((r = this.editor.prosemirrorView) == null || r.pasteHTML(o));
  }
  /**
   * Paste text into the editor. Defaults to interpreting text as markdown.
   * @param text The text to paste.
   */
  pasteText(t) {
    var n;
    return (n = this.editor.prosemirrorView) == null ? void 0 : n.pasteText(t);
  }
  /**
   * Paste markdown into the editor.
   * @param markdown The markdown to paste.
   */
  pasteMarkdown(t) {
    const n = rx(t);
    return this.pasteHTML(n);
  }
};
const Qp = [
  "vscode-editor-data",
  "blocknote/html",
  "text/markdown",
  "text/html",
  "text/plain",
  "Files"
];
function wU(e, t) {
  if (!e.startsWith(".") || !t.startsWith("."))
    throw new Error("The strings provided are not valid file extensions.");
  return e === t;
}
function vU(e, t) {
  const n = e.split("/"), r = t.split("/");
  if (n.length !== 2)
    throw new Error(`The string ${e} is not a valid MIME type.`);
  if (r.length !== 2)
    throw new Error(`The string ${t} is not a valid MIME type.`);
  return n[1] === "*" || r[1] === "*" ? n[0] === r[0] : (n[0] === "*" || r[0] === "*" || n[0] === r[0]) && n[1] === r[1];
}
function Z1(e, t, n, r = "after") {
  let o;
  return Array.isArray(t.content) && t.content.length === 0 ? o = e.updateBlock(t, n).id : o = e.insertBlocks(
    [n],
    t,
    r
  )[0].id, o;
}
async function ox(e, t) {
  var n;
  if (!t.uploadFile) {
    console.warn(
      "Attempted ot insert file, but uploadFile is not set in the BlockNote editor options"
    );
    return;
  }
  const r = "dataTransfer" in e ? e.dataTransfer : e.clipboardData;
  if (r === null)
    return;
  let o = null;
  for (const s of Qp)
    if (r.types.includes(s)) {
      o = s;
      break;
    }
  if (o !== "Files")
    return;
  const i = r.items;
  if (i) {
    e.preventDefault();
    for (let s = 0; s < i.length; s++) {
      let a = "file";
      for (const c of Object.values(t.schema.blockSpecs))
        for (const u of ((n = c.implementation.meta) == null ? void 0 : n.fileBlockAccept) || []) {
          const d = u.startsWith("."), f = i[s].getAsFile();
          if (f && (!d && f.type && vU(i[s].type, u) || d && wU(
            "." + f.name.split(".").pop(),
            u
          ))) {
            a = c.config.type;
            break;
          }
        }
      const l = i[s].getAsFile();
      if (l) {
        const c = {
          type: a,
          props: {
            name: l.name
          }
        };
        let u;
        if (e.type === "paste") {
          const h = t.getTextCursorPosition().block;
          u = Z1(t, h, c);
        } else if (e.type === "drop") {
          const h = {
            left: e.clientX,
            top: e.clientY
          }, p = t.prosemirrorView.posAtCoords(h);
          if (!p)
            return;
          u = t.transact((m) => {
            var b;
            const y = so(m.doc, p.pos), k = (b = t.domElement) == null ? void 0 : b.querySelector(
              `[data-id="${y.node.attrs.id}"]`
            ), C = k == null ? void 0 : k.getBoundingClientRect();
            return Z1(
              t,
              t.getBlock(y.node.attrs.id),
              c,
              C && (C.top + C.bottom) / 2 > h.top ? "before" : "after"
            );
          });
        } else
          return;
        const d = await t.uploadFile(l, u), f = typeof d == "string" ? {
          props: {
            url: d
          }
        } : { ...d };
        t.updateBlock(u, f);
      }
    }
  }
}
const SU = (e) => ut.create({
  name: "dropFile",
  addProseMirrorPlugins() {
    return [
      new me({
        props: {
          handleDOMEvents: {
            drop(t, n) {
              if (!e.isEditable)
                return;
              let r = null;
              for (const o of Qp)
                if (n.dataTransfer.types.includes(o)) {
                  r = o;
                  break;
                }
              return r === null ? !0 : r === "Files" ? (ox(n, e), !0) : !1;
            }
          }
        }
      })
    ];
  }
}), _U = /(^|\n) {0,3}#{1,6} {1,8}[^\n]{1,64}\r?\n\r?\n\s{0,32}\S/, AU = /(_|__|\*|\*\*|~~|==|\+\+)(?!\s)(?:[^\s](?:.{0,62}[^\s])?|\S)(?=\1)/, IU = /\[[^\]]{1,128}\]\(https?:\/\/\S{1,999}\)/, NU = /(?:\s|^)`(?!\s)(?:[^\s`](?:[^`]{0,46}[^\s`])?|[^\s`])`([^\w]|$)/, MU = /(?:^|\n)\s{0,5}-\s{1}[^\n]+\n\s{0,15}-\s/, LU = /(?:^|\n)\s{0,5}\d+\.\s{1}[^\n]+\n\s{0,15}\d+\.\s/, OU = /\n{2} {0,3}-{2,48}\n{2}/, DU = /(?:\n|^)(```|~~~|\$\$)(?!`|~)[^\s]{0,64} {0,64}[^\n]{0,64}\n[\s\S]{0,9999}?\s*\1 {0,64}(?:\n+|$)/, RU = /(?:\n|^)(?!\s)\w[^\n]{0,64}\r?\n(-|=)\1{0,64}\n\n\s{0,64}(\w|$)/, PU = /(?:^|(\r?\n\r?\n))( {0,3}>[^\n]{1,333}\n){1,999}($|(\r?\n))/, BU = /^\s*\|(.+\|)+\s*$/m, $U = /^\s*\|(\s*[-:]+[-:]\s*\|)+\s*$/m, HU = /^\s*\|(.+\|)+\s*$/m, FU = (e) => _U.test(e) || AU.test(e) || IU.test(e) || NU.test(e) || MU.test(e) || LU.test(e) || OU.test(e) || DU.test(e) || RU.test(e) || PU.test(e) || BU.test(e) || $U.test(e) || HU.test(e);
async function UU(e, t) {
  const { schema: n } = t.state;
  if (!e.clipboardData)
    return !1;
  const r = e.clipboardData.getData("text/plain");
  if (!r)
    return !1;
  if (!n.nodes.codeBlock)
    return t.pasteText(r), !0;
  const o = e.clipboardData.getData("vscode-editor-data"), i = o ? JSON.parse(o) : void 0, s = i == null ? void 0 : i.mode;
  return s ? (t.pasteHTML(
    `<pre><code class="language-${s}">${r.replace(
      /\r\n?/g,
      `
`
    )}</code></pre>`
  ), !0) : !1;
}
function jU({
  event: e,
  editor: t,
  prioritizeMarkdownOverHTML: n,
  plainTextAsMarkdown: r
}) {
  var o;
  if (t.transact(
    (a) => a.selection.$from.parent.type.spec.code && a.selection.$to.parent.type.spec.code
  )) {
    const a = (o = e.clipboardData) == null ? void 0 : o.getData("text/plain");
    if (a)
      return t.pasteText(a), !0;
  }
  let i;
  for (const a of Qp)
    if (e.clipboardData.types.includes(a)) {
      i = a;
      break;
    }
  if (!i)
    return !0;
  if (i === "vscode-editor-data")
    return UU(e, t.prosemirrorView), !0;
  if (i === "Files")
    return ox(e, t), !0;
  const s = e.clipboardData.getData(i);
  if (i === "blocknote/html")
    return t.pasteHTML(s, !0), !0;
  if (i === "text/markdown")
    return t.pasteMarkdown(s), !0;
  if (n) {
    const a = e.clipboardData.getData("text/plain");
    if (FU(a))
      return t.pasteMarkdown(a), !0;
  }
  return i === "text/html" ? (t.pasteHTML(s), !0) : r ? (t.pasteMarkdown(s), !0) : (t.pasteText(s), !0);
}
const VU = (e, t) => ut.create({
  name: "pasteFromClipboard",
  addProseMirrorPlugins() {
    return [
      new me({
        props: {
          handleDOMEvents: {
            paste(n, r) {
              if (r.preventDefault(), !!e.isEditable)
                return t({
                  event: r,
                  editor: e,
                  defaultPasteHandler: ({
                    prioritizeMarkdownOverHTML: o = !0,
                    plainTextAsMarkdown: i = !0
                  } = {}) => jU({
                    event: r,
                    editor: e,
                    prioritizeMarkdownOverHTML: o,
                    plainTextAsMarkdown: i
                  })
                });
            }
          }
        }
      })
    ];
  }
});
function zU(e, t, n) {
  var r;
  let o = !1;
  const i = e.state.selection instanceof qe;
  if (!i) {
    const l = e.state.doc.slice(
      e.state.selection.from,
      e.state.selection.to,
      !1
    ).content, c = [];
    for (let u = 0; u < l.childCount; u++)
      c.push(l.child(u));
    o = c.find(
      (u) => u.type.isInGroup("bnBlock") || u.type.name === "blockGroup" || u.type.spec.group === "blockContent"
    ) === void 0, o && (t = l);
  }
  let s;
  const a = mu(
    e.state.schema,
    n
  );
  if (i) {
    ((r = t.firstChild) == null ? void 0 : r.type.name) === "table" && (t = t.firstChild.content);
    const l = TE(
      t,
      n.schema.inlineContentSchema,
      n.schema.styleSchema
    );
    s = `<table>${a.exportInlineContent(
      l,
      {}
    )}</table>`;
  } else if (o) {
    const l = $c(
      t,
      n.schema.inlineContentSchema,
      n.schema.styleSchema
    );
    s = a.exportInlineContent(l, {});
  } else {
    const l = OT(t);
    s = a.exportBlocks(l, {});
  }
  return s;
}
function ix(e, t) {
  "node" in e.state.selection && e.state.selection.node.type.spec.group === "blockContent" && t.transact(
    (s) => s.setSelection(
      new cn(s.doc.resolve(e.state.selection.from - 1))
    )
  );
  const n = e.serializeForClipboard(
    e.state.selection.content()
  ).dom.innerHTML, r = e.state.selection.content().content, o = zU(
    e,
    r,
    t
  ), i = Wp(o);
  return { clipboardHTML: n, externalHTML: o, markdown: i };
}
const X1 = () => {
  const e = window.getSelection();
  if (!e || e.isCollapsed)
    return !0;
  let t = e.focusNode;
  for (; t; ) {
    if (t instanceof HTMLElement && t.getAttribute("contenteditable") === "false")
      return !0;
    t = t.parentElement;
  }
  return !1;
}, J1 = (e, t, n) => {
  n.preventDefault(), n.clipboardData.clearData();
  const { clipboardHTML: r, externalHTML: o, markdown: i } = ix(
    t,
    e
  );
  n.clipboardData.setData("blocknote/html", r), n.clipboardData.setData("text/html", o), n.clipboardData.setData("text/plain", i);
}, qU = (e) => ut.create({
  name: "copyToClipboard",
  addProseMirrorPlugins() {
    return [
      new me({
        props: {
          handleDOMEvents: {
            copy(t, n) {
              return X1() || J1(e, t, n), !0;
            },
            cut(t, n) {
              return X1() || (J1(e, t, n), t.editable && t.dispatch(t.state.tr.deleteSelection())), !0;
            },
            // This is for the use-case in which only a block without content
            // is selected, e.g. an image block, and dragged (not using the
            // drag handle).
            dragstart(t, n) {
              if (!("node" in t.state.selection) || t.state.selection.node.type.spec.group !== "blockContent")
                return;
              e.transact(
                (s) => s.setSelection(
                  new cn(
                    s.doc.resolve(t.state.selection.from - 1)
                  )
                )
              ), n.preventDefault(), n.dataTransfer.clearData();
              const { clipboardHTML: r, externalHTML: o, markdown: i } = ix(t, e);
              return n.dataTransfer.setData("blocknote/html", r), n.dataTransfer.setData("text/html", o), n.dataTransfer.setData("text/plain", i), !0;
            }
          }
        }
      })
    ];
  }
}), WU = ut.create({
  name: "blockBackgroundColor",
  addGlobalAttributes() {
    return [
      {
        types: ["tableCell", "tableHeader"],
        attributes: {
          backgroundColor: JM()
        }
      }
    ];
  }
}), GU = Jn.create({
  name: "hardBreak",
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  priority: 10,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["br", kn(this.options.HTMLAttributes, e)];
  },
  renderText() {
    return `
`;
  }
}), oh = (e, t) => {
  const n = e.resolve(t), r = n.index();
  if (r === 0)
    return;
  const o = n.posAtIndex(r - 1);
  return Bc(
    e.resolve(o)
  );
}, sx = (e, t) => {
  for (; t.childContainer; ) {
    const n = t.childContainer.node, r = e.resolve(t.childContainer.beforePos + 1).posAtIndex(n.childCount - 1);
    t = Bc(e.resolve(r));
  }
  return t;
}, YU = (e, t) => e.isBlockContainer && e.blockContent.node.type.spec.content === "inline*" && e.blockContent.node.childCount > 0 && t.isBlockContainer && t.blockContent.node.type.spec.content === "inline*", KU = (e, t, n, r) => {
  if (!r.isBlockContainer)
    throw new Error(
      `Attempted to merge block at position ${r.bnBlock.beforePos} into previous block at position ${n.bnBlock.beforePos}, but next block is not a block container`
    );
  if (r.childContainer) {
    const o = e.doc.resolve(
      r.childContainer.beforePos + 1
    ), i = e.doc.resolve(
      r.childContainer.afterPos - 1
    ), s = o.blockRange(i);
    if (t) {
      const a = e.doc.resolve(r.bnBlock.beforePos);
      e.tr.lift(s, a.depth);
    }
  }
  if (t) {
    if (!n.isBlockContainer)
      throw new Error(
        `Attempted to merge block at position ${r.bnBlock.beforePos} into previous block at position ${n.bnBlock.beforePos}, but previous block is not a block container`
      );
    t(
      e.tr.delete(
        n.blockContent.afterPos - 1,
        r.blockContent.beforePos + 1
      )
    );
  }
  return !0;
}, eb = (e) => ({
  state: t,
  dispatch: n
}) => {
  const r = t.doc.resolve(e), o = Bc(r), i = oh(
    t.doc,
    o.bnBlock.beforePos
  );
  if (!i)
    return !1;
  const s = sx(
    t.doc,
    i
  );
  return YU(s, o) ? KU(t, n, s, o) : !1;
}, QU = ut.create({
  priority: 50,
  // TODO: The shortcuts need a refactor. Do we want to use a command priority
  //  design as there is now, or clump the logic into a single function?
  addKeyboardShortcuts() {
    const e = () => this.editor.commands.first(({ chain: r, commands: o }) => [
      // Deletes the selection if it's not empty.
      () => o.deleteSelection(),
      // Undoes an input rule if one was triggered in the last editor state change.
      () => o.undoInputRule(),
      // Reverts block content type to a paragraph if the selection is at the start of the block.
      () => o.command(({ state: i }) => {
        const s = Jt(i);
        if (!s.isBlockContainer)
          return !1;
        const a = i.selection.from === s.blockContent.beforePos + 1, l = s.blockContent.node.type.name === "paragraph";
        return a && !l ? o.command(
          YM(s.bnBlock.beforePos, {
            type: "paragraph",
            props: {}
          })
        ) : !1;
      }),
      // Removes a level of nesting if the block is indented if the selection is at the start of the block.
      () => o.command(({ state: i }) => {
        const s = Jt(i);
        if (!s.isBlockContainer)
          return !1;
        const { blockContent: a } = s;
        return i.selection.from === a.beforePos + 1 ? o.liftListItem("blockContainer") : !1;
      }),
      // Merges block with the previous one if it isn't indented, and the selection is at the start of the
      // block. The target block for merging must contain inline content.
      () => o.command(({ state: i }) => {
        const s = Jt(i);
        if (!s.isBlockContainer)
          return !1;
        const { bnBlock: a, blockContent: l } = s, c = i.selection.from === l.beforePos + 1, u = i.selection.empty, d = a.beforePos;
        return c && u ? r().command(eb(d)).scrollIntoView().run() : !1;
      }),
      () => o.command(({ state: i, tr: s, dispatch: a }) => {
        const l = Jt(i);
        if (!l.isBlockContainer || s.selection.from !== l.blockContent.beforePos + 1)
          return !1;
        const c = s.doc.resolve(l.bnBlock.beforePos);
        if (c.nodeBefore || c.node().type.name !== "column")
          return !1;
        const u = s.doc.resolve(l.bnBlock.beforePos), d = s.doc.resolve(u.before()), f = d.before();
        if (a) {
          const h = s.doc.slice(
            l.bnBlock.beforePos,
            l.bnBlock.afterPos
          ).content;
          s.delete(
            l.bnBlock.beforePos,
            l.bnBlock.afterPos
          ), d.index() === 0 ? (nh(s, f), s.insert(f, h), s.setSelection(
            pe.near(s.doc.resolve(f))
          )) : (s.insert(d.pos - 1, h), s.setSelection(
            pe.near(s.doc.resolve(d.pos - 1))
          ), nh(s, f));
        }
        return !0;
      }),
      // Deletes the current block if it's an empty block with inline content,
      // and moves the selection to the previous block.
      () => o.command(({ state: i }) => {
        const s = Jt(i);
        if (!s.isBlockContainer)
          return !1;
        if (s.blockContent.node.childCount === 0 && s.blockContent.node.type.spec.content === "inline*") {
          const a = oh(
            i.doc,
            s.bnBlock.beforePos
          );
          if (!a || !a.isBlockContainer)
            return !1;
          let l = r();
          if (a.blockContent.node.type.spec.content === "tableRow+") {
            const c = s.bnBlock.beforePos - 1 - 1 - 1 - 1 - 1;
            l = l.setTextSelection(
              c
            );
          } else if (a.blockContent.node.type.spec.content === "") {
            const c = a.blockContent.afterPos - a.blockContent.node.nodeSize;
            l = l.setNodeSelection(
              c
            );
          } else {
            const c = a.blockContent.afterPos - a.blockContent.node.nodeSize;
            l = l.setTextSelection(c);
          }
          return l.deleteRange({
            from: s.bnBlock.beforePos,
            to: s.bnBlock.afterPos
          }).scrollIntoView().run();
        }
        return !1;
      }),
      // Deletes previous block if it contains no content and isn't a table,
      // when the selection is empty and at the start of the block. Moves the
      // current block into the deleted block's place.
      () => o.command(({ state: i }) => {
        const s = Jt(i);
        if (!s.isBlockContainer)
          throw new Error("todo");
        const a = i.selection.from === s.blockContent.beforePos + 1, l = i.selection.empty, c = oh(
          i.doc,
          s.bnBlock.beforePos
        );
        if (c && a && l) {
          const u = sx(
            i.doc,
            c
          );
          if (!u.isBlockContainer)
            throw new Error("todo");
          if (u.blockContent.node.type.spec.content === "" || u.blockContent.node.type.spec.content === "inline*" && u.blockContent.node.childCount === 0)
            return r().cut(
              {
                from: s.bnBlock.beforePos,
                to: s.bnBlock.afterPos
              },
              u.bnBlock.afterPos
            ).deleteRange({
              from: u.bnBlock.beforePos,
              to: u.bnBlock.afterPos
            }).run();
        }
        return !1;
      })
    ]), t = () => this.editor.commands.first(({ commands: r }) => [
      // Deletes the selection if it's not empty.
      () => r.deleteSelection(),
      // Merges block with the next one (at the same nesting level or lower),
      // if one exists, the block has no children, and the selection is at the
      // end of the block.
      () => r.command(({ state: o }) => {
        const i = Jt(o);
        if (!i.isBlockContainer)
          return !1;
        const {
          bnBlock: s,
          blockContent: a,
          childContainer: l
        } = i, { depth: c } = o.doc.resolve(s.beforePos), u = s.afterPos === o.doc.nodeSize - 3, d = o.selection.from === a.afterPos - 1, f = o.selection.empty;
        if (!u && d && f && l === void 0) {
          let h = c, p = s.afterPos + 1, m = o.doc.resolve(p).depth;
          for (; m < h; )
            h = m, p += 2, m = o.doc.resolve(p).depth;
          return r.command(eb(p - 1));
        }
        return !1;
      })
    ]), n = (r = !1) => this.editor.commands.first(({ commands: o, tr: i }) => [
      // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start
      // of the block.
      () => o.command(({ state: s }) => {
        const a = Jt(s);
        if (!a.isBlockContainer)
          return !1;
        const { bnBlock: l, blockContent: c } = a, { depth: u } = s.doc.resolve(l.beforePos), d = s.selection.$anchor.parentOffset === 0, f = s.selection.anchor === s.selection.head, h = c.node.childCount === 0, p = u > 1;
        return d && f && h && p ? o.liftListItem("blockContainer") : !1;
      }),
      // Creates a hard break if block is configured to do so.
      () => o.command(({ state: s }) => {
        var a;
        const l = Jt(s), c = ((a = this.options.editor.schema.blockSchema[l.blockNoteType].meta) == null ? void 0 : a.hardBreakShortcut) ?? "shift+enter";
        if (c === "none")
          return !1;
        if (
          // If shortcut is not configured, or is configured as "shift+enter",
          // create a hard break for shift+enter, but not for enter.
          c === "shift+enter" && r || // If shortcut is configured as "enter", create a hard break for
          // both enter and shift+enter.
          c === "enter"
        ) {
          const u = i.storedMarks || i.selection.$head.marks().filter(
            (d) => this.editor.extensionManager.splittableMarks.includes(
              d.type.name
            )
          );
          return i.insert(
            i.selection.head,
            i.doc.type.schema.nodes.hardBreak.create()
          ).ensureMarks(u), !0;
        }
        return !1;
      }),
      // Creates a new block and moves the selection to it if the current one is empty, while the selection is also
      // empty & at the start of the block.
      () => o.command(({ state: s, dispatch: a }) => {
        const l = Jt(s);
        if (!l.isBlockContainer)
          return !1;
        const { bnBlock: c, blockContent: u } = l, d = s.selection.$anchor.parentOffset === 0, f = s.selection.anchor === s.selection.head, h = u.node.childCount === 0;
        if (d && f && h) {
          const p = c.afterPos, m = p + 2;
          if (a) {
            const b = s.schema.nodes.blockContainer.createAndFill();
            s.tr.insert(p, b).scrollIntoView(), s.tr.setSelection(
              new pe(s.doc.resolve(m))
            );
          }
          return !0;
        }
        return !1;
      }),
      // Splits the current block, moving content inside that's after the cursor to a new text block below. Also
      // deletes the selection beforehand, if it's not empty.
      () => o.command(({ state: s, chain: a }) => {
        const l = Jt(s);
        if (!l.isBlockContainer)
          return !1;
        const { blockContent: c } = l, u = s.selection.$anchor.parentOffset === 0;
        return c.node.childCount === 0 ? !1 : (a().deleteSelection().command(
          A6(
            s.selection.from,
            u,
            u
          )
        ).run(), !0);
      })
    ]);
    return {
      Backspace: e,
      Delete: t,
      Enter: () => n(),
      "Shift-Enter": () => n(!0),
      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the
      // editor since the browser will try to use tab for keyboard navigation.
      Tab: () => {
        var r, o;
        return this.options.tabBehavior !== "prefer-indent" && ((r = this.options.editor.getExtension(ho)) != null && r.store.state || ((o = this.options.editor.getExtension(zn)) == null ? void 0 : o.store.state) !== void 0) ? !1 : tx(this.options.editor);
      },
      "Shift-Tab": () => {
        var r, o;
        return this.options.tabBehavior !== "prefer-indent" && ((r = this.options.editor.getExtension(ho)) != null && r.store.state || ((o = this.options.editor.getExtension(zn)) == null ? void 0 : o.store.state) !== void 0) ? !1 : this.editor.commands.liftListItem("blockContainer");
      },
      "Shift-Mod-ArrowUp": () => (this.options.editor.moveBlocksUp(), !0),
      "Shift-Mod-ArrowDown": () => (this.options.editor.moveBlocksDown(), !0),
      "Mod-z": () => this.options.editor.undo(),
      "Mod-y": () => this.options.editor.redo(),
      "Shift-Mod-z": () => this.options.editor.redo()
    };
  }
}), ZU = Hn.create({
  name: "insertion",
  inclusive: !1,
  excludes: "deletion modification insertion",
  addAttributes() {
    return {
      id: { default: null, validate: "number" }
      // note: validate is supported in prosemirror but not in tiptap, so this doesn't actually work (considered not critical)
    };
  },
  extendMarkSchema(e) {
    return e.name !== "insertion" ? {} : {
      blocknoteIgnore: !0,
      inclusive: !1,
      toDOM(t, n) {
        return [
          "ins",
          {
            "data-id": String(t.attrs.id),
            "data-inline": String(n),
            ...!n && { style: "display: contents" }
            // changed to "contents" to make this work for table rows
          },
          0
        ];
      },
      parseDOM: [
        {
          tag: "ins",
          getAttrs(t) {
            return t.dataset.id ? {
              id: parseInt(t.dataset.id, 10)
            } : !1;
          }
        }
      ]
    };
  }
}), XU = Hn.create({
  name: "deletion",
  inclusive: !1,
  excludes: "insertion modification deletion",
  addAttributes() {
    return {
      id: { default: null, validate: "number" }
      // note: validate is supported in prosemirror but not in tiptap
    };
  },
  extendMarkSchema(e) {
    return e.name !== "deletion" ? {} : {
      blocknoteIgnore: !0,
      inclusive: !1,
      // attrs: {
      //   id: { validate: "number" },
      // },
      toDOM(t, n) {
        return [
          "del",
          {
            "data-id": String(t.attrs.id),
            "data-inline": String(n),
            ...!n && { style: "display: contents" }
            // changed to "contents" to make this work for table rows
          },
          0
        ];
      },
      parseDOM: [
        {
          tag: "del",
          getAttrs(t) {
            return t.dataset.id ? {
              id: parseInt(t.dataset.id, 10)
            } : !1;
          }
        }
      ]
    };
  }
}), JU = Hn.create({
  name: "modification",
  inclusive: !1,
  excludes: "deletion insertion",
  addAttributes() {
    return {
      id: { default: null, validate: "number" },
      type: { validate: "string" },
      attrName: { default: null, validate: "string|null" },
      previousValue: { default: null },
      newValue: { default: null }
    };
  },
  extendMarkSchema(e) {
    return e.name !== "modification" ? {} : {
      blocknoteIgnore: !0,
      inclusive: !1,
      // attrs: {
      //   id: { validate: "number" },
      //   type: { validate: "string" },
      //   attrName: { default: null, validate: "string|null" },
      //   previousValue: { default: null },
      //   newValue: { default: null },
      // },
      toDOM(t, n) {
        return [
          n ? "span" : "div",
          {
            "data-type": "modification",
            "data-id": String(t.attrs.id),
            "data-mod-type": t.attrs.type,
            "data-mod-prev-val": JSON.stringify(t.attrs.previousValue),
            // TODO: Try to serialize marks with toJSON?
            "data-mod-new-val": JSON.stringify(t.attrs.newValue)
          },
          0
        ];
      },
      parseDOM: [
        {
          tag: "span[data-type='modification']",
          getAttrs(t) {
            return t.dataset.id ? {
              id: parseInt(t.dataset.id, 10),
              type: t.dataset.modType,
              previousValue: t.dataset.modPrevVal,
              newValue: t.dataset.modNewVal
            } : !1;
          }
        },
        {
          tag: "div[data-type='modification']",
          getAttrs(t) {
            return t.dataset.id ? {
              id: parseInt(t.dataset.id, 10),
              type: t.dataset.modType,
              previousValue: t.dataset.modPrevVal
            } : !1;
          }
        }
      ]
    };
  }
}), ej = ut.create({
  name: "textAlignment",
  addGlobalAttributes() {
    return [
      {
        // Generally text alignment is handled through props using the custom
        // blocks API. Tables are the only blocks that are created as TipTap
        // nodes and ported to blocks, so we need to add text alignment in a
        // separate extension.
        types: ["tableCell", "tableHeader"],
        attributes: {
          textAlignment: {
            default: "left",
            parseHTML: (e) => e.getAttribute("data-text-alignment"),
            renderHTML: (e) => e.textAlignment === "left" ? {} : {
              "data-text-alignment": e.textAlignment
            }
          }
        }
      }
    ];
  }
}), tj = ut.create({
  name: "blockTextColor",
  addGlobalAttributes() {
    return [
      {
        types: ["table", "tableCell", "tableHeader"],
        attributes: {
          textColor: e6()
        }
      }
    ];
  }
}), nj = {
  blockColor: "data-block-color",
  blockStyle: "data-block-style",
  id: "data-id",
  depth: "data-depth",
  depthChange: "data-depth-change"
}, rj = Jn.create({
  name: "blockContainer",
  group: "blockGroupChild bnBlock",
  // A block always contains content, and optionally a blockGroup which contains nested blocks
  content: "blockContent blockGroup?",
  // Ensures content-specific keyboard handlers trigger first.
  priority: 50,
  defining: !0,
  marks: "insertion modification deletion",
  parseHTML() {
    return [
      {
        tag: "div[data-node-type=" + this.name + "]",
        getAttrs: (e) => {
          if (typeof e == "string")
            return !1;
          const t = {};
          for (const [n, r] of Object.entries(nj))
            e.getAttribute(r) && (t[n] = e.getAttribute(r));
          return t;
        }
      },
      // Ignore `blockOuter` divs, but parse the `blockContainer` divs inside them.
      {
        tag: 'div[data-node-type="blockOuter"]',
        skip: !0
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    var t;
    const n = document.createElement("div");
    n.className = "bn-block-outer", n.setAttribute("data-node-type", "blockOuter");
    for (const [i, s] of Object.entries(e))
      i !== "class" && n.setAttribute(i, s);
    const r = {
      ...((t = this.options.domAttributes) == null ? void 0 : t.block) || {},
      ...e
    }, o = document.createElement("div");
    o.className = dt("bn-block", r.class), o.setAttribute("data-node-type", this.name);
    for (const [i, s] of Object.entries(r))
      i !== "class" && o.setAttribute(i, s);
    return n.appendChild(o), {
      dom: n,
      contentDOM: o
    };
  }
}), oj = Jn.create({
  name: "blockGroup",
  group: "childContainer",
  content: "blockGroupChild+",
  marks: "deletion insertion modification",
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (e) => typeof e == "string" ? !1 : e.getAttribute("data-node-type") === "blockGroup" ? null : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    var t;
    const n = {
      ...((t = this.options.domAttributes) == null ? void 0 : t.blockGroup) || {},
      ...e
    }, r = document.createElement("div");
    r.className = dt(
      "bn-block-group",
      n.class
    ), r.setAttribute("data-node-type", "blockGroup");
    for (const [o, i] of Object.entries(n))
      o !== "class" && r.setAttribute(o, i);
    return {
      dom: r,
      contentDOM: r
    };
  }
}), ij = Jn.create({
  name: "doc",
  topNode: !0,
  content: "blockGroup",
  marks: "insertion modification deletion"
}), sj = He(
  ({ options: e }) => ({
    key: "collaboration",
    blockNoteExtensions: [
      AB(e),
      Kf(e),
      wl(e),
      vl(),
      MB(e)
    ]
  })
);
let tb = !1;
function aj(e, t) {
  const n = [
    ui.ClipboardTextSerializer,
    ui.Commands,
    ui.Editable,
    ui.FocusEvents,
    ui.Tabindex,
    m$,
    Pc.configure({
      // everything from bnBlock group (nodes that represent a BlockNote block should have an id)
      types: ["blockContainer", "columnList", "column"],
      setIdAttribute: t.setIdAttribute
    }),
    GU,
    w$,
    // marks:
    ZU,
    XU,
    JU,
    x$.extend({
      inclusive: !1
    }).configure({
      defaultProtocol: MT,
      // only call this once if we have multiple editors installed. Or fix https://github.com/ueberdosis/tiptap/issues/5450
      protocols: tb ? [] : NT
    }),
    ...Object.values(e.schema.styleSpecs).map((r) => r.implementation.mark.configure({
      editor: e
    })),
    tj,
    WU,
    ej,
    // make sure escape blurs editor, so that we can tab to other elements in the host page (accessibility)
    ut.create({
      name: "OverrideEscape",
      addKeyboardShortcuts: () => ({
        Escape: () => {
          var r;
          return (r = e.getExtension(Rn)) != null && r.shown() ? !1 : (e.blur(), !0);
        }
      })
    }),
    // nodes
    ij,
    rj.configure({
      editor: e,
      domAttributes: t.domAttributes
    }),
    QU.configure({
      editor: e,
      tabBehavior: t.tabBehavior
    }),
    oj.configure({
      domAttributes: t.domAttributes
    }),
    ...Object.values(e.schema.inlineContentSpecs).filter((r) => r.config !== "link" && r.config !== "text").map((r) => r.implementation.node.configure({
      editor: e
    })),
    ...Object.values(e.schema.blockSpecs).flatMap((r) => [
      // the node extension implementations
      ..."node" in r.implementation ? [
        r.implementation.node.configure({
          editor: e,
          domAttributes: t.domAttributes
        })
      ] : []
    ]),
    qU(e),
    VU(
      e,
      t.pasteHandler || ((r) => r.defaultPasteHandler())
    ),
    SU(e)
  ];
  return tb = !0, n;
}
function lj(e, t) {
  const n = [
    AT(),
    LB(t),
    zn(t),
    ho(t),
    Ea(t),
    RB(),
    BB(t),
    lc(t),
    Zn(t),
    Rn(t),
    ...t.trailingBlock !== !1 ? [JB()] : []
  ];
  return t.collaboration ? n.push(sj(t.collaboration)) : n.push(OB()), "table" in e.schema.blockSpecs && n.push(tt(t)), t.animations !== !1 && n.push(HB()), n;
}
class cj {
  constructor(t, n) {
    Pe(this, "disabledExtensions", /* @__PURE__ */ new Set()), Pe(this, "extensions", []), Pe(this, "abortMap", /* @__PURE__ */ new Map()), Pe(this, "extensionFactories", /* @__PURE__ */ new Map()), Pe(this, "extensionPlugins", /* @__PURE__ */ new Map()), this.editor = t, this.options = n, t.onMount(() => {
      for (const r of this.extensions)
        if (r.mount) {
          const o = new window.AbortController(), i = r.mount({
            dom: t.prosemirrorView.dom,
            root: t.prosemirrorView.root,
            signal: o.signal
          });
          i && o.signal.addEventListener("abort", () => {
            i();
          }), this.abortMap.set(r, o);
        }
    }), t.onUnmount(() => {
      for (const [r, o] of this.abortMap.entries())
        this.abortMap.delete(r), o.abort();
    }), this.disabledExtensions = new Set(n.disableExtensions || []);
    for (const r of lj(this.editor, this.options))
      this.addExtension(r);
    for (const r of this.options.extensions ?? [])
      this.addExtension(r);
    for (const r of Object.values(this.editor.schema.blockSpecs))
      for (const o of r.extensions ?? [])
        this.addExtension(o);
  }
  /**
   * Register one or more extensions to the editor after the editor is initialized.
   *
   * This allows users to switch on & off extensions "at runtime".
   */
  registerExtension(t) {
    var n;
    const r = [].concat(t).filter(Boolean);
    if (!r.length) {
      console.warn("No extensions found to register", t);
      return;
    }
    const o = r.map((s) => this.addExtension(s)).filter(Boolean), i = /* @__PURE__ */ new Set();
    for (const s of o)
      s != null && s.tiptapExtensions && console.warn(
        `Extension ${s.key} has tiptap extensions, but these cannot be changed after initializing the editor. Please separate the extension into multiple extensions if you want to add them, or re-initialize the editor.`,
        s
      ), (n = s == null ? void 0 : s.inputRules) != null && n.length && console.warn(
        `Extension ${s.key} has input rules, but these cannot be changed after initializing the editor. Please separate the extension into multiple extensions if you want to add them, or re-initialize the editor.`,
        s
      ), this.getProsemirrorPluginsFromExtension(s).plugins.forEach(
        (a) => {
          i.add(a);
        }
      );
    this.updatePlugins((s) => [...s, ...i]);
  }
  /**
   * Register an extension to the editor
   * @param extension - The extension to register
   * @returns The extension instance
   */
  addExtension(t) {
    let n;
    if (typeof t == "function" ? n = t({ editor: this.editor }) : n = t, !(!n || this.disabledExtensions.has(n.key))) {
      if (typeof t == "function") {
        const r = n[Af];
        typeof r == "function" && this.extensionFactories.set(r, n);
      }
      if (this.extensions.push(n), n.blockNoteExtensions)
        for (const r of n.blockNoteExtensions)
          this.addExtension(r);
      return n;
    }
  }
  /**
   * Resolve an extension or a list of extensions into a list of extension instances
   * @param toResolve - The extension or list of extensions to resolve
   * @returns A list of extension instances
   */
  resolveExtensions(t) {
    const n = [];
    if (typeof t == "function") {
      const r = this.extensionFactories.get(t);
      r && n.push(r);
    } else if (Array.isArray(t))
      for (const r of t)
        n.push(...this.resolveExtensions(r));
    else if (typeof t == "object" && "key" in t)
      n.push(t);
    else if (typeof t == "string") {
      const r = this.extensions.find((o) => o.key === t);
      r && n.push(r);
    }
    return n;
  }
  /**
   * Unregister an extension from the editor
   * @param toUnregister - The extension to unregister
   * @returns void
   */
  unregisterExtension(t) {
    var n;
    const r = this.resolveExtensions(t);
    if (!r.length) {
      console.warn("No extensions found to unregister", t);
      return;
    }
    let o = !1;
    const i = /* @__PURE__ */ new Set();
    for (const s of r) {
      this.extensions = this.extensions.filter((l) => l !== s), this.extensionFactories.forEach((l, c) => {
        l === s && this.extensionFactories.delete(c);
      }), (n = this.abortMap.get(s)) == null || n.abort(), this.abortMap.delete(s);
      const a = this.extensionPlugins.get(s);
      a == null || a.forEach((l) => {
        i.add(l);
      }), this.extensionPlugins.delete(s), s.tiptapExtensions && !o && (o = !0, console.warn(
        `Extension ${s.key} has tiptap extensions, but they will not be removed. Please separate the extension into multiple extensions if you want to remove them, or re-initialize the editor.`,
        t
      ));
    }
    this.updatePlugins(
      (s) => s.filter((a) => !i.has(a))
    );
  }
  /**
   * Allows resetting the current prosemirror state's plugins
   * @param update - A function that takes the current plugins and returns the new plugins
   * @returns void
   */
  updatePlugins(t) {
    const n = this.editor.prosemirrorState, r = n.reconfigure({
      plugins: t(n.plugins.slice())
    });
    this.editor.prosemirrorView.updateState(r);
  }
  /**
   * Get all the extensions that are registered to the editor
   */
  getTiptapExtensions() {
    var t;
    const n = aj(
      this.editor,
      this.options
    ).filter((i) => !this.disabledExtensions.has(i.name)), r = RT(this.extensions), o = /* @__PURE__ */ new Map();
    for (const i of this.extensions) {
      i.tiptapExtensions && n.push(...i.tiptapExtensions);
      const s = r(i.key), { plugins: a, inputRules: l } = this.getProsemirrorPluginsFromExtension(i);
      a.length && n.push(
        ut.create({
          name: i.key,
          priority: s,
          addProseMirrorPlugins: () => a
        })
      ), l.length && (o.has(s) || o.set(s, []), o.get(s).push(...l));
    }
    n.push(
      ut.create({
        name: "blocknote-input-rules",
        addProseMirrorPlugins() {
          const i = [];
          return Array.from(o.keys()).sort().reverse().forEach((s) => {
            i.push(...o.get(s));
          }), [p$({ rules: i })];
        }
      })
    );
    for (const i of ((t = this.options._tiptapOptions) == null ? void 0 : t.extensions) ?? [])
      n.push(i);
    return n;
  }
  /**
   * This maps a blocknote extension into an array of Prosemirror plugins if it has any of the following:
   * - plugins
   * - keyboard shortcuts
   * - input rules
   */
  getProsemirrorPluginsFromExtension(t) {
    var n, r, o;
    const i = [...t.prosemirrorPlugins ?? []], s = [];
    return !((n = t.prosemirrorPlugins) != null && n.length) && !Object.keys(t.keyboardShortcuts || {}).length && !((r = t.inputRules) != null && r.length) ? { plugins: i, inputRules: s } : (this.extensionPlugins.set(t, i), (o = t.inputRules) != null && o.length && s.push(
      ...t.inputRules.map((a) => new ei(a.find, (l, c, u, d) => {
        const f = a.replace({
          match: c,
          range: { from: u, to: d },
          editor: this.editor
        });
        if (f) {
          const h = this.editor.getTextCursorPosition();
          if (this.editor.schema.blockSchema[h.block.type].content !== "inline")
            return null;
          const p = ra(l.tr), m = l.tr.deleteRange(u, d);
          return Xc(m, p.bnBlock.beforePos, f), m;
        }
        return null;
      }))
    ), Object.keys(t.keyboardShortcuts || {}).length && i.push(
      My(
        Object.fromEntries(
          Object.entries(t.keyboardShortcuts).map(([a, l]) => [
            a,
            () => l({ editor: this.editor })
          ])
        )
      )
    ), { plugins: i, inputRules: s });
  }
  /**
   * Get all extensions
   */
  getExtensions() {
    return new Map(
      this.extensions.map((t) => [t.key, t])
    );
  }
  getExtension(t) {
    if (typeof t == "string")
      return this.extensions.find((r) => r.key === t) || void 0;
    if (typeof t == "function")
      return this.extensionFactories.get(t) || void 0;
    throw new Error(`Invalid extension type: ${typeof t}`);
  }
  /**
   * Check if an extension exists
   */
  hasExtension(t) {
    return typeof t == "string" ? this.extensions.some((n) => n.key === t) : typeof t == "object" && "key" in t ? this.extensions.some((n) => n.key === t.key) : typeof t == "function" ? this.extensionFactories.has(t) : !1;
  }
}
function uj(e, t) {
  let { $from: n, $to: r } = t;
  if (n.pos > n.start() && n.pos < e.content.size) {
    const o = e.textBetween(n.pos, n.pos + 1);
    if (/^[\w\p{P}]$/u.test(o)) {
      const i = e.textBetween(n.start(), n.pos).match(/[\w\p{P}]+$/u);
      i && (n = e.resolve(n.pos - i[0].length));
    }
  }
  if (r.pos < r.end() && r.pos > 0) {
    const o = e.textBetween(r.pos - 1, r.pos);
    if (/^[\w\p{P}]$/u.test(o)) {
      const i = e.textBetween(r.pos, r.end()).match(/^[\w\p{P}]+/u);
      i && (r = e.resolve(r.pos + i[0].length));
    }
  }
  return { $from: n, $to: r, from: n.pos, to: r.pos };
}
function dj(e) {
  const t = ht(e);
  if (e.selection.empty || "node" in e.selection)
    return;
  const n = e.doc.resolve(
    so(e.doc, e.selection.from).posBeforeNode
  ), r = e.doc.resolve(
    so(e.doc, e.selection.to).posBeforeNode
  ), o = (c, u) => {
    const d = n.posAtIndex(c, u), f = e.doc.resolve(d).nodeAfter;
    if (!f)
      throw new Error(
        `Error getting selection - node not found at position ${d}`
      );
    return ct(f, t);
  }, i = [], s = n.sharedDepth(r.pos), a = n.index(s), l = r.index(s);
  if (n.depth > s) {
    i.push(ct(n.nodeAfter, t));
    for (let c = n.depth; c > s; c--)
      if (n.node(c).type.isInGroup("childContainer")) {
        const u = n.index(c) + 1, d = n.node(c).childCount;
        for (let f = u; f < d; f++)
          i.push(o(f, c));
      }
  } else
    i.push(o(a, s));
  for (let c = a + 1; c <= l; c++)
    i.push(o(c, s));
  if (i.length === 0)
    throw new Error(
      `Error getting selection - selection doesn't span any blocks (${e.selection})`
    );
  return {
    blocks: i
  };
}
function fj(e, t, n) {
  const r = typeof t == "string" ? t : t.id, o = typeof n == "string" ? n : n.id, i = ht(e), s = oa(i);
  if (r === o)
    throw new Error(
      `Attempting to set selection with the same anchor and head blocks (id ${r})`
    );
  const a = Yt(r, e.doc);
  if (!a)
    throw new Error(`Block with ID ${r} not found`);
  const l = Yt(o, e.doc);
  if (!l)
    throw new Error(`Block with ID ${o} not found`);
  const c = ao(a), u = ao(l), d = s.blockSchema[c.blockNoteType], f = s.blockSchema[u.blockNoteType];
  if (!c.isBlockContainer || d.content === "none")
    throw new Error(
      `Attempting to set selection anchor in block without content (id ${r})`
    );
  if (!u.isBlockContainer || f.content === "none")
    throw new Error(
      `Attempting to set selection anchor in block without content (id ${o})`
    );
  let h, p;
  if (d.content === "table") {
    const m = Je.get(c.blockContent.node);
    h = c.blockContent.beforePos + m.positionAt(0, 0, c.blockContent.node) + 1 + 2;
  } else
    h = c.blockContent.beforePos + 1;
  if (f.content === "table") {
    const m = Je.get(u.blockContent.node), b = u.blockContent.beforePos + m.positionAt(
      m.height - 1,
      m.width - 1,
      u.blockContent.node
    ) + 1, y = e.doc.resolve(b).nodeAfter.nodeSize;
    p = b + y - 2;
  } else
    p = u.blockContent.afterPos - 1;
  e.setSelection(pe.create(e.doc, h, p));
}
function hj(e, t = !1) {
  const n = ht(e), r = t ? uj(e.doc, e.selection) : e.selection;
  let o = r.$from, i = r.$to;
  for (; i.parentOffset >= i.parent.nodeSize - 2 && i.depth > 0; )
    i = e.doc.resolve(i.pos + 1);
  for (; i.parentOffset === 0 && i.depth > 0; )
    i = e.doc.resolve(i.pos - 1);
  for (; o.parentOffset === 0 && o.depth > 0; )
    o = e.doc.resolve(o.pos - 1);
  for (; o.parentOffset >= o.parent.nodeSize - 2 && o.depth > 0; )
    o = e.doc.resolve(o.pos + 1);
  const s = K_(
    e.doc.slice(o.pos, i.pos, !0),
    n
  );
  return {
    _meta: {
      startPos: o.pos,
      endPos: i.pos
    },
    ...s
  };
}
function pj(e) {
  const { bnBlock: t } = ra(e), n = ht(e.doc), r = e.doc.resolve(t.beforePos), o = r.nodeBefore, i = e.doc.resolve(t.afterPos).nodeAfter;
  let s;
  return r.depth > 1 && (s = r.node(), s.type.isInGroup("bnBlock") || (s = r.node(r.depth - 1))), {
    block: ct(t.node, n),
    prevBlock: o === null ? void 0 : ct(o, n),
    nextBlock: i === null ? void 0 : ct(i, n),
    parentBlock: s === void 0 ? void 0 : ct(s, n)
  };
}
function ax(e, t, n = "start") {
  const r = typeof t == "string" ? t : t.id, o = ht(e.doc), i = oa(o), s = Yt(r, e.doc);
  if (!s)
    throw new Error(`Block with ID ${r} not found`);
  const a = ao(s), l = i.blockSchema[a.blockNoteType].content;
  if (a.isBlockContainer) {
    const c = a.blockContent;
    if (l === "none") {
      e.setSelection(cn.create(e.doc, c.beforePos));
      return;
    }
    if (l === "inline")
      n === "start" ? e.setSelection(
        pe.create(e.doc, c.beforePos + 1)
      ) : e.setSelection(
        pe.create(e.doc, c.afterPos - 1)
      );
    else if (l === "table")
      n === "start" ? e.setSelection(
        pe.create(e.doc, c.beforePos + 4)
      ) : e.setSelection(
        pe.create(e.doc, c.afterPos - 4)
      );
    else
      throw new br(l);
  } else {
    const c = n === "start" ? a.childContainer.node.firstChild : a.childContainer.node.lastChild;
    ax(e, c.attrs.id, n);
  }
}
class mj {
  constructor(t) {
    this.editor = t;
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.
   */
  getSelection() {
    return this.editor.transact((t) => dj(t));
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned block will be
   * only the part of the block that is included in the selection.
   */
  getSelectionCutBlocks(t = !1) {
    return this.editor.transact((n) => hj(n, t));
  }
  /**
   * Sets the selection to a range of blocks.
   * @param startBlock The identifier of the block that should be the start of the selection.
   * @param endBlock The identifier of the block that should be the end of the selection.
   */
  setSelection(t, n) {
    return this.editor.transact((r) => fj(r, t, n));
  }
  /**
   * Gets a snapshot of the current text cursor position.
   * @returns A snapshot of the current text cursor position.
   */
  getTextCursorPosition() {
    return this.editor.transact((t) => pj(t));
  }
  /**
   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
   * not be found.
   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
   * @param placement Whether the text cursor should be placed at the start or end of the block.
   */
  setTextCursorPosition(t, n = "start") {
    return this.editor.transact(
      (r) => ax(r, t, n)
    );
  }
  /**
   * Gets the bounding box of the current selection.
   */
  getSelectionBoundingBox() {
    if (!this.editor.prosemirrorView)
      return;
    const { selection: t } = this.editor.prosemirrorState, { ranges: n } = t, r = Math.min(...n.map((i) => i.$from.pos)), o = Math.max(...n.map((i) => i.$to.pos));
    if (GS(t)) {
      const i = this.editor.prosemirrorView.nodeDOM(r);
      if (i)
        return i.getBoundingClientRect();
    }
    return rE(
      this.editor.prosemirrorView,
      r,
      o
    ).toJSON();
  }
}
class gj {
  constructor(t) {
    Pe(this, "activeTransaction", null), Pe(this, "isInCan", !1), this.editor = t;
  }
  /**
   * For any command that can be executed, you can check if it can be executed by calling `editor.can(command)`.
   * @example
   * ```ts
   * if (editor.can(editor.undo)) {
   *   // show button
   * } else {
   *   // hide button
   * }
   */
  can(t) {
    try {
      return this.isInCan = !0, t();
    } finally {
      this.isInCan = !1;
    }
  }
  /**
   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.
   *
   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.
   *
   * @example
   * ```ts
   * editor.exec((state, dispatch, view) => {
   *   dispatch(state.tr.insertText("Hello, world!"));
   * });
   * ```
   */
  exec(t) {
    if (this.activeTransaction)
      throw new Error(
        "`exec` should not be called within a `transact` call, move the `exec` call outside of the `transact` call"
      );
    if (this.isInCan)
      return this.canExec(t);
    const n = this.prosemirrorState, r = this.prosemirrorView;
    return t(n, (o) => this.prosemirrorView.dispatch(o), r);
  }
  /**
   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.
   *
   * @example
   * ```ts
   * if (editor.canExec(command)) {
   *   // show button
   * } else {
   *   // hide button
   * }
   * ```
   */
  canExec(t) {
    if (this.activeTransaction)
      throw new Error(
        "`canExec` should not be called within a `transact` call, move the `canExec` call outside of the `transact` call"
      );
    const n = this.prosemirrorState, r = this.prosemirrorView;
    return t(n, void 0, r);
  }
  /**
   * Execute a function within a "blocknote transaction".
   * All changes to the editor within the transaction will be grouped together, so that
   * we can dispatch them as a single operation (thus creating only a single undo step)
   *
   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.
   *
   * @example
   * ```ts
   * // All changes to the editor will be grouped together
   * editor.transact((tr) => {
   *   tr.insertText("Hello, world!");
   * // These two operations will be grouped together in a single undo step
   *   editor.transact((tr) => {
   *     tr.insertText("Hello, world!");
   *   });
   * });
   * ```
   */
  transact(t) {
    if (this.activeTransaction)
      return t(this.activeTransaction);
    try {
      this.activeTransaction = this.editor._tiptapEditor.state.tr;
      const n = t(this.activeTransaction), r = this.activeTransaction;
      return this.activeTransaction = null, r && // Only dispatch if the transaction was actually modified in some way
      (r.docChanged || r.selectionSet || r.scrolledIntoView || r.storedMarksSet || !r.isGeneric) && this.prosemirrorView.dispatch(r), n;
    } finally {
      this.activeTransaction = null;
    }
  }
  /**
   * Get the underlying prosemirror state
   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date
   * @see https://prosemirror.net/docs/ref/#state.EditorState
   */
  get prosemirrorState() {
    if (this.activeTransaction)
      throw new Error(
        "`prosemirrorState` should not be called within a `transact` call, move the `prosemirrorState` call outside of the `transact` call or use `editor.transact` to read the current editor state"
      );
    return this.editor._tiptapEditor.state;
  }
  /**
   * Get the underlying prosemirror view
   * @see https://prosemirror.net/docs/ref/#view.EditorView
   */
  get prosemirrorView() {
    return this.editor._tiptapEditor.view;
  }
  isFocused() {
    var t;
    return ((t = this.prosemirrorView) == null ? void 0 : t.hasFocus()) || !1;
  }
  focus() {
    var t;
    (t = this.prosemirrorView) == null || t.focus();
  }
  /**
   * Checks if the editor is currently editable, or if it's locked.
   * @returns True if the editor is editable, false otherwise.
   */
  get isEditable() {
    if (!this.editor._tiptapEditor) {
      if (!this.editor.headless)
        throw new Error("no editor, but also not headless?");
      return !1;
    }
    return this.editor._tiptapEditor.isEditable === void 0 ? !0 : this.editor._tiptapEditor.isEditable;
  }
  /**
   * Makes the editor editable or locks it, depending on the argument passed.
   * @param editable True to make the editor editable, or false to lock it.
   */
  set isEditable(t) {
    if (!this.editor._tiptapEditor) {
      if (!this.editor.headless)
        throw new Error("no editor, but also not headless?");
      return;
    }
    this.editor._tiptapEditor.options.editable !== t && this.editor._tiptapEditor.setEditable(t);
  }
  /**
   * Undo the last action.
   */
  undo() {
    const t = this.editor.getExtension("yUndo");
    if (t)
      return this.exec(t.undoCommand);
    const n = this.editor.getExtension("history");
    if (n)
      return this.exec(n.undoCommand);
    throw new Error("No undo plugin found");
  }
  /**
   * Redo the last action.
   */
  redo() {
    const t = this.editor.getExtension("yUndo");
    if (t)
      return this.exec(t.redoCommand);
    const n = this.editor.getExtension("history");
    if (n)
      return this.exec(n.redoCommand);
    throw new Error("No redo plugin found");
  }
}
function bj(e, t, n, r = { updateSelection: !0 }) {
  let { from: o, to: i } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, s = !0, a = !0, l = "";
  if (n.forEach((c) => {
    c.check(), s && c.isText && c.marks.length === 0 ? l += c.text : s = !1, a = a ? c.isBlock : !1;
  }), o === i && a) {
    const { parent: c } = e.doc.resolve(o);
    c.isTextblock && !c.type.spec.code && !c.childCount && (o -= 1, i += 1);
  }
  return s ? e.insertText(l, o, i) : e.replaceWith(o, i, n), r.updateSelection && qy(e, e.steps.length - 1, -1), !0;
}
class yj {
  constructor(t) {
    this.editor = t;
  }
  /**
   * Insert a piece of content at the current cursor position.
   *
   * @param content can be a string, or array of partial inline content elements
   */
  insertInlineContent(t, { updateSelection: n = !1 } = {}) {
    const r = Gn(t, this.editor.pmSchema);
    this.editor.transact((o) => {
      bj(
        o,
        {
          from: o.selection.from,
          to: o.selection.to
        },
        r,
        {
          updateSelection: n
        }
      );
    });
  }
  /**
   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
   */
  getActiveStyles() {
    return this.editor.transact((t) => {
      const n = {}, r = t.selection.$to.marks();
      for (const o of r) {
        const i = this.editor.schema.styleSchema[o.type.name];
        if (!i) {
          o.type.name !== "link" && // "blocknoteIgnore" tagged marks (such as comments) are also not considered BlockNote "styles"
          !o.type.spec.blocknoteIgnore && console.warn("mark not found in styleschema", o.type.name);
          continue;
        }
        i.propSchema === "boolean" ? n[i.type] = !0 : n[i.type] = o.attrs.stringValue;
      }
      return n;
    });
  }
  /**
   * Adds styles to the currently selected content.
   * @param styles The styles to add.
   */
  addStyles(t) {
    for (const [n, r] of Object.entries(t)) {
      const o = this.editor.schema.styleSchema[n];
      if (!o)
        throw new Error(`style ${n} not found in styleSchema`);
      if (o.propSchema === "boolean")
        this.editor._tiptapEditor.commands.setMark(n);
      else if (o.propSchema === "string")
        this.editor._tiptapEditor.commands.setMark(n, {
          stringValue: r
        });
      else
        throw new br(o.propSchema);
    }
  }
  /**
   * Removes styles from the currently selected content.
   * @param styles The styles to remove.
   */
  removeStyles(t) {
    for (const n of Object.keys(t))
      this.editor._tiptapEditor.commands.unsetMark(n);
  }
  /**
   * Toggles styles on the currently selected content.
   * @param styles The styles to toggle.
   */
  toggleStyles(t) {
    for (const [n, r] of Object.entries(t)) {
      const o = this.editor.schema.styleSchema[n];
      if (!o)
        throw new Error(`style ${n} not found in styleSchema`);
      if (o.propSchema === "boolean")
        this.editor._tiptapEditor.commands.toggleMark(n);
      else if (o.propSchema === "string")
        this.editor._tiptapEditor.commands.toggleMark(n, {
          stringValue: r
        });
      else
        throw new br(o.propSchema);
    }
  }
  /**
   * Gets the currently selected text.
   */
  getSelectedText() {
    return this.editor.transact((t) => t.doc.textBetween(t.selection.from, t.selection.to));
  }
  /**
   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
   */
  getSelectedLinkUrl() {
    return this.editor._tiptapEditor.getAttributes("link").href;
  }
  /**
   * Creates a new link to replace the selected content.
   * @param url The link URL.
   * @param text The text to display the link with.
   */
  createLink(t, n) {
    if (t === "")
      return;
    const r = this.editor.pmSchema.mark("link", { href: t });
    this.editor.transact((o) => {
      const { from: i, to: s } = o.selection;
      n ? o.insertText(n, i, s).addMark(i, i + n.length, r) : o.setSelection(pe.create(o.doc, s)).addMark(
        i,
        s,
        r
      );
    });
  }
}
function Ej(e, t) {
  const n = [];
  return e.forEach((r, o, i) => {
    i !== t && n.push(r);
  }), be.from(n);
}
function kj(e, t) {
  const n = [];
  for (let r = 0; r < e.childCount; r++)
    if (e.child(r).type.name === "tableRow")
      if (n.length > 0 && n[n.length - 1].type.name === "table") {
        const o = n[n.length - 1], i = o.copy(o.content.addToEnd(e.child(r)));
        n[n.length - 1] = i;
      } else {
        const o = t.nodes.table.createChecked(
          void 0,
          e.child(r)
        );
        n.push(o);
      }
    else
      n.push(e.child(r));
  return e = be.from(n), e;
}
function Cj(e, t) {
  let n = be.from(e.content);
  if (n = kj(n, t.state.schema), !Tj(n, t))
    return new lt(n, e.openStart, e.openEnd);
  for (let r = 0; r < n.childCount; r++)
    if (n.child(r).type.spec.group === "blockContent") {
      const o = [n.child(r)];
      if (r + 1 < n.childCount && n.child(r + 1).type.name === "blockGroup") {
        const s = n.child(r + 1).child(0).child(0);
        (s.type.name === "bulletListItem" || s.type.name === "numberedListItem" || s.type.name === "checkListItem") && (o.push(n.child(r + 1)), n = Ej(n, r + 1));
      }
      const i = t.state.schema.nodes.blockContainer.createChecked(
        void 0,
        o
      );
      n = n.replaceChild(r, i);
    }
  return new lt(n, e.openStart, e.openEnd);
}
function Tj(e, t) {
  var n, r;
  const o = e.childCount === 1, i = ((n = e.firstChild) == null ? void 0 : n.type.spec.content) === "inline*", s = ((r = e.firstChild) == null ? void 0 : r.type.spec.content) === "tableRow+";
  if (o) {
    if (i)
      return !1;
    if (s) {
      const a = Jt(t.state);
      if (a.isBlockContainer)
        return a.blockContent.node.type.spec.content !== "tableRow+";
    }
  }
  return !0;
}
const xj = {
  enableInputRules: !0,
  enablePasteRules: !0,
  enableCoreExtensions: !1
};
let lx = class cx extends Gp {
  constructor(t) {
    var n, r, o, i, s, a, l, c, u, d;
    super(), Pe(this, "pmSchema"), Pe(this, "_tiptapEditor"), Pe(this, "elementRenderer", null), Pe(this, "blockCache", /* @__PURE__ */ new WeakMap()), Pe(this, "dictionary"), Pe(this, "schema"), Pe(this, "blockImplementations"), Pe(this, "inlineContentImplementations"), Pe(this, "styleImplementations"), Pe(this, "uploadFile"), Pe(this, "onUploadStartCallbacks", []), Pe(this, "onUploadEndCallbacks", []), Pe(this, "resolveFileUrl"), Pe(this, "settings"), Pe(this, "_blockManager"), Pe(this, "_eventManager"), Pe(this, "_exportManager"), Pe(this, "_extensionManager"), Pe(this, "_selectionManager"), Pe(this, "_stateManager"), Pe(this, "_styleManager"), Pe(this, "unregisterExtension", (...k) => this._extensionManager.unregisterExtension(...k)), Pe(this, "registerExtension", (...k) => this._extensionManager.registerExtension(...k)), Pe(this, "getExtension", (...k) => this._extensionManager.getExtension(...k)), Pe(this, "mount", (k) => {
      this._tiptapEditor.mount({ mount: k });
    }), Pe(this, "unmount", () => {
      this._tiptapEditor.unmount();
    }), this.options = t, this.dictionary = t.dictionary || d$, this.settings = {
      tables: {
        splitCells: ((n = t == null ? void 0 : t.tables) == null ? void 0 : n.splitCells) ?? !1,
        cellBackgroundColor: ((r = t == null ? void 0 : t.tables) == null ? void 0 : r.cellBackgroundColor) ?? !1,
        cellTextColor: ((o = t == null ? void 0 : t.tables) == null ? void 0 : o.cellTextColor) ?? !1,
        headers: ((i = t == null ? void 0 : t.tables) == null ? void 0 : i.headers) ?? !1
      }
    };
    const f = {
      defaultStyles: !0,
      schema: t.schema || PT.create(),
      ...t,
      placeholders: {
        ...this.dictionary.placeholders,
        ...t.placeholders
      }
    };
    if (this.schema = f.schema, this.blockImplementations = f.schema.blockSpecs, this.inlineContentImplementations = f.schema.inlineContentSpecs, this.styleImplementations = f.schema.styleSpecs, f.uploadFile) {
      const k = f.uploadFile;
      this.uploadFile = async (C, _) => {
        this.onUploadStartCallbacks.forEach(
          (w) => w.apply(this, [_])
        );
        try {
          return await k(C, _);
        } finally {
          this.onUploadEndCallbacks.forEach(
            (w) => w.apply(this, [_])
          );
        }
      };
    }
    this.resolveFileUrl = f.resolveFileUrl, this._eventManager = new hU(this), this._extensionManager = new cj(this, f);
    const h = this._extensionManager.getTiptapExtensions(), p = this._extensionManager.hasExtension("ySync") || this._extensionManager.hasExtension("liveblocksExtension");
    p && f.initialContent && console.warn(
      "When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider"
    );
    const m = {
      ...xj,
      ...f._tiptapOptions,
      element: null,
      autofocus: f.autofocus ?? !1,
      extensions: h,
      editorProps: {
        ...(s = f._tiptapOptions) == null ? void 0 : s.editorProps,
        attributes: {
          // As of TipTap v2.5.0 the tabIndex is removed when the editor is not
          // editable, so you can't focus it. We want to revert this as we have
          // UI behaviour that relies on it.
          tabIndex: "0",
          ...(l = (a = f._tiptapOptions) == null ? void 0 : a.editorProps) == null ? void 0 : l.attributes,
          ...(c = f.domAttributes) == null ? void 0 : c.editor,
          class: dt(
            "bn-editor",
            f.defaultStyles ? "bn-default-styles" : "",
            ((d = (u = f.domAttributes) == null ? void 0 : u.editor) == null ? void 0 : d.class) || ""
          )
        },
        transformPasted: Cj
      }
    };
    try {
      const k = f.initialContent || (p ? [
        {
          type: "paragraph",
          id: "initialBlockId"
        }
      ] : [
        {
          type: "paragraph",
          id: Pc.options.generateID()
        }
      ]);
      if (!Array.isArray(k) || k.length === 0)
        throw new Error(
          "initialContent must be a non-empty array of blocks, received: " + k
        );
      const C = FS(m.extensions), _ = k.map(
        (T) => Ko(T, C, this.schema.styleSchema).toJSON()
      ), w = Dl(
        {
          type: "doc",
          content: [
            {
              type: "blockGroup",
              content: _
            }
          ]
        },
        C,
        m.parseOptions
      );
      this._tiptapEditor = new M_({
        ...m,
        content: w.toJSON()
      }), this.pmSchema = this._tiptapEditor.schema;
    } catch (k) {
      throw new Error(
        "Error creating document from blocks passed as `initialContent`",
        { cause: k }
      );
    }
    let b;
    const y = this.pmSchema.nodes.doc.createAndFill;
    this.pmSchema.nodes.doc.createAndFill = (...k) => {
      if (b)
        return b;
      const C = y.apply(this.pmSchema.nodes.doc, k), _ = JSON.parse(JSON.stringify(C.toJSON()));
      return _.content[0].content[0].attrs.id = "initialBlockId", b = gh.fromJSON(this.pmSchema, _), b;
    }, this.pmSchema.cached.blockNoteEditor = this, this._blockManager = new fU(this), this._exportManager = new xU(this), this._selectionManager = new mj(this), this._stateManager = new gj(this), this._styleManager = new yj(this), this.emit("create");
  }
  static create(t) {
    return new cx(t ?? {});
  }
  /**
   * BlockNote extensions that are added to the editor, keyed by the extension key
   */
  get extensions() {
    return this._extensionManager.getExtensions();
  }
  /**
   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.
   *
   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.
   *
   * @example
   * ```ts
   * editor.exec((state, dispatch, view) => {
   *   dispatch(state.tr.insertText("Hello, world!"));
   * });
   * ```
   */
  exec(t) {
    return this._stateManager.exec(t);
  }
  /**
   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.
   *
   * @example
   * ```ts
   * if (editor.canExec(command)) {
   *   // show button
   * } else {
   *   // hide button
   * }
   * ```
   */
  canExec(t) {
    return this._stateManager.canExec(t);
  }
  /**
   * Execute a function within a "blocknote transaction".
   * All changes to the editor within the transaction will be grouped together, so that
   * we can dispatch them as a single operation (thus creating only a single undo step)
   *
   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.
   *
   * @example
   * ```ts
   * // All changes to the editor will be grouped together
   * editor.transact((tr) => {
   *   tr.insertText("Hello, world!");
   * // These two operations will be grouped together in a single undo step
   *   editor.transact((tr) => {
   *     tr.insertText("Hello, world!");
   *   });
   * });
   * ```
   */
  transact(t) {
    return this._stateManager.transact(t);
  }
  /**
   * Get the underlying prosemirror state
   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date
   * @see https://prosemirror.net/docs/ref/#state.EditorState
   */
  get prosemirrorState() {
    return this._stateManager.prosemirrorState;
  }
  /**
   * Get the underlying prosemirror view
   * @see https://prosemirror.net/docs/ref/#view.EditorView
   */
  get prosemirrorView() {
    return this._stateManager.prosemirrorView;
  }
  get domElement() {
    var t;
    if (!this.headless)
      return (t = this.prosemirrorView) == null ? void 0 : t.dom;
  }
  isFocused() {
    var t;
    return this.headless ? !1 : ((t = this.prosemirrorView) == null ? void 0 : t.hasFocus()) || !1;
  }
  get headless() {
    return !this._tiptapEditor.isInitialized;
  }
  /**
   * Focus on the editor
   */
  focus() {
    this.headless || this.prosemirrorView.focus();
  }
  /**
   * Blur the editor
   */
  blur() {
    var t;
    this.headless || (t = this.domElement) == null || t.blur();
  }
  // TODO move to extension
  onUploadStart(t) {
    return this.onUploadStartCallbacks.push(t), () => {
      const n = this.onUploadStartCallbacks.indexOf(t);
      n > -1 && this.onUploadStartCallbacks.splice(n, 1);
    };
  }
  onUploadEnd(t) {
    return this.onUploadEndCallbacks.push(t), () => {
      const n = this.onUploadEndCallbacks.indexOf(t);
      n > -1 && this.onUploadEndCallbacks.splice(n, 1);
    };
  }
  /**
   * @deprecated, use `editor.document` instead
   */
  get topLevelBlocks() {
    return this.document;
  }
  /**
   * Gets a snapshot of all top-level (non-nested) blocks in the editor.
   * @returns A snapshot of all top-level (non-nested) blocks in the editor.
   */
  get document() {
    return this._blockManager.document;
  }
  /**
   * Gets a snapshot of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block that should be
   * retrieved.
   * @returns The block that matches the identifier, or `undefined` if no
   * matching block was found.
   */
  getBlock(t) {
    return this._blockManager.getBlock(t);
  }
  /**
   * Gets a snapshot of the previous sibling of an existing block from the
   * editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * previous sibling should be retrieved.
   * @returns The previous sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the first child/block
   * in the document.
   */
  getPrevBlock(t) {
    return this._blockManager.getPrevBlock(t);
  }
  /**
   * Gets a snapshot of the next sibling of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * next sibling should be retrieved.
   * @returns The next sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the last child/block in
   * the document.
   */
  getNextBlock(t) {
    return this._blockManager.getNextBlock(t);
  }
  /**
   * Gets a snapshot of the parent of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * parent should be retrieved.
   * @returns The parent of the block that matches the identifier. `undefined`
   * if no matching block was found, or the block isn't nested.
   */
  getParentBlock(t) {
    return this._blockManager.getParentBlock(t);
  }
  /**
   * Traverses all blocks in the editor depth-first, and executes a callback for each.
   * @param callback The callback to execute for each block. Returning `false` stops the traversal.
   * @param reverse Whether the blocks should be traversed in reverse order.
   */
  forEachBlock(t, n = !1) {
    this._blockManager.forEachBlock(t, n);
  }
  /**
   * Executes a callback whenever the editor's contents change.
   * @param callback The callback to execute.
   *
   * @deprecated use {@link BlockNoteEditor.onChange} instead
   */
  onEditorContentChange(t) {
    this._tiptapEditor.on("update", t);
  }
  /**
   * Executes a callback whenever the editor's selection changes.
   * @param callback The callback to execute.
   *
   * @deprecated use `onSelectionChange` instead
   */
  onEditorSelectionChange(t) {
    this._tiptapEditor.on("selectionUpdate", t);
  }
  /**
   * Executes a callback before any change is applied to the editor, allowing you to cancel the change.
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onBeforeChange(t) {
    return this._extensionManager.getExtension(AT).subscribe(t);
  }
  /**
   * Gets a snapshot of the current text cursor position.
   * @returns A snapshot of the current text cursor position.
   */
  getTextCursorPosition() {
    return this._selectionManager.getTextCursorPosition();
  }
  /**
   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
   * not be found.
   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
   * @param placement Whether the text cursor should be placed at the start or end of the block.
   */
  setTextCursorPosition(t, n = "start") {
    return this._selectionManager.setTextCursorPosition(t, n);
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.
   */
  getSelection() {
    return this._selectionManager.getSelection();
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned block will be
   * only the part of the block that is included in the selection.
   */
  getSelectionCutBlocks(t = !1) {
    return this._selectionManager.getSelectionCutBlocks(t);
  }
  /**
   * Sets the selection to a range of blocks.
   * @param startBlock The identifier of the block that should be the start of the selection.
   * @param endBlock The identifier of the block that should be the end of the selection.
   */
  setSelection(t, n) {
    return this._selectionManager.setSelection(t, n);
  }
  /**
   * Checks if the editor is currently editable, or if it's locked.
   * @returns True if the editor is editable, false otherwise.
   */
  get isEditable() {
    return this._stateManager.isEditable;
  }
  /**
   * Makes the editor editable or locks it, depending on the argument passed.
   * @param editable True to make the editor editable, or false to lock it.
   */
  set isEditable(t) {
    this._stateManager.isEditable = t;
  }
  /**
   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
   * error if the reference block could not be found.
   * @param blocksToInsert An array of partial blocks that should be inserted.
   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
   * `referenceBlock`.
   */
  insertBlocks(t, n, r = "before") {
    return this._blockManager.insertBlocks(
      t,
      n,
      r
    );
  }
  /**
   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
   * not be found.
   * @param blockToUpdate The block that should be updated.
   * @param update A partial block which defines how the existing block should be changed.
   */
  updateBlock(t, n) {
    return this._blockManager.updateBlock(t, n);
  }
  /**
   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
   */
  removeBlocks(t) {
    return this._blockManager.removeBlocks(t);
  }
  /**
   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
   * @param blocksToRemove An array of blocks that should be replaced.
   * @param blocksToInsert An array of partial blocks to replace the old ones with.
   */
  replaceBlocks(t, n) {
    return this._blockManager.replaceBlocks(t, n);
  }
  /**
   * Undo the last action.
   */
  undo() {
    return this._stateManager.undo();
  }
  /**
   * Redo the last action.
   */
  redo() {
    return this._stateManager.redo();
  }
  /**
   * Insert a piece of content at the current cursor position.
   *
   * @param content can be a string, or array of partial inline content elements
   */
  insertInlineContent(t, { updateSelection: n = !1 } = {}) {
    this._styleManager.insertInlineContent(t, { updateSelection: n });
  }
  /**
   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
   */
  getActiveStyles() {
    return this._styleManager.getActiveStyles();
  }
  /**
   * Adds styles to the currently selected content.
   * @param styles The styles to add.
   */
  addStyles(t) {
    this._styleManager.addStyles(t);
  }
  /**
   * Removes styles from the currently selected content.
   * @param styles The styles to remove.
   */
  removeStyles(t) {
    this._styleManager.removeStyles(t);
  }
  /**
   * Toggles styles on the currently selected content.
   * @param styles The styles to toggle.
   */
  toggleStyles(t) {
    this._styleManager.toggleStyles(t);
  }
  /**
   * Gets the currently selected text.
   */
  getSelectedText() {
    return this._styleManager.getSelectedText();
  }
  /**
   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
   */
  getSelectedLinkUrl() {
    return this._styleManager.getSelectedLinkUrl();
  }
  /**
   * Creates a new link to replace the selected content.
   * @param url The link URL.
   * @param text The text to display the link with.
   */
  createLink(t, n) {
    this._styleManager.createLink(t, n);
  }
  /**
   * Checks if the block containing the text cursor can be nested.
   */
  canNestBlock() {
    return this._blockManager.canNestBlock();
  }
  /**
   * Nests the block containing the text cursor into the block above it.
   */
  nestBlock() {
    this._blockManager.nestBlock();
  }
  /**
   * Checks if the block containing the text cursor is nested.
   */
  canUnnestBlock() {
    return this._blockManager.canUnnestBlock();
  }
  /**
   * Lifts the block containing the text cursor out of its parent.
   */
  unnestBlock() {
    this._blockManager.unnestBlock();
  }
  /**
   * Moves the selected blocks up. If the previous block has children, moves
   * them to the end of its children. If there is no previous block, but the
   * current blocks share a common parent, moves them out of & before it.
   */
  moveBlocksUp() {
    return this._blockManager.moveBlocksUp();
  }
  /**
   * Moves the selected blocks down. If the next block has children, moves
   * them to the start of its children. If there is no next block, but the
   * current blocks share a common parent, moves them out of & after it.
   */
  moveBlocksDown() {
    return this._blockManager.moveBlocksDown();
  }
  /**
   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list
   * items are un-nested in the output HTML.
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToHTMLLossy(t = this.document) {
    return this._exportManager.blocksToHTMLLossy(t);
  }
  /**
   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.
   *
   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)
   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToFullHTML(t = this.document) {
    return this._exportManager.blocksToFullHTML(t);
  }
  /**
   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
   * @param html The HTML string to parse blocks from.
   * @returns The blocks parsed from the HTML string.
   */
  tryParseHTMLToBlocks(t) {
    return this._exportManager.tryParseHTMLToBlocks(t);
  }
  /**
   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
   * @param blocks An array of blocks that should be serialized into Markdown.
   * @returns The blocks, serialized as a Markdown string.
   */
  blocksToMarkdownLossy(t = this.document) {
    return this._exportManager.blocksToMarkdownLossy(t);
  }
  /**
   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
   * as text.
   * @param markdown The Markdown string to parse blocks from.
   * @returns The blocks parsed from the Markdown string.
   */
  tryParseMarkdownToBlocks(t) {
    return this._exportManager.tryParseMarkdownToBlocks(t);
  }
  /**
   * A callback function that runs whenever the editor's contents change.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onChange(t, n) {
    return this._eventManager.onChange(t, n);
  }
  /**
   * A callback function that runs whenever the text cursor position or selection changes.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onSelectionChange(t, n) {
    return this._eventManager.onSelectionChange(
      t,
      n
    );
  }
  /**
   * A callback function that runs when the editor has been mounted.
   *
   * This can be useful for plugins to initialize themselves after the editor has been mounted.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onMount(t) {
    this._eventManager.onMount(t);
  }
  /**
   * A callback function that runs when the editor has been unmounted.
   *
   * This can be useful for plugins to clean up themselves after the editor has been unmounted.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onUnmount(t) {
    this._eventManager.onUnmount(t);
  }
  /**
   * Gets the bounding box of the current selection.
   * @returns The bounding box of the current selection.
   */
  getSelectionBoundingBox() {
    return this._selectionManager.getSelectionBoundingBox();
  }
  get isEmpty() {
    const t = this.document;
    return t.length === 0 || t.length === 1 && t[0].type === "paragraph" && t[0].content.length === 0;
  }
  /**
   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.
   * @param html The HTML to paste.
   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.
   */
  pasteHTML(t, n = !1) {
    this._exportManager.pasteHTML(t, n);
  }
  /**
   * Paste text into the editor. Defaults to interpreting text as markdown.
   * @param text The text to paste.
   */
  pasteText(t) {
    return this._exportManager.pasteText(t);
  }
  /**
   * Paste markdown into the editor.
   * @param markdown The markdown to paste.
   */
  pasteMarkdown(t) {
    return this._exportManager.pasteMarkdown(t);
  }
};
var wj = Object.defineProperty, vj = (e, t, n) => t in e ? wj(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, nb = (e, t, n) => vj(e, typeof t != "symbol" ? t + "" : t, n);
const rb = Hn.create({
  name: "comment",
  excludes: "",
  inclusive: !1,
  keepOnSplit: !0,
  addAttributes() {
    return {
      // orphans are marks that currently don't have an active thread. It could be
      // that users have resolved the thread. Resolved threads by default are not shown in the document,
      // but we need to keep the mark (positioning) data so we can still "revive" it when the thread is unresolved
      // or we enter a "comments" view that includes resolved threads.
      orphan: {
        parseHTML: (e) => !!e.getAttribute("data-orphan"),
        renderHTML: (e) => e.orphan ? {
          "data-orphan": "true"
        } : {},
        default: !1
      },
      threadId: {
        parseHTML: (e) => e.getAttribute("data-bn-thread-id"),
        renderHTML: (e) => ({
          "data-bn-thread-id": e.threadId
        }),
        default: ""
      }
    };
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "span",
      kn(e, {
        class: "bn-thread-mark"
      })
    ];
  },
  parseHTML() {
    return [{ tag: "span.bn-thread-mark" }];
  },
  extendMarkSchema(e) {
    return e.name === "comment" ? {
      blocknoteIgnore: !0
    } : {};
  }
});
let Sj = class extends Gp {
  constructor(t) {
    super(), nb(this, "userCache", /* @__PURE__ */ new Map()), nb(this, "loadingUsers", /* @__PURE__ */ new Set()), this.resolveUsers = t;
  }
  /**
   * Load information about users based on an array of user ids.
   */
  async loadUsers(t) {
    const n = t.filter(
      (r) => !this.userCache.has(r) && !this.loadingUsers.has(r)
    );
    if (n.length !== 0) {
      for (const r of n)
        this.loadingUsers.add(r);
      try {
        const r = await this.resolveUsers(n);
        for (const o of r)
          this.userCache.set(o.id, o);
        this.emit("update", this.userCache);
      } finally {
        for (const r of n)
          this.loadingUsers.delete(r);
      }
    }
  }
  /**
   * Retrieve information about a user based on their id, if cached.
   *
   * The user will have to be loaded via `loadUsers` first
   */
  getUser(t) {
    return this.userCache.get(t);
  }
  /**
   * Subscribe to changes in the user store.
   *
   * @param cb - The callback to call when the user store changes.
   * @returns A function to unsubscribe from the user store.
   */
  subscribe(t) {
    return this.on("update", t);
  }
};
const el = new we("blocknote-comments");
function _j(e, t) {
  const n = /* @__PURE__ */ new Map();
  return e.descendants((r, o) => {
    r.marks.forEach((i) => {
      if (i.type.name === t) {
        const s = i.attrs.threadId;
        if (!s)
          return;
        const a = o, l = a + r.nodeSize, c = n.get(s) ?? {
          from: 1 / 0,
          to: 0
        };
        n.set(s, {
          from: Math.min(a, c.from),
          to: Math.max(l, c.to)
        });
      }
    });
  }), n;
}
const $n = He(
  ({
    editor: e,
    options: { schema: t, threadStore: n, resolveUsers: r }
  }) => {
    if (!r)
      throw new Error(
        "resolveUsers is required to be defined when using comments"
      );
    if (!n)
      throw new Error(
        "threadStore is required to be defined when using comments"
      );
    const o = rb.name, i = new Sj(r), s = yo(
      {
        pendingComment: !1,
        selectedThreadId: void 0,
        threadPositions: /* @__PURE__ */ new Map()
      },
      {
        onUpdate() {
          s.state.selectedThreadId !== s.prevState.selectedThreadId && e.transact((l) => l.setMeta(el, !0));
        }
      }
    ), a = (l) => {
      e.transact((c) => {
        c.doc.descendants((u, d) => {
          u.marks.forEach((f) => {
            if (f.type.name === o) {
              const h = f.type, p = f.attrs.threadId, m = l.get(p), b = !!(!m || m.resolved || m.deletedAt);
              if (b !== f.attrs.orphan) {
                const y = Math.max(d, 0), k = Math.min(
                  d + u.nodeSize,
                  c.doc.content.size - 1,
                  c.doc.content.size - 1
                );
                c.removeMark(y, k, f), c.addMark(
                  y,
                  k,
                  h.create({
                    ...f.attrs,
                    orphan: b
                  })
                ), b && s.state.selectedThreadId === p && s.setState((C) => ({
                  ...C,
                  selectedThreadId: void 0
                }));
              }
            }
          });
        });
      });
    };
    return {
      key: "comments",
      store: s,
      prosemirrorPlugins: [
        new me({
          key: el,
          state: {
            init() {
              return {
                decorations: kt.empty
              };
            },
            apply(l, c) {
              const u = l.getMeta(el);
              if (!l.docChanged && !u)
                return c;
              const d = l.docChanged ? _j(l.doc, o) : s.state.threadPositions;
              (d.size > 0 || s.state.threadPositions.size > 0) && s.setState((h) => ({
                ...h,
                threadPositions: d
              }));
              const f = [];
              if (s.state.selectedThreadId) {
                const h = d.get(
                  s.state.selectedThreadId
                );
                h && f.push(
                  Lt.inline(
                    h.from,
                    h.to,
                    {
                      class: "bn-thread-mark-selected"
                    }
                  )
                );
              }
              return {
                decorations: kt.create(l.doc, f)
              };
            }
          },
          props: {
            decorations(l) {
              var c;
              return ((c = el.getState(l)) == null ? void 0 : c.decorations) ?? kt.empty;
            },
            handleClick: (l, c, u) => {
              if (u.button !== 0)
                return;
              const d = l.state.doc.nodeAt(c);
              if (!d) {
                s.setState((p) => ({
                  ...p,
                  selectedThreadId: void 0
                }));
                return;
              }
              const f = d.marks.find(
                (p) => p.type.name === o && p.attrs.orphan !== !0
              ), h = f == null ? void 0 : f.attrs.threadId;
              h !== s.state.selectedThreadId && s.setState((p) => ({
                ...p,
                selectedThreadId: h
              }));
            }
          }
        })
      ],
      threadStore: n,
      mount() {
        const l = n.subscribe(a);
        a(n.getThreads());
        const c = e.onSelectionChange(() => {
          s.state.pendingComment && s.setState((u) => ({
            ...u,
            pendingComment: !1
          }));
        });
        return () => {
          l(), c();
        };
      },
      selectThread(l, c = !0) {
        var u, d;
        if (s.state.selectedThreadId !== l && (s.setState((f) => ({
          ...f,
          pendingComment: !1,
          selectedThreadId: l
        })), l && c)) {
          const f = s.state.threadPositions.get(l);
          if (!f)
            return;
          (d = (u = e.prosemirrorView) == null ? void 0 : u.domAtPos(f.from).node) == null || d.scrollIntoView({
            behavior: "smooth",
            block: "center"
          });
        }
      },
      startPendingComment() {
        var l;
        s.setState((c) => ({
          ...c,
          selectedThreadId: void 0,
          pendingComment: !0
        })), (l = e.getExtension(lc)) == null || l.showSelection(!0, "comments");
      },
      stopPendingComment() {
        var l;
        s.setState((c) => ({
          ...c,
          selectedThreadId: void 0,
          pendingComment: !1
        })), (l = e.getExtension(lc)) == null || l.showSelection(!1, "comments");
      },
      async createThread(l) {
        const c = await n.createThread(l);
        if (n.addThreadToDocument) {
          const u = e.prosemirrorView, d = u.state.selection, f = Xe.getState(u.state), h = {
            prosemirror: {
              head: d.head,
              anchor: d.anchor
            },
            yjs: f ? Zl(f.binding, u.state) : void 0
          };
          await n.addThreadToDocument({
            threadId: c.id,
            selection: h
          });
        } else
          e._tiptapEditor.commands.setMark(o, {
            orphan: !1,
            threadId: c.id
          });
      },
      userStore: i,
      commentEditorSchema: t,
      tiptapExtensions: [rb]
    };
  }
);
let Md;
async function Aj() {
  return Md || (Md = (async () => {
    const [e, t] = await Promise.all([
      import("./module-DS36xGfa.js"),
      // use a dynamic import to encourage bundle-splitting
      // and a smaller initial client bundle size
      import("./native-D8_4pb9S.js")
    ]), n = "default" in e ? e.default : e, r = "default" in t ? t.default : t;
    return await n.init({ data: r }), { emojiMart: n, emojiData: r };
  })(), Md);
}
async function Ij(e, t) {
  if (!("text" in e.schema.inlineContentSchema) || e.schema.inlineContentSchema.text !== dL.text)
    return [];
  const { emojiData: n, emojiMart: r } = await Aj();
  return (t.trim() === "" ? Object.values(n.emojis) : await r.SearchIndex.search(t)).map((o) => ({
    id: o.skins[0].native,
    onItemClick: () => e.insertInlineContent(o.skins[0].native + " ")
  }));
}
function Nj() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function Mj() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: r
    } = t;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function Lj() {
  return /apple/i.test(navigator.vendor);
}
function Oj() {
  return Nj().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function Dj() {
  return Mj().includes("jsdom/");
}
const ob = "data-floating-ui-focusable", Rj = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function ib(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (n = n.shadowRoot) == null ? void 0 : n.activeElement) != null; ) {
    var n;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function Zs(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode == null ? void 0 : t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && Ry(n)) {
    let r = t;
    for (; r; ) {
      if (e === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function fi(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
function Ld(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function Pj(e) {
  return e.matches("html,body");
}
function Lo(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function Bj(e) {
  return kh(e) && e.matches(Rj);
}
function $j(e) {
  if (!e || Dj()) return !0;
  try {
    return e.matches(":focus-visible");
  } catch {
    return !0;
  }
}
function Hj(e) {
  return e ? e.hasAttribute(ob) ? e : e.querySelector("[" + ob + "]") || e : null;
}
function _l(e, t, n) {
  return n === void 0 && (n = !0), e.filter((o) => {
    var i;
    return o.parentId === t && (!n || ((i = o.context) == null ? void 0 : i.open));
  }).flatMap((o) => [o, ..._l(e, o.id, n)]);
}
function Fj(e) {
  return "nativeEvent" in e;
}
function ih(e, t) {
  const n = ["mouse", "pen"];
  return n.push("", void 0), n.includes(e);
}
var Uj = typeof document < "u", jj = function() {
}, Pn = Uj ? Ch : jj;
const Vj = {
  ...K
};
function no(e) {
  const t = K.useRef(e);
  return Pn(() => {
    t.current = e;
  }), t;
}
const zj = Vj.useInsertionEffect, qj = zj || ((e) => e());
function fr(e) {
  const t = K.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return qj(() => {
    t.current = e;
  }), K.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
      r[o] = arguments[o];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
function Wj(e) {
  const t = K.useRef(void 0), n = K.useCallback((r) => {
    const o = e.map((i) => {
      if (i != null) {
        if (typeof i == "function") {
          const s = i, a = s(r);
          return typeof a == "function" ? a : () => {
            s(null);
          };
        }
        return i.current = r, () => {
          i.current = null;
        };
      }
    });
    return () => {
      o.forEach((i) => i == null ? void 0 : i());
    };
  }, e);
  return K.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
const Gj = "data-floating-ui-focusable", sb = "active", ab = "selected", Yj = {
  ...K
};
let lb = !1, Kj = 0;
const cb = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + Kj++
);
function Qj() {
  const [e, t] = K.useState(() => lb ? cb() : void 0);
  return Pn(() => {
    e == null && t(cb());
  }, []), K.useEffect(() => {
    lb = !0;
  }, []), e;
}
const Zj = Yj.useId, ux = Zj || Qj;
let sh;
process.env.NODE_ENV !== "production" && (sh = /* @__PURE__ */ new Set());
function Xj() {
  for (var e, t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  const o = "Floating UI: " + n.join(" ");
  if (!((e = sh) != null && e.has(o))) {
    var i;
    (i = sh) == null || i.add(o), console.error(o);
  }
}
function Jj() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((o) => o(n));
    },
    on(t, n) {
      e.has(t) || e.set(t, /* @__PURE__ */ new Set()), e.get(t).add(n);
    },
    off(t, n) {
      var r;
      (r = e.get(t)) == null || r.delete(n);
    }
  };
}
const eV = /* @__PURE__ */ K.createContext(null), tV = /* @__PURE__ */ K.createContext(null), Zp = () => {
  var e;
  return ((e = K.useContext(eV)) == null ? void 0 : e.id) || null;
}, Xp = () => K.useContext(tV);
function Jp(e) {
  return "data-floating-ui-" + e;
}
function en(e) {
  e.current !== -1 && (clearTimeout(e.current), e.current = -1);
}
const ub = /* @__PURE__ */ Jp("safe-polygon");
function Al(e, t, n) {
  if (n && !ih(n))
    return 0;
  if (typeof e == "number")
    return e;
  if (typeof e == "function") {
    const r = e();
    return typeof r == "number" ? r : r == null ? void 0 : r[t];
  }
  return e == null ? void 0 : e[t];
}
function Od(e) {
  return typeof e == "function" ? e() : e;
}
function dx(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    dataRef: o,
    events: i,
    elements: s
  } = e, {
    enabled: a = !0,
    delay: l = 0,
    handleClose: c = null,
    mouseOnly: u = !1,
    restMs: d = 0,
    move: f = !0
  } = t, h = Xp(), p = Zp(), m = no(c), b = no(l), y = no(n), k = no(d), C = K.useRef(), _ = K.useRef(-1), w = K.useRef(), T = K.useRef(-1), M = K.useRef(!0), D = K.useRef(!1), R = K.useRef(() => {
  }), N = K.useRef(!1), B = fr(() => {
    var Y;
    const V = (Y = o.current.openEvent) == null ? void 0 : Y.type;
    return (V == null ? void 0 : V.includes("mouse")) && V !== "mousedown";
  });
  K.useEffect(() => {
    if (!a) return;
    function Y(V) {
      let {
        open: Q
      } = V;
      Q || (en(_), en(T), M.current = !0, N.current = !1);
    }
    return i.on("openchange", Y), () => {
      i.off("openchange", Y);
    };
  }, [a, i]), K.useEffect(() => {
    if (!a || !m.current || !n) return;
    function Y(Q) {
      B() && r(!1, Q, "hover");
    }
    const V = Lo(s.floating).documentElement;
    return V.addEventListener("mouseleave", Y), () => {
      V.removeEventListener("mouseleave", Y);
    };
  }, [s.floating, n, r, a, m, B]);
  const F = K.useCallback(function(Y, V, Q) {
    V === void 0 && (V = !0), Q === void 0 && (Q = "hover");
    const S = Al(b.current, "close", C.current);
    S && !w.current ? (en(_), _.current = window.setTimeout(() => r(!1, Y, Q), S)) : V && (en(_), r(!1, Y, Q));
  }, [b, r]), W = fr(() => {
    R.current(), w.current = void 0;
  }), L = fr(() => {
    if (D.current) {
      const Y = Lo(s.floating).body;
      Y.style.pointerEvents = "", Y.removeAttribute(ub), D.current = !1;
    }
  }), H = fr(() => o.current.openEvent ? ["click", "mousedown"].includes(o.current.openEvent.type) : !1);
  K.useEffect(() => {
    if (!a) return;
    function Y(ee) {
      if (en(_), M.current = !1, u && !ih(C.current) || Od(k.current) > 0 && !Al(b.current, "open"))
        return;
      const A = Al(b.current, "open", C.current);
      A ? _.current = window.setTimeout(() => {
        y.current || r(!0, ee, "hover");
      }, A) : n || r(!0, ee, "hover");
    }
    function V(ee) {
      if (H()) {
        L();
        return;
      }
      R.current();
      const A = Lo(s.floating);
      if (en(T), N.current = !1, m.current && o.current.floatingContext) {
        n || en(_), w.current = m.current({
          ...o.current.floatingContext,
          tree: h,
          x: ee.clientX,
          y: ee.clientY,
          onClose() {
            L(), W(), H() || F(ee, !0, "safe-polygon");
          }
        });
        const ge = w.current;
        A.addEventListener("mousemove", ge), R.current = () => {
          A.removeEventListener("mousemove", ge);
        };
        return;
      }
      (C.current === "touch" ? !Zs(s.floating, ee.relatedTarget) : !0) && F(ee);
    }
    function Q(ee) {
      H() || o.current.floatingContext && (m.current == null || m.current({
        ...o.current.floatingContext,
        tree: h,
        x: ee.clientX,
        y: ee.clientY,
        onClose() {
          L(), W(), H() || F(ee);
        }
      })(ee));
    }
    function S() {
      en(_);
    }
    function ue(ee) {
      H() || F(ee, !1);
    }
    if (Rt(s.domReference)) {
      const ee = s.domReference, A = s.floating;
      return n && ee.addEventListener("mouseleave", Q), f && ee.addEventListener("mousemove", Y, {
        once: !0
      }), ee.addEventListener("mouseenter", Y), ee.addEventListener("mouseleave", V), A && (A.addEventListener("mouseleave", Q), A.addEventListener("mouseenter", S), A.addEventListener("mouseleave", ue)), () => {
        n && ee.removeEventListener("mouseleave", Q), f && ee.removeEventListener("mousemove", Y), ee.removeEventListener("mouseenter", Y), ee.removeEventListener("mouseleave", V), A && (A.removeEventListener("mouseleave", Q), A.removeEventListener("mouseenter", S), A.removeEventListener("mouseleave", ue));
      };
    }
  }, [s, a, e, u, f, F, W, L, r, n, y, h, b, m, o, H, k]), Pn(() => {
    var Y;
    if (a && n && (Y = m.current) != null && (Y = Y.__options) != null && Y.blockPointerEvents && B()) {
      D.current = !0;
      const Q = s.floating;
      if (Rt(s.domReference) && Q) {
        var V;
        const S = Lo(s.floating).body;
        S.setAttribute(ub, "");
        const ue = s.domReference, ee = h == null || (V = h.nodesRef.current.find((A) => A.id === p)) == null || (V = V.context) == null ? void 0 : V.elements.floating;
        return ee && (ee.style.pointerEvents = ""), S.style.pointerEvents = "none", ue.style.pointerEvents = "auto", Q.style.pointerEvents = "auto", () => {
          S.style.pointerEvents = "", ue.style.pointerEvents = "", Q.style.pointerEvents = "";
        };
      }
    }
  }, [a, n, p, s, h, m, B]), Pn(() => {
    n || (C.current = void 0, N.current = !1, W(), L());
  }, [n, W, L]), K.useEffect(() => () => {
    W(), en(_), en(T), L();
  }, [a, s.domReference, W, L]);
  const J = K.useMemo(() => {
    function Y(V) {
      C.current = V.pointerType;
    }
    return {
      onPointerDown: Y,
      onPointerEnter: Y,
      onMouseMove(V) {
        const {
          nativeEvent: Q
        } = V;
        function S() {
          !M.current && !y.current && r(!0, Q, "hover");
        }
        u && !ih(C.current) || n || Od(k.current) === 0 || N.current && V.movementX ** 2 + V.movementY ** 2 < 2 || (en(T), C.current === "touch" ? S() : (N.current = !0, T.current = window.setTimeout(S, Od(k.current))));
      }
    };
  }, [u, r, n, y, k]);
  return K.useMemo(() => a ? {
    reference: J
  } : {}, [a, J]);
}
const ah = () => {
}, fx = /* @__PURE__ */ K.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: ah,
  setState: ah,
  isInstantPhase: !1
}), nV = () => K.useContext(fx);
function rV(e) {
  const {
    children: t,
    delay: n,
    timeoutMs: r = 0
  } = e, [o, i] = K.useReducer((l, c) => ({
    ...l,
    ...c
  }), {
    delay: n,
    timeoutMs: r,
    initialDelay: n,
    currentId: null,
    isInstantPhase: !1
  }), s = K.useRef(null), a = K.useCallback((l) => {
    i({
      currentId: l
    });
  }, []);
  return Pn(() => {
    o.currentId ? s.current === null ? s.current = o.currentId : o.isInstantPhase || i({
      isInstantPhase: !0
    }) : (o.isInstantPhase && i({
      isInstantPhase: !1
    }), s.current = null);
  }, [o.currentId, o.isInstantPhase]), /* @__PURE__ */ E.jsx(fx.Provider, {
    value: K.useMemo(() => ({
      ...o,
      setState: i,
      setCurrentId: a
    }), [o, a]),
    children: t
  });
}
function oV(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    floatingId: o
  } = e, {
    id: i,
    enabled: s = !0
  } = t, a = i ?? o, l = nV(), {
    currentId: c,
    setCurrentId: u,
    initialDelay: d,
    setState: f,
    timeoutMs: h
  } = l;
  return Pn(() => {
    s && c && (f({
      delay: {
        open: 1,
        close: Al(d, "close")
      }
    }), c !== a && r(!1));
  }, [s, a, r, f, c, d]), Pn(() => {
    function p() {
      r(!1), f({
        delay: d,
        currentId: null
      });
    }
    if (s && c && !n && c === a) {
      if (h) {
        const m = window.setTimeout(p, h);
        return () => {
          clearTimeout(m);
        };
      }
      p();
    }
  }, [s, n, f, c, a, r, d, h]), Pn(() => {
    s && (u === ah || !n || u(a));
  }, [s, n, u, a]), l;
}
function Dd(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode == null ? void 0 : t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && Ry(n)) {
    let r = t;
    for (; r; ) {
      if (e === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function iV(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const sV = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, aV = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, db = (e) => {
  var t, n;
  return {
    escapeKey: typeof e == "boolean" ? e : (t = e == null ? void 0 : e.escapeKey) != null ? t : !1,
    outsidePress: typeof e == "boolean" ? e : (n = e == null ? void 0 : e.outsidePress) != null ? n : !0
  };
};
function hx(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    elements: o,
    dataRef: i
  } = e, {
    enabled: s = !0,
    escapeKey: a = !0,
    outsidePress: l = !0,
    outsidePressEvent: c = "pointerdown",
    referencePress: u = !1,
    referencePressEvent: d = "pointerdown",
    ancestorScroll: f = !1,
    bubbles: h,
    capture: p
  } = t, m = Xp(), b = fr(typeof l == "function" ? l : () => !1), y = typeof l == "function" ? b : l, k = K.useRef(!1), {
    escapeKey: C,
    outsidePress: _
  } = db(h), {
    escapeKey: w,
    outsidePress: T
  } = db(p), M = K.useRef(!1), D = fr((L) => {
    var H;
    if (!n || !s || !a || L.key !== "Escape" || M.current)
      return;
    const J = (H = i.current.floatingContext) == null ? void 0 : H.nodeId, Y = m ? _l(m.nodesRef.current, J) : [];
    if (!C && (L.stopPropagation(), Y.length > 0)) {
      let V = !0;
      if (Y.forEach((Q) => {
        var S;
        if ((S = Q.context) != null && S.open && !Q.context.dataRef.current.__escapeKeyBubbles) {
          V = !1;
          return;
        }
      }), !V)
        return;
    }
    r(!1, Fj(L) ? L.nativeEvent : L, "escape-key");
  }), R = fr((L) => {
    var H;
    const J = () => {
      var Y;
      D(L), (Y = fi(L)) == null || Y.removeEventListener("keydown", J);
    };
    (H = fi(L)) == null || H.addEventListener("keydown", J);
  }), N = fr((L) => {
    var H;
    const J = i.current.insideReactTree;
    i.current.insideReactTree = !1;
    const Y = k.current;
    if (k.current = !1, c === "click" && Y || J || typeof y == "function" && !y(L))
      return;
    const V = fi(L), Q = "[" + Jp("inert") + "]", S = Lo(o.floating).querySelectorAll(Q);
    let ue = Rt(V) ? V : null;
    for (; ue && !Vu(ue); ) {
      const ge = _v(ue);
      if (Vu(ge) || !Rt(ge))
        break;
      ue = ge;
    }
    if (S.length && Rt(V) && !Pj(V) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !Zs(V, o.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(S).every((ge) => !Zs(ue, ge)))
      return;
    if (kh(V) && W) {
      const ge = Vu(V), Ee = Av(V), Qe = /auto|scroll/, Te = ge || Qe.test(Ee.overflowX), ce = ge || Qe.test(Ee.overflowY), nt = Te && V.clientWidth > 0 && V.scrollWidth > V.clientWidth, pt = ce && V.clientHeight > 0 && V.scrollHeight > V.clientHeight, mt = Ee.direction === "rtl", je = pt && (mt ? L.offsetX <= V.offsetWidth - V.clientWidth : L.offsetX > V.clientWidth), Vt = nt && L.offsetY > V.clientHeight;
      if (je || Vt)
        return;
    }
    const ee = (H = i.current.floatingContext) == null ? void 0 : H.nodeId, A = m && _l(m.nodesRef.current, ee).some((ge) => {
      var Ee;
      return Ld(L, (Ee = ge.context) == null ? void 0 : Ee.elements.floating);
    });
    if (Ld(L, o.floating) || Ld(L, o.domReference) || A)
      return;
    const le = m ? _l(m.nodesRef.current, ee) : [];
    if (le.length > 0) {
      let ge = !0;
      if (le.forEach((Ee) => {
        var Qe;
        if ((Qe = Ee.context) != null && Qe.open && !Ee.context.dataRef.current.__outsidePressBubbles) {
          ge = !1;
          return;
        }
      }), !ge)
        return;
    }
    r(!1, L, "outside-press");
  }), B = fr((L) => {
    var H;
    const J = () => {
      var Y;
      N(L), (Y = fi(L)) == null || Y.removeEventListener(c, J);
    };
    (H = fi(L)) == null || H.addEventListener(c, J);
  });
  K.useEffect(() => {
    if (!n || !s)
      return;
    i.current.__escapeKeyBubbles = C, i.current.__outsidePressBubbles = _;
    let L = -1;
    function H(S) {
      r(!1, S, "ancestor-scroll");
    }
    function J() {
      window.clearTimeout(L), M.current = !0;
    }
    function Y() {
      L = window.setTimeout(
        () => {
          M.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        Iv() ? 5 : 0
      );
    }
    const V = Lo(o.floating);
    a && (V.addEventListener("keydown", w ? R : D, w), V.addEventListener("compositionstart", J), V.addEventListener("compositionend", Y)), y && V.addEventListener(c, T ? B : N, T);
    let Q = [];
    return f && (Rt(o.domReference) && (Q = ll(o.domReference)), Rt(o.floating) && (Q = Q.concat(ll(o.floating))), !Rt(o.reference) && o.reference && o.reference.contextElement && (Q = Q.concat(ll(o.reference.contextElement)))), Q = Q.filter((S) => {
      var ue;
      return S !== ((ue = V.defaultView) == null ? void 0 : ue.visualViewport);
    }), Q.forEach((S) => {
      S.addEventListener("scroll", H, {
        passive: !0
      });
    }), () => {
      a && (V.removeEventListener("keydown", w ? R : D, w), V.removeEventListener("compositionstart", J), V.removeEventListener("compositionend", Y)), y && V.removeEventListener(c, T ? B : N, T), Q.forEach((S) => {
        S.removeEventListener("scroll", H);
      }), window.clearTimeout(L);
    };
  }, [i, o, a, y, c, n, r, f, s, C, _, D, w, R, N, T, B]), K.useEffect(() => {
    i.current.insideReactTree = !1;
  }, [i, y, c]);
  const F = K.useMemo(() => ({
    onKeyDown: D,
    ...u && {
      [sV[d]]: (L) => {
        r(!1, L.nativeEvent, "reference-press");
      },
      ...d !== "click" && {
        onClick(L) {
          r(!1, L.nativeEvent, "reference-press");
        }
      }
    }
  }), [D, r, u, d]), W = K.useMemo(() => ({
    onKeyDown: D,
    onMouseDown() {
      k.current = !0;
    },
    onMouseUp() {
      k.current = !0;
    },
    [aV[c]]: () => {
      i.current.insideReactTree = !0;
    }
  }), [D, c, i]);
  return K.useMemo(() => s ? {
    reference: F,
    floating: W
  } : {}, [s, F, W]);
}
function lV(e) {
  const {
    open: t = !1,
    onOpenChange: n,
    elements: r
  } = e, o = ux(), i = K.useRef({}), [s] = K.useState(() => Jj()), a = Zp() != null;
  if (process.env.NODE_ENV !== "production") {
    const h = r.reference;
    h && !Rt(h) && Xj("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [l, c] = K.useState(r.reference), u = fr((h, p, m) => {
    i.current.openEvent = h ? p : void 0, s.emit("openchange", {
      open: h,
      event: p,
      reason: m,
      nested: a
    }), n == null || n(h, p, m);
  }), d = K.useMemo(() => ({
    setPositionReference: c
  }), []), f = K.useMemo(() => ({
    reference: l || r.reference || null,
    floating: r.floating || null,
    domReference: r.reference
  }), [l, r.reference, r.floating]);
  return K.useMemo(() => ({
    dataRef: i,
    open: t,
    onOpenChange: u,
    elements: f,
    events: s,
    floatingId: o,
    refs: d
  }), [t, u, f, s, o, d]);
}
function gu(e) {
  e === void 0 && (e = {});
  const {
    nodeId: t
  } = e, n = lV({
    ...e,
    elements: {
      reference: null,
      floating: null,
      ...e.elements
    }
  }), r = e.rootContext || n, o = r.elements, [i, s] = K.useState(null), [a, l] = K.useState(null), u = (o == null ? void 0 : o.domReference) || i, d = K.useRef(null), f = Xp();
  Pn(() => {
    u && (d.current = u);
  }, [u]);
  const h = vv({
    ...e,
    elements: {
      ...o,
      ...a && {
        reference: a
      }
    }
  }), p = K.useCallback((C) => {
    const _ = Rt(C) ? {
      getBoundingClientRect: () => C.getBoundingClientRect(),
      getClientRects: () => C.getClientRects(),
      contextElement: C
    } : C;
    l(_), h.refs.setReference(_);
  }, [h.refs]), m = K.useCallback((C) => {
    (Rt(C) || C === null) && (d.current = C, s(C)), (Rt(h.refs.reference.current) || h.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    C !== null && !Rt(C)) && h.refs.setReference(C);
  }, [h.refs]), b = K.useMemo(() => ({
    ...h.refs,
    setReference: m,
    setPositionReference: p,
    domReference: d
  }), [h.refs, m, p]), y = K.useMemo(() => ({
    ...h.elements,
    domReference: u
  }), [h.elements, u]), k = K.useMemo(() => ({
    ...h,
    ...r,
    refs: b,
    elements: y,
    nodeId: t
  }), [h, b, y, t, r]);
  return Pn(() => {
    r.dataRef.current.floatingContext = k;
    const C = f == null ? void 0 : f.nodesRef.current.find((_) => _.id === t);
    C && (C.context = k);
  }), K.useMemo(() => ({
    ...h,
    context: k,
    refs: b,
    elements: y
  }), [h, b, y, k]);
}
function Rd() {
  return Oj() && Lj();
}
function cV(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    events: o,
    dataRef: i,
    elements: s
  } = e, {
    enabled: a = !0,
    visibleOnly: l = !0
  } = t, c = K.useRef(!1), u = K.useRef(-1), d = K.useRef(!0);
  K.useEffect(() => {
    if (!a) return;
    const h = Sv(s.domReference);
    function p() {
      !n && kh(s.domReference) && s.domReference === ib(Lo(s.domReference)) && (c.current = !0);
    }
    function m() {
      d.current = !0;
    }
    function b() {
      d.current = !1;
    }
    return h.addEventListener("blur", p), Rd() && (h.addEventListener("keydown", m, !0), h.addEventListener("pointerdown", b, !0)), () => {
      h.removeEventListener("blur", p), Rd() && (h.removeEventListener("keydown", m, !0), h.removeEventListener("pointerdown", b, !0));
    };
  }, [s.domReference, n, a]), K.useEffect(() => {
    if (!a) return;
    function h(p) {
      let {
        reason: m
      } = p;
      (m === "reference-press" || m === "escape-key") && (c.current = !0);
    }
    return o.on("openchange", h), () => {
      o.off("openchange", h);
    };
  }, [o, a]), K.useEffect(() => () => {
    en(u);
  }, []);
  const f = K.useMemo(() => ({
    onMouseLeave() {
      c.current = !1;
    },
    onFocus(h) {
      if (c.current) return;
      const p = fi(h.nativeEvent);
      if (l && Rt(p)) {
        if (Rd() && !h.relatedTarget) {
          if (!d.current && !Bj(p))
            return;
        } else if (!$j(p))
          return;
      }
      r(!0, h.nativeEvent, "focus");
    },
    onBlur(h) {
      c.current = !1;
      const p = h.relatedTarget, m = h.nativeEvent, b = Rt(p) && p.hasAttribute(Jp("focus-guard")) && p.getAttribute("data-type") === "outside";
      u.current = window.setTimeout(() => {
        var y;
        const k = ib(s.domReference ? s.domReference.ownerDocument : document);
        !p && k === s.domReference || Zs((y = i.current.floatingContext) == null ? void 0 : y.refs.floating.current, k) || Zs(s.domReference, k) || b || r(!1, m, "focus");
      });
    }
  }), [i, s.domReference, r, l]);
  return K.useMemo(() => a ? {
    reference: f
  } : {}, [a, f]);
}
function Pd(e, t, n) {
  const r = /* @__PURE__ */ new Map(), o = n === "item";
  let i = e;
  if (o && e) {
    const {
      [sb]: s,
      [ab]: a,
      ...l
    } = e;
    i = l;
  }
  return {
    ...n === "floating" && {
      tabIndex: -1,
      [Gj]: ""
    },
    ...i,
    ...t.map((s) => {
      const a = s ? s[n] : null;
      return typeof a == "function" ? e ? a(e) : null : a;
    }).concat(e).reduce((s, a) => (a && Object.entries(a).forEach((l) => {
      let [c, u] = l;
      if (!(o && [sb, ab].includes(c)))
        if (c.indexOf("on") === 0) {
          if (r.has(c) || r.set(c, []), typeof u == "function") {
            var d;
            (d = r.get(c)) == null || d.push(u), s[c] = function() {
              for (var f, h = arguments.length, p = new Array(h), m = 0; m < h; m++)
                p[m] = arguments[m];
              return (f = r.get(c)) == null ? void 0 : f.map((b) => b(...p)).find((b) => b !== void 0);
            };
          }
        } else
          s[c] = u;
    }), s), {})
  };
}
function px(e) {
  e === void 0 && (e = []);
  const t = e.map((a) => a == null ? void 0 : a.reference), n = e.map((a) => a == null ? void 0 : a.floating), r = e.map((a) => a == null ? void 0 : a.item), o = K.useCallback(
    (a) => Pd(a, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), i = K.useCallback(
    (a) => Pd(a, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    n
  ), s = K.useCallback(
    (a) => Pd(a, e, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    r
  );
  return K.useMemo(() => ({
    getReferenceProps: o,
    getFloatingProps: i,
    getItemProps: s
  }), [o, i, s]);
}
const uV = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function dV(e, t) {
  var n, r;
  t === void 0 && (t = {});
  const {
    open: o,
    elements: i,
    floatingId: s
  } = e, {
    enabled: a = !0,
    role: l = "dialog"
  } = t, c = ux(), u = ((n = i.domReference) == null ? void 0 : n.id) || c, d = K.useMemo(() => {
    var k;
    return ((k = Hj(i.floating)) == null ? void 0 : k.id) || s;
  }, [i.floating, s]), f = (r = uV.get(l)) != null ? r : l, p = Zp() != null, m = K.useMemo(() => f === "tooltip" || l === "label" ? {
    ["aria-" + (l === "label" ? "labelledby" : "describedby")]: o ? d : void 0
  } : {
    "aria-expanded": o ? "true" : "false",
    "aria-haspopup": f === "alertdialog" ? "dialog" : f,
    "aria-controls": o ? d : void 0,
    ...f === "listbox" && {
      role: "combobox"
    },
    ...f === "menu" && {
      id: u
    },
    ...f === "menu" && p && {
      role: "menuitem"
    },
    ...l === "select" && {
      "aria-autocomplete": "none"
    },
    ...l === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [f, d, p, o, u, l]), b = K.useMemo(() => {
    const k = {
      id: d,
      ...f && {
        role: f
      }
    };
    return f === "tooltip" || l === "label" ? k : {
      ...k,
      ...f === "menu" && {
        "aria-labelledby": u
      }
    };
  }, [f, d, u, l]), y = K.useCallback((k) => {
    let {
      active: C,
      selected: _
    } = k;
    const w = {
      role: "option",
      ...C && {
        id: d + "-fui-option"
      }
    };
    switch (l) {
      case "select":
      case "combobox":
        return {
          ...w,
          "aria-selected": _
        };
    }
    return {};
  }, [d, l]);
  return K.useMemo(() => a ? {
    reference: m,
    floating: b,
    item: y
  } : {}, [a, m, b, y]);
}
const fb = (e) => e.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (t, n) => (n ? "-" : "") + t.toLowerCase());
function si(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function fV(e, t) {
  const [n, r] = K.useState(e);
  return e && !n && r(!0), K.useEffect(() => {
    if (!e && n) {
      const o = setTimeout(() => r(!1), t);
      return () => clearTimeout(o);
    }
  }, [e, n, t]), n;
}
function mx(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    elements: {
      floating: r
    }
  } = e, {
    duration: o = 250
  } = t, s = (typeof o == "number" ? o : o.close) || 0, [a, l] = K.useState("unmounted"), c = fV(n, s);
  return !c && a === "close" && l("unmounted"), Pn(() => {
    if (r) {
      if (n) {
        l("initial");
        const u = requestAnimationFrame(() => {
          jv.flushSync(() => {
            l("open");
          });
        });
        return () => {
          cancelAnimationFrame(u);
        };
      }
      l("close");
    }
  }, [n, r]), {
    isMounted: c,
    status: a
  };
}
function hV(e, t) {
  t === void 0 && (t = {});
  const {
    initial: n = {
      opacity: 0
    },
    open: r,
    close: o,
    common: i,
    duration: s = 250
  } = t, a = e.placement, l = a.split("-")[0], c = K.useMemo(() => ({
    side: l,
    placement: a
  }), [l, a]), u = typeof s == "number", d = (u ? s : s.open) || 0, f = (u ? s : s.close) || 0, [h, p] = K.useState(() => ({
    ...si(i, c),
    ...si(n, c)
  })), {
    isMounted: m,
    status: b
  } = mx(e, {
    duration: s
  }), y = no(n), k = no(r), C = no(o), _ = no(i);
  return Pn(() => {
    const w = si(y.current, c), T = si(C.current, c), M = si(_.current, c), D = si(k.current, c) || Object.keys(w).reduce((R, N) => (R[N] = "", R), {});
    if (b === "initial" && p((R) => ({
      transitionProperty: R.transitionProperty,
      ...M,
      ...w
    })), b === "open" && p({
      transitionProperty: Object.keys(D).map(fb).join(","),
      transitionDuration: d + "ms",
      ...M,
      ...D
    }), b === "close") {
      const R = T || w;
      p({
        transitionProperty: Object.keys(R).map(fb).join(","),
        transitionDuration: f + "ms",
        ...M,
        ...R
      });
    }
  }, [f, C, y, k, _, d, b, c]), {
    isMounted: m,
    styles: h
  };
}
function gx(e, t, n) {
  return n === void 0 && (n = !0), e.filter((o) => {
    var i;
    return o.parentId === t && (!n || ((i = o.context) == null ? void 0 : i.open));
  }).flatMap((o) => [o, ...gx(e, o.id, n)]);
}
function hb(e, t) {
  const [n, r] = e;
  let o = !1;
  const i = t.length;
  for (let s = 0, a = i - 1; s < i; a = s++) {
    const [l, c] = t[s] || [0, 0], [u, d] = t[a] || [0, 0];
    c >= r != d >= r && n <= (u - l) * (r - c) / (d - c) + l && (o = !o);
  }
  return o;
}
function pV(e, t) {
  return e[0] >= t.x && e[0] <= t.x + t.width && e[1] >= t.y && e[1] <= t.y + t.height;
}
function mV(e) {
  e === void 0 && (e = {});
  const {
    buffer: t = 0.5,
    blockPointerEvents: n = !1,
    requireIntent: r = !0
  } = e, o = {
    current: -1
  };
  let i = !1, s = null, a = null, l = typeof performance < "u" ? performance.now() : 0;
  function c(d, f) {
    const h = performance.now(), p = h - l;
    if (s === null || a === null || p === 0)
      return s = d, a = f, l = h, null;
    const m = d - s, b = f - a, k = Math.sqrt(m * m + b * b) / p;
    return s = d, a = f, l = h, k;
  }
  const u = (d) => {
    let {
      x: f,
      y: h,
      placement: p,
      elements: m,
      onClose: b,
      nodeId: y,
      tree: k
    } = d;
    return function(_) {
      function w() {
        en(o), b();
      }
      if (en(o), !m.domReference || !m.floating || p == null || f == null || h == null)
        return;
      const {
        clientX: T,
        clientY: M
      } = _, D = [T, M], R = iV(_), N = _.type === "mouseleave", B = Dd(m.floating, R), F = Dd(m.domReference, R), W = m.domReference.getBoundingClientRect(), L = m.floating.getBoundingClientRect(), H = p.split("-")[0], J = f > L.right - L.width / 2, Y = h > L.bottom - L.height / 2, V = pV(D, W), Q = L.width > W.width, S = L.height > W.height, ue = (Q ? W : L).left, ee = (Q ? W : L).right, A = (S ? W : L).top, le = (S ? W : L).bottom;
      if (B && (i = !0, !N))
        return;
      if (F && (i = !1), F && !N) {
        i = !0;
        return;
      }
      if (N && Rt(_.relatedTarget) && Dd(m.floating, _.relatedTarget) || k && gx(k.nodesRef.current, y).length)
        return;
      if (H === "top" && h >= W.bottom - 1 || H === "bottom" && h <= W.top + 1 || H === "left" && f >= W.right - 1 || H === "right" && f <= W.left + 1)
        return w();
      let ge = [];
      switch (H) {
        case "top":
          ge = [[ue, W.top + 1], [ue, L.bottom - 1], [ee, L.bottom - 1], [ee, W.top + 1]];
          break;
        case "bottom":
          ge = [[ue, L.top + 1], [ue, W.bottom - 1], [ee, W.bottom - 1], [ee, L.top + 1]];
          break;
        case "left":
          ge = [[L.right - 1, le], [L.right - 1, A], [W.left + 1, A], [W.left + 1, le]];
          break;
        case "right":
          ge = [[W.right - 1, le], [W.right - 1, A], [L.left + 1, A], [L.left + 1, le]];
          break;
      }
      function Ee(Qe) {
        let [Te, ce] = Qe;
        switch (H) {
          case "top": {
            const nt = [Q ? Te + t / 2 : J ? Te + t * 4 : Te - t * 4, ce + t + 1], pt = [Q ? Te - t / 2 : J ? Te + t * 4 : Te - t * 4, ce + t + 1], mt = [[L.left, J || Q ? L.bottom - t : L.top], [L.right, J ? Q ? L.bottom - t : L.top : L.bottom - t]];
            return [nt, pt, ...mt];
          }
          case "bottom": {
            const nt = [Q ? Te + t / 2 : J ? Te + t * 4 : Te - t * 4, ce - t], pt = [Q ? Te - t / 2 : J ? Te + t * 4 : Te - t * 4, ce - t], mt = [[L.left, J || Q ? L.top + t : L.bottom], [L.right, J ? Q ? L.top + t : L.bottom : L.top + t]];
            return [nt, pt, ...mt];
          }
          case "left": {
            const nt = [Te + t + 1, S ? ce + t / 2 : Y ? ce + t * 4 : ce - t * 4], pt = [Te + t + 1, S ? ce - t / 2 : Y ? ce + t * 4 : ce - t * 4];
            return [...[[Y || S ? L.right - t : L.left, L.top], [Y ? S ? L.right - t : L.left : L.right - t, L.bottom]], nt, pt];
          }
          case "right": {
            const nt = [Te - t, S ? ce + t / 2 : Y ? ce + t * 4 : ce - t * 4], pt = [Te - t, S ? ce - t / 2 : Y ? ce + t * 4 : ce - t * 4], mt = [[Y || S ? L.left + t : L.right, L.top], [Y ? S ? L.left + t : L.right : L.left + t, L.bottom]];
            return [nt, pt, ...mt];
          }
        }
      }
      if (!hb([T, M], ge)) {
        if (i && !V)
          return w();
        if (!N && r) {
          const Qe = c(_.clientX, _.clientY);
          if (Qe !== null && Qe < 0.1)
            return w();
        }
        hb([T, M], Ee([f, h])) ? !i && r && (o.current = window.setTimeout(w, 40)) : w();
      }
    };
  };
  return u.__options = {
    blockPointerEvents: n
  }, u;
}
function gV(e, t = (n) => n) {
  return Nv.useSyncExternalStoreWithSelector(
    e.subscribe,
    () => e.state,
    () => e.state,
    t,
    bV
  );
}
function bV(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, o] of e)
      if (!t.has(r) || !Object.is(o, t.get(r))) return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r)) return !1;
    return !0;
  }
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  const n = pb(e);
  if (n.length !== pb(t).length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (!Object.prototype.hasOwnProperty.call(t, n[r]) || !Object.is(e[n[r]], t[n[r]]))
      return !1;
  return !0;
}
function pb(e) {
  return Object.keys(e).concat(
    Object.getOwnPropertySymbols(e)
  );
}
var yV = Object.defineProperty, em = (e, t) => {
  for (var n in t)
    yV(e, n, { get: t[n], enumerable: !0 });
};
function bx(e) {
  const { state: t, transaction: n } = e;
  let { selection: r } = n, { doc: o } = n, { storedMarks: i } = n;
  return {
    ...t,
    apply: t.apply.bind(t),
    applyTransaction: t.applyTransaction.bind(t),
    plugins: t.plugins,
    schema: t.schema,
    reconfigure: t.reconfigure.bind(t),
    toJSON: t.toJSON.bind(t),
    get storedMarks() {
      return i;
    },
    get selection() {
      return r;
    },
    get doc() {
      return o;
    },
    get tr() {
      return r = n.selection, o = n.doc, i = n.storedMarks, n;
    }
  };
}
var EV = class {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: t, state: n } = this, { view: r } = t, { tr: o } = n, i = this.buildProps(o);
    return Object.fromEntries(
      Object.entries(e).map(([s, a]) => [s, (...c) => {
        const u = a(...c)(i);
        return !o.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(o), u;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, t = !0) {
    const { rawCommands: n, editor: r, state: o } = this, { view: i } = r, s = [], a = !!e, l = e || o.tr, c = () => (!a && t && !l.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(l), s.every((d) => d === !0)), u = {
      ...Object.fromEntries(
        Object.entries(n).map(([d, f]) => [d, (...p) => {
          const m = this.buildProps(l, t), b = f(...p)(m);
          return s.push(b), u;
        }])
      ),
      run: c
    };
    return u;
  }
  createCan(e) {
    const { rawCommands: t, state: n } = this, r = !1, o = e || n.tr, i = this.buildProps(o, r);
    return {
      ...Object.fromEntries(
        Object.entries(t).map(([a, l]) => [a, (...c) => l(...c)({ ...i, dispatch: void 0 })])
      ),
      chain: () => this.createChain(o, r)
    };
  }
  buildProps(e, t = !0) {
    const { rawCommands: n, editor: r, state: o } = this, { view: i } = r, s = {
      tr: e,
      editor: r,
      view: i,
      state: bx({
        state: o,
        transaction: e
      }),
      dispatch: t ? () => {
      } : void 0,
      chain: () => this.createChain(e, t),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(
          Object.entries(n).map(([a, l]) => [a, (...c) => l(...c)(s)])
        );
      }
    };
    return s;
  }
}, yx = {};
em(yx, {
  blur: () => kV,
  clearContent: () => CV,
  clearNodes: () => TV,
  command: () => xV,
  createParagraphNear: () => wV,
  cut: () => vV,
  deleteCurrentNode: () => SV,
  deleteNode: () => _V,
  deleteRange: () => AV,
  deleteSelection: () => IV,
  enter: () => NV,
  exitCode: () => MV,
  extendMarkRange: () => OV,
  first: () => DV,
  focus: () => BV,
  forEach: () => $V,
  insertContent: () => HV,
  insertContentAt: () => jV,
  joinBackward: () => qV,
  joinDown: () => zV,
  joinForward: () => WV,
  joinItemBackward: () => GV,
  joinItemForward: () => YV,
  joinTextblockBackward: () => KV,
  joinTextblockForward: () => QV,
  joinUp: () => VV,
  keyboardShortcut: () => XV,
  lift: () => JV,
  liftEmptyBlock: () => ez,
  liftListItem: () => tz,
  newlineInCode: () => nz,
  resetAttributes: () => rz,
  scrollIntoView: () => oz,
  selectAll: () => iz,
  selectNodeBackward: () => sz,
  selectNodeForward: () => az,
  selectParentNode: () => lz,
  selectTextblockEnd: () => cz,
  selectTextblockStart: () => uz,
  setContent: () => fz,
  setMark: () => Sz,
  setMeta: () => _z,
  setNode: () => Az,
  setNodeSelection: () => Iz,
  setTextDirection: () => Nz,
  setTextSelection: () => Mz,
  sinkListItem: () => Lz,
  splitBlock: () => Oz,
  splitListItem: () => Dz,
  toggleList: () => Rz,
  toggleMark: () => Pz,
  toggleNode: () => Bz,
  toggleWrap: () => $z,
  undoInputRule: () => Hz,
  unsetAllMarks: () => Fz,
  unsetMark: () => Uz,
  unsetTextDirection: () => jz,
  updateAttributes: () => Vz,
  wrapIn: () => zz,
  wrapInList: () => qz
});
var kV = () => ({ editor: e, view: t }) => (requestAnimationFrame(() => {
  var n;
  e.isDestroyed || (t.dom.blur(), (n = window == null ? void 0 : window.getSelection()) == null || n.removeAllRanges());
}), !0), CV = (e = !0) => ({ commands: t }) => t.setContent("", { emitUpdate: e }), TV = () => ({ state: e, tr: t, dispatch: n }) => {
  const { selection: r } = t, { ranges: o } = r;
  return n && o.forEach(({ $from: i, $to: s }) => {
    e.doc.nodesBetween(i.pos, s.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: u } = t, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + a.nodeSize)), h = d.blockRange(f);
      if (!h)
        return;
      const p = cy(h);
      if (a.type.isTextblock) {
        const { defaultType: m } = d.parent.contentMatchAt(d.index());
        t.setNodeMarkup(h.start, m);
      }
      (p || p === 0) && t.lift(h, p);
    });
  }), !0;
}, xV = (e) => (t) => e(t), wV = () => ({ state: e, dispatch: t }) => uy(e, t), vV = (e, t) => ({ editor: n, tr: r }) => {
  const { state: o } = n, i = o.doc.slice(e.from, e.to);
  r.deleteRange(e.from, e.to);
  const s = r.mapping.map(t);
  return r.insert(s, i.content), r.setSelection(new pe(r.doc.resolve(Math.max(s - 1, 0)))), !0;
}, SV = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const o = e.selection.$anchor;
  for (let i = o.depth; i > 0; i -= 1)
    if (o.node(i).type === r.type) {
      if (t) {
        const a = o.before(i), l = o.after(i);
        e.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
};
function Ht(e, t) {
  if (typeof e == "string") {
    if (!t.nodes[e])
      throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);
    return t.nodes[e];
  }
  return e;
}
var _V = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const o = Ht(e, n.schema), i = t.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === o) {
      if (r) {
        const l = i.before(s), c = i.after(s);
        t.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, AV = (e) => ({ tr: t, dispatch: n }) => {
  const { from: r, to: o } = e;
  return n && t.delete(r, o), !0;
}, IV = () => ({ state: e, dispatch: t }) => dy(e, t), NV = () => ({ commands: e }) => e.keyboardShortcut("Enter"), MV = () => ({ state: e, dispatch: t }) => fy(e, t);
function LV(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function cc(e, t, n = { strict: !0 }) {
  const r = Object.keys(t);
  return r.length ? r.every((o) => n.strict ? t[o] === e[o] : LV(t[o]) ? t[o].test(e[o]) : t[o] === e[o]) : !0;
}
function Ex(e, t, n = {}) {
  return e.find((r) => r.type === t && cc(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((o) => [o, r.attrs[o]])),
    n
  ));
}
function mb(e, t, n = {}) {
  return !!Ex(e, t, n);
}
function kx(e, t, n) {
  var r;
  if (!e || !t)
    return;
  let o = e.parent.childAfter(e.parentOffset);
  if ((!o.node || !o.node.marks.some((u) => u.type === t)) && (o = e.parent.childBefore(e.parentOffset)), !o.node || !o.node.marks.some((u) => u.type === t) || (n = n || ((r = o.node.marks[0]) == null ? void 0 : r.attrs), !Ex([...o.node.marks], t, n)))
    return;
  let s = o.index, a = e.start() + o.offset, l = s + 1, c = a + o.node.nodeSize;
  for (; s > 0 && mb([...e.parent.child(s - 1).marks], t, n); )
    s -= 1, a -= e.parent.child(s).nodeSize;
  for (; l < e.parent.childCount && mb([...e.parent.child(l).marks], t, n); )
    c += e.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: c
  };
}
function ko(e, t) {
  if (typeof e == "string") {
    if (!t.marks[e])
      throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);
    return t.marks[e];
  }
  return e;
}
var OV = (e, t = {}) => ({ tr: n, state: r, dispatch: o }) => {
  const i = ko(e, r.schema), { doc: s, selection: a } = n, { $from: l, from: c, to: u } = a;
  if (o) {
    const d = kx(l, i, t);
    if (d && d.from <= c && d.to >= u) {
      const f = pe.create(s, d.from, d.to);
      n.setSelection(f);
    }
  }
  return !0;
}, DV = (e) => (t) => {
  const n = typeof e == "function" ? e(t) : e;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](t))
      return !0;
  return !1;
};
function Cx(e) {
  return e instanceof pe;
}
function Rr(e = 0, t = 0, n = 0) {
  return Math.min(Math.max(e, t), n);
}
function RV(e, t = null) {
  if (!t)
    return null;
  const n = ot.atStart(e), r = ot.atEnd(e);
  if (t === "start" || t === !0)
    return n;
  if (t === "end")
    return r;
  const o = n.from, i = r.to;
  return t === "all" ? pe.create(e, Rr(0, o, i), Rr(e.content.size, o, i)) : pe.create(e, Rr(t, o, i), Rr(t, o, i));
}
function gb() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function uc() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function PV() {
  return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
}
var BV = (e = null, t = {}) => ({ editor: n, view: r, tr: o, dispatch: i }) => {
  t = {
    scrollIntoView: !0,
    ...t
  };
  const s = () => {
    (uc() || gb()) && r.dom.focus(), PV() && !uc() && !gb() && r.dom.focus({ preventScroll: !0 }), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), t != null && t.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  try {
    if (r.hasFocus() && e === null || e === !1)
      return !0;
  } catch {
    return !1;
  }
  if (i && e === null && !Cx(n.state.selection))
    return s(), !0;
  const a = RV(o.doc, e) || n.state.selection, l = n.state.selection.eq(a);
  return i && (l || o.setSelection(a), l && o.storedMarks && o.setStoredMarks(o.storedMarks), s()), !0;
}, $V = (e, t) => (n) => e.every((r, o) => t(r, { ...n, index: o })), HV = (e, t) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, e, t), Tx = (e) => {
  const t = e.childNodes;
  for (let n = t.length - 1; n >= 0; n -= 1) {
    const r = t[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? e.removeChild(r) : r.nodeType === 1 && Tx(r);
  }
  return e;
};
function tl(e) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const t = `<body>${e}</body>`, n = new window.DOMParser().parseFromString(t, "text/html").body;
  return Tx(n);
}
function Xs(e, t, n) {
  if (e instanceof gh || e instanceof be)
    return e;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof e == "object" && e !== null, o = typeof e == "string";
  if (r)
    try {
      if (Array.isArray(e) && e.length > 0)
        return be.fromArray(e.map((a) => t.nodeFromJSON(a)));
      const s = t.nodeFromJSON(e);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (i) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", i), Xs("", t, n);
    }
  if (o) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const l = new bh({
        topNode: t.spec.topNode,
        marks: t.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: t.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (s = !0, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Mn.fromSchema(l).parseSlice(tl(e), n.parseOptions) : Mn.fromSchema(l).parse(tl(e), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`)
        });
    }
    const i = Mn.fromSchema(t);
    return n.slice ? i.parseSlice(tl(e), n.parseOptions).content : i.parse(tl(e), n.parseOptions);
  }
  return Xs("", t, n);
}
function FV(e, t, n) {
  const r = e.steps.length - 1;
  if (r < t)
    return;
  const o = e.steps[r];
  if (!(o instanceof Sc || o instanceof As))
    return;
  const i = e.mapping.maps[r];
  let s = 0;
  i.forEach((a, l, c, u) => {
    s === 0 && (s = u);
  }), e.setSelection(ot.near(e.doc.resolve(s), n));
}
var UV = (e) => !("type" in e), jV = (e, t, n) => ({ tr: r, dispatch: o, editor: i }) => {
  var s;
  if (o) {
    n = {
      parseOptions: i.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    const l = (b) => {
      i.emit("contentError", {
        editor: i,
        error: b,
        disableCollaboration: () => {
          "collaboration" in i.storage && typeof i.storage.collaboration == "object" && i.storage.collaboration && (i.storage.collaboration.isDisabled = !0);
        }
      });
    }, c = {
      preserveWhitespace: "full",
      ...n.parseOptions
    };
    if (!n.errorOnInvalidContent && !i.options.enableContentCheck && i.options.emitContentError)
      try {
        Xs(t, i.schema, {
          parseOptions: c,
          errorOnInvalidContent: !0
        });
      } catch (b) {
        l(b);
      }
    try {
      a = Xs(t, i.schema, {
        parseOptions: c,
        errorOnInvalidContent: (s = n.errorOnInvalidContent) != null ? s : i.options.enableContentCheck
      });
    } catch (b) {
      return l(b), !1;
    }
    let { from: u, to: d } = typeof e == "number" ? { from: e, to: e } : { from: e.from, to: e.to }, f = !0, h = !0;
    if ((UV(a) ? a : [a]).forEach((b) => {
      b.check(), f = f ? b.isText && b.marks.length === 0 : !1, h = h ? b.isBlock : !1;
    }), u === d && h) {
      const { parent: b } = r.doc.resolve(u);
      b.isTextblock && !b.type.spec.code && !b.childCount && (u -= 1, d += 1);
    }
    let m;
    if (f) {
      if (Array.isArray(t))
        m = t.map((b) => b.text || "").join("");
      else if (t instanceof be) {
        let b = "";
        t.forEach((y) => {
          y.text && (b += y.text);
        }), m = b;
      } else typeof t == "object" && t && t.text ? m = t.text : m = t;
      r.insertText(m, u, d);
    } else {
      m = a;
      const b = r.doc.resolve(u), y = b.node(), k = b.parentOffset === 0, C = y.isText || y.isTextblock, _ = y.content.size > 0;
      k && C && _ && (u = Math.max(0, u - 1)), r.replaceWith(u, d, m);
    }
    n.updateSelection && FV(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: u, text: m }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: u, text: m });
  }
  return !0;
}, VV = () => ({ state: e, dispatch: t }) => hy(e, t), zV = () => ({ state: e, dispatch: t }) => py(e, t), qV = () => ({ state: e, dispatch: t }) => my(e, t), WV = () => ({ state: e, dispatch: t }) => gy(e, t), GV = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = vc(e.doc, e.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, YV = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = vc(e.doc, e.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, KV = () => ({ state: e, dispatch: t }) => by(e, t), QV = () => ({ state: e, dispatch: t }) => yy(e, t);
function xx() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function ZV(e) {
  const t = e.split(/-(?!$)/);
  let n = t[t.length - 1];
  n === "Space" && (n = " ");
  let r, o, i, s;
  for (let a = 0; a < t.length - 1; a += 1) {
    const l = t[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      o = !0;
    else if (/^s(hift)?$/i.test(l))
      i = !0;
    else if (/^mod$/i.test(l))
      uc() || xx() ? s = !0 : o = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (n = `Alt-${n}`), o && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), i && (n = `Shift-${n}`), n;
}
var XV = (e) => ({ editor: t, view: n, tr: r, dispatch: o }) => {
  const i = ZV(e).split(/-(?!$)/), s = i.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: i.includes("Alt"),
    ctrlKey: i.includes("Ctrl"),
    metaKey: i.includes("Meta"),
    shiftKey: i.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = t.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, a));
  });
  return l == null || l.steps.forEach((c) => {
    const u = c.map(r.mapping);
    u && o && r.maybeStep(u);
  }), !0;
};
function tm(e, t, n = {}) {
  const { from: r, to: o, empty: i } = e.selection, s = t ? Ht(t, e.schema) : null, a = [];
  e.doc.nodesBetween(r, o, (d, f) => {
    if (d.isText)
      return;
    const h = Math.max(r, f), p = Math.min(o, f + d.nodeSize);
    a.push({
      node: d,
      from: h,
      to: p
    });
  });
  const l = o - r, c = a.filter((d) => s ? s.name === d.node.type.name : !0).filter((d) => cc(d.node.attrs, n, { strict: !1 }));
  return i ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
var JV = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const o = Ht(e, n.schema);
  return tm(n, o, t) ? Ey(n, r) : !1;
}, ez = () => ({ state: e, dispatch: t }) => ky(e, t), tz = (e) => ({ state: t, dispatch: n }) => {
  const r = Ht(e, t.schema);
  return Cy(r)(t, n);
}, nz = () => ({ state: e, dispatch: t }) => Ty(e, t);
function wx(e, t) {
  return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null;
}
function bb(e, t) {
  const n = typeof t == "string" ? [t] : t;
  return Object.keys(e).reduce((r, o) => (n.includes(o) || (r[o] = e[o]), r), {});
}
var rz = (e, t) => ({ tr: n, state: r, dispatch: o }) => {
  let i = null, s = null;
  const a = wx(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (i = Ht(e, r.schema)), a === "mark" && (s = ko(e, r.schema));
  let l = !1;
  return n.selection.ranges.forEach((c) => {
    r.doc.nodesBetween(c.$from.pos, c.$to.pos, (u, d) => {
      i && i === u.type && (l = !0, o && n.setNodeMarkup(d, void 0, bb(u.attrs, t))), s && u.marks.length && u.marks.forEach((f) => {
        s === f.type && (l = !0, o && n.addMark(d, d + u.nodeSize, s.create(bb(f.attrs, t))));
      });
    });
  }), l;
}, oz = () => ({ tr: e, dispatch: t }) => (t && e.scrollIntoView(), !0), iz = () => ({ tr: e, dispatch: t }) => {
  if (t) {
    const n = new yh(e.doc);
    e.setSelection(n);
  }
  return !0;
}, sz = () => ({ state: e, dispatch: t }) => xy(e, t), az = () => ({ state: e, dispatch: t }) => wy(e, t), lz = () => ({ state: e, dispatch: t }) => vy(e, t), cz = () => ({ state: e, dispatch: t }) => Sy(e, t), uz = () => ({ state: e, dispatch: t }) => _y(e, t);
function dz(e, t, n = {}, r = {}) {
  return Xs(e, t, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
var fz = (e, { errorOnInvalidContent: t, emitUpdate: n = !0, parseOptions: r = {} } = {}) => ({ editor: o, tr: i, dispatch: s, commands: a }) => {
  const { doc: l } = i;
  if (r.preserveWhitespace !== "full") {
    const c = dz(e, o.schema, r, {
      errorOnInvalidContent: t ?? o.options.enableContentCheck
    });
    return s && i.replaceWith(0, l.content.size, c).setMeta("preventUpdate", !n), !0;
  }
  return s && i.setMeta("preventUpdate", !n), a.insertContentAt({ from: 0, to: l.content.size }, e, {
    parseOptions: r,
    errorOnInvalidContent: t ?? o.options.enableContentCheck
  });
};
function hz(e, t) {
  const n = ko(t, e.schema), { from: r, to: o, empty: i } = e.selection, s = [];
  i ? (e.storedMarks && s.push(...e.storedMarks), s.push(...e.selection.$head.marks())) : e.doc.nodesBetween(r, o, (l) => {
    s.push(...l.marks);
  });
  const a = s.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function pz(e, t) {
  const n = new Eh(e);
  return t.forEach((r) => {
    r.steps.forEach((o) => {
      n.step(o);
    });
  }), n;
}
function mz(e) {
  for (let t = 0; t < e.edgeCount; t += 1) {
    const { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function gz(e, t) {
  for (let n = e.depth; n > 0; n -= 1) {
    const r = e.node(n);
    if (t(r))
      return {
        pos: n > 0 ? e.before(n) : 0,
        start: e.start(n),
        depth: n,
        node: r
      };
  }
}
function nm(e) {
  return (t) => gz(t.$from, e);
}
function Js(e, t, n) {
  return e.config[t] === void 0 && e.parent ? Js(e.parent, t, n) : typeof e.config[t] == "function" ? e.config[t].bind({
    ...n,
    parent: e.parent ? Js(e.parent, t, n) : null
  }) : e.config[t];
}
function bz(e) {
  return typeof e == "function";
}
function lh(e, t = void 0, ...n) {
  return bz(e) ? t ? e.bind(t)(...n) : e(...n) : e;
}
function vx(e) {
  const t = e.filter((o) => o.type === "extension"), n = e.filter((o) => o.type === "node"), r = e.filter((o) => o.type === "mark");
  return {
    baseExtensions: t,
    nodeExtensions: n,
    markExtensions: r
  };
}
function yz(e, t, n) {
  const { from: r, to: o } = t, { blockSeparator: i = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return e.nodesBetween(r, o, (l, c, u, d) => {
    var f;
    l.isBlock && c > r && (a += i);
    const h = s == null ? void 0 : s[l.type.name];
    if (h)
      return u && (a += h({
        node: l,
        pos: c,
        parent: u,
        index: d,
        range: t
      })), !1;
    l.isText && (a += (f = l == null ? void 0 : l.text) == null ? void 0 : f.slice(Math.max(r, c) - c, o - c));
  }), a;
}
function Ez(e) {
  return Object.fromEntries(
    Object.entries(e.nodes).filter(([, t]) => t.spec.toText).map(([t, n]) => [t, n.spec.toText])
  );
}
function kz(e, t = JSON.stringify) {
  const n = {};
  return e.filter((r) => {
    const o = t(r);
    return Object.prototype.hasOwnProperty.call(n, o) ? !1 : n[o] = !0;
  });
}
function Cz(e) {
  const t = kz(e);
  return t.length === 1 ? t : t.filter((n, r) => !t.filter((i, s) => s !== r).some((i) => n.oldRange.from >= i.oldRange.from && n.oldRange.to <= i.oldRange.to && n.newRange.from >= i.newRange.from && n.newRange.to <= i.newRange.to));
}
function Tz(e) {
  const { mapping: t, steps: n } = e, r = [];
  return t.maps.forEach((o, i) => {
    const s = [];
    if (o.ranges.length)
      o.forEach((a, l) => {
        s.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[i];
      if (a === void 0 || l === void 0)
        return;
      s.push({ from: a, to: l });
    }
    s.forEach(({ from: a, to: l }) => {
      const c = t.slice(i).map(a, -1), u = t.slice(i).map(l), d = t.invert().map(c, -1), f = t.invert().map(u);
      r.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), Cz(r);
}
function Il(e, t, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const o = e.find((i) => i.type === t && i.name === r);
      return o ? o.attribute.keepOnSplit : !1;
    })
  );
}
function xz(e, t, n = {}) {
  const { empty: r, ranges: o } = e.selection, i = t ? ko(t, e.schema) : null;
  if (r)
    return !!(e.storedMarks || e.selection.$from.marks()).filter((d) => i ? i.name === d.type.name : !0).find((d) => cc(d.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (o.forEach(({ $from: d, $to: f }) => {
    const h = d.pos, p = f.pos;
    e.doc.nodesBetween(h, p, (m, b) => {
      if (!m.isText && !m.marks.length)
        return;
      const y = Math.max(h, b), k = Math.min(p, b + m.nodeSize), C = k - y;
      s += C, a.push(
        ...m.marks.map((_) => ({
          mark: _,
          from: y,
          to: k
        }))
      );
    });
  }), s === 0)
    return !1;
  const l = a.filter((d) => i ? i.name === d.mark.type.name : !0).filter((d) => cc(d.mark.attrs, n, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = a.filter((d) => i ? d.mark.type !== i && d.mark.type.excludes(i) : !0).reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= s;
}
function yb(e, t) {
  const { nodeExtensions: n } = vx(t), r = n.find((s) => s.name === e);
  if (!r)
    return !1;
  const o = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, i = lh(Js(r, "group", o));
  return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function Sx(e, {
  checkChildren: t = !0,
  ignoreWhitespace: n = !1
} = {}) {
  var r;
  if (n) {
    if (e.type.name === "hardBreak")
      return !0;
    if (e.isText)
      return /^\s*$/m.test((r = e.text) != null ? r : "");
  }
  if (e.isText)
    return !e.text;
  if (e.isAtom || e.isLeaf)
    return !1;
  if (e.content.childCount === 0)
    return !0;
  if (t) {
    let o = !0;
    return e.content.forEach((i) => {
      o !== !1 && (Sx(i, { ignoreWhitespace: n, checkChildren: t }) || (o = !1));
    }), o;
  }
  return !1;
}
function wz(e, t, n) {
  const o = e.state.doc.content.size, i = Rr(t, 0, o), s = Rr(n, 0, o), a = e.coordsAtPos(i), l = e.coordsAtPos(s, -1), c = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), f = Math.max(a.right, l.right), h = f - d, p = u - c, y = {
    top: c,
    bottom: u,
    left: d,
    right: f,
    width: h,
    height: p,
    x: d,
    y: c
  };
  return {
    ...y,
    toJSON: () => y
  };
}
function vz(e, t, n) {
  var r;
  const { selection: o } = t;
  let i = null;
  if (Cx(o) && (i = o.$cursor), i) {
    const a = (r = e.storedMarks) != null ? r : i.marks();
    return i.parent.type.allowsMarkType(n) && (!!n.isInSet(a) || !a.some((c) => c.type.excludes(n)));
  }
  const { ranges: s } = o;
  return s.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? e.doc.inlineContent && e.doc.type.allowsMarkType(n) : !1;
    return e.doc.nodesBetween(a.pos, l.pos, (u, d, f) => {
      if (c)
        return !1;
      if (u.isInline) {
        const h = !f || f.type.allowsMarkType(n), p = !!n.isInSet(u.marks) || !u.marks.some((m) => m.type.excludes(n));
        c = h && p;
      }
      return !c;
    }), c;
  });
}
var Sz = (e, t = {}) => ({ tr: n, state: r, dispatch: o }) => {
  const { selection: i } = n, { empty: s, ranges: a } = i, l = ko(e, r.schema);
  if (o)
    if (s) {
      const c = hz(r, l);
      n.addStoredMark(
        l.create({
          ...c,
          ...t
        })
      );
    } else
      a.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        r.doc.nodesBetween(u, d, (f, h) => {
          const p = Math.max(h, u), m = Math.min(h + f.nodeSize, d);
          f.marks.find((y) => y.type === l) ? f.marks.forEach((y) => {
            l === y.type && n.addMark(
              p,
              m,
              l.create({
                ...y.attrs,
                ...t
              })
            );
          }) : n.addMark(p, m, l.create(t));
        });
      });
  return vz(r, n, l);
}, _z = (e, t) => ({ tr: n }) => (n.setMeta(e, t), !0), Az = (e, t = {}) => ({ state: n, dispatch: r, chain: o }) => {
  const i = Ht(e, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), i.isTextblock ? o().command(({ commands: a }) => Nl(i, { ...s, ...t })(n) ? !0 : a.clearNodes()).command(({ state: a }) => Nl(i, { ...s, ...t })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, Iz = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, o = Rr(e, 0, r.content.size), i = cn.create(r, o);
    t.setSelection(i);
  }
  return !0;
}, Nz = (e, t) => ({ tr: n, state: r, dispatch: o }) => {
  const { selection: i } = r;
  let s, a;
  return typeof t == "number" ? (s = t, a = t) : t && "from" in t && "to" in t ? (s = t.from, a = t.to) : (s = i.from, a = i.to), o && n.doc.nodesBetween(s, a, (l, c) => {
    l.isText || n.setNodeMarkup(c, void 0, {
      ...l.attrs,
      dir: e
    });
  }), !0;
}, Mz = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, { from: o, to: i } = typeof e == "number" ? { from: e, to: e } : e, s = pe.atStart(r).from, a = pe.atEnd(r).to, l = Rr(o, s, a), c = Rr(i, s, a), u = pe.create(r, l, c);
    t.setSelection(u);
  }
  return !0;
}, Lz = (e) => ({ state: t, dispatch: n }) => {
  const r = Ht(e, t.schema);
  return Ay(r)(t, n);
};
function Eb(e, t) {
  const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
  if (n) {
    const r = n.filter((o) => t == null ? void 0 : t.includes(o.type.name));
    e.tr.ensureMarks(r);
  }
}
var Oz = ({ keepMarks: e = !0 } = {}) => ({ tr: t, state: n, dispatch: r, editor: o }) => {
  const { selection: i, doc: s } = t, { $from: a, $to: l } = i, c = o.extensionManager.attributes, u = Il(c, a.node().type.name, a.node().attrs);
  if (i instanceof cn && i.node.isBlock)
    return !a.parentOffset || !ro(s, a.pos) ? !1 : (r && (e && Eb(n, o.extensionManager.splittableMarks), t.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : mz(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let h = d && f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0, p = ro(t.doc, t.mapping.map(a.pos), 1, h);
  if (!h && !p && ro(t.doc, t.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (p = !0, h = f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0), r) {
    if (p && (i instanceof pe && t.deleteSelection(), t.split(t.mapping.map(a.pos), 1, h), f && !d && !a.parentOffset && a.parent.type !== f)) {
      const m = t.mapping.map(a.before()), b = t.doc.resolve(m);
      a.node(-1).canReplaceWith(b.index(), b.index() + 1, f) && t.setNodeMarkup(t.mapping.map(a.before()), f);
    }
    e && Eb(n, o.extensionManager.splittableMarks), t.scrollIntoView();
  }
  return p;
}, Dz = (e, t = {}) => ({ tr: n, state: r, dispatch: o, editor: i }) => {
  var s;
  const a = Ht(e, r.schema), { $from: l, $to: c } = r.selection, u = r.selection.node;
  if (u && u.isBlock || l.depth < 2 || !l.sameParent(c))
    return !1;
  const d = l.node(-1);
  if (d.type !== a)
    return !1;
  const f = i.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (o) {
      let y = be.empty;
      const k = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let D = l.depth - k; D >= l.depth - 3; D -= 1)
        y = be.from(l.node(D).copy(y));
      const C = (
        // eslint-disable-next-line no-nested-ternary
        l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3
      ), _ = {
        ...Il(f, l.node().type.name, l.node().attrs),
        ...t
      }, w = ((s = a.contentMatch.defaultType) == null ? void 0 : s.createAndFill(_)) || void 0;
      y = y.append(be.from(a.createAndFill(null, w) || void 0));
      const T = l.before(l.depth - (k - 1));
      n.replace(T, l.after(-C), new lt(y, 4 - k, 0));
      let M = -1;
      n.doc.nodesBetween(T, n.doc.content.size, (D, R) => {
        if (M > -1)
          return !1;
        D.isTextblock && D.content.size === 0 && (M = R + 1);
      }), M > -1 && n.setSelection(pe.near(n.doc.resolve(M))), n.scrollIntoView();
    }
    return !0;
  }
  const h = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, p = {
    ...Il(f, d.type.name, d.attrs),
    ...t
  }, m = {
    ...Il(f, l.node().type.name, l.node().attrs),
    ...t
  };
  n.delete(l.pos, c.pos);
  const b = h ? [
    { type: a, attrs: p },
    { type: h, attrs: m }
  ] : [{ type: a, attrs: p }];
  if (!ro(n.doc, l.pos, 2))
    return !1;
  if (o) {
    const { selection: y, storedMarks: k } = r, { splittableMarks: C } = i.extensionManager, _ = k || y.$to.parentOffset && y.$from.marks();
    if (n.split(l.pos, 2, b).scrollIntoView(), !_ || !o)
      return !0;
    const w = _.filter((T) => C.includes(T.type.name));
    n.ensureMarks(w);
  }
  return !0;
}, Bd = (e, t) => {
  const n = nm((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const o = e.doc.nodeAt(r);
  return n.node.type === (o == null ? void 0 : o.type) && _c(e.doc, n.pos) && e.join(n.pos), !0;
}, $d = (e, t) => {
  const n = nm((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const o = e.doc.nodeAt(r);
  return n.node.type === (o == null ? void 0 : o.type) && _c(e.doc, r) && e.join(r), !0;
}, Rz = (e, t, n, r = {}) => ({ editor: o, tr: i, state: s, dispatch: a, chain: l, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: f } = o.extensionManager, h = Ht(e, s.schema), p = Ht(t, s.schema), { selection: m, storedMarks: b } = s, { $from: y, $to: k } = m, C = y.blockRange(k), _ = b || m.$to.parentOffset && m.$from.marks();
  if (!C)
    return !1;
  const w = nm((T) => yb(T.type.name, d))(m);
  if (C.depth >= 1 && w && C.depth - w.depth <= 1) {
    if (w.node.type === h)
      return c.liftListItem(p);
    if (yb(w.node.type.name, d) && h.validContent(w.node.content) && a)
      return l().command(() => (i.setNodeMarkup(w.pos, h), !0)).command(() => Bd(i, h)).command(() => $d(i, h)).run();
  }
  return !n || !_ || !a ? l().command(() => u().wrapInList(h, r) ? !0 : c.clearNodes()).wrapInList(h, r).command(() => Bd(i, h)).command(() => $d(i, h)).run() : l().command(() => {
    const T = u().wrapInList(h, r), M = _.filter((D) => f.includes(D.type.name));
    return i.ensureMarks(M), T ? !0 : c.clearNodes();
  }).wrapInList(h, r).command(() => Bd(i, h)).command(() => $d(i, h)).run();
}, Pz = (e, t = {}, n = {}) => ({ state: r, commands: o }) => {
  const { extendEmptyMarkRange: i = !1 } = n, s = ko(e, r.schema);
  return xz(r, s, t) ? o.unsetMark(s, { extendEmptyMarkRange: i }) : o.setMark(s, t);
}, Bz = (e, t, n = {}) => ({ state: r, commands: o }) => {
  const i = Ht(e, r.schema), s = Ht(t, r.schema), a = tm(r, i, n);
  let l;
  return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), a ? o.setNode(s, l) : o.setNode(i, { ...l, ...n });
}, $z = (e, t = {}) => ({ state: n, commands: r }) => {
  const o = Ht(e, n.schema);
  return tm(n, o, t) ? r.lift(o) : r.wrapIn(o, t);
}, Hz = () => ({ state: e, dispatch: t }) => {
  const n = e.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const o = n[r];
    let i;
    if (o.spec.isInputRules && (i = o.getState(e))) {
      if (t) {
        const s = e.tr, a = i.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          s.step(a.steps[l].invert(a.docs[l]));
        if (i.text) {
          const l = s.doc.resolve(i.from).marks();
          s.replaceWith(i.from, i.to, e.schema.text(i.text, l));
        } else
          s.delete(i.from, i.to);
      }
      return !0;
    }
  }
  return !1;
}, Fz = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, { empty: r, ranges: o } = n;
  return r || t && o.forEach((i) => {
    e.removeMark(i.$from.pos, i.$to.pos);
  }), !0;
}, Uz = (e, t = {}) => ({ tr: n, state: r, dispatch: o }) => {
  var i;
  const { extendEmptyMarkRange: s = !1 } = t, { selection: a } = n, l = ko(e, r.schema), { $from: c, empty: u, ranges: d } = a;
  if (!o)
    return !0;
  if (u && s) {
    let { from: f, to: h } = a;
    const p = (i = c.marks().find((b) => b.type === l)) == null ? void 0 : i.attrs, m = kx(c, l, p);
    m && (f = m.from, h = m.to), n.removeMark(f, h, l);
  } else
    d.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, jz = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const { selection: o } = n;
  let i, s;
  return typeof e == "number" ? (i = e, s = e) : e && "from" in e && "to" in e ? (i = e.from, s = e.to) : (i = o.from, s = o.to), r && t.doc.nodesBetween(i, s, (a, l) => {
    if (a.isText)
      return;
    const c = { ...a.attrs };
    delete c.dir, t.setNodeMarkup(l, void 0, c);
  }), !0;
}, Vz = (e, t = {}) => ({ tr: n, state: r, dispatch: o }) => {
  let i = null, s = null;
  const a = wx(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (i = Ht(e, r.schema)), a === "mark" && (s = ko(e, r.schema));
  let l = !1;
  return n.selection.ranges.forEach((c) => {
    const u = c.$from.pos, d = c.$to.pos;
    let f, h, p, m;
    n.selection.empty ? r.doc.nodesBetween(u, d, (b, y) => {
      i && i === b.type && (l = !0, p = Math.max(y, u), m = Math.min(y + b.nodeSize, d), f = y, h = b);
    }) : r.doc.nodesBetween(u, d, (b, y) => {
      y < u && i && i === b.type && (l = !0, p = Math.max(y, u), m = Math.min(y + b.nodeSize, d), f = y, h = b), y >= u && y <= d && (i && i === b.type && (l = !0, o && n.setNodeMarkup(y, void 0, {
        ...b.attrs,
        ...t
      })), s && b.marks.length && b.marks.forEach((k) => {
        if (s === k.type && (l = !0, o)) {
          const C = Math.max(y, u), _ = Math.min(y + b.nodeSize, d);
          n.addMark(
            C,
            _,
            s.create({
              ...k.attrs,
              ...t
            })
          );
        }
      }));
    }), h && (f !== void 0 && o && n.setNodeMarkup(f, void 0, {
      ...h.attrs,
      ...t
    }), s && h.marks.length && h.marks.forEach((b) => {
      s === b.type && o && n.addMark(
        p,
        m,
        s.create({
          ...b.attrs,
          ...t
        })
      );
    }));
  }), l;
}, zz = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const o = Ht(e, n.schema);
  return Iy(o, t)(n, r);
}, qz = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const o = Ht(e, n.schema);
  return Ny(o, t)(n, r);
};
function Wz(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function nl(e) {
  return Wz(e) !== "Object" ? !1 : e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype;
}
function _x(e, t) {
  const n = { ...e };
  return nl(e) && nl(t) && Object.keys(t).forEach((r) => {
    nl(t[r]) && nl(e[r]) ? n[r] = _x(e[r], t[r]) : n[r] = t[r];
  }), n;
}
var Gz = class {
  constructor(e = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...lh(
        Js(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...lh(
        Js(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => _x(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new this.constructor({ ...this.config, ...e });
    return t.parent = this, this.child = t, t.name = "name" in e ? e.name : t.parent.name, t;
  }
}, Yz = {};
em(Yz, {
  ClipboardTextSerializer: () => Kz,
  Commands: () => Qz,
  Delete: () => Zz,
  Drop: () => Xz,
  Editable: () => Jz,
  FocusEvents: () => eq,
  Keymap: () => tq,
  Paste: () => nq,
  Tabindex: () => rq,
  TextDirection: () => oq,
  focusEventsPluginKey: () => Ix
});
var wr = class Ax extends Gz {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new Ax(n);
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
}, Kz = wr.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: e } = this, { state: t, schema: n } = e, { doc: r, selection: o } = t, { ranges: i } = o, s = Math.min(...i.map((u) => u.$from.pos)), a = Math.max(...i.map((u) => u.$to.pos)), l = Ez(n);
            return yz(r, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), Qz = wr.create({
  name: "commands",
  addCommands() {
    return {
      ...yx
    };
  }
}), Zz = wr.create({
  name: "delete",
  onUpdate({ transaction: e, appendedTransactions: t }) {
    var n, r, o;
    const i = () => {
      var s, a, l, c;
      if ((c = (l = (a = (s = this.editor.options.coreExtensionOptions) == null ? void 0 : s.delete) == null ? void 0 : a.filterTransaction) == null ? void 0 : l.call(a, e)) != null ? c : e.getMeta("y-sync$"))
        return;
      const u = pz(e.before, [e, ...t]);
      Tz(u).forEach((h) => {
        u.mapping.mapResult(h.oldRange.from).deletedAfter && u.mapping.mapResult(h.oldRange.to).deletedBefore && u.before.nodesBetween(h.oldRange.from, h.oldRange.to, (p, m) => {
          const b = m + p.nodeSize - 2, y = h.oldRange.from <= m && b <= h.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: p,
            from: m,
            to: b,
            newFrom: u.mapping.map(m),
            newTo: u.mapping.map(b),
            deletedRange: h.oldRange,
            newRange: h.newRange,
            partial: !y,
            editor: this.editor,
            transaction: e,
            combinedTransform: u
          });
        });
      });
      const f = u.mapping;
      u.steps.forEach((h, p) => {
        var m, b;
        if (h instanceof Ly) {
          const y = f.slice(p).map(h.from, -1), k = f.slice(p).map(h.to), C = f.invert().map(y, -1), _ = f.invert().map(k), w = (m = u.doc.nodeAt(y - 1)) == null ? void 0 : m.marks.some((M) => M.eq(h.mark)), T = (b = u.doc.nodeAt(k)) == null ? void 0 : b.marks.some((M) => M.eq(h.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: h.mark,
            from: h.from,
            to: h.to,
            deletedRange: {
              from: C,
              to: _
            },
            newRange: {
              from: y,
              to: k
            },
            partial: !!(T || w),
            editor: this.editor,
            transaction: e,
            combinedTransform: u
          });
        }
      });
    };
    (o = (r = (n = this.editor.options.coreExtensionOptions) == null ? void 0 : n.delete) == null ? void 0 : r.async) == null || o ? setTimeout(i, 0) : i();
  }
}), Xz = wr.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("tiptapDrop"),
        props: {
          handleDrop: (e, t, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: t,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), Jz = wr.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), Ix = new we("focusEvents"), eq = wr.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: e } = this;
    return [
      new me({
        key: Ix,
        props: {
          handleDOMEvents: {
            focus: (t, n) => {
              e.isFocused = !0;
              const r = e.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            },
            blur: (t, n) => {
              e.isFocused = !1;
              const r = e.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), tq = wr.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: u, $anchor: d } = l, { pos: f, parent: h } = d, p = d.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : d, m = p.parent.type.spec.isolating, b = d.pos - d.parentOffset, y = m && p.parent.childCount === 1 ? b === d.pos : ot.atStart(c).from === f;
        return !u || !h.type.isTextblock || h.textContent.length || !y || y && d.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: e,
      "Mod-Backspace": e,
      "Shift-Backspace": e,
      Delete: t,
      "Mod-Delete": t,
      "Mod-a": () => this.editor.commands.selectAll()
    }, o = {
      ...r
    }, i = {
      ...r,
      "Ctrl-h": e,
      "Alt-Backspace": e,
      "Ctrl-d": t,
      "Ctrl-Alt-Backspace": t,
      "Alt-Delete": t,
      "Alt-d": t,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return uc() || xx() ? i : o;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new me({
        key: new we("clearDocument"),
        appendTransaction: (e, t, n) => {
          if (e.some((m) => m.getMeta("composition")))
            return;
          const r = e.some((m) => m.docChanged) && !t.doc.eq(n.doc), o = e.some((m) => m.getMeta("preventClearDocument"));
          if (!r || o)
            return;
          const { empty: i, from: s, to: a } = t.selection, l = ot.atStart(t.doc).from, c = ot.atEnd(t.doc).to;
          if (i || !(s === l && a === c) || !Sx(n.doc))
            return;
          const f = n.tr, h = bx({
            state: n,
            transaction: f
          }), { commands: p } = new EV({
            editor: this.editor,
            state: h
          });
          if (p.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), nq = wr.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("tiptapPaste"),
        props: {
          handlePaste: (e, t, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: t,
              slice: n
            });
          }
        }
      })
    ];
  }
}), rq = wr.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), oq = wr.create({
  name: "textDirection",
  addOptions() {
    return {
      direction: void 0
    };
  },
  addGlobalAttributes() {
    if (!this.options.direction)
      return [];
    const { nodeExtensions: e } = vx(this.extensions);
    return [
      {
        types: e.filter((t) => t.name !== "text").map((t) => t.name),
        attributes: {
          dir: {
            default: this.options.direction,
            parseHTML: (t) => {
              const n = t.getAttribute("dir");
              return n && (n === "ltr" || n === "rtl" || n === "auto") ? n : this.options.direction;
            },
            renderHTML: (t) => t.dir ? {
              dir: t.dir
            } : {}
          }
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    return [
      new me({
        key: new we("textDirection"),
        props: {
          attributes: () => {
            const e = this.options.direction;
            return e ? {
              dir: e
            } : {};
          }
        }
      })
    ];
  }
}), iq = {};
em(iq, {
  createAtomBlockMarkdownSpec: () => sq,
  createBlockMarkdownSpec: () => aq,
  createInlineMarkdownSpec: () => uq,
  parseAttributes: () => rm,
  parseIndentedBlocks: () => dq,
  renderNestedMarkdownContent: () => fq,
  serializeAttributes: () => om
});
function rm(e) {
  if (!(e != null && e.trim()))
    return {};
  const t = {}, n = [], r = e.replace(/["']([^"']*)["']/g, (c) => (n.push(c), `__QUOTED_${n.length - 1}__`)), o = r.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (o) {
    const c = o.map((u) => u.trim().slice(1));
    t.class = c.join(" ");
  }
  const i = r.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  i && (t.id = i[1]);
  const s = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  Array.from(r.matchAll(s)).forEach(([, c, u]) => {
    var d;
    const f = parseInt(((d = u.match(/__QUOTED_(\d+)__/)) == null ? void 0 : d[1]) || "0", 10), h = n[f];
    h && (t[c] = h.slice(1, -1));
  });
  const l = r.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  return l && l.split(/\s+/).filter(Boolean).forEach((u) => {
    u.match(/^[a-zA-Z][\w-]*$/) && (t[u] = !0);
  }), t;
}
function om(e) {
  if (!e || Object.keys(e).length === 0)
    return "";
  const t = [];
  return e.class && String(e.class).split(/\s+/).filter(Boolean).forEach((r) => t.push(`.${r}`)), e.id && t.push(`#${e.id}`), Object.entries(e).forEach(([n, r]) => {
    n === "class" || n === "id" || (r === !0 ? t.push(n) : r !== !1 && r != null && t.push(`${n}="${String(r)}"`));
  }), t.join(" ");
}
function sq(e) {
  const {
    nodeName: t,
    name: n,
    parseAttributes: r = rm,
    serializeAttributes: o = om,
    defaultAttributes: i = {},
    requiredAttributes: s = [],
    allowedAttributes: a
  } = e, l = n || t, c = (u) => {
    if (!a)
      return u;
    const d = {};
    return a.forEach((f) => {
      f in u && (d[f] = u[f]);
    }), d;
  };
  return {
    parseMarkdown: (u, d) => {
      const f = { ...i, ...u.attributes };
      return d.createNode(t, f, []);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(u) {
        var d;
        const f = new RegExp(`^:::${l}(?:\\s|$)`, "m"), h = (d = u.match(f)) == null ? void 0 : d.index;
        return h !== void 0 ? h : -1;
      },
      tokenize(u, d, f) {
        const h = new RegExp(`^:::${l}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`), p = u.match(h);
        if (!p)
          return;
        const m = p[1] || "", b = r(m);
        if (!s.find((k) => !(k in b)))
          return {
            type: t,
            raw: p[0],
            attributes: b
          };
      }
    },
    renderMarkdown: (u) => {
      const d = c(u.attrs || {}), f = o(d), h = f ? ` {${f}}` : "";
      return `:::${l}${h} :::`;
    }
  };
}
function aq(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: o = rm,
    serializeAttributes: i = om,
    defaultAttributes: s = {},
    content: a = "block",
    allowedAttributes: l
  } = e, c = n || t, u = (d) => {
    if (!l)
      return d;
    const f = {};
    return l.forEach((h) => {
      h in d && (f[h] = d[h]);
    }), f;
  };
  return {
    parseMarkdown: (d, f) => {
      let h;
      if (r) {
        const m = r(d);
        h = typeof m == "string" ? [{ type: "text", text: m }] : m;
      } else a === "block" ? h = f.parseChildren(d.tokens || []) : h = f.parseInline(d.tokens || []);
      const p = { ...s, ...d.attributes };
      return f.createNode(t, p, h);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(d) {
        var f;
        const h = new RegExp(`^:::${c}`, "m"), p = (f = d.match(h)) == null ? void 0 : f.index;
        return p !== void 0 ? p : -1;
      },
      tokenize(d, f, h) {
        var p;
        const m = new RegExp(`^:::${c}(?:\\s+\\{([^}]*)\\})?\\s*\\n`), b = d.match(m);
        if (!b)
          return;
        const [y, k = ""] = b, C = o(k);
        let _ = 1;
        const w = y.length;
        let T = "";
        const M = /^:::([\w-]*)(\s.*)?/gm, D = d.slice(w);
        for (M.lastIndex = 0; ; ) {
          const R = M.exec(D);
          if (R === null)
            break;
          const N = R.index, B = R[1];
          if (!((p = R[2]) != null && p.endsWith(":::"))) {
            if (B)
              _ += 1;
            else if (_ -= 1, _ === 0) {
              const F = D.slice(0, N);
              T = F.trim();
              const W = d.slice(0, w + N + R[0].length);
              let L = [];
              if (T)
                if (a === "block")
                  for (L = h.blockTokens(F), L.forEach((H) => {
                    H.text && (!H.tokens || H.tokens.length === 0) && (H.tokens = h.inlineTokens(H.text));
                  }); L.length > 0; ) {
                    const H = L[L.length - 1];
                    if (H.type === "paragraph" && (!H.text || H.text.trim() === ""))
                      L.pop();
                    else
                      break;
                  }
                else
                  L = h.inlineTokens(T);
              return {
                type: t,
                raw: W,
                attributes: C,
                content: T,
                tokens: L
              };
            }
          }
        }
      }
    },
    renderMarkdown: (d, f) => {
      const h = u(d.attrs || {}), p = i(h), m = p ? ` {${p}}` : "", b = f.renderChildren(d.content || [], `

`);
      return `:::${c}${m}

${b}

:::`;
    }
  };
}
function lq(e) {
  if (!e.trim())
    return {};
  const t = {}, n = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let r = n.exec(e);
  for (; r !== null; ) {
    const [, o, i, s] = r;
    t[o] = i || s, r = n.exec(e);
  }
  return t;
}
function cq(e) {
  return Object.entries(e).filter(([, t]) => t != null).map(([t, n]) => `${t}="${n}"`).join(" ");
}
function uq(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: o = lq,
    serializeAttributes: i = cq,
    defaultAttributes: s = {},
    selfClosing: a = !1,
    allowedAttributes: l
  } = e, c = n || t, u = (f) => {
    if (!l)
      return f;
    const h = {};
    return l.forEach((p) => {
      const m = typeof p == "string" ? p : p.name, b = typeof p == "string" ? void 0 : p.skipIfDefault;
      if (m in f) {
        const y = f[m];
        if (b !== void 0 && y === b)
          return;
        h[m] = y;
      }
    }), h;
  }, d = c.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (f, h) => {
      const p = { ...s, ...f.attributes };
      if (a)
        return h.createNode(t, p);
      const m = r ? r(f) : f.content || "";
      return m ? h.createNode(t, p, [h.createTextNode(m)]) : h.createNode(t, p, []);
    },
    markdownTokenizer: {
      name: t,
      level: "inline",
      start(f) {
        const h = a ? new RegExp(`\\[${d}\\s*[^\\]]*\\]`) : new RegExp(`\\[${d}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${d}\\]`), p = f.match(h), m = p == null ? void 0 : p.index;
        return m !== void 0 ? m : -1;
      },
      tokenize(f, h, p) {
        const m = a ? new RegExp(`^\\[${d}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${d}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${d}\\]`), b = f.match(m);
        if (!b)
          return;
        let y = "", k = "";
        if (a) {
          const [, _] = b;
          k = _;
        } else {
          const [, _, w] = b;
          k = _, y = w || "";
        }
        const C = o(k.trim());
        return {
          type: t,
          raw: b[0],
          content: y.trim(),
          attributes: C
        };
      }
    },
    renderMarkdown: (f) => {
      let h = "";
      r ? h = r(f) : f.content && f.content.length > 0 && (h = f.content.filter((y) => y.type === "text").map((y) => y.text).join(""));
      const p = u(f.attrs || {}), m = i(p), b = m ? ` ${m}` : "";
      return a ? `[${c}${b}]` : `[${c}${b}]${h}[/${c}]`;
    }
  };
}
function dq(e, t, n) {
  var r, o, i, s;
  const a = e.split(`
`), l = [];
  let c = "", u = 0;
  const d = t.baseIndentSize || 2;
  for (; u < a.length; ) {
    const f = a[u], h = f.match(t.itemPattern);
    if (!h) {
      if (l.length > 0)
        break;
      if (f.trim() === "") {
        u += 1, c = `${c}${f}
`;
        continue;
      } else
        return;
    }
    const p = t.extractItemData(h), { indentLevel: m, mainContent: b } = p;
    c = `${c}${f}
`;
    const y = [b];
    for (u += 1; u < a.length; ) {
      const w = a[u];
      if (w.trim() === "") {
        const M = a.slice(u + 1).findIndex((N) => N.trim() !== "");
        if (M === -1)
          break;
        if ((((o = (r = a[u + 1 + M].match(/^(\s*)/)) == null ? void 0 : r[1]) == null ? void 0 : o.length) || 0) > m) {
          y.push(w), c = `${c}${w}
`, u += 1;
          continue;
        } else
          break;
      }
      if ((((s = (i = w.match(/^(\s*)/)) == null ? void 0 : i[1]) == null ? void 0 : s.length) || 0) > m)
        y.push(w), c = `${c}${w}
`, u += 1;
      else
        break;
    }
    let k;
    const C = y.slice(1);
    if (C.length > 0) {
      const w = C.map((T) => T.slice(m + d)).join(`
`);
      w.trim() && (t.customNestedParser ? k = t.customNestedParser(w) : k = n.blockTokens(w));
    }
    const _ = t.createToken(p, k);
    l.push(_);
  }
  if (l.length !== 0)
    return {
      items: l,
      raw: c
    };
}
function fq(e, t, n, r) {
  if (!e || !Array.isArray(e.content))
    return "";
  const o = typeof n == "function" ? n(r) : n, [i, ...s] = e.content, a = t.renderChildren([i]), l = [`${o}${a}`];
  return s && s.length > 0 && s.forEach((c) => {
    const u = t.renderChildren([c]);
    if (u) {
      const d = u.split(`
`).map((f) => f ? t.indent(f) : "").join(`
`);
      l.push(d);
    }
  }), l.join(`
`);
}
var hq = Object.defineProperty, pq = (e, t, n) => t in e ? hq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, us = (e, t, n) => pq(e, typeof t != "symbol" ? t + "" : t, n);
const Nx = Xn(void 0);
function rr(e) {
  return Tn(Nx);
}
const Mx = Xn(
  void 0
);
function ne() {
  return Tn(Mx);
}
function ae(e) {
  const t = rr();
  if (!(t != null && t.editor))
    throw new Error(
      "useBlockNoteEditor was called outside of a BlockNoteContext provider or BlockNoteView component"
    );
  return t.editor;
}
function Ce() {
  return rr().editor.dictionary;
}
const mq = (e) => {
  const t = ne(), n = Ce(), r = ae(), o = r.getBlock(e.blockId), [i, s] = fe(""), a = Z(
    (u) => {
      s(u.currentTarget.value);
    },
    []
  ), l = Z(
    (u) => {
      u.key === "Enter" && !u.nativeEvent.isComposing && (u.preventDefault(), r.updateBlock(o.id, {
        props: {
          name: ng(i),
          url: i
        }
      }));
    },
    [r, o.id, i]
  ), c = Z(() => {
    r.updateBlock(o.id, {
      props: {
        name: ng(i),
        url: i
      }
    });
  }, [r, o.id, i]);
  return /* @__PURE__ */ E.jsxs(t.FilePanel.TabPanel, { className: "bn-tab-panel", children: [
    /* @__PURE__ */ E.jsx(
      t.FilePanel.TextInput,
      {
        className: "bn-text-input",
        placeholder: n.file_panel.embed.url_placeholder,
        value: i,
        onChange: a,
        onKeyDown: l,
        "data-test": "embed-input"
      }
    ),
    /* @__PURE__ */ E.jsx(
      t.FilePanel.Button,
      {
        className: "bn-button",
        onClick: c,
        "data-test": "embed-input-button",
        children: n.file_panel.embed.embed_button[o.type] || n.file_panel.embed.embed_button.file
      }
    )
  ] });
}, gq = (e) => {
  var t, n;
  const r = ne(), o = Ce(), { setLoading: i } = e, s = ae(), a = s.getBlock(e.blockId), [l, c] = fe(!1);
  ie(() => {
    l && setTimeout(() => {
      c(!1);
    }, 3e3);
  }, [l]);
  const u = Z(
    (h) => {
      if (h === null)
        return;
      async function p(m) {
        if (i(!0), s.uploadFile !== void 0)
          try {
            let b = await s.uploadFile(m, e.blockId);
            typeof b == "string" && (b = {
              props: {
                name: m.name,
                url: b
              }
            }), s.updateBlock(e.blockId, b);
          } catch {
            c(!0);
          } finally {
            i(!1);
          }
      }
      p(h);
    },
    [e.blockId, s, i]
  ), d = s.schema.blockSpecs[a.type], f = (n = (t = d.implementation.meta) == null ? void 0 : t.fileBlockAccept) != null && n.length ? d.implementation.meta.fileBlockAccept.join(",") : "*/*";
  return /* @__PURE__ */ E.jsxs(r.FilePanel.TabPanel, { className: "bn-tab-panel", children: [
    /* @__PURE__ */ E.jsx(
      r.FilePanel.FileInput,
      {
        className: "bn-file-input",
        "data-test": "upload-input",
        accept: f,
        placeholder: o.file_panel.upload.file_placeholder[a.type] || o.file_panel.upload.file_placeholder.file,
        value: null,
        onChange: u
      }
    ),
    l && /* @__PURE__ */ E.jsx("div", { className: "bn-error-text", children: o.file_panel.upload.upload_error })
  ] });
}, Lx = (e) => {
  const t = ne(), n = Ce(), r = ae(), [o, i] = fe(!1), s = e.tabs ?? [
    ...r.uploadFile !== void 0 ? [
      {
        name: n.file_panel.upload.title,
        tabPanel: /* @__PURE__ */ E.jsx(gq, { blockId: e.blockId, setLoading: i })
      }
    ] : [],
    {
      name: n.file_panel.embed.title,
      tabPanel: /* @__PURE__ */ E.jsx(mq, { blockId: e.blockId })
    }
  ], [a, l] = fe(
    e.defaultOpenTab || s[0].name
  );
  return /* @__PURE__ */ E.jsx(
    t.FilePanel.Root,
    {
      className: "bn-panel",
      defaultOpenTab: a,
      openTab: a,
      setOpenTab: l,
      tabs: s,
      loading: o
    }
  );
};
function bq(e) {
  let t = new DOMRect();
  const n = "getBoundingClientRect" in e ? () => e.getBoundingClientRect() : () => e.element.getBoundingClientRect();
  return () => "element" in e && (e.cacheMountedBoundingClientRect ?? !0) ? (e.element.isConnected && (t = n()), t) : n();
}
const hr = (e) => {
  var t, n, r;
  const { refs: o, floatingStyles: i, context: s } = gu({
    whileElementsMounted: Ml,
    ...e.useFloatingOptions
  }), { isMounted: a, styles: l } = hV(
    s,
    e.useTransitionStylesProps
  ), { status: c } = mx(
    s,
    e.useTransitionStatusProps
  ), u = hx(s, e.useDismissProps), d = dx(s, { enabled: !1, ...e.useHoverProps }), { getFloatingProps: f } = px([u, d]), h = Ae(""), p = Ae(null), m = Wj([p, o.setFloating]);
  if (ie(() => {
    if (e.reference) {
      const y = "element" in e.reference ? e.reference.element : void 0;
      y !== void 0 && o.setReference(y), o.setPositionReference({
        getBoundingClientRect: bq(
          e.reference
        ),
        contextElement: y
      });
    }
  }, [e.reference, o]), ie(
    () => {
      var y;
      (c === "initial" || c === "open") && (y = p.current) != null && y.innerHTML && (h.current = p.current.innerHTML);
    },
    // `props.children` is added to the deps, since it's ultimately the HTML of
    // the children that we're storing.
    [c, e.reference, e.children]
  ), !a)
    return !1;
  const b = {
    ...e.elementProps,
    style: {
      display: "flex",
      ...(t = e.elementProps) == null ? void 0 : t.style,
      zIndex: `calc(var(--bn-ui-base-z-index) + ${((r = (n = e.elementProps) == null ? void 0 : n.style) == null ? void 0 : r.zIndex) || 0})`,
      ...i,
      ...l
    },
    ...f()
  };
  return c === "close" ? /* @__PURE__ */ E.jsx(
    "div",
    {
      ref: m,
      ...b,
      dangerouslySetInnerHTML: { __html: h.current }
    }
  ) : /* @__PURE__ */ E.jsx("div", { ref: m, ...b, children: e.children });
}, Ox = (e) => {
  const { blockId: t, children: n, ...r } = e, o = ae(), i = Me(
    () => o.transact((s) => {
      if (!t)
        return;
      const a = Yt(t, s.doc);
      if (!a)
        return;
      const { node: l } = o.prosemirrorView.domAtPos(
        a.posBeforeNode + 1
      );
      if (l instanceof Element)
        return {
          element: l
        };
    }),
    [o, t]
  );
  return /* @__PURE__ */ E.jsx(hr, { reference: i, ...r, children: t !== void 0 && n });
};
function Fe(e, t) {
  const n = ((t == null ? void 0 : t.editor) ?? ae()).getExtension(e);
  if (!n)
    throw new Error("Extension not found", { cause: { plugin: e } });
  return n;
}
function Ke(e, t) {
  const { store: n } = Fe(e, t);
  if (!n)
    throw new Error("Store not found on plugin", { cause: { plugin: e } });
  return gV(n, t == null ? void 0 : t.selector);
}
const yq = (e) => {
  const t = ae(), n = Fe(zn), r = Ke(zn), o = Me(
    () => {
      var s, a;
      return {
        ...e.floatingUIOptions,
        useFloatingOptions: {
          open: !!r,
          // Needed as hooks like `useDismiss` call `onOpenChange` to change the
          // open state.
          onOpenChange: (l, c, u) => {
            l || n.closeMenu(), u === "escape-key" && t.focus();
          },
          middleware: [Ln(10), Hr()],
          ...(s = e.floatingUIOptions) == null ? void 0 : s.useFloatingOptions
        },
        elementProps: {
          style: {
            zIndex: 90
          },
          ...(a = e.floatingUIOptions) == null ? void 0 : a.elementProps
        }
      };
    },
    [r, t, n, e.floatingUIOptions]
  ), i = e.filePanel || Lx;
  return /* @__PURE__ */ E.jsx(Ox, { blockId: r, ...o, children: r && /* @__PURE__ */ E.jsx(i, { blockId: r }) });
};
function Eq(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var kq = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t instanceof Map && n instanceof Map) {
      if (t.size !== n.size) return !1;
      for (o of t.entries())
        if (!n.has(o[0])) return !1;
      for (o of t.entries())
        if (!e(o[1], n.get(o[0]))) return !1;
      return !0;
    }
    if (t instanceof Set && n instanceof Set) {
      if (t.size !== n.size) return !1;
      for (o of t.entries())
        if (!n.has(o[0])) return !1;
      return !0;
    }
    if (ArrayBuffer.isView(t) && ArrayBuffer.isView(n)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (t[o] !== n[o]) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!(s === "_owner" && t.$$typeof) && !e(t[s], n[s]))
        return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
};
const Cq = /* @__PURE__ */ Eq(kq);
var ch = { exports: {} }, Hd = {}, Fd = { exports: {} }, Ud = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kb;
function Tq() {
  if (kb) return Ud;
  kb = 1;
  var e = st;
  function t(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, i = e.useLayoutEffect, s = e.useDebugValue;
  function a(d, f) {
    var h = f(), p = r({ inst: { value: h, getSnapshot: f } }), m = p[0].inst, b = p[1];
    return i(
      function() {
        m.value = h, m.getSnapshot = f, l(m) && b({ inst: m });
      },
      [d, h, f]
    ), o(
      function() {
        return l(m) && b({ inst: m }), d(function() {
          l(m) && b({ inst: m });
        });
      },
      [d]
    ), s(h), h;
  }
  function l(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var h = f();
      return !n(d, h);
    } catch {
      return !0;
    }
  }
  function c(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
  return Ud.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, Ud;
}
var Cb = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tb;
function xq() {
  return Tb || (Tb = 1, process.env.NODE_ENV !== "production" && function() {
    function e(h, p) {
      return h === p && (h !== 0 || 1 / h === 1 / p) || h !== h && p !== p;
    }
    function t(h, p) {
      u || o.startTransition === void 0 || (u = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var m = p();
      if (!d) {
        var b = p();
        i(m, b) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), d = !0);
      }
      b = s({
        inst: { value: m, getSnapshot: p }
      });
      var y = b[0].inst, k = b[1];
      return l(
        function() {
          y.value = m, y.getSnapshot = p, n(y) && k({ inst: y });
        },
        [h, m, p]
      ), a(
        function() {
          return n(y) && k({ inst: y }), h(function() {
            n(y) && k({ inst: y });
          });
        },
        [h]
      ), c(m), m;
    }
    function n(h) {
      var p = h.getSnapshot;
      h = h.value;
      try {
        var m = p();
        return !i(h, m);
      } catch {
        return !0;
      }
    }
    function r(h, p) {
      return p();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var o = st, i = typeof Object.is == "function" ? Object.is : e, s = o.useState, a = o.useEffect, l = o.useLayoutEffect, c = o.useDebugValue, u = !1, d = !1, f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : t;
    Cb.useSyncExternalStore = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Cb;
}
var xb;
function Dx() {
  return xb || (xb = 1, process.env.NODE_ENV === "production" ? Fd.exports = Tq() : Fd.exports = xq()), Fd.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wb;
function wq() {
  if (wb) return Hd;
  wb = 1;
  var e = st, t = Dx();
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, o = t.useSyncExternalStore, i = e.useRef, s = e.useEffect, a = e.useMemo, l = e.useDebugValue;
  return Hd.useSyncExternalStoreWithSelector = function(c, u, d, f, h) {
    var p = i(null);
    if (p.current === null) {
      var m = { hasValue: !1, value: null };
      p.current = m;
    } else m = p.current;
    p = a(
      function() {
        function y(T) {
          if (!k) {
            if (k = !0, C = T, T = f(T), h !== void 0 && m.hasValue) {
              var M = m.value;
              if (h(M, T))
                return _ = M;
            }
            return _ = T;
          }
          if (M = _, r(C, T)) return M;
          var D = f(T);
          return h !== void 0 && h(M, D) ? (C = T, M) : (C = T, _ = D);
        }
        var k = !1, C, _, w = d === void 0 ? null : d;
        return [
          function() {
            return y(u());
          },
          w === null ? void 0 : function() {
            return y(w());
          }
        ];
      },
      [u, d, f, h]
    );
    var b = o(c, p[0], p[1]);
    return s(
      function() {
        m.hasValue = !0, m.value = b;
      },
      [b]
    ), l(b), b;
  }, Hd;
}
var vb = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Sb;
function vq() {
  return Sb || (Sb = 1, process.env.NODE_ENV !== "production" && function() {
    function e(c, u) {
      return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var t = st, n = Dx(), r = typeof Object.is == "function" ? Object.is : e, o = n.useSyncExternalStore, i = t.useRef, s = t.useEffect, a = t.useMemo, l = t.useDebugValue;
    vb.useSyncExternalStoreWithSelector = function(c, u, d, f, h) {
      var p = i(null);
      if (p.current === null) {
        var m = { hasValue: !1, value: null };
        p.current = m;
      } else m = p.current;
      p = a(
        function() {
          function y(T) {
            if (!k) {
              if (k = !0, C = T, T = f(T), h !== void 0 && m.hasValue) {
                var M = m.value;
                if (h(M, T))
                  return _ = M;
              }
              return _ = T;
            }
            if (M = _, r(C, T))
              return M;
            var D = f(T);
            return h !== void 0 && h(M, D) ? (C = T, M) : (C = T, _ = D);
          }
          var k = !1, C, _, w = d === void 0 ? null : d;
          return [
            function() {
              return y(u());
            },
            w === null ? void 0 : function() {
              return y(w());
            }
          ];
        },
        [u, d, f, h]
      );
      var b = o(c, p[0], p[1]);
      return s(
        function() {
          m.hasValue = !0, m.value = b;
        },
        [b]
      ), l(b), b;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), vb;
}
process.env.NODE_ENV === "production" ? ch.exports = wq() : ch.exports = vq();
var Sq = ch.exports;
const _q = typeof window < "u" ? Ch : ie;
class Aq {
  constructor(t) {
    us(this, "transactionNumber", 0), us(this, "lastTransactionNumber", 0), us(this, "lastSnapshot"), us(this, "editor"), us(this, "subscribers", /* @__PURE__ */ new Set()), this.editor = t, this.lastSnapshot = { editor: t, transactionNumber: 0 }, this.getSnapshot = this.getSnapshot.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.watch = this.watch.bind(this), this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    return this.transactionNumber === this.lastTransactionNumber ? this.lastSnapshot : (this.lastTransactionNumber = this.transactionNumber, this.lastSnapshot = {
      editor: this.editor,
      transactionNumber: this.transactionNumber
    }, this.lastSnapshot);
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(t) {
    return this.subscribers.add(t), () => {
      this.subscribers.delete(t);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(t, n) {
    if (this.editor = t, this.editor) {
      const r = () => {
        this.transactionNumber += 1, this.subscribers.forEach((s) => s());
      }, o = this.editor._tiptapEditor, i = {
        all: "transaction",
        selection: "selectionUpdate",
        change: "update"
      };
      return o.on(i[n], r), () => {
        o.off(i[n], r);
      };
    }
  }
}
function _t(e) {
  const t = rr(), n = e.editor || (t == null ? void 0 : t.editor) || null, r = e.on || "all", [o] = fe(() => new Aq(n)), i = Sq.useSyncExternalStoreWithSelector(
    o.subscribe,
    o.getSnapshot,
    o.getServerSnapshot,
    e.selector,
    e.equalityFn ?? Cq
  );
  return _q(() => o.watch(n, r), [n, o, r]), $v(i), i;
}
const im = (e) => {
  const { position: t, children: n, ...r } = e, { from: o, to: i } = t || {}, s = ae(), a = Me(() => {
    var l;
    if (!(o === void 0 || i === void 0))
      return {
        // Use first child as the editor DOM element may itself be scrollable.
        // For FloatingUI to auto-update the position during scrolling, the
        // `contextElement` must be a descendant of the scroll container.
        element: ((l = s.domElement) == null ? void 0 : l.firstElementChild) || void 0,
        getBoundingClientRect: () => wz(s.prosemirrorView, o, i ?? o)
      };
  }, [s, o, i]);
  return /* @__PURE__ */ E.jsx(hr, { reference: a, ...r, children: t !== void 0 && n });
};
var Rx = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, _b = st.createContext && /* @__PURE__ */ st.createContext(Rx), Iq = ["attr", "size", "title"];
function Nq(e, t) {
  if (e == null) return {};
  var n = Mq(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Mq(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function dc() {
  return dc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, dc.apply(this, arguments);
}
function Ab(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ab(Object(n), !0).forEach(function(r) {
      Lq(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ab(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Lq(e, t, n) {
  return t = Oq(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Oq(e) {
  var t = Dq(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Dq(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Px(e) {
  return e && e.map((t, n) => /* @__PURE__ */ st.createElement(t.tag, fc({
    key: n
  }, t.attr), Px(t.child)));
}
function re(e) {
  return (t) => /* @__PURE__ */ st.createElement(Rq, dc({
    attr: fc({}, e.attr)
  }, t), Px(e.child));
}
function Rq(e) {
  var t = (n) => {
    var {
      attr: r,
      size: o,
      title: i
    } = e, s = Nq(e, Iq), a = o || n.size || "1em", l;
    return n.className && (l = n.className), e.className && (l = (l ? l + " " : "") + e.className), /* @__PURE__ */ st.createElement("svg", dc({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, r, s, {
      className: l,
      style: fc(fc({
        color: e.color || n.color
      }, n.style), e.style),
      height: a,
      width: a,
      xmlns: "http://www.w3.org/2000/svg"
    }), i && /* @__PURE__ */ st.createElement("title", null, i), e.children);
  };
  return _b !== void 0 ? /* @__PURE__ */ st.createElement(_b.Consumer, null, (n) => t(n)) : t(Rx);
}
function Pq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 7V11L2 6L8 1V5H13C17.4183 5 21 8.58172 21 13C21 17.4183 17.4183 21 13 21H4V19H13C16.3137 19 19 16.3137 19 13C19 9.68629 16.3137 7 13 7H8Z" }, child: [] }] })(e);
}
function Bx(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M7.29117 20.8242L2 22L3.17581 16.7088C2.42544 15.3056 2 13.7025 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C10.2975 22 8.6944 21.5746 7.29117 20.8242ZM7.58075 18.711L8.23428 19.0605C9.38248 19.6745 10.6655 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 13.3345 4.32549 14.6175 4.93949 15.7657L5.28896 16.4192L4.63416 19.3658L7.58075 18.711Z" }, child: [] }] })(e);
}
function Bq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M7.24264 17.9967H3V13.754L14.435 2.319C14.8256 1.92848 15.4587 1.92848 15.8492 2.319L18.6777 5.14743C19.0682 5.53795 19.0682 6.17112 18.6777 6.56164L7.24264 17.9967ZM3 19.9967H21V21.9967H3V19.9967Z" }, child: [] }] })(e);
}
function $q(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M23 12L15.9289 19.0711L14.5147 17.6569L20.1716 12L14.5147 6.34317L15.9289 4.92896L23 12ZM3.82843 12L9.48528 17.6569L8.07107 19.0711L1 12L8.07107 4.92896L9.48528 6.34317L3.82843 12Z" }, child: [] }] })(e);
}
function Hq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z" }, child: [] }] })(e);
}
function Fq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM5 19H19V21H5V19ZM3 14H21V16H3V14ZM5 9H19V11H5V9Z" }, child: [] }] })(e);
}
function Uq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM3 14H21V16H3V14ZM3 9H21V11H3V9Z" }, child: [] }] })(e);
}
function jq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H17V21H3V19ZM3 14H21V16H3V14ZM3 9H17V11H3V9Z" }, child: [] }] })(e);
}
function Vq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM7 19H21V21H7V19ZM3 14H21V16H3V14ZM7 9H21V11H7V9Z" }, child: [] }] })(e);
}
function zq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 11H12.5C13.8807 11 15 9.88071 15 8.5C15 7.11929 13.8807 6 12.5 6H8V11ZM18 15.5C18 17.9853 15.9853 20 13.5 20H6V4H12.5C14.9853 4 17 6.01472 17 8.5C17 9.70431 16.5269 10.7981 15.7564 11.6058C17.0979 12.3847 18 13.837 18 15.5ZM8 13V18H13.5C14.8807 18 16 16.8807 16 15.5C16 14.1193 14.8807 13 13.5 13H8Z" }, child: [] }] })(e);
}
function qq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3.41436 5.99995L5.70726 3.70706L4.29304 2.29285L0.585938 5.99995L4.29304 9.70706L5.70726 8.29285L3.41436 5.99995ZM9.58594 5.99995L7.29304 3.70706L8.70726 2.29285L12.4144 5.99995L8.70726 9.70706L7.29304 8.29285L9.58594 5.99995ZM14.0002 2.99995H21.0002C21.5524 2.99995 22.0002 3.44767 22.0002 3.99995V20C22.0002 20.5522 21.5524 21 21.0002 21H3.00015C2.44787 21 2.00015 20.5522 2.00015 20V12H4.00015V19H20.0002V4.99995H14.0002V2.99995Z" }, child: [] }] })(e);
}
function Ib(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5.55397 22H3.3999L10.9999 3H12.9999L20.5999 22H18.4458L16.0458 16H7.95397L5.55397 22ZM8.75397 14H15.2458L11.9999 5.88517L8.75397 14Z" }, child: [] }] })(e);
}
function hc(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 20H11V13H4V20H2V4H4V11H11V4H13V20ZM21.0005 8V20H19.0005L19 10.204L17 10.74V8.67L19.5005 8H21.0005Z" }, child: [] }] })(e);
}
function pc(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M4 4V11H11V4H13V20H11V13H4V20H2V4H4ZM18.5 8C20.5711 8 22.25 9.67893 22.25 11.75C22.25 12.6074 21.9623 13.3976 21.4781 14.0292L21.3302 14.2102L18.0343 18H22V20H15L14.9993 18.444L19.8207 12.8981C20.0881 12.5908 20.25 12.1893 20.25 11.75C20.25 10.7835 19.4665 10 18.5 10C17.5818 10 16.8288 10.7071 16.7558 11.6065L16.75 11.75H14.75C14.75 9.67893 16.4289 8 18.5 8Z" }, child: [] }] })(e);
}
function mc(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M22 8L21.9984 10L19.4934 12.883C21.0823 13.3184 22.25 14.7728 22.25 16.5C22.25 18.5711 20.5711 20.25 18.5 20.25C16.674 20.25 15.1528 18.9449 14.8184 17.2166L16.7821 16.8352C16.9384 17.6413 17.6481 18.25 18.5 18.25C19.4665 18.25 20.25 17.4665 20.25 16.5C20.25 15.5335 19.4665 14.75 18.5 14.75C18.214 14.75 17.944 14.8186 17.7056 14.9403L16.3992 13.3932L19.3484 10H15V8H22ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4Z" }, child: [] }] })(e);
}
function $x(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 20H11V13H4V20H2V4H4V11H11V4H13V20ZM22 8V16H23.5V18H22V20H20V18H14.5V16.66L19.5 8H22ZM20 11.133L17.19 16H20V11.133Z" }, child: [] }] })(e);
}
function Hx(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M22 8V10H17.6769L17.2126 12.6358C17.5435 12.5472 17.8912 12.5 18.25 12.5C20.4591 12.5 22.25 14.2909 22.25 16.5C22.25 18.7091 20.4591 20.5 18.25 20.5C16.4233 20.5 14.8827 19.2756 14.4039 17.6027L16.3271 17.0519C16.5667 17.8881 17.3369 18.5 18.25 18.5C19.3546 18.5 20.25 17.6046 20.25 16.5C20.25 15.3954 19.3546 14.5 18.25 14.5C17.6194 14.5 17.057 14.7918 16.6904 15.2478L14.8803 14.3439L16 8H22ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4Z" }, child: [] }] })(e);
}
function Fx(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M21.097 8L18.499 12.5C20.7091 12.5 22.5 14.2909 22.5 16.5C22.5 18.7091 20.7091 20.5 18.5 20.5C16.2909 20.5 14.5 18.7091 14.5 16.5C14.5 15.7636 14.699 15.0737 15.0461 14.4811L18.788 8H21.097ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4ZM18.5 14.5C17.3954 14.5 16.5 15.3954 16.5 16.5C16.5 17.6046 17.3954 18.5 18.5 18.5C19.6046 18.5 20.5 17.6046 20.5 16.5C20.5 15.3954 19.6046 14.5 18.5 14.5Z" }, child: [] }] })(e);
}
function Wq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM3 12.5L7 9V16L3 12.5Z" }, child: [] }] })(e);
}
function Gq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM7 12.5L3 16V9L7 12.5Z" }, child: [] }] })(e);
}
function Nb(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 5H11V19H8V21H16V19H13V5H16V3H8V5ZM2 7C1.44772 7 1 7.44772 1 8V16C1 16.5523 1.44772 17 2 17H8V15H3V9H8V7H2ZM16 9H21V15H16V17H22C22.5523 17 23 16.5523 23 16V8C23 7.44772 22.5523 7 22 7H16V9Z" }, child: [] }] })(e);
}
function Yq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M15 20H7V18H9.92661L12.0425 6H9V4H17V6H14.0734L11.9575 18H15V20Z" }, child: [] }] })(e);
}
function Kq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17 17H22V19H19V22H17V17ZM7 7H2V5H5V2H7V7ZM18.364 15.5355L16.9497 14.1213L18.364 12.7071C20.3166 10.7545 20.3166 7.58866 18.364 5.63604C16.4113 3.68342 13.2455 3.68342 11.2929 5.63604L9.87868 7.05025L8.46447 5.63604L9.87868 4.22183C12.6123 1.48816 17.0445 1.48816 19.7782 4.22183C22.5118 6.9555 22.5118 11.3877 19.7782 14.1213L18.364 15.5355ZM15.5355 18.364L14.1213 19.7782C11.3877 22.5118 6.9555 22.5118 4.22183 19.7782C1.48816 17.0445 1.48816 12.6123 4.22183 9.87868L5.63604 8.46447L7.05025 9.87868L5.63604 11.2929C3.68342 13.2455 3.68342 16.4113 5.63604 18.364C7.58866 20.3166 10.7545 20.3166 12.7071 18.364L14.1213 16.9497L15.5355 18.364ZM14.8284 7.75736L16.2426 9.17157L9.17157 16.2426L7.75736 14.8284L14.8284 7.75736Z" }, child: [] }] })(e);
}
function Ux(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M18.3638 15.5355L16.9496 14.1213L18.3638 12.7071C20.3164 10.7545 20.3164 7.58866 18.3638 5.63604C16.4112 3.68341 13.2453 3.68341 11.2927 5.63604L9.87849 7.05025L8.46428 5.63604L9.87849 4.22182C12.6122 1.48815 17.0443 1.48815 19.778 4.22182C22.5117 6.95549 22.5117 11.3876 19.778 14.1213L18.3638 15.5355ZM15.5353 18.364L14.1211 19.7782C11.3875 22.5118 6.95531 22.5118 4.22164 19.7782C1.48797 17.0445 1.48797 12.6123 4.22164 9.87868L5.63585 8.46446L7.05007 9.87868L5.63585 11.2929C3.68323 13.2455 3.68323 16.4113 5.63585 18.364C7.58847 20.3166 10.7543 20.3166 12.7069 18.364L14.1211 16.9497L15.5353 18.364ZM14.8282 7.75736L16.2425 9.17157L9.17139 16.2426L7.75717 14.8284L14.8282 7.75736Z" }, child: [] }] })(e);
}
function jx(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8.00008 6V9H5.00008V6H8.00008ZM3.00008 4V11H10.0001V4H3.00008ZM13.0001 4H21.0001V6H13.0001V4ZM13.0001 11H21.0001V13H13.0001V11ZM13.0001 18H21.0001V20H13.0001V18ZM10.7072 16.2071L9.29297 14.7929L6.00008 18.0858L4.20718 16.2929L2.79297 17.7071L6.00008 20.9142L10.7072 16.2071Z" }, child: [] }] })(e);
}
function Vx(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 4H21V6H8V4ZM5 3V6H6V7H3V6H4V4H3V3H5ZM3 14V11.5H5V11H3V10H6V12.5H4V13H6V14H3ZM5 19.5H3V18.5H5V18H3V17H6V21H3V20H5V19.5ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z" }, child: [] }] })(e);
}
function zx(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 4H21V6H8V4ZM4.5 6.5C3.67157 6.5 3 5.82843 3 5C3 4.17157 3.67157 3.5 4.5 3.5C5.32843 3.5 6 4.17157 6 5C6 5.82843 5.32843 6.5 4.5 6.5ZM4.5 13.5C3.67157 13.5 3 12.8284 3 12C3 11.1716 3.67157 10.5 4.5 10.5C5.32843 10.5 6 11.1716 6 12C6 12.8284 5.32843 13.5 4.5 13.5ZM4.5 20.4C3.67157 20.4 3 19.7284 3 18.9C3 18.0716 3.67157 17.4 4.5 17.4C5.32843 17.4 6 18.0716 6 18.9C6 19.7284 5.32843 20.4 4.5 20.4ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z" }, child: [] }] })(e);
}
function Qq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M20 3C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM11 5H5V10.999H7V9L10 12L7 15V13H5V19H11V17H13V19H19V13H17V15L14 12L17 9V10.999H19V5H13V7H11V5ZM13 13V15H11V13H13ZM13 9V11H11V9H13Z" }, child: [] }] })(e);
}
function Zq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M21 20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20C20.5523 3 21 3.44772 21 4V20ZM19 11V5H13.001V7H15L12 10L9 7H11V5H5V11H7V13H5V19H11V17H9L12 14L15 17H13.001V19H19V13H17V11H19ZM11 13H9V11H11V13ZM15 13H13V11H15V13Z" }, child: [] }] })(e);
}
function qx(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M21 4H3V6H21V4ZM21 11H8V13H21V11ZM21 18H8V20H21V18ZM5 11H3V20H5V11Z" }, child: [] }] })(e);
}
function Xq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17.1538 14C17.3846 14.5161 17.5 15.0893 17.5 15.7196C17.5 17.0625 16.9762 18.1116 15.9286 18.867C14.8809 19.6223 13.4335 20 11.5862 20C9.94674 20 8.32335 19.6185 6.71592 18.8555V16.6009C8.23538 17.4783 9.7908 17.917 11.3822 17.917C13.9333 17.917 15.2128 17.1846 15.2208 15.7196C15.2208 15.0939 15.0049 14.5598 14.5731 14.1173C14.5339 14.0772 14.4939 14.0381 14.4531 14H3V12H21V14H17.1538ZM13.076 11H7.62908C7.4566 10.8433 7.29616 10.6692 7.14776 10.4778C6.71592 9.92084 6.5 9.24559 6.5 8.45207C6.5 7.21602 6.96583 6.165 7.89749 5.299C8.82916 4.43299 10.2706 4 12.2219 4C13.6934 4 15.1009 4.32808 16.4444 4.98426V7.13591C15.2448 6.44921 13.9293 6.10587 12.4978 6.10587C10.0187 6.10587 8.77917 6.88793 8.77917 8.45207C8.77917 8.87172 8.99709 9.23796 9.43293 9.55079C9.86878 9.86362 10.4066 10.1135 11.0463 10.3004C11.6665 10.4816 12.3431 10.7148 13.076 11H13.076Z" }, child: [] }] })(e);
}
function Jq(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 10V14H19V10H13ZM11 10H5V14H11V10ZM13 19H19V16H13V19ZM11 19V16H5V19H11ZM13 5V8H19V5H13ZM11 5H5V8H11V5ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3Z" }, child: [] }] })(e);
}
function sm(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 6V21H11V6H5V4H19V6H13Z" }, child: [] }] })(e);
}
function eW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 3V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V3H18V12C18 15.3137 15.3137 18 12 18C8.68629 18 6 15.3137 6 12V3H8ZM4 20H20V22H4V20Z" }, child: [] }] })(e);
}
function tW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z" }, child: [] }] })(e);
}
function nW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z" }, child: [] }] })(e);
}
function rW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M21 15V18H24V20H21V23H19V20H16V18H19V15H21ZM21.0082 3C21.556 3 22 3.44495 22 3.9934L22.0007 13.3417C21.3749 13.1204 20.7015 13 20 13V5H4L4.001 19L13.2929 9.70715C13.6528 9.34604 14.22 9.31823 14.6123 9.62322L14.7065 9.70772L18.2521 13.2586C15.791 14.0069 14 16.2943 14 19C14 19.7015 14.1204 20.3749 14.3417 21.0007L2.9918 21C2.44405 21 2 20.5551 2 20.0066V3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082ZM8 7C9.10457 7 10 7.89543 10 9C10 10.1046 9.10457 11 8 11C6.89543 11 6 10.1046 6 9C6 7.89543 6.89543 7 8 7Z" }, child: [] }] })(e);
}
function oW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M20 3C20.5523 3 21 3.44772 21 4V5.757L19 7.757V5H5V13.1L9 9.1005L13.328 13.429L12.0012 14.7562L11.995 18.995L16.2414 19.0012L17.571 17.671L18.8995 19H19V16.242L21 14.242V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM21.7782 7.80761L23.1924 9.22183L15.4142 17L13.9979 16.9979L14 15.5858L21.7782 7.80761ZM15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7Z" }, child: [] }] })(e);
}
function Wx(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M22 18V20H2V18H22ZM2 3.5L10 8.5L2 13.5V3.5ZM22 11V13H12V11H22ZM22 4V6H12V4H22Z" }, child: [] }] })(e);
}
function iW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z" }, child: [] }] })(e);
}
function sW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M11 11V5H13V11H19V13H13V19H11V13H5V11H11Z" }, child: [] }] })(e);
}
function aW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M9.9997 15.1709L19.1921 5.97852L20.6063 7.39273L9.9997 17.9993L3.63574 11.6354L5.04996 10.2212L9.9997 15.1709Z" }, child: [] }] })(e);
}
function lW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17 6H22V8H20V21C20 21.5523 19.5523 22 19 22H5C4.44772 22 4 21.5523 4 21V8H2V6H7V3C7 2.44772 7.44772 2 8 2H16C16.5523 2 17 2.44772 17 3V6ZM18 8H6V20H18V8ZM9 4V6H15V4H9Z" }, child: [] }] })(e);
}
function cW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17 6H22V8H20V21C20 21.5523 19.5523 22 19 22H5C4.44772 22 4 21.5523 4 21V8H2V6H7V3C7 2.44772 7.44772 2 8 2H16C16.5523 2 17 2.44772 17 3V6ZM9 11V17H11V11H9ZM13 11V17H15V11H13ZM9 4V6H15V4H9Z" }, child: [] }] })(e);
}
function uW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M4 19H20V12H22V20C22 20.5523 21.5523 21 21 21H3C2.44772 21 2 20.5523 2 20V12H4V19ZM14 9H19L12 16L5 9H10V3H14V9Z" }, child: [] }] })(e);
}
function dW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M10 6V8H5V19H16V14H18V20C18 20.5523 17.5523 21 17 21H4C3.44772 21 3 20.5523 3 20V7C3 6.44772 3.44772 6 4 6H10ZM21 3V12L17.206 8.207L11.2071 14.2071L9.79289 12.7929L15.792 6.793L12 3H21Z" }, child: [] }] })(e);
}
function fW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5 10C3.9 10 3 10.9 3 12C3 13.1 3.9 14 5 14C6.1 14 7 13.1 7 12C7 10.9 6.1 10 5 10ZM19 10C17.9 10 17 10.9 17 12C17 13.1 17.9 14 19 14C20.1 14 21 13.1 21 12C21 10.9 20.1 10 19 10ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10Z" }, child: [] }] })(e);
}
function hW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5 11V13H19V11H5Z" }, child: [] }] })(e);
}
function pW(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM8 13C8 15.2091 9.79086 17 12 17C14.2091 17 16 15.2091 16 13H8ZM8 11C8.82843 11 9.5 10.3284 9.5 9.5C9.5 8.67157 8.82843 8 8 8C7.17157 8 6.5 8.67157 6.5 9.5C6.5 10.3284 7.17157 11 8 11ZM16 11C16.8284 11 17.5 10.3284 17.5 9.5C17.5 8.67157 16.8284 8 16 8C15.1716 8 14.5 8.67157 14.5 9.5C14.5 10.3284 15.1716 11 16 11Z" }, child: [] }] })(e);
}
function Mb(e) {
  return re({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM8 13H16C16 15.2091 14.2091 17 12 17C9.79086 17 8 15.2091 8 13ZM8 11C7.17157 11 6.5 10.3284 6.5 9.5C6.5 8.67157 7.17157 8 8 8C8.82843 8 9.5 8.67157 9.5 9.5C9.5 10.3284 8.82843 11 8 11ZM16 11C15.1716 11 14.5 10.3284 14.5 9.5C14.5 8.67157 15.1716 8 16 8C16.8284 8 17.5 8.67157 17.5 9.5C17.5 10.3284 16.8284 11 16 11Z" }, child: [] }] })(e);
}
const mW = {
  bold: zq,
  italic: Yq,
  underline: eW,
  strike: Xq,
  code: $q
};
function gW(e, t) {
  return e in t.schema.styleSchema && t.schema.styleSchema[e].type === e && t.schema.styleSchema[e].propSchema === "boolean";
}
const rl = (e) => {
  const t = Ce(), n = ne(), r = ae(), o = _t({
    editor: r,
    selector: ({ editor: a }) => {
      var l;
      if (
        // The editor is read-only.
        !(!a.isEditable || // The style is not in the schema.
        !gW(e.basicTextStyle, a) || // None of the selected blocks have inline content
        !(((l = a.getSelection()) == null ? void 0 : l.blocks) || [
          a.getTextCursorPosition().block
        ]).find((c) => c.content !== void 0))
      )
        return e.basicTextStyle in a.getActiveStyles() ? { active: !0 } : { active: !1 };
    }
  }), i = Z(
    (a) => {
      r.focus(), r.toggleStyles({ [a]: !0 });
    },
    [r, e]
  );
  if (o === void 0)
    return null;
  const s = mW[e.basicTextStyle];
  return /* @__PURE__ */ E.jsx(
    n.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": e.basicTextStyle,
      onClick: () => i(e.basicTextStyle),
      isSelected: o.active,
      label: t.formatting_toolbar[e.basicTextStyle].tooltip,
      mainTooltip: t.formatting_toolbar[e.basicTextStyle].tooltip,
      secondaryTooltip: Sn(
        t.formatting_toolbar[e.basicTextStyle].secondary_tooltip,
        t.generic.ctrl_shortcut
      ),
      icon: /* @__PURE__ */ E.jsx(s, {})
    }
  );
}, uh = (e) => {
  const t = e.textColor || "default", n = e.backgroundColor || "default", r = e.size || 16, o = Me(
    () => ({
      pointerEvents: "none",
      fontSize: (r * 0.75).toString() + "px",
      height: r.toString() + "px",
      lineHeight: r.toString() + "px",
      textAlign: "center",
      width: r.toString() + "px"
    }),
    [r]
  );
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "bn-color-icon",
      "data-background-color": n,
      "data-text-color": t,
      style: o,
      children: "A"
    }
  );
}, Lb = [
  "default",
  "gray",
  "brown",
  "red",
  "orange",
  "yellow",
  "green",
  "blue",
  "purple",
  "pink"
], bu = (e) => {
  const t = ne(), n = Ce();
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(() => e.text ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(t.Generic.Menu.Label, { children: n.color_picker.text_title }),
      Lb.map((r) => /* @__PURE__ */ E.jsx(
        t.Generic.Menu.Item,
        {
          onClick: () => {
            e.onClick && e.onClick(), e.text.setColor(r);
          },
          "data-test": "text-color-" + r,
          icon: /* @__PURE__ */ E.jsx(uh, { textColor: r, size: e.iconSize }),
          checked: e.text.color === r,
          children: n.color_picker.colors[r]
        },
        "text-color-" + r
      ))
    ] }) : null, {}),
    /* @__PURE__ */ E.jsx(() => e.background ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(t.Generic.Menu.Label, { children: n.color_picker.background_title }),
      Lb.map((r) => /* @__PURE__ */ E.jsx(
        t.Generic.Menu.Item,
        {
          onClick: () => {
            e.onClick && e.onClick(), e.background.setColor(r);
          },
          "data-test": "background-color-" + r,
          icon: /* @__PURE__ */ E.jsx(uh, { backgroundColor: r, size: e.iconSize }),
          checked: e.background.color === r,
          children: n.color_picker.colors[r]
        },
        "background-color-" + r
      ))
    ] }) : null, {})
  ] });
};
function ol(e, t) {
  return `${e}Color` in t.schema.styleSchema && t.schema.styleSchema[`${e}Color`].type === `${e}Color` && t.schema.styleSchema[`${e}Color`].propSchema === "string";
}
const bW = () => {
  const e = ne(), t = Ce(), n = ae(), r = ol("text", n), o = ol("background", n), i = _t({
    editor: n,
    selector: ({ editor: l }) => {
      var c;
      if (
        // The editor is read-only.
        !l.isEditable || // None of the selected blocks have inline content
        !(((c = l.getSelection()) == null ? void 0 : c.blocks) || [
          l.getTextCursorPosition().block
        ]).find((f) => f.content !== void 0)
      )
        return;
      const u = ol("text", l), d = ol("background", l);
      if (!(!u && !d))
        return {
          textColor: u ? l.getActiveStyles().textColor || "default" : void 0,
          backgroundColor: d ? l.getActiveStyles().backgroundColor || "default" : void 0
        };
    }
  }), s = Z(
    (l) => {
      if (!r)
        throw Error(
          "Tried to set text color, but style does not exist in editor schema."
        );
      l === "default" ? n.removeStyles({ textColor: l }) : n.addStyles({ textColor: l }), setTimeout(() => {
        n.focus();
      });
    },
    [n, r]
  ), a = Z(
    (l) => {
      if (!o)
        throw Error(
          "Tried to set background color, but style does not exist in editor schema."
        );
      l === "default" ? n.removeStyles({ backgroundColor: l }) : n.addStyles({ backgroundColor: l }), setTimeout(() => {
        n.focus();
      });
    },
    [o, n]
  );
  return i === void 0 ? null : /* @__PURE__ */ E.jsxs(e.Generic.Menu.Root, { children: [
    /* @__PURE__ */ E.jsx(e.Generic.Menu.Trigger, { children: /* @__PURE__ */ E.jsx(
      e.FormattingToolbar.Button,
      {
        className: "bn-button",
        "data-test": "colors",
        label: t.formatting_toolbar.colors.tooltip,
        mainTooltip: t.formatting_toolbar.colors.tooltip,
        icon: /* @__PURE__ */ E.jsx(
          uh,
          {
            textColor: i.textColor,
            backgroundColor: i.backgroundColor,
            size: 20
          }
        )
      }
    ) }),
    /* @__PURE__ */ E.jsx(
      e.Generic.Menu.Dropdown,
      {
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: /* @__PURE__ */ E.jsx(
          bu,
          {
            text: i.textColor ? {
              color: i.textColor,
              setColor: s
            } : void 0,
            background: i.backgroundColor ? {
              color: i.backgroundColor,
              setColor: a
            } : void 0
          }
        )
      }
    )
  ] });
}, Ob = (e) => {
  for (const t of NT)
    if (e.startsWith(t))
      return e;
  return `${MT}://${e}`;
}, Gx = (e) => {
  const t = ne(), n = Ce(), { editLink: r } = Fe(Ea), { url: o, text: i, showTextField: s } = e, [a, l] = fe(o), [c, u] = fe(i);
  ie(() => {
    l(o), u(i);
  }, [i, o]);
  const d = Z(
    (m) => {
      var b, y;
      m.key === "Enter" && !m.nativeEvent.isComposing && (m.preventDefault(), r(Ob(a), c, e.range.from), (b = e.setToolbarOpen) == null || b.call(e, !1), (y = e.setToolbarPositionFrozen) == null || y.call(e, !1));
    },
    [r, a, c, e]
  ), f = Z(
    (m) => l(m.currentTarget.value),
    []
  ), h = Z(
    (m) => u(m.currentTarget.value),
    []
  ), p = Z(() => {
    var m, b;
    r(Ob(a), c, e.range.from), (m = e.setToolbarOpen) == null || m.call(e, !1), (b = e.setToolbarPositionFrozen) == null || b.call(e, !1);
  }, [r, a, c, e]);
  return /* @__PURE__ */ E.jsxs(t.Generic.Form.Root, { children: [
    /* @__PURE__ */ E.jsx(
      t.Generic.Form.TextInput,
      {
        className: "bn-text-input",
        name: "url",
        icon: /* @__PURE__ */ E.jsx(Ux, {}),
        autoFocus: !0,
        placeholder: n.link_toolbar.form.url_placeholder,
        value: a,
        onKeyDown: d,
        onChange: f,
        onSubmit: p
      }
    ),
    s !== !1 && /* @__PURE__ */ E.jsx(
      t.Generic.Form.TextInput,
      {
        className: "bn-text-input",
        name: "title",
        icon: /* @__PURE__ */ E.jsx(sm, {}),
        placeholder: n.link_toolbar.form.title_placeholder,
        value: c,
        onKeyDown: d,
        onChange: h,
        onSubmit: p
      }
    )
  ] });
};
function yW(e) {
  return "link" in e.schema.inlineContentSchema && e.schema.inlineContentSchema.link === "link";
}
const EW = () => {
  const e = ae(), t = ne(), n = Ce(), r = Fe(ho), { showSelection: o } = Fe(lc), [i, s] = fe(!1);
  ie(() => (o(i, "createLinkButton"), () => o(!1, "createLinkButton")), [i, o]);
  const a = _t({
    editor: e,
    selector: ({ editor: l }) => {
      var c;
      if (
        // The editor is read-only.
        !(!l.isEditable || // Links are not in the schema.
        !yW(l) || // Table cells are selected.
        Lf(l.prosemirrorState.selection) || // None of the selected blocks have inline content
        !(((c = l.getSelection()) == null ? void 0 : c.blocks) || [
          l.getTextCursorPosition().block
        ]).find((u) => u.content !== void 0))
      )
        return {
          url: l.getSelectedLinkUrl(),
          text: l.getSelectedText(),
          range: {
            from: l.prosemirrorState.selection.from,
            to: l.prosemirrorState.selection.to
          }
        };
    }
  });
  return ie(() => {
    s(!1);
  }, [a]), ie(() => {
    const l = (u) => {
      (u.ctrlKey || u.metaKey) && u.key === "k" && (s(!0), u.preventDefault());
    }, c = e.domElement;
    return c == null || c.addEventListener("keydown", l), () => {
      c == null || c.removeEventListener("keydown", l);
    };
  }, [e.domElement]), a === void 0 ? null : /* @__PURE__ */ E.jsxs(
    t.Generic.Popover.Root,
    {
      open: i,
      onOpenChange: s,
      children: [
        /* @__PURE__ */ E.jsx(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ E.jsx(
          t.FormattingToolbar.Button,
          {
            className: "bn-button",
            "data-test": "createLink",
            label: n.formatting_toolbar.link.tooltip,
            mainTooltip: n.formatting_toolbar.link.tooltip,
            secondaryTooltip: Sn(
              n.formatting_toolbar.link.secondary_tooltip,
              n.generic.ctrl_shortcut
            ),
            icon: /* @__PURE__ */ E.jsx(Ux, {}),
            onClick: () => s((l) => !l)
          }
        ) }),
        /* @__PURE__ */ E.jsx(
          t.Generic.Popover.Content,
          {
            className: "bn-popover-content bn-form-popover",
            variant: "form-popover",
            children: /* @__PURE__ */ E.jsx(
              Gx,
              {
                url: a.url || "",
                text: a.text,
                range: a.range,
                showTextField: !1,
                setToolbarOpen: (l) => r.store.setState(l)
              }
            )
          }
        )
      ]
    }
  );
}, kW = () => {
  const e = Ce(), t = ne(), n = ae(), r = _t({
    editor: n,
    selector: ({ editor: l }) => {
      var c;
      if (!l.isEditable)
        return;
      const u = ((c = l.getSelection()) == null ? void 0 : c.blocks) || [
        l.getTextCursorPosition().block
      ];
      if (u.length !== 1)
        return;
      const d = u[0];
      if (on(d, l, d.type, {
        url: "string",
        caption: "string"
      }))
        return d;
    }
  }), [o, i] = fe();
  ie(() => {
    r !== void 0 && i(r.props.caption);
  }, [r]);
  const s = Z(
    (l) => i(l.currentTarget.value),
    []
  ), a = Z(
    (l) => {
      r !== void 0 && rt(n, r.type, {
        caption: "string"
      }) && l.key === "Enter" && !l.nativeEvent.isComposing && (l.preventDefault(), n.updateBlock(r.id, {
        props: {
          caption: o
        }
      }));
    },
    [r, o, n]
  );
  return r === void 0 ? null : /* @__PURE__ */ E.jsxs(t.Generic.Popover.Root, { children: [
    /* @__PURE__ */ E.jsx(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ E.jsx(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        label: e.formatting_toolbar.file_caption.tooltip,
        mainTooltip: e.formatting_toolbar.file_caption.tooltip,
        icon: /* @__PURE__ */ E.jsx(Nb, {})
      }
    ) }),
    /* @__PURE__ */ E.jsx(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: /* @__PURE__ */ E.jsx(t.Generic.Form.Root, { children: /* @__PURE__ */ E.jsx(
          t.Generic.Form.TextInput,
          {
            name: "file-caption",
            icon: /* @__PURE__ */ E.jsx(Nb, {}),
            value: o || "",
            autoFocus: !0,
            placeholder: e.formatting_toolbar.file_caption.input_placeholder,
            onKeyDown: a,
            onChange: s
          }
        ) })
      }
    )
  ] });
}, CW = () => {
  const e = Ce(), t = ne(), n = ae(), r = _t({
    editor: n,
    selector: ({ editor: i }) => {
      var s;
      if (!i.isEditable)
        return;
      const a = ((s = i.getSelection()) == null ? void 0 : s.blocks) || [
        i.getTextCursorPosition().block
      ];
      if (a.length !== 1)
        return;
      const l = a[0];
      if (on(l, i, l.type, {
        url: "string"
      }))
        return l;
    }
  }), o = Z(() => {
    r !== void 0 && (n.focus(), n.removeBlocks([r.id]));
  }, [r, n]);
  return r === void 0 ? null : /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.file_delete.tooltip[r.type] || e.formatting_toolbar.file_delete.tooltip.file,
      mainTooltip: e.formatting_toolbar.file_delete.tooltip[r.type] || e.formatting_toolbar.file_delete.tooltip.file,
      icon: /* @__PURE__ */ E.jsx(lW, {}),
      onClick: o
    }
  );
}, TW = () => {
  const e = Ce(), t = ne(), n = ae(), r = _t({
    editor: n,
    selector: ({ editor: l }) => {
      var c;
      if (!l.isEditable)
        return;
      const u = ((c = l.getSelection()) == null ? void 0 : c.blocks) || [
        l.getTextCursorPosition().block
      ];
      if (u.length !== 1)
        return;
      const d = u[0];
      if (on(d, l, d.type, {
        url: "string",
        name: "string"
      }))
        return d;
    }
  }), [o, i] = fe();
  ie(() => {
    r !== void 0 && i(r.props.name);
  }, [r]);
  const s = Z(
    (l) => i(l.currentTarget.value),
    []
  ), a = Z(
    (l) => {
      r !== void 0 && rt(n, r.type, {
        name: "string"
      }) && l.key === "Enter" && !l.nativeEvent.isComposing && (l.preventDefault(), n.updateBlock(r.id, {
        props: {
          name: o
        }
      }));
    },
    [r, o, n]
  );
  return r === void 0 ? null : /* @__PURE__ */ E.jsxs(t.Generic.Popover.Root, { children: [
    /* @__PURE__ */ E.jsx(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ E.jsx(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        label: e.formatting_toolbar.file_rename.tooltip[r.type] || e.formatting_toolbar.file_rename.tooltip.file,
        mainTooltip: e.formatting_toolbar.file_rename.tooltip[r.type] || e.formatting_toolbar.file_rename.tooltip.file,
        icon: /* @__PURE__ */ E.jsx(Ib, {})
      }
    ) }),
    /* @__PURE__ */ E.jsx(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: /* @__PURE__ */ E.jsx(t.Generic.Form.Root, { children: /* @__PURE__ */ E.jsx(
          t.Generic.Form.TextInput,
          {
            name: "file-name",
            icon: /* @__PURE__ */ E.jsx(Ib, {}),
            value: o || "",
            autoFocus: !0,
            placeholder: e.formatting_toolbar.file_rename.input_placeholder[r.type] || e.formatting_toolbar.file_rename.input_placeholder.file,
            onKeyDown: a,
            onChange: s
          }
        ) })
      }
    )
  ] });
}, xW = () => {
  const e = Ce(), t = ne(), n = ae(), r = _t({
    editor: n,
    selector: ({ editor: o }) => {
      var i;
      if (!o.isEditable)
        return;
      const s = ((i = o.getSelection()) == null ? void 0 : i.blocks) || [
        o.getTextCursorPosition().block
      ];
      if (s.length !== 1)
        return;
      const a = s[0];
      if (on(a, o, a.type, {
        url: "string"
      }))
        return a;
    }
  });
  return r === void 0 ? null : /* @__PURE__ */ E.jsxs(t.Generic.Popover.Root, { position: "bottom", children: [
    /* @__PURE__ */ E.jsx(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ E.jsx(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        mainTooltip: e.formatting_toolbar.file_replace.tooltip[r.type] || e.formatting_toolbar.file_replace.tooltip.file,
        label: e.formatting_toolbar.file_replace.tooltip[r.type] || e.formatting_toolbar.file_replace.tooltip.file,
        icon: /* @__PURE__ */ E.jsx(oW, {})
      }
    ) }),
    /* @__PURE__ */ E.jsx(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-panel-popover",
        variant: "panel-popover",
        children: /* @__PURE__ */ E.jsx(Lx, { blockId: r.id })
      }
    )
  ] });
}, wW = () => {
  const e = Ce(), t = ne(), n = ae(), r = _t({
    editor: n,
    selector: ({ editor: i }) => {
      var s;
      if (
        // The editor is read-only.
        !(!i.isEditable || // None of the selected blocks have inline content
        !(((s = i.getSelection()) == null ? void 0 : s.blocks) || [
          i.getTextCursorPosition().block
        ]).find((a) => a.content !== void 0))
      )
        return {
          canNestBlock: i.canNestBlock()
        };
    }
  }), o = Z(() => {
    r !== void 0 && r.canNestBlock && (n.focus(), n.nestBlock());
  }, [n, r]);
  return r === void 0 ? null : /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": "nestBlock",
      onClick: o,
      isDisabled: !r.canNestBlock,
      label: e.formatting_toolbar.nest.tooltip,
      mainTooltip: e.formatting_toolbar.nest.tooltip,
      secondaryTooltip: Sn(
        e.formatting_toolbar.nest.secondary_tooltip,
        e.generic.ctrl_shortcut
      ),
      icon: /* @__PURE__ */ E.jsx(Gq, {})
    }
  );
}, vW = () => {
  const e = Ce(), t = ne(), n = ae(), r = _t({
    editor: n,
    selector: ({ editor: i }) => {
      var s;
      if (
        // The editor is read-only.
        !(!i.isEditable || // None of the selected blocks have inline content
        !(((s = i.getSelection()) == null ? void 0 : s.blocks) || [
          i.getTextCursorPosition().block
        ]).find((a) => a.content !== void 0))
      )
        return {
          canUnnestBlock: i.canUnnestBlock()
        };
    }
  }), o = Z(() => {
    r !== void 0 && r.canUnnestBlock && (n.focus(), n.unnestBlock());
  }, [n, r]);
  return r === void 0 ? null : /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": "unnestBlock",
      onClick: o,
      isDisabled: !r.canUnnestBlock,
      label: e.formatting_toolbar.unnest.tooltip,
      mainTooltip: e.formatting_toolbar.unnest.tooltip,
      secondaryTooltip: Sn(
        e.formatting_toolbar.unnest.secondary_tooltip,
        e.generic.ctrl_shortcut
      ),
      icon: /* @__PURE__ */ E.jsx(Wq, {})
    }
  );
}, SW = (e) => [
  {
    name: e.slash_menu.paragraph.title,
    type: "paragraph",
    icon: sm
  },
  {
    name: e.slash_menu.heading.title,
    type: "heading",
    props: { level: 1, isToggleable: !1 },
    icon: hc
  },
  {
    name: e.slash_menu.heading_2.title,
    type: "heading",
    props: { level: 2, isToggleable: !1 },
    icon: pc
  },
  {
    name: e.slash_menu.heading_3.title,
    type: "heading",
    props: { level: 3, isToggleable: !1 },
    icon: mc
  },
  {
    name: e.slash_menu.heading_4.title,
    type: "heading",
    props: { level: 4, isToggleable: !1 },
    icon: $x
  },
  {
    name: e.slash_menu.heading_5.title,
    type: "heading",
    props: { level: 5, isToggleable: !1 },
    icon: Hx
  },
  {
    name: e.slash_menu.heading_6.title,
    type: "heading",
    props: { level: 6, isToggleable: !1 },
    icon: Fx
  },
  {
    name: e.slash_menu.toggle_heading.title,
    type: "heading",
    props: { level: 1, isToggleable: !0 },
    icon: hc
  },
  {
    name: e.slash_menu.toggle_heading_2.title,
    type: "heading",
    props: { level: 2, isToggleable: !0 },
    icon: pc
  },
  {
    name: e.slash_menu.toggle_heading_3.title,
    type: "heading",
    props: { level: 3, isToggleable: !0 },
    icon: mc
  },
  {
    name: e.slash_menu.quote.title,
    type: "quote",
    icon: qx
  },
  {
    name: e.slash_menu.toggle_list.title,
    type: "toggleListItem",
    icon: Wx
  },
  {
    name: e.slash_menu.bullet_list.title,
    type: "bulletListItem",
    icon: zx
  },
  {
    name: e.slash_menu.numbered_list.title,
    type: "numberedListItem",
    icon: Vx
  },
  {
    name: e.slash_menu.check_list.title,
    type: "checkListItem",
    icon: jx
  }
], _W = (e) => {
  const t = ne(), n = ae(), r = _t({
    editor: n,
    selector: ({ editor: a }) => {
      var l;
      return ((l = a.getSelection()) == null ? void 0 : l.blocks) || [a.getTextCursorPosition().block];
    }
  }), o = r[0], i = Me(
    () => (e.items || SW(n.dictionary)).filter(
      (a) => rt(
        n,
        a.type,
        Object.fromEntries(
          Object.entries(a.props || {}).map(([l, c]) => [
            l,
            typeof c
          ])
        )
      )
    ),
    [n, e.items]
  ), s = Me(() => i.map((a) => {
    const l = a.icon, c = a.type === o.type, u = Object.entries(a.props || {}).filter(
      ([d, f]) => f !== o.props[d]
    ).length === 0;
    return {
      text: a.name,
      icon: /* @__PURE__ */ E.jsx(l, { size: 16 }),
      onClick: () => {
        n.focus(), n.transact(() => {
          for (const d of r)
            n.updateBlock(d, {
              type: a.type,
              props: a.props
            });
        });
      },
      isSelected: c && u
    };
  }), [
    n,
    i,
    o.props,
    o.type,
    r
  ]);
  return !Me(
    () => s.find((a) => a.isSelected) !== void 0,
    [s]
  ) || !n.isEditable ? null : /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Select,
    {
      className: "bn-select",
      items: s
    }
  );
}, AW = () => {
  const e = Ce(), t = ne(), n = Fe("comments"), { store: r } = Fe(ho), o = Z(() => {
    n.startPendingComment(), r.setState(!1);
  }, [n, r]);
  return /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.comment.tooltip,
      mainTooltip: e.formatting_toolbar.comment.tooltip,
      icon: /* @__PURE__ */ E.jsx(Bx, {}),
      onClick: o
    }
  );
}, IW = () => ae().getExtension("comments") ? /* @__PURE__ */ E.jsx(AW, {}) : null, NW = () => {
  const e = Ce(), t = ne(), n = ae(), r = Z(() => {
    n._tiptapEditor.chain().focus().addPendingComment().run();
  }, [n]);
  return (
    // We manually check if a comment extension (like liveblocks) is installed
    // By adding default support for this, the user doesn't need to customize the formatting toolbar
    !n._tiptapEditor.commands.addPendingComment || !n.isEditable ? null : /* @__PURE__ */ E.jsx(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        label: e.formatting_toolbar.comment.tooltip,
        mainTooltip: e.formatting_toolbar.comment.tooltip,
        icon: /* @__PURE__ */ E.jsx(Bx, {}),
        onClick: r
      }
    )
  );
};
function dh(e, t) {
  try {
    const n = new URL(e, t);
    if (n.protocol !== "javascript:")
      return n.href;
  } catch {
  }
  return "#";
}
const MW = () => {
  const e = Ce(), t = ne(), n = ae(), r = _t({
    editor: n,
    selector: ({ editor: i }) => {
      var s;
      const a = ((s = i.getSelection()) == null ? void 0 : s.blocks) || [
        i.getTextCursorPosition().block
      ];
      if (a.length !== 1)
        return;
      const l = a[0];
      if (on(l, i, l.type, {
        url: "string"
      }))
        return l;
    }
  }), o = Z(() => {
    r !== void 0 && (n.focus(), n.resolveFileUrl ? n.resolveFileUrl(r.props.url).then(
      (i) => window.open(dh(i, window.location.href))
    ) : window.open(dh(r.props.url, window.location.href)));
  }, [r, n]);
  return r === void 0 ? null : /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.file_download.tooltip[r.type] || e.formatting_toolbar.file_download.tooltip.file,
      mainTooltip: e.formatting_toolbar.file_download.tooltip[r.type] || e.formatting_toolbar.file_download.tooltip.file,
      icon: /* @__PURE__ */ E.jsx(uW, {}),
      onClick: o
    }
  );
}, LW = () => {
  const e = Ce(), t = ne(), n = ae(), r = _t({
    editor: n,
    selector: ({ editor: i }) => {
      var s;
      if (!i.isEditable)
        return;
      const a = ((s = i.getSelection()) == null ? void 0 : s.blocks) || [
        i.getTextCursorPosition().block
      ];
      if (a.length !== 1)
        return;
      const l = a[0];
      if (on(l, i, l.type, {
        url: "string",
        showPreview: "boolean"
      }))
        return l;
    }
  }), o = Z(() => {
    r !== void 0 && rt(n, r.type, {
      showPreview: "boolean"
    }) && n.updateBlock(r.id, {
      props: {
        showPreview: !r.props.showPreview
      }
    });
  }, [r, n]);
  return r === void 0 ? null : /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: "Toggle preview",
      mainTooltip: e.formatting_toolbar.file_preview_toggle.tooltip,
      icon: /* @__PURE__ */ E.jsx(rW, {}),
      isSelected: r.props.showPreview,
      onClick: o
    }
  );
}, OW = () => {
  const e = Ce(), t = ne(), n = ae(), r = Fe(tt), o = _t({
    editor: n,
    selector: ({ editor: s }) => {
      var a;
      if (!s.isEditable || !s.settings.tables.splitCells)
        return;
      const l = ((a = s.getSelection()) == null ? void 0 : a.blocks) || [
        s.getTextCursorPosition().block
      ];
      if (l.length !== 1)
        return;
      const c = l[0];
      if (c.type === "table")
        return {
          mergeDirection: r.getMergeDirection(c)
        };
    }
  }), i = Z(() => {
    r == null || r.mergeCells();
  }, [r]);
  return o === void 0 ? null : /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.table_cell_merge.tooltip,
      mainTooltip: e.formatting_toolbar.table_cell_merge.tooltip,
      icon: o.mergeDirection === "horizontal" ? /* @__PURE__ */ E.jsx(Qq, {}) : /* @__PURE__ */ E.jsx(Zq, {}),
      onClick: i
    }
  );
}, DW = () => ae().getExtension(tt) ? /* @__PURE__ */ E.jsx(OW, {}) : null, RW = {
  left: jq,
  center: Fq,
  right: Vq,
  justify: Uq
}, jd = (e) => {
  const t = ne(), n = Ce(), r = ae(), o = _t({
    editor: r,
    selector: ({ editor: a }) => {
      var l, c;
      if (!a.isEditable)
        return;
      const u = ((l = a.getSelection()) == null ? void 0 : l.blocks) || [
        a.getTextCursorPosition().block
      ], d = u[0];
      if (on(d, a, d.type, {
        textAlignment: $e.textAlignment
      }))
        return {
          textAlignment: d.props.textAlignment,
          blocks: u
        };
      if (u.length === 1 && on(d, a, "table"))
        return (c = a.getExtension(tt)) != null && c.getCellSelection() ? {
          textAlignment: oo(
            d.content.rows[0].cells[0]
          ).props.textAlignment,
          blocks: [d]
        } : void 0;
    }
  }), i = Z(
    (a) => {
      var l;
      if (o !== void 0) {
        r.focus();
        for (const c of o.blocks)
          if (on(c, r, c.type, {
            textAlignment: $e.textAlignment
          }) && rt(r, c.type, {
            textAlignment: $e.textAlignment
          }))
            r.updateBlock(c, {
              props: { textAlignment: a }
            });
          else if (c.type === "table") {
            const u = (l = r.getExtension(tt)) == null ? void 0 : l.getCellSelection();
            if (!u)
              continue;
            const d = c.content.rows.map(
              (f) => ({
                ...f,
                cells: f.cells.map((h) => oo(h))
              })
            );
            u.cells.forEach(({ row: f, col: h }) => {
              d[f].cells[h].props.textAlignment = a;
            }), r.updateBlock(c, {
              type: "table",
              content: {
                ...c.content,
                type: "tableContent",
                rows: d
              }
            }), r.setTextCursorPosition(c);
          }
      }
    },
    [r, o]
  );
  if (o === void 0)
    return null;
  const s = RW[e.textAlignment];
  return /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": `alignText${e.textAlignment.slice(0, 1).toUpperCase() + e.textAlignment.slice(1)}`,
      onClick: () => i(e.textAlignment),
      isSelected: o.textAlignment === e.textAlignment,
      label: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,
      mainTooltip: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,
      icon: /* @__PURE__ */ E.jsx(s, {})
    }
  );
}, Yx = (e) => [
  /* @__PURE__ */ E.jsx(_W, { items: e }, "blockTypeSelect"),
  /* @__PURE__ */ E.jsx(DW, {}, "tableCellMergeButton"),
  /* @__PURE__ */ E.jsx(kW, {}, "fileCaptionButton"),
  /* @__PURE__ */ E.jsx(xW, {}, "replaceFileButton"),
  /* @__PURE__ */ E.jsx(TW, {}, "fileRenameButton"),
  /* @__PURE__ */ E.jsx(CW, {}, "fileDeleteButton"),
  /* @__PURE__ */ E.jsx(MW, {}, "fileDownloadButton"),
  /* @__PURE__ */ E.jsx(LW, {}, "filePreviewButton"),
  /* @__PURE__ */ E.jsx(rl, { basicTextStyle: "bold" }, "boldStyleButton"),
  /* @__PURE__ */ E.jsx(rl, { basicTextStyle: "italic" }, "italicStyleButton"),
  /* @__PURE__ */ E.jsx(
    rl,
    {
      basicTextStyle: "underline"
    },
    "underlineStyleButton"
  ),
  /* @__PURE__ */ E.jsx(rl, { basicTextStyle: "strike" }, "strikeStyleButton"),
  /* @__PURE__ */ E.jsx(jd, { textAlignment: "left" }, "textAlignLeftButton"),
  /* @__PURE__ */ E.jsx(jd, { textAlignment: "center" }, "textAlignCenterButton"),
  /* @__PURE__ */ E.jsx(jd, { textAlignment: "right" }, "textAlignRightButton"),
  /* @__PURE__ */ E.jsx(bW, {}, "colorStyleButton"),
  /* @__PURE__ */ E.jsx(wW, {}, "nestBlockButton"),
  /* @__PURE__ */ E.jsx(vW, {}, "unnestBlockButton"),
  /* @__PURE__ */ E.jsx(EW, {}, "createLinkButton"),
  /* @__PURE__ */ E.jsx(IW, {}, "addCommentButton"),
  /* @__PURE__ */ E.jsx(NW, {}, "addTiptapCommentButton")
], Kx = (e) => {
  const t = ne();
  return /* @__PURE__ */ E.jsx(
    t.FormattingToolbar.Root,
    {
      className: "bn-toolbar bn-formatting-toolbar",
      children: e.children || Yx(e.blockTypeSelectItems)
    }
  );
}, PW = (e) => {
  switch (e) {
    case "left":
      return "top-start";
    case "center":
      return "top";
    case "right":
      return "top-end";
    default:
      return "top-start";
  }
}, Qx = (e) => {
  const t = ae(), n = Fe(ho, {
    editor: t
  }), r = Ke(ho, {
    editor: t
  }), o = _t({
    editor: t,
    selector: ({ editor: l }) => n.store.state ? {
      from: l.prosemirrorState.selection.from,
      to: l.prosemirrorState.selection.to
    } : void 0
  }), i = _t({
    editor: t,
    selector: ({ editor: l }) => {
      const c = l.getTextCursorPosition().block;
      return on(c, l, c.type, {
        textAlignment: $e.textAlignment
      }) ? PW(c.props.textAlignment) : "top-start";
    }
  }), s = Me(
    () => {
      var l, c;
      return {
        ...e.floatingUIOptions,
        useFloatingOptions: {
          open: r,
          // Needed as hooks like `useDismiss` call `onOpenChange` to change the
          // open state.
          onOpenChange: (u, d, f) => {
            n.store.setState(u), f === "escape-key" && t.focus();
          },
          placement: i,
          middleware: [Ln(10), mo(), Hr()],
          ...(l = e.floatingUIOptions) == null ? void 0 : l.useFloatingOptions
        },
        elementProps: {
          style: {
            zIndex: 40
          },
          ...(c = e.floatingUIOptions) == null ? void 0 : c.elementProps
        }
      };
    },
    [r, i, e.floatingUIOptions, n.store, t]
  ), a = e.formattingToolbar || Kx;
  return /* @__PURE__ */ E.jsx(im, { position: o, ...s, children: r && /* @__PURE__ */ E.jsx(a, {}) });
}, BW = (e) => {
  const t = ne(), n = Ce(), { deleteLink: r } = Fe(Ea);
  return /* @__PURE__ */ E.jsx(
    t.LinkToolbar.Button,
    {
      className: "bn-button",
      label: n.link_toolbar.delete.tooltip,
      mainTooltip: n.link_toolbar.delete.tooltip,
      isSelected: !1,
      onClick: () => {
        var o;
        r(e.range.from), (o = e.setToolbarOpen) == null || o.call(e, !1);
      },
      icon: /* @__PURE__ */ E.jsx(Kq, {})
    }
  );
}, $W = (e) => {
  const t = ne(), n = Ce();
  return /* @__PURE__ */ E.jsxs(
    t.Generic.Popover.Root,
    {
      onOpenChange: e.setToolbarPositionFrozen,
      children: [
        /* @__PURE__ */ E.jsx(t.Generic.Popover.Trigger, { children: /* @__PURE__ */ E.jsx(
          t.LinkToolbar.Button,
          {
            className: "bn-button",
            mainTooltip: n.link_toolbar.edit.tooltip,
            isSelected: !1,
            children: n.link_toolbar.edit.text
          }
        ) }),
        /* @__PURE__ */ E.jsx(
          t.Generic.Popover.Content,
          {
            className: "bn-popover-content bn-form-popover",
            variant: "form-popover",
            children: /* @__PURE__ */ E.jsx(
              Gx,
              {
                url: e.url,
                text: e.text,
                range: e.range,
                setToolbarOpen: e.setToolbarOpen,
                setToolbarPositionFrozen: e.setToolbarPositionFrozen
              }
            )
          }
        )
      ]
    }
  );
}, HW = (e) => {
  const t = ne(), n = Ce();
  return /* @__PURE__ */ E.jsx(
    t.LinkToolbar.Button,
    {
      className: "bn-button",
      mainTooltip: n.link_toolbar.open.tooltip,
      label: n.link_toolbar.open.tooltip,
      isSelected: !1,
      onClick: () => {
        window.open(dh(e.url, window.location.href), "_blank");
      },
      icon: /* @__PURE__ */ E.jsx(dW, {})
    }
  );
}, FW = (e) => {
  const t = ne();
  return /* @__PURE__ */ E.jsx(t.LinkToolbar.Root, { className: "bn-toolbar bn-link-toolbar", children: e.children || /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(
      $W,
      {
        url: e.url,
        text: e.text,
        range: e.range,
        setToolbarOpen: e.setToolbarOpen,
        setToolbarPositionFrozen: e.setToolbarPositionFrozen
      }
    ),
    /* @__PURE__ */ E.jsx(HW, { url: e.url }),
    /* @__PURE__ */ E.jsx(
      BW,
      {
        range: e.range,
        setToolbarOpen: e.setToolbarOpen
      }
    )
  ] }) });
}, UW = (e) => {
  const t = ae(), [n, r] = fe(!1), [o, i] = fe(!1), s = Fe(Ea), [a, l] = fe(void 0);
  ie(() => {
    const f = () => {
      const y = s.getLinkAtSelection();
      if (!y) {
        l(void 0), o || r(!1);
        return;
      }
      l({
        cursorType: "text",
        url: y.mark.attrs.href,
        text: y.text,
        range: y.range,
        element: s.getLinkElementAtPos(y.range.from)
      }), o || r(!0);
    }, h = (y) => {
      if (a !== void 0 && a.cursorType === "text" || !(y.target instanceof HTMLElement))
        return;
      const k = s.getLinkAtElement(y.target);
      k && l({
        cursorType: "mouse",
        url: k.mark.attrs.href,
        text: k.text,
        range: k.range,
        element: s.getLinkElementAtPos(k.range.from)
      });
    }, p = t.onChange(f), m = t.onSelectionChange(f), b = t.domElement;
    return b == null || b.addEventListener("mouseover", h), () => {
      p(), m(), b == null || b.removeEventListener("mouseover", h);
    };
  }, [t, t.domElement, s, a, o]);
  const c = Me(
    () => {
      var f, h, p;
      return {
        ...e.floatingUIOptions,
        useFloatingOptions: {
          open: n,
          onOpenChange: (m, b, y) => {
            o || a !== void 0 && a.cursorType === "text" && y === "hover" || (y === "escape-key" && t.focus(), r(m));
          },
          placement: "top-start",
          middleware: [Ln(10), Hr()],
          ...(f = e.floatingUIOptions) == null ? void 0 : f.useFloatingOptions
        },
        useHoverProps: {
          // `useHover` hook only enabled when a link is hovered with the
          // mouse.
          enabled: a !== void 0 && a.cursorType === "mouse",
          delay: {
            open: 250,
            close: 250
          },
          handleClose: mV(),
          ...(h = e.floatingUIOptions) == null ? void 0 : h.useHoverProps
        },
        elementProps: {
          style: {
            zIndex: 50
          },
          ...(p = e.floatingUIOptions) == null ? void 0 : p.elementProps
        }
      };
    },
    [t, a, e.floatingUIOptions, n, o]
  ), u = Me(
    () => a != null && a.element ? { element: a.element } : void 0,
    [a == null ? void 0 : a.element]
  );
  if (!t.isEditable)
    return null;
  const d = e.linkToolbar || FW;
  return /* @__PURE__ */ E.jsx(hr, { reference: u, ...c, children: a && /* @__PURE__ */ E.jsx(
    d,
    {
      url: a.url,
      text: a.text,
      range: a.range,
      setToolbarOpen: r,
      setToolbarPositionFrozen: i
    }
  ) });
};
function jW(e) {
  return re({ attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8Z" }, child: [] }, { tag: "path", attr: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8Z" }, child: [] }] })(e);
}
const VW = () => {
  const e = ne(), t = Ce(), n = ae(), r = Fe(Rn), o = Ke(Zn, {
    editor: n,
    selector: (s) => s == null ? void 0 : s.block
  }), i = Z(() => {
    if (o === void 0)
      return;
    const s = o.content;
    if (s !== void 0 && Array.isArray(s) && s.length === 0)
      n.setTextCursorPosition(o), r.openSuggestionMenu("/");
    else {
      const a = n.insertBlocks(
        [{ type: "paragraph" }],
        o,
        "after"
      )[0];
      n.setTextCursorPosition(a), r.openSuggestionMenu("/");
    }
  }, [o, n, r]);
  return o === void 0 ? null : /* @__PURE__ */ E.jsx(
    e.SideMenu.Button,
    {
      className: "bn-button",
      label: t.side_menu.add_block_label,
      icon: /* @__PURE__ */ E.jsx(jW, { size: 24, onClick: i, "data-test": "dragHandleAdd" })
    }
  );
};
function Zx(e) {
  return re({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0V0z" }, child: [] }, { tag: "path", attr: { d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" }, child: [] }] })(e);
}
function zW(e) {
  return re({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0z" }, child: [] }, { tag: "path", attr: { d: "m7 10 5 5 5-5z" }, child: [] }] })(e);
}
const qW = (e) => {
  const t = ne(), n = ae(), r = Ke(Zn, {
    editor: n,
    selector: (o) => o == null ? void 0 : o.block
  });
  return r === void 0 || !on(r, n, r.type, {
    textColor: "string"
  }) && !on(r, n, r.type, {
    backgroundColor: "string"
  }) ? null : /* @__PURE__ */ E.jsxs(t.Generic.Menu.Root, { position: "right", sub: !0, children: [
    /* @__PURE__ */ E.jsx(t.Generic.Menu.Trigger, { sub: !0, children: /* @__PURE__ */ E.jsx(
      t.Generic.Menu.Item,
      {
        className: "bn-menu-item",
        subTrigger: !0,
        children: e.children
      }
    ) }),
    /* @__PURE__ */ E.jsx(
      t.Generic.Menu.Dropdown,
      {
        sub: !0,
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: /* @__PURE__ */ E.jsx(
          bu,
          {
            iconSize: 18,
            text: on(r, n, r.type, {
              textColor: "string"
            }) && rt(n, r.type, {
              textColor: "string"
            }) ? {
              color: r.props.textColor,
              setColor: (o) => n.updateBlock(r, {
                type: r.type,
                props: { textColor: o }
              })
            } : void 0,
            background: on(r, n, r.type, {
              backgroundColor: "string"
            }) && rt(n, r.type, {
              backgroundColor: "string"
            }) ? {
              color: r.props.backgroundColor,
              setColor: (o) => n.updateBlock(r, {
                props: { backgroundColor: o }
              })
            } : void 0
          }
        )
      }
    )
  ] });
}, WW = (e) => {
  const t = ne(), n = ae(), r = Ke(Zn, {
    editor: n,
    selector: (o) => o == null ? void 0 : o.block
  });
  return r === void 0 ? null : /* @__PURE__ */ E.jsx(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      onClick: () => n.removeBlocks([r]),
      children: e.children
    }
  );
}, GW = (e) => {
  const t = ne(), n = ae(), r = Ke(Zn, {
    editor: n,
    selector: (i) => i == null ? void 0 : i.block
  });
  if (r === void 0 || r.type !== "table" || !n.settings.tables.headers)
    return null;
  const o = !!r.content.headerRows;
  return /* @__PURE__ */ E.jsx(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      checked: o,
      onClick: () => {
        n.updateBlock(r, {
          content: {
            ...r.content,
            headerRows: o ? void 0 : 1
          }
        });
      },
      children: e.children
    }
  );
}, YW = (e) => {
  const t = ne(), n = ae(), r = Ke(Zn, {
    editor: n,
    selector: (i) => i == null ? void 0 : i.block
  });
  if (r === void 0 || r.type !== "table" || !n.settings.tables.headers)
    return null;
  const o = !!r.content.headerCols;
  return /* @__PURE__ */ E.jsx(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      checked: o,
      onClick: () => {
        n.updateBlock(r, {
          content: {
            ...r.content,
            headerCols: o ? void 0 : 1
          }
        });
      },
      children: e.children
    }
  );
}, KW = (e) => {
  const t = ne(), n = Ce();
  return /* @__PURE__ */ E.jsx(
    t.Generic.Menu.Dropdown,
    {
      className: "bn-menu-dropdown bn-drag-handle-menu",
      children: e.children || /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        /* @__PURE__ */ E.jsx(WW, { children: n.drag_handle.delete_menuitem }),
        /* @__PURE__ */ E.jsx(qW, { children: n.drag_handle.colors_menuitem }),
        /* @__PURE__ */ E.jsx(GW, { children: n.drag_handle.header_row_menuitem }),
        /* @__PURE__ */ E.jsx(YW, { children: n.drag_handle.header_column_menuitem })
      ] })
    }
  );
}, QW = (e) => {
  const t = ne(), n = Ce(), r = Fe(Zn), o = Ke(Zn, {
    selector: (s) => s == null ? void 0 : s.block
  });
  if (o === void 0)
    return null;
  const i = e.dragHandleMenu || KW;
  return /* @__PURE__ */ E.jsxs(
    t.Generic.Menu.Root,
    {
      onOpenChange: (s) => {
        s ? r.freezeMenu() : r.unfreezeMenu();
      },
      position: "left",
      children: [
        /* @__PURE__ */ E.jsx(t.Generic.Menu.Trigger, { children: /* @__PURE__ */ E.jsx(
          t.SideMenu.Button,
          {
            label: n.side_menu.drag_handle_label,
            draggable: !0,
            onDragStart: (s) => r.blockDragStart(s, o),
            onDragEnd: r.blockDragEnd,
            className: "bn-button",
            icon: /* @__PURE__ */ E.jsx(Zx, { size: 24, "data-test": "dragHandle" })
          }
        ) }),
        /* @__PURE__ */ E.jsx(i, { children: e.children })
      ]
    }
  );
}, ZW = (e) => {
  const t = ne(), n = ae(), r = Ke(Zn, {
    editor: n,
    selector: (i) => i == null ? void 0 : i.block
  }), o = Me(() => {
    var i;
    if (r === void 0)
      return {};
    const s = {
      "data-block-type": r.type
    };
    return r.type === "heading" && (s["data-level"] = r.props.level.toString()), (i = n.schema.blockSpecs[r.type].implementation.meta) != null && i.fileBlockAccept && (r.props.url ? s["data-url"] = "true" : s["data-url"] = "false"), s;
  }, [r, n.schema.blockSpecs]);
  return /* @__PURE__ */ E.jsx(t.SideMenu.Root, { className: "bn-side-menu", ...o, children: e.children || /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(VW, {}),
    /* @__PURE__ */ E.jsx(QW, { dragHandleMenu: e.dragHandleMenu })
  ] }) });
}, XW = (e) => {
  const t = Ke(Zn, {
    selector: (s) => s !== void 0 ? {
      show: s.show,
      block: s.block
    } : void 0
  }), { show: n, block: r } = t || {}, o = Me(
    () => {
      var s, a, l;
      return {
        ...e.floatingUIOptions,
        useFloatingOptions: {
          open: n,
          placement: "left-start",
          ...(s = e.floatingUIOptions) == null ? void 0 : s.useFloatingOptions
        },
        useDismissProps: {
          enabled: !1,
          ...(a = e.floatingUIOptions) == null ? void 0 : a.useDismissProps
        },
        elementProps: {
          style: {
            zIndex: 20
          },
          ...(l = e.floatingUIOptions) == null ? void 0 : l.elementProps
        }
      };
    },
    [e.floatingUIOptions, n]
  ), i = e.sideMenu || ZW;
  return /* @__PURE__ */ E.jsx(Ox, { blockId: n ? r == null ? void 0 : r.id : void 0, ...o, children: (r == null ? void 0 : r.id) && /* @__PURE__ */ E.jsx(i, {}) });
};
async function JW(e, t) {
  return (await Ij(e, t)).map(
    ({ id: n, onItemClick: r }) => ({
      id: n,
      onItemClick: r,
      icon: n
    })
  );
}
function eG(e) {
  const t = ne(), n = Ce(), { items: r, loadingState: o, selectedIndex: i, onItemClick: s, columns: a } = e, l = o === "loading-initial" || o === "loading" ? /* @__PURE__ */ E.jsx(
    t.GridSuggestionMenu.Loader,
    {
      className: "bn-grid-suggestion-menu-loader",
      columns: a
    }
  ) : null, c = Me(() => {
    const u = [];
    for (let d = 0; d < r.length; d++) {
      const f = r[d];
      u.push(
        /* @__PURE__ */ E.jsx(
          t.GridSuggestionMenu.Item,
          {
            className: "bn-grid-suggestion-menu-item",
            item: f,
            id: `bn-grid-suggestion-menu-item-${d}`,
            isSelected: d === i,
            onClick: () => s == null ? void 0 : s(f)
          },
          f.id
        )
      );
    }
    return u;
  }, [t, r, s, i]);
  return /* @__PURE__ */ E.jsxs(
    t.GridSuggestionMenu.Root,
    {
      id: "bn-grid-suggestion-menu",
      columns: a,
      className: "bn-grid-suggestion-menu",
      children: [
        l,
        c,
        c.length === 0 && e.loadingState === "loaded" && /* @__PURE__ */ E.jsx(
          t.GridSuggestionMenu.EmptyItem,
          {
            className: "bn-grid-suggestion-menu-empty-item",
            columns: a,
            children: n.suggestion_menu.no_items_title
          }
        )
      ]
    }
  );
}
function Xx(e, t, n, r = 3) {
  const o = Ae(0);
  ie(() => {
    t !== void 0 && (e.length > 0 ? o.current = t.length : t.length - o.current > r && n());
  }, [n, r, e.length, t]);
}
function Jx(e, t) {
  const [n, r] = fe([]), [o, i] = fe(!1), s = Ae(void 0), a = Ae(void 0);
  return ie(() => {
    const l = e;
    s.current = e, i(!0), t(e).then((c) => {
      s.current === l && (r(c), i(!1), a.current = l);
    });
  }, [e, t]), {
    items: n || [],
    // The query that was used to retrieve the last set of items may not be the
    // same as the current query as the items from the current query may not
    // have been retrieved yet. This is useful when using the returns of this
    // hook in other hooks.
    usedQuery: a.current,
    loadingState: a.current === void 0 ? "loading-initial" : o ? "loading" : "loaded"
  };
}
function tG(e, t, n, r, o) {
  const [i, s] = fe(0), a = r !== void 0 && r > 1;
  return ie(() => {
    const l = (u) => (u.key === "ArrowLeft" && (u.preventDefault(), n.length && s((i - 1 + n.length) % n.length)), u.key === "ArrowRight" && (u.preventDefault(), n.length && s((i + 1 + n.length) % n.length)), u.key === "ArrowUp" ? (u.preventDefault(), n.length && s(
      (i - r + n.length) % n.length
    ), !0) : u.key === "ArrowDown" ? (u.preventDefault(), n.length && s((i + r) % n.length), !0) : u.key === "Enter" && !u.isComposing ? (u.stopPropagation(), u.preventDefault(), n.length && (o == null || o(n[i])), !0) : !1), c = e.domElement;
    return c == null || c.addEventListener("keydown", l, !0), () => {
      c == null || c.removeEventListener(
        "keydown",
        l,
        !0
      );
    };
  }, [e.domElement, n, i, o, r, a]), ie(() => {
    s(0);
  }, [t]), {
    selectedIndex: n.length === 0 ? void 0 : i
  };
}
function nG(e) {
  const t = rr().setContentEditableProps, n = ae(), {
    getItems: r,
    gridSuggestionMenuComponent: o,
    query: i,
    clearQuery: s,
    closeMenu: a,
    onItemClick: l,
    columns: c
  } = e, u = Z(
    (m) => {
      a(), s(), l == null || l(m);
    },
    [l, a, s]
  ), { items: d, usedQuery: f, loadingState: h } = Jx(
    i,
    r
  );
  Xx(d, f, a);
  const { selectedIndex: p } = tG(
    n,
    i,
    d,
    c,
    u
  );
  return ie(() => (t((m) => ({
    ...m,
    "aria-expanded": !0,
    "aria-controls": "bn-suggestion-menu"
  })), () => {
    t((m) => ({
      ...m,
      "aria-expanded": !1,
      "aria-controls": void 0
    }));
  }), [t]), ie(() => (t((m) => ({
    ...m,
    "aria-activedescendant": p ? "bn-suggestion-menu-item-" + p : void 0
  })), () => {
    t((m) => ({
      ...m,
      "aria-activedescendant": void 0
    }));
  }), [t, p]), /* @__PURE__ */ E.jsx(
    o,
    {
      items: d,
      onItemClick: u,
      loadingState: h,
      selectedIndex: p,
      columns: c
    }
  );
}
function rG(e) {
  const t = ae(), {
    triggerCharacter: n,
    gridSuggestionMenuComponent: r,
    columns: o,
    minQueryLength: i,
    onItemClick: s,
    getItems: a
  } = e, l = Me(() => s || ((p) => {
    p.onItemClick(t);
  }), [t, s]), c = Me(() => a || (async (p) => await JW(
    t,
    p
  )), [t, a]), u = Fe(Rn);
  ie(() => {
    u.addTriggerCharacter(n);
  }, [u, n]);
  const d = Ke(Rn), f = Ke(Rn, {
    selector: (p) => {
      var m;
      return {
        // Use first child as the editor DOM element may itself be scrollable.
        // For FloatingUI to auto-update the position during scrolling, the
        // `contextElement` must be a descendant of the scroll container.
        element: ((m = t.domElement) == null ? void 0 : m.firstChild) || void 0,
        getBoundingClientRect: () => (p == null ? void 0 : p.referencePos) || new DOMRect()
      };
    }
  }), h = Me(
    () => {
      var p, m;
      return {
        ...e.floatingUIOptions,
        useFloatingOptions: {
          open: (d == null ? void 0 : d.show) && (d == null ? void 0 : d.triggerCharacter) === n,
          onOpenChange: (b) => {
            b || u.closeMenu();
          },
          placement: "bottom-start",
          middleware: [
            Ln(10),
            // Flips the menu placement to maximize the space available, and prevents
            // the menu from being cut off by the confines of the screen.
            Py({
              allowedPlacements: ["bottom-start", "top-start"],
              padding: 10
            }),
            mo(),
            Is({
              apply({ elements: b, availableHeight: y }) {
                b.floating.style.maxHeight = `${Math.max(0, y)}px`;
              },
              padding: 10
            })
          ],
          ...(p = e.floatingUIOptions) == null ? void 0 : p.useFloatingOptions
        },
        elementProps: {
          // Prevents editor blurring when clicking the scroll bar.
          onMouseDownCapture: (b) => b.preventDefault(),
          style: {
            zIndex: 70
          },
          ...(m = e.floatingUIOptions) == null ? void 0 : m.elementProps
        }
      };
    },
    [
      e.floatingUIOptions,
      d == null ? void 0 : d.show,
      d == null ? void 0 : d.triggerCharacter,
      u,
      n
    ]
  );
  return !d || !d.ignoreQueryLength && i && (d.query.startsWith(" ") || d.query.length < i) ? null : /* @__PURE__ */ E.jsx(hr, { reference: f, ...h, children: n && /* @__PURE__ */ E.jsx(
    nG,
    {
      query: d.query,
      closeMenu: u.closeMenu,
      clearQuery: u.clearQuery,
      getItems: c,
      columns: o,
      gridSuggestionMenuComponent: r || eG,
      onItemClick: l
    }
  ) });
}
function oG(e) {
  const t = ne(), n = Ce(), { items: r, loadingState: o, selectedIndex: i, onItemClick: s } = e, a = o === "loading-initial" || o === "loading" ? /* @__PURE__ */ E.jsx(
    t.SuggestionMenu.Loader,
    {
      className: "bn-suggestion-menu-loader"
    }
  ) : null, l = Me(() => {
    let c;
    const u = [];
    for (let d = 0; d < r.length; d++) {
      const f = r[d];
      f.group !== c && (c = f.group, u.push(
        /* @__PURE__ */ E.jsx(
          t.SuggestionMenu.Label,
          {
            className: "bn-suggestion-menu-label",
            children: c
          },
          c
        )
      )), u.push(
        /* @__PURE__ */ E.jsx(
          t.SuggestionMenu.Item,
          {
            className: dt(
              "bn-suggestion-menu-item",
              f.size === "small" ? "bn-suggestion-menu-item-small" : ""
            ),
            item: f,
            id: `bn-suggestion-menu-item-${d}`,
            isSelected: d === i,
            onClick: () => s == null ? void 0 : s(f)
          },
          f.title
        )
      );
    }
    return u;
  }, [t, r, s, i]);
  return /* @__PURE__ */ E.jsxs(
    t.SuggestionMenu.Root,
    {
      id: "bn-suggestion-menu",
      className: "bn-suggestion-menu",
      children: [
        l,
        l.length === 0 && (e.loadingState === "loading" || e.loadingState === "loaded") && /* @__PURE__ */ E.jsx(
          t.SuggestionMenu.EmptyItem,
          {
            className: "bn-suggestion-menu-item",
            children: n.suggestion_menu.no_items_title
          }
        ),
        a
      ]
    }
  );
}
function iG(e, t) {
  const [n, r] = fe(0);
  return {
    selectedIndex: n,
    setSelectedIndex: r,
    handler: (o) => {
      if (o.key === "ArrowUp")
        return o.preventDefault(), e.length && r((n - 1 + e.length) % e.length), !0;
      if (o.key === "ArrowDown")
        return o.preventDefault(), e.length && r((n + 1) % e.length), !0;
      if (o.key === "PageUp")
        return o.preventDefault(), e.length && r(0), !0;
      if (o.key === "PageDown")
        return o.preventDefault(), e.length && r(e.length - 1), !0;
      const i = sG(o) ? o.nativeEvent.isComposing : o.isComposing;
      return o.key === "Enter" && !i ? (o.preventDefault(), o.stopPropagation(), e.length && (t == null || t(e[n])), !0) : !1;
    }
  };
}
function sG(e) {
  return e.nativeEvent !== void 0;
}
function aG(e, t, n, r, o) {
  const { selectedIndex: i, setSelectedIndex: s, handler: a } = iG(n, r);
  return ie(() => {
    const l = e.domElement;
    return l == null || l.addEventListener("keydown", a, !0), () => {
      l == null || l.removeEventListener("keydown", a, !0);
    };
  }, [e.domElement, n, i, r, o, a]), ie(() => {
    s(0);
  }, [t, s]), {
    selectedIndex: n.length === 0 ? void 0 : i
  };
}
function lG(e) {
  const t = rr().setContentEditableProps, n = ae(), {
    getItems: r,
    suggestionMenuComponent: o,
    query: i,
    clearQuery: s,
    closeMenu: a,
    onItemClick: l
  } = e, c = Z(
    (p) => {
      a(), s(), l == null || l(p);
    },
    [l, a, s]
  ), { items: u, usedQuery: d, loadingState: f } = Jx(
    i,
    r
  );
  Xx(u, d, a);
  const { selectedIndex: h } = aG(
    n,
    i,
    u,
    c
  );
  return ie(() => (t((p) => ({
    ...p,
    "aria-expanded": !0,
    "aria-controls": "bn-suggestion-menu"
  })), () => {
    t((p) => ({
      ...p,
      "aria-expanded": !1,
      "aria-controls": void 0
    }));
  }), [t]), ie(() => (t((p) => ({
    ...p,
    "aria-activedescendant": h ? "bn-suggestion-menu-item-" + h : void 0
  })), () => {
    t((p) => ({
      ...p,
      "aria-activedescendant": void 0
    }));
  }), [t, h]), /* @__PURE__ */ E.jsx(
    o,
    {
      items: u,
      onItemClick: c,
      loadingState: f,
      selectedIndex: h
    }
  );
}
const cG = {
  heading: hc,
  heading_2: pc,
  heading_3: mc,
  heading_4: $x,
  heading_5: Hx,
  heading_6: Fx,
  toggle_heading: hc,
  toggle_heading_2: pc,
  toggle_heading_3: mc,
  quote: qx,
  toggle_list: Wx,
  numbered_list: Vx,
  bullet_list: zx,
  check_list: jx,
  paragraph: sm,
  table: Jq,
  image: nW,
  video: tW,
  audio: iW,
  file: Hq,
  emoji: pW,
  code_block: qq,
  divider: hW
};
function uG(e) {
  return sL(e).map((t) => {
    const n = cG[t.key];
    return {
      ...t,
      icon: /* @__PURE__ */ E.jsx(n, { size: 18 })
    };
  });
}
function dG(e) {
  const t = ae(), {
    triggerCharacter: n,
    suggestionMenuComponent: r,
    minQueryLength: o,
    onItemClick: i,
    getItems: s
  } = e, a = Me(() => i || ((h) => {
    h.onItemClick(t);
  }), [t, i]), l = Me(() => s || (async (h) => aL(
    uG(t),
    h
  )), [t, s]), c = Fe(Rn);
  ie(() => {
    c.addTriggerCharacter(n);
  }, [c, n]);
  const u = Ke(Rn), d = Ke(Rn, {
    selector: (h) => {
      var p;
      return {
        // Use first child as the editor DOM element may itself be scrollable.
        // For FloatingUI to auto-update the position during scrolling, the
        // `contextElement` must be a descendant of the scroll container.
        element: ((p = t.domElement) == null ? void 0 : p.firstChild) || void 0,
        getBoundingClientRect: () => (h == null ? void 0 : h.referencePos) || new DOMRect()
      };
    }
  }), f = Me(
    () => {
      var h, p;
      return {
        ...e.floatingUIOptions,
        useFloatingOptions: {
          open: (u == null ? void 0 : u.show) && (u == null ? void 0 : u.triggerCharacter) === n,
          onOpenChange: (m) => {
            m || c.closeMenu();
          },
          placement: "bottom-start",
          middleware: [
            Ln(10),
            // Flips the menu placement to maximize the space available, and prevents
            // the menu from being cut off by the confines of the screen.
            Py({
              allowedPlacements: ["bottom-start", "top-start"],
              padding: 10
            }),
            mo(),
            Is({
              apply({ elements: m, availableHeight: b }) {
                m.floating.style.maxHeight = `${Math.max(0, b)}px`;
              },
              padding: 10
            })
          ],
          ...(h = e.floatingUIOptions) == null ? void 0 : h.useFloatingOptions
        },
        elementProps: {
          // Prevents editor blurring when clicking the scroll bar.
          onMouseDownCapture: (m) => m.preventDefault(),
          style: {
            zIndex: 80
          },
          ...(p = e.floatingUIOptions) == null ? void 0 : p.elementProps
        }
      };
    },
    [
      e.floatingUIOptions,
      u == null ? void 0 : u.show,
      u == null ? void 0 : u.triggerCharacter,
      c,
      n
    ]
  );
  return !u || !u.ignoreQueryLength && o && (u.query.startsWith(" ") || u.query.length < o) ? null : /* @__PURE__ */ E.jsx(hr, { reference: d, ...f, children: n && /* @__PURE__ */ E.jsx(
    lG,
    {
      query: u.query,
      closeMenu: c.closeMenu,
      clearQuery: c.clearQuery,
      getItems: l,
      suggestionMenuComponent: r || oG,
      onItemClick: a
    }
  ) });
}
const fG = (e, t = 0.3) => {
  const n = Math.floor(e) + t, r = Math.ceil(e) - t;
  return e >= n && e <= r ? Math.round(e) : e < n ? Math.floor(e) : Math.ceil(e);
}, hG = (e) => {
  const t = ne(), n = ae(), r = Fe(tt), o = Ke(tt, {
    selector: (u) => u == null ? void 0 : u.block
  }), i = Ae(!1), [s, a] = fe(), l = Z(
    (u) => {
      r.freezeHandles(), e.hideOtherElements(!0), o && (a({
        originalContent: o.content,
        originalCroppedContent: {
          rows: r.cropEmptyRowsOrColumns(
            o,
            e.orientation === "addOrRemoveColumns" ? "columns" : "rows"
          )
        },
        startPos: e.orientation === "addOrRemoveColumns" ? u.clientX : u.clientY
      }), i.current = !1, u.preventDefault());
    },
    [o, e, r]
  ), c = Z(() => {
    !o || i.current || n.updateBlock(o, {
      type: "table",
      content: {
        ...o.content,
        rows: e.orientation === "addOrRemoveColumns" ? r.addRowsOrColumns(o, "columns", 1) : r.addRowsOrColumns(o, "rows", 1)
      }
    });
  }, [o, n, e.orientation, r]);
  return ie(() => {
    const u = (d) => {
      var f, h;
      if (!o)
        return;
      if (!s)
        throw new Error("editingState is undefined");
      i.current = !0;
      const p = (e.orientation === "addOrRemoveColumns" ? d.clientX : d.clientY) - s.startPos, m = e.orientation === "addOrRemoveColumns" ? ((f = s.originalCroppedContent.rows[0]) == null ? void 0 : f.cells.length) ?? 0 : s.originalCroppedContent.rows.length, b = e.orientation === "addOrRemoveColumns" ? ((h = s.originalContent.rows[0]) == null ? void 0 : h.cells.length) ?? 0 : s.originalContent.rows.length, y = e.orientation === "addOrRemoveColumns" ? o.content.rows[0].cells.length : o.content.rows.length, k = b + fG(
        p / (e.orientation === "addOrRemoveColumns" ? nu : j6),
        0.3
      );
      k >= m && k > 0 && k !== y && (n.updateBlock(o, {
        type: "table",
        content: {
          ...o.content,
          rows: e.orientation === "addOrRemoveColumns" ? r.addRowsOrColumns(
            {
              type: "table",
              content: s.originalCroppedContent
            },
            "columns",
            k - m
          ) : r.addRowsOrColumns(
            {
              type: "table",
              content: s.originalCroppedContent
            },
            "rows",
            k - m
          )
        }
      }), o.content && n.setTextCursorPosition(o));
    };
    return s && window.addEventListener("mousemove", u), () => {
      window.removeEventListener("mousemove", u);
    };
  }, [o, s, n, e.orientation, r]), ie(() => {
    const u = () => {
      e.hideOtherElements(!1), r.unfreezeHandles(), a(void 0);
    };
    return s && window.addEventListener("mouseup", u), () => {
      window.removeEventListener("mouseup", u);
    };
  }, [s, e, r]), n.isEditable ? /* @__PURE__ */ E.jsx(
    t.TableHandle.ExtendButton,
    {
      className: dt(
        "bn-extend-button",
        e.orientation === "addOrRemoveColumns" ? "bn-extend-button-add-remove-columns" : "bn-extend-button-add-remove-rows",
        s !== null ? "bn-extend-button-editing" : ""
      ),
      onClick: c,
      onMouseDown: l,
      children: e.children || /* @__PURE__ */ E.jsx(sW, { size: 18, "data-test": "extendButton" })
    }
  ) : null;
}, Db = (e) => {
  const t = ne(), n = Ce(), r = Fe(tt), o = Ke(tt, {
    selector: (i) => e.orientation === "column" ? i == null ? void 0 : i.colIndex : i == null ? void 0 : i.rowIndex
  });
  return r === void 0 || o === void 0 ? null : /* @__PURE__ */ E.jsx(
    t.Generic.Menu.Item,
    {
      onClick: () => {
        r.addRowOrColumn(
          o,
          e.orientation === "row" ? { orientation: "row", side: e.side } : { orientation: "column", side: e.side }
        );
      },
      children: n.table_handle[`add_${e.side}_menuitem`]
    }
  );
}, pG = (e) => {
  const t = ne(), n = Ce(), r = Fe(tt), o = Ke(tt, {
    selector: (i) => e.orientation === "column" ? i == null ? void 0 : i.colIndex : i == null ? void 0 : i.rowIndex
  });
  return r === void 0 || o === void 0 ? null : /* @__PURE__ */ E.jsx(
    t.Generic.Menu.Item,
    {
      onClick: () => r.removeRowOrColumn(o, e.orientation),
      children: e.orientation === "row" ? n.table_handle.delete_row_menuitem : n.table_handle.delete_column_menuitem
    }
  );
}, mG = (e) => {
  const t = ne(), n = Ce(), r = ae(), o = Fe(tt), { block: i, index: s } = Ke(tt, {
    selector: (u) => ({
      block: u == null ? void 0 : u.block,
      index: e.orientation === "column" ? u == null ? void 0 : u.colIndex : u == null ? void 0 : u.rowIndex
    })
  }), a = Me(() => o === void 0 || i === void 0 || s === void 0 ? [] : e.orientation === "row" ? o.getCellsAtRowHandle(i, s) : o.getCellsAtColumnHandle(i, s), [i, s, e.orientation, o]), l = (u, d) => {
    if (i === void 0)
      return;
    const f = i.content.rows.map((h) => ({
      ...h,
      cells: h.cells.map((p) => oo(p))
    }));
    a.forEach(({ row: h, col: p }) => {
      d === "text" ? f[h].cells[p].props.textColor = u : f[h].cells[p].props.backgroundColor = u;
    }), r.updateBlock(i, {
      type: "table",
      content: {
        ...i.content,
        rows: f
      }
    }), r.setTextCursorPosition(i);
  };
  if (!a || !a[0] || !o || r.settings.tables.cellTextColor === !1 && r.settings.tables.cellBackgroundColor === !1)
    return null;
  const c = oo(a[0].cell);
  return /* @__PURE__ */ E.jsxs(t.Generic.Menu.Root, { position: "right", sub: !0, children: [
    /* @__PURE__ */ E.jsx(t.Generic.Menu.Trigger, { sub: !0, children: /* @__PURE__ */ E.jsx(
      t.Generic.Menu.Item,
      {
        className: "bn-menu-item",
        subTrigger: !0,
        children: e.children || n.drag_handle.colors_menuitem
      }
    ) }),
    /* @__PURE__ */ E.jsx(
      t.Generic.Menu.Dropdown,
      {
        sub: !0,
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: /* @__PURE__ */ E.jsx(
          bu,
          {
            iconSize: 18,
            text: r.settings.tables.cellTextColor ? {
              // All cells have the same text color
              color: a.every(
                ({ cell: u }) => io(u) && u.props.textColor === c.props.textColor
              ) ? c.props.textColor : "default",
              setColor: (u) => {
                l(u, "text");
              }
            } : void 0,
            background: r.settings.tables.cellBackgroundColor ? {
              color: a.every(
                ({ cell: u }) => io(u) && u.props.backgroundColor === c.props.backgroundColor
              ) ? c.props.backgroundColor : "default",
              setColor: (u) => l(u, "background")
            } : void 0
          }
        )
      }
    )
  ] });
}, gG = (e) => {
  const t = ne(), n = Ce(), r = ae(), o = Fe(tt), { block: i, index: s } = Ke(tt, {
    selector: (l) => ({
      block: l == null ? void 0 : l.block,
      index: e.orientation === "column" ? l == null ? void 0 : l.colIndex : l == null ? void 0 : l.rowIndex
    })
  });
  if (o === void 0 || i === void 0 || s !== 0 || e.orientation !== "row" || !r.settings.tables.headers)
    return null;
  const a = !!i.content.headerRows;
  return /* @__PURE__ */ E.jsx(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      checked: a,
      onClick: () => {
        r.updateBlock(i, {
          ...i,
          content: {
            ...i.content,
            headerRows: a ? void 0 : 1
          }
        });
      },
      children: n.drag_handle.header_row_menuitem
    }
  );
}, bG = (e) => {
  const t = ne(), n = Ce(), r = ae(), o = Fe(tt), i = Ke(tt, {
    selector: (l) => l == null ? void 0 : l.block
  }), s = Ke(tt, {
    selector: (l) => e.orientation === "column" ? l == null ? void 0 : l.colIndex : l == null ? void 0 : l.rowIndex
  });
  if (!o || s !== 0 || !i || e.orientation !== "column" || !r.settings.tables.headers)
    return null;
  const a = !!i.content.headerCols;
  return /* @__PURE__ */ E.jsx(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      checked: a,
      onClick: () => {
        r.updateBlock(i, {
          ...i,
          content: {
            ...i.content,
            headerCols: a ? void 0 : 1
          }
        });
      },
      children: n.drag_handle.header_column_menuitem
    }
  );
}, yG = (e) => {
  const t = ne();
  return /* @__PURE__ */ E.jsx(t.Generic.Menu.Dropdown, { className: "bn-table-handle-menu", children: e.children || /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(pG, { orientation: e.orientation }),
    /* @__PURE__ */ E.jsx(
      Db,
      {
        orientation: e.orientation,
        side: e.orientation === "row" ? "above" : "left"
      }
    ),
    /* @__PURE__ */ E.jsx(
      Db,
      {
        orientation: e.orientation,
        side: e.orientation === "row" ? "below" : "right"
      }
    ),
    /* @__PURE__ */ E.jsx(gG, { orientation: e.orientation }),
    /* @__PURE__ */ E.jsx(bG, { orientation: e.orientation }),
    /* @__PURE__ */ E.jsx(mG, { orientation: e.orientation })
  ] }) });
}, EG = (e) => {
  const t = ae(), n = ne(), [r, o] = fe(!1), i = e.tableHandleMenu || yG, s = Fe(tt), a = Ke(tt), l = Me(() => !s || !a || !a.block || a.block.type !== "table" ? !1 : e.orientation === "column" ? s.getCellsAtColumnHandle(a.block, a.colIndex).every(({ cell: c }) => Ho(c) === 1) : s.getCellsAtRowHandle(a.block, a.rowIndex).every(({ cell: c }) => Os(c) === 1), [e.orientation, a, s]);
  return a ? /* @__PURE__ */ E.jsxs(
    n.Generic.Menu.Root,
    {
      onOpenChange: (c) => {
        c ? (s.freezeHandles(), e.hideOtherElements(!0)) : (s.unfreezeHandles(), e.hideOtherElements(!1), t.focus());
      },
      position: "right",
      children: [
        /* @__PURE__ */ E.jsx(n.Generic.Menu.Trigger, { children: /* @__PURE__ */ E.jsx(
          n.TableHandle.Root,
          {
            className: dt(
              "bn-table-handle",
              r ? "bn-table-handle-dragging" : "",
              l ? "" : "bn-table-handle-not-draggable"
            ),
            draggable: l,
            onDragStart: (c) => {
              o(!0), e.hideOtherElements(!0), e.orientation === "column" ? s.colDragStart(c) : s.rowDragStart(c);
            },
            onDragEnd: () => {
              s.dragEnd(), e.hideOtherElements(!1), o(!1);
            },
            style: e.orientation === "column" ? { transform: "rotate(0.25turn)" } : void 0,
            children: e.children || /* @__PURE__ */ E.jsx(Zx, { size: 24, "data-test": "tableHandle" })
          }
        ) }),
        /* @__PURE__ */ E.jsx(i, { orientation: e.orientation })
      ]
    }
  ) : null;
}, kG = (e) => {
  var t, n;
  const r = ne(), o = Ce(), i = ae(), { block: s, colIndex: a, rowIndex: l } = Ke(
    tt,
    {
      selector: (d) => ({
        block: d == null ? void 0 : d.block,
        colIndex: d == null ? void 0 : d.colIndex,
        rowIndex: d == null ? void 0 : d.rowIndex
      })
    }
  ), c = (d, f) => {
    if (s === void 0 || a === void 0 || l === void 0)
      return;
    const h = s.content.rows.map((p) => ({
      ...p,
      cells: p.cells.map((m) => oo(m))
    }));
    f === "text" ? h[l].cells[a].props.textColor = d : h[l].cells[a].props.backgroundColor = d, i.updateBlock(s, {
      type: "table",
      content: {
        ...s.content,
        rows: h
      }
    }), i.setTextCursorPosition(s);
  };
  if (s === void 0 || a === void 0 || l === void 0)
    return null;
  const u = (n = (t = s.content.rows[l]) == null ? void 0 : t.cells) == null ? void 0 : n[a];
  return !u || i.settings.tables.cellTextColor === !1 && i.settings.tables.cellBackgroundColor === !1 ? null : /* @__PURE__ */ E.jsxs(r.Generic.Menu.Root, { position: "right", sub: !0, children: [
    /* @__PURE__ */ E.jsx(r.Generic.Menu.Trigger, { sub: !0, children: /* @__PURE__ */ E.jsx(
      r.Generic.Menu.Item,
      {
        className: "bn-menu-item",
        subTrigger: !0,
        children: e.children || o.drag_handle.colors_menuitem
      }
    ) }),
    /* @__PURE__ */ E.jsx(
      r.Generic.Menu.Dropdown,
      {
        sub: !0,
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: /* @__PURE__ */ E.jsx(
          bu,
          {
            iconSize: 18,
            text: i.settings.tables.cellTextColor ? {
              color: io(u) ? u.props.textColor : "default",
              setColor: (d) => c(d, "text")
            } : void 0,
            background: i.settings.tables.cellBackgroundColor ? {
              color: io(u) ? u.props.backgroundColor : "default",
              setColor: (d) => c(d, "background")
            } : void 0
          }
        )
      }
    )
  ] });
}, CG = () => {
  var e, t;
  const n = ne(), r = Ce(), o = ae(), i = Fe(tt), { block: s, colIndex: a, rowIndex: l } = Ke(
    tt,
    {
      selector: (u) => ({
        block: u == null ? void 0 : u.block,
        colIndex: u == null ? void 0 : u.colIndex,
        rowIndex: u == null ? void 0 : u.rowIndex
      })
    }
  );
  if (s === void 0 || a === void 0 || l === void 0)
    return null;
  const c = (t = (e = s.content.rows[l]) == null ? void 0 : e.cells) == null ? void 0 : t[a];
  return !c || !io(c) || Os(c) === 1 && Ho(c) === 1 || !o.settings.tables.splitCells ? null : /* @__PURE__ */ E.jsx(
    n.Generic.Menu.Item,
    {
      onClick: () => {
        i.splitCell({
          row: l,
          col: a
        });
      },
      children: r.table_handle.split_cell_menuitem
    }
  );
}, TG = (e) => {
  const t = ne();
  return /* @__PURE__ */ E.jsx(
    t.Generic.Menu.Dropdown,
    {
      className: "bn-menu-dropdown bn-table-handle-menu",
      children: e.children || /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        /* @__PURE__ */ E.jsx(CG, {}),
        /* @__PURE__ */ E.jsx(kG, {})
      ] })
    }
  );
}, xG = (e) => {
  const t = ne(), n = ae(), r = Fe(tt), o = e.tableCellMenu || TG;
  return !n.settings.tables.splitCells && !n.settings.tables.cellBackgroundColor && !n.settings.tables.cellTextColor ? null : /* @__PURE__ */ E.jsxs(
    t.Generic.Menu.Root,
    {
      onOpenChange: (i) => {
        i ? (r.freezeHandles(), e.hideOtherElements(!0)) : (r.unfreezeHandles(), e.hideOtherElements(!1), n.focus());
      },
      position: "right",
      children: [
        /* @__PURE__ */ E.jsx(t.Generic.Menu.Trigger, { children: /* @__PURE__ */ E.jsx(t.Generic.Menu.Button, { className: "bn-table-cell-handle", children: e.children || /* @__PURE__ */ E.jsx(zW, { size: 12, "data-test": "tableCellHandle" }) }) }),
        /* @__PURE__ */ E.jsx(o, {})
      ]
    }
  );
}, wG = (e) => {
  const t = ae(), [n, r] = fe(), o = Ke(tt), i = Me(() => {
    const u = {};
    if (o === void 0)
      return {};
    const d = Yt(
      o.block.id,
      t.prosemirrorState.doc
    );
    if (!d)
      return {};
    const f = d.posBeforeNode + 1, h = t.prosemirrorView.domAtPos(
      f + 1
    ).node;
    if (!(h instanceof Element))
      return {};
    if (u.tableReference = { element: h }, o.rowIndex === void 0 || o.colIndex === void 0)
      return u;
    const p = t.prosemirrorState.doc.resolve(f + 1).posAtIndex(o.rowIndex), m = t.prosemirrorState.doc.resolve(p + 1).posAtIndex(o.colIndex), b = t.prosemirrorView.domAtPos(m + 1).node;
    return b instanceof Element ? (u.cellReference = { element: b }, u.rowReference = {
      element: h,
      getBoundingClientRect: () => {
        const y = h.getBoundingClientRect(), k = b.getBoundingClientRect();
        return new DOMRect(
          y.x,
          o.draggingState && o.draggingState.draggedCellOrientation === "row" ? o.draggingState.mousePos - k.height / 2 : k.y,
          y.width,
          k.height
        );
      }
    }, u.columnReference = {
      element: h,
      getBoundingClientRect: () => {
        const y = h.getBoundingClientRect(), k = b.getBoundingClientRect();
        return new DOMRect(
          o.draggingState && o.draggingState.draggedCellOrientation === "col" ? o.draggingState.mousePos - k.width / 2 : k.x,
          y.y,
          k.width,
          y.height
        );
      }
    }, u) : {};
  }, [t, o]), s = Me(
    () => o !== void 0 ? {
      rowTableHandle: {
        useFloatingOptions: {
          open: o.show && o.rowIndex !== void 0 && (!n || n === "rowTableHandle"),
          placement: "left",
          middleware: [Ln(-10)]
        },
        elementProps: {
          style: {
            zIndex: 10
          }
        }
      },
      columnTableHandle: {
        useFloatingOptions: {
          open: o.show && o.colIndex !== void 0 && (!n || n === "columnTableHandle"),
          placement: "top",
          middleware: [Ln(-12)]
        },
        elementProps: {
          style: {
            zIndex: 10
          }
        }
      },
      tableCellHandle: {
        useFloatingOptions: {
          open: o.show && o.rowIndex !== void 0 && o.colIndex !== void 0 && (!n || n === "tableCellHandle"),
          placement: "top-end",
          middleware: [Ln({ mainAxis: -15, crossAxis: -1 })]
        },
        elementProps: {
          style: {
            zIndex: 10
          }
        }
      },
      extendRowsButton: {
        useFloatingOptions: {
          open: o.show && o.showAddOrRemoveRowsButton && (!n || n === "extendRowsButton"),
          placement: "bottom",
          middleware: [
            Is({
              apply({ rects: u, elements: d }) {
                Object.assign(d.floating.style, {
                  width: `${u.reference.width}px`
                });
              }
            })
          ]
        },
        elementProps: {
          style: {
            zIndex: 10
          }
        }
      },
      extendColumnsButton: {
        useFloatingOptions: {
          open: o.show && o.showAddOrRemoveColumnsButton && (!n || n === "extendColumnsButton"),
          placement: "right",
          middleware: [
            Is({
              apply({ rects: u, elements: d }) {
                Object.assign(d.floating.style, {
                  height: `${u.reference.height}px`
                });
              }
            })
          ]
        },
        elementProps: {
          style: {
            zIndex: 10
          }
        }
      }
    } : void 0,
    [n, o]
  );
  if (!o)
    return null;
  const a = e.tableHandle || EG, l = e.extendButton || hG, c = e.tableCellHandle || xG;
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(
      hr,
      {
        reference: i == null ? void 0 : i.rowReference,
        ...s == null ? void 0 : s.rowTableHandle,
        children: o.show && o.rowIndex !== void 0 && (!n || n === "rowTableHandle") && /* @__PURE__ */ E.jsx(
          a,
          {
            orientation: "row",
            hideOtherElements: (u) => r(u ? "rowTableHandle" : void 0)
          }
        )
      }
    ),
    /* @__PURE__ */ E.jsx(
      hr,
      {
        reference: i == null ? void 0 : i.columnReference,
        ...s == null ? void 0 : s.columnTableHandle,
        children: o.show && o.colIndex !== void 0 && (!n || n === "columnTableHandle") && /* @__PURE__ */ E.jsx(
          a,
          {
            orientation: "column",
            hideOtherElements: (u) => r(u ? "columnTableHandle" : void 0)
          }
        )
      }
    ),
    /* @__PURE__ */ E.jsx(
      hr,
      {
        reference: i == null ? void 0 : i.cellReference,
        ...s == null ? void 0 : s.tableCellHandle,
        children: o.show && o.rowIndex !== void 0 && o.colIndex !== void 0 && (!n || n === "tableCellHandle") && /* @__PURE__ */ E.jsx(
          c,
          {
            hideOtherElements: (u) => r(u ? "tableCellHandle" : void 0)
          }
        )
      }
    ),
    /* @__PURE__ */ E.jsx(
      hr,
      {
        reference: i == null ? void 0 : i.tableReference,
        ...s == null ? void 0 : s.extendRowsButton,
        children: o.show && o.showAddOrRemoveRowsButton && (!n || n === "extendRowsButton") && /* @__PURE__ */ E.jsx(
          l,
          {
            orientation: "addOrRemoveRows",
            hideOtherElements: (u) => r(u ? "extendRowsButton" : void 0)
          }
        )
      }
    ),
    /* @__PURE__ */ E.jsx(
      hr,
      {
        reference: i == null ? void 0 : i.tableReference,
        ...s == null ? void 0 : s.extendColumnsButton,
        children: o.show && o.showAddOrRemoveColumnsButton && (!n || n === "extendColumnsButton") && /* @__PURE__ */ E.jsx(
          l,
          {
            orientation: "addOrRemoveColumns",
            hideOtherElements: (u) => r(u ? "extendColumnsButton" : void 0)
          }
        )
      }
    )
  ] });
}, vG = $y(
  () => Promise.resolve().then(() => YG)
), SG = $y(
  () => Promise.resolve().then(() => ZG)
);
function _G(e) {
  const t = ae();
  if (!t)
    throw new Error(
      "BlockNoteDefaultUI must be used within a BlockNoteContext.Provider"
    );
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    t.getExtension(ho) && e.formattingToolbar !== !1 && /* @__PURE__ */ E.jsx(Qx, {}),
    t.getExtension(Ea) && e.linkToolbar !== !1 && /* @__PURE__ */ E.jsx(UW, {}),
    t.getExtension(Rn) && e.slashMenu !== !1 && /* @__PURE__ */ E.jsx(dG, { triggerCharacter: "/" }),
    t.getExtension(Rn) && e.emojiPicker !== !1 && /* @__PURE__ */ E.jsx(
      rG,
      {
        triggerCharacter: ":",
        columns: 10,
        minQueryLength: 2
      }
    ),
    t.getExtension(Zn) && e.sideMenu !== !1 && /* @__PURE__ */ E.jsx(XW, {}),
    t.getExtension(zn) && e.filePanel !== !1 && /* @__PURE__ */ E.jsx(yq, {}),
    t.getExtension(tt) && e.tableHandles !== !1 && /* @__PURE__ */ E.jsx(wG, {}),
    t.getExtension($n) && e.comments !== !1 && /* @__PURE__ */ E.jsxs(Hv, { children: [
      /* @__PURE__ */ E.jsx(vG, {}),
      /* @__PURE__ */ E.jsx(SG, {})
    ] })
  ] });
}
function AG(e, t) {
  const n = rr();
  t || (t = n == null ? void 0 : n.editor), ie(() => {
    if (!t)
      throw new Error(
        "'editor' is required, either from BlockNoteContext or as a function argument"
      );
    return t.onChange(e);
  }, [e, t]);
}
function IG(e, t, n) {
  const r = rr();
  t || (t = r == null ? void 0 : r.editor), ie(() => {
    if (!t)
      throw new Error(
        "'editor' is required, either from BlockNoteContext or as a function argument"
      );
    return t.onSelectionChange(e, n);
  }, [e, t, n]);
}
const ew = () => {
  const e = Me(
    () => {
      var s;
      return (s = window.matchMedia) == null ? void 0 : s.call(window, "(prefers-color-scheme: dark)");
    },
    []
  ), t = Me(
    () => {
      var s;
      return (s = window.matchMedia) == null ? void 0 : s.call(window, "(prefers-color-scheme: light)");
    },
    []
  ), n = e == null ? void 0 : e.matches, r = t == null ? void 0 : t.matches, [o, i] = fe(n ? "dark" : r ? "light" : "no-preference");
  return ie(() => {
    i(n ? "dark" : r ? "light" : "no-preference");
  }, [n, r]), ie(() => {
    if (typeof (e == null ? void 0 : e.addEventListener) == "function") {
      const s = ({ matches: l }) => l && i("dark"), a = ({ matches: l }) => l && i("light");
      return e == null || e.addEventListener("change", s), t == null || t.addEventListener("change", a), () => {
        e == null || e.removeEventListener("change", s), t == null || t.removeEventListener("change", a);
      };
    } else {
      const s = () => i(
        e.matches ? "dark" : t.matches ? "light" : "no-preference"
      );
      return e == null || e.addEventListener("change", s), t == null || t.addEventListener("change", s), () => {
        e == null || e.removeEventListener("change", s), t == null || t.removeEventListener("change", s);
      };
    }
  }, [e, t]), o;
}, tw = Xn(void 0);
function NG() {
  return Tn(tw);
}
function MG() {
  const e = /* @__PURE__ */ new Set();
  let t = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(n) {
      return e.add(n), () => {
        e.delete(n);
      };
    },
    getSnapshot() {
      return t;
    },
    getServerSnapshot() {
      return t;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(n, r) {
      t = {
        ...t,
        [n]: Ac(r.reactElement, r.element, n)
      }, e.forEach((o) => o());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(n) {
      const r = { ...t };
      delete r[n], t = r, e.forEach((o) => o());
    }
  };
}
const LG = ({
  contentComponent: e
}) => {
  const t = Th(
    e.subscribe,
    e.getSnapshot,
    e.getServerSnapshot
  );
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: Object.values(t) });
}, OG = se((e, t) => {
  const [n, r] = fe();
  return Bv(t, () => (o, i) => {
    zv(() => {
      r({ node: o, container: i });
    }), r(void 0);
  }, []), /* @__PURE__ */ E.jsx(E.Fragment, { children: n && Ac(n.node, n.container) });
}), Rb = () => {
};
function DG(e, t) {
  const {
    editor: n,
    className: r,
    theme: o,
    children: i,
    editable: s,
    onSelectionChange: a,
    onChange: l,
    formattingToolbar: c,
    linkToolbar: u,
    slashMenu: d,
    emojiPicker: f,
    sideMenu: h,
    filePanel: p,
    tableHandles: m,
    comments: b,
    autoFocus: y,
    renderEditor: k = !0,
    ...C
  } = e, [_, w] = fe(), T = rr(), M = ew(), D = (T == null ? void 0 : T.colorSchemePreference) || M, R = o || (D === "dark" ? "dark" : "light");
  AG(l || Rb, n), IG(a || Rb, n);
  const N = Z(
    (W) => {
      n.elementRenderer = W;
    },
    [n]
  ), B = Me(() => ({
    ...T,
    editor: n,
    setContentEditableProps: w,
    colorSchemePreference: R
  }), [T, n, R]), F = Me(() => ({
    editorProps: {
      autoFocus: y,
      contentEditableProps: _,
      editable: s
    },
    defaultUIProps: {
      formattingToolbar: c,
      linkToolbar: u,
      slashMenu: d,
      emojiPicker: f,
      sideMenu: h,
      filePanel: p,
      tableHandles: m,
      comments: b
    }
  }), [
    y,
    _,
    s,
    c,
    u,
    d,
    f,
    h,
    p,
    m,
    b
  ]);
  return /* @__PURE__ */ E.jsx(Nx.Provider, { value: B, children: /* @__PURE__ */ E.jsxs(tw.Provider, { value: F, children: [
    /* @__PURE__ */ E.jsx(OG, { ref: N }),
    /* @__PURE__ */ E.jsx(
      RG,
      {
        className: r,
        renderEditor: k,
        editorColorScheme: R,
        ref: t,
        ...C,
        children: i
      }
    )
  ] }) });
}
const RG = st.forwardRef(({ className: e, renderEditor: t, editorColorScheme: n, children: r, ...o }, i) => /* @__PURE__ */ E.jsx(
  "div",
  {
    className: dt("bn-container", n, e),
    "data-color-scheme": n,
    ...o,
    ref: i,
    children: t ? /* @__PURE__ */ E.jsx(BG, { children: r }) : r
  }
)), PG = st.forwardRef(DG), BG = (e) => {
  const t = NG(), n = ae(), r = Me(() => MG(), []), o = Z(
    (i) => {
      n.isEditable = t.editorProps.editable !== !1, n._tiptapEditor.contentComponent = r, i ? n.mount(i) : n.unmount();
    },
    [t.editorProps.editable, n, r]
  );
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(LG, { contentComponent: r }),
    /* @__PURE__ */ E.jsx($G, { ...t.editorProps, ...e, mount: o }),
    /* @__PURE__ */ E.jsx(_G, { ...t.defaultUIProps }),
    e.children
  ] });
}, $G = (e) => {
  const { autoFocus: t, mount: n, contentEditableProps: r } = e;
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "data-bn-autofocus": t,
      ref: n,
      ...r
    }
  );
}, am = (e = {}, t = []) => Me(() => {
  const n = lx.create(e);
  return window && (window.ProseMirror = n._tiptapEditor), n;
}, t), lm = (e) => {
  const [t, n] = fe(!1), r = _t({
    editor: e.editor,
    selector: ({ editor: a }) => a.isEmpty
  }), o = ne(), i = Z(() => {
    n(!0);
  }, []), s = Z(() => {
    n(!1);
  }, []);
  return ie(() => {
    e.editable && e.autoFocus && e.editor.focus();
  }, [e.autoFocus, e.editable, e.editor]), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(
      o.Comments.Editor,
      {
        autoFocus: e.autoFocus,
        className: "bn-comment-editor",
        editor: e.editor,
        onFocus: i,
        onBlur: s,
        editable: e.editable
      }
    ),
    e.actions && /* @__PURE__ */ E.jsx("div", { className: "bn-comment-actions-wrapper", children: /* @__PURE__ */ E.jsx(e.actions, { isFocused: t, isEmpty: r }) })
  ] });
};
let Vd;
async function HG() {
  return Vd || (Vd = (async () => {
    const [e, t] = await Promise.all([
      import("./module-DS36xGfa.js"),
      // use a dynamic import to encourage bundle-splitting
      // and a smaller initial client bundle size
      import("./native-D8_4pb9S.js")
    ]), n = "default" in e ? e.default : e, r = "default" in t ? t.default : t;
    return await n.init({ data: r }), { emojiMart: n, emojiData: r };
  })(), Vd);
}
function FG(e) {
  const t = Ae(null), n = Ae(null);
  return n.current && n.current.update(e), ie(() => ((async () => {
    const { emojiMart: r } = await HG();
    n.current = new r.Picker({ ...e, ref: t });
  })(), () => {
    n.current = null;
  }), []), st.createElement("div", { ref: t });
}
const Pb = (e) => {
  var t;
  const [n, r] = fe(!1), o = ne(), i = ae(), s = rr();
  return /* @__PURE__ */ E.jsxs(o.Generic.Popover.Root, { open: n, children: [
    /* @__PURE__ */ E.jsx(o.Generic.Popover.Trigger, { children: /* @__PURE__ */ E.jsx(
      "div",
      {
        onClick: (a) => {
          var l;
          a.preventDefault(), a.stopPropagation(), r(!n), (l = e.onOpenChange) == null || l.call(e, !n);
        },
        style: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        },
        children: e.children
      }
    ) }),
    ((t = i.domElement) == null ? void 0 : t.parentElement) && Ac(
      /* @__PURE__ */ E.jsx(
        o.Generic.Popover.Content,
        {
          className: "bn-emoji-picker-popover",
          variant: "panel-popover",
          children: /* @__PURE__ */ E.jsx(
            FG,
            {
              perLine: 7,
              onClickOutside: () => {
                var a;
                r(!1), (a = e.onOpenChange) == null || a.call(e, !1);
              },
              onEmojiSelect: (a) => {
                var l;
                e.onEmojiSelect(a), r(!1), (l = e.onOpenChange) == null || l.call(e, !1);
              },
              theme: s == null ? void 0 : s.colorSchemePreference
            }
          )
        }
      ),
      i.domElement.parentElement
    )
  ] });
};
function UG(e) {
  return cm([e]).get(e);
}
function cm(e) {
  const t = Fe($n).userStore, n = Z(() => {
    const i = /* @__PURE__ */ new Map();
    for (const s of e) {
      const a = t.getUser(s);
      a && i.set(s, a);
    }
    return i;
  }, [t, e]), r = Me(() => ({
    current: n()
  }), [n]), o = Z(
    (i) => {
      const s = t.subscribe((a) => {
        r.current = n(), i();
      });
      return t.loadUsers(e), s;
    },
    [t, n, e, r]
  );
  return Th(o, () => r.current);
}
const jG = (e) => {
  const t = ne(), n = Ce(), r = Fe($n), o = e.comment.reactions.find(
    (l) => l.emoji === e.emoji
  );
  if (!o)
    throw new Error(
      "Trying to render reaction badge for non-existing reaction"
    );
  const [i, s] = fe([]), a = cm(i);
  return /* @__PURE__ */ E.jsx(
    t.Generic.Badge.Root,
    {
      className: dt("bn-badge", "bn-comment-reaction"),
      text: o.userIds.length.toString(),
      icon: o.emoji,
      isSelected: r.threadStore.auth.canDeleteReaction(
        e.comment,
        o.emoji
      ),
      onClick: () => e.onReactionSelect(o.emoji),
      onMouseEnter: () => s(o.userIds),
      mainTooltip: n.comments.reactions.reacted_by,
      secondaryTooltip: `${Array.from(a.values()).map((l) => l.username).join(`
`)}`
    },
    o.emoji
  );
}, { textColor: zX, backgroundColor: qX, ...VG } = Tp, um = PT.create({
  blockSpecs: {
    paragraph: y2()
  },
  styleSpecs: VG
}), zG = ({
  comment: e,
  thread: t,
  showResolveButton: n
}) => {
  const r = Fe($n), o = Ce(), i = am({
    initialContent: e.body,
    trailingBlock: !1,
    dictionary: {
      ...o,
      placeholders: {
        emptyDocument: o.placeholders.edit_comment
      }
    },
    schema: r.commentEditorSchema || um
  }), s = ne(), [a, l] = fe(!1), [c, u] = fe(!1), d = r.threadStore, f = Z(() => {
    l(!0);
  }, []), h = Z(() => {
    i.replaceBlocks(i.document, e.body), l(!1);
  }, [i, e.body]), p = Z(
    async (N) => {
      await d.updateComment({
        commentId: e.id,
        comment: {
          body: i.document
        },
        threadId: t.id
      }), l(!1);
    },
    [e, t.id, i, d]
  ), m = Z(async () => {
    await d.deleteComment({
      commentId: e.id,
      threadId: t.id
    });
  }, [e, t.id, d]), b = Z(
    async (N) => {
      d.auth.canAddReaction(e, N) ? await d.addReaction({
        threadId: t.id,
        commentId: e.id,
        emoji: N
      }) : d.auth.canDeleteReaction(e, N) && await d.deleteReaction({
        threadId: t.id,
        commentId: e.id,
        emoji: N
      });
    },
    [d, e, t.id]
  ), y = Z(async () => {
    await d.resolveThread({
      threadId: t.id
    });
  }, [t.id, d]), k = Z(async () => {
    await d.unresolveThread({
      threadId: t.id
    });
  }, [t.id, d]), C = UG(e.userId);
  if (!e.body)
    return null;
  let _;
  const w = d.auth.canAddReaction(e), T = d.auth.canDeleteComment(e), M = d.auth.canUpdateComment(e), D = n && (t.resolved ? d.auth.canUnresolveThread(t) : d.auth.canResolveThread(t));
  a || (_ = /* @__PURE__ */ E.jsxs(
    s.Generic.Toolbar.Root,
    {
      className: dt("bn-action-toolbar", "bn-comment-actions"),
      variant: "action-toolbar",
      children: [
        w && /* @__PURE__ */ E.jsx(
          Pb,
          {
            onEmojiSelect: (N) => b(N.native),
            onOpenChange: u,
            children: /* @__PURE__ */ E.jsx(
              s.Generic.Toolbar.Button,
              {
                mainTooltip: o.comments.actions.add_reaction,
                variant: "compact",
                children: /* @__PURE__ */ E.jsx(Mb, { size: 16 })
              },
              "add-reaction"
            )
          }
        ),
        D && (t.resolved ? /* @__PURE__ */ E.jsx(
          s.Generic.Toolbar.Button,
          {
            mainTooltip: "Re-open",
            variant: "compact",
            onClick: k,
            children: /* @__PURE__ */ E.jsx(Pq, { size: 16 })
          },
          "reopen"
        ) : /* @__PURE__ */ E.jsx(
          s.Generic.Toolbar.Button,
          {
            mainTooltip: o.comments.actions.resolve,
            variant: "compact",
            onClick: y,
            children: /* @__PURE__ */ E.jsx(aW, { size: 16 })
          },
          "resolve"
        )),
        (T || M) && /* @__PURE__ */ E.jsxs(s.Generic.Menu.Root, { position: "bottom-start", children: [
          /* @__PURE__ */ E.jsx(s.Generic.Menu.Trigger, { children: /* @__PURE__ */ E.jsx(
            s.Generic.Toolbar.Button,
            {
              mainTooltip: o.comments.actions.more_actions,
              variant: "compact",
              children: /* @__PURE__ */ E.jsx(fW, { size: 16 })
            },
            "more-actions"
          ) }),
          /* @__PURE__ */ E.jsxs(s.Generic.Menu.Dropdown, { className: "bn-menu-dropdown", children: [
            M && /* @__PURE__ */ E.jsx(
              s.Generic.Menu.Item,
              {
                icon: /* @__PURE__ */ E.jsx(Bq, {}),
                onClick: f,
                children: o.comments.actions.edit_comment
              },
              "edit-comment"
            ),
            T && /* @__PURE__ */ E.jsx(
              s.Generic.Menu.Item,
              {
                icon: /* @__PURE__ */ E.jsx(cW, {}),
                onClick: m,
                children: o.comments.actions.delete_comment
              },
              "delete-comment"
            )
          ] })
        ] })
      ]
    }
  ));
  const R = e.createdAt.toLocaleDateString(void 0, {
    month: "short",
    day: "numeric"
  });
  if (!e.body)
    throw new Error("soft deletes are not yet supported");
  return /* @__PURE__ */ E.jsx(
    s.Comments.Comment,
    {
      authorInfo: C ?? "loading",
      timeString: R,
      edited: e.updatedAt.getTime() !== e.createdAt.getTime(),
      showActions: "hover",
      actions: _,
      className: "bn-thread-comment",
      emojiPickerOpen: c,
      children: /* @__PURE__ */ E.jsx(
        lm,
        {
          autoFocus: a,
          editor: i,
          editable: a,
          actions: e.reactions.length > 0 || a ? ({ isEmpty: N }) => /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
            e.reactions.length > 0 && !a && /* @__PURE__ */ E.jsxs(
              s.Generic.Badge.Group,
              {
                className: dt(
                  "bn-badge-group",
                  "bn-comment-reactions"
                ),
                children: [
                  e.reactions.map((B) => /* @__PURE__ */ E.jsx(
                    jG,
                    {
                      comment: e,
                      emoji: B.emoji,
                      onReactionSelect: b
                    },
                    B.emoji
                  )),
                  w && /* @__PURE__ */ E.jsx(
                    Pb,
                    {
                      onEmojiSelect: (B) => b(B.native),
                      onOpenChange: u,
                      children: /* @__PURE__ */ E.jsx(
                        s.Generic.Badge.Root,
                        {
                          className: dt(
                            "bn-badge",
                            "bn-comment-add-reaction"
                          ),
                          text: "+",
                          icon: /* @__PURE__ */ E.jsx(Mb, { size: 16 }),
                          mainTooltip: o.comments.actions.add_reaction
                        }
                      )
                    }
                  )
                ]
              }
            ),
            a && /* @__PURE__ */ E.jsxs(
              s.Generic.Toolbar.Root,
              {
                variant: "action-toolbar",
                className: dt(
                  "bn-action-toolbar",
                  "bn-comment-actions"
                ),
                children: [
                  /* @__PURE__ */ E.jsx(
                    s.Generic.Toolbar.Button,
                    {
                      mainTooltip: o.comments.save_button_text,
                      variant: "compact",
                      onClick: p,
                      isDisabled: N,
                      children: o.comments.save_button_text
                    }
                  ),
                  /* @__PURE__ */ E.jsx(
                    s.Generic.Toolbar.Button,
                    {
                      className: "bn-button",
                      mainTooltip: o.comments.cancel_button_text,
                      variant: "compact",
                      onClick: h,
                      children: o.comments.cancel_button_text
                    }
                  )
                ]
              }
            )
          ] }) : void 0
        }
      )
    }
  );
}, qG = ({
  thread: e,
  maxCommentsBeforeCollapse: t
}) => {
  const n = ne(), r = Ce(), o = cm(e.resolvedBy ? [e.resolvedBy] : []), i = e.comments.map((s, a) => /* @__PURE__ */ E.jsx(
    zG,
    {
      thread: e,
      comment: s,
      showResolveButton: a === 0
    },
    s.id + JSON.stringify(s.body || "{}")
  ));
  if (e.resolved && e.resolvedUpdatedAt && e.resolvedBy) {
    if (!o.get(e.resolvedBy))
      throw new Error(
        `User ${e.resolvedBy} resolved thread ${e.id}, but their data could not be found.`
      );
    const s = e.comments.findLastIndex(
      (a) => e.resolvedUpdatedAt.getTime() > a.createdAt.getTime()
    ) + 1;
    i.splice(
      s,
      0,
      /* @__PURE__ */ E.jsx(
        n.Comments.Comment,
        {
          className: "bn-thread-comment",
          authorInfo: e.resolvedBy && o.get(e.resolvedBy) || "loading",
          timeString: e.resolvedUpdatedAt.toLocaleDateString(void 0, {
            month: "short",
            day: "numeric"
          }),
          edited: !1,
          showActions: !1,
          children: /* @__PURE__ */ E.jsx("div", { className: "bn-resolved-text", children: r.comments.sidebar.marked_as_resolved })
        },
        "resolved-comment"
      )
    );
  }
  return t && i.length > t && i.splice(
    1,
    i.length - 2,
    /* @__PURE__ */ E.jsx(
      n.Comments.ExpandSectionsPrompt,
      {
        className: "bn-thread-expand-prompt",
        children: r.comments.sidebar.more_replies(e.comments.length - 2)
      },
      "expand-prompt"
    )
  ), i;
};
function WG() {
  const e = Fe($n), t = ne(), n = Ce(), r = am({
    trailingBlock: !1,
    dictionary: {
      ...n,
      placeholders: {
        emptyDocument: n.placeholders.new_comment
      }
    },
    schema: e.commentEditorSchema || um
  });
  return /* @__PURE__ */ E.jsx(t.Comments.Card, { className: "bn-thread", children: /* @__PURE__ */ E.jsx(
    lm,
    {
      autoFocus: !0,
      editable: !0,
      editor: r,
      actions: ({ isEmpty: o }) => /* @__PURE__ */ E.jsx(
        t.Generic.Toolbar.Root,
        {
          className: dt(
            "bn-action-toolbar",
            "bn-comment-actions"
          ),
          variant: "action-toolbar",
          children: /* @__PURE__ */ E.jsx(
            t.Generic.Toolbar.Button,
            {
              className: "bn-button",
              mainTooltip: "Save",
              variant: "compact",
              isDisabled: o,
              onClick: async () => {
                await e.createThread({
                  initialComment: {
                    body: r.document
                  }
                }), e.stopPendingComment();
              },
              children: "Save"
            }
          )
        }
      )
    }
  ) });
}
function GG(e) {
  const t = ae(), n = Fe($n), r = Ke($n, {
    editor: t,
    selector: (a) => a.pendingComment
  }), o = _t({
    editor: t,
    selector: ({ editor: a }) => r ? {
      from: a.prosemirrorState.selection.from,
      to: a.prosemirrorState.selection.to
    } : void 0
  }), i = Me(
    () => {
      var a, l;
      return {
        ...e.floatingUIOptions,
        useFloatingOptions: {
          open: !!r,
          // Needed as hooks like `useDismiss` call `onOpenChange` to change the
          // open state.
          onOpenChange: (c) => {
            c || (n.stopPendingComment(), t.focus());
          },
          placement: "bottom",
          middleware: [Ln(10), mo(), Hr()],
          ...(a = e.floatingUIOptions) == null ? void 0 : a.useFloatingOptions
        },
        elementProps: {
          style: {
            zIndex: 60
          },
          ...(l = e.floatingUIOptions) == null ? void 0 : l.elementProps
        }
      };
    },
    [n, t, r, e.floatingUIOptions]
  ), s = e.floatingComposer || WG;
  return /* @__PURE__ */ E.jsx(im, { position: o, ...i, children: /* @__PURE__ */ E.jsx(s, {}) });
}
const YG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: GG
}, Symbol.toStringTag, { value: "Module" })), nw = ({
  thread: e,
  selected: t,
  referenceText: n,
  maxCommentsBeforeCollapse: r,
  onFocus: o,
  onBlur: i,
  tabIndex: s
}) => {
  const a = ne(), l = Ce(), c = Fe($n), u = am({
    trailingBlock: !1,
    dictionary: {
      ...l,
      placeholders: {
        emptyDocument: l.placeholders.comment_reply
      }
    },
    schema: c.commentEditorSchema || um
  }), d = Z(async () => {
    await c.threadStore.addComment({
      comment: {
        body: u.document
      },
      threadId: e.id
    }), u.removeBlocks(u.document);
  }, [c, u, e.id]);
  return /* @__PURE__ */ E.jsxs(
    a.Comments.Card,
    {
      className: "bn-thread",
      headerText: n,
      onFocus: o,
      onBlur: i,
      selected: t,
      tabIndex: s,
      children: [
        /* @__PURE__ */ E.jsx(a.Comments.CardSection, { className: "bn-thread-comments", children: /* @__PURE__ */ E.jsx(
          qG,
          {
            thread: e,
            maxCommentsBeforeCollapse: t ? void 0 : r || 5
          }
        ) }),
        t && /* @__PURE__ */ E.jsx(a.Comments.CardSection, { className: "bn-thread-composer", children: /* @__PURE__ */ E.jsx(
          lm,
          {
            autoFocus: !1,
            editable: !0,
            editor: u,
            actions: ({ isEmpty: f }) => f ? null : /* @__PURE__ */ E.jsx(
              a.Generic.Toolbar.Root,
              {
                variant: "action-toolbar",
                className: dt(
                  "bn-action-toolbar",
                  "bn-comment-actions"
                ),
                children: /* @__PURE__ */ E.jsx(
                  a.Generic.Toolbar.Button,
                  {
                    mainTooltip: l.comments.save_button_text,
                    variant: "compact",
                    isDisabled: f,
                    onClick: d,
                    children: l.comments.save_button_text
                  }
                )
              }
            )
          }
        ) })
      ]
    }
  );
};
function KG() {
  const e = Fe($n).threadStore, t = Ae(void 0);
  t.current || (t.current = e.getThreads());
  const n = Z(
    (r) => e.subscribe((o) => {
      t.current = o, r();
    }),
    [e]
  );
  return Th(n, () => t.current);
}
function QG(e) {
  const t = ae(), n = Fe($n), r = Ke($n, {
    editor: t,
    selector: (l) => l.selectedThreadId ? {
      id: l.selectedThreadId,
      position: l.threadPositions.get(l.selectedThreadId)
    } : void 0
  }), o = KG(), i = Me(
    () => r ? o.get(r.id) : void 0,
    [r, o]
  ), s = Me(
    () => {
      var l, c;
      return {
        ...e.floatingUIOptions,
        useFloatingOptions: {
          open: !!r,
          // Needed as hooks like `useDismiss` call `onOpenChange` to change the
          // open state.
          onOpenChange: (u, d, f) => {
            f === "escape-key" && t.focus(), u || n.selectThread(void 0);
          },
          placement: "bottom",
          middleware: [Ln(10), mo(), Hr()],
          ...(l = e.floatingUIOptions) == null ? void 0 : l.useFloatingOptions
        },
        elementProps: {
          style: {
            zIndex: 30
          },
          ...(c = e.floatingUIOptions) == null ? void 0 : c.elementProps
        }
      };
    },
    [n, t, e.floatingUIOptions, r]
  ), a = e.floatingThread || nw;
  return /* @__PURE__ */ E.jsx(im, { position: r == null ? void 0 : r.position, ...s, children: i && /* @__PURE__ */ E.jsx(a, { thread: i, selected: !0 }) });
}
const ZG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: QG
}, Symbol.toStringTag, { value: "Module" }));
st.memo(
  ({
    thread: e,
    selectedThreadId: t,
    maxCommentsBeforeCollapse: n,
    referenceText: r
  }) => {
    const o = Fe($n), i = Z(
      (a) => {
        a.target.closest(".bn-action-toolbar") || o.selectThread(e.id);
      },
      [o, e.id]
    ), s = Z(
      (a) => {
        if (!a.relatedTarget || a.relatedTarget.closest(".bn-action-toolbar"))
          return;
        const l = a.target instanceof Node ? a.target : null, c = a.relatedTarget instanceof Node ? a.relatedTarget.closest(".bn-thread") : null;
        (!l || !c || !c.contains(l)) && o.selectThread(void 0);
      },
      [o]
    );
    return /* @__PURE__ */ E.jsx(
      nw,
      {
        thread: e,
        selected: e.id === t,
        referenceText: r,
        maxCommentsBeforeCollapse: n,
        onFocus: i,
        onBlur: s,
        tabIndex: 0
      }
    );
  }
);
function rw(e, t) {
  const n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), o = n.top < r.top, i = n.bottom > r.bottom;
  return o && i ? "both" : o ? "top" : i ? "bottom" : "none";
}
function XG(e) {
  return (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
function gr(e) {
  return Object.keys(e);
}
function zd(e) {
  return e && typeof e == "object" && !Array.isArray(e);
}
function dm(e, t) {
  const n = { ...e }, r = t;
  return zd(e) && zd(t) && Object.keys(t).forEach((o) => {
    zd(r[o]) && o in e ? n[o] = dm(n[o], r[o]) : n[o] = r[o];
  }), n;
}
function JG(e) {
  return e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
function eY(e) {
  var t;
  return typeof e != "string" || !e.includes("var(--mantine-scale)") ? e : (t = e.match(/^calc\((.*?)\)$/)) == null ? void 0 : t[1].split("*")[0].trim();
}
function tY(e) {
  const t = eY(e);
  return typeof t == "number" ? t : typeof t == "string" ? t.includes("calc") || t.includes("var") ? t : t.includes("px") ? Number(t.replace("px", "")) : t.includes("rem") ? Number(t.replace("rem", "")) * 16 : t.includes("em") ? Number(t.replace("em", "")) * 16 : Number(t) : NaN;
}
function Bb(e) {
  return e === "0rem" ? "0rem" : `calc(${e} * var(--mantine-scale))`;
}
function ow(e, { shouldScale: t = !1 } = {}) {
  function n(r) {
    if (r === 0 || r === "0")
      return `0${e}`;
    if (typeof r == "number") {
      const o = `${r / 16}${e}`;
      return t ? Bb(o) : o;
    }
    if (typeof r == "string") {
      if (r === "" || r.startsWith("calc(") || r.startsWith("clamp(") || r.includes("rgba("))
        return r;
      if (r.includes(","))
        return r.split(",").map((i) => n(i)).join(",");
      if (r.includes(" "))
        return r.split(" ").map((i) => n(i)).join(" ");
      const o = r.replace("px", "");
      if (!Number.isNaN(Number(o))) {
        const i = `${Number(o) / 16}${e}`;
        return t ? Bb(i) : i;
      }
    }
    return r;
  }
  return n;
}
const U = ow("rem", { shouldScale: !0 }), $b = ow("em");
function yu(e) {
  return Object.keys(e).reduce((t, n) => (e[n] !== void 0 && (t[n] = e[n]), t), {});
}
function iw(e) {
  if (typeof e == "number")
    return !0;
  if (typeof e == "string") {
    if (e.startsWith("calc(") || e.startsWith("var(") || e.includes(" ") && e.trim() !== "")
      return !0;
    const t = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
    return e.trim().split(/\s+/).every((r) => t.test(r));
  }
  return !1;
}
function sw(e) {
  return Array.isArray(e) || e === null ? !1 : typeof e == "object" ? e.type !== Hy : !1;
}
function Eu(e) {
  const t = Xn(null);
  return [({ children: o, value: i }) => /* @__PURE__ */ E.jsx(t.Provider, { value: i, children: o }), () => {
    const o = Tn(t);
    if (o === null)
      throw new Error(e);
    return o;
  }];
}
function ku(e = null) {
  const t = Xn(e);
  return [({ children: o, value: i }) => /* @__PURE__ */ E.jsx(t.Provider, { value: i, children: o }), () => Tn(t)];
}
function Hb(e, t) {
  return (n) => {
    if (typeof n != "string" || n.trim().length === 0)
      throw new Error(t);
    return `${e}-${n}`;
  };
}
function gc(e, t) {
  let n = e;
  for (; (n = n.parentElement) && !n.matches(t); )
    ;
  return n;
}
function nY(e, t, n) {
  for (let r = e - 1; r >= 0; r -= 1)
    if (!t[r].disabled)
      return r;
  if (n) {
    for (let r = t.length - 1; r > -1; r -= 1)
      if (!t[r].disabled)
        return r;
  }
  return e;
}
function rY(e, t, n) {
  for (let r = e + 1; r < t.length; r += 1)
    if (!t[r].disabled)
      return r;
  if (n) {
    for (let r = 0; r < t.length; r += 1)
      if (!t[r].disabled)
        return r;
  }
  return e;
}
function oY(e, t, n) {
  return gc(e, n) === gc(t, n);
}
function fm({
  parentSelector: e,
  siblingSelector: t,
  onKeyDown: n,
  loop: r = !0,
  activateOnFocus: o = !1,
  dir: i = "rtl",
  orientation: s
}) {
  return (a) => {
    var p;
    n == null || n(a);
    const l = Array.from(
      ((p = gc(a.currentTarget, e)) == null ? void 0 : p.querySelectorAll(
        t
      )) || []
    ).filter((m) => oY(a.currentTarget, m, e)), c = l.findIndex((m) => a.currentTarget === m), u = rY(c, l, r), d = nY(c, l, r), f = i === "rtl" ? d : u, h = i === "rtl" ? u : d;
    switch (a.key) {
      case "ArrowRight": {
        s === "horizontal" && (a.stopPropagation(), a.preventDefault(), l[f].focus(), o && l[f].click());
        break;
      }
      case "ArrowLeft": {
        s === "horizontal" && (a.stopPropagation(), a.preventDefault(), l[h].focus(), o && l[h].click());
        break;
      }
      case "ArrowUp": {
        s === "vertical" && (a.stopPropagation(), a.preventDefault(), l[d].focus(), o && l[d].click());
        break;
      }
      case "ArrowDown": {
        s === "vertical" && (a.stopPropagation(), a.preventDefault(), l[u].focus(), o && l[u].click());
        break;
      }
      case "Home": {
        a.stopPropagation(), a.preventDefault(), !l[0].disabled && l[0].focus();
        break;
      }
      case "End": {
        a.stopPropagation(), a.preventDefault();
        const m = l.length - 1;
        !l[m].disabled && l[m].focus();
        break;
      }
    }
  };
}
const iY = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function ka(e) {
  return iY[e];
}
const sY = () => {
};
function aY(e, t = { active: !0 }) {
  return typeof e != "function" || !t.active ? t.onKeyDown || sY : (n) => {
    var r;
    n.key === "Escape" && (e(n), (r = t.onTrigger) == null || r.call(t));
  };
}
function et(e, t = "size", n = !0) {
  if (e !== void 0)
    return iw(e) ? n ? U(e) : e : `var(--${t}-${e})`;
}
function Ca(e) {
  return et(e, "mantine-spacing");
}
function Ut(e) {
  return e === void 0 ? "var(--mantine-radius-default)" : et(e, "mantine-radius");
}
function an(e) {
  return et(e, "mantine-font-size");
}
function lY(e) {
  return et(e, "mantine-line-height", !1);
}
function aw(e) {
  if (e)
    return et(e, "mantine-shadow", !1);
}
function sn(e, t) {
  return (n) => {
    e == null || e(n), t == null || t(n);
  };
}
function cY(e, t, n) {
  var r;
  return n ? Array.from(
    ((r = gc(n, t)) == null ? void 0 : r.querySelectorAll(e)) || []
  ).findIndex((o) => o === n) : null;
}
function uY(e = "mantine-") {
  return `${e}${Math.random().toString(36).slice(2, 11)}`;
}
function Fb(e) {
  const t = Ae(e);
  return ie(() => {
    t.current = e;
  }), Me(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
const dY = ["mousedown", "touchstart"];
function fY(e, t, n) {
  const r = Ae(null), o = t || dY;
  return ie(() => {
    const i = (s) => {
      const { target: a } = s ?? {};
      if (Array.isArray(n)) {
        const l = !document.body.contains(a) && (a == null ? void 0 : a.tagName) !== "HTML";
        n.every((u) => !!u && !s.composedPath().includes(u)) && !l && e(s);
      } else r.current && !r.current.contains(a) && e(s);
    };
    return o.forEach((s) => document.addEventListener(s, i)), () => {
      o.forEach((s) => document.removeEventListener(s, i));
    };
  }, [r, e, n]), r;
}
function hY(e, t) {
  try {
    return e.addEventListener("change", t), () => e.removeEventListener("change", t);
  } catch {
    return e.addListener(t), () => e.removeListener(t);
  }
}
function pY(e, t) {
  return typeof window < "u" && "matchMedia" in window ? window.matchMedia(e).matches : !1;
}
function mY(e, t, { getInitialValueInEffect: n } = {
  getInitialValueInEffect: !0
}) {
  const [r, o] = fe(
    n ? t : pY(e)
  );
  return ie(() => {
    try {
      const i = window.matchMedia(e);
      return o(i.matches), hY(i, (s) => o(s.matches));
    } catch {
      return;
    }
  }, [e]), r || !1;
}
const Ta = typeof document < "u" ? Ch : ie;
function ea(e, t) {
  const n = Ae(!1);
  ie(
    () => () => {
      n.current = !1;
    },
    []
  ), ie(() => {
    if (n.current)
      return e();
    n.current = !0;
  }, t);
}
function gY({
  opened: e,
  shouldReturnFocus: t = !0
}) {
  const n = Ae(null), r = () => {
    var o;
    n.current && "focus" in n.current && typeof n.current.focus == "function" && ((o = n.current) == null || o.focus({ preventScroll: !0 }));
  };
  return ea(() => {
    let o = -1;
    const i = (s) => {
      s.key === "Tab" && window.clearTimeout(o);
    };
    return document.addEventListener("keydown", i), e ? n.current = document.activeElement : t && (o = window.setTimeout(r, 10)), () => {
      window.clearTimeout(o), document.removeEventListener("keydown", i);
    };
  }, [e, t]), r;
}
const bY = /input|select|textarea|button|object/, lw = "a, input, select, textarea, button, object, [tabindex]";
function yY(e) {
  return process.env.NODE_ENV === "test" ? !1 : e.style.display === "none";
}
function EY(e) {
  if (e.getAttribute("aria-hidden") || e.getAttribute("hidden") || e.getAttribute("type") === "hidden")
    return !1;
  let n = e;
  for (; n && !(n === document.body || n.nodeType === 11); ) {
    if (yY(n))
      return !1;
    n = n.parentNode;
  }
  return !0;
}
function cw(e) {
  let t = e.getAttribute("tabindex");
  return t === null && (t = void 0), parseInt(t, 10);
}
function fh(e) {
  const t = e.nodeName.toLowerCase(), n = !Number.isNaN(cw(e));
  return /* @ts-expect-error function accepts any html element but if it is a button, it should not be disabled to trigger the condition */ (bY.test(t) && !e.disabled || e instanceof HTMLAnchorElement && e.href || n) && EY(e);
}
function uw(e) {
  const t = cw(e);
  return (Number.isNaN(t) || t >= 0) && fh(e);
}
function kY(e) {
  return Array.from(e.querySelectorAll(lw)).filter(uw);
}
function CY(e, t) {
  const n = kY(e);
  if (!n.length) {
    t.preventDefault();
    return;
  }
  const r = n[t.shiftKey ? 0 : n.length - 1], o = e.getRootNode();
  let i = r === o.activeElement || e === o.activeElement;
  const s = o.activeElement;
  if (s.tagName === "INPUT" && s.getAttribute("type") === "radio" && (i = n.filter(
    (u) => u.getAttribute("type") === "radio" && u.getAttribute("name") === s.getAttribute("name")
  ).includes(r)), !i)
    return;
  t.preventDefault();
  const l = n[t.shiftKey ? n.length - 1 : 0];
  l && l.focus();
}
function dw(e = !0) {
  const t = Ae(null), n = (o) => {
    let i = o.querySelector("[data-autofocus]");
    if (!i) {
      const s = Array.from(o.querySelectorAll(lw));
      i = s.find(uw) || s.find(fh) || null, !i && fh(o) && (i = o);
    }
    i ? i.focus({ preventScroll: !0 }) : process.env.NODE_ENV === "development" && console.warn(
      "[@mantine/hooks/use-focus-trap] Failed to find focusable element within provided node",
      o
    );
  }, r = Z(
    (o) => {
      e && o !== null && t.current !== o && (o ? (setTimeout(() => {
        o.getRootNode() ? n(o) : process.env.NODE_ENV === "development" && console.warn("[@mantine/hooks/use-focus-trap] Ref node is not part of the dom", o);
      }), t.current = o) : t.current = null);
    },
    [e]
  );
  return ie(() => {
    if (!e)
      return;
    t.current && setTimeout(() => n(t.current));
    const o = (i) => {
      i.key === "Tab" && t.current && CY(t.current, i);
    };
    return document.addEventListener("keydown", o), () => document.removeEventListener("keydown", o);
  }, [e]), r;
}
const TY = st.useId || (() => {
});
function xY() {
  const e = TY();
  return e ? `mantine-${e.replace(/:/g, "")}` : "";
}
function Qi(e) {
  const t = xY(), [n, r] = fe(t);
  return Ta(() => {
    r(uY());
  }, []), typeof e == "string" ? e : typeof window > "u" ? t : n;
}
function bc(e, t) {
  if (typeof e == "function")
    return e(t);
  typeof e == "object" && e !== null && "current" in e && (e.current = t);
}
function Cu(...e) {
  const t = /* @__PURE__ */ new Map();
  return (n) => {
    if (e.forEach((r) => {
      const o = bc(r, n);
      o && t.set(r, o);
    }), t.size > 0)
      return () => {
        e.forEach((r) => {
          const o = t.get(r);
          o && typeof o == "function" ? o() : bc(r, null);
        }), t.clear();
      };
  };
}
function or(...e) {
  return Z(Cu(...e), e);
}
function Zi({
  value: e,
  defaultValue: t,
  finalValue: n,
  onChange: r = () => {
  }
}) {
  const [o, i] = fe(
    t !== void 0 ? t : n
  ), s = (a, ...l) => {
    i(a), r == null || r(a, ...l);
  };
  return e !== void 0 ? [e, r, !0] : [o, s, !1];
}
function wY(e, t) {
  return mY("(prefers-reduced-motion: reduce)", e, t);
}
function vY() {
  const [e, t] = fe(!1), n = Ae(null), r = Z(() => {
    t(!0);
  }, []), o = Z(() => {
    t(!1);
  }, []);
  return { ref: Z(
    (s) => {
      n.current && (n.current.removeEventListener("mouseenter", r), n.current.removeEventListener("mouseleave", o)), s && (s.addEventListener("mouseenter", r), s.addEventListener("mouseleave", o)), n.current = s;
    },
    [r, o]
  ), hovered: e };
}
function SY(e = !1, t = {}) {
  const [n, r] = fe(e), o = Z(() => {
    r((a) => {
      var l;
      return a || ((l = t.onOpen) == null || l.call(t), !0);
    });
  }, [t.onOpen]), i = Z(() => {
    r((a) => {
      var l;
      return a && ((l = t.onClose) == null || l.call(t), !1);
    });
  }, [t.onClose]), s = Z(() => {
    n ? i() : o();
  }, [i, o, n]);
  return [n, { open: o, close: i, toggle: s }];
}
function _Y(e) {
  return e.currentTarget instanceof HTMLElement && e.relatedTarget instanceof HTMLElement ? e.currentTarget.contains(e.relatedTarget) : !1;
}
function AY({
  onBlur: e,
  onFocus: t
} = {}) {
  const [n, r] = fe(!1), o = Ae(!1), i = Ae(null), s = Fb(t), a = Fb(e), l = Z((f) => {
    r(f), o.current = f;
  }, []), c = Z((f) => {
    o.current || (l(!0), s(f));
  }, []), u = Z((f) => {
    o.current && !_Y(f) && (l(!1), a(f));
  }, []), d = Z(
    (f) => {
      f && (i.current && (i.current.removeEventListener("focusin", c), i.current.removeEventListener("focusout", u)), f.addEventListener("focusin", c), f.addEventListener("focusout", u), i.current = f);
    },
    [c, u]
  );
  return ie(
    () => () => {
      i.current && (i.current.removeEventListener("focusin", c), i.current.removeEventListener("focusout", u));
    },
    []
  ), { ref: d, focused: n };
}
function hm(e) {
  var n;
  const t = st.version;
  return typeof st.version != "string" || t.startsWith("18.") ? e == null ? void 0 : e.ref : (n = e == null ? void 0 : e.props) == null ? void 0 : n.ref;
}
function xa(e) {
  const t = xh.toArray(e);
  return t.length !== 1 || !sw(t[0]) ? null : t[0];
}
const IY = {};
function NY(e) {
  const t = {};
  return e.forEach((n) => {
    Object.entries(n).forEach(([r, o]) => {
      t[r] ? t[r] = Ur(t[r], o) : t[r] = o;
    });
  }), t;
}
function Tu({ theme: e, classNames: t, props: n, stylesCtx: r }) {
  const i = (Array.isArray(t) ? t : [t]).map(
    (s) => typeof s == "function" ? s(e, n, r) : s || IY
  );
  return NY(i);
}
function yc({ theme: e, styles: t, props: n, stylesCtx: r }) {
  return (Array.isArray(t) ? t : [t]).reduce((i, s) => typeof s == "function" ? { ...i, ...s(e, n, r) } : { ...i, ...s }, {});
}
const pm = Xn(null);
function Co() {
  const e = Tn(pm);
  if (!e)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  return e;
}
function MY() {
  return Co().cssVariablesResolver;
}
function LY() {
  return Co().classNamesPrefix;
}
function mm() {
  return Co().getStyleNonce;
}
function OY() {
  return Co().withStaticClasses;
}
function DY() {
  return Co().headless;
}
function RY() {
  var e;
  return (e = Co().stylesTransform) == null ? void 0 : e.sx;
}
function PY() {
  var e;
  return (e = Co().stylesTransform) == null ? void 0 : e.styles;
}
function xu() {
  return Co().env || "default";
}
function BY(e) {
  return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(e);
}
function $Y(e) {
  let t = e.replace("#", "");
  if (t.length === 3) {
    const s = t.split("");
    t = [
      s[0],
      s[0],
      s[1],
      s[1],
      s[2],
      s[2]
    ].join("");
  }
  if (t.length === 8) {
    const s = parseInt(t.slice(6, 8), 16) / 255;
    return {
      r: parseInt(t.slice(0, 2), 16),
      g: parseInt(t.slice(2, 4), 16),
      b: parseInt(t.slice(4, 6), 16),
      a: s
    };
  }
  const n = parseInt(t, 16), r = n >> 16 & 255, o = n >> 8 & 255, i = n & 255;
  return {
    r,
    g: o,
    b: i,
    a: 1
  };
}
function HY(e) {
  const [t, n, r, o] = e.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
  return { r: t, g: n, b: r, a: o === void 0 ? 1 : o };
}
function FY(e) {
  const t = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i, n = e.match(t);
  if (!n)
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    };
  const r = parseInt(n[1], 10), o = parseInt(n[2], 10) / 100, i = parseInt(n[3], 10) / 100, s = n[5] ? parseFloat(n[5]) : void 0, a = (1 - Math.abs(2 * i - 1)) * o, l = r / 60, c = a * (1 - Math.abs(l % 2 - 1)), u = i - a / 2;
  let d, f, h;
  return l >= 0 && l < 1 ? (d = a, f = c, h = 0) : l >= 1 && l < 2 ? (d = c, f = a, h = 0) : l >= 2 && l < 3 ? (d = 0, f = a, h = c) : l >= 3 && l < 4 ? (d = 0, f = c, h = a) : l >= 4 && l < 5 ? (d = c, f = 0, h = a) : (d = a, f = 0, h = c), {
    r: Math.round((d + u) * 255),
    g: Math.round((f + u) * 255),
    b: Math.round((h + u) * 255),
    a: s || 1
  };
}
function gm(e) {
  return BY(e) ? $Y(e) : e.startsWith("rgb") ? HY(e) : e.startsWith("hsl") ? FY(e) : {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}
function il(e, t) {
  if (e.startsWith("var("))
    return `color-mix(in srgb, ${e}, black ${t * 100}%)`;
  const { r: n, g: r, b: o, a: i } = gm(e), s = 1 - t, a = (l) => Math.round(l * s);
  return `rgba(${a(n)}, ${a(r)}, ${a(o)}, ${i})`;
}
function ta(e, t) {
  return typeof e.primaryShade == "number" ? e.primaryShade : t === "dark" ? e.primaryShade.dark : e.primaryShade.light;
}
function qd(e) {
  return e <= 0.03928 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
}
function UY(e) {
  const t = e.match(/oklch\((.*?)%\s/);
  return t ? parseFloat(t[1]) : null;
}
function jY(e) {
  if (e.startsWith("oklch("))
    return (UY(e) || 0) / 100;
  const { r: t, g: n, b: r } = gm(e), o = t / 255, i = n / 255, s = r / 255, a = qd(o), l = qd(i), c = qd(s);
  return 0.2126 * a + 0.7152 * l + 0.0722 * c;
}
function ds(e, t = 0.179) {
  return e.startsWith("var(") ? !1 : jY(e) > t;
}
function ti({
  color: e,
  theme: t,
  colorScheme: n
}) {
  if (typeof e != "string")
    throw new Error(
      `[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof e}`
    );
  if (e === "bright")
    return {
      color: e,
      value: n === "dark" ? t.white : t.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: ds(
        n === "dark" ? t.white : t.black,
        t.luminanceThreshold
      ),
      variable: "--mantine-color-bright"
    };
  if (e === "dimmed")
    return {
      color: e,
      value: n === "dark" ? t.colors.dark[2] : t.colors.gray[7],
      shade: void 0,
      isThemeColor: !1,
      isLight: ds(
        n === "dark" ? t.colors.dark[2] : t.colors.gray[6],
        t.luminanceThreshold
      ),
      variable: "--mantine-color-dimmed"
    };
  if (e === "white" || e === "black")
    return {
      color: e,
      value: e === "white" ? t.white : t.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: ds(
        e === "white" ? t.white : t.black,
        t.luminanceThreshold
      ),
      variable: `--mantine-color-${e}`
    };
  const [r, o] = e.split("."), i = o ? Number(o) : void 0, s = r in t.colors;
  if (s) {
    const a = i !== void 0 ? t.colors[r][i] : t.colors[r][ta(t, n || "light")];
    return {
      color: r,
      value: a,
      shade: i,
      isThemeColor: s,
      isLight: ds(a, t.luminanceThreshold),
      variable: o ? `--mantine-color-${r}-${i}` : `--mantine-color-${r}-filled`
    };
  }
  return {
    color: e,
    value: e,
    isThemeColor: s,
    isLight: ds(e, t.luminanceThreshold),
    shade: i,
    variable: void 0
  };
}
function Fr(e, t) {
  const n = ti({ color: e || t.primaryColor, theme: t });
  return n.variable ? `var(${n.variable})` : e;
}
function hh(e, t) {
  const n = {
    from: (e == null ? void 0 : e.from) || t.defaultGradient.from,
    to: (e == null ? void 0 : e.to) || t.defaultGradient.to,
    deg: (e == null ? void 0 : e.deg) ?? t.defaultGradient.deg ?? 0
  }, r = Fr(n.from, t), o = Fr(n.to, t);
  return `linear-gradient(${n.deg}deg, ${r} 0%, ${o} 100%)`;
}
function ur(e, t) {
  if (typeof e != "string" || t > 1 || t < 0)
    return "rgba(0, 0, 0, 1)";
  if (e.startsWith("var(")) {
    const i = (1 - t) * 100;
    return `color-mix(in srgb, ${e}, transparent ${i}%)`;
  }
  if (e.startsWith("oklch"))
    return e.includes("/") ? e.replace(/\/\s*[\d.]+\s*\)/, `/ ${t})`) : e.replace(")", ` / ${t})`);
  const { r: n, g: r, b: o } = gm(e);
  return `rgba(${n}, ${r}, ${o}, ${t})`;
}
const ai = ur, VY = ({
  color: e,
  theme: t,
  variant: n,
  gradient: r,
  autoContrast: o
}) => {
  const i = ti({ color: e, theme: t }), s = typeof o == "boolean" ? o : t.autoContrast;
  if (n === "none")
    return {
      background: "transparent",
      hover: "transparent",
      color: "inherit",
      border: "none"
    };
  if (n === "filled") {
    const a = s && i.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
    return i.isThemeColor ? i.shade === void 0 ? {
      background: `var(--mantine-color-${e}-filled)`,
      hover: `var(--mantine-color-${e}-filled-hover)`,
      color: a,
      border: `${U(1)} solid transparent`
    } : {
      background: `var(--mantine-color-${i.color}-${i.shade})`,
      hover: `var(--mantine-color-${i.color}-${i.shade === 9 ? 8 : i.shade + 1})`,
      color: a,
      border: `${U(1)} solid transparent`
    } : {
      background: e,
      hover: il(e, 0.1),
      color: a,
      border: `${U(1)} solid transparent`
    };
  }
  if (n === "light") {
    if (i.isThemeColor) {
      if (i.shade === void 0)
        return {
          background: `var(--mantine-color-${e}-light)`,
          hover: `var(--mantine-color-${e}-light-hover)`,
          color: `var(--mantine-color-${e}-light-color)`,
          border: `${U(1)} solid transparent`
        };
      const a = t.colors[i.color][i.shade];
      return {
        background: ur(a, 0.1),
        hover: ur(a, 0.12),
        color: `var(--mantine-color-${i.color}-${Math.min(i.shade, 6)})`,
        border: `${U(1)} solid transparent`
      };
    }
    return {
      background: ur(e, 0.1),
      hover: ur(e, 0.12),
      color: e,
      border: `${U(1)} solid transparent`
    };
  }
  if (n === "outline")
    return i.isThemeColor ? i.shade === void 0 ? {
      background: "transparent",
      hover: `var(--mantine-color-${e}-outline-hover)`,
      color: `var(--mantine-color-${e}-outline)`,
      border: `${U(1)} solid var(--mantine-color-${e}-outline)`
    } : {
      background: "transparent",
      hover: ur(t.colors[i.color][i.shade], 0.05),
      color: `var(--mantine-color-${i.color}-${i.shade})`,
      border: `${U(1)} solid var(--mantine-color-${i.color}-${i.shade})`
    } : {
      background: "transparent",
      hover: ur(e, 0.05),
      color: e,
      border: `${U(1)} solid ${e}`
    };
  if (n === "subtle") {
    if (i.isThemeColor) {
      if (i.shade === void 0)
        return {
          background: "transparent",
          hover: `var(--mantine-color-${e}-light-hover)`,
          color: `var(--mantine-color-${e}-light-color)`,
          border: `${U(1)} solid transparent`
        };
      const a = t.colors[i.color][i.shade];
      return {
        background: "transparent",
        hover: ur(a, 0.12),
        color: `var(--mantine-color-${i.color}-${Math.min(i.shade, 6)})`,
        border: `${U(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: ur(e, 0.12),
      color: e,
      border: `${U(1)} solid transparent`
    };
  }
  return n === "transparent" ? i.isThemeColor ? i.shade === void 0 ? {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${e}-light-color)`,
    border: `${U(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${i.color}-${Math.min(i.shade, 6)})`,
    border: `${U(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: e,
    border: `${U(1)} solid transparent`
  } : n === "white" ? i.isThemeColor ? i.shade === void 0 ? {
    background: "var(--mantine-color-white)",
    hover: il(t.white, 0.01),
    color: `var(--mantine-color-${e}-filled)`,
    border: `${U(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: il(t.white, 0.01),
    color: `var(--mantine-color-${i.color}-${i.shade})`,
    border: `${U(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: il(t.white, 0.01),
    color: e,
    border: `${U(1)} solid transparent`
  } : n === "gradient" ? {
    background: hh(r, t),
    hover: hh(r, t),
    color: "var(--mantine-color-white)",
    border: "none"
  } : n === "default" ? {
    background: "var(--mantine-color-default)",
    hover: "var(--mantine-color-default-hover)",
    color: "var(--mantine-color-default-color)",
    border: `${U(1)} solid var(--mantine-color-default-border)`
  } : {};
}, zY = {
  dark: [
    "#C9C9C9",
    "#b8b8b8",
    "#828282",
    "#696969",
    "#424242",
    "#3b3b3b",
    "#2e2e2e",
    "#242424",
    "#1f1f1f",
    "#141414"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
}, Ub = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji", bm = {
  scale: 1,
  fontSmoothing: !0,
  focusRing: "auto",
  white: "#fff",
  black: "#000",
  colors: zY,
  primaryShade: { light: 6, dark: 8 },
  primaryColor: "blue",
  variantColorResolver: VY,
  autoContrast: !1,
  luminanceThreshold: 0.3,
  fontFamily: Ub,
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  respectReducedMotion: !1,
  cursorType: "default",
  defaultGradient: { from: "blue", to: "cyan", deg: 45 },
  defaultRadius: "sm",
  activeClassName: "mantine-active",
  focusClassName: "",
  headings: {
    fontFamily: Ub,
    fontWeight: "700",
    textWrap: "wrap",
    sizes: {
      h1: { fontSize: U(34), lineHeight: "1.3" },
      h2: { fontSize: U(26), lineHeight: "1.35" },
      h3: { fontSize: U(22), lineHeight: "1.4" },
      h4: { fontSize: U(18), lineHeight: "1.45" },
      h5: { fontSize: U(16), lineHeight: "1.5" },
      h6: { fontSize: U(14), lineHeight: "1.5" }
    }
  },
  fontSizes: {
    xs: U(12),
    sm: U(14),
    md: U(16),
    lg: U(18),
    xl: U(20)
  },
  lineHeights: {
    xs: "1.4",
    sm: "1.45",
    md: "1.55",
    lg: "1.6",
    xl: "1.65"
  },
  radius: {
    xs: U(2),
    sm: U(4),
    md: U(8),
    lg: U(16),
    xl: U(32)
  },
  spacing: {
    xs: U(10),
    sm: U(12),
    md: U(16),
    lg: U(20),
    xl: U(32)
  },
  breakpoints: {
    xs: "36em",
    sm: "48em",
    md: "62em",
    lg: "75em",
    xl: "88em"
  },
  shadows: {
    xs: `0 ${U(1)} ${U(3)} rgba(0, 0, 0, 0.05), 0 ${U(1)} ${U(2)} rgba(0, 0, 0, 0.1)`,
    sm: `0 ${U(1)} ${U(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${U(10)} ${U(
      15
    )} ${U(-5)}, rgba(0, 0, 0, 0.04) 0 ${U(7)} ${U(7)} ${U(-5)}`,
    md: `0 ${U(1)} ${U(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${U(20)} ${U(
      25
    )} ${U(-5)}, rgba(0, 0, 0, 0.04) 0 ${U(10)} ${U(10)} ${U(-5)}`,
    lg: `0 ${U(1)} ${U(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${U(28)} ${U(
      23
    )} ${U(-7)}, rgba(0, 0, 0, 0.04) 0 ${U(12)} ${U(12)} ${U(-7)}`,
    xl: `0 ${U(1)} ${U(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${U(36)} ${U(
      28
    )} ${U(-7)}, rgba(0, 0, 0, 0.04) 0 ${U(17)} ${U(17)} ${U(-7)}`
  },
  other: {},
  components: {}
};
function jb(e) {
  return e === "auto" || e === "dark" || e === "light";
}
function qY({
  key: e = "mantine-color-scheme-value"
} = {}) {
  let t;
  return {
    get: (n) => {
      if (typeof window > "u")
        return n;
      try {
        const r = window.localStorage.getItem(e);
        return jb(r) ? r : n;
      } catch {
        return n;
      }
    },
    set: (n) => {
      try {
        window.localStorage.setItem(e, n);
      } catch (r) {
        console.warn(
          "[@mantine/core] Local storage color scheme manager was unable to save color scheme.",
          r
        );
      }
    },
    subscribe: (n) => {
      t = (r) => {
        r.storageArea === window.localStorage && r.key === e && jb(r.newValue) && n(r.newValue);
      }, window.addEventListener("storage", t);
    },
    unsubscribe: () => {
      window.removeEventListener("storage", t);
    },
    clear: () => {
      window.localStorage.removeItem(e);
    }
  };
}
const WY = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more  https://mantine.dev/theming/colors/#primary-color", Vb = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function Wd(e) {
  return e < 0 || e > 9 ? !1 : parseInt(e.toString(), 10) === e;
}
function zb(e) {
  if (!(e.primaryColor in e.colors))
    throw new Error(WY);
  if (typeof e.primaryShade == "object" && (!Wd(e.primaryShade.dark) || !Wd(e.primaryShade.light)))
    throw new Error(Vb);
  if (typeof e.primaryShade == "number" && !Wd(e.primaryShade))
    throw new Error(Vb);
}
function GY(e, t) {
  var r;
  if (!t)
    return zb(e), e;
  const n = dm(e, t);
  return t.fontFamily && !((r = t.headings) != null && r.fontFamily) && (n.headings.fontFamily = t.fontFamily), zb(n), n;
}
const ym = Xn(null), YY = () => Tn(ym) || bm;
function dn() {
  const e = Tn(ym);
  if (!e)
    throw new Error(
      "@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"
    );
  return e;
}
function fw({
  theme: e,
  children: t,
  inherit: n = !0
}) {
  const r = YY(), o = Me(
    () => GY(n ? r : bm, e),
    [e, r, n]
  );
  return /* @__PURE__ */ E.jsx(ym.Provider, { value: o, children: t });
}
fw.displayName = "@mantine/core/MantineThemeProvider";
function KY() {
  const e = dn(), t = mm(), n = gr(e.breakpoints).reduce((r, o) => {
    const i = e.breakpoints[o].includes("px"), s = tY(e.breakpoints[o]), a = i ? `${s - 0.1}px` : $b(s - 0.1), l = i ? `${s}px` : $b(s);
    return `${r}@media (max-width: ${a}) {.mantine-visible-from-${o} {display: none !important;}}@media (min-width: ${l}) {.mantine-hidden-from-${o} {display: none !important;}}`;
  }, "");
  return /* @__PURE__ */ E.jsx(
    "style",
    {
      "data-mantine-styles": "classes",
      nonce: t == null ? void 0 : t(),
      dangerouslySetInnerHTML: { __html: n }
    }
  );
}
function Gd(e) {
  return Object.entries(e).map(([t, n]) => `${t}: ${n};`).join("");
}
function hw(e, t) {
  const n = t ? [t] : [":root", ":host"], r = Gd(e.variables), o = r ? `${n.join(", ")}{${r}}` : "", i = Gd(e.dark), s = Gd(e.light), a = (u) => n.map(
    (d) => d === ":host" ? `${d}([data-mantine-color-scheme="${u}"])` : `${d}[data-mantine-color-scheme="${u}"]`
  ).join(", "), l = i ? `${a("dark")}{${i}}` : "", c = s ? `${a("light")}{${s}}` : "";
  return `${o}

${l}

${c}`;
}
function pw({ color: e, theme: t, autoContrast: n }) {
  return (typeof n == "boolean" ? n : t.autoContrast) && ti({ color: e || t.primaryColor, theme: t }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function qb(e, t) {
  return pw({
    color: e.colors[e.primaryColor][ta(e, t)],
    theme: e,
    autoContrast: null
  });
}
function sl({
  theme: e,
  color: t,
  colorScheme: n,
  name: r = t,
  withColorValues: o = !0
}) {
  if (!e.colors[t])
    return {};
  if (n === "light") {
    const a = ta(e, "light"), l = {
      [`--mantine-color-${r}-text`]: `var(--mantine-color-${r}-filled)`,
      [`--mantine-color-${r}-filled`]: `var(--mantine-color-${r}-${a})`,
      [`--mantine-color-${r}-filled-hover`]: `var(--mantine-color-${r}-${a === 9 ? 8 : a + 1})`,
      [`--mantine-color-${r}-light`]: ai(e.colors[t][a], 0.1),
      [`--mantine-color-${r}-light-hover`]: ai(e.colors[t][a], 0.12),
      [`--mantine-color-${r}-light-color`]: `var(--mantine-color-${r}-${a})`,
      [`--mantine-color-${r}-outline`]: `var(--mantine-color-${r}-${a})`,
      [`--mantine-color-${r}-outline-hover`]: ai(e.colors[t][a], 0.05)
    };
    return o ? {
      [`--mantine-color-${r}-0`]: e.colors[t][0],
      [`--mantine-color-${r}-1`]: e.colors[t][1],
      [`--mantine-color-${r}-2`]: e.colors[t][2],
      [`--mantine-color-${r}-3`]: e.colors[t][3],
      [`--mantine-color-${r}-4`]: e.colors[t][4],
      [`--mantine-color-${r}-5`]: e.colors[t][5],
      [`--mantine-color-${r}-6`]: e.colors[t][6],
      [`--mantine-color-${r}-7`]: e.colors[t][7],
      [`--mantine-color-${r}-8`]: e.colors[t][8],
      [`--mantine-color-${r}-9`]: e.colors[t][9],
      ...l
    } : l;
  }
  const i = ta(e, "dark"), s = {
    [`--mantine-color-${r}-text`]: `var(--mantine-color-${r}-4)`,
    [`--mantine-color-${r}-filled`]: `var(--mantine-color-${r}-${i})`,
    [`--mantine-color-${r}-filled-hover`]: `var(--mantine-color-${r}-${i === 9 ? 8 : i + 1})`,
    [`--mantine-color-${r}-light`]: ai(
      e.colors[t][Math.max(0, i - 2)],
      0.15
    ),
    [`--mantine-color-${r}-light-hover`]: ai(
      e.colors[t][Math.max(0, i - 2)],
      0.2
    ),
    [`--mantine-color-${r}-light-color`]: `var(--mantine-color-${r}-${Math.max(i - 5, 0)})`,
    [`--mantine-color-${r}-outline`]: `var(--mantine-color-${r}-${Math.max(i - 4, 0)})`,
    [`--mantine-color-${r}-outline-hover`]: ai(
      e.colors[t][Math.max(i - 4, 0)],
      0.05
    )
  };
  return o ? {
    [`--mantine-color-${r}-0`]: e.colors[t][0],
    [`--mantine-color-${r}-1`]: e.colors[t][1],
    [`--mantine-color-${r}-2`]: e.colors[t][2],
    [`--mantine-color-${r}-3`]: e.colors[t][3],
    [`--mantine-color-${r}-4`]: e.colors[t][4],
    [`--mantine-color-${r}-5`]: e.colors[t][5],
    [`--mantine-color-${r}-6`]: e.colors[t][6],
    [`--mantine-color-${r}-7`]: e.colors[t][7],
    [`--mantine-color-${r}-8`]: e.colors[t][8],
    [`--mantine-color-${r}-9`]: e.colors[t][9],
    ...s
  } : s;
}
function QY(e) {
  return !!e && typeof e == "object" && "mantine-virtual-color" in e;
}
function li(e, t, n) {
  gr(t).forEach(
    (r) => Object.assign(e, { [`--mantine-${n}-${r}`]: t[r] })
  );
}
const mw = (e) => {
  const t = ta(e, "light"), n = e.defaultRadius in e.radius ? e.radius[e.defaultRadius] : U(e.defaultRadius), r = {
    variables: {
      "--mantine-z-index-app": "100",
      "--mantine-z-index-modal": "200",
      "--mantine-z-index-popover": "300",
      "--mantine-z-index-overlay": "400",
      "--mantine-z-index-max": "9999",
      "--mantine-scale": e.scale.toString(),
      "--mantine-cursor-type": e.cursorType,
      "--mantine-webkit-font-smoothing": e.fontSmoothing ? "antialiased" : "unset",
      "--mantine-moz-font-smoothing": e.fontSmoothing ? "grayscale" : "unset",
      "--mantine-color-white": e.white,
      "--mantine-color-black": e.black,
      "--mantine-line-height": e.lineHeights.md,
      "--mantine-font-family": e.fontFamily,
      "--mantine-font-family-monospace": e.fontFamilyMonospace,
      "--mantine-font-family-headings": e.headings.fontFamily,
      "--mantine-heading-font-weight": e.headings.fontWeight,
      "--mantine-heading-text-wrap": e.headings.textWrap,
      "--mantine-radius-default": n,
      // Primary colors
      "--mantine-primary-color-filled": `var(--mantine-color-${e.primaryColor}-filled)`,
      "--mantine-primary-color-filled-hover": `var(--mantine-color-${e.primaryColor}-filled-hover)`,
      "--mantine-primary-color-light": `var(--mantine-color-${e.primaryColor}-light)`,
      "--mantine-primary-color-light-hover": `var(--mantine-color-${e.primaryColor}-light-hover)`,
      "--mantine-primary-color-light-color": `var(--mantine-color-${e.primaryColor}-light-color)`
    },
    light: {
      "--mantine-color-scheme": "light",
      "--mantine-primary-color-contrast": qb(e, "light"),
      "--mantine-color-bright": "var(--mantine-color-black)",
      "--mantine-color-text": e.black,
      "--mantine-color-body": e.white,
      "--mantine-color-error": "var(--mantine-color-red-6)",
      "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
      "--mantine-color-anchor": `var(--mantine-color-${e.primaryColor}-${t})`,
      "--mantine-color-default": "var(--mantine-color-white)",
      "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
      "--mantine-color-default-color": "var(--mantine-color-black)",
      "--mantine-color-default-border": "var(--mantine-color-gray-4)",
      "--mantine-color-dimmed": "var(--mantine-color-gray-6)",
      "--mantine-color-disabled": "var(--mantine-color-gray-2)",
      "--mantine-color-disabled-color": "var(--mantine-color-gray-5)",
      "--mantine-color-disabled-border": "var(--mantine-color-gray-3)"
    },
    dark: {
      "--mantine-color-scheme": "dark",
      "--mantine-primary-color-contrast": qb(e, "dark"),
      "--mantine-color-bright": "var(--mantine-color-white)",
      "--mantine-color-text": "var(--mantine-color-dark-0)",
      "--mantine-color-body": "var(--mantine-color-dark-7)",
      "--mantine-color-error": "var(--mantine-color-red-8)",
      "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
      "--mantine-color-anchor": `var(--mantine-color-${e.primaryColor}-4)`,
      "--mantine-color-default": "var(--mantine-color-dark-6)",
      "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
      "--mantine-color-default-color": "var(--mantine-color-white)",
      "--mantine-color-default-border": "var(--mantine-color-dark-4)",
      "--mantine-color-dimmed": "var(--mantine-color-dark-2)",
      "--mantine-color-disabled": "var(--mantine-color-dark-6)",
      "--mantine-color-disabled-color": "var(--mantine-color-dark-3)",
      "--mantine-color-disabled-border": "var(--mantine-color-dark-4)"
    }
  };
  li(r.variables, e.breakpoints, "breakpoint"), li(r.variables, e.spacing, "spacing"), li(r.variables, e.fontSizes, "font-size"), li(r.variables, e.lineHeights, "line-height"), li(r.variables, e.shadows, "shadow"), li(r.variables, e.radius, "radius"), e.colors[e.primaryColor].forEach((i, s) => {
    r.variables[`--mantine-primary-color-${s}`] = `var(--mantine-color-${e.primaryColor}-${s})`;
  }), gr(e.colors).forEach((i) => {
    const s = e.colors[i];
    if (QY(s)) {
      Object.assign(
        r.light,
        sl({
          theme: e,
          name: s.name,
          color: s.light,
          colorScheme: "light",
          withColorValues: !0
        })
      ), Object.assign(
        r.dark,
        sl({
          theme: e,
          name: s.name,
          color: s.dark,
          colorScheme: "dark",
          withColorValues: !0
        })
      );
      return;
    }
    s.forEach((a, l) => {
      r.variables[`--mantine-color-${i}-${l}`] = a;
    }), Object.assign(
      r.light,
      sl({
        theme: e,
        color: i,
        colorScheme: "light",
        withColorValues: !1
      })
    ), Object.assign(
      r.dark,
      sl({
        theme: e,
        color: i,
        colorScheme: "dark",
        withColorValues: !1
      })
    );
  });
  const o = e.headings.sizes;
  return gr(o).forEach((i) => {
    r.variables[`--mantine-${i}-font-size`] = o[i].fontSize, r.variables[`--mantine-${i}-line-height`] = o[i].lineHeight, r.variables[`--mantine-${i}-font-weight`] = o[i].fontWeight || e.headings.fontWeight;
  }), r;
};
function ZY({ theme: e, generator: t }) {
  const n = mw(e), r = t == null ? void 0 : t(e);
  return r ? dm(n, r) : n;
}
const Yd = mw(bm);
function XY(e) {
  const t = {
    variables: {},
    light: {},
    dark: {}
  };
  return gr(e.variables).forEach((n) => {
    Yd.variables[n] !== e.variables[n] && (t.variables[n] = e.variables[n]);
  }), gr(e.light).forEach((n) => {
    Yd.light[n] !== e.light[n] && (t.light[n] = e.light[n]);
  }), gr(e.dark).forEach((n) => {
    Yd.dark[n] !== e.dark[n] && (t.dark[n] = e.dark[n]);
  }), t;
}
function JY(e) {
  return hw(
    {
      variables: {},
      dark: { "--mantine-color-scheme": "dark" },
      light: { "--mantine-color-scheme": "light" }
    },
    e
  );
}
function gw({
  cssVariablesSelector: e,
  deduplicateCssVariables: t
}) {
  const n = dn(), r = mm(), o = MY(), i = ZY({ theme: n, generator: o }), s = (e === void 0 || e === ":root" || e === ":host") && t, a = s ? XY(i) : i, l = hw(a, e);
  return l ? /* @__PURE__ */ E.jsx(
    "style",
    {
      "data-mantine-styles": !0,
      nonce: r == null ? void 0 : r(),
      dangerouslySetInnerHTML: {
        __html: `${l}${s ? "" : JY(e)}`
      }
    }
  ) : null;
}
gw.displayName = "@mantine/CssVariables";
function ci(e, t) {
  var o, i;
  const n = typeof window < "u" && "matchMedia" in window && ((o = window.matchMedia("(prefers-color-scheme: dark)")) == null ? void 0 : o.matches), r = e !== "auto" ? e : n ? "dark" : "light";
  (i = t()) == null || i.setAttribute("data-mantine-color-scheme", r);
}
function eK({
  manager: e,
  defaultColorScheme: t,
  getRootElement: n,
  forceColorScheme: r
}) {
  const o = Ae(null), [i, s] = fe(() => e.get(t)), a = r || i, l = Z(
    (u) => {
      r || (ci(u, n), s(u), e.set(u));
    },
    [e.set, a, r]
  ), c = Z(() => {
    s(t), ci(t, n), e.clear();
  }, [e.clear, t]);
  return ie(() => (e.subscribe(l), e.unsubscribe), [e.subscribe, e.unsubscribe]), Ta(() => {
    ci(e.get(t), n);
  }, []), ie(() => {
    var d;
    if (r)
      return ci(r, n), () => {
      };
    r === void 0 && ci(i, n), typeof window < "u" && "matchMedia" in window && (o.current = window.matchMedia("(prefers-color-scheme: dark)"));
    const u = (f) => {
      i === "auto" && ci(f.matches ? "dark" : "light", n);
    };
    return (d = o.current) == null || d.addEventListener("change", u), () => {
      var f;
      return (f = o.current) == null ? void 0 : f.removeEventListener("change", u);
    };
  }, [i, r]), { colorScheme: a, setColorScheme: l, clearColorScheme: c };
}
function tK({
  respectReducedMotion: e,
  getRootElement: t
}) {
  Ta(() => {
    var n;
    e && ((n = t()) == null || n.setAttribute("data-respect-reduced-motion", "true"));
  }, [e]);
}
function bw({
  theme: e,
  children: t,
  getStyleNonce: n,
  withStaticClasses: r = !0,
  withGlobalClasses: o = !0,
  deduplicateCssVariables: i = !0,
  withCssVariables: s = !0,
  cssVariablesSelector: a,
  classNamesPrefix: l = "mantine",
  colorSchemeManager: c = qY(),
  defaultColorScheme: u = "light",
  getRootElement: d = () => document.documentElement,
  cssVariablesResolver: f,
  forceColorScheme: h,
  stylesTransform: p,
  env: m
}) {
  const { colorScheme: b, setColorScheme: y, clearColorScheme: k } = eK({
    defaultColorScheme: u,
    forceColorScheme: h,
    manager: c,
    getRootElement: d
  });
  return tK({
    respectReducedMotion: (e == null ? void 0 : e.respectReducedMotion) || !1,
    getRootElement: d
  }), /* @__PURE__ */ E.jsx(
    pm.Provider,
    {
      value: {
        colorScheme: b,
        setColorScheme: y,
        clearColorScheme: k,
        getRootElement: d,
        classNamesPrefix: l,
        getStyleNonce: n,
        cssVariablesResolver: f,
        cssVariablesSelector: a ?? ":root",
        withStaticClasses: r,
        stylesTransform: p,
        env: m
      },
      children: /* @__PURE__ */ E.jsxs(fw, { theme: e, children: [
        s && /* @__PURE__ */ E.jsx(
          gw,
          {
            cssVariablesSelector: a,
            deduplicateCssVariables: i
          }
        ),
        o && /* @__PURE__ */ E.jsx(KY, {}),
        t
      ] })
    }
  );
}
bw.displayName = "@mantine/core/MantineProvider";
function wu({
  classNames: e,
  styles: t,
  props: n,
  stylesCtx: r
}) {
  const o = dn();
  return {
    resolvedClassNames: Tu({
      theme: o,
      classNames: e,
      props: n,
      stylesCtx: r || void 0
    }),
    resolvedStyles: yc({
      theme: o,
      styles: t,
      props: n,
      stylesCtx: r || void 0
    })
  };
}
const nK = {
  always: "mantine-focus-always",
  auto: "mantine-focus-auto",
  never: "mantine-focus-never"
};
function rK({ theme: e, options: t, unstyled: n }) {
  return Ur(
    (t == null ? void 0 : t.focusable) && !n && (e.focusClassName || nK[e.focusRing]),
    (t == null ? void 0 : t.active) && !n && e.activeClassName
  );
}
function oK({
  selector: e,
  stylesCtx: t,
  options: n,
  props: r,
  theme: o
}) {
  return Tu({
    theme: o,
    classNames: n == null ? void 0 : n.classNames,
    props: (n == null ? void 0 : n.props) || r,
    stylesCtx: t
  })[e];
}
function Wb({
  selector: e,
  stylesCtx: t,
  theme: n,
  classNames: r,
  props: o
}) {
  return Tu({ theme: n, classNames: r, props: o, stylesCtx: t })[e];
}
function iK({ rootSelector: e, selector: t, className: n }) {
  return e === t ? n : void 0;
}
function sK({ selector: e, classes: t, unstyled: n }) {
  return n ? void 0 : t[e];
}
function aK({
  themeName: e,
  classNamesPrefix: t,
  selector: n,
  withStaticClass: r
}) {
  return r === !1 ? [] : e.map((o) => `${t}-${o}-${n}`);
}
function lK({
  themeName: e,
  theme: t,
  selector: n,
  props: r,
  stylesCtx: o
}) {
  return e.map(
    (i) => {
      var s, a;
      return (a = Tu({
        theme: t,
        classNames: (s = t.components[i]) == null ? void 0 : s.classNames,
        props: r,
        stylesCtx: o
      })) == null ? void 0 : a[n];
    }
  );
}
function cK({
  options: e,
  classes: t,
  selector: n,
  unstyled: r
}) {
  return e != null && e.variant && !r ? t[`${n}--${e.variant}`] : void 0;
}
function uK({
  theme: e,
  options: t,
  themeName: n,
  selector: r,
  classNamesPrefix: o,
  classNames: i,
  classes: s,
  unstyled: a,
  className: l,
  rootSelector: c,
  props: u,
  stylesCtx: d,
  withStaticClasses: f,
  headless: h,
  transformedStyles: p
}) {
  return Ur(
    rK({ theme: e, options: t, unstyled: a || h }),
    lK({ theme: e, themeName: n, selector: r, props: u, stylesCtx: d }),
    cK({ options: t, classes: s, selector: r, unstyled: a }),
    Wb({ selector: r, stylesCtx: d, theme: e, classNames: i, props: u }),
    Wb({ selector: r, stylesCtx: d, theme: e, classNames: p, props: u }),
    oK({ selector: r, stylesCtx: d, options: t, props: u, theme: e }),
    iK({ rootSelector: c, selector: r, className: l }),
    sK({ selector: r, classes: s, unstyled: a || h }),
    f && !h && aK({
      themeName: n,
      classNamesPrefix: o,
      selector: r,
      withStaticClass: t == null ? void 0 : t.withStaticClass
    }),
    t == null ? void 0 : t.className
  );
}
function dK({
  theme: e,
  themeName: t,
  props: n,
  stylesCtx: r,
  selector: o
}) {
  return t.map(
    (i) => {
      var s;
      return yc({
        theme: e,
        styles: (s = e.components[i]) == null ? void 0 : s.styles,
        props: n,
        stylesCtx: r
      })[o];
    }
  ).reduce((i, s) => ({ ...i, ...s }), {});
}
function ph({ style: e, theme: t }) {
  return Array.isArray(e) ? [...e].reduce(
    (n, r) => ({ ...n, ...ph({ style: r, theme: t }) }),
    {}
  ) : typeof e == "function" ? e(t) : e ?? {};
}
function fK(e) {
  return e.reduce((t, n) => (n && Object.keys(n).forEach((r) => {
    t[r] = { ...t[r], ...yu(n[r]) };
  }), t), {});
}
function hK({
  vars: e,
  varsResolver: t,
  theme: n,
  props: r,
  stylesCtx: o,
  selector: i,
  themeName: s,
  headless: a
}) {
  var l;
  return (l = fK([
    a ? {} : t == null ? void 0 : t(n, r, o),
    ...s.map((c) => {
      var u, d, f;
      return (f = (d = (u = n.components) == null ? void 0 : u[c]) == null ? void 0 : d.vars) == null ? void 0 : f.call(d, n, r, o);
    }),
    e == null ? void 0 : e(n, r, o)
  ])) == null ? void 0 : l[i];
}
function pK({
  theme: e,
  themeName: t,
  selector: n,
  options: r,
  props: o,
  stylesCtx: i,
  rootSelector: s,
  styles: a,
  style: l,
  vars: c,
  varsResolver: u,
  headless: d,
  withStylesTransform: f
}) {
  return {
    ...!f && dK({ theme: e, themeName: t, props: o, stylesCtx: i, selector: n }),
    ...!f && yc({ theme: e, styles: a, props: o, stylesCtx: i })[n],
    ...!f && yc({ theme: e, styles: r == null ? void 0 : r.styles, props: (r == null ? void 0 : r.props) || o, stylesCtx: i })[n],
    ...hK({ theme: e, props: o, stylesCtx: i, vars: c, varsResolver: u, selector: n, themeName: t, headless: d }),
    ...s === n ? ph({ style: l, theme: e }) : null,
    ...ph({ style: r == null ? void 0 : r.style, theme: e })
  };
}
function mK({ props: e, stylesCtx: t, themeName: n }) {
  var s;
  const r = dn(), o = (s = PY()) == null ? void 0 : s();
  return {
    getTransformedStyles: (a) => o ? [
      ...a.map(
        (c) => o(c, { props: e, theme: r, ctx: t })
      ),
      ...n.map(
        (c) => {
          var u;
          return o((u = r.components[c]) == null ? void 0 : u.styles, { props: e, theme: r, ctx: t });
        }
      )
    ].filter(Boolean) : [],
    withStylesTransform: !!o
  };
}
function Oe({
  name: e,
  classes: t,
  props: n,
  stylesCtx: r,
  className: o,
  style: i,
  rootSelector: s = "root",
  unstyled: a,
  classNames: l,
  styles: c,
  vars: u,
  varsResolver: d,
  attributes: f
}) {
  const h = dn(), p = LY(), m = OY(), b = DY(), y = (Array.isArray(e) ? e : [e]).filter((_) => _), { withStylesTransform: k, getTransformedStyles: C } = mK({
    props: n,
    stylesCtx: r,
    themeName: y
  });
  return (_, w) => ({
    className: uK({
      theme: h,
      options: w,
      themeName: y,
      selector: _,
      classNamesPrefix: p,
      classNames: l,
      classes: t,
      unstyled: a,
      className: o,
      rootSelector: s,
      props: n,
      stylesCtx: r,
      withStaticClasses: m,
      headless: b,
      transformedStyles: C([w == null ? void 0 : w.styles, c])
    }),
    style: pK({
      theme: h,
      themeName: y,
      selector: _,
      options: w,
      props: n,
      stylesCtx: r,
      rootSelector: s,
      styles: c,
      style: i,
      vars: u,
      varsResolver: d,
      headless: b,
      withStylesTransform: k
    }),
    ...f == null ? void 0 : f[_]
  });
}
function gK(e, t) {
  return typeof e == "boolean" ? e : t.autoContrast;
}
function X(e, t, n) {
  var s;
  const r = dn(), o = (s = r.components[e]) == null ? void 0 : s.defaultProps, i = typeof o == "function" ? o(r) : o;
  return { ...t, ...i, ...yu(n) };
}
function Kd(e) {
  return gr(e).reduce(
    (t, n) => e[n] !== void 0 ? `${t}${JG(n)}:${e[n]};` : t,
    ""
  ).trim();
}
function bK({ selector: e, styles: t, media: n, container: r }) {
  const o = t ? Kd(t) : "", i = Array.isArray(n) ? n.map((a) => `@media${a.query}{${e}{${Kd(a.styles)}}}`) : [], s = Array.isArray(r) ? r.map(
    (a) => `@container ${a.query}{${e}{${Kd(a.styles)}}}`
  ) : [];
  return `${o ? `${e}{${o}}` : ""}${i.join("")}${s.join("")}`.trim();
}
function yw(e) {
  const t = mm();
  return /* @__PURE__ */ E.jsx(
    "style",
    {
      "data-mantine-styles": "inline",
      nonce: t == null ? void 0 : t(),
      dangerouslySetInnerHTML: { __html: bK(e) }
    }
  );
}
function vu(e) {
  const {
    m: t,
    mx: n,
    my: r,
    mt: o,
    mb: i,
    ml: s,
    mr: a,
    me: l,
    ms: c,
    p: u,
    px: d,
    py: f,
    pt: h,
    pb: p,
    pl: m,
    pr: b,
    pe: y,
    ps: k,
    bd: C,
    bdrs: _,
    bg: w,
    c: T,
    opacity: M,
    ff: D,
    fz: R,
    fw: N,
    lts: B,
    ta: F,
    lh: W,
    fs: L,
    tt: H,
    td: J,
    w: Y,
    miw: V,
    maw: Q,
    h: S,
    mih: ue,
    mah: ee,
    bgsz: A,
    bgp: le,
    bgr: ge,
    bga: Ee,
    pos: Qe,
    top: Te,
    left: ce,
    bottom: nt,
    right: pt,
    inset: mt,
    display: je,
    flex: Vt,
    hiddenFrom: Un,
    visibleFrom: vr,
    lightHidden: Sr,
    darkHidden: _r,
    sx: zt,
    ...qr
  } = e;
  return { styleProps: yu({
    m: t,
    mx: n,
    my: r,
    mt: o,
    mb: i,
    ml: s,
    mr: a,
    me: l,
    ms: c,
    p: u,
    px: d,
    py: f,
    pt: h,
    pb: p,
    pl: m,
    pr: b,
    pe: y,
    ps: k,
    bd: C,
    bg: w,
    c: T,
    opacity: M,
    ff: D,
    fz: R,
    fw: N,
    lts: B,
    ta: F,
    lh: W,
    fs: L,
    tt: H,
    td: J,
    w: Y,
    miw: V,
    maw: Q,
    h: S,
    mih: ue,
    mah: ee,
    bgsz: A,
    bgp: le,
    bgr: ge,
    bga: Ee,
    pos: Qe,
    top: Te,
    left: ce,
    bottom: nt,
    right: pt,
    inset: mt,
    display: je,
    flex: Vt,
    bdrs: _,
    hiddenFrom: Un,
    visibleFrom: vr,
    lightHidden: Sr,
    darkHidden: _r,
    sx: zt
  }), rest: qr };
}
const yK = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  ms: { type: "spacing", property: "marginInlineStart" },
  me: { type: "spacing", property: "marginInlineEnd" },
  mx: { type: "spacing", property: "marginInline" },
  my: { type: "spacing", property: "marginBlock" },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  ps: { type: "spacing", property: "paddingInlineStart" },
  pe: { type: "spacing", property: "paddingInlineEnd" },
  px: { type: "spacing", property: "paddingInline" },
  py: { type: "spacing", property: "paddingBlock" },
  bd: { type: "border", property: "border" },
  bdrs: { type: "radius", property: "borderRadius" },
  bg: { type: "color", property: "background" },
  c: { type: "textColor", property: "color" },
  opacity: { type: "identity", property: "opacity" },
  ff: { type: "fontFamily", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "identity", property: "fontWeight" },
  lts: { type: "size", property: "letterSpacing" },
  ta: { type: "identity", property: "textAlign" },
  lh: { type: "lineHeight", property: "lineHeight" },
  fs: { type: "identity", property: "fontStyle" },
  tt: { type: "identity", property: "textTransform" },
  td: { type: "identity", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "size", property: "backgroundSize" },
  bgp: { type: "identity", property: "backgroundPosition" },
  bgr: { type: "identity", property: "backgroundRepeat" },
  bga: { type: "identity", property: "backgroundAttachment" },
  pos: { type: "identity", property: "position" },
  top: { type: "size", property: "top" },
  left: { type: "size", property: "left" },
  bottom: { type: "size", property: "bottom" },
  right: { type: "size", property: "right" },
  inset: { type: "size", property: "inset" },
  display: { type: "identity", property: "display" },
  flex: { type: "identity", property: "flex" }
};
function Em(e, t) {
  const n = ti({ color: e, theme: t });
  return n.color === "dimmed" ? "var(--mantine-color-dimmed)" : n.color === "bright" ? "var(--mantine-color-bright)" : n.variable ? `var(${n.variable})` : n.color;
}
function EK(e, t) {
  const n = ti({ color: e, theme: t });
  return n.isThemeColor && n.shade === void 0 ? `var(--mantine-color-${n.color}-text)` : Em(e, t);
}
function kK(e, t) {
  if (typeof e == "number")
    return U(e);
  if (typeof e == "string") {
    const [n, r, ...o] = e.split(" ").filter((s) => s.trim() !== "");
    let i = `${U(n)}`;
    return r && (i += ` ${r}`), o.length > 0 && (i += ` ${Em(o.join(" "), t)}`), i.trim();
  }
  return e;
}
const Gb = {
  text: "var(--mantine-font-family)",
  mono: "var(--mantine-font-family-monospace)",
  monospace: "var(--mantine-font-family-monospace)",
  heading: "var(--mantine-font-family-headings)",
  headings: "var(--mantine-font-family-headings)"
};
function CK(e) {
  return typeof e == "string" && e in Gb ? Gb[e] : e;
}
const TK = ["h1", "h2", "h3", "h4", "h5", "h6"];
function xK(e, t) {
  return typeof e == "string" && e in t.fontSizes ? `var(--mantine-font-size-${e})` : typeof e == "string" && TK.includes(e) ? `var(--mantine-${e}-font-size)` : typeof e == "number" || typeof e == "string" ? U(e) : e;
}
function wK(e) {
  return e;
}
const vK = ["h1", "h2", "h3", "h4", "h5", "h6"];
function SK(e, t) {
  return typeof e == "string" && e in t.lineHeights ? `var(--mantine-line-height-${e})` : typeof e == "string" && vK.includes(e) ? `var(--mantine-${e}-line-height)` : e;
}
function _K(e, t) {
  return typeof e == "string" && e in t.radius ? `var(--mantine-radius-${e})` : typeof e == "number" || typeof e == "string" ? U(e) : e;
}
function AK(e) {
  return typeof e == "number" ? U(e) : e;
}
function IK(e, t) {
  if (typeof e == "number")
    return U(e);
  if (typeof e == "string") {
    const n = e.replace("-", "");
    if (!(n in t.spacing))
      return U(e);
    const r = `--mantine-spacing-${n}`;
    return e.startsWith("-") ? `calc(var(${r}) * -1)` : `var(${r})`;
  }
  return e;
}
const Qd = {
  color: Em,
  textColor: EK,
  fontSize: xK,
  spacing: IK,
  radius: _K,
  identity: wK,
  size: AK,
  lineHeight: SK,
  fontFamily: CK,
  border: kK
};
function Yb(e) {
  return e.replace("(min-width: ", "").replace("em)", "");
}
function NK({
  media: e,
  ...t
}) {
  const r = Object.keys(e).sort((o, i) => Number(Yb(o)) - Number(Yb(i))).map((o) => ({ query: o, styles: e[o] }));
  return { ...t, media: r };
}
function MK(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.keys(e);
  return !(t.length === 1 && t[0] === "base");
}
function LK(e) {
  return typeof e == "object" && e !== null ? "base" in e ? e.base : void 0 : e;
}
function OK(e) {
  return typeof e == "object" && e !== null ? gr(e).filter((t) => t !== "base") : [];
}
function DK(e, t) {
  return typeof e == "object" && e !== null && t in e ? e[t] : e;
}
function Ew({
  styleProps: e,
  data: t,
  theme: n
}) {
  return NK(
    gr(e).reduce(
      (r, o) => {
        if (o === "hiddenFrom" || o === "visibleFrom" || o === "sx")
          return r;
        const i = t[o], s = Array.isArray(i.property) ? i.property : [i.property], a = LK(e[o]);
        if (!MK(e[o]))
          return s.forEach((c) => {
            r.inlineStyles[c] = Qd[i.type](a, n);
          }), r;
        r.hasResponsiveStyles = !0;
        const l = OK(e[o]);
        return s.forEach((c) => {
          a != null && (r.styles[c] = Qd[i.type](a, n)), l.forEach((u) => {
            const d = `(min-width: ${n.breakpoints[u]})`;
            r.media[d] = {
              ...r.media[d],
              [c]: Qd[i.type](
                DK(e[o], u),
                n
              )
            };
          });
        }), r;
      },
      {
        hasResponsiveStyles: !1,
        styles: {},
        inlineStyles: {},
        media: {}
      }
    )
  );
}
function kw() {
  return `__m__-${Fv().replace(/[:]/g, "")}`;
}
function Cw(e, t) {
  return Array.isArray(e) ? [...e].reduce(
    (n, r) => ({ ...n, ...Cw(r, t) }),
    {}
  ) : typeof e == "function" ? e(t) : e ?? {};
}
function Tw(e) {
  return e.startsWith("data-") ? e : `data-${e}`;
}
function RK(e) {
  return Object.keys(e).reduce((t, n) => {
    const r = e[n];
    return r === void 0 || r === "" || r === !1 || r === null || (t[Tw(n)] = e[n]), t;
  }, {});
}
function xw(e) {
  return e ? typeof e == "string" ? { [Tw(e)]: !0 } : Array.isArray(e) ? [...e].reduce(
    (t, n) => ({ ...t, ...xw(n) }),
    {}
  ) : RK(e) : null;
}
function mh(e, t) {
  return Array.isArray(e) ? [...e].reduce(
    (n, r) => ({ ...n, ...mh(r, t) }),
    {}
  ) : typeof e == "function" ? e(t) : e ?? {};
}
function PK({
  theme: e,
  style: t,
  vars: n,
  styleProps: r
}) {
  const o = mh(t, e), i = mh(n, e);
  return { ...o, ...i, ...r };
}
const ww = se(
  ({
    component: e,
    style: t,
    __vars: n,
    className: r,
    variant: o,
    mod: i,
    size: s,
    hiddenFrom: a,
    visibleFrom: l,
    lightHidden: c,
    darkHidden: u,
    renderRoot: d,
    __size: f,
    ...h
  }, p) => {
    var D;
    const m = dn(), b = e || "div", { styleProps: y, rest: k } = vu(h), C = RY(), _ = (D = C == null ? void 0 : C()) == null ? void 0 : D(y.sx), w = kw(), T = Ew({
      styleProps: y,
      theme: m,
      data: yK
    }), M = {
      ref: p,
      style: PK({
        theme: m,
        style: t,
        vars: n,
        styleProps: T.inlineStyles
      }),
      className: Ur(r, _, {
        [w]: T.hasResponsiveStyles,
        "mantine-light-hidden": c,
        "mantine-dark-hidden": u,
        [`mantine-hidden-from-${a}`]: a,
        [`mantine-visible-from-${l}`]: l
      }),
      "data-variant": o,
      "data-size": iw(s) ? void 0 : s || void 0,
      size: f,
      ...xw(i),
      ...k
    };
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      T.hasResponsiveStyles && /* @__PURE__ */ E.jsx(
        yw,
        {
          selector: `.${w}`,
          styles: T.styles,
          media: T.media
        }
      ),
      typeof d == "function" ? d(M) : /* @__PURE__ */ E.jsx(b, { ...M })
    ] });
  }
);
ww.displayName = "@mantine/core/Box";
const de = ww;
function vw(e) {
  return e;
}
function BK(e) {
  const t = e;
  return (n) => {
    const r = se((o, i) => /* @__PURE__ */ E.jsx(t, { ...n, ...o, ref: i }));
    return r.extend = t.extend, r.displayName = `WithProps(${t.displayName})`, r;
  };
}
function De(e) {
  const t = se(e);
  return t.extend = vw, t.withProps = (n) => {
    const r = se((o, i) => /* @__PURE__ */ E.jsx(t, { ...n, ...o, ref: i }));
    return r.extend = t.extend, r.displayName = `WithProps(${t.displayName})`, r;
  }, t;
}
function jt(e) {
  const t = se(e);
  return t.withProps = (n) => {
    const r = se((o, i) => /* @__PURE__ */ E.jsx(t, { ...n, ...o, ref: i }));
    return r.extend = t.extend, r.displayName = `WithProps(${t.displayName})`, r;
  }, t.extend = vw, t;
}
const $K = Xn({
  dir: "ltr",
  toggleDirection: () => {
  },
  setDirection: () => {
  }
});
function Xi() {
  return Tn($K);
}
var Sw = { root: "m_87cf2631" };
const HK = {
  __staticSelector: "UnstyledButton"
}, To = jt(
  (e, t) => {
    const n = X("UnstyledButton", HK, e), {
      className: r,
      component: o = "button",
      __staticSelector: i,
      unstyled: s,
      classNames: a,
      styles: l,
      style: c,
      attributes: u,
      ...d
    } = n, f = Oe({
      name: i,
      props: n,
      classes: Sw,
      className: r,
      style: c,
      classNames: a,
      styles: l,
      unstyled: s,
      attributes: u
    });
    return /* @__PURE__ */ E.jsx(
      de,
      {
        ...f("root", { focusable: !0 }),
        component: o,
        ref: t,
        type: o === "button" ? "button" : void 0,
        ...d
      }
    );
  }
);
To.classes = Sw;
To.displayName = "@mantine/core/UnstyledButton";
var _w = { root: "m_515a97f8" };
const km = De((e, t) => {
  const n = X("VisuallyHidden", null, e), { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, attributes: c, ...u } = n, d = Oe({
    name: "VisuallyHidden",
    classes: _w,
    props: n,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: c
  });
  return /* @__PURE__ */ E.jsx(de, { component: "span", ref: t, ...d("root"), ...u });
});
km.classes = _w;
km.displayName = "@mantine/core/VisuallyHidden";
var Aw = { root: "m_1b7284a3" };
const FK = (e, { radius: t, shadow: n }) => ({
  root: {
    "--paper-radius": t === void 0 ? void 0 : Ut(t),
    "--paper-shadow": aw(n)
  }
}), Cm = jt((e, t) => {
  const n = X("Paper", null, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    withBorder: l,
    vars: c,
    radius: u,
    shadow: d,
    variant: f,
    mod: h,
    attributes: p,
    ...m
  } = n, b = Oe({
    name: "Paper",
    props: n,
    classes: Aw,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: p,
    vars: c,
    varsResolver: FK
  });
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ref: t,
      mod: [{ "data-with-border": l }, h],
      ...b("root"),
      variant: f,
      ...m
    }
  );
});
Cm.classes = Aw;
Cm.displayName = "@mantine/core/Paper";
function Kb(e, t, n, r) {
  return e === "center" || r === "center" ? { top: t } : e === "end" ? { bottom: n } : e === "start" ? { top: n } : {};
}
function Qb(e, t, n, r, o) {
  return e === "center" || r === "center" ? { left: t } : e === "end" ? { [o === "ltr" ? "right" : "left"]: n } : e === "start" ? { [o === "ltr" ? "left" : "right"]: n } : {};
}
const UK = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function jK({
  position: e,
  arrowSize: t,
  arrowOffset: n,
  arrowRadius: r,
  arrowPosition: o,
  arrowX: i,
  arrowY: s,
  dir: a
}) {
  const [l, c = "center"] = e.split("-"), u = {
    width: t,
    height: t,
    transform: "rotate(45deg)",
    position: "absolute",
    [UK[l]]: r
  }, d = -t / 2;
  return l === "left" ? {
    ...u,
    ...Kb(c, s, n, o),
    right: d,
    borderLeftColor: "transparent",
    borderBottomColor: "transparent",
    clipPath: "polygon(100% 0, 0 0, 100% 100%)"
  } : l === "right" ? {
    ...u,
    ...Kb(c, s, n, o),
    left: d,
    borderRightColor: "transparent",
    borderTopColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 100%)"
  } : l === "top" ? {
    ...u,
    ...Qb(c, i, n, o, a),
    bottom: d,
    borderTopColor: "transparent",
    borderLeftColor: "transparent",
    clipPath: "polygon(0 100%, 100% 100%, 100% 0)"
  } : l === "bottom" ? {
    ...u,
    ...Qb(c, i, n, o, a),
    top: d,
    borderBottomColor: "transparent",
    borderRightColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 0)"
  } : {};
}
const Ec = se(
  ({
    position: e,
    arrowSize: t,
    arrowOffset: n,
    arrowRadius: r,
    arrowPosition: o,
    visible: i,
    arrowX: s,
    arrowY: a,
    style: l,
    ...c
  }, u) => {
    const { dir: d } = Xi();
    return i ? /* @__PURE__ */ E.jsx(
      "div",
      {
        ...c,
        ref: u,
        style: {
          ...l,
          ...jK({
            position: e,
            arrowSize: t,
            arrowOffset: n,
            arrowRadius: r,
            arrowPosition: o,
            dir: d,
            arrowX: s,
            arrowY: a
          })
        }
      }
    ) : null;
  }
);
Ec.displayName = "@mantine/core/FloatingArrow";
function Iw(e, t) {
  if (e === "rtl" && (t.includes("right") || t.includes("left"))) {
    const [n, r] = t.split("-"), o = n === "right" ? "left" : "right";
    return r === void 0 ? o : `${o}-${r}`;
  }
  return t;
}
var Nw = { root: "m_9814e45f" };
const VK = {
  zIndex: ka("modal")
}, zK = (e, { gradient: t, color: n, backgroundOpacity: r, blur: o, radius: i, zIndex: s }) => ({
  root: {
    "--overlay-bg": t || (n !== void 0 || r !== void 0) && ur(n || "#000", r ?? 0.6) || void 0,
    "--overlay-filter": o ? `blur(${U(o)})` : void 0,
    "--overlay-radius": i === void 0 ? void 0 : Ut(i),
    "--overlay-z-index": s == null ? void 0 : s.toString()
  }
}), na = jt((e, t) => {
  const n = X("Overlay", VK, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    fixed: c,
    center: u,
    children: d,
    radius: f,
    zIndex: h,
    gradient: p,
    blur: m,
    color: b,
    backgroundOpacity: y,
    mod: k,
    attributes: C,
    ..._
  } = n, w = Oe({
    name: "Overlay",
    props: n,
    classes: Nw,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: C,
    vars: l,
    varsResolver: zK
  });
  return /* @__PURE__ */ E.jsx(de, { ref: t, ...w("root"), mod: [{ center: u, fixed: c }, k], ..._, children: d });
});
na.classes = Nw;
na.displayName = "@mantine/core/Overlay";
function Zd(e) {
  const t = document.createElement("div");
  return t.setAttribute("data-portal", "true"), typeof e.className == "string" && t.classList.add(...e.className.split(" ").filter(Boolean)), typeof e.style == "object" && Object.assign(t.style, e.style), typeof e.id == "string" && t.setAttribute("id", e.id), t;
}
function qK({ target: e, reuseTargetNode: t, ...n }) {
  if (e)
    return typeof e == "string" ? document.querySelector(e) || Zd(n) : e;
  if (t) {
    const r = document.querySelector("[data-mantine-shared-portal-node]");
    if (r)
      return r;
    const o = Zd(n);
    return o.setAttribute("data-mantine-shared-portal-node", "true"), document.body.appendChild(o), o;
  }
  return Zd(n);
}
const WK = {
  reuseTargetNode: !0
}, Mw = De((e, t) => {
  const { children: n, target: r, reuseTargetNode: o, ...i } = X("Portal", WK, e), [s, a] = fe(!1), l = Ae(null);
  return Ta(() => (a(!0), l.current = qK({ target: r, reuseTargetNode: o, ...i }), bc(t, l.current), !r && !o && l.current && document.body.appendChild(l.current), () => {
    !r && !o && l.current && document.body.removeChild(l.current);
  }), [r]), !s || !l.current ? null : Ac(/* @__PURE__ */ E.jsx(E.Fragment, { children: n }), l.current);
});
Mw.displayName = "@mantine/core/Portal";
const Bi = De(
  ({ withinPortal: e = !0, children: t, ...n }, r) => xu() === "test" || !e ? /* @__PURE__ */ E.jsx(E.Fragment, { children: t }) : /* @__PURE__ */ E.jsx(Mw, { ref: r, ...n, children: t })
);
Bi.displayName = "@mantine/core/OptionalPortal";
const fs = (e) => ({
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: `scale(.9) translateY(${e === "bottom" ? 10 : -10}px)` },
  transitionProperty: "transform, opacity"
}), al = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  "fade-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-30px)" },
    transitionProperty: "opacity, transform"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(-20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(-5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: {
    ...fs("bottom"),
    common: { transformOrigin: "center center" }
  },
  "pop-bottom-left": {
    ...fs("bottom"),
    common: { transformOrigin: "bottom left" }
  },
  "pop-bottom-right": {
    ...fs("bottom"),
    common: { transformOrigin: "bottom right" }
  },
  "pop-top-left": {
    ...fs("top"),
    common: { transformOrigin: "top left" }
  },
  "pop-top-right": {
    ...fs("top"),
    common: { transformOrigin: "top right" }
  }
}, Zb = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function GK({
  transition: e,
  state: t,
  duration: n,
  timingFunction: r
}) {
  const o = {
    WebkitBackfaceVisibility: "hidden",
    transitionDuration: `${n}ms`,
    transitionTimingFunction: r
  };
  return typeof e == "string" ? e in al ? {
    transitionProperty: al[e].transitionProperty,
    ...o,
    ...al[e].common,
    ...al[e][Zb[t]]
  } : {} : {
    transitionProperty: e.transitionProperty,
    ...o,
    ...e.common,
    ...e[Zb[t]]
  };
}
function YK({
  duration: e,
  exitDuration: t,
  timingFunction: n,
  mounted: r,
  onEnter: o,
  onExit: i,
  onEntered: s,
  onExited: a,
  enterDelay: l,
  exitDelay: c
}) {
  const u = dn(), d = wY(), f = u.respectReducedMotion ? d : !1, [h, p] = fe(f ? 0 : e), [m, b] = fe(r ? "entered" : "exited"), y = Ae(-1), k = Ae(-1), C = Ae(-1);
  function _() {
    window.clearTimeout(y.current), window.clearTimeout(k.current), cancelAnimationFrame(C.current);
  }
  const w = (M) => {
    _();
    const D = M ? o : i, R = M ? s : a, N = f ? 0 : M ? e : t;
    p(N), N === 0 ? (typeof D == "function" && D(), typeof R == "function" && R(), b(M ? "entered" : "exited")) : C.current = requestAnimationFrame(() => {
      Vv.flushSync(() => {
        b(M ? "pre-entering" : "pre-exiting");
      }), C.current = requestAnimationFrame(() => {
        typeof D == "function" && D(), b(M ? "entering" : "exiting"), y.current = window.setTimeout(() => {
          typeof R == "function" && R(), b(M ? "entered" : "exited");
        }, N);
      });
    });
  }, T = (M) => {
    if (_(), typeof (M ? l : c) != "number") {
      w(M);
      return;
    }
    k.current = window.setTimeout(
      () => {
        w(M);
      },
      M ? l : c
    );
  };
  return ea(() => {
    T(r);
  }, [r]), ie(
    () => () => {
      _();
    },
    []
  ), {
    transitionDuration: h,
    transitionStatus: m,
    transitionTimingFunction: n || "ease"
  };
}
function po({
  keepMounted: e,
  transition: t = "fade",
  duration: n = 250,
  exitDuration: r = n,
  mounted: o,
  children: i,
  timingFunction: s = "ease",
  onExit: a,
  onEntered: l,
  onEnter: c,
  onExited: u,
  enterDelay: d,
  exitDelay: f
}) {
  const h = xu(), { transitionDuration: p, transitionStatus: m, transitionTimingFunction: b } = YK({
    mounted: o,
    exitDuration: r,
    duration: n,
    timingFunction: s,
    onExit: a,
    onEntered: l,
    onEnter: c,
    onExited: u,
    enterDelay: d,
    exitDelay: f
  });
  return p === 0 || h === "test" ? o ? /* @__PURE__ */ E.jsx(E.Fragment, { children: i({}) }) : e ? i({ display: "none" }) : null : m === "exited" ? e ? i({ display: "none" }) : null : /* @__PURE__ */ E.jsx(E.Fragment, { children: i(
    GK({
      transition: t,
      duration: p,
      state: m,
      timingFunction: b
    })
  ) });
}
po.displayName = "@mantine/core/Transition";
const [KK, Lw] = Eu(
  "Popover component was not found in the tree"
);
var Ow = { dropdown: "m_38a85659", arrow: "m_a31dc6c1", overlay: "m_3d7bc908" };
function Tm({
  children: e,
  active: t = !0,
  refProp: n = "ref",
  innerRef: r
}) {
  const o = dw(t), i = or(o, r), s = xa(e);
  return s ? $i(s, { [n]: i }) : e;
}
function Dw(e) {
  return /* @__PURE__ */ E.jsx(km, { tabIndex: -1, "data-autofocus": !0, ...e });
}
Tm.displayName = "@mantine/core/FocusTrap";
Dw.displayName = "@mantine/core/FocusTrapInitialFocus";
Tm.InitialFocus = Dw;
const Su = De((e, t) => {
  var b, y, k, C;
  const n = X("PopoverDropdown", null, e), {
    className: r,
    style: o,
    vars: i,
    children: s,
    onKeyDownCapture: a,
    variant: l,
    classNames: c,
    styles: u,
    ...d
  } = n, f = Lw(), h = gY({
    opened: f.opened,
    shouldReturnFocus: f.returnFocus
  }), p = f.withRoles ? {
    "aria-labelledby": f.getTargetId(),
    id: f.getDropdownId(),
    role: "dialog",
    tabIndex: -1
  } : {}, m = or(t, f.floating);
  return f.disabled ? null : /* @__PURE__ */ E.jsx(Bi, { ...f.portalProps, withinPortal: f.withinPortal, children: /* @__PURE__ */ E.jsx(
    po,
    {
      mounted: f.opened,
      ...f.transitionProps,
      transition: ((b = f.transitionProps) == null ? void 0 : b.transition) || "fade",
      duration: ((y = f.transitionProps) == null ? void 0 : y.duration) ?? 150,
      keepMounted: f.keepMounted,
      exitDuration: typeof ((k = f.transitionProps) == null ? void 0 : k.exitDuration) == "number" ? f.transitionProps.exitDuration : (C = f.transitionProps) == null ? void 0 : C.duration,
      children: (_) => /* @__PURE__ */ E.jsx(Tm, { active: f.trapFocus && f.opened, innerRef: m, children: /* @__PURE__ */ E.jsxs(
        de,
        {
          ...p,
          ...d,
          variant: l,
          onKeyDownCapture: aY(
            () => {
              var w, T;
              (w = f.onClose) == null || w.call(f), (T = f.onDismiss) == null || T.call(f);
            },
            {
              active: f.closeOnEscape,
              onTrigger: h,
              onKeyDown: a
            }
          ),
          "data-position": f.placement,
          "data-fixed": f.floatingStrategy === "fixed" || void 0,
          ...f.getStyles("dropdown", {
            className: r,
            props: n,
            classNames: c,
            styles: u,
            style: [
              {
                ..._,
                zIndex: f.zIndex,
                top: f.y ?? 0,
                left: f.x ?? 0,
                width: f.width === "target" ? void 0 : U(f.width),
                ...f.referenceHidden ? { display: "none" } : null
              },
              f.resolvedStyles.dropdown,
              u == null ? void 0 : u.dropdown,
              o
            ]
          }),
          children: [
            s,
            /* @__PURE__ */ E.jsx(
              Ec,
              {
                ref: f.arrowRef,
                arrowX: f.arrowX,
                arrowY: f.arrowY,
                visible: f.withArrow,
                position: f.placement,
                arrowSize: f.arrowSize,
                arrowRadius: f.arrowRadius,
                arrowOffset: f.arrowOffset,
                arrowPosition: f.arrowPosition,
                ...f.getStyles("arrow", {
                  props: n,
                  classNames: c,
                  styles: u
                })
              }
            )
          ]
        }
      ) })
    }
  ) });
});
Su.classes = Ow;
Su.displayName = "@mantine/core/PopoverDropdown";
const QK = {
  refProp: "ref",
  popupType: "dialog"
}, xm = De((e, t) => {
  const { children: n, refProp: r, popupType: o, ...i } = X(
    "PopoverTarget",
    QK,
    e
  ), s = xa(n);
  if (!s)
    throw new Error(
      "Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const a = i, l = Lw(), c = or(l.reference, hm(s), t), u = l.withRoles ? {
    "aria-haspopup": o,
    "aria-expanded": l.opened,
    "aria-controls": l.opened ? l.getDropdownId() : void 0,
    id: l.getTargetId()
  } : {}, d = s.props;
  return $i(s, {
    ...a,
    ...u,
    ...l.targetProps,
    className: Ur(l.targetProps.className, a.className, d.className),
    [r]: c,
    ...l.controlled ? null : {
      onClick: () => {
        var f;
        l.onToggle(), (f = d.onClick) == null || f.call(d);
      }
    }
  });
});
xm.displayName = "@mantine/core/PopoverTarget";
function ZK(e) {
  if (e === void 0)
    return { shift: !0, flip: !0 };
  const t = { ...e };
  return e.shift === void 0 && (t.shift = !0), e.flip === void 0 && (t.flip = !0), t;
}
function XK(e, t, n) {
  const r = ZK(e.middlewares), o = [Ln(e.offset), Mv()];
  return e.dropdownVisible && n !== "test" && e.preventPositionChangeWhenVisible && (r.flip = !1), r.flip && o.push(
    typeof r.flip == "boolean" ? Hr() : Hr(r.flip)
  ), r.shift && o.push(
    mo(
      typeof r.shift == "boolean" ? { limiter: Qm(), padding: 5 } : { limiter: Qm(), padding: 5, ...r.shift }
    )
  ), r.inline && o.push(
    typeof r.inline == "boolean" ? gs() : gs(r.inline)
  ), o.push(By({ element: e.arrowRef, padding: e.arrowOffset })), (r.size || e.width === "target") && o.push(
    Is({
      ...typeof r.size == "boolean" ? {} : r.size,
      apply({ rects: i, availableWidth: s, availableHeight: a, ...l }) {
        var d;
        const u = ((d = t().refs.floating.current) == null ? void 0 : d.style) ?? {};
        r.size && (typeof r.size == "object" && r.size.apply ? r.size.apply({ rects: i, availableWidth: s, availableHeight: a, ...l }) : Object.assign(u, {
          maxWidth: `${s}px`,
          maxHeight: `${a}px`
        })), e.width === "target" && Object.assign(u, {
          width: `${i.reference.width}px`
        });
      }
    })
  ), o;
}
function JK(e) {
  const t = xu(), [n, r] = Zi({
    value: e.opened,
    defaultValue: e.defaultOpened,
    finalValue: !1,
    onChange: e.onChange
  }), o = Ae(n), i = () => {
    n && !e.disabled && r(!1);
  }, s = () => {
    e.disabled || r(!n);
  }, a = gu({
    strategy: e.strategy,
    placement: e.preventPositionChangeWhenVisible ? e.positionRef.current : e.position,
    middleware: XK(e, () => a, t),
    whileElementsMounted: e.keepMounted ? void 0 : Ml
  });
  return ie(() => {
    if (!(!a.refs.reference.current || !a.refs.floating.current) && n)
      return Ml(
        a.refs.reference.current,
        a.refs.floating.current,
        a.update
      );
  }, [n, a.update]), ea(() => {
    var l;
    (l = e.onPositionChange) == null || l.call(e, a.placement), e.positionRef.current = a.placement;
  }, [a.placement, e.preventPositionChangeWhenVisible]), ea(() => {
    var l, c;
    n !== o.current && (n ? (c = e.onOpen) == null || c.call(e) : (l = e.onClose) == null || l.call(e)), o.current = n;
  }, [n, e.onClose, e.onOpen]), Ta(() => {
    let l = -1;
    return n && (l = window.setTimeout(() => e.setDropdownVisible(!0), 4)), () => {
      window.clearTimeout(l);
    };
  }, [n, e.position]), {
    floating: a,
    controlled: typeof e.opened == "boolean",
    opened: n,
    onClose: i,
    onToggle: s
  };
}
const eQ = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transitionProps: { transition: "fade", duration: 150 },
  middlewares: { flip: !0, shift: !0, inline: !1 },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: !0,
  withinPortal: !0,
  closeOnEscape: !0,
  trapFocus: !1,
  withRoles: !0,
  returnFocus: !1,
  withOverlay: !1,
  hideDetached: !0,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: ka("popover"),
  __staticSelector: "Popover",
  width: "max-content"
}, tQ = (e, { radius: t, shadow: n }) => ({
  dropdown: {
    "--popover-radius": t === void 0 ? void 0 : Ut(t),
    "--popover-shadow": aw(n)
  }
});
function ir(e) {
  var ar, wn, Wr, Gr, Ot, Ar, vn;
  const t = X("Popover", eQ, e), {
    children: n,
    position: r,
    offset: o,
    onPositionChange: i,
    // Scheduled for removal in 9.0
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    positionDependencies: s,
    opened: a,
    transitionProps: l,
    onExitTransitionEnd: c,
    onEnterTransitionEnd: u,
    width: d,
    middlewares: f,
    withArrow: h,
    arrowSize: p,
    arrowOffset: m,
    arrowRadius: b,
    arrowPosition: y,
    unstyled: k,
    classNames: C,
    styles: _,
    closeOnClickOutside: w,
    withinPortal: T,
    portalProps: M,
    closeOnEscape: D,
    clickOutsideEvents: R,
    trapFocus: N,
    onClose: B,
    onDismiss: F,
    onOpen: W,
    onChange: L,
    zIndex: H,
    radius: J,
    shadow: Y,
    id: V,
    defaultOpened: Q,
    __staticSelector: S,
    withRoles: ue,
    disabled: ee,
    returnFocus: A,
    variant: le,
    keepMounted: ge,
    vars: Ee,
    floatingStrategy: Qe,
    withOverlay: Te,
    overlayProps: ce,
    hideDetached: nt,
    attributes: pt,
    preventPositionChangeWhenVisible: mt,
    ...je
  } = t, Vt = Oe({
    name: S,
    props: t,
    classes: Ow,
    classNames: C,
    styles: _,
    unstyled: k,
    attributes: pt,
    rootSelector: "dropdown",
    vars: Ee,
    varsResolver: tQ
  }), { resolvedStyles: Un } = wu({ classNames: C, styles: _, props: t }), [vr, Sr] = fe(a ?? Q ?? !1), _r = Ae(r), zt = Ae(null), [qr, _a] = fe(null), [Hu, Fu] = fe(null), { dir: Uu } = Xi(), ju = xu(), $ = Qi(V), z = JK({
    middlewares: f,
    width: d,
    position: Iw(Uu, r),
    offset: typeof o == "number" ? o + (h ? p / 2 : 0) : o,
    arrowRef: zt,
    arrowOffset: m,
    onPositionChange: i,
    positionDependencies: s,
    opened: a,
    defaultOpened: Q,
    onChange: L,
    onOpen: W,
    onClose: B,
    onDismiss: F,
    strategy: Qe,
    dropdownVisible: vr,
    setDropdownVisible: Sr,
    positionRef: _r,
    disabled: ee,
    preventPositionChangeWhenVisible: mt,
    keepMounted: ge
  });
  fY(
    () => {
      w && (z.onClose(), F == null || F());
    },
    R,
    [qr, Hu]
  );
  const he = Z(
    (hn) => {
      _a(hn), z.floating.refs.setReference(hn);
    },
    [z.floating.refs.setReference]
  ), Ie = Z(
    (hn) => {
      Fu(hn), z.floating.refs.setFloating(hn);
    },
    [z.floating.refs.setFloating]
  ), Ve = Z(() => {
    var hn;
    (hn = l == null ? void 0 : l.onExited) == null || hn.call(l), c == null || c(), Sr(!1), mt || (_r.current = r);
  }, [l == null ? void 0 : l.onExited, c, mt, r]), fn = Z(() => {
    var hn;
    (hn = l == null ? void 0 : l.onEntered) == null || hn.call(l), u == null || u();
  }, [l == null ? void 0 : l.onEntered, u]);
  return /* @__PURE__ */ E.jsxs(
    KK,
    {
      value: {
        returnFocus: A,
        disabled: ee,
        controlled: z.controlled,
        reference: he,
        floating: Ie,
        x: z.floating.x,
        y: z.floating.y,
        arrowX: (Wr = (wn = (ar = z.floating) == null ? void 0 : ar.middlewareData) == null ? void 0 : wn.arrow) == null ? void 0 : Wr.x,
        arrowY: (Ar = (Ot = (Gr = z.floating) == null ? void 0 : Gr.middlewareData) == null ? void 0 : Ot.arrow) == null ? void 0 : Ar.y,
        opened: z.opened,
        arrowRef: zt,
        transitionProps: { ...l, onExited: Ve, onEntered: fn },
        width: d,
        withArrow: h,
        arrowSize: p,
        arrowOffset: m,
        arrowRadius: b,
        arrowPosition: y,
        placement: z.floating.placement,
        trapFocus: N,
        withinPortal: T,
        portalProps: M,
        zIndex: H,
        radius: J,
        shadow: Y,
        closeOnEscape: D,
        onDismiss: F,
        onClose: z.onClose,
        onToggle: z.onToggle,
        getTargetId: () => `${$}-target`,
        getDropdownId: () => `${$}-dropdown`,
        withRoles: ue,
        targetProps: je,
        __staticSelector: S,
        classNames: C,
        styles: _,
        unstyled: k,
        variant: le,
        keepMounted: ge,
        getStyles: Vt,
        resolvedStyles: Un,
        floatingStrategy: Qe,
        referenceHidden: nt && ju !== "test" ? (vn = z.floating.middlewareData.hide) == null ? void 0 : vn.referenceHidden : !1
      },
      children: [
        n,
        Te && /* @__PURE__ */ E.jsx(
          po,
          {
            transition: "fade",
            mounted: z.opened,
            duration: (l == null ? void 0 : l.duration) || 250,
            exitDuration: (l == null ? void 0 : l.exitDuration) || 250,
            children: (hn) => /* @__PURE__ */ E.jsx(Bi, { withinPortal: T, children: /* @__PURE__ */ E.jsx(
              na,
              {
                ...ce,
                ...Vt("overlay", {
                  className: ce == null ? void 0 : ce.className,
                  style: [hn, ce == null ? void 0 : ce.style]
                })
              }
            ) })
          }
        )
      ]
    }
  );
}
ir.Target = xm;
ir.Dropdown = Su;
ir.displayName = "@mantine/core/Popover";
ir.extend = (e) => e;
var qn = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" };
const Rw = se(({ className: e, ...t }, n) => /* @__PURE__ */ E.jsxs(de, { component: "span", className: Ur(qn.barsLoader, e), ...t, ref: n, children: [
  /* @__PURE__ */ E.jsx("span", { className: qn.bar }),
  /* @__PURE__ */ E.jsx("span", { className: qn.bar }),
  /* @__PURE__ */ E.jsx("span", { className: qn.bar })
] }));
Rw.displayName = "@mantine/core/Bars";
const Pw = se(({ className: e, ...t }, n) => /* @__PURE__ */ E.jsxs(de, { component: "span", className: Ur(qn.dotsLoader, e), ...t, ref: n, children: [
  /* @__PURE__ */ E.jsx("span", { className: qn.dot }),
  /* @__PURE__ */ E.jsx("span", { className: qn.dot }),
  /* @__PURE__ */ E.jsx("span", { className: qn.dot })
] }));
Pw.displayName = "@mantine/core/Dots";
const Bw = se(({ className: e, ...t }, n) => /* @__PURE__ */ E.jsx(de, { component: "span", className: Ur(qn.ovalLoader, e), ...t, ref: n }));
Bw.displayName = "@mantine/core/Oval";
const $w = {
  bars: Rw,
  oval: Bw,
  dots: Pw
}, nQ = {
  loaders: $w,
  type: "oval"
}, rQ = (e, { size: t, color: n }) => ({
  root: {
    "--loader-size": et(t, "loader-size"),
    "--loader-color": n ? Fr(n, e) : void 0
  }
}), xo = De((e, t) => {
  const n = X("Loader", nQ, e), {
    size: r,
    color: o,
    type: i,
    vars: s,
    className: a,
    style: l,
    classNames: c,
    styles: u,
    unstyled: d,
    loaders: f,
    variant: h,
    children: p,
    attributes: m,
    ...b
  } = n, y = Oe({
    name: "Loader",
    props: n,
    classes: qn,
    className: a,
    style: l,
    classNames: c,
    styles: u,
    unstyled: d,
    attributes: m,
    vars: s,
    varsResolver: rQ
  });
  return p ? /* @__PURE__ */ E.jsx(de, { ...y("root"), ref: t, ...b, children: p }) : /* @__PURE__ */ E.jsx(
    de,
    {
      ...y("root"),
      ref: t,
      component: f[i],
      variant: h,
      size: r,
      ...b
    }
  );
});
xo.defaultLoaders = $w;
xo.classes = qn;
xo.displayName = "@mantine/core/Loader";
var Ji = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21", groupSection: "m_437b6484" };
const Xb = {
  orientation: "horizontal"
}, oQ = (e, { borderWidth: t }) => ({
  group: { "--ai-border-width": U(t) }
}), wm = De((e, t) => {
  const n = X("ActionIconGroup", Xb, e), {
    className: r,
    style: o,
    classNames: i,
    styles: s,
    unstyled: a,
    orientation: l,
    vars: c,
    borderWidth: u,
    variant: d,
    mod: f,
    attributes: h,
    ...p
  } = X("ActionIconGroup", Xb, e), m = Oe({
    name: "ActionIconGroup",
    props: n,
    classes: Ji,
    className: r,
    style: o,
    classNames: i,
    styles: s,
    unstyled: a,
    attributes: h,
    vars: c,
    varsResolver: oQ,
    rootSelector: "group"
  });
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ...m("group"),
      ref: t,
      variant: d,
      mod: [{ "data-orientation": l }, f],
      role: "group",
      ...p
    }
  );
});
wm.classes = Ji;
wm.displayName = "@mantine/core/ActionIconGroup";
const iQ = (e, { radius: t, color: n, gradient: r, variant: o, autoContrast: i, size: s }) => {
  const a = e.variantColorResolver({
    color: n || e.primaryColor,
    theme: e,
    gradient: r,
    variant: o || "filled",
    autoContrast: i
  });
  return {
    groupSection: {
      "--section-height": et(s, "section-height"),
      "--section-padding-x": et(s, "section-padding-x"),
      "--section-fz": an(s),
      "--section-radius": t === void 0 ? void 0 : Ut(t),
      "--section-bg": n || o ? a.background : void 0,
      "--section-color": a.color,
      "--section-bd": n || o ? a.border : void 0
    }
  };
}, vm = De((e, t) => {
  const n = X("ActionIconGroupSection", null, e), {
    className: r,
    style: o,
    classNames: i,
    styles: s,
    unstyled: a,
    vars: l,
    variant: c,
    gradient: u,
    radius: d,
    autoContrast: f,
    attributes: h,
    ...p
  } = n, m = Oe({
    name: "ActionIconGroupSection",
    props: n,
    classes: Ji,
    className: r,
    style: o,
    classNames: i,
    styles: s,
    unstyled: a,
    attributes: h,
    vars: l,
    varsResolver: iQ,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ E.jsx(de, { ...m("groupSection"), ref: t, variant: c, ...p });
});
vm.classes = Ji;
vm.displayName = "@mantine/core/ActionIconGroupSection";
const sQ = (e, { size: t, radius: n, variant: r, gradient: o, color: i, autoContrast: s }) => {
  const a = e.variantColorResolver({
    color: i || e.primaryColor,
    theme: e,
    gradient: o,
    variant: r || "filled",
    autoContrast: s
  });
  return {
    root: {
      "--ai-size": et(t, "ai-size"),
      "--ai-radius": n === void 0 ? void 0 : Ut(n),
      "--ai-bg": i || r ? a.background : void 0,
      "--ai-hover": i || r ? a.hover : void 0,
      "--ai-hover-color": i || r ? a.hoverColor : void 0,
      "--ai-color": a.color,
      "--ai-bd": i || r ? a.border : void 0
    }
  };
}, ni = jt((e, t) => {
  const n = X("ActionIcon", null, e), {
    className: r,
    unstyled: o,
    variant: i,
    classNames: s,
    styles: a,
    style: l,
    loading: c,
    loaderProps: u,
    size: d,
    color: f,
    radius: h,
    __staticSelector: p,
    gradient: m,
    vars: b,
    children: y,
    disabled: k,
    "data-disabled": C,
    autoContrast: _,
    mod: w,
    attributes: T,
    ...M
  } = n, D = Oe({
    name: ["ActionIcon", p],
    props: n,
    className: r,
    style: l,
    classes: Ji,
    classNames: s,
    styles: a,
    unstyled: o,
    attributes: T,
    vars: b,
    varsResolver: sQ
  });
  return /* @__PURE__ */ E.jsxs(
    To,
    {
      ...D("root", { active: !k && !c && !C }),
      ...M,
      unstyled: o,
      variant: i,
      size: d,
      disabled: k || c,
      ref: t,
      mod: [{ loading: c, disabled: k || C }, w],
      children: [
        typeof c == "boolean" && /* @__PURE__ */ E.jsx(po, { mounted: c, transition: "slide-down", duration: 150, children: (R) => /* @__PURE__ */ E.jsx(de, { component: "span", ...D("loader", { style: R }), "aria-hidden": !0, children: /* @__PURE__ */ E.jsx(xo, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...u }) }) }),
        /* @__PURE__ */ E.jsx(de, { component: "span", mod: { loading: c }, ...D("icon"), children: y })
      ]
    }
  );
});
ni.classes = Ji;
ni.displayName = "@mantine/core/ActionIcon";
ni.Group = wm;
ni.GroupSection = vm;
const Hw = se(
  ({ size: e = "var(--cb-icon-size, 70%)", style: t, ...n }, r) => /* @__PURE__ */ E.jsx(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...t, width: e, height: e },
      ref: r,
      ...n,
      children: /* @__PURE__ */ E.jsx(
        "path",
        {
          d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  )
);
Hw.displayName = "@mantine/core/CloseIcon";
var Fw = { root: "m_86a44da5", "root--subtle": "m_220c80f2" };
const aQ = {
  variant: "subtle"
}, lQ = (e, { size: t, radius: n, iconSize: r }) => ({
  root: {
    "--cb-size": et(t, "cb-size"),
    "--cb-radius": n === void 0 ? void 0 : Ut(n),
    "--cb-icon-size": U(r)
  }
}), _u = jt((e, t) => {
  const n = X("CloseButton", aQ, e), {
    iconSize: r,
    children: o,
    vars: i,
    radius: s,
    className: a,
    classNames: l,
    style: c,
    styles: u,
    unstyled: d,
    "data-disabled": f,
    disabled: h,
    variant: p,
    icon: m,
    mod: b,
    attributes: y,
    __staticSelector: k,
    ...C
  } = n, _ = Oe({
    name: k || "CloseButton",
    props: n,
    className: a,
    style: c,
    classes: Fw,
    classNames: l,
    styles: u,
    unstyled: d,
    attributes: y,
    vars: i,
    varsResolver: lQ
  });
  return /* @__PURE__ */ E.jsxs(
    To,
    {
      ref: t,
      ...C,
      unstyled: d,
      variant: p,
      disabled: h,
      mod: [{ disabled: h || f }, b],
      ..._("root", { variant: p, active: !h && !f }),
      children: [
        m || /* @__PURE__ */ E.jsx(Hw, {}),
        o
      ]
    }
  );
});
_u.classes = Fw;
_u.displayName = "@mantine/core/CloseButton";
function cQ(e) {
  return xh.toArray(e).filter(Boolean);
}
var Uw = { root: "m_4081bf90" };
const uQ = {
  preventGrowOverflow: !0,
  gap: "md",
  align: "center",
  justify: "flex-start",
  wrap: "wrap"
}, dQ = (e, { grow: t, preventGrowOverflow: n, gap: r, align: o, justify: i, wrap: s }, { childWidth: a }) => ({
  root: {
    "--group-child-width": t && n ? a : void 0,
    "--group-gap": Ca(r),
    "--group-align": o,
    "--group-justify": i,
    "--group-wrap": s
  }
}), Mt = De((e, t) => {
  const n = X("Group", uQ, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    children: l,
    gap: c,
    align: u,
    justify: d,
    wrap: f,
    grow: h,
    preventGrowOverflow: p,
    vars: m,
    variant: b,
    __size: y,
    mod: k,
    attributes: C,
    ..._
  } = n, w = cQ(l), T = w.length, M = Ca(c ?? "md"), R = { childWidth: `calc(${100 / T}% - (${M} - ${M} / ${T}))` }, N = Oe({
    name: "Group",
    props: n,
    stylesCtx: R,
    className: o,
    style: i,
    classes: Uw,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: C,
    vars: m,
    varsResolver: dQ
  });
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ...N("root"),
      ref: t,
      variant: b,
      mod: [{ grow: h }, k],
      size: y,
      ..._,
      children: w
    }
  );
});
Mt.classes = Uw;
Mt.displayName = "@mantine/core/Group";
const [fQ, hQ] = ku({
  size: "sm"
});
var Fn = { wrapper: "m_6c018570", input: "m_8fb7ebe7", section: "m_82577fc2", placeholder: "m_88bacfd0", root: "m_46b77525", label: "m_8fdc1311", required: "m_78a94662", error: "m_8f816625", description: "m_fe47ce59" };
const jw = De((e, t) => {
  const n = X("InputClearButton", null, e), { size: r, variant: o, vars: i, classNames: s, styles: a, ...l } = n, c = hQ(), { resolvedClassNames: u, resolvedStyles: d } = wu({
    classNames: s,
    styles: a,
    props: n
  });
  return /* @__PURE__ */ E.jsx(
    _u,
    {
      variant: o || "transparent",
      ref: t,
      size: r || (c == null ? void 0 : c.size) || "sm",
      classNames: u,
      styles: d,
      __staticSelector: "InputClearButton",
      style: { pointerEvents: "all", background: "var(--input-bg)", ...l.style },
      ...l
    }
  );
});
jw.displayName = "@mantine/core/InputClearButton";
const pQ = {
  xs: 7,
  sm: 8,
  md: 10,
  lg: 12,
  xl: 15
};
function mQ({
  __clearable: e,
  __clearSection: t,
  rightSection: n,
  __defaultRightSection: r,
  size: o = "sm"
}) {
  const i = e && t;
  return i && (n || r) ? /* @__PURE__ */ E.jsxs(
    "div",
    {
      "data-combined-clear-section": !0,
      style: {
        display: "flex",
        gap: 2,
        alignItems: "center",
        paddingInlineEnd: pQ[o]
      },
      children: [
        i,
        n || r
      ]
    }
  ) : n === null ? null : n || i || r;
}
const [gQ, Au] = ku({
  offsetBottom: !1,
  offsetTop: !1,
  describedBy: void 0,
  getStyles: null,
  inputId: void 0,
  labelId: void 0
}), bQ = (e, { size: t }) => ({
  description: {
    "--input-description-size": t === void 0 ? void 0 : `calc(${an(t)} - ${U(2)})`
  }
}), Iu = De((e, t) => {
  const n = X("InputDescription", null, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    size: c,
    __staticSelector: u,
    __inheritStyles: d = !0,
    attributes: f,
    variant: h,
    ...p
  } = X("InputDescription", null, n), m = Au(), b = Oe({
    name: ["InputWrapper", u],
    props: n,
    classes: Fn,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: f,
    rootSelector: "description",
    vars: l,
    varsResolver: bQ
  }), y = d && (m == null ? void 0 : m.getStyles) || b;
  return /* @__PURE__ */ E.jsx(
    de,
    {
      component: "p",
      ref: t,
      variant: h,
      size: c,
      ...y("description", m != null && m.getStyles ? { className: o, style: i } : void 0),
      ...p
    }
  );
});
Iu.classes = Fn;
Iu.displayName = "@mantine/core/InputDescription";
const yQ = (e, { size: t }) => ({
  error: {
    "--input-error-size": t === void 0 ? void 0 : `calc(${an(t)} - ${U(2)})`
  }
}), Nu = De((e, t) => {
  const n = X("InputError", null, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    size: c,
    attributes: u,
    __staticSelector: d,
    __inheritStyles: f = !0,
    variant: h,
    ...p
  } = n, m = Oe({
    name: ["InputWrapper", d],
    props: n,
    classes: Fn,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: u,
    rootSelector: "error",
    vars: l,
    varsResolver: yQ
  }), b = Au(), y = f && (b == null ? void 0 : b.getStyles) || m;
  return /* @__PURE__ */ E.jsx(
    de,
    {
      component: "p",
      ref: t,
      variant: h,
      size: c,
      ...y("error", b != null && b.getStyles ? { className: o, style: i } : void 0),
      ...p
    }
  );
});
Nu.classes = Fn;
Nu.displayName = "@mantine/core/InputError";
const Jb = {
  labelElement: "label"
}, EQ = (e, { size: t }) => ({
  label: {
    "--input-label-size": an(t),
    "--input-asterisk-color": void 0
  }
}), Mu = De((e, t) => {
  const n = X("InputLabel", Jb, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    labelElement: c,
    size: u,
    required: d,
    htmlFor: f,
    onMouseDown: h,
    children: p,
    __staticSelector: m,
    variant: b,
    mod: y,
    attributes: k,
    ...C
  } = X("InputLabel", Jb, n), _ = Oe({
    name: ["InputWrapper", m],
    props: n,
    classes: Fn,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: k,
    rootSelector: "label",
    vars: l,
    varsResolver: EQ
  }), w = Au(), T = (w == null ? void 0 : w.getStyles) || _;
  return /* @__PURE__ */ E.jsxs(
    de,
    {
      ...T("label", w != null && w.getStyles ? { className: o, style: i } : void 0),
      component: c,
      variant: b,
      size: u,
      ref: t,
      htmlFor: c === "label" ? f : void 0,
      mod: [{ required: d }, y],
      onMouseDown: (M) => {
        h == null || h(M), !M.defaultPrevented && M.detail > 1 && M.preventDefault();
      },
      ...C,
      children: [
        p,
        d && /* @__PURE__ */ E.jsx("span", { ...T("required"), "aria-hidden": !0, children: " *" })
      ]
    }
  );
});
Mu.classes = Fn;
Mu.displayName = "@mantine/core/InputLabel";
const Sm = De((e, t) => {
  const n = X("InputPlaceholder", null, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    __staticSelector: c,
    variant: u,
    error: d,
    mod: f,
    attributes: h,
    ...p
  } = n, m = Oe({
    name: ["InputPlaceholder", c],
    props: n,
    classes: Fn,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: h,
    rootSelector: "placeholder"
  });
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ...m("placeholder"),
      mod: [{ error: !!d }, f],
      component: "span",
      variant: u,
      ref: t,
      ...p
    }
  );
});
Sm.classes = Fn;
Sm.displayName = "@mantine/core/InputPlaceholder";
function kQ(e, { hasDescription: t, hasError: n }) {
  const r = e.findIndex((l) => l === "input"), o = e.slice(0, r), i = e.slice(r + 1), s = t && o.includes("description") || n && o.includes("error");
  return { offsetBottom: t && i.includes("description") || n && i.includes("error"), offsetTop: s };
}
const CQ = {
  labelElement: "label",
  inputContainer: (e) => e,
  inputWrapperOrder: ["label", "description", "input", "error"]
}, TQ = (e, { size: t }) => ({
  label: {
    "--input-label-size": an(t),
    "--input-asterisk-color": void 0
  },
  error: {
    "--input-error-size": t === void 0 ? void 0 : `calc(${an(t)} - ${U(2)})`
  },
  description: {
    "--input-description-size": t === void 0 ? void 0 : `calc(${an(t)} - ${U(2)})`
  }
}), _m = De((e, t) => {
  const n = X("InputWrapper", CQ, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    size: c,
    variant: u,
    __staticSelector: d,
    inputContainer: f,
    inputWrapperOrder: h,
    label: p,
    error: m,
    description: b,
    labelProps: y,
    descriptionProps: k,
    errorProps: C,
    labelElement: _,
    children: w,
    withAsterisk: T,
    id: M,
    required: D,
    __stylesApiProps: R,
    mod: N,
    attributes: B,
    ...F
  } = n, W = Oe({
    name: ["InputWrapper", d],
    props: R || n,
    classes: Fn,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: B,
    vars: l,
    varsResolver: TQ
  }), L = {
    size: c,
    variant: u,
    __staticSelector: d
  }, H = Qi(M), J = typeof T == "boolean" ? T : D, Y = (C == null ? void 0 : C.id) || `${H}-error`, V = (k == null ? void 0 : k.id) || `${H}-description`, Q = H, S = !!m && typeof m != "boolean", ue = !!b, ee = `${S ? Y : ""} ${ue ? V : ""}`, A = ee.trim().length > 0 ? ee.trim() : void 0, le = (y == null ? void 0 : y.id) || `${H}-label`, ge = p && /* @__PURE__ */ E.jsx(
    Mu,
    {
      labelElement: _,
      id: le,
      htmlFor: Q,
      required: J,
      ...L,
      ...y,
      children: p
    },
    "label"
  ), Ee = ue && /* @__PURE__ */ E.jsx(
    Iu,
    {
      ...k,
      ...L,
      size: (k == null ? void 0 : k.size) || L.size,
      id: (k == null ? void 0 : k.id) || V,
      children: b
    },
    "description"
  ), Qe = /* @__PURE__ */ E.jsx(Hy, { children: f(w) }, "input"), Te = S && /* @__PURE__ */ Uv(
    Nu,
    {
      ...C,
      ...L,
      size: (C == null ? void 0 : C.size) || L.size,
      key: "error",
      id: (C == null ? void 0 : C.id) || Y
    },
    m
  ), ce = h.map((nt) => {
    switch (nt) {
      case "label":
        return ge;
      case "input":
        return Qe;
      case "description":
        return Ee;
      case "error":
        return Te;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ E.jsx(
    gQ,
    {
      value: {
        getStyles: W,
        describedBy: A,
        inputId: Q,
        labelId: le,
        ...kQ(h, { hasDescription: ue, hasError: S })
      },
      children: /* @__PURE__ */ E.jsx(
        de,
        {
          ref: t,
          variant: u,
          size: c,
          mod: [{ error: !!m }, N],
          ...W("root"),
          ...F,
          children: ce
        }
      )
    }
  );
});
_m.classes = Fn;
_m.displayName = "@mantine/core/InputWrapper";
const xQ = {
  variant: "default",
  leftSectionPointerEvents: "none",
  rightSectionPointerEvents: "none",
  withAria: !0,
  withErrorStyles: !0,
  size: "sm"
}, wQ = (e, t, n) => ({
  wrapper: {
    "--input-margin-top": n.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-margin-bottom": n.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-height": et(t.size, "input-height"),
    "--input-fz": an(t.size),
    "--input-radius": t.radius === void 0 ? void 0 : Ut(t.radius),
    "--input-left-section-width": t.leftSectionWidth !== void 0 ? U(t.leftSectionWidth) : void 0,
    "--input-right-section-width": t.rightSectionWidth !== void 0 ? U(t.rightSectionWidth) : void 0,
    "--input-padding-y": t.multiline ? et(t.size, "input-padding-y") : void 0,
    "--input-left-section-pointer-events": t.leftSectionPointerEvents,
    "--input-right-section-pointer-events": t.rightSectionPointerEvents
  }
}), Cn = jt((e, t) => {
  const n = X("Input", xQ, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    required: l,
    __staticSelector: c,
    __stylesApiProps: u,
    size: d,
    wrapperProps: f,
    error: h,
    disabled: p,
    leftSection: m,
    leftSectionProps: b,
    leftSectionWidth: y,
    rightSection: k,
    rightSectionProps: C,
    rightSectionWidth: _,
    rightSectionPointerEvents: w,
    leftSectionPointerEvents: T,
    variant: M,
    vars: D,
    pointer: R,
    multiline: N,
    radius: B,
    id: F,
    withAria: W,
    withErrorStyles: L,
    mod: H,
    inputSize: J,
    attributes: Y,
    __clearSection: V,
    __clearable: Q,
    __defaultRightSection: S,
    ...ue
  } = n, { styleProps: ee, rest: A } = vu(ue), le = Au(), ge = { offsetBottom: le == null ? void 0 : le.offsetBottom, offsetTop: le == null ? void 0 : le.offsetTop }, Ee = Oe({
    name: ["Input", c],
    props: u || n,
    classes: Fn,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: Y,
    stylesCtx: ge,
    rootSelector: "wrapper",
    vars: D,
    varsResolver: wQ
  }), Qe = W ? {
    required: l,
    disabled: p,
    "aria-invalid": !!h,
    "aria-describedby": le == null ? void 0 : le.describedBy,
    id: (le == null ? void 0 : le.inputId) || F
  } : {}, Te = mQ({
    __clearable: Q,
    __clearSection: V,
    rightSection: k,
    __defaultRightSection: S,
    size: d
  });
  return /* @__PURE__ */ E.jsx(fQ, { value: { size: d || "sm" }, children: /* @__PURE__ */ E.jsxs(
    de,
    {
      ...Ee("wrapper"),
      ...ee,
      ...f,
      mod: [
        {
          error: !!h && L,
          pointer: R,
          disabled: p,
          multiline: N,
          "data-with-right-section": !!Te,
          "data-with-left-section": !!m
        },
        H
      ],
      variant: M,
      size: d,
      children: [
        m && /* @__PURE__ */ E.jsx(
          "div",
          {
            ...b,
            "data-position": "left",
            ...Ee("section", {
              className: b == null ? void 0 : b.className,
              style: b == null ? void 0 : b.style
            }),
            children: m
          }
        ),
        /* @__PURE__ */ E.jsx(
          de,
          {
            component: "input",
            ...A,
            ...Qe,
            ref: t,
            required: l,
            mod: { disabled: p, error: !!h && L },
            variant: M,
            __size: J,
            ...Ee("input")
          }
        ),
        Te && /* @__PURE__ */ E.jsx(
          "div",
          {
            ...C,
            "data-position": "right",
            ...Ee("section", {
              className: C == null ? void 0 : C.className,
              style: C == null ? void 0 : C.style
            }),
            children: Te
          }
        )
      ]
    }
  ) });
});
Cn.classes = Fn;
Cn.Wrapper = _m;
Cn.Label = Mu;
Cn.Error = Nu;
Cn.Description = Iu;
Cn.Placeholder = Sm;
Cn.ClearButton = jw;
Cn.displayName = "@mantine/core/Input";
function vQ(e, t, n) {
  const r = X(e, t, n), {
    label: o,
    description: i,
    error: s,
    required: a,
    classNames: l,
    styles: c,
    className: u,
    unstyled: d,
    __staticSelector: f,
    __stylesApiProps: h,
    errorProps: p,
    labelProps: m,
    descriptionProps: b,
    wrapperProps: y,
    id: k,
    size: C,
    style: _,
    inputContainer: w,
    inputWrapperOrder: T,
    withAsterisk: M,
    variant: D,
    vars: R,
    mod: N,
    attributes: B,
    ...F
  } = r, { styleProps: W, rest: L } = vu(F), H = {
    label: o,
    description: i,
    error: s,
    required: a,
    classNames: l,
    className: u,
    __staticSelector: f,
    __stylesApiProps: h || r,
    errorProps: p,
    labelProps: m,
    descriptionProps: b,
    unstyled: d,
    styles: c,
    size: C,
    style: _,
    inputContainer: w,
    inputWrapperOrder: T,
    withAsterisk: M,
    variant: D,
    id: k,
    mod: N,
    attributes: B,
    ...y
  };
  return {
    ...L,
    classNames: l,
    styles: c,
    unstyled: d,
    wrapperProps: { ...H, ...W },
    inputProps: {
      required: a,
      classNames: l,
      styles: c,
      unstyled: d,
      size: C,
      __staticSelector: f,
      __stylesApiProps: h || r,
      error: s,
      variant: D,
      id: k,
      attributes: B
    }
  };
}
const SQ = {
  __staticSelector: "InputBase",
  withAria: !0,
  size: "sm"
}, es = jt((e, t) => {
  const { inputProps: n, wrapperProps: r, ...o } = vQ("InputBase", SQ, e);
  return /* @__PURE__ */ E.jsx(Cn.Wrapper, { ...r, children: /* @__PURE__ */ E.jsx(Cn, { ...n, ...o, ref: t }) });
});
es.classes = { ...Cn.classes, ...Cn.Wrapper.classes };
es.displayName = "@mantine/core/InputBase";
const _Q = {
  gap: { type: "spacing", property: "gap" },
  rowGap: { type: "spacing", property: "rowGap" },
  columnGap: { type: "spacing", property: "columnGap" },
  align: { type: "identity", property: "alignItems" },
  justify: { type: "identity", property: "justifyContent" },
  wrap: { type: "identity", property: "flexWrap" },
  direction: { type: "identity", property: "flexDirection" }
};
var Vw = { root: "m_8bffd616" };
const Am = jt((e, t) => {
  const n = X("Flex", null, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    gap: c,
    rowGap: u,
    columnGap: d,
    align: f,
    justify: h,
    wrap: p,
    direction: m,
    attributes: b,
    ...y
  } = n, k = Oe({
    name: "Flex",
    classes: Vw,
    props: n,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: b,
    vars: l
  }), C = dn(), _ = kw(), w = Ew({
    styleProps: { gap: c, rowGap: u, columnGap: d, align: f, justify: h, wrap: p, direction: m },
    theme: C,
    data: _Q
  });
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    w.hasResponsiveStyles && /* @__PURE__ */ E.jsx(
      yw,
      {
        selector: `.${_}`,
        styles: w.styles,
        media: w.media
      }
    ),
    /* @__PURE__ */ E.jsx(
      de,
      {
        ref: t,
        ...k("root", {
          className: _,
          style: yu(w.inlineStyles)
        }),
        ...y
      }
    )
  ] });
});
Am.classes = Vw;
Am.displayName = "@mantine/core/Flex";
function zw({ open: e, close: t, openDelay: n, closeDelay: r }) {
  const o = Ae(-1), i = Ae(-1), s = () => {
    window.clearTimeout(o.current), window.clearTimeout(i.current);
  }, a = () => {
    s(), n === 0 || n === void 0 ? e() : o.current = window.setTimeout(e, n);
  }, l = () => {
    s(), r === 0 || r === void 0 ? t() : i.current = window.setTimeout(t, r);
  };
  return ie(() => s, []), { openDropdown: a, closeDropdown: l };
}
function qw({ style: e, size: t = 16, ...n }) {
  return /* @__PURE__ */ E.jsx(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...e, width: U(t), height: U(t), display: "block" },
      ...n,
      children: /* @__PURE__ */ E.jsx(
        "path",
        {
          d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
qw.displayName = "@mantine/core/AccordionChevron";
var Ww = { root: "m_b6d8b162" };
function AQ(e) {
  if (e === "start")
    return "start";
  if (e === "end" || e)
    return "end";
}
const IQ = {
  inherit: !1
}, NQ = /* Will be removed in 9.0 */ /* eslint-disable-next-line @typescript-eslint/no-deprecated */ (e, { variant: t, lineClamp: n, gradient: r, size: o, color: i }) => ({
  root: {
    "--text-fz": an(o),
    "--text-lh": lY(o),
    "--text-gradient": t === "gradient" ? hh(r, e) : void 0,
    "--text-line-clamp": typeof n == "number" ? n.toString() : void 0,
    "--text-color": i ? Fr(i, e) : void 0
  }
}), Er = jt((e, t) => {
  const n = X("Text", IQ, e), {
    lineClamp: r,
    truncate: o,
    inline: i,
    inherit: s,
    gradient: a,
    span: l,
    __staticSelector: c,
    vars: u,
    className: d,
    style: f,
    classNames: h,
    styles: p,
    unstyled: m,
    variant: b,
    mod: y,
    size: k,
    attributes: C,
    ..._
  } = n, w = Oe({
    name: ["Text", c],
    props: n,
    classes: Ww,
    className: d,
    style: f,
    classNames: h,
    styles: p,
    unstyled: m,
    attributes: C,
    vars: u,
    varsResolver: NQ
  });
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ...w("root", { focusable: !0 }),
      ref: t,
      component: l ? "span" : "p",
      variant: b,
      mod: [
        {
          "data-truncate": AQ(o),
          "data-line-clamp": typeof r == "number",
          "data-inline": i,
          "data-inherit": s
        },
        y
      ],
      size: k,
      ..._
    }
  );
});
Er.classes = Ww;
Er.displayName = "@mantine/core/Text";
function kc({ size: e, style: t, ...n }) {
  const r = e !== void 0 ? { width: U(e), height: U(e), ...t } : t;
  return /* @__PURE__ */ E.jsx(
    "svg",
    {
      viewBox: "0 0 10 7",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: r,
      "aria-hidden": !0,
      ...n,
      children: /* @__PURE__ */ E.jsx(
        "path",
        {
          d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
var Lu = { group: "m_11def92b", root: "m_f85678b6", image: "m_11f8ac07", placeholder: "m_104cd71f" };
const Gw = Xn(null), MQ = Gw.Provider;
function LQ() {
  return { withinGroup: !!Tn(Gw) };
}
const OQ = (e, { spacing: t }) => ({
  group: {
    "--ag-spacing": Ca(t)
  }
}), Im = De((e, t) => {
  const n = X("AvatarGroup", null, e), { classNames: r, className: o, style: i, styles: s, unstyled: a, vars: l, spacing: c, attributes: u, ...d } = n, f = Oe({
    name: "AvatarGroup",
    classes: Lu,
    props: n,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: u,
    vars: l,
    varsResolver: OQ,
    rootSelector: "group"
  });
  return /* @__PURE__ */ E.jsx(MQ, { value: !0, children: /* @__PURE__ */ E.jsx(de, { ref: t, ...f("group"), ...d }) });
});
Im.classes = Lu;
Im.displayName = "@mantine/core/AvatarGroup";
function DQ(e) {
  return /* @__PURE__ */ E.jsx(
    "svg",
    {
      ...e,
      "data-avatar-placeholder-icon": !0,
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: /* @__PURE__ */ E.jsx(
        "path",
        {
          d: "M0.877014 7.49988C0.877014 3.84219 3.84216 0.877045 7.49985 0.877045C11.1575 0.877045 14.1227 3.84219 14.1227 7.49988C14.1227 11.1575 11.1575 14.1227 7.49985 14.1227C3.84216 14.1227 0.877014 11.1575 0.877014 7.49988ZM7.49985 1.82704C4.36683 1.82704 1.82701 4.36686 1.82701 7.49988C1.82701 8.97196 2.38774 10.3131 3.30727 11.3213C4.19074 9.94119 5.73818 9.02499 7.50023 9.02499C9.26206 9.02499 10.8093 9.94097 11.6929 11.3208C12.6121 10.3127 13.1727 8.97172 13.1727 7.49988C13.1727 4.36686 10.6328 1.82704 7.49985 1.82704ZM10.9818 11.9787C10.2839 10.7795 8.9857 9.97499 7.50023 9.97499C6.01458 9.97499 4.71624 10.7797 4.01845 11.9791C4.97952 12.7272 6.18765 13.1727 7.49985 13.1727C8.81227 13.1727 10.0206 12.727 10.9818 11.9787ZM5.14999 6.50487C5.14999 5.207 6.20212 4.15487 7.49999 4.15487C8.79786 4.15487 9.84999 5.207 9.84999 6.50487C9.84999 7.80274 8.79786 8.85487 7.49999 8.85487C6.20212 8.85487 5.14999 7.80274 5.14999 6.50487ZM7.49999 5.10487C6.72679 5.10487 6.09999 5.73167 6.09999 6.50487C6.09999 7.27807 6.72679 7.90487 7.49999 7.90487C8.27319 7.90487 8.89999 7.27807 8.89999 6.50487C8.89999 5.73167 8.27319 5.10487 7.49999 5.10487Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
function RQ(e) {
  let t = 0;
  for (let n = 0; n < e.length; n += 1) {
    const r = e.charCodeAt(n);
    t = (t << 5) - t + r, t |= 0;
  }
  return t;
}
const PQ = [
  "blue",
  "cyan",
  "grape",
  "green",
  "indigo",
  "lime",
  "orange",
  "pink",
  "red",
  "teal",
  "violet"
];
function BQ(e, t = PQ) {
  const n = RQ(e), r = Math.abs(n) % t.length;
  return t[r];
}
function $Q(e, t = 2) {
  const n = e.split(" ");
  return n.length === 1 ? e.slice(0, t).toUpperCase() : n.map((r) => r[0]).slice(0, t).join("").toUpperCase();
}
const HQ = (e, { size: t, radius: n, variant: r, gradient: o, color: i, autoContrast: s, name: a, allowedInitialsColors: l }) => {
  const c = i === "initials" && typeof a == "string" ? BQ(a, l) : i, u = e.variantColorResolver({
    color: c || "gray",
    theme: e,
    gradient: o,
    variant: r || "light",
    autoContrast: s
  });
  return {
    root: {
      "--avatar-size": et(t, "avatar-size"),
      "--avatar-radius": n === void 0 ? void 0 : Ut(n),
      "--avatar-bg": c || r ? u.background : void 0,
      "--avatar-color": c || r ? u.color : void 0,
      "--avatar-bd": c || r ? u.border : void 0
    }
  };
}, Ou = jt((e, t) => {
  const n = X("Avatar", null, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    src: c,
    alt: u,
    radius: d,
    color: f,
    gradient: h,
    imageProps: p,
    children: m,
    autoContrast: b,
    mod: y,
    name: k,
    allowedInitialsColors: C,
    attributes: _,
    ...w
  } = n, T = LQ(), [M, D] = fe(!c), R = Oe({
    name: "Avatar",
    props: n,
    classes: Lu,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: _,
    vars: l,
    varsResolver: HQ
  });
  return ie(() => D(!c), [c]), /* @__PURE__ */ E.jsx(
    de,
    {
      ...R("root"),
      mod: [{ "within-group": T.withinGroup }, y],
      ref: t,
      ...w,
      children: M || !c ? /* @__PURE__ */ E.jsx("span", { ...R("placeholder"), title: u, children: m || typeof k == "string" && $Q(k) || /* @__PURE__ */ E.jsx(DQ, {}) }) : /* @__PURE__ */ E.jsx(
        "img",
        {
          ...p,
          ...R("image"),
          src: c,
          alt: u,
          onError: (N) => {
            var B;
            D(!0), (B = p == null ? void 0 : p.onError) == null || B.call(p, N);
          }
        }
      )
    }
  );
});
Ou.classes = Lu;
Ou.displayName = "@mantine/core/Avatar";
Ou.Group = Im;
var Yw = { root: "m_347db0ec", "root--dot": "m_fbd81e3d", label: "m_5add502a", section: "m_91fdda9b" };
const FQ = (e, { radius: t, color: n, gradient: r, variant: o, size: i, autoContrast: s, circle: a }) => {
  const l = e.variantColorResolver({
    color: n || e.primaryColor,
    theme: e,
    gradient: r,
    variant: o || "filled",
    autoContrast: s
  });
  return {
    root: {
      "--badge-height": et(i, "badge-height"),
      "--badge-padding-x": et(i, "badge-padding-x"),
      "--badge-fz": et(i, "badge-fz"),
      "--badge-radius": a || t === void 0 ? void 0 : Ut(t),
      "--badge-bg": n || o ? l.background : void 0,
      "--badge-color": n || o ? l.color : void 0,
      "--badge-bd": n || o ? l.border : void 0,
      "--badge-dot-color": o === "dot" ? Fr(n, e) : void 0
    }
  };
}, Nm = jt((e, t) => {
  const n = X("Badge", null, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    radius: c,
    color: u,
    gradient: d,
    leftSection: f,
    rightSection: h,
    children: p,
    variant: m,
    fullWidth: b,
    autoContrast: y,
    circle: k,
    mod: C,
    attributes: _,
    ...w
  } = n, T = Oe({
    name: "Badge",
    props: n,
    classes: Yw,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: _,
    vars: l,
    varsResolver: FQ
  });
  return /* @__PURE__ */ E.jsxs(
    de,
    {
      variant: m,
      mod: [
        {
          block: b,
          circle: k,
          "with-right-section": !!h,
          "with-left-section": !!f
        },
        C
      ],
      ...T("root", { variant: m }),
      ref: t,
      ...w,
      children: [
        f && /* @__PURE__ */ E.jsx("span", { ...T("section"), "data-position": "left", children: f }),
        /* @__PURE__ */ E.jsx("span", { ...T("label"), children: p }),
        h && /* @__PURE__ */ E.jsx("span", { ...T("section"), "data-position": "right", children: h })
      ]
    }
  );
});
Nm.classes = Yw;
Nm.displayName = "@mantine/core/Badge";
var ts = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844", groupSection: "m_70be2a01" };
const ey = {
  orientation: "horizontal"
}, UQ = (e, { borderWidth: t }) => ({
  group: { "--button-border-width": U(t) }
}), Mm = De((e, t) => {
  const n = X("ButtonGroup", ey, e), {
    className: r,
    style: o,
    classNames: i,
    styles: s,
    unstyled: a,
    orientation: l,
    vars: c,
    borderWidth: u,
    variant: d,
    mod: f,
    attributes: h,
    ...p
  } = X("ButtonGroup", ey, e), m = Oe({
    name: "ButtonGroup",
    props: n,
    classes: ts,
    className: r,
    style: o,
    classNames: i,
    styles: s,
    unstyled: a,
    attributes: h,
    vars: c,
    varsResolver: UQ,
    rootSelector: "group"
  });
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ...m("group"),
      ref: t,
      variant: d,
      mod: [{ "data-orientation": l }, f],
      role: "group",
      ...p
    }
  );
});
Mm.classes = ts;
Mm.displayName = "@mantine/core/ButtonGroup";
const jQ = (e, { radius: t, color: n, gradient: r, variant: o, autoContrast: i, size: s }) => {
  const a = e.variantColorResolver({
    color: n || e.primaryColor,
    theme: e,
    gradient: r,
    variant: o || "filled",
    autoContrast: i
  });
  return {
    groupSection: {
      "--section-height": et(s, "section-height"),
      "--section-padding-x": et(s, "section-padding-x"),
      "--section-fz": s != null && s.includes("compact") ? an(s.replace("compact-", "")) : an(s),
      "--section-radius": t === void 0 ? void 0 : Ut(t),
      "--section-bg": n || o ? a.background : void 0,
      "--section-color": a.color,
      "--section-bd": n || o ? a.border : void 0
    }
  };
}, Lm = De((e, t) => {
  const n = X("ButtonGroupSection", null, e), {
    className: r,
    style: o,
    classNames: i,
    styles: s,
    unstyled: a,
    vars: l,
    variant: c,
    gradient: u,
    radius: d,
    autoContrast: f,
    attributes: h,
    ...p
  } = n, m = Oe({
    name: "ButtonGroupSection",
    props: n,
    classes: ts,
    className: r,
    style: o,
    classNames: i,
    styles: s,
    unstyled: a,
    attributes: h,
    vars: l,
    varsResolver: jQ,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ E.jsx(de, { ...m("groupSection"), ref: t, variant: c, ...p });
});
Lm.classes = ts;
Lm.displayName = "@mantine/core/ButtonGroupSection";
const VQ = {
  in: { opacity: 1, transform: `translate(-50%, calc(-50% + ${U(1)}))` },
  out: { opacity: 0, transform: "translate(-50%, -200%)" },
  common: { transformOrigin: "center" },
  transitionProperty: "transform, opacity"
}, zQ = (e, { radius: t, color: n, gradient: r, variant: o, size: i, justify: s, autoContrast: a }) => {
  const l = e.variantColorResolver({
    color: n || e.primaryColor,
    theme: e,
    gradient: r,
    variant: o || "filled",
    autoContrast: a
  });
  return {
    root: {
      "--button-justify": s,
      "--button-height": et(i, "button-height"),
      "--button-padding-x": et(i, "button-padding-x"),
      "--button-fz": i != null && i.includes("compact") ? an(i.replace("compact-", "")) : an(i),
      "--button-radius": t === void 0 ? void 0 : Ut(t),
      "--button-bg": n || o ? l.background : void 0,
      "--button-hover": n || o ? l.hover : void 0,
      "--button-color": l.color,
      "--button-bd": n || o ? l.border : void 0,
      "--button-hover-color": n || o ? l.hoverColor : void 0
    }
  };
}, sr = jt((e, t) => {
  const n = X("Button", null, e), {
    style: r,
    vars: o,
    className: i,
    color: s,
    disabled: a,
    children: l,
    leftSection: c,
    rightSection: u,
    fullWidth: d,
    variant: f,
    radius: h,
    loading: p,
    loaderProps: m,
    gradient: b,
    classNames: y,
    styles: k,
    unstyled: C,
    "data-disabled": _,
    autoContrast: w,
    mod: T,
    attributes: M,
    ...D
  } = n, R = Oe({
    name: "Button",
    props: n,
    classes: ts,
    className: i,
    style: r,
    classNames: y,
    styles: k,
    unstyled: C,
    attributes: M,
    vars: o,
    varsResolver: zQ
  }), N = !!c, B = !!u;
  return /* @__PURE__ */ E.jsxs(
    To,
    {
      ref: t,
      ...R("root", { active: !a && !p && !_ }),
      unstyled: C,
      variant: f,
      disabled: a || p,
      mod: [
        {
          disabled: a || _,
          loading: p,
          block: d,
          "with-left-section": N,
          "with-right-section": B
        },
        T
      ],
      ...D,
      children: [
        typeof p == "boolean" && /* @__PURE__ */ E.jsx(po, { mounted: p, transition: VQ, duration: 150, children: (F) => /* @__PURE__ */ E.jsx(de, { component: "span", ...R("loader", { style: F }), "aria-hidden": !0, children: /* @__PURE__ */ E.jsx(
          xo,
          {
            color: "var(--button-color)",
            size: "calc(var(--button-height) / 1.8)",
            ...m
          }
        ) }) }),
        /* @__PURE__ */ E.jsxs("span", { ...R("inner"), children: [
          c && /* @__PURE__ */ E.jsx(de, { component: "span", ...R("section"), mod: { position: "left" }, children: c }),
          /* @__PURE__ */ E.jsx(de, { component: "span", mod: { loading: p }, ...R("label"), children: l }),
          u && /* @__PURE__ */ E.jsx(de, { component: "span", ...R("section"), mod: { position: "right" }, children: u })
        ] })
      ]
    }
  );
});
sr.classes = ts;
sr.displayName = "@mantine/core/Button";
sr.Group = Mm;
sr.GroupSection = Lm;
const [qQ, WQ] = Eu(
  "Card component was not found in tree"
);
var Om = { root: "m_e615b15f", section: "m_599a2148" };
const Du = jt((e, t) => {
  const n = X("CardSection", null, e), { classNames: r, className: o, style: i, styles: s, vars: a, withBorder: l, inheritPadding: c, mod: u, ...d } = n, f = WQ();
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ref: t,
      mod: [{ "with-border": l, "inherit-padding": c }, u],
      ...f.getStyles("section", { className: o, style: i, styles: s, classNames: r }),
      ...d
    }
  );
});
Du.classes = Om;
Du.displayName = "@mantine/core/CardSection";
const GQ = (e, { padding: t }) => ({
  root: {
    "--card-padding": Ca(t)
  }
}), wa = jt((e, t) => {
  const n = X("Card", null, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    children: c,
    padding: u,
    attributes: d,
    ...f
  } = n, h = Oe({
    name: "Card",
    props: n,
    classes: Om,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: d,
    vars: l,
    varsResolver: GQ
  }), p = xh.toArray(c), m = p.map((b, y) => typeof b == "object" && b && "type" in b && b.type === Du ? $i(b, {
    "data-first-section": y === 0 || void 0,
    "data-last-section": y === p.length - 1 || void 0
  }) : b);
  return /* @__PURE__ */ E.jsx(qQ, { value: { getStyles: h }, children: /* @__PURE__ */ E.jsx(Cm, { ref: t, unstyled: a, ...h("root"), ...f, children: m }) });
});
wa.classes = Om;
wa.displayName = "@mantine/core/Card";
wa.Section = Du;
var Kw = { root: "m_f59ffda3", label: "m_be049a53", "label--outline": "m_3904c1af", "label--filled": "m_fa109255", "label--light": "m_f7e165c3", iconWrapper: "m_9ac86df9", checkIcon: "m_d6d72580", input: "m_bde07329" };
const [YQ, KQ] = ku();
function Qw(e) {
  const { value: t, defaultValue: n, onChange: r, multiple: o, children: i } = X("ChipGroup", null, e), [s, a] = Zi({
    value: t,
    defaultValue: n,
    finalValue: o ? [] : null,
    onChange: r
  }), l = (u) => Array.isArray(s) ? s.includes(u) : u === s, c = (u) => {
    const d = u.currentTarget.value;
    Array.isArray(s) ? a(s.includes(d) ? s.filter((f) => f !== d) : [...s, d]) : a(d);
  };
  return /* @__PURE__ */ E.jsx(YQ, { value: { isChipSelected: l, onChange: c, multiple: o }, children: i });
}
Qw.displayName = "@mantine/core/ChipGroup";
const QQ = {
  type: "checkbox"
}, ZQ = (e, { size: t, radius: n, variant: r, color: o, autoContrast: i }) => {
  const s = e.variantColorResolver({
    color: o || e.primaryColor,
    theme: e,
    variant: r || "filled",
    autoContrast: i
  });
  return {
    root: {
      "--chip-fz": an(t),
      "--chip-size": et(t, "chip-size"),
      "--chip-radius": n === void 0 ? void 0 : Ut(n),
      "--chip-checked-padding": et(t, "chip-checked-padding"),
      "--chip-padding": et(t, "chip-padding"),
      "--chip-icon-size": et(t, "chip-icon-size"),
      "--chip-bg": o || r ? s.background : void 0,
      "--chip-hover": o || r ? s.hover : void 0,
      "--chip-color": o || r ? s.color : void 0,
      "--chip-bd": o || r ? s.border : void 0,
      "--chip-spacing": et(t, "chip-spacing")
    }
  };
}, Ru = De((e, t) => {
  const n = X("Chip", QQ, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    id: c,
    checked: u,
    defaultChecked: d,
    onChange: f,
    value: h,
    wrapperProps: p,
    type: m,
    disabled: b,
    children: y,
    size: k,
    variant: C,
    icon: _,
    rootRef: w,
    autoContrast: T,
    mod: M,
    attributes: D,
    ...R
  } = n, N = Oe({
    name: "Chip",
    classes: Kw,
    props: n,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: D,
    vars: l,
    varsResolver: ZQ
  }), B = KQ(), F = Qi(c), { styleProps: W, rest: L } = vu(R), [H, J] = Zi({
    value: u,
    defaultValue: d,
    finalValue: !1,
    onChange: f
  }), Y = B ? {
    checked: B.isChipSelected(h),
    onChange: (Q) => {
      B.onChange(Q), f == null || f(Q.currentTarget.checked);
    },
    type: B.multiple ? "checkbox" : "radio"
  } : {}, V = Y.checked || H;
  return /* @__PURE__ */ E.jsxs(
    de,
    {
      size: k,
      variant: C,
      ref: w,
      mod: M,
      ...N("root"),
      ...W,
      ...p,
      children: [
        /* @__PURE__ */ E.jsx(
          "input",
          {
            type: m,
            ...N("input"),
            checked: V,
            onChange: (Q) => J(Q.currentTarget.checked),
            id: F,
            disabled: b,
            ref: t,
            value: h,
            ...Y,
            ...L
          }
        ),
        /* @__PURE__ */ E.jsxs(
          "label",
          {
            htmlFor: F,
            "data-checked": V || void 0,
            "data-disabled": b || void 0,
            ...N("label", { variant: C || "filled" }),
            children: [
              V && _ !== null && _ !== !1 && /* @__PURE__ */ E.jsx("span", { ...N("iconWrapper"), children: _ === void 0 ? /* @__PURE__ */ E.jsx(kc, { ...N("checkIcon") }) : _ }),
              /* @__PURE__ */ E.jsx("span", { children: y })
            ]
          }
        )
      ]
    }
  );
});
Ru.classes = Kw;
Ru.displayName = "@mantine/core/Chip";
Ru.Group = Qw;
var Zw = { root: "m_3eebeb36", label: "m_9e365f20" };
const XQ = {
  orientation: "horizontal"
}, JQ = (e, { color: t, variant: n, size: r }) => ({
  root: {
    "--divider-color": t ? Fr(t, e) : void 0,
    "--divider-border-style": n,
    "--divider-size": et(r, "divider-size")
  }
}), Dm = De((e, t) => {
  const n = X("Divider", XQ, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    color: c,
    orientation: u,
    label: d,
    labelPosition: f,
    mod: h,
    attributes: p,
    ...m
  } = n, b = Oe({
    name: "Divider",
    classes: Zw,
    props: n,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: p,
    vars: l,
    varsResolver: JQ
  });
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ref: t,
      mod: [{ orientation: u, "with-label": !!d }, h],
      ...b("root"),
      ...m,
      role: "separator",
      children: d && /* @__PURE__ */ E.jsx(de, { component: "span", mod: { position: f }, ...b("label"), children: d })
    }
  );
});
Dm.classes = Zw;
Dm.displayName = "@mantine/core/Divider";
const eZ = {
  multiple: !1
}, Xw = se(
  (e, t) => {
    const {
      onChange: n,
      children: r,
      multiple: o,
      accept: i,
      name: s,
      form: a,
      resetRef: l,
      disabled: c,
      capture: u,
      inputProps: d,
      ...f
    } = X("FileButton", eZ, e), h = Ae(null), p = () => {
      var y;
      !c && ((y = h.current) == null || y.click());
    }, m = (y) => {
      if (y.currentTarget.files === null)
        return n(o ? [] : null);
      n(o ? Array.from(y.currentTarget.files) : y.currentTarget.files[0] || null);
    };
    return bc(l, () => {
      h.current && (h.current.value = "");
    }), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        "input",
        {
          style: { display: "none" },
          type: "file",
          accept: i,
          multiple: o,
          onChange: m,
          ref: or(t, h),
          name: s,
          form: a,
          capture: u,
          ...d
        }
      ),
      r({ onClick: p, ...f })
    ] });
  }
);
Xw.displayName = "@mantine/core/FileButton";
const tZ = ({ value: e }) => /* @__PURE__ */ E.jsx("div", { style: { overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }, children: Array.isArray(e) ? e.map((t) => t.name).join(", ") : e == null ? void 0 : e.name }), nZ = {
  valueComponent: tZ,
  size: "sm"
}, Rm = De((e, t) => {
  const n = X("FileInput", nZ, e), {
    unstyled: r,
    vars: o,
    onChange: i,
    value: s,
    defaultValue: a,
    multiple: l,
    accept: c,
    name: u,
    form: d,
    valueComponent: f,
    clearable: h,
    clearButtonProps: p,
    readOnly: m,
    capture: b,
    fileInputProps: y,
    rightSection: k,
    size: C,
    placeholder: _,
    component: w,
    resetRef: T,
    classNames: M,
    styles: D,
    attributes: R,
    ...N
  } = n, B = Ae(null), { resolvedClassNames: F, resolvedStyles: W } = wu({
    classNames: M,
    styles: D,
    props: n
  }), [L, H] = Zi({
    value: s,
    defaultValue: a,
    onChange: i,
    finalValue: l ? [] : null
  }), J = Array.isArray(L) ? L.length !== 0 : L !== null, Y = k || (h && J && !m ? /* @__PURE__ */ E.jsx(
    _u,
    {
      ...p,
      variant: "subtle",
      onClick: () => H(l ? [] : null),
      size: C,
      unstyled: r
    }
  ) : null);
  return ie(() => {
    var V;
    (Array.isArray(L) && L.length === 0 || L === null) && ((V = B.current) == null || V.call(B));
  }, [L]), /* @__PURE__ */ E.jsx(
    Xw,
    {
      onChange: H,
      multiple: l,
      accept: c,
      name: u,
      form: d,
      resetRef: or(B, T),
      disabled: m,
      capture: b,
      inputProps: y,
      children: (V) => /* @__PURE__ */ E.jsx(
        es,
        {
          component: w || "button",
          ref: t,
          rightSection: Y,
          ...V,
          ...N,
          __staticSelector: "FileInput",
          multiline: !0,
          type: "button",
          pointer: !0,
          __stylesApiProps: n,
          unstyled: r,
          size: C,
          classNames: M,
          styles: D,
          attributes: R,
          children: J ? /* @__PURE__ */ E.jsx(f, { value: L }) : /* @__PURE__ */ E.jsx(
            Cn.Placeholder,
            {
              __staticSelector: "FileInput",
              classNames: F,
              styles: W,
              attributes: R,
              children: _
            }
          )
        }
      )
    }
  );
});
Rm.classes = es.classes;
Rm.displayName = "@mantine/core/FileInput";
const rZ = Rm;
var Jw = { root: "m_6e45937b", loader: "m_e8eb006c", overlay: "m_df587f17" };
const ty = {
  transitionProps: { transition: "fade", duration: 0 },
  overlayProps: { backgroundOpacity: 0.75 },
  zIndex: ka("overlay")
}, oZ = (e, { zIndex: t }) => ({
  root: {
    "--lo-z-index": t == null ? void 0 : t.toString()
  }
}), Pm = De((e, t) => {
  const n = X("LoadingOverlay", ty, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    transitionProps: c,
    loaderProps: u,
    overlayProps: d,
    visible: f,
    zIndex: h,
    attributes: p,
    ...m
  } = n, b = dn(), y = Oe({
    name: "LoadingOverlay",
    classes: Jw,
    props: n,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: p,
    vars: l,
    varsResolver: oZ
  }), k = { ...ty.overlayProps, ...d };
  return /* @__PURE__ */ E.jsx(po, { transition: "fade", ...c, mounted: !!f, children: (C) => /* @__PURE__ */ E.jsxs(de, { ...y("root", { style: C }), ref: t, ...m, children: [
    /* @__PURE__ */ E.jsx(xo, { ...y("loader"), unstyled: a, ...u }),
    /* @__PURE__ */ E.jsx(
      na,
      {
        ...k,
        ...y("overlay"),
        darkHidden: !0,
        unstyled: a,
        color: (d == null ? void 0 : d.color) || b.white
      }
    ),
    /* @__PURE__ */ E.jsx(
      na,
      {
        ...k,
        ...y("overlay"),
        lightHidden: !0,
        unstyled: a,
        color: (d == null ? void 0 : d.color) || b.colors.dark[5]
      }
    )
  ] }) });
});
Pm.classes = Jw;
Pm.displayName = "@mantine/core/LoadingOverlay";
const [iZ, wo] = Eu(
  "Menu component was not found in the tree"
);
var vo = { dropdown: "m_dc9b7c9f", label: "m_9bfac126", divider: "m_efdf90cb", item: "m_99ac2aa1", itemLabel: "m_5476e0d3", itemSection: "m_8b75e504", chevron: "m_b85b0bed" };
const Bm = De((e, t) => {
  const { classNames: n, className: r, style: o, styles: i, vars: s, ...a } = X(
    "MenuDivider",
    null,
    e
  ), l = wo();
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ref: t,
      ...l.getStyles("divider", { className: r, style: o, styles: i, classNames: n }),
      ...a
    }
  );
});
Bm.classes = vo;
Bm.displayName = "@mantine/core/MenuDivider";
const $m = De((e, t) => {
  const {
    classNames: n,
    className: r,
    style: o,
    styles: i,
    vars: s,
    onMouseEnter: a,
    onMouseLeave: l,
    onKeyDown: c,
    children: u,
    ...d
  } = X("MenuDropdown", null, e), f = Ae(null), h = wo(), p = sn(c, (y) => {
    var k, C;
    (y.key === "ArrowUp" || y.key === "ArrowDown") && (y.preventDefault(), (C = (k = f.current) == null ? void 0 : k.querySelectorAll("[data-menu-item]:not(:disabled)")[0]) == null || C.focus());
  }), m = sn(
    a,
    () => (h.trigger === "hover" || h.trigger === "click-hover") && h.openDropdown()
  ), b = sn(
    l,
    () => (h.trigger === "hover" || h.trigger === "click-hover") && h.closeDropdown()
  );
  return /* @__PURE__ */ E.jsxs(
    ir.Dropdown,
    {
      ...d,
      onMouseEnter: m,
      onMouseLeave: b,
      role: "menu",
      "aria-orientation": "vertical",
      ref: or(t, f),
      ...h.getStyles("dropdown", {
        className: r,
        style: o,
        styles: i,
        classNames: n,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      onKeyDown: p,
      children: [
        h.withInitialFocusPlaceholder && /* @__PURE__ */ E.jsx("div", { tabIndex: -1, "data-autofocus": !0, "data-mantine-stop-propagation": !0, style: { outline: 0 } }),
        u
      ]
    }
  );
});
$m.classes = vo;
$m.displayName = "@mantine/core/MenuDropdown";
const [sZ, Pu] = ku(), Hm = jt((e, t) => {
  const {
    classNames: n,
    className: r,
    style: o,
    styles: i,
    vars: s,
    color: a,
    closeMenuOnClick: l,
    leftSection: c,
    rightSection: u,
    children: d,
    disabled: f,
    "data-disabled": h,
    ...p
  } = X("MenuItem", null, e), m = wo(), b = Pu(), y = dn(), { dir: k } = Xi(), C = Ae(null), _ = p, w = sn(_.onClick, () => {
    h || (typeof l == "boolean" ? l && m.closeDropdownImmediately() : m.closeOnItemClick && m.closeDropdownImmediately());
  }), T = a ? y.variantColorResolver({ color: a, theme: y, variant: "light" }) : void 0, M = a ? ti({ color: a, theme: y }) : null, D = sn(_.onKeyDown, (R) => {
    R.key === "ArrowLeft" && b && (b.close(), b.focusParentItem());
  });
  return /* @__PURE__ */ E.jsxs(
    To,
    {
      onMouseDown: (R) => R.preventDefault(),
      ...p,
      unstyled: m.unstyled,
      tabIndex: m.menuItemTabIndex,
      ...m.getStyles("item", { className: r, style: o, styles: i, classNames: n }),
      ref: or(C, t),
      role: "menuitem",
      disabled: f,
      "data-menu-item": !0,
      "data-disabled": f || h || void 0,
      "data-mantine-stop-propagation": !0,
      onClick: w,
      onKeyDown: fm({
        siblingSelector: "[data-menu-item]:not([data-disabled])",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: m.loop,
        dir: k,
        orientation: "vertical",
        onKeyDown: D
      }),
      __vars: {
        "--menu-item-color": M != null && M.isThemeColor && (M == null ? void 0 : M.shade) === void 0 ? `var(--mantine-color-${M.color}-6)` : T == null ? void 0 : T.color,
        "--menu-item-hover": T == null ? void 0 : T.hover
      },
      children: [
        c && /* @__PURE__ */ E.jsx("div", { ...m.getStyles("itemSection", { styles: i, classNames: n }), "data-position": "left", children: c }),
        d && /* @__PURE__ */ E.jsx("div", { ...m.getStyles("itemLabel", { styles: i, classNames: n }), children: d }),
        u && /* @__PURE__ */ E.jsx("div", { ...m.getStyles("itemSection", { styles: i, classNames: n }), "data-position": "right", children: u })
      ]
    }
  );
});
Hm.classes = vo;
Hm.displayName = "@mantine/core/MenuItem";
const Fm = De((e, t) => {
  const { classNames: n, className: r, style: o, styles: i, vars: s, ...a } = X(
    "MenuLabel",
    null,
    e
  ), l = wo();
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ref: t,
      ...l.getStyles("label", { className: r, style: o, styles: i, classNames: n }),
      ...a
    }
  );
});
Fm.classes = vo;
Fm.displayName = "@mantine/core/MenuLabel";
const Um = De((e, t) => {
  const {
    classNames: n,
    className: r,
    style: o,
    styles: i,
    vars: s,
    onMouseEnter: a,
    onMouseLeave: l,
    onKeyDown: c,
    children: u,
    ...d
  } = X("MenuSubDropdown", null, e), f = Ae(null), h = wo(), p = Pu(), m = sn(a, p == null ? void 0 : p.open), b = sn(l, p == null ? void 0 : p.close);
  return /* @__PURE__ */ E.jsx(
    ir.Dropdown,
    {
      ...d,
      onMouseEnter: m,
      onMouseLeave: b,
      role: "menu",
      "aria-orientation": "vertical",
      ref: or(t, f),
      ...h.getStyles("dropdown", {
        className: r,
        style: o,
        styles: i,
        classNames: n,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      children: u
    }
  );
});
Um.classes = vo;
Um.displayName = "@mantine/core/MenuSubDropdown";
const jm = jt((e, t) => {
  const {
    classNames: n,
    className: r,
    style: o,
    styles: i,
    vars: s,
    color: a,
    leftSection: l,
    rightSection: c,
    children: u,
    disabled: d,
    "data-disabled": f,
    closeMenuOnClick: h,
    ...p
  } = X("MenuSubItem", null, e), m = wo(), b = Pu(), y = dn(), { dir: k } = Xi(), C = Ae(null), _ = p, w = a ? y.variantColorResolver({ color: a, theme: y, variant: "light" }) : void 0, T = a ? ti({ color: a, theme: y }) : null, M = sn(_.onKeyDown, (B) => {
    B.key === "ArrowRight" && (b == null || b.open(), b == null || b.focusFirstItem()), B.key === "ArrowLeft" && (b != null && b.parentContext) && (b.parentContext.close(), b.parentContext.focusParentItem());
  }), D = sn(_.onClick, () => {
    !f && h && m.closeDropdownImmediately();
  }), R = sn(_.onMouseEnter, b == null ? void 0 : b.open), N = sn(_.onMouseLeave, b == null ? void 0 : b.close);
  return /* @__PURE__ */ E.jsxs(
    To,
    {
      onMouseDown: (B) => B.preventDefault(),
      ...p,
      unstyled: m.unstyled,
      tabIndex: m.menuItemTabIndex,
      ...m.getStyles("item", { className: r, style: o, styles: i, classNames: n }),
      ref: or(C, t),
      role: "menuitem",
      disabled: d,
      "data-menu-item": !0,
      "data-sub-menu-item": !0,
      "data-disabled": d || f || void 0,
      "data-mantine-stop-propagation": !0,
      onMouseEnter: R,
      onMouseLeave: N,
      onClick: D,
      onKeyDown: fm({
        siblingSelector: "[data-menu-item]:not([data-disabled])",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: m.loop,
        dir: k,
        orientation: "vertical",
        onKeyDown: M
      }),
      __vars: {
        "--menu-item-color": T != null && T.isThemeColor && (T == null ? void 0 : T.shade) === void 0 ? `var(--mantine-color-${T.color}-6)` : w == null ? void 0 : w.color,
        "--menu-item-hover": w == null ? void 0 : w.hover
      },
      children: [
        l && /* @__PURE__ */ E.jsx("div", { ...m.getStyles("itemSection", { styles: i, classNames: n }), "data-position": "left", children: l }),
        u && /* @__PURE__ */ E.jsx("div", { ...m.getStyles("itemLabel", { styles: i, classNames: n }), children: u }),
        /* @__PURE__ */ E.jsx("div", { ...m.getStyles("itemSection", { styles: i, classNames: n }), "data-position": "right", children: c || /* @__PURE__ */ E.jsx(qw, { ...m.getStyles("chevron"), size: 14 }) })
      ]
    }
  );
});
jm.classes = vo;
jm.displayName = "@mantine/core/MenuSubItem";
function ev({ children: e, refProp: t }) {
  if (!sw(e))
    throw new Error(
      "Menu.Sub.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  return wo(), /* @__PURE__ */ E.jsx(ir.Target, { refProp: t, popupType: "menu", children: e });
}
ev.displayName = "@mantine/core/MenuSubTarget";
const aZ = {
  offset: 0,
  position: "right-start",
  transitionProps: { duration: 0 },
  openDelay: 0,
  middlewares: {
    shift: {
      // Enable crossAxis shift to keep submenu dropdown within viewport bounds when positioned horizontally
      crossAxis: !0
    }
  }
};
function ns(e) {
  const { children: t, closeDelay: n, openDelay: r, ...o } = X("MenuSub", aZ, e), i = Qi(), [s, { open: a, close: l }] = SY(!1), c = Pu(), { openDropdown: u, closeDropdown: d } = zw({
    open: a,
    close: l,
    closeDelay: n,
    openDelay: r
  }), f = () => window.setTimeout(() => {
    var p, m;
    (m = (p = document.getElementById(`${i}-dropdown`)) == null ? void 0 : p.querySelectorAll("[data-menu-item]:not([data-disabled])")[0]) == null || m.focus();
  }, 16), h = () => window.setTimeout(() => {
    var p;
    (p = document.getElementById(`${i}-target`)) == null || p.focus();
  }, 16);
  return /* @__PURE__ */ E.jsx(
    sZ,
    {
      value: {
        opened: s,
        close: d,
        open: u,
        focusFirstItem: f,
        focusParentItem: h,
        parentContext: c
      },
      children: /* @__PURE__ */ E.jsx(ir, { opened: s, withinPortal: !1, withArrow: !1, id: i, ...o, children: t })
    }
  );
}
ns.extend = (e) => e;
ns.displayName = "@mantine/core/MenuSub";
ns.Target = ev;
ns.Dropdown = Um;
ns.Item = jm;
const lZ = {
  refProp: "ref"
}, tv = se((e, t) => {
  const { children: n, refProp: r, ...o } = X("MenuTarget", lZ, e), i = xa(n);
  if (!i)
    throw new Error(
      "Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const s = wo(), a = i.props, l = sn(a.onClick, () => {
    s.trigger === "click" ? s.toggleDropdown() : s.trigger === "click-hover" && (s.setOpenedViaClick(!0), s.opened || s.openDropdown());
  }), c = sn(
    a.onMouseEnter,
    () => (s.trigger === "hover" || s.trigger === "click-hover") && s.openDropdown()
  ), u = sn(a.onMouseLeave, () => {
    (s.trigger === "hover" || s.trigger === "click-hover" && !s.openedViaClick) && s.closeDropdown();
  });
  return /* @__PURE__ */ E.jsx(ir.Target, { refProp: r, popupType: "menu", ref: t, ...o, children: $i(i, {
    onClick: l,
    onMouseEnter: c,
    onMouseLeave: u,
    "data-expanded": s.opened ? !0 : void 0
  }) });
});
tv.displayName = "@mantine/core/MenuTarget";
const cZ = {
  trapFocus: !0,
  closeOnItemClick: !0,
  withInitialFocusPlaceholder: !0,
  clickOutsideEvents: ["mousedown", "touchstart", "keydown"],
  loop: !0,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100,
  menuItemTabIndex: -1
};
function it(e) {
  const t = X("Menu", cZ, e), {
    children: n,
    onOpen: r,
    onClose: o,
    opened: i,
    defaultOpened: s,
    trapFocus: a,
    onChange: l,
    closeOnItemClick: c,
    loop: u,
    closeOnEscape: d,
    trigger: f,
    openDelay: h,
    closeDelay: p,
    classNames: m,
    styles: b,
    unstyled: y,
    variant: k,
    vars: C,
    menuItemTabIndex: _,
    keepMounted: w,
    withInitialFocusPlaceholder: T,
    attributes: M,
    ...D
  } = t, R = Oe({
    name: "Menu",
    classes: vo,
    props: t,
    classNames: m,
    styles: b,
    unstyled: y,
    attributes: M
  }), [N, B] = Zi({
    value: i,
    defaultValue: s,
    finalValue: !1,
    onChange: l
  }), [F, W] = fe(!1), L = () => {
    B(!1), W(!1), N && (o == null || o());
  }, H = () => {
    B(!0), !N && (r == null || r());
  }, J = () => {
    N ? L() : H();
  }, { openDropdown: Y, closeDropdown: V } = zw({ open: H, close: L, closeDelay: p, openDelay: h }), Q = (ee) => cY("[data-menu-item]", "[data-menu-dropdown]", ee), { resolvedClassNames: S, resolvedStyles: ue } = wu({
    classNames: m,
    styles: b,
    props: t
  });
  return /* @__PURE__ */ E.jsx(
    iZ,
    {
      value: {
        getStyles: R,
        opened: N,
        toggleDropdown: J,
        getItemIndex: Q,
        openedViaClick: F,
        setOpenedViaClick: W,
        closeOnItemClick: c,
        closeDropdown: f === "click" ? L : V,
        openDropdown: f === "click" ? H : Y,
        closeDropdownImmediately: L,
        loop: u,
        trigger: f,
        unstyled: y,
        menuItemTabIndex: _,
        withInitialFocusPlaceholder: T
      },
      children: /* @__PURE__ */ E.jsx(
        ir,
        {
          returnFocus: !0,
          ...D,
          opened: N,
          onChange: J,
          defaultOpened: s,
          trapFocus: w ? !1 : a,
          closeOnEscape: d,
          __staticSelector: "Menu",
          classNames: S,
          styles: ue,
          unstyled: y,
          variant: k,
          keepMounted: w,
          children: n
        }
      )
    }
  );
}
it.extend = (e) => e;
it.withProps = BK(it);
it.classes = vo;
it.displayName = "@mantine/core/Menu";
it.Item = Hm;
it.Label = Fm;
it.Dropdown = $m;
it.Target = tv;
it.Divider = Bm;
it.Sub = ns;
const uZ = {
  duration: 100,
  transition: "fade"
};
function ny(e, t) {
  return { ...uZ, ...t, ...e };
}
var Bu = { tooltip: "m_1b3c8819", arrow: "m_f898399f" };
function dZ({
  offset: e,
  position: t,
  defaultOpened: n
}) {
  const [r, o] = fe(n), i = Ae(null), { x: s, y: a, elements: l, refs: c, update: u, placement: d } = gu({
    placement: t,
    middleware: [
      mo({
        crossAxis: !0,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  }), f = d.includes("right") ? e : t.includes("left") ? e * -1 : 0, h = d.includes("bottom") ? e : t.includes("top") ? e * -1 : 0, p = Z(
    ({ clientX: m, clientY: b }) => {
      c.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: m,
            y: b,
            left: m + f,
            top: b + h,
            right: m,
            bottom: b
          };
        }
      });
    },
    [l.reference]
  );
  return ie(() => {
    if (c.floating.current) {
      const m = i.current;
      m.addEventListener("mousemove", p);
      const b = ll(c.floating.current);
      return b.forEach((y) => {
        y.addEventListener("scroll", u);
      }), () => {
        m.removeEventListener("mousemove", p), b.forEach((y) => {
          y.removeEventListener("scroll", u);
        });
      };
    }
  }, [l.reference, c.floating.current, u, p, r]), { handleMouseMove: p, x: s, y: a, opened: r, setOpened: o, boundaryRef: i, floating: c.setFloating };
}
const fZ = {
  refProp: "ref",
  withinPortal: !0,
  offset: 10,
  position: "right",
  zIndex: ka("popover")
}, hZ = (e, { radius: t, color: n }) => ({
  tooltip: {
    "--tooltip-radius": t === void 0 ? void 0 : Ut(t),
    "--tooltip-bg": n ? Fr(n, e) : void 0,
    "--tooltip-color": n ? "var(--mantine-color-white)" : void 0
  }
}), Vm = De((e, t) => {
  const n = X("TooltipFloating", fZ, e), {
    children: r,
    refProp: o,
    withinPortal: i,
    style: s,
    className: a,
    classNames: l,
    styles: c,
    unstyled: u,
    radius: d,
    color: f,
    label: h,
    offset: p,
    position: m,
    multiline: b,
    zIndex: y,
    disabled: k,
    defaultOpened: C,
    variant: _,
    vars: w,
    portalProps: T,
    attributes: M,
    ...D
  } = n, R = dn(), N = Oe({
    name: "TooltipFloating",
    props: n,
    classes: Bu,
    className: a,
    style: s,
    classNames: l,
    styles: c,
    unstyled: u,
    attributes: M,
    rootSelector: "tooltip",
    vars: w,
    varsResolver: hZ
  }), { handleMouseMove: B, x: F, y: W, opened: L, boundaryRef: H, floating: J, setOpened: Y } = dZ({
    offset: p,
    position: m,
    defaultOpened: C
  }), V = xa(r);
  if (!V)
    throw new Error(
      "[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const Q = or(H, hm(V), t), S = V.props, ue = (A) => {
    var le;
    (le = S.onMouseEnter) == null || le.call(S, A), B(A), Y(!0);
  }, ee = (A) => {
    var le;
    (le = S.onMouseLeave) == null || le.call(S, A), Y(!1);
  };
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(Bi, { ...T, withinPortal: i, children: /* @__PURE__ */ E.jsx(
      de,
      {
        ...D,
        ...N("tooltip", {
          style: {
            ...Cw(s, R),
            zIndex: y,
            display: !k && L ? "block" : "none",
            top: (W && Math.round(W)) ?? "",
            left: (F && Math.round(F)) ?? ""
          }
        }),
        variant: _,
        ref: J,
        mod: { multiline: b },
        children: h
      }
    ) }),
    $i(V, {
      ...S,
      [o]: Q,
      onMouseEnter: ue,
      onMouseLeave: ee
    })
  ] });
});
Vm.classes = Bu;
Vm.displayName = "@mantine/core/TooltipFloating";
const nv = Xn(!1), pZ = nv.Provider, mZ = () => Tn(nv), gZ = {
  openDelay: 0,
  closeDelay: 0
};
function zm(e) {
  const { openDelay: t, closeDelay: n, children: r } = X("TooltipGroup", gZ, e);
  return /* @__PURE__ */ E.jsx(pZ, { value: !0, children: /* @__PURE__ */ E.jsx(rV, { delay: { open: t, close: n }, children: r }) });
}
zm.displayName = "@mantine/core/TooltipGroup";
zm.extend = (e) => e;
function bZ(e) {
  if (e === void 0)
    return { shift: !0, flip: !0 };
  const t = { ...e };
  return e.shift === void 0 && (t.shift = !0), e.flip === void 0 && (t.flip = !0), t;
}
function yZ(e) {
  const t = bZ(e.middlewares), n = [Ln(e.offset)];
  return t.shift && n.push(
    mo(
      typeof t.shift == "boolean" ? { padding: 8 } : { padding: 8, ...t.shift }
    )
  ), t.flip && n.push(
    typeof t.flip == "boolean" ? Hr() : Hr(t.flip)
  ), n.push(By({ element: e.arrowRef, padding: e.arrowOffset })), t.inline ? n.push(
    typeof t.inline == "boolean" ? gs() : gs(t.inline)
  ) : e.inline && n.push(gs()), n;
}
function EZ(e) {
  var w, T, M;
  const [t, n] = fe(e.defaultOpened), o = typeof e.opened == "boolean" ? e.opened : t, i = mZ(), s = Qi(), a = Z(
    (D) => {
      n(D), D && y(s);
    },
    [s]
  ), {
    x: l,
    y: c,
    context: u,
    refs: d,
    placement: f,
    middlewareData: { arrow: { x: h, y: p } = {} }
  } = gu({
    strategy: e.strategy,
    placement: e.position,
    open: o,
    onOpenChange: a,
    middleware: yZ(e),
    whileElementsMounted: Ml
  }), { delay: m, currentId: b, setCurrentId: y } = oV(u, { id: s }), { getReferenceProps: k, getFloatingProps: C } = px([
    dx(u, {
      enabled: (w = e.events) == null ? void 0 : w.hover,
      delay: i ? m : { open: e.openDelay, close: e.closeDelay },
      mouseOnly: !((T = e.events) != null && T.touch)
    }),
    cV(u, { enabled: (M = e.events) == null ? void 0 : M.focus, visibleOnly: !0 }),
    dV(u, { role: "tooltip" }),
    // Cannot be used with controlled tooltip, page jumps
    hx(u, { enabled: typeof e.opened > "u" })
  ]);
  ea(() => {
    var D;
    (D = e.onPositionChange) == null || D.call(e, f);
  }, [f]);
  const _ = o && b && b !== s;
  return {
    x: l,
    y: c,
    arrowX: h,
    arrowY: p,
    reference: d.setReference,
    floating: d.setFloating,
    getFloatingProps: C,
    getReferenceProps: k,
    isGroupPhase: _,
    opened: o,
    placement: f
  };
}
const ry = {
  position: "top",
  refProp: "ref",
  withinPortal: !0,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transitionProps: { duration: 100, transition: "fade" },
  events: { hover: !0, focus: !1, touch: !1 },
  zIndex: ka("popover"),
  positionDependencies: [],
  middlewares: { flip: !0, shift: !0, inline: !1 }
}, kZ = (e, { radius: t, color: n, variant: r, autoContrast: o }) => {
  const i = e.variantColorResolver({
    theme: e,
    color: n || e.primaryColor,
    autoContrast: o,
    variant: r || "filled"
  });
  return {
    tooltip: {
      "--tooltip-radius": t === void 0 ? void 0 : Ut(t),
      "--tooltip-bg": n ? i.background : void 0,
      "--tooltip-color": n ? i.color : void 0
    }
  };
}, rs = De((e, t) => {
  const n = X("Tooltip", ry, e), {
    children: r,
    position: o,
    refProp: i,
    label: s,
    openDelay: a,
    closeDelay: l,
    onPositionChange: c,
    opened: u,
    defaultOpened: d,
    withinPortal: f,
    radius: h,
    color: p,
    classNames: m,
    styles: b,
    unstyled: y,
    style: k,
    className: C,
    withArrow: _,
    arrowSize: w,
    arrowOffset: T,
    arrowRadius: M,
    arrowPosition: D,
    offset: R,
    transitionProps: N,
    multiline: B,
    events: F,
    zIndex: W,
    disabled: L,
    // Scheduled for removal in 9.0
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    positionDependencies: H,
    onClick: J,
    onMouseEnter: Y,
    onMouseLeave: V,
    inline: Q,
    variant: S,
    keepMounted: ue,
    vars: ee,
    portalProps: A,
    mod: le,
    floatingStrategy: ge,
    middlewares: Ee,
    autoContrast: Qe,
    attributes: Te,
    target: ce,
    ...nt
  } = X("Tooltip", ry, n), { dir: pt } = Xi(), mt = Ae(null), je = EZ({
    position: Iw(pt, o),
    closeDelay: l,
    openDelay: a,
    onPositionChange: c,
    opened: u,
    defaultOpened: d,
    events: F,
    arrowRef: mt,
    arrowOffset: T,
    offset: typeof R == "number" ? R + (_ ? w / 2 : 0) : R,
    positionDependencies: [...H, ce ?? r],
    inline: Q,
    strategy: ge,
    middlewares: Ee
  });
  ie(() => {
    const zt = ce instanceof HTMLElement ? ce : typeof ce == "string" ? document.querySelector(ce) : (ce == null ? void 0 : ce.current) || null;
    zt && je.reference(zt);
  }, [ce, je]);
  const Vt = Oe({
    name: "Tooltip",
    props: n,
    classes: Bu,
    className: C,
    style: k,
    classNames: m,
    styles: b,
    unstyled: y,
    attributes: Te,
    rootSelector: "tooltip",
    vars: ee,
    varsResolver: kZ
  }), Un = xa(r);
  if (!ce && !Un)
    return null;
  if (ce) {
    const zt = ny(N, { duration: 100, transition: "fade" });
    return /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(Bi, { ...A, withinPortal: f, children: /* @__PURE__ */ E.jsx(
      po,
      {
        ...zt,
        keepMounted: ue,
        mounted: !L && !!je.opened,
        duration: je.isGroupPhase ? 10 : zt.duration,
        children: (qr) => /* @__PURE__ */ E.jsxs(
          de,
          {
            ...nt,
            "data-fixed": ge === "fixed" || void 0,
            variant: S,
            mod: [{ multiline: B }, le],
            ...je.getFloatingProps({
              ref: je.floating,
              className: Vt("tooltip").className,
              style: {
                ...Vt("tooltip").style,
                ...qr,
                zIndex: W,
                top: je.y ?? 0,
                left: je.x ?? 0
              }
            }),
            children: [
              s,
              /* @__PURE__ */ E.jsx(
                Ec,
                {
                  ref: mt,
                  arrowX: je.arrowX,
                  arrowY: je.arrowY,
                  visible: _,
                  position: je.placement,
                  arrowSize: w,
                  arrowOffset: T,
                  arrowRadius: M,
                  arrowPosition: D,
                  ...Vt("arrow")
                }
              )
            ]
          }
        )
      }
    ) }) });
  }
  const vr = Un.props, Sr = or(je.reference, hm(Un), t), _r = ny(N, { duration: 100, transition: "fade" });
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(Bi, { ...A, withinPortal: f, children: /* @__PURE__ */ E.jsx(
      po,
      {
        ..._r,
        keepMounted: ue,
        mounted: !L && !!je.opened,
        duration: je.isGroupPhase ? 10 : _r.duration,
        children: (zt) => /* @__PURE__ */ E.jsxs(
          de,
          {
            ...nt,
            "data-fixed": ge === "fixed" || void 0,
            variant: S,
            mod: [{ multiline: B }, le],
            ...je.getFloatingProps({
              ref: je.floating,
              className: Vt("tooltip").className,
              style: {
                ...Vt("tooltip").style,
                ...zt,
                zIndex: W,
                top: je.y ?? 0,
                left: je.x ?? 0
              }
            }),
            children: [
              s,
              /* @__PURE__ */ E.jsx(
                Ec,
                {
                  ref: mt,
                  arrowX: je.arrowX,
                  arrowY: je.arrowY,
                  visible: _,
                  position: je.placement,
                  arrowSize: w,
                  arrowOffset: T,
                  arrowRadius: M,
                  arrowPosition: D,
                  ...Vt("arrow")
                }
              )
            ]
          }
        )
      }
    ) }),
    $i(
      Un,
      je.getReferenceProps({
        onClick: J,
        onMouseEnter: Y,
        onMouseLeave: V,
        onMouseMove: n.onMouseMove,
        onPointerDown: n.onPointerDown,
        onPointerEnter: n.onPointerEnter,
        ...vr,
        className: Ur(C, vr.className),
        [i]: Sr
      })
    )
  ] });
});
rs.classes = Bu;
rs.displayName = "@mantine/core/Tooltip";
rs.Floating = Vm;
rs.Group = zm;
var rv = { root: "m_18320242", "skeleton-fade": "m_299c329c" };
const CZ = {
  visible: !0,
  animate: !0
}, TZ = (e, { width: t, height: n, radius: r, circle: o }) => ({
  root: {
    "--skeleton-height": U(n),
    "--skeleton-width": U(o ? n : t),
    "--skeleton-radius": o ? "1000px" : r === void 0 ? void 0 : Ut(r)
  }
}), Cc = De((e, t) => {
  const n = X("Skeleton", CZ, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    width: c,
    height: u,
    circle: d,
    visible: f,
    radius: h,
    animate: p,
    mod: m,
    attributes: b,
    ...y
  } = n, k = Oe({
    name: "Skeleton",
    classes: rv,
    props: n,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: b,
    vars: l,
    varsResolver: TZ
  });
  return /* @__PURE__ */ E.jsx(de, { ref: t, ...k("root"), mod: [{ visible: f, animate: p }, m], ...y });
});
Cc.classes = rv;
Cc.displayName = "@mantine/core/Skeleton";
var ov = { root: "m_6d731127" };
const xZ = {
  gap: "md",
  align: "stretch",
  justify: "flex-start"
}, wZ = (e, { gap: t, align: n, justify: r }) => ({
  root: {
    "--stack-gap": Ca(t),
    "--stack-align": n,
    "--stack-justify": r
  }
}), va = De((e, t) => {
  const n = X("Stack", xZ, e), {
    classNames: r,
    className: o,
    style: i,
    styles: s,
    unstyled: a,
    vars: l,
    align: c,
    justify: u,
    gap: d,
    variant: f,
    attributes: h,
    ...p
  } = n, m = Oe({
    name: "Stack",
    props: n,
    classes: ov,
    className: o,
    style: i,
    classNames: r,
    styles: s,
    unstyled: a,
    attributes: h,
    vars: l,
    varsResolver: wZ
  });
  return /* @__PURE__ */ E.jsx(de, { ref: t, ...m("root"), variant: f, ...p });
});
va.classes = ov;
va.displayName = "@mantine/core/Stack";
const [vZ, qm] = Eu(
  "Tabs component was not found in the tree"
);
var Sa = { root: "m_89d60db1", "list--default": "m_576c9d4", list: "m_89d33d6d", tab: "m_4ec4dce6", panel: "m_b0c91715", tabSection: "m_fc420b1f", tabLabel: "m_42bbd1ae", "tab--default": "m_539e827b", "list--outline": "m_6772fbd5", "tab--outline": "m_b59ab47c", "tab--pills": "m_c3381914" };
const Wm = De((e, t) => {
  const n = X("TabsList", null, e), { children: r, className: o, grow: i, justify: s, classNames: a, styles: l, style: c, mod: u, ...d } = n, f = qm();
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ...d,
      ...f.getStyles("list", {
        className: o,
        style: c,
        classNames: a,
        styles: l,
        props: n,
        variant: f.variant
      }),
      ref: t,
      role: "tablist",
      variant: f.variant,
      mod: [
        {
          grow: i,
          orientation: f.orientation,
          placement: f.orientation === "vertical" && f.placement,
          inverted: f.inverted
        },
        u
      ],
      "aria-orientation": f.orientation,
      __vars: { "--tabs-justify": s },
      children: r
    }
  );
});
Wm.classes = Sa;
Wm.displayName = "@mantine/core/TabsList";
const Gm = De((e, t) => {
  const n = X("TabsPanel", null, e), { children: r, className: o, value: i, classNames: s, styles: a, style: l, mod: c, keepMounted: u, ...d } = n, f = qm(), h = f.value === i, p = f.keepMounted || u || h ? r : null;
  return /* @__PURE__ */ E.jsx(
    de,
    {
      ...f.getStyles("panel", {
        className: o,
        classNames: s,
        styles: a,
        style: [l, h ? void 0 : { display: "none" }],
        props: n
      }),
      ref: t,
      mod: [{ orientation: f.orientation }, c],
      role: "tabpanel",
      id: f.getPanelId(i),
      "aria-labelledby": f.getTabId(i),
      ...d,
      children: p
    }
  );
});
Gm.classes = Sa;
Gm.displayName = "@mantine/core/TabsPanel";
const Ym = De((e, t) => {
  const n = X("TabsTab", null, e), {
    className: r,
    children: o,
    rightSection: i,
    leftSection: s,
    value: a,
    onClick: l,
    onKeyDown: c,
    disabled: u,
    color: d,
    style: f,
    classNames: h,
    styles: p,
    vars: m,
    mod: b,
    tabIndex: y,
    ...k
  } = n, C = dn(), { dir: _ } = Xi(), w = qm(), T = a === w.value, M = (R) => {
    w.onChange(w.allowTabDeactivation && a === w.value ? null : a), l == null || l(R);
  }, D = { classNames: h, styles: p, props: n };
  return /* @__PURE__ */ E.jsxs(
    To,
    {
      ...w.getStyles("tab", { className: r, style: f, variant: w.variant, ...D }),
      disabled: u,
      unstyled: w.unstyled,
      variant: w.variant,
      mod: [
        {
          active: T,
          disabled: u,
          orientation: w.orientation,
          inverted: w.inverted,
          placement: w.orientation === "vertical" && w.placement
        },
        b
      ],
      ref: t,
      role: "tab",
      id: w.getTabId(a),
      "aria-selected": T,
      tabIndex: y !== void 0 ? y : T || w.value === null ? 0 : -1,
      "aria-controls": w.getPanelId(a),
      onClick: M,
      __vars: { "--tabs-color": d ? Fr(d, C) : void 0 },
      onKeyDown: fm({
        siblingSelector: '[role="tab"]',
        parentSelector: '[role="tablist"]',
        activateOnFocus: w.activateTabWithKeyboard,
        loop: w.loop,
        orientation: w.orientation || "horizontal",
        dir: _,
        onKeyDown: c
      }),
      ...k,
      children: [
        s && /* @__PURE__ */ E.jsx("span", { ...w.getStyles("tabSection", D), "data-position": "left", children: s }),
        o && /* @__PURE__ */ E.jsx("span", { ...w.getStyles("tabLabel", D), children: o }),
        i && /* @__PURE__ */ E.jsx("span", { ...w.getStyles("tabSection", D), "data-position": "right", children: i })
      ]
    }
  );
});
Ym.classes = Sa;
Ym.displayName = "@mantine/core/TabsTab";
const oy = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value", SZ = {
  keepMounted: !0,
  orientation: "horizontal",
  loop: !0,
  activateTabWithKeyboard: !0,
  variant: "default",
  placement: "left"
}, _Z = (e, { radius: t, color: n, autoContrast: r }) => ({
  root: {
    "--tabs-radius": Ut(t),
    "--tabs-color": Fr(n, e),
    "--tabs-text-color": gK(r, e) ? pw({ color: n, theme: e, autoContrast: r }) : void 0
  }
}), Pr = De((e, t) => {
  const n = X("Tabs", SZ, e), {
    defaultValue: r,
    value: o,
    onChange: i,
    orientation: s,
    children: a,
    loop: l,
    id: c,
    activateTabWithKeyboard: u,
    allowTabDeactivation: d,
    variant: f,
    color: h,
    radius: p,
    inverted: m,
    placement: b,
    keepMounted: y,
    classNames: k,
    styles: C,
    unstyled: _,
    className: w,
    style: T,
    vars: M,
    autoContrast: D,
    mod: R,
    attributes: N,
    ...B
  } = n, F = Qi(c), [W, L] = Zi({
    value: o,
    defaultValue: r,
    finalValue: null,
    onChange: i
  }), H = Oe({
    name: "Tabs",
    props: n,
    classes: Sa,
    className: w,
    style: T,
    classNames: k,
    styles: C,
    unstyled: _,
    attributes: N,
    vars: M,
    varsResolver: _Z
  });
  return /* @__PURE__ */ E.jsx(
    vZ,
    {
      value: {
        placement: b,
        value: W,
        orientation: s,
        id: F,
        loop: l,
        activateTabWithKeyboard: u,
        getTabId: Hb(`${F}-tab`, oy),
        getPanelId: Hb(`${F}-panel`, oy),
        onChange: L,
        allowTabDeactivation: d,
        variant: f,
        color: h,
        radius: p,
        inverted: m,
        keepMounted: y,
        unstyled: _,
        getStyles: H
      },
      children: /* @__PURE__ */ E.jsx(
        de,
        {
          ref: t,
          id: F,
          variant: f,
          mod: [
            {
              orientation: s,
              inverted: s === "horizontal" && m,
              placement: s === "vertical" && b
            },
            R
          ],
          ...H("root"),
          ...B,
          children: a
        }
      )
    }
  );
});
Pr.classes = Sa;
Pr.displayName = "@mantine/core/Tabs";
Pr.Tab = Ym;
Pr.Panel = Gm;
Pr.List = Wm;
const $u = De((e, t) => {
  const n = X("TextInput", null, e);
  return /* @__PURE__ */ E.jsx(es, { component: "input", ref: t, ...n, __staticSelector: "TextInput" });
});
$u.classes = es.classes;
$u.displayName = "@mantine/core/TextInput";
const iv = (e, t, n = !1) => {
  const r = [];
  function o(i, s = "--bn") {
    for (const a in i) {
      const l = a.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), c = `${s}-${l}`;
      typeof i[a] != "object" ? (typeof i[a] == "number" && (i[a] = `${i[a]}px`), n ? t.style.removeProperty(c) : t.style.setProperty(c, i[a].toString())) : o(i[a], c);
    }
  }
  return o(e), r;
}, iy = (e, t) => iv(e, t), AZ = {
  colors: {
    editor: {
      text: void 0,
      background: void 0
    },
    menu: {
      text: void 0,
      background: void 0
    },
    tooltip: {
      text: void 0,
      background: void 0
    },
    hovered: {
      text: void 0,
      background: void 0
    },
    selected: {
      text: void 0,
      background: void 0
    },
    disabled: {
      text: void 0,
      background: void 0
    },
    shadow: void 0,
    border: void 0,
    sideMenu: void 0,
    highlights: {
      gray: {
        text: void 0,
        background: void 0
      },
      brown: {
        text: void 0,
        background: void 0
      },
      red: {
        text: void 0,
        background: void 0
      },
      orange: {
        text: void 0,
        background: void 0
      },
      yellow: {
        text: void 0,
        background: void 0
      },
      green: {
        text: void 0,
        background: void 0
      },
      blue: {
        text: void 0,
        background: void 0
      },
      purple: {
        text: void 0,
        background: void 0
      },
      pink: {
        text: void 0,
        background: void 0
      }
    }
  },
  borderRadius: void 0,
  fontFamily: void 0
}, IZ = (e) => iv(AZ, e, !0), sv = (e) => /* @__PURE__ */ E.jsxs(va, { gap: 0, className: "bn-tooltip", children: [
  /* @__PURE__ */ E.jsx(Er, { size: "sm", lineClamp: 5, children: e.mainTooltip }),
  e.secondaryTooltip && /* @__PURE__ */ E.jsx(Er, { size: "xs", lineClamp: 5, children: e.secondaryTooltip })
] }), Xd = se(
  (e, t) => {
    const {
      className: n,
      children: r,
      mainTooltip: o,
      secondaryTooltip: i,
      icon: s,
      isSelected: a,
      isDisabled: l,
      onClick: c,
      label: u,
      variant: d,
      ...f
    } = e;
    xe(f, !1);
    const [h, p] = fe(!1), m = r ? /* @__PURE__ */ E.jsx(
      sr,
      {
        "aria-label": u,
        className: n,
        onMouseDown: (b) => {
          If() && b.currentTarget.focus();
        },
        onClick: (b) => {
          p(!0), c == null || c(b);
        },
        onPointerLeave: () => p(!1),
        "aria-pressed": a,
        "data-selected": a || void 0,
        "data-test": o ? o.slice(0, 1).toLowerCase() + o.replace(/\s+/g, "").slice(1) : void 0,
        size: d === "compact" ? "compact-xs" : "xs",
        disabled: l || !1,
        ref: t,
        ...f,
        children: r
      }
    ) : /* @__PURE__ */ E.jsx(
      ni,
      {
        className: n,
        "aria-label": u,
        onMouseDown: (b) => {
          If() && b.currentTarget.focus();
        },
        onClick: (b) => {
          p(!0), c == null || c(b);
        },
        onPointerLeave: () => p(!1),
        "aria-pressed": a,
        "data-selected": a || void 0,
        "data-test": o ? o.slice(0, 1).toLowerCase() + o.replace(/\s+/g, "").slice(1) : void 0,
        size: d === "compact" ? 20 : 30,
        disabled: l || !1,
        ref: t,
        ...f,
        children: s
      }
    );
    return o ? /* @__PURE__ */ E.jsx(
      rs,
      {
        disabled: h,
        withinPortal: !1,
        label: /* @__PURE__ */ E.jsx(
          sv,
          {
            mainTooltip: o,
            secondaryTooltip: i
          }
        ),
        children: m
      }
    ) : m;
  }
), NZ = se((e, t) => {
  const {
    className: n,
    text: r,
    icon: o,
    isSelected: i,
    mainTooltip: s,
    secondaryTooltip: a,
    onClick: l,
    onMouseEnter: c,
    ...u
  } = e;
  xe(u, !1);
  const [d, f] = fe(!1), h = /* @__PURE__ */ E.jsxs(
    Ru,
    {
      className: n,
      checked: i === !0,
      wrapperProps: {
        onMouseEnter: c,
        onMouseLeave: () => f(!1),
        onClick: (p) => {
          f(!0), l == null || l(p);
        }
      },
      variant: "light",
      icon: null,
      ref: t,
      children: [
        /* @__PURE__ */ E.jsx("span", { children: o }),
        /* @__PURE__ */ E.jsx("span", { children: r })
      ]
    }
  );
  return !s || d ? h : /* @__PURE__ */ E.jsx(
    rs,
    {
      refProp: "rootRef",
      withinPortal: !1,
      label: /* @__PURE__ */ E.jsx(
        sv,
        {
          mainTooltip: s,
          secondaryTooltip: a
        }
      ),
      children: h
    }
  );
}), MZ = se((e, t) => {
  const { className: n, children: r, ...o } = e;
  return xe(o), /* @__PURE__ */ E.jsx(Mt, { className: n, ref: t, children: r });
}), LZ = se((e, t) => {
  const {
    className: n,
    children: r,
    headerText: o,
    selected: i,
    onFocus: s,
    onBlur: a,
    tabIndex: l,
    ...c
  } = e;
  return xe(c, !1), /* @__PURE__ */ E.jsxs(
    wa,
    {
      className: dt(n, i ? "selected" : ""),
      onFocus: s,
      onBlur: a,
      tabIndex: l,
      ref: t,
      children: [
        o && /* @__PURE__ */ E.jsx(Er, { className: "bn-header-text", children: o }),
        r
      ]
    }
  );
}), OZ = se((e, t) => {
  const { className: n, children: r, ...o } = e;
  return xe(o, !1), /* @__PURE__ */ E.jsx(wa.Section, { className: n, ref: t, children: r });
}), DZ = se((e, t) => {
  const { className: n, children: r, ...o } = e;
  return xe(o, !1), /* @__PURE__ */ E.jsx(
    Dm,
    {
      className: n,
      label: /* @__PURE__ */ E.jsx(Er, { children: r }),
      ref: t
    }
  );
}), RZ = se((e, t) => {
  const { authorInfo: n, timeString: r, edited: o, ...i } = e, s = Ce();
  return xe(i, !1), n === "loading" ? /* @__PURE__ */ E.jsxs(Mt, { children: [
    /* @__PURE__ */ E.jsx(Cc, { height: 24, width: 24 }),
    /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsx(Cc, { height: 12, width: 100 }) })
  ] }) : /* @__PURE__ */ E.jsxs(Mt, { children: [
    /* @__PURE__ */ E.jsx(
      Ou,
      {
        src: n.avatarUrl,
        alt: n.username,
        radius: "xl",
        size: "sm",
        color: "initials"
      }
    ),
    /* @__PURE__ */ E.jsxs(Er, { fz: "sm", fw: "bold", children: [
      n.username,
      /* @__PURE__ */ E.jsxs(Er, { fz: "xs", c: "dimmed", span: !0, ml: "xs", children: [
        r,
        " ",
        o && `(${s.comments.edited})`
      ] })
    ] })
  ] });
}), PZ = se((e, t) => {
  const {
    className: n,
    showActions: r,
    authorInfo: o,
    timeString: i,
    edited: s,
    actions: a,
    emojiPickerOpen: l,
    children: c,
    ...u
  } = e, { hovered: d, ref: f } = vY(), h = XG([t, f]);
  return xe(u, !1), /* @__PURE__ */ E.jsxs(Mt, { pos: "relative", ref: h, className: n, children: [
    a && (r === !0 || r === void 0 || r === "hover" && d || l) ? /* @__PURE__ */ E.jsx(
      Mt,
      {
        style: {
          position: "absolute",
          right: 0,
          top: 0,
          zIndex: 10
        },
        children: a
      }
    ) : null,
    /* @__PURE__ */ E.jsx(RZ, { ...e }),
    c
  ] });
}), BZ = se((e, t) => {
  const { className: n, autoFocus: r, onFocus: o, onBlur: i, editor: s, editable: a, ...l } = e;
  xe(l, !1);
  const c = rr();
  return /* @__PURE__ */ E.jsx(
    cv,
    {
      autoFocus: r,
      className: n,
      editor: e.editor,
      sideMenu: !1,
      slashMenu: !1,
      tableHandles: !1,
      filePanel: !1,
      formattingToolbar: !1,
      editable: a,
      theme: c == null ? void 0 : c.colorSchemePreference,
      ref: t,
      onFocus: o,
      onBlur: i,
      children: /* @__PURE__ */ E.jsx(
        Qx,
        {
          formattingToolbar: $Z
        }
      )
    }
  );
}), $Z = () => {
  const e = Yx([]).filter(
    (t) => t.key !== "nestBlockButton" && t.key !== "unnestBlockButton"
  );
  return /* @__PURE__ */ E.jsx(Kx, { blockTypeSelectItems: [], children: e });
}, HZ = se((e, t) => {
  const {
    className: n,
    name: r,
    label: o,
    variant: i,
    icon: s,
    value: a,
    autoFocus: l,
    placeholder: c,
    disabled: u,
    onKeyDown: d,
    onChange: f,
    onSubmit: h,
    autoComplete: p,
    rightSection: m,
    ...b
  } = e;
  return xe(b), /* @__PURE__ */ E.jsx(
    $u,
    {
      size: "xs",
      className: dt(
        n || "",
        i === "large" ? "bn-mt-input-large" : ""
      ),
      ref: t,
      name: r,
      label: o,
      leftSection: s,
      value: a,
      autoFocus: l,
      "data-autofocus": l ? "true" : void 0,
      rightSection: m,
      placeholder: c,
      disabled: u,
      onKeyDown: d,
      onChange: f,
      onSubmit: h,
      autoComplete: p
    }
  );
}), FZ = Xn(void 0), UZ = (e) => {
  const { children: t, onOpenChange: n, position: r, sub: o, ...i } = e;
  return xe(i), o ? /* @__PURE__ */ E.jsx(
    it.Sub,
    {
      transitionProps: { duration: 250, exitDelay: 250 },
      withinPortal: !1,
      middlewares: { flip: !0, shift: !0, inline: !1, size: !0 },
      onChange: n,
      position: r,
      children: t
    }
  ) : /* @__PURE__ */ E.jsx(
    it,
    {
      withinPortal: !1,
      middlewares: { flip: !0, shift: !0, inline: !1, size: !0 },
      onChange: n,
      position: r,
      returnFocus: !1,
      children: t
    }
  );
}, jZ = se((e, t) => {
  const { className: n, children: r, icon: o, checked: i, subTrigger: s, onClick: a, ...l } = e;
  return xe(l, !1), s ? /* @__PURE__ */ E.jsx(
    it.Sub.Item,
    {
      className: n,
      ref: t,
      leftSection: o,
      rightSection: i ? /* @__PURE__ */ E.jsx(kc, { size: 10 }) : i === !1 ? /* @__PURE__ */ E.jsx("div", { className: "bn-tick-space" }) : null,
      onClick: a,
      ...l,
      children: r
    }
  ) : /* @__PURE__ */ E.jsx(
    it.Item,
    {
      className: n,
      ref: t,
      leftSection: o,
      rightSection: i ? /* @__PURE__ */ E.jsx(kc, { size: 10 }) : i === !1 ? /* @__PURE__ */ E.jsx("div", { className: "bn-tick-space" }) : null,
      onClick: a,
      ...l,
      children: r
    }
  );
}), VZ = (e) => {
  const {
    children: t,
    sub: n,
    // unused
    ...r
  } = e;
  return xe(r), n ? /* @__PURE__ */ E.jsx(it.Sub.Target, { children: t }) : /* @__PURE__ */ E.jsx(it.Target, { children: t });
}, zZ = se((e, t) => {
  const {
    className: n,
    children: r,
    sub: o,
    //unused
    ...i
  } = e;
  xe(i);
  const s = Tn(FZ);
  return o ? /* @__PURE__ */ E.jsx(
    it.Sub.Dropdown,
    {
      className: n,
      ref: t,
      onMouseOver: s == null ? void 0 : s.onMenuMouseOver,
      onMouseLeave: s == null ? void 0 : s.onMenuMouseLeave,
      children: r
    }
  ) : /* @__PURE__ */ E.jsx(
    it.Dropdown,
    {
      className: n,
      ref: t,
      onMouseOver: s == null ? void 0 : s.onMenuMouseOver,
      onMouseLeave: s == null ? void 0 : s.onMenuMouseLeave,
      children: r
    }
  );
}), qZ = se((e, t) => {
  const { className: n, ...r } = e;
  return xe(r), /* @__PURE__ */ E.jsx(it.Divider, { className: n, ref: t });
}), WZ = se((e, t) => {
  const { className: n, children: r, ...o } = e;
  return xe(o), /* @__PURE__ */ E.jsx(it.Label, { className: n, ref: t, children: r });
}), GZ = se((e, t) => {
  const {
    className: n,
    children: r,
    icon: o,
    onClick: i,
    onDragEnd: s,
    onDragStart: a,
    draggable: l,
    label: c,
    ...u
  } = e;
  return xe(u, !1), o ? /* @__PURE__ */ E.jsx(
    ni,
    {
      size: 24,
      className: n,
      ref: t,
      onClick: i,
      onDragEnd: s,
      onDragStart: a,
      draggable: l,
      "aria-label": c,
      ...u,
      children: o
    }
  ) : /* @__PURE__ */ E.jsx(
    sr,
    {
      className: n,
      ref: t,
      onClick: i,
      onDragEnd: s,
      onDragStart: a,
      draggable: l,
      "aria-label": c,
      ...u,
      children: r
    }
  );
}), YZ = se((e, t) => {
  const {
    className: n,
    tabs: r,
    defaultOpenTab: o,
    openTab: i,
    setOpenTab: s,
    loading: a,
    ...l
  } = e;
  return xe(l), /* @__PURE__ */ E.jsx(Mt, { className: n, ref: t, children: /* @__PURE__ */ E.jsxs(
    Pr,
    {
      value: i,
      defaultValue: o,
      onChange: s,
      children: [
        a && /* @__PURE__ */ E.jsx(Pm, { visible: a }),
        /* @__PURE__ */ E.jsx(Pr.List, { children: r.map((c) => /* @__PURE__ */ E.jsx(
          Pr.Tab,
          {
            "data-test": `${c.name.toLowerCase()}-tab`,
            value: c.name,
            children: c.name
          },
          c.name
        )) }),
        r.map((c) => /* @__PURE__ */ E.jsx(Pr.Panel, { value: c.name, children: c.tabPanel }, c.name))
      ]
    }
  ) });
}), KZ = se((e, t) => {
  const { className: n, children: r, onClick: o, label: i, ...s } = e;
  return xe(s), /* @__PURE__ */ E.jsx(
    sr,
    {
      size: "xs",
      "aria-label": i,
      className: n,
      ref: t,
      onClick: o,
      ...s,
      children: r
    }
  );
}), QZ = se((e, t) => {
  const { className: n, accept: r, value: o, placeholder: i, onChange: s, ...a } = e;
  return xe(a), /* @__PURE__ */ E.jsx(
    rZ,
    {
      size: "xs",
      className: n,
      ref: t,
      accept: r,
      value: o,
      placeholder: i,
      onChange: s,
      ...a
    }
  );
}), ZZ = se((e, t) => {
  const { className: n, children: r, ...o } = e;
  return xe(o), /* @__PURE__ */ E.jsx("div", { className: n, ref: t, children: r });
}), XZ = se((e, t) => {
  const { className: n, value: r, placeholder: o, onKeyDown: i, onChange: s, ...a } = e;
  return xe(a), /* @__PURE__ */ E.jsx(
    $u,
    {
      size: "xs",
      "data-test": "embed-input",
      className: n,
      ref: t,
      value: r,
      placeholder: o,
      onKeyDown: i,
      onChange: s
    }
  );
}), JZ = (e) => {
  const { open: t, onOpenChange: n, position: r, children: o, ...i } = e;
  return xe(i), /* @__PURE__ */ E.jsx(
    ir,
    {
      middlewares: { size: { padding: 20 } },
      withinPortal: !1,
      opened: t,
      onChange: n,
      position: r,
      zIndex: 1e4,
      children: o
    }
  );
}, eX = (e) => {
  const { children: t, ...n } = e;
  return xe(n), /* @__PURE__ */ E.jsx(xm, { children: t });
}, tX = se((e, t) => {
  const {
    className: n,
    children: r,
    variant: o,
    // unused
    ...i
  } = e;
  return xe(i), /* @__PURE__ */ E.jsx(Su, { className: n, ref: t, children: r });
}), nX = se((e, t) => {
  const { className: n, children: r, ...o } = e;
  return xe(o, !1), /* @__PURE__ */ E.jsx(
    Mt,
    {
      align: "center",
      gap: 0,
      className: n,
      ref: t,
      ...o,
      children: r
    }
  );
}), rX = se((e, t) => {
  const {
    className: n,
    children: r,
    icon: o,
    onClick: i,
    onDragEnd: s,
    onDragStart: a,
    draggable: l,
    label: c,
    ...u
  } = e;
  return xe(u, !1), o ? /* @__PURE__ */ E.jsx(
    ni,
    {
      size: 24,
      className: n,
      ref: t,
      onClick: i,
      onDragEnd: s,
      onDragStart: a,
      draggable: l,
      "aria-label": c,
      ...u,
      children: o
    }
  ) : /* @__PURE__ */ E.jsx(
    sr,
    {
      className: n,
      ref: t,
      onClick: i,
      onDragEnd: s,
      onDragStart: a,
      draggable: l,
      "aria-label": c,
      ...u,
      children: r
    }
  );
}), oX = se((e, t) => {
  const { className: n, children: r, id: o, ...i } = e;
  return xe(i), /* @__PURE__ */ E.jsx(
    va,
    {
      gap: 0,
      className: n,
      ref: t,
      id: o,
      role: "listbox",
      children: r
    }
  );
}), iX = se((e, t) => {
  const { className: n, children: r, ...o } = e;
  return xe(o), /* @__PURE__ */ E.jsx(Mt, { className: n, ref: t, children: /* @__PURE__ */ E.jsx(Mt, { className: "bn-mt-suggestion-menu-item-title", children: r }) });
}), sX = se((e, t) => {
  const { className: n, isSelected: r, onClick: o, item: i, id: s, ...a } = e;
  xe(a);
  const l = Ae(null);
  return ie(() => {
    if (!l.current || !r)
      return;
    const c = rw(l.current, l.current.closest(
      ".bn-suggestion-menu, #ai-suggestion-menu"
    ));
    c === "top" ? l.current.scrollIntoView(!0) : c === "bottom" && l.current.scrollIntoView(!1);
  }, [r]), /* @__PURE__ */ E.jsxs(
    Mt,
    {
      gap: 0,
      className: n,
      ref: Cu(t, l),
      id: s,
      role: "option",
      onMouseDown: (c) => c.preventDefault(),
      onClick: o,
      "aria-selected": r || void 0,
      children: [
        i.icon && /* @__PURE__ */ E.jsx(
          Mt,
          {
            className: "bn-mt-suggestion-menu-item-section",
            "data-position": "left",
            children: i.icon
          }
        ),
        /* @__PURE__ */ E.jsxs(va, { gap: 0, className: "bn-mt-suggestion-menu-item-body", children: [
          /* @__PURE__ */ E.jsx(Er, { className: "bn-mt-suggestion-menu-item-title", children: i.title }),
          /* @__PURE__ */ E.jsx(Er, { className: "bn-mt-suggestion-menu-item-subtitle", children: i.subtext })
        ] }),
        i.badge && /* @__PURE__ */ E.jsx(
          Mt,
          {
            "data-position": "right",
            className: "bn-mt-suggestion-menu-item-section",
            children: /* @__PURE__ */ E.jsx(Nm, { size: "xs", children: i.badge })
          }
        )
      ]
    }
  );
}), aX = se((e, t) => {
  const { className: n, children: r, ...o } = e;
  return xe(o), /* @__PURE__ */ E.jsx(Mt, { className: n, ref: t, children: r });
}), lX = se((e, t) => {
  const { className: n, ...r } = e;
  return xe(r), /* @__PURE__ */ E.jsx(xo, { className: n, type: "dots", size: 16, ref: t });
}), cX = se((e, t) => {
  const { className: n, children: r, id: o, columns: i, ...s } = e;
  return xe(s), /* @__PURE__ */ E.jsx(
    "div",
    {
      className: n,
      style: { gridTemplateColumns: `repeat(${i}, 1fr)` },
      ref: t,
      id: o,
      role: "grid",
      children: r
    }
  );
}), uX = se((e, t) => {
  const { className: n, children: r, columns: o, ...i } = e;
  return xe(i), /* @__PURE__ */ E.jsx(
    Mt,
    {
      className: n,
      style: { gridColumn: `1 / ${o + 1}` },
      ref: t,
      children: /* @__PURE__ */ E.jsx(Mt, { className: "bn-mt-suggestion-menu-item-title", children: r })
    }
  );
}), dX = se((e, t) => {
  const { className: n, isSelected: r, onClick: o, item: i, id: s, ...a } = e;
  xe(a);
  const l = Ae(null);
  return ie(() => {
    if (!l.current || !r)
      return;
    const c = rw(
      l.current,
      l.current.closest(".bn-grid-suggestion-menu")
    );
    c === "top" ? l.current.scrollIntoView(!0) : c === "bottom" && l.current.scrollIntoView(!1);
  }, [r]), /* @__PURE__ */ E.jsx(
    "div",
    {
      className: n,
      ref: Cu(t, l),
      id: s,
      role: "option",
      onClick: o,
      "aria-selected": r || void 0,
      children: i.icon
    }
  );
}), fX = se((e, t) => {
  const {
    className: n,
    children: r,
    // unused, using "dots" instead
    columns: o,
    ...i
  } = e;
  return xe(i), /* @__PURE__ */ E.jsx(
    xo,
    {
      className: n,
      style: { gridColumn: `1 / ${o + 1}` },
      type: "dots",
      ref: t
    }
  );
}), hX = se((e, t) => {
  const { children: n, className: r, onMouseDown: o, onClick: i, ...s } = e;
  return xe(s, !1), /* @__PURE__ */ E.jsx(
    sr,
    {
      className: r,
      ref: t,
      onMouseDown: o,
      onClick: i,
      ...s,
      children: n
    }
  );
}), pX = se((e, t) => {
  const {
    className: n,
    children: r,
    draggable: o,
    onDragStart: i,
    onDragEnd: s,
    style: a,
    label: l,
    ...c
  } = e;
  return xe(c, !1), /* @__PURE__ */ E.jsx(
    sr,
    {
      className: n,
      ref: t,
      "aria-label": l,
      draggable: o,
      onDragStart: i,
      onDragEnd: s,
      style: a,
      ...c,
      children: r
    }
  );
}), Jd = se(
  (e, t) => {
    const {
      className: n,
      children: r,
      onMouseEnter: o,
      onMouseLeave: i,
      variant: s,
      ...a
    } = e;
    xe(a);
    const { ref: l, focused: c } = AY(), u = dw(c), d = Cu(t, l, u);
    return /* @__PURE__ */ E.jsx(
      Am,
      {
        className: n,
        ref: d,
        role: "toolbar",
        onMouseEnter: o,
        onMouseLeave: i,
        gap: s === "action-toolbar" ? 2 : void 0,
        children: r
      }
    );
  }
);
var av = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, sy = st.createContext && /* @__PURE__ */ st.createContext(av), mX = ["attr", "size", "title"];
function gX(e, t) {
  if (e == null) return {};
  var n = bX(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function bX(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function Tc() {
  return Tc = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Tc.apply(this, arguments);
}
function ay(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ay(Object(n), !0).forEach(function(r) {
      yX(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ay(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function yX(e, t, n) {
  return t = EX(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function EX(e) {
  var t = kX(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function kX(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function lv(e) {
  return e && e.map((t, n) => /* @__PURE__ */ st.createElement(t.tag, xc({
    key: n
  }, t.attr), lv(t.child)));
}
function CX(e) {
  return (t) => /* @__PURE__ */ st.createElement(TX, Tc({
    attr: xc({}, e.attr)
  }, t), lv(e.child));
}
function TX(e) {
  var t = (n) => {
    var {
      attr: r,
      size: o,
      title: i
    } = e, s = gX(e, mX), a = o || n.size || "1em", l;
    return n.className && (l = n.className), e.className && (l = (l ? l + " " : "") + e.className), /* @__PURE__ */ st.createElement("svg", Tc({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, r, s, {
      className: l,
      style: xc(xc({
        color: e.color || n.color
      }, n.style), e.style),
      height: a,
      width: a,
      xmlns: "http://www.w3.org/2000/svg"
    }), i && /* @__PURE__ */ st.createElement("title", null, i), e.children);
  };
  return sy !== void 0 ? /* @__PURE__ */ st.createElement(sy.Consumer, null, (n) => t(n)) : t(av);
}
function xX(e) {
  return CX({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z", clipRule: "evenodd" }, child: [] }] })(e);
}
const ef = se((e, t) => {
  const { className: n, items: r, isDisabled: o, ...i } = e;
  xe(i);
  const s = r.filter((a) => a.isSelected)[0];
  return s ? /* @__PURE__ */ E.jsxs(
    it,
    {
      withinPortal: !1,
      transitionProps: {
        exitDuration: 0
      },
      disabled: o,
      middlewares: { flip: !0, shift: !0, inline: !1, size: !0 },
      children: [
        /* @__PURE__ */ E.jsx(it.Target, { children: /* @__PURE__ */ E.jsx(
          sr,
          {
            onMouseDown: (a) => {
              If() && a.currentTarget.focus();
            },
            leftSection: s.icon,
            rightSection: /* @__PURE__ */ E.jsx(xX, {}),
            size: "xs",
            variant: "subtle",
            disabled: o,
            children: s.text
          }
        ) }),
        /* @__PURE__ */ E.jsx(it.Dropdown, { className: n, ref: t, children: r.map((a) => /* @__PURE__ */ E.jsx(
          it.Item,
          {
            onClick: a.onClick,
            leftSection: a.icon,
            rightSection: a.isSelected ? /* @__PURE__ */ E.jsx(kc, { size: 10, className: "bn-tick-icon" }) : (
              // Ensures space for tick even if item isn't currently selected.
              /* @__PURE__ */ E.jsx("div", { className: "bn-tick-space" })
            ),
            disabled: a.isDisabled,
            children: a.text
          },
          a.text
        )) })
      ]
    }
  ) : null;
}), wX = {
  FormattingToolbar: {
    Root: Jd,
    Button: Xd,
    Select: ef
  },
  FilePanel: {
    Root: YZ,
    Button: KZ,
    FileInput: QZ,
    TabPanel: ZZ,
    TextInput: XZ
  },
  GridSuggestionMenu: {
    Root: cX,
    Item: dX,
    EmptyItem: uX,
    Loader: fX
  },
  LinkToolbar: {
    Root: Jd,
    Button: Xd,
    Select: ef
  },
  SideMenu: {
    Root: nX,
    Button: rX
  },
  SuggestionMenu: {
    Root: oX,
    Item: sX,
    EmptyItem: iX,
    Label: aX,
    Loader: lX
  },
  TableHandle: {
    Root: pX,
    ExtendButton: hX
  },
  Generic: {
    Badge: {
      Root: NZ,
      Group: MZ
    },
    Form: {
      Root: (e) => /* @__PURE__ */ E.jsx("div", { children: e.children }),
      TextInput: HZ
    },
    Menu: {
      Root: UZ,
      Trigger: VZ,
      Dropdown: zZ,
      Divider: qZ,
      Label: WZ,
      Item: jZ,
      Button: GZ
    },
    Popover: {
      Root: JZ,
      Trigger: eX,
      Content: tX
    },
    Toolbar: {
      Root: Jd,
      Button: Xd,
      Select: ef
    }
  },
  Comments: {
    Comment: PZ,
    Editor: BZ,
    Card: LZ,
    CardSection: OZ,
    ExpandSectionsPrompt: DZ
  }
}, cv = (e) => {
  const { className: t, theme: n, ...r } = e, o = rr(), i = ew(), s = (o == null ? void 0 : o.colorSchemePreference) || i, a = Z(
    (d) => {
      if (d && (IZ(d), typeof n == "object")) {
        if ("light" in n && "dark" in n) {
          iy(
            n[s === "dark" ? "dark" : "light"],
            d
          );
          return;
        }
        iy(n, d);
        return;
      }
    },
    [s, n]
  ), l = Tn(pm), c = typeof n == "string" ? n : s !== "no-preference" ? s : "light", u = /* @__PURE__ */ E.jsx(Mx.Provider, { value: wX, children: /* @__PURE__ */ E.jsx(
    PG,
    {
      "data-mantine-color-scheme": c,
      className: dt("bn-mantine", t || ""),
      theme: typeof n == "object" ? void 0 : n,
      ...r,
      ref: a
    }
  ) });
  return l ? u : /* @__PURE__ */ E.jsx(
    bw,
    {
      withCssVariables: !1,
      getRootElement: () => {
      },
      children: u
    }
  );
};
function vX(e) {
  if (!Array.isArray(e)) return !1;
  if (e.length === 0) return !0;
  const t = e[0];
  return typeof t == "object" && t !== null && "type" in t;
}
function SX({ initialData: e, onSave: t }) {
  const n = Ae(t);
  n.current = t;
  const { resolvedTheme: r } = Lv(), o = Me(() => {
    const i = vX(e) ? e : void 0;
    return lx.create({
      initialContent: i
    });
  }, []);
  return ie(() => {
    const i = () => {
      const a = o.document;
      n.current(a);
    }, s = o.onChange(i);
    return () => {
      s();
    };
  }, [o]), /* @__PURE__ */ E.jsx("div", { className: "h-full w-full overflow-auto bg-background", children: /* @__PURE__ */ E.jsx("div", { className: "max-w-4xl mx-auto py-8 px-4", children: /* @__PURE__ */ E.jsx(
    cv,
    {
      editor: o,
      theme: r === "dark" ? "dark" : "light",
      className: "min-h-[500px]"
    }
  ) }) });
}
const ly = Rv.notes;
function WX() {
  const { id: e } = Pv(), { artifact: t, loading: n, error: r, save: o, rename: i, toggleFavorite: s, saving: a, updateTags: l } = Ov("notes", e);
  return /* @__PURE__ */ E.jsx(
    Dv,
    {
      title: ly.title,
      icon: ly.icon,
      artifact: t,
      loading: n,
      error: r,
      saving: a,
      onRename: i,
      onToggleFavorite: s,
      onUpdateTags: l,
      children: /* @__PURE__ */ E.jsx(SX, { initialData: t == null ? void 0 : t.data, onSave: o })
    }
  );
}
export {
  WX as default
};
