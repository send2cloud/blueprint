var Lbe = Object.defineProperty;
var yz = (t) => {
  throw TypeError(t);
};
var Fbe = (t, e, n) => e in t ? Lbe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var P = (t, e, n) => Fbe(t, typeof e != "symbol" ? e + "" : e, n), NA = (t, e, n) => e.has(t) || yz("Cannot " + n);
var J = (t, e, n) => (NA(t, e, "read from private field"), n ? n.call(t) : e.get(t)), ft = (t, e, n) => e.has(t) ? yz("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), He = (t, e, n, r) => (NA(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n), zt = (t, e, n) => (NA(t, e, "access private method"), n);
var XS = (t, e, n, r) => ({
  set _(s) {
    He(t, e, s, n);
  },
  get _() {
    return J(t, e, r);
  }
});
import * as T from "react";
import B, { forwardRef as du, createElement as _D, isValidElement as jA, useLayoutEffect as un, useState as he, createContext as zn, useContext as tn, useRef as fe, useCallback as re, useSyncExternalStore as Gx, useEffect as me, useMemo as Ke, memo as it, useId as Bbe, useDebugValue as zbe, Fragment as D$, cloneElement as Ube, Component as hq, createRef as mf, lazy as pq, Suspense as Hbe } from "react";
import * as b0 from "react-dom";
import By, { flushSync as x0, unstable_batchedUpdates as Vbe } from "react-dom";
import { useNavigate as Wbe, NavLink as Kbe, useLocation as N$, Outlet as Gbe, Link as vz, useParams as $P, Routes as Ybe, Route as Dr } from "react-router-dom";
var yn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Wr(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var ED = { exports: {} }, Fv = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bz;
function qbe() {
  if (bz) return Fv;
  bz = 1;
  var t = B, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function i(a, c, l) {
    var d, u = {}, f = null, p = null;
    l !== void 0 && (f = "" + l), c.key !== void 0 && (f = "" + c.key), c.ref !== void 0 && (p = c.ref);
    for (d in c) r.call(c, d) && !o.hasOwnProperty(d) && (u[d] = c[d]);
    if (a && a.defaultProps) for (d in c = a.defaultProps, c) u[d] === void 0 && (u[d] = c[d]);
    return { $$typeof: e, type: a, key: f, ref: p, props: u, _owner: s.current };
  }
  return Fv.Fragment = n, Fv.jsx = i, Fv.jsxs = i, Fv;
}
var Bv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xz;
function Xbe() {
  return xz || (xz = 1, process.env.NODE_ENV !== "production" && function() {
    var t = B, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), a = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), g = Symbol.iterator, y = "@@iterator";
    function m(Q) {
      if (Q === null || typeof Q != "object")
        return null;
      var Ee = g && Q[g] || Q[y];
      return typeof Ee == "function" ? Ee : null;
    }
    var v = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(Q) {
      {
        for (var Ee = arguments.length, $e = new Array(Ee > 1 ? Ee - 1 : 0), ut = 1; ut < Ee; ut++)
          $e[ut - 1] = arguments[ut];
        x("error", Q, $e);
      }
    }
    function x(Q, Ee, $e) {
      {
        var ut = v.ReactDebugCurrentFrame, It = ut.getStackAddendum();
        It !== "" && (Ee += "%s", $e = $e.concat([It]));
        var on = $e.map(function(jt) {
          return String(jt);
        });
        on.unshift("Warning: " + Ee), Function.prototype.apply.call(console[Q], console, on);
      }
    }
    var w = !1, S = !1, C = !1, _ = !1, E = !1, M;
    M = Symbol.for("react.module.reference");
    function N(Q) {
      return !!(typeof Q == "string" || typeof Q == "function" || Q === r || Q === o || E || Q === s || Q === l || Q === d || _ || Q === p || w || S || C || typeof Q == "object" && Q !== null && (Q.$$typeof === f || Q.$$typeof === u || Q.$$typeof === i || Q.$$typeof === a || Q.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Q.$$typeof === M || Q.getModuleId !== void 0));
    }
    function O(Q, Ee, $e) {
      var ut = Q.displayName;
      if (ut)
        return ut;
      var It = Ee.displayName || Ee.name || "";
      return It !== "" ? $e + "(" + It + ")" : $e;
    }
    function D(Q) {
      return Q.displayName || "Context";
    }
    function k(Q) {
      if (Q == null)
        return null;
      if (typeof Q.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Q == "function")
        return Q.displayName || Q.name || null;
      if (typeof Q == "string")
        return Q;
      switch (Q) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case s:
          return "StrictMode";
        case l:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof Q == "object")
        switch (Q.$$typeof) {
          case a:
            var Ee = Q;
            return D(Ee) + ".Consumer";
          case i:
            var $e = Q;
            return D($e._context) + ".Provider";
          case c:
            return O(Q, Q.render, "ForwardRef");
          case u:
            var ut = Q.displayName || null;
            return ut !== null ? ut : k(Q.type) || "Memo";
          case f: {
            var It = Q, on = It._payload, jt = It._init;
            try {
              return k(jt(on));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var A = Object.assign, R = 0, j, $, F, L, z, H, U;
    function W() {
    }
    W.__reactDisabledLog = !0;
    function Z() {
      {
        if (R === 0) {
          j = console.log, $ = console.info, F = console.warn, L = console.error, z = console.group, H = console.groupCollapsed, U = console.groupEnd;
          var Q = {
            configurable: !0,
            enumerable: !0,
            value: W,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Q,
            log: Q,
            warn: Q,
            error: Q,
            group: Q,
            groupCollapsed: Q,
            groupEnd: Q
          });
        }
        R++;
      }
    }
    function K() {
      {
        if (R--, R === 0) {
          var Q = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: A({}, Q, {
              value: j
            }),
            info: A({}, Q, {
              value: $
            }),
            warn: A({}, Q, {
              value: F
            }),
            error: A({}, Q, {
              value: L
            }),
            group: A({}, Q, {
              value: z
            }),
            groupCollapsed: A({}, Q, {
              value: H
            }),
            groupEnd: A({}, Q, {
              value: U
            })
          });
        }
        R < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var oe = v.ReactCurrentDispatcher, Y;
    function ee(Q, Ee, $e) {
      {
        if (Y === void 0)
          try {
            throw Error();
          } catch (It) {
            var ut = It.stack.trim().match(/\n( *(at )?)/);
            Y = ut && ut[1] || "";
          }
        return `
` + Y + Q;
      }
    }
    var ae = !1, de;
    {
      var ye = typeof WeakMap == "function" ? WeakMap : Map;
      de = new ye();
    }
    function G(Q, Ee) {
      if (!Q || ae)
        return "";
      {
        var $e = de.get(Q);
        if ($e !== void 0)
          return $e;
      }
      var ut;
      ae = !0;
      var It = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var on;
      on = oe.current, oe.current = null, Z();
      try {
        if (Ee) {
          var jt = function() {
            throw Error();
          };
          if (Object.defineProperty(jt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(jt, []);
            } catch (Zr) {
              ut = Zr;
            }
            Reflect.construct(Q, [], jt);
          } else {
            try {
              jt.call();
            } catch (Zr) {
              ut = Zr;
            }
            Q.call(jt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Zr) {
            ut = Zr;
          }
          Q();
        }
      } catch (Zr) {
        if (Zr && ut && typeof Zr.stack == "string") {
          for (var Rt = Zr.stack.split(`
`), Or = ut.stack.split(`
`), an = Rt.length - 1, hn = Or.length - 1; an >= 1 && hn >= 0 && Rt[an] !== Or[hn]; )
            hn--;
          for (; an >= 1 && hn >= 0; an--, hn--)
            if (Rt[an] !== Or[hn]) {
              if (an !== 1 || hn !== 1)
                do
                  if (an--, hn--, hn < 0 || Rt[an] !== Or[hn]) {
                    var Cs = `
` + Rt[an].replace(" at new ", " at ");
                    return Q.displayName && Cs.includes("<anonymous>") && (Cs = Cs.replace("<anonymous>", Q.displayName)), typeof Q == "function" && de.set(Q, Cs), Cs;
                  }
                while (an >= 1 && hn >= 0);
              break;
            }
        }
      } finally {
        ae = !1, oe.current = on, K(), Error.prepareStackTrace = It;
      }
      var Qi = Q ? Q.displayName || Q.name : "", Ji = Qi ? ee(Qi) : "";
      return typeof Q == "function" && de.set(Q, Ji), Ji;
    }
    function xe(Q, Ee, $e) {
      return G(Q, !1);
    }
    function ge(Q) {
      var Ee = Q.prototype;
      return !!(Ee && Ee.isReactComponent);
    }
    function ze(Q, Ee, $e) {
      if (Q == null)
        return "";
      if (typeof Q == "function")
        return G(Q, ge(Q));
      if (typeof Q == "string")
        return ee(Q);
      switch (Q) {
        case l:
          return ee("Suspense");
        case d:
          return ee("SuspenseList");
      }
      if (typeof Q == "object")
        switch (Q.$$typeof) {
          case c:
            return xe(Q.render);
          case u:
            return ze(Q.type, Ee, $e);
          case f: {
            var ut = Q, It = ut._payload, on = ut._init;
            try {
              return ze(on(It), Ee, $e);
            } catch {
            }
          }
        }
      return "";
    }
    var Ge = Object.prototype.hasOwnProperty, Ct = {}, vn = v.ReactDebugCurrentFrame;
    function Yt(Q) {
      if (Q) {
        var Ee = Q._owner, $e = ze(Q.type, Q._source, Ee ? Ee.type : null);
        vn.setExtraStackFrame($e);
      } else
        vn.setExtraStackFrame(null);
    }
    function X(Q, Ee, $e, ut, It) {
      {
        var on = Function.call.bind(Ge);
        for (var jt in Q)
          if (on(Q, jt)) {
            var Rt = void 0;
            try {
              if (typeof Q[jt] != "function") {
                var Or = Error((ut || "React class") + ": " + $e + " type `" + jt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Q[jt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Or.name = "Invariant Violation", Or;
              }
              Rt = Q[jt](Ee, jt, ut, $e, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (an) {
              Rt = an;
            }
            Rt && !(Rt instanceof Error) && (Yt(It), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ut || "React class", $e, jt, typeof Rt), Yt(null)), Rt instanceof Error && !(Rt.message in Ct) && (Ct[Rt.message] = !0, Yt(It), b("Failed %s type: %s", $e, Rt.message), Yt(null));
          }
      }
    }
    var ce = Array.isArray;
    function pe(Q) {
      return ce(Q);
    }
    function Ie(Q) {
      {
        var Ee = typeof Symbol == "function" && Symbol.toStringTag, $e = Ee && Q[Symbol.toStringTag] || Q.constructor.name || "Object";
        return $e;
      }
    }
    function ke(Q) {
      try {
        return Ce(Q), !1;
      } catch {
        return !0;
      }
    }
    function Ce(Q) {
      return "" + Q;
    }
    function De(Q) {
      if (ke(Q))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ie(Q)), Ce(Q);
    }
    var ot = v.ReactCurrentOwner, Nt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Kn, In, Mr;
    Mr = {};
    function qi(Q) {
      if (Ge.call(Q, "ref")) {
        var Ee = Object.getOwnPropertyDescriptor(Q, "ref").get;
        if (Ee && Ee.isReactWarning)
          return !1;
      }
      return Q.ref !== void 0;
    }
    function Us(Q) {
      if (Ge.call(Q, "key")) {
        var Ee = Object.getOwnPropertyDescriptor(Q, "key").get;
        if (Ee && Ee.isReactWarning)
          return !1;
      }
      return Q.key !== void 0;
    }
    function ur(Q, Ee) {
      if (typeof Q.ref == "string" && ot.current && Ee && ot.current.stateNode !== Ee) {
        var $e = k(ot.current.type);
        Mr[$e] || (b('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', k(ot.current.type), Q.ref), Mr[$e] = !0);
      }
    }
    function Hs(Q, Ee) {
      {
        var $e = function() {
          Kn || (Kn = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ee));
        };
        $e.isReactWarning = !0, Object.defineProperty(Q, "key", {
          get: $e,
          configurable: !0
        });
      }
    }
    function Yr(Q, Ee) {
      {
        var $e = function() {
          In || (In = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ee));
        };
        $e.isReactWarning = !0, Object.defineProperty(Q, "ref", {
          get: $e,
          configurable: !0
        });
      }
    }
    var vi = function(Q, Ee, $e, ut, It, on, jt) {
      var Rt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: Q,
        key: Ee,
        ref: $e,
        props: jt,
        // Record the component responsible for creating this element.
        _owner: on
      };
      return Rt._store = {}, Object.defineProperty(Rt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Rt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ut
      }), Object.defineProperty(Rt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: It
      }), Object.freeze && (Object.freeze(Rt.props), Object.freeze(Rt)), Rt;
    };
    function ho(Q, Ee, $e, ut, It) {
      {
        var on, jt = {}, Rt = null, Or = null;
        $e !== void 0 && (De($e), Rt = "" + $e), Us(Ee) && (De(Ee.key), Rt = "" + Ee.key), qi(Ee) && (Or = Ee.ref, ur(Ee, It));
        for (on in Ee)
          Ge.call(Ee, on) && !Nt.hasOwnProperty(on) && (jt[on] = Ee[on]);
        if (Q && Q.defaultProps) {
          var an = Q.defaultProps;
          for (on in an)
            jt[on] === void 0 && (jt[on] = an[on]);
        }
        if (Rt || Or) {
          var hn = typeof Q == "function" ? Q.displayName || Q.name || "Unknown" : Q;
          Rt && Hs(jt, hn), Or && Yr(jt, hn);
        }
        return vi(Q, Rt, Or, It, ut, ot.current, jt);
      }
    }
    var Ss = v.ReactCurrentOwner, ja = v.ReactDebugCurrentFrame;
    function bi(Q) {
      if (Q) {
        var Ee = Q._owner, $e = ze(Q.type, Q._source, Ee ? Ee.type : null);
        ja.setExtraStackFrame($e);
      } else
        ja.setExtraStackFrame(null);
    }
    var Xi;
    Xi = !1;
    function qr(Q) {
      return typeof Q == "object" && Q !== null && Q.$$typeof === e;
    }
    function Wo() {
      {
        if (Ss.current) {
          var Q = k(Ss.current.type);
          if (Q)
            return `

Check the render method of \`` + Q + "`.";
        }
        return "";
      }
    }
    function ct(Q) {
      return "";
    }
    var Pt = {};
    function sn(Q) {
      {
        var Ee = Wo();
        if (!Ee) {
          var $e = typeof Q == "string" ? Q : Q.displayName || Q.name;
          $e && (Ee = `

Check the top-level render call using <` + $e + ">.");
        }
        return Ee;
      }
    }
    function tr(Q, Ee) {
      {
        if (!Q._store || Q._store.validated || Q.key != null)
          return;
        Q._store.validated = !0;
        var $e = sn(Ee);
        if (Pt[$e])
          return;
        Pt[$e] = !0;
        var ut = "";
        Q && Q._owner && Q._owner !== Ss.current && (ut = " It was passed a child from " + k(Q._owner.type) + "."), bi(Q), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', $e, ut), bi(null);
      }
    }
    function Xr(Q, Ee) {
      {
        if (typeof Q != "object")
          return;
        if (pe(Q))
          for (var $e = 0; $e < Q.length; $e++) {
            var ut = Q[$e];
            qr(ut) && tr(ut, Ee);
          }
        else if (qr(Q))
          Q._store && (Q._store.validated = !0);
        else if (Q) {
          var It = m(Q);
          if (typeof It == "function" && It !== Q.entries)
            for (var on = It.call(Q), jt; !(jt = on.next()).done; )
              qr(jt.value) && tr(jt.value, Ee);
        }
      }
    }
    function po(Q) {
      {
        var Ee = Q.type;
        if (Ee == null || typeof Ee == "string")
          return;
        var $e;
        if (typeof Ee == "function")
          $e = Ee.propTypes;
        else if (typeof Ee == "object" && (Ee.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ee.$$typeof === u))
          $e = Ee.propTypes;
        else
          return;
        if ($e) {
          var ut = k(Ee);
          X($e, Q.props, "prop", ut, Q);
        } else if (Ee.PropTypes !== void 0 && !Xi) {
          Xi = !0;
          var It = k(Ee);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", It || "Unknown");
        }
        typeof Ee.getDefaultProps == "function" && !Ee.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ko(Q) {
      {
        for (var Ee = Object.keys(Q.props), $e = 0; $e < Ee.length; $e++) {
          var ut = Ee[$e];
          if (ut !== "children" && ut !== "key") {
            bi(Q), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ut), bi(null);
            break;
          }
        }
        Q.ref !== null && (bi(Q), b("Invalid attribute `ref` supplied to `React.Fragment`."), bi(null));
      }
    }
    var Nn = {};
    function Vs(Q, Ee, $e, ut, It, on) {
      {
        var jt = N(Q);
        if (!jt) {
          var Rt = "";
          (Q === void 0 || typeof Q == "object" && Q !== null && Object.keys(Q).length === 0) && (Rt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Or = ct();
          Or ? Rt += Or : Rt += Wo();
          var an;
          Q === null ? an = "null" : pe(Q) ? an = "array" : Q !== void 0 && Q.$$typeof === e ? (an = "<" + (k(Q.type) || "Unknown") + " />", Rt = " Did you accidentally export a JSX literal instead of a component?") : an = typeof Q, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", an, Rt);
        }
        var hn = ho(Q, Ee, $e, It, on);
        if (hn == null)
          return hn;
        if (jt) {
          var Cs = Ee.children;
          if (Cs !== void 0)
            if (ut)
              if (pe(Cs)) {
                for (var Qi = 0; Qi < Cs.length; Qi++)
                  Xr(Cs[Qi], Q);
                Object.freeze && Object.freeze(Cs);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Xr(Cs, Q);
        }
        if (Ge.call(Ee, "key")) {
          var Ji = k(Q), Zr = Object.keys(Ee).filter(function(gh) {
            return gh !== "key";
          }), ud = Zr.length > 0 ? "{key: someKey, " + Zr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Nn[Ji + ud]) {
            var ea = Zr.length > 0 ? "{" + Zr.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ud, Ji, ea, Ji), Nn[Ji + ud] = !0;
          }
        }
        return Q === r ? Ko(hn) : po(hn), hn;
      }
    }
    function _u(Q, Ee, $e) {
      return Vs(Q, Ee, $e, !0);
    }
    function dd(Q, Ee, $e) {
      return Vs(Q, Ee, $e, !1);
    }
    var Zi = dd, ph = _u;
    Bv.Fragment = r, Bv.jsx = Zi, Bv.jsxs = ph;
  }()), Bv;
}
process.env.NODE_ENV === "production" ? ED.exports = qbe() : ED.exports = Xbe();
var h = ED.exports;
const Zbe = 1, Qbe = 1e6;
let RA = 0;
function Jbe() {
  return RA = (RA + 1) % Number.MAX_SAFE_INTEGER, RA.toString();
}
const $A = /* @__PURE__ */ new Map(), wz = (t) => {
  if ($A.has(t))
    return;
  const e = setTimeout(() => {
    $A.delete(t), ox({
      type: "REMOVE_TOAST",
      toastId: t
    });
  }, Qbe);
  $A.set(t, e);
}, exe = (t, e) => {
  switch (e.type) {
    case "ADD_TOAST":
      return {
        ...t,
        toasts: [e.toast, ...t.toasts].slice(0, Zbe)
      };
    case "UPDATE_TOAST":
      return {
        ...t,
        toasts: t.toasts.map((n) => n.id === e.toast.id ? { ...n, ...e.toast } : n)
      };
    case "DISMISS_TOAST": {
      const { toastId: n } = e;
      return n ? wz(n) : t.toasts.forEach((r) => {
        wz(r.id);
      }), {
        ...t,
        toasts: t.toasts.map(
          (r) => r.id === n || n === void 0 ? {
            ...r,
            open: !1
          } : r
        )
      };
    }
    case "REMOVE_TOAST":
      return e.toastId === void 0 ? {
        ...t,
        toasts: []
      } : {
        ...t,
        toasts: t.toasts.filter((n) => n.id !== e.toastId)
      };
  }
}, MC = [];
let OC = { toasts: [] };
function ox(t) {
  OC = exe(OC, t), MC.forEach((e) => {
    e(OC);
  });
}
function Fd({ ...t }) {
  const e = Jbe(), n = (s) => ox({
    type: "UPDATE_TOAST",
    toast: { ...s, id: e }
  }), r = () => ox({ type: "DISMISS_TOAST", toastId: e });
  return ox({
    type: "ADD_TOAST",
    toast: {
      ...t,
      id: e,
      open: !0,
      onOpenChange: (s) => {
        s || r();
      }
    }
  }), {
    id: e,
    dismiss: r,
    update: n
  };
}
function j$() {
  const [t, e] = T.useState(OC);
  return T.useEffect(() => (MC.push(e), () => {
    const n = MC.indexOf(e);
    n > -1 && MC.splice(n, 1);
  }), [t]), {
    ...t,
    toast: Fd,
    dismiss: (n) => ox({ type: "DISMISS_TOAST", toastId: n })
  };
}
function Te(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(s) {
    if (t == null || t(s), n === !1 || !s.defaultPrevented)
      return e == null ? void 0 : e(s);
  };
}
function Sz(t, e) {
  if (typeof t == "function")
    return t(e);
  t != null && (t.current = e);
}
function eu(...t) {
  return (e) => {
    let n = !1;
    const r = t.map((s) => {
      const o = Sz(s, e);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let s = 0; s < r.length; s++) {
          const o = r[s];
          typeof o == "function" ? o() : Sz(t[s], null);
        }
      };
  };
}
function vt(...t) {
  return T.useCallback(eu(...t), t);
}
function txe(t, e) {
  const n = T.createContext(e), r = (o) => {
    const { children: i, ...a } = o, c = T.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ h.jsx(n.Provider, { value: c, children: i });
  };
  r.displayName = t + "Provider";
  function s(o) {
    const i = T.useContext(n);
    if (i) return i;
    if (e !== void 0) return e;
    throw new Error(`\`${o}\` must be used within \`${t}\``);
  }
  return [r, s];
}
function bs(t, e = []) {
  let n = [];
  function r(o, i) {
    const a = T.createContext(i), c = n.length;
    n = [...n, i];
    const l = (u) => {
      var v;
      const { scope: f, children: p, ...g } = u, y = ((v = f == null ? void 0 : f[t]) == null ? void 0 : v[c]) || a, m = T.useMemo(() => g, Object.values(g));
      return /* @__PURE__ */ h.jsx(y.Provider, { value: m, children: p });
    };
    l.displayName = o + "Provider";
    function d(u, f) {
      var y;
      const p = ((y = f == null ? void 0 : f[t]) == null ? void 0 : y[c]) || a, g = T.useContext(p);
      if (g) return g;
      if (i !== void 0) return i;
      throw new Error(`\`${u}\` must be used within \`${o}\``);
    }
    return [l, d];
  }
  const s = () => {
    const o = n.map((i) => T.createContext(i));
    return function(a) {
      const c = (a == null ? void 0 : a[t]) || o;
      return T.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: c } }),
        [a, c]
      );
    };
  };
  return s.scopeName = t, [r, nxe(s, ...e)];
}
function nxe(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((s) => ({
      useScope: s(),
      scopeName: s.scopeName
    }));
    return function(o) {
      const i = r.reduce((a, { useScope: c, scopeName: l }) => {
        const u = c(o)[`__scope${l}`];
        return { ...a, ...u };
      }, {});
      return T.useMemo(() => ({ [`__scope${e.scopeName}`]: i }), [i]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
// @__NO_SIDE_EFFECTS__
function kf(t) {
  const e = /* @__PURE__ */ rxe(t), n = T.forwardRef((r, s) => {
    const { children: o, ...i } = r, a = T.Children.toArray(o), c = a.find(oxe);
    if (c) {
      const l = c.props.children, d = a.map((u) => u === c ? T.Children.count(l) > 1 ? T.Children.only(null) : T.isValidElement(l) ? l.props.children : null : u);
      return /* @__PURE__ */ h.jsx(e, { ...i, ref: s, children: T.isValidElement(l) ? T.cloneElement(l, void 0, d) : null });
    }
    return /* @__PURE__ */ h.jsx(e, { ...i, ref: s, children: o });
  });
  return n.displayName = `${t}.Slot`, n;
}
var zy = /* @__PURE__ */ kf("Slot");
// @__NO_SIDE_EFFECTS__
function rxe(t) {
  const e = T.forwardRef((n, r) => {
    const { children: s, ...o } = n;
    if (T.isValidElement(s)) {
      const i = axe(s), a = ixe(o, s.props);
      return s.type !== T.Fragment && (a.ref = r ? eu(r, i) : i), T.cloneElement(s, a);
    }
    return T.Children.count(s) > 1 ? T.Children.only(null) : null;
  });
  return e.displayName = `${t}.SlotClone`, e;
}
var gq = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function sxe(t) {
  const e = ({ children: n }) => /* @__PURE__ */ h.jsx(h.Fragment, { children: n });
  return e.displayName = `${t}.Slottable`, e.__radixId = gq, e;
}
function oxe(t) {
  return T.isValidElement(t) && typeof t.type == "function" && "__radixId" in t.type && t.type.__radixId === gq;
}
function ixe(t, e) {
  const n = { ...e };
  for (const r in e) {
    const s = t[r], o = e[r];
    /^on[A-Z]/.test(r) ? s && o ? n[r] = (...a) => {
      const c = o(...a);
      return s(...a), c;
    } : s && (n[r] = s) : r === "style" ? n[r] = { ...s, ...o } : r === "className" && (n[r] = [s, o].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function axe(t) {
  var r, s;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
function w0(t) {
  const e = t + "CollectionProvider", [n, r] = bs(e), [s, o] = n(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), i = (y) => {
    const { scope: m, children: v } = y, b = B.useRef(null), x = B.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ h.jsx(s, { scope: m, itemMap: x, collectionRef: b, children: v });
  };
  i.displayName = e;
  const a = t + "CollectionSlot", c = /* @__PURE__ */ kf(a), l = B.forwardRef(
    (y, m) => {
      const { scope: v, children: b } = y, x = o(a, v), w = vt(m, x.collectionRef);
      return /* @__PURE__ */ h.jsx(c, { ref: w, children: b });
    }
  );
  l.displayName = a;
  const d = t + "CollectionItemSlot", u = "data-radix-collection-item", f = /* @__PURE__ */ kf(d), p = B.forwardRef(
    (y, m) => {
      const { scope: v, children: b, ...x } = y, w = B.useRef(null), S = vt(m, w), C = o(d, v);
      return B.useEffect(() => (C.itemMap.set(w, { ref: w, ...x }), () => void C.itemMap.delete(w))), /* @__PURE__ */ h.jsx(f, { [u]: "", ref: S, children: b });
    }
  );
  p.displayName = d;
  function g(y) {
    const m = o(t + "CollectionConsumer", y);
    return B.useCallback(() => {
      const b = m.collectionRef.current;
      if (!b) return [];
      const x = Array.from(b.querySelectorAll(`[${u}]`));
      return Array.from(m.itemMap.values()).sort(
        (C, _) => x.indexOf(C.ref.current) - x.indexOf(_.ref.current)
      );
    }, [m.collectionRef, m.itemMap]);
  }
  return [
    { Provider: i, Slot: l, ItemSlot: p },
    g,
    r
  ];
}
var cxe = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Re = cxe.reduce((t, e) => {
  const n = /* @__PURE__ */ kf(`Primitive.${e}`), r = T.forwardRef((s, o) => {
    const { asChild: i, ...a } = s, c = i ? n : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ h.jsx(c, { ...a, ref: o });
  });
  return r.displayName = `Primitive.${e}`, { ...t, [e]: r };
}, {});
function R$(t, e) {
  t && b0.flushSync(() => t.dispatchEvent(e));
}
function pr(t) {
  const e = T.useRef(t);
  return T.useEffect(() => {
    e.current = t;
  }), T.useMemo(() => (...n) => {
    var r;
    return (r = e.current) == null ? void 0 : r.call(e, ...n);
  }, []);
}
function lxe(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = pr(t);
  T.useEffect(() => {
    const r = (s) => {
      s.key === "Escape" && n(s);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [n, e]);
}
var dxe = "DismissableLayer", TD = "dismissableLayer.update", uxe = "dismissableLayer.pointerDownOutside", fxe = "dismissableLayer.focusOutside", Cz, mq = T.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), ng = T.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: s,
      onFocusOutside: o,
      onInteractOutside: i,
      onDismiss: a,
      ...c
    } = t, l = T.useContext(mq), [d, u] = T.useState(null), f = (d == null ? void 0 : d.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, p] = T.useState({}), g = vt(e, (_) => u(_)), y = Array.from(l.layers), [m] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1), v = y.indexOf(m), b = d ? y.indexOf(d) : -1, x = l.layersWithOutsidePointerEventsDisabled.size > 0, w = b >= v, S = pxe((_) => {
      const E = _.target, M = [...l.branches].some((N) => N.contains(E));
      !w || M || (s == null || s(_), i == null || i(_), _.defaultPrevented || a == null || a());
    }, f), C = gxe((_) => {
      const E = _.target;
      [...l.branches].some((N) => N.contains(E)) || (o == null || o(_), i == null || i(_), _.defaultPrevented || a == null || a());
    }, f);
    return lxe((_) => {
      b === l.layers.size - 1 && (r == null || r(_), !_.defaultPrevented && a && (_.preventDefault(), a()));
    }, f), T.useEffect(() => {
      if (d)
        return n && (l.layersWithOutsidePointerEventsDisabled.size === 0 && (Cz = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), l.layersWithOutsidePointerEventsDisabled.add(d)), l.layers.add(d), _z(), () => {
          n && l.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = Cz);
        };
    }, [d, f, n, l]), T.useEffect(() => () => {
      d && (l.layers.delete(d), l.layersWithOutsidePointerEventsDisabled.delete(d), _z());
    }, [d, l]), T.useEffect(() => {
      const _ = () => p({});
      return document.addEventListener(TD, _), () => document.removeEventListener(TD, _);
    }, []), /* @__PURE__ */ h.jsx(
      Re.div,
      {
        ...c,
        ref: g,
        style: {
          pointerEvents: x ? w ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: Te(t.onFocusCapture, C.onFocusCapture),
        onBlurCapture: Te(t.onBlurCapture, C.onBlurCapture),
        onPointerDownCapture: Te(
          t.onPointerDownCapture,
          S.onPointerDownCapture
        )
      }
    );
  }
);
ng.displayName = dxe;
var hxe = "DismissableLayerBranch", yq = T.forwardRef((t, e) => {
  const n = T.useContext(mq), r = T.useRef(null), s = vt(e, r);
  return T.useEffect(() => {
    const o = r.current;
    if (o)
      return n.branches.add(o), () => {
        n.branches.delete(o);
      };
  }, [n.branches]), /* @__PURE__ */ h.jsx(Re.div, { ...t, ref: s });
});
yq.displayName = hxe;
function pxe(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = pr(t), r = T.useRef(!1), s = T.useRef(() => {
  });
  return T.useEffect(() => {
    const o = (a) => {
      if (a.target && !r.current) {
        let c = function() {
          vq(
            uxe,
            n,
            l,
            { discrete: !0 }
          );
        };
        const l = { originalEvent: a };
        a.pointerType === "touch" ? (e.removeEventListener("click", s.current), s.current = c, e.addEventListener("click", s.current, { once: !0 })) : c();
      } else
        e.removeEventListener("click", s.current);
      r.current = !1;
    }, i = window.setTimeout(() => {
      e.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(i), e.removeEventListener("pointerdown", o), e.removeEventListener("click", s.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function gxe(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = pr(t), r = T.useRef(!1);
  return T.useEffect(() => {
    const s = (o) => {
      o.target && !r.current && vq(fxe, n, { originalEvent: o }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", s), () => e.removeEventListener("focusin", s);
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function _z() {
  const t = new CustomEvent(TD);
  document.dispatchEvent(t);
}
function vq(t, e, n, { discrete: r }) {
  const s = n.originalEvent.target, o = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && s.addEventListener(t, e, { once: !0 }), r ? R$(s, o) : s.dispatchEvent(o);
}
var mxe = ng, yxe = yq, vs = globalThis != null && globalThis.document ? T.useLayoutEffect : () => {
}, vxe = "Portal", Uy = T.forwardRef((t, e) => {
  var a;
  const { container: n, ...r } = t, [s, o] = T.useState(!1);
  vs(() => o(!0), []);
  const i = n || s && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
  return i ? By.createPortal(/* @__PURE__ */ h.jsx(Re.div, { ...r, ref: e }), i) : null;
});
Uy.displayName = vxe;
function bxe(t, e) {
  return T.useReducer((n, r) => e[n][r] ?? n, t);
}
var Fs = (t) => {
  const { present: e, children: n } = t, r = xxe(e), s = typeof n == "function" ? n({ present: r.isPresent }) : T.Children.only(n), o = vt(r.ref, wxe(s));
  return typeof n == "function" || r.isPresent ? T.cloneElement(s, { ref: o }) : null;
};
Fs.displayName = "Presence";
function xxe(t) {
  const [e, n] = T.useState(), r = T.useRef(null), s = T.useRef(t), o = T.useRef("none"), i = t ? "mounted" : "unmounted", [a, c] = bxe(i, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return T.useEffect(() => {
    const l = ZS(r.current);
    o.current = a === "mounted" ? l : "none";
  }, [a]), vs(() => {
    const l = r.current, d = s.current;
    if (d !== t) {
      const f = o.current, p = ZS(l);
      t ? c("MOUNT") : p === "none" || (l == null ? void 0 : l.display) === "none" ? c("UNMOUNT") : c(d && f !== p ? "ANIMATION_OUT" : "UNMOUNT"), s.current = t;
    }
  }, [t, c]), vs(() => {
    if (e) {
      let l;
      const d = e.ownerDocument.defaultView ?? window, u = (p) => {
        const y = ZS(r.current).includes(CSS.escape(p.animationName));
        if (p.target === e && y && (c("ANIMATION_END"), !s.current)) {
          const m = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", l = d.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = m);
          });
        }
      }, f = (p) => {
        p.target === e && (o.current = ZS(r.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", u), e.addEventListener("animationend", u), () => {
        d.clearTimeout(l), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", u), e.removeEventListener("animationend", u);
      };
    } else
      c("ANIMATION_END");
  }, [e, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: T.useCallback((l) => {
      r.current = l ? getComputedStyle(l) : null, n(l);
    }, [])
  };
}
function ZS(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function wxe(t) {
  var r, s;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var Sxe = T[" useInsertionEffect ".trim().toString()] || vs;
function io({
  prop: t,
  defaultProp: e,
  onChange: n = () => {
  },
  caller: r
}) {
  const [s, o, i] = Cxe({
    defaultProp: e,
    onChange: n
  }), a = t !== void 0, c = a ? t : s;
  {
    const d = T.useRef(t !== void 0);
    T.useEffect(() => {
      const u = d.current;
      u !== a && console.warn(
        `${r} is changing from ${u ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), d.current = a;
    }, [a, r]);
  }
  const l = T.useCallback(
    (d) => {
      var u;
      if (a) {
        const f = _xe(d) ? d(t) : d;
        f !== t && ((u = i.current) == null || u.call(i, f));
      } else
        o(d);
    },
    [a, t, o, i]
  );
  return [c, l];
}
function Cxe({
  defaultProp: t,
  onChange: e
}) {
  const [n, r] = T.useState(t), s = T.useRef(n), o = T.useRef(e);
  return Sxe(() => {
    o.current = e;
  }, [e]), T.useEffect(() => {
    var i;
    s.current !== n && ((i = o.current) == null || i.call(o, n), s.current = n);
  }, [n, s]), [n, r, o];
}
function _xe(t) {
  return typeof t == "function";
}
var bq = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), Exe = "VisuallyHidden", LP = T.forwardRef(
  (t, e) => /* @__PURE__ */ h.jsx(
    Re.span,
    {
      ...t,
      ref: e,
      style: { ...bq, ...t.style }
    }
  )
);
LP.displayName = Exe;
var Txe = LP, $$ = "ToastProvider", [L$, Pxe, Ixe] = w0("Toast"), [xq, P3t] = bs("Toast", [Ixe]), [kxe, FP] = xq($$), wq = (t) => {
  const {
    __scopeToast: e,
    label: n = "Notification",
    duration: r = 5e3,
    swipeDirection: s = "right",
    swipeThreshold: o = 50,
    children: i
  } = t, [a, c] = T.useState(null), [l, d] = T.useState(0), u = T.useRef(!1), f = T.useRef(!1);
  return n.trim() || console.error(
    `Invalid prop \`label\` supplied to \`${$$}\`. Expected non-empty \`string\`.`
  ), /* @__PURE__ */ h.jsx(L$.Provider, { scope: e, children: /* @__PURE__ */ h.jsx(
    kxe,
    {
      scope: e,
      label: n,
      duration: r,
      swipeDirection: s,
      swipeThreshold: o,
      toastCount: l,
      viewport: a,
      onViewportChange: c,
      onToastAdd: T.useCallback(() => d((p) => p + 1), []),
      onToastRemove: T.useCallback(() => d((p) => p - 1), []),
      isFocusedToastEscapeKeyDownRef: u,
      isClosePausedRef: f,
      children: i
    }
  ) });
};
wq.displayName = $$;
var Sq = "ToastViewport", Axe = ["F8"], PD = "toast.viewportPause", ID = "toast.viewportResume", F$ = T.forwardRef(
  (t, e) => {
    const {
      __scopeToast: n,
      hotkey: r = Axe,
      label: s = "Notifications ({hotkey})",
      ...o
    } = t, i = FP(Sq, n), a = Pxe(n), c = T.useRef(null), l = T.useRef(null), d = T.useRef(null), u = T.useRef(null), f = vt(e, u, i.onViewportChange), p = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), g = i.toastCount > 0;
    T.useEffect(() => {
      const m = (v) => {
        var x;
        r.length !== 0 && r.every((w) => v[w] || v.code === w) && ((x = u.current) == null || x.focus());
      };
      return document.addEventListener("keydown", m), () => document.removeEventListener("keydown", m);
    }, [r]), T.useEffect(() => {
      const m = c.current, v = u.current;
      if (g && m && v) {
        const b = () => {
          if (!i.isClosePausedRef.current) {
            const C = new CustomEvent(PD);
            v.dispatchEvent(C), i.isClosePausedRef.current = !0;
          }
        }, x = () => {
          if (i.isClosePausedRef.current) {
            const C = new CustomEvent(ID);
            v.dispatchEvent(C), i.isClosePausedRef.current = !1;
          }
        }, w = (C) => {
          !m.contains(C.relatedTarget) && x();
        }, S = () => {
          m.contains(document.activeElement) || x();
        };
        return m.addEventListener("focusin", b), m.addEventListener("focusout", w), m.addEventListener("pointermove", b), m.addEventListener("pointerleave", S), window.addEventListener("blur", b), window.addEventListener("focus", x), () => {
          m.removeEventListener("focusin", b), m.removeEventListener("focusout", w), m.removeEventListener("pointermove", b), m.removeEventListener("pointerleave", S), window.removeEventListener("blur", b), window.removeEventListener("focus", x);
        };
      }
    }, [g, i.isClosePausedRef]);
    const y = T.useCallback(
      ({ tabbingDirection: m }) => {
        const b = a().map((x) => {
          const w = x.ref.current, S = [w, ...Hxe(w)];
          return m === "forwards" ? S : S.reverse();
        });
        return (m === "forwards" ? b.reverse() : b).flat();
      },
      [a]
    );
    return T.useEffect(() => {
      const m = u.current;
      if (m) {
        const v = (b) => {
          var S, C, _;
          const x = b.altKey || b.ctrlKey || b.metaKey;
          if (b.key === "Tab" && !x) {
            const E = document.activeElement, M = b.shiftKey;
            if (b.target === m && M) {
              (S = l.current) == null || S.focus();
              return;
            }
            const D = y({ tabbingDirection: M ? "backwards" : "forwards" }), k = D.findIndex((A) => A === E);
            LA(D.slice(k + 1)) ? b.preventDefault() : M ? (C = l.current) == null || C.focus() : (_ = d.current) == null || _.focus();
          }
        };
        return m.addEventListener("keydown", v), () => m.removeEventListener("keydown", v);
      }
    }, [a, y]), /* @__PURE__ */ h.jsxs(
      yxe,
      {
        ref: c,
        role: "region",
        "aria-label": s.replace("{hotkey}", p),
        tabIndex: -1,
        style: { pointerEvents: g ? void 0 : "none" },
        children: [
          g && /* @__PURE__ */ h.jsx(
            kD,
            {
              ref: l,
              onFocusFromOutsideViewport: () => {
                const m = y({
                  tabbingDirection: "forwards"
                });
                LA(m);
              }
            }
          ),
          /* @__PURE__ */ h.jsx(L$.Slot, { scope: n, children: /* @__PURE__ */ h.jsx(Re.ol, { tabIndex: -1, ...o, ref: f }) }),
          g && /* @__PURE__ */ h.jsx(
            kD,
            {
              ref: d,
              onFocusFromOutsideViewport: () => {
                const m = y({
                  tabbingDirection: "backwards"
                });
                LA(m);
              }
            }
          )
        ]
      }
    );
  }
);
F$.displayName = Sq;
var Cq = "ToastFocusProxy", kD = T.forwardRef(
  (t, e) => {
    const { __scopeToast: n, onFocusFromOutsideViewport: r, ...s } = t, o = FP(Cq, n);
    return /* @__PURE__ */ h.jsx(
      LP,
      {
        tabIndex: 0,
        ...s,
        ref: e,
        style: { position: "fixed" },
        onFocus: (i) => {
          var l;
          const a = i.relatedTarget;
          !((l = o.viewport) != null && l.contains(a)) && r();
        }
      }
    );
  }
);
kD.displayName = Cq;
var S0 = "Toast", Mxe = "toast.swipeStart", Oxe = "toast.swipeMove", Dxe = "toast.swipeCancel", Nxe = "toast.swipeEnd", _q = T.forwardRef(
  (t, e) => {
    const { forceMount: n, open: r, defaultOpen: s, onOpenChange: o, ...i } = t, [a, c] = io({
      prop: r,
      defaultProp: s ?? !0,
      onChange: o,
      caller: S0
    });
    return /* @__PURE__ */ h.jsx(Fs, { present: n || a, children: /* @__PURE__ */ h.jsx(
      $xe,
      {
        open: a,
        ...i,
        ref: e,
        onClose: () => c(!1),
        onPause: pr(t.onPause),
        onResume: pr(t.onResume),
        onSwipeStart: Te(t.onSwipeStart, (l) => {
          l.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: Te(t.onSwipeMove, (l) => {
          const { x: d, y: u } = l.detail.delta;
          l.currentTarget.setAttribute("data-swipe", "move"), l.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${d}px`), l.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${u}px`);
        }),
        onSwipeCancel: Te(t.onSwipeCancel, (l) => {
          l.currentTarget.setAttribute("data-swipe", "cancel"), l.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), l.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), l.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), l.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: Te(t.onSwipeEnd, (l) => {
          const { x: d, y: u } = l.detail.delta;
          l.currentTarget.setAttribute("data-swipe", "end"), l.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), l.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), l.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${d}px`), l.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${u}px`), c(!1);
        })
      }
    ) });
  }
);
_q.displayName = S0;
var [jxe, Rxe] = xq(S0, {
  onClose() {
  }
}), $xe = T.forwardRef(
  (t, e) => {
    const {
      __scopeToast: n,
      type: r = "foreground",
      duration: s,
      open: o,
      onClose: i,
      onEscapeKeyDown: a,
      onPause: c,
      onResume: l,
      onSwipeStart: d,
      onSwipeMove: u,
      onSwipeCancel: f,
      onSwipeEnd: p,
      ...g
    } = t, y = FP(S0, n), [m, v] = T.useState(null), b = vt(e, (A) => v(A)), x = T.useRef(null), w = T.useRef(null), S = s || y.duration, C = T.useRef(0), _ = T.useRef(S), E = T.useRef(0), { onToastAdd: M, onToastRemove: N } = y, O = pr(() => {
      var R;
      (m == null ? void 0 : m.contains(document.activeElement)) && ((R = y.viewport) == null || R.focus()), i();
    }), D = T.useCallback(
      (A) => {
        !A || A === 1 / 0 || (window.clearTimeout(E.current), C.current = (/* @__PURE__ */ new Date()).getTime(), E.current = window.setTimeout(O, A));
      },
      [O]
    );
    T.useEffect(() => {
      const A = y.viewport;
      if (A) {
        const R = () => {
          D(_.current), l == null || l();
        }, j = () => {
          const $ = (/* @__PURE__ */ new Date()).getTime() - C.current;
          _.current = _.current - $, window.clearTimeout(E.current), c == null || c();
        };
        return A.addEventListener(PD, j), A.addEventListener(ID, R), () => {
          A.removeEventListener(PD, j), A.removeEventListener(ID, R);
        };
      }
    }, [y.viewport, S, c, l, D]), T.useEffect(() => {
      o && !y.isClosePausedRef.current && D(S);
    }, [o, S, y.isClosePausedRef, D]), T.useEffect(() => (M(), () => N()), [M, N]);
    const k = T.useMemo(() => m ? Mq(m) : null, [m]);
    return y.viewport ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      k && /* @__PURE__ */ h.jsx(
        Lxe,
        {
          __scopeToast: n,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          children: k
        }
      ),
      /* @__PURE__ */ h.jsx(jxe, { scope: n, onClose: O, children: b0.createPortal(
        /* @__PURE__ */ h.jsx(L$.ItemSlot, { scope: n, children: /* @__PURE__ */ h.jsx(
          mxe,
          {
            asChild: !0,
            onEscapeKeyDown: Te(a, () => {
              y.isFocusedToastEscapeKeyDownRef.current || O(), y.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */ h.jsx(
              Re.li,
              {
                tabIndex: 0,
                "data-state": o ? "open" : "closed",
                "data-swipe-direction": y.swipeDirection,
                ...g,
                ref: b,
                style: { userSelect: "none", touchAction: "none", ...t.style },
                onKeyDown: Te(t.onKeyDown, (A) => {
                  A.key === "Escape" && (a == null || a(A.nativeEvent), A.nativeEvent.defaultPrevented || (y.isFocusedToastEscapeKeyDownRef.current = !0, O()));
                }),
                onPointerDown: Te(t.onPointerDown, (A) => {
                  A.button === 0 && (x.current = { x: A.clientX, y: A.clientY });
                }),
                onPointerMove: Te(t.onPointerMove, (A) => {
                  if (!x.current) return;
                  const R = A.clientX - x.current.x, j = A.clientY - x.current.y, $ = !!w.current, F = ["left", "right"].includes(y.swipeDirection), L = ["left", "up"].includes(y.swipeDirection) ? Math.min : Math.max, z = F ? L(0, R) : 0, H = F ? 0 : L(0, j), U = A.pointerType === "touch" ? 10 : 2, W = { x: z, y: H }, Z = { originalEvent: A, delta: W };
                  $ ? (w.current = W, QS(Oxe, u, Z, {
                    discrete: !1
                  })) : Ez(W, y.swipeDirection, U) ? (w.current = W, QS(Mxe, d, Z, {
                    discrete: !1
                  }), A.target.setPointerCapture(A.pointerId)) : (Math.abs(R) > U || Math.abs(j) > U) && (x.current = null);
                }),
                onPointerUp: Te(t.onPointerUp, (A) => {
                  const R = w.current, j = A.target;
                  if (j.hasPointerCapture(A.pointerId) && j.releasePointerCapture(A.pointerId), w.current = null, x.current = null, R) {
                    const $ = A.currentTarget, F = { originalEvent: A, delta: R };
                    Ez(R, y.swipeDirection, y.swipeThreshold) ? QS(Nxe, p, F, {
                      discrete: !0
                    }) : QS(
                      Dxe,
                      f,
                      F,
                      {
                        discrete: !0
                      }
                    ), $.addEventListener("click", (L) => L.preventDefault(), {
                      once: !0
                    });
                  }
                })
              }
            )
          }
        ) }),
        y.viewport
      ) })
    ] }) : null;
  }
), Lxe = (t) => {
  const { __scopeToast: e, children: n, ...r } = t, s = FP(S0, e), [o, i] = T.useState(!1), [a, c] = T.useState(!1);
  return zxe(() => i(!0)), T.useEffect(() => {
    const l = window.setTimeout(() => c(!0), 1e3);
    return () => window.clearTimeout(l);
  }, []), a ? null : /* @__PURE__ */ h.jsx(Uy, { asChild: !0, children: /* @__PURE__ */ h.jsx(LP, { ...r, children: o && /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    s.label,
    " ",
    n
  ] }) }) });
}, Fxe = "ToastTitle", Eq = T.forwardRef(
  (t, e) => {
    const { __scopeToast: n, ...r } = t;
    return /* @__PURE__ */ h.jsx(Re.div, { ...r, ref: e });
  }
);
Eq.displayName = Fxe;
var Bxe = "ToastDescription", Tq = T.forwardRef(
  (t, e) => {
    const { __scopeToast: n, ...r } = t;
    return /* @__PURE__ */ h.jsx(Re.div, { ...r, ref: e });
  }
);
Tq.displayName = Bxe;
var Pq = "ToastAction", Iq = T.forwardRef(
  (t, e) => {
    const { altText: n, ...r } = t;
    return n.trim() ? /* @__PURE__ */ h.jsx(Aq, { altText: n, asChild: !0, children: /* @__PURE__ */ h.jsx(B$, { ...r, ref: e }) }) : (console.error(
      `Invalid prop \`altText\` supplied to \`${Pq}\`. Expected non-empty \`string\`.`
    ), null);
  }
);
Iq.displayName = Pq;
var kq = "ToastClose", B$ = T.forwardRef(
  (t, e) => {
    const { __scopeToast: n, ...r } = t, s = Rxe(kq, n);
    return /* @__PURE__ */ h.jsx(Aq, { asChild: !0, children: /* @__PURE__ */ h.jsx(
      Re.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: Te(t.onClick, s.onClose)
      }
    ) });
  }
);
B$.displayName = kq;
var Aq = T.forwardRef((t, e) => {
  const { __scopeToast: n, altText: r, ...s } = t;
  return /* @__PURE__ */ h.jsx(
    Re.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...s,
      ref: e
    }
  );
});
function Mq(t) {
  const e = [];
  return Array.from(t.childNodes).forEach((r) => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && e.push(r.textContent), Uxe(r)) {
      const s = r.ariaHidden || r.hidden || r.style.display === "none", o = r.dataset.radixToastAnnounceExclude === "";
      if (!s)
        if (o) {
          const i = r.dataset.radixToastAnnounceAlt;
          i && e.push(i);
        } else
          e.push(...Mq(r));
    }
  }), e;
}
function QS(t, e, n, { discrete: r }) {
  const s = n.originalEvent.currentTarget, o = new CustomEvent(t, { bubbles: !0, cancelable: !0, detail: n });
  e && s.addEventListener(t, e, { once: !0 }), r ? R$(s, o) : s.dispatchEvent(o);
}
var Ez = (t, e, n = 0) => {
  const r = Math.abs(t.x), s = Math.abs(t.y), o = r > s;
  return e === "left" || e === "right" ? o && r > n : !o && s > n;
};
function zxe(t = () => {
}) {
  const e = pr(t);
  vs(() => {
    let n = 0, r = 0;
    return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(e)), () => {
      window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
    };
  }, [e]);
}
function Uxe(t) {
  return t.nodeType === t.ELEMENT_NODE;
}
function Hxe(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const s = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function LA(t) {
  const e = document.activeElement;
  return t.some((n) => n === e ? !0 : (n.focus(), document.activeElement !== e));
}
var Oq = wq, Dq = F$, z$ = _q, U$ = Eq, H$ = Tq, V$ = Iq, V_ = B$;
function Nq(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = Nq(t[e])) && (r && (r += " "), r += n);
  } else for (n in t) t[n] && (r && (r += " "), r += n);
  return r;
}
function jq() {
  for (var t, e, n = 0, r = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = Nq(t)) && (r && (r += " "), r += e);
  return r;
}
const Tz = (t) => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t, Pz = jq, Hy = (t, e) => (n) => {
  var r;
  if ((e == null ? void 0 : e.variants) == null) return Pz(t, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: s, defaultVariants: o } = e, i = Object.keys(s).map((l) => {
    const d = n == null ? void 0 : n[l], u = o == null ? void 0 : o[l];
    if (d === null) return null;
    const f = Tz(d) || Tz(u);
    return s[l][f];
  }), a = n && Object.entries(n).reduce((l, d) => {
    let [u, f] = d;
    return f === void 0 || (l[u] = f), l;
  }, {}), c = e == null || (r = e.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((l, d) => {
    let { class: u, className: f, ...p } = d;
    return Object.entries(p).every((g) => {
      let [y, m] = g;
      return Array.isArray(m) ? m.includes({
        ...o,
        ...a
      }[y]) : {
        ...o,
        ...a
      }[y] === m;
    }) ? [
      ...l,
      u,
      f
    ] : l;
  }, []);
  return Pz(t, i, c, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Vxe = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Rq = (...t) => t.filter((e, n, r) => !!e && e.trim() !== "" && r.indexOf(e) === n).join(" ").trim();
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Wxe = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Kxe = du(
  ({
    color: t = "currentColor",
    size: e = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: s = "",
    children: o,
    iconNode: i,
    ...a
  }, c) => _D(
    "svg",
    {
      ref: c,
      ...Wxe,
      width: e,
      height: e,
      stroke: t,
      strokeWidth: r ? Number(n) * 24 / Number(e) : n,
      className: Rq("lucide", s),
      ...a
    },
    [
      ...i.map(([l, d]) => _D(l, d)),
      ...Array.isArray(o) ? o : [o]
    ]
  )
);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Tt = (t, e) => {
  const n = du(
    ({ className: r, ...s }, o) => _D(Kxe, {
      ref: o,
      iconNode: e,
      className: Rq(`lucide-${Vxe(t)}`, r),
      ...s
    })
  );
  return n.displayName = `${t}`, n;
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Gxe = Tt("ArrowLeft", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Yxe = Tt("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mp = Tt("Calendar", [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
  ["path", { d: "M3 10h18", key: "8toen8" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const W$ = Tt("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $q = Tt("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BP = Tt("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Lq = Tt("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const qxe = Tt("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Xxe = Tt("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Zxe = Tt("CircleArrowUp", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m16 12-4-4-4 4", key: "177agl" }],
  ["path", { d: "M12 16V8", key: "1sbj14" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Vy = Tt("CircleHelp", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Iz = Tt("Clock", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Fq = Tt("Columns3", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Qxe = Tt("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Jxe = Tt("Database", [
  ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
  ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
  ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ewe = Tt("ExternalLink", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const twe = Tt("EyeOff", [
  [
    "path",
    {
      d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",
      key: "ct8e1f"
    }
  ],
  ["path", { d: "M14.084 14.158a3 3 0 0 1-4.242-4.242", key: "151rxh" }],
  [
    "path",
    {
      d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",
      key: "13bj9a"
    }
  ],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nwe = Tt("Eye", [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yp = Tt("FileText", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const C0 = Tt("GitBranch", [
  ["line", { x1: "6", x2: "6", y1: "3", y2: "15", key: "17qcm7" }],
  ["circle", { cx: "18", cy: "6", r: "3", key: "1h7g24" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["path", { d: "M18 9a9 9 0 0 1-9 9", key: "n2h4wq" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rwe = Tt("GripVertical", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bq = Tt("House", [
  ["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8", key: "5wwlr5" }],
  [
    "path",
    {
      d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
      key: "1d0kgt"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const K$ = Tt("Keyboard", [
  ["path", { d: "M10 8h.01", key: "1r9ogq" }],
  ["path", { d: "M12 12h.01", key: "1mp3jc" }],
  ["path", { d: "M14 8h.01", key: "1primd" }],
  ["path", { d: "M16 12h.01", key: "1l6xoz" }],
  ["path", { d: "M18 8h.01", key: "emo2bl" }],
  ["path", { d: "M6 8h.01", key: "x9i8wu" }],
  ["path", { d: "M7 16h10", key: "wp8him" }],
  ["path", { d: "M8 12h.01", key: "czm47f" }],
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const G$ = Tt("LayoutGrid", [
  ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }],
  ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }],
  ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }],
  ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AD = Tt("Link2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wy = Tt("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zq = Tt("MessageSquare", [
  ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const swe = Tt("Moon", [
  ["path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z", key: "a7tn18" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Uq = Tt("MousePointer", [
  ["path", { d: "M12.586 12.586 19 19", key: "ea5xo7" }],
  [
    "path",
    {
      d: "M3.688 3.037a.497.497 0 0 0-.651.651l6.5 15.999a.501.501 0 0 0 .947-.062l1.569-6.083a2 2 0 0 1 1.448-1.479l6.124-1.579a.5.5 0 0 0 .063-.947z",
      key: "277e5u"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const W_ = Tt("Network", [
  ["rect", { x: "16", y: "16", width: "6", height: "6", rx: "1", key: "4q2zg0" }],
  ["rect", { x: "2", y: "16", width: "6", height: "6", rx: "1", key: "8cvhb9" }],
  ["rect", { x: "9", y: "2", width: "6", height: "6", rx: "1", key: "1egb70" }],
  ["path", { d: "M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3", key: "1jsf9p" }],
  ["path", { d: "M12 12V8", key: "2874zd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Hq = Tt("Palette", [
  ["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" }],
  ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" }],
  ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" }],
  ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" }],
  [
    "path",
    {
      d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",
      key: "12rzf8"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const owe = Tt("PanelLeftClose", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }],
  ["path", { d: "m16 15-3-3 3-3", key: "14y99z" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Vq = Tt("PanelLeft", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wq = Tt("Pencil", [
  [
    "path",
    {
      d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
      key: "1a8usu"
    }
  ],
  ["path", { d: "m15 5 4 4", key: "1mk7zo" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kz = Tt("Pin", [
  ["path", { d: "M12 17v5", key: "bb1du9" }],
  [
    "path",
    {
      d: "M9 10.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H8a2 2 0 0 0 0 4 1 1 0 0 1 1 1z",
      key: "1nkz8b"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Jc = Tt("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Kq = Tt("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _0 = Tt("Settings", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Gq = Tt("Share2", [
  ["circle", { cx: "18", cy: "5", r: "3", key: "gq8acd" }],
  ["circle", { cx: "6", cy: "12", r: "3", key: "w7nqdw" }],
  ["circle", { cx: "18", cy: "19", r: "3", key: "1xt0gg" }],
  ["line", { x1: "8.59", x2: "15.42", y1: "13.51", y2: "17.49", key: "47mynk" }],
  ["line", { x1: "15.41", x2: "8.59", y1: "6.51", y2: "10.49", key: "1n3mei" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Yq = Tt("SquareCheckBig", [
  ["path", { d: "M21 10.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.5", key: "1uzm8b" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yf = Tt("Star", [
  [
    "path",
    {
      d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",
      key: "r04s7s"
    }
  ]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iwe = Tt("Sun", [
  ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M12 20v2", key: "1lh1kg" }],
  ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }],
  ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }],
  ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const E0 = Tt("Tag", [
  [
    "path",
    {
      d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
      key: "vktsd0"
    }
  ],
  ["circle", { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor", key: "kqv944" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ky = Tt("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rg = Tt("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const awe = Tt("ZoomIn", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "11", x2: "11", y1: "8", y2: "14", key: "1vmskp" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]), Y$ = "-", cwe = (t) => {
  const e = dwe(t), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = t;
  return {
    getClassGroupId: (i) => {
      const a = i.split(Y$);
      return a[0] === "" && a.length !== 1 && a.shift(), qq(a, e) || lwe(i);
    },
    getConflictingClassGroupIds: (i, a) => {
      const c = n[i] || [];
      return a && r[i] ? [...c, ...r[i]] : c;
    }
  };
}, qq = (t, e) => {
  var i;
  if (t.length === 0)
    return e.classGroupId;
  const n = t[0], r = e.nextPart.get(n), s = r ? qq(t.slice(1), r) : void 0;
  if (s)
    return s;
  if (e.validators.length === 0)
    return;
  const o = t.join(Y$);
  return (i = e.validators.find(({
    validator: a
  }) => a(o))) == null ? void 0 : i.classGroupId;
}, Az = /^\[(.+)\]$/, lwe = (t) => {
  if (Az.test(t)) {
    const e = Az.exec(t)[1], n = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, dwe = (t) => {
  const {
    theme: e,
    prefix: n
  } = t, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return fwe(Object.entries(t.classGroups), n).forEach(([o, i]) => {
    MD(i, r, o, e);
  }), r;
}, MD = (t, e, n, r) => {
  t.forEach((s) => {
    if (typeof s == "string") {
      const o = s === "" ? e : Mz(e, s);
      o.classGroupId = n;
      return;
    }
    if (typeof s == "function") {
      if (uwe(s)) {
        MD(s(r), e, n, r);
        return;
      }
      e.validators.push({
        validator: s,
        classGroupId: n
      });
      return;
    }
    Object.entries(s).forEach(([o, i]) => {
      MD(i, Mz(e, o), n, r);
    });
  });
}, Mz = (t, e) => {
  let n = t;
  return e.split(Y$).forEach((r) => {
    n.nextPart.has(r) || n.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(r);
  }), n;
}, uwe = (t) => t.isThemeGetter, fwe = (t, e) => e ? t.map(([n, r]) => {
  const s = r.map((o) => typeof o == "string" ? e + o : typeof o == "object" ? Object.fromEntries(Object.entries(o).map(([i, a]) => [e + i, a])) : o);
  return [n, s];
}) : t, hwe = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const s = (o, i) => {
    n.set(o, i), e++, e > t && (e = 0, r = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(o) {
      let i = n.get(o);
      if (i !== void 0)
        return i;
      if ((i = r.get(o)) !== void 0)
        return s(o, i), i;
    },
    set(o, i) {
      n.has(o) ? n.set(o, i) : s(o, i);
    }
  };
}, Xq = "!", pwe = (t) => {
  const {
    separator: e,
    experimentalParseClassName: n
  } = t, r = e.length === 1, s = e[0], o = e.length, i = (a) => {
    const c = [];
    let l = 0, d = 0, u;
    for (let m = 0; m < a.length; m++) {
      let v = a[m];
      if (l === 0) {
        if (v === s && (r || a.slice(m, m + o) === e)) {
          c.push(a.slice(d, m)), d = m + o;
          continue;
        }
        if (v === "/") {
          u = m;
          continue;
        }
      }
      v === "[" ? l++ : v === "]" && l--;
    }
    const f = c.length === 0 ? a : a.substring(d), p = f.startsWith(Xq), g = p ? f.substring(1) : f, y = u && u > d ? u - d : void 0;
    return {
      modifiers: c,
      hasImportantModifier: p,
      baseClassName: g,
      maybePostfixModifierPosition: y
    };
  };
  return n ? (a) => n({
    className: a,
    parseClassName: i
  }) : i;
}, gwe = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let n = [];
  return t.forEach((r) => {
    r[0] === "[" ? (e.push(...n.sort(), r), n = []) : n.push(r);
  }), e.push(...n.sort()), e;
}, mwe = (t) => ({
  cache: hwe(t.cacheSize),
  parseClassName: pwe(t),
  ...cwe(t)
}), ywe = /\s+/, vwe = (t, e) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: s
  } = e, o = [], i = t.trim().split(ywe);
  let a = "";
  for (let c = i.length - 1; c >= 0; c -= 1) {
    const l = i[c], {
      modifiers: d,
      hasImportantModifier: u,
      baseClassName: f,
      maybePostfixModifierPosition: p
    } = n(l);
    let g = !!p, y = r(g ? f.substring(0, p) : f);
    if (!y) {
      if (!g) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (y = r(f), !y) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      g = !1;
    }
    const m = gwe(d).join(":"), v = u ? m + Xq : m, b = v + y;
    if (o.includes(b))
      continue;
    o.push(b);
    const x = s(y, g);
    for (let w = 0; w < x.length; ++w) {
      const S = x[w];
      o.push(v + S);
    }
    a = l + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function bwe() {
  let t = 0, e, n, r = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (n = Zq(e)) && (r && (r += " "), r += n);
  return r;
}
const Zq = (t) => {
  if (typeof t == "string")
    return t;
  let e, n = "";
  for (let r = 0; r < t.length; r++)
    t[r] && (e = Zq(t[r])) && (n && (n += " "), n += e);
  return n;
};
function xwe(t, ...e) {
  let n, r, s, o = i;
  function i(c) {
    const l = e.reduce((d, u) => u(d), t());
    return n = mwe(l), r = n.cache.get, s = n.cache.set, o = a, a(c);
  }
  function a(c) {
    const l = r(c);
    if (l)
      return l;
    const d = vwe(c, n);
    return s(c, d), d;
  }
  return function() {
    return o(bwe.apply(null, arguments));
  };
}
const Yn = (t) => {
  const e = (n) => n[t] || [];
  return e.isThemeGetter = !0, e;
}, Qq = /^\[(?:([a-z-]+):)?(.+)\]$/i, wwe = /^\d+\/\d+$/, Swe = /* @__PURE__ */ new Set(["px", "full", "screen"]), Cwe = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, _we = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Ewe = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Twe = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Pwe = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, md = (t) => bm(t) || Swe.has(t) || wwe.test(t), Pu = (t) => Gy(t, "length", jwe), bm = (t) => !!t && !Number.isNaN(Number(t)), FA = (t) => Gy(t, "number", bm), zv = (t) => !!t && Number.isInteger(Number(t)), Iwe = (t) => t.endsWith("%") && bm(t.slice(0, -1)), Ft = (t) => Qq.test(t), Iu = (t) => Cwe.test(t), kwe = /* @__PURE__ */ new Set(["length", "size", "percentage"]), Awe = (t) => Gy(t, kwe, Jq), Mwe = (t) => Gy(t, "position", Jq), Owe = /* @__PURE__ */ new Set(["image", "url"]), Dwe = (t) => Gy(t, Owe, $we), Nwe = (t) => Gy(t, "", Rwe), Uv = () => !0, Gy = (t, e, n) => {
  const r = Qq.exec(t);
  return r ? r[1] ? typeof e == "string" ? r[1] === e : e.has(r[1]) : n(r[2]) : !1;
}, jwe = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  _we.test(t) && !Ewe.test(t)
), Jq = () => !1, Rwe = (t) => Twe.test(t), $we = (t) => Pwe.test(t), Lwe = () => {
  const t = Yn("colors"), e = Yn("spacing"), n = Yn("blur"), r = Yn("brightness"), s = Yn("borderColor"), o = Yn("borderRadius"), i = Yn("borderSpacing"), a = Yn("borderWidth"), c = Yn("contrast"), l = Yn("grayscale"), d = Yn("hueRotate"), u = Yn("invert"), f = Yn("gap"), p = Yn("gradientColorStops"), g = Yn("gradientColorStopPositions"), y = Yn("inset"), m = Yn("margin"), v = Yn("opacity"), b = Yn("padding"), x = Yn("saturate"), w = Yn("scale"), S = Yn("sepia"), C = Yn("skew"), _ = Yn("space"), E = Yn("translate"), M = () => ["auto", "contain", "none"], N = () => ["auto", "hidden", "clip", "visible", "scroll"], O = () => ["auto", Ft, e], D = () => [Ft, e], k = () => ["", md, Pu], A = () => ["auto", bm, Ft], R = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], j = () => ["solid", "dashed", "dotted", "double", "none"], $ = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], F = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], L = () => ["", "0", Ft], z = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], H = () => [bm, Ft];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Uv],
      spacing: [md, Pu],
      blur: ["none", "", Iu, Ft],
      brightness: H(),
      borderColor: [t],
      borderRadius: ["none", "", "full", Iu, Ft],
      borderSpacing: D(),
      borderWidth: k(),
      contrast: H(),
      grayscale: L(),
      hueRotate: H(),
      invert: L(),
      gap: D(),
      gradientColorStops: [t],
      gradientColorStopPositions: [Iwe, Pu],
      inset: O(),
      margin: O(),
      opacity: H(),
      padding: D(),
      saturate: H(),
      scale: H(),
      sepia: L(),
      skew: H(),
      space: D(),
      translate: D()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Ft]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Iu]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": z()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": z()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...R(), Ft]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: N()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": N()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": N()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: M()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": M()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": M()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [y]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [y]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [y]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [y]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [y]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [y]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [y]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [y]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [y]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", zv, Ft]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: O()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Ft]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: L()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: L()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", zv, Ft]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Uv]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", zv, Ft]
        }, Ft]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": A()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": A()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Uv]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [zv, Ft]
        }, Ft]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": A()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": A()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Ft]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Ft]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...F()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...F(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...F(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [b]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [b]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [b]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [b]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [b]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [b]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [b]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [b]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [b]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [m]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [m]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [m]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [m]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [m]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [m]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [m]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [m]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [m]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [_]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [_]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ft, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Ft, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Ft, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [Iu]
        }, Iu]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Ft, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Ft, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Ft, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Ft, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Iu, Pu]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", FA]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Uv]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Ft]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", bm, FA]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", md, Ft]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ft]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Ft]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [v]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [v]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...j(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", md, Pu]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", md, Ft]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: D()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ft]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ft]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [v]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...R(), Mwe]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", Awe]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Dwe]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [g]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [g]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [g]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [p]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [o]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [o]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [o]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [o]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [o]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [o]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [o]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [o]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [o]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [o]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [o]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [o]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [o]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [o]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [o]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [v]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...j(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [v]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: j()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [s]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [s]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [s]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [s]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [s]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [s]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [s]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [s]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [s]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [s]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...j()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [md, Ft]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [md, Pu]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: k()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [v]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [md, Pu]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Iu, Nwe]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Uv]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [v]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...$(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": $()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [r]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [c]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Iu, Ft]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [l]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [u]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [x]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [S]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [r]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [c]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [l]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [u]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [v]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [x]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [S]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [i]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [i]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [i]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Ft]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: H()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Ft]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: H()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Ft]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [w]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [w]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [w]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [zv, Ft]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [E]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [E]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [C]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [C]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Ft]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ft]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": D()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": D()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": D()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": D()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": D()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": D()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": D()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": D()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": D()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": D()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": D()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": D()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": D()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": D()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": D()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": D()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": D()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": D()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ft]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [md, Pu, FA]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, Fwe = /* @__PURE__ */ xwe(Lwe);
function Oe(...t) {
  return Fwe(jq(t));
}
const Bwe = Oq, eX = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  Dq,
  {
    ref: n,
    className: Oe(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      t
    ),
    ...e
  }
));
eX.displayName = Dq.displayName;
const zwe = Hy(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), tX = T.forwardRef(({ className: t, variant: e, ...n }, r) => /* @__PURE__ */ h.jsx(z$, { ref: r, className: Oe(zwe({ variant: e }), t), ...n }));
tX.displayName = z$.displayName;
const Uwe = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  V$,
  {
    ref: n,
    className: Oe(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50",
      t
    ),
    ...e
  }
));
Uwe.displayName = V$.displayName;
const nX = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  V_,
  {
    ref: n,
    className: Oe(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      t
    ),
    "toast-close": "",
    ...e,
    children: /* @__PURE__ */ h.jsx(rg, { className: "h-4 w-4" })
  }
));
nX.displayName = V_.displayName;
const rX = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(U$, { ref: n, className: Oe("text-sm font-semibold", t), ...e }));
rX.displayName = U$.displayName;
const sX = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(H$, { ref: n, className: Oe("text-sm opacity-90", t), ...e }));
sX.displayName = H$.displayName;
function Hwe() {
  const { toasts: t } = j$();
  return /* @__PURE__ */ h.jsxs(Bwe, { children: [
    t.map(function({ id: e, title: n, description: r, action: s, ...o }) {
      return /* @__PURE__ */ h.jsxs(tX, { ...o, children: [
        /* @__PURE__ */ h.jsxs("div", { className: "grid gap-1", children: [
          n && /* @__PURE__ */ h.jsx(rX, { children: n }),
          r && /* @__PURE__ */ h.jsx(sX, { children: r })
        ] }),
        s,
        /* @__PURE__ */ h.jsx(nX, {})
      ] }, e);
    }),
    /* @__PURE__ */ h.jsx(eX, {})
  ] });
}
var K_ = ["light", "dark"], q$ = "(prefers-color-scheme: dark)", Vwe = typeof window > "u", X$ = T.createContext(void 0), Wwe = { setTheme: (t) => {
}, themes: [] }, Yy = () => {
  var t;
  return (t = T.useContext(X$)) != null ? t : Wwe;
}, Kwe = (t) => T.useContext(X$) ? t.children : T.createElement(Ywe, { ...t }), Gwe = ["light", "dark"], Ywe = ({ forcedTheme: t, disableTransitionOnChange: e = !1, enableSystem: n = !0, enableColorScheme: r = !0, storageKey: s = "theme", themes: o = Gwe, defaultTheme: i = n ? "system" : "light", attribute: a = "data-theme", value: c, children: l, nonce: d }) => {
  let [u, f] = T.useState(() => Oz(s, i)), [p, g] = T.useState(() => Oz(s)), y = c ? Object.values(c) : o, m = T.useCallback((w) => {
    let S = w;
    if (!S) return;
    w === "system" && n && (S = Dz());
    let C = c ? c[S] : S, _ = e ? Xwe() : null, E = document.documentElement;
    if (a === "class" ? (E.classList.remove(...y), C && E.classList.add(C)) : C ? E.setAttribute(a, C) : E.removeAttribute(a), r) {
      let M = K_.includes(i) ? i : null, N = K_.includes(S) ? S : M;
      E.style.colorScheme = N;
    }
    _ == null || _();
  }, []), v = T.useCallback((w) => {
    let S = typeof w == "function" ? w(w) : w;
    f(S);
    try {
      localStorage.setItem(s, S);
    } catch {
    }
  }, [t]), b = T.useCallback((w) => {
    let S = Dz(w);
    g(S), u === "system" && n && !t && m("system");
  }, [u, t]);
  T.useEffect(() => {
    let w = window.matchMedia(q$);
    return w.addListener(b), b(w), () => w.removeListener(b);
  }, [b]), T.useEffect(() => {
    let w = (S) => {
      if (S.key !== s) return;
      let C = S.newValue || i;
      v(C);
    };
    return window.addEventListener("storage", w), () => window.removeEventListener("storage", w);
  }, [v]), T.useEffect(() => {
    m(t ?? u);
  }, [t, u]);
  let x = T.useMemo(() => ({ theme: u, setTheme: v, forcedTheme: t, resolvedTheme: u === "system" ? p : u, themes: n ? [...o, "system"] : o, systemTheme: n ? p : void 0 }), [u, v, t, p, n, o]);
  return T.createElement(X$.Provider, { value: x }, T.createElement(qwe, { forcedTheme: t, disableTransitionOnChange: e, enableSystem: n, enableColorScheme: r, storageKey: s, themes: o, defaultTheme: i, attribute: a, value: c, children: l, attrs: y, nonce: d }), l);
}, qwe = T.memo(({ forcedTheme: t, storageKey: e, attribute: n, enableSystem: r, enableColorScheme: s, defaultTheme: o, value: i, attrs: a, nonce: c }) => {
  let l = o === "system", d = n === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${a.map((g) => `'${g}'`).join(",")})`};` : `var d=document.documentElement,n='${n}',s='setAttribute';`, u = s ? K_.includes(o) && o ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${o}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", f = (g, y = !1, m = !0) => {
    let v = i ? i[g] : g, b = y ? g + "|| ''" : `'${v}'`, x = "";
    return s && m && !y && K_.includes(g) && (x += `d.style.colorScheme = '${g}';`), n === "class" ? y || v ? x += `c.add(${b})` : x += "null" : v && (x += `d[s](n,${b})`), x;
  }, p = t ? `!function(){${d}${f(t)}}()` : r ? `!function(){try{${d}var e=localStorage.getItem('${e}');if('system'===e||(!e&&${l})){var t='${q$}',m=window.matchMedia(t);if(m.media!==t||m.matches){${f("dark")}}else{${f("light")}}}else if(e){${i ? `var x=${JSON.stringify(i)};` : ""}${f(i ? "x[e]" : "e", !0)}}${l ? "" : "else{" + f(o, !1, !1) + "}"}${u}}catch(e){}}()` : `!function(){try{${d}var e=localStorage.getItem('${e}');if(e){${i ? `var x=${JSON.stringify(i)};` : ""}${f(i ? "x[e]" : "e", !0)}}else{${f(o, !1, !1)};}${u}}catch(t){}}();`;
  return T.createElement("script", { nonce: c, dangerouslySetInnerHTML: { __html: p } });
}), Oz = (t, e) => {
  if (Vwe) return;
  let n;
  try {
    n = localStorage.getItem(t) || void 0;
  } catch {
  }
  return n || e;
}, Xwe = () => {
  let t = document.createElement("style");
  return t.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(t), () => {
    window.getComputedStyle(document.body), setTimeout(() => {
      document.head.removeChild(t);
    }, 1);
  };
}, Dz = (t) => (t || (t = window.matchMedia(q$)), t.matches ? "dark" : "light"), Zwe = (t) => {
  switch (t) {
    case "success":
      return e0e;
    case "info":
      return n0e;
    case "warning":
      return t0e;
    case "error":
      return r0e;
    default:
      return null;
  }
}, Qwe = Array(12).fill(0), Jwe = ({ visible: t, className: e }) => B.createElement("div", { className: ["sonner-loading-wrapper", e].filter(Boolean).join(" "), "data-visible": t }, B.createElement("div", { className: "sonner-spinner" }, Qwe.map((n, r) => B.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${r}` })))), e0e = B.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, B.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), t0e = B.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, B.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), n0e = B.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, B.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), r0e = B.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, B.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" })), s0e = B.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, B.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), B.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })), o0e = () => {
  let [t, e] = B.useState(document.hidden);
  return B.useEffect(() => {
    let n = () => {
      e(document.hidden);
    };
    return document.addEventListener("visibilitychange", n), () => window.removeEventListener("visibilitychange", n);
  }, []), t;
}, OD = 1, i0e = class {
  constructor() {
    this.subscribe = (t) => (this.subscribers.push(t), () => {
      let e = this.subscribers.indexOf(t);
      this.subscribers.splice(e, 1);
    }), this.publish = (t) => {
      this.subscribers.forEach((e) => e(t));
    }, this.addToast = (t) => {
      this.publish(t), this.toasts = [...this.toasts, t];
    }, this.create = (t) => {
      var e;
      let { message: n, ...r } = t, s = typeof (t == null ? void 0 : t.id) == "number" || ((e = t.id) == null ? void 0 : e.length) > 0 ? t.id : OD++, o = this.toasts.find((a) => a.id === s), i = t.dismissible === void 0 ? !0 : t.dismissible;
      return this.dismissedToasts.has(s) && this.dismissedToasts.delete(s), o ? this.toasts = this.toasts.map((a) => a.id === s ? (this.publish({ ...a, ...t, id: s, title: n }), { ...a, ...t, id: s, dismissible: i, title: n }) : a) : this.addToast({ title: n, ...r, dismissible: i, id: s }), s;
    }, this.dismiss = (t) => (this.dismissedToasts.add(t), t || this.toasts.forEach((e) => {
      this.subscribers.forEach((n) => n({ id: e.id, dismiss: !0 }));
    }), this.subscribers.forEach((e) => e({ id: t, dismiss: !0 })), t), this.message = (t, e) => this.create({ ...e, message: t }), this.error = (t, e) => this.create({ ...e, message: t, type: "error" }), this.success = (t, e) => this.create({ ...e, type: "success", message: t }), this.info = (t, e) => this.create({ ...e, type: "info", message: t }), this.warning = (t, e) => this.create({ ...e, type: "warning", message: t }), this.loading = (t, e) => this.create({ ...e, type: "loading", message: t }), this.promise = (t, e) => {
      if (!e) return;
      let n;
      e.loading !== void 0 && (n = this.create({ ...e, promise: t, type: "loading", message: e.loading, description: typeof e.description != "function" ? e.description : void 0 }));
      let r = t instanceof Promise ? t : t(), s = n !== void 0, o, i = r.then(async (c) => {
        if (o = ["resolve", c], B.isValidElement(c)) s = !1, this.create({ id: n, type: "default", message: c });
        else if (c0e(c) && !c.ok) {
          s = !1;
          let l = typeof e.error == "function" ? await e.error(`HTTP error! status: ${c.status}`) : e.error, d = typeof e.description == "function" ? await e.description(`HTTP error! status: ${c.status}`) : e.description;
          this.create({ id: n, type: "error", message: l, description: d });
        } else if (e.success !== void 0) {
          s = !1;
          let l = typeof e.success == "function" ? await e.success(c) : e.success, d = typeof e.description == "function" ? await e.description(c) : e.description;
          this.create({ id: n, type: "success", message: l, description: d });
        }
      }).catch(async (c) => {
        if (o = ["reject", c], e.error !== void 0) {
          s = !1;
          let l = typeof e.error == "function" ? await e.error(c) : e.error, d = typeof e.description == "function" ? await e.description(c) : e.description;
          this.create({ id: n, type: "error", message: l, description: d });
        }
      }).finally(() => {
        var c;
        s && (this.dismiss(n), n = void 0), (c = e.finally) == null || c.call(e);
      }), a = () => new Promise((c, l) => i.then(() => o[0] === "reject" ? l(o[1]) : c(o[1])).catch(l));
      return typeof n != "string" && typeof n != "number" ? { unwrap: a } : Object.assign(n, { unwrap: a });
    }, this.custom = (t, e) => {
      let n = (e == null ? void 0 : e.id) || OD++;
      return this.create({ jsx: t(n), id: n, ...e }), n;
    }, this.getActiveToasts = () => this.toasts.filter((t) => !this.dismissedToasts.has(t.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
}, Ti = new i0e(), a0e = (t, e) => {
  let n = (e == null ? void 0 : e.id) || OD++;
  return Ti.addToast({ title: t, ...e, id: n }), n;
}, c0e = (t) => t && typeof t == "object" && "ok" in t && typeof t.ok == "boolean" && "status" in t && typeof t.status == "number", l0e = a0e, d0e = () => Ti.toasts, u0e = () => Ti.getActiveToasts();
Object.assign(l0e, { success: Ti.success, info: Ti.info, warning: Ti.warning, error: Ti.error, custom: Ti.custom, message: Ti.message, promise: Ti.promise, dismiss: Ti.dismiss, loading: Ti.loading }, { getHistory: d0e, getToasts: u0e });
function f0e(t, { insertAt: e } = {}) {
  if (typeof document > "u") return;
  let n = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style");
  r.type = "text/css", e === "top" && n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r), r.styleSheet ? r.styleSheet.cssText = t : r.appendChild(document.createTextNode(t));
}
f0e(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
function JS(t) {
  return t.label !== void 0;
}
var h0e = 3, p0e = "32px", g0e = "16px", Nz = 4e3, m0e = 356, y0e = 14, v0e = 20, b0e = 200;
function _c(...t) {
  return t.filter(Boolean).join(" ");
}
function x0e(t) {
  let [e, n] = t.split("-"), r = [];
  return e && r.push(e), n && r.push(n), r;
}
var w0e = (t) => {
  var e, n, r, s, o, i, a, c, l, d, u;
  let { invert: f, toast: p, unstyled: g, interacting: y, setHeights: m, visibleToasts: v, heights: b, index: x, toasts: w, expanded: S, removeToast: C, defaultRichColors: _, closeButton: E, style: M, cancelButtonStyle: N, actionButtonStyle: O, className: D = "", descriptionClassName: k = "", duration: A, position: R, gap: j, loadingIcon: $, expandByDefault: F, classNames: L, icons: z, closeButtonAriaLabel: H = "Close toast", pauseWhenPageIsHidden: U } = t, [W, Z] = B.useState(null), [K, oe] = B.useState(null), [Y, ee] = B.useState(!1), [ae, de] = B.useState(!1), [ye, G] = B.useState(!1), [xe, ge] = B.useState(!1), [ze, Ge] = B.useState(!1), [Ct, vn] = B.useState(0), [Yt, X] = B.useState(0), ce = B.useRef(p.duration || A || Nz), pe = B.useRef(null), Ie = B.useRef(null), ke = x === 0, Ce = x + 1 <= v, De = p.type, ot = p.dismissible !== !1, Nt = p.className || "", Kn = p.descriptionClassName || "", In = B.useMemo(() => b.findIndex((ct) => ct.toastId === p.id) || 0, [b, p.id]), Mr = B.useMemo(() => {
    var ct;
    return (ct = p.closeButton) != null ? ct : E;
  }, [p.closeButton, E]), qi = B.useMemo(() => p.duration || A || Nz, [p.duration, A]), Us = B.useRef(0), ur = B.useRef(0), Hs = B.useRef(0), Yr = B.useRef(null), [vi, ho] = R.split("-"), Ss = B.useMemo(() => b.reduce((ct, Pt, sn) => sn >= In ? ct : ct + Pt.height, 0), [b, In]), ja = o0e(), bi = p.invert || f, Xi = De === "loading";
  ur.current = B.useMemo(() => In * j + Ss, [In, Ss]), B.useEffect(() => {
    ce.current = qi;
  }, [qi]), B.useEffect(() => {
    ee(!0);
  }, []), B.useEffect(() => {
    let ct = Ie.current;
    if (ct) {
      let Pt = ct.getBoundingClientRect().height;
      return X(Pt), m((sn) => [{ toastId: p.id, height: Pt, position: p.position }, ...sn]), () => m((sn) => sn.filter((tr) => tr.toastId !== p.id));
    }
  }, [m, p.id]), B.useLayoutEffect(() => {
    if (!Y) return;
    let ct = Ie.current, Pt = ct.style.height;
    ct.style.height = "auto";
    let sn = ct.getBoundingClientRect().height;
    ct.style.height = Pt, X(sn), m((tr) => tr.find((Xr) => Xr.toastId === p.id) ? tr.map((Xr) => Xr.toastId === p.id ? { ...Xr, height: sn } : Xr) : [{ toastId: p.id, height: sn, position: p.position }, ...tr]);
  }, [Y, p.title, p.description, m, p.id]);
  let qr = B.useCallback(() => {
    de(!0), vn(ur.current), m((ct) => ct.filter((Pt) => Pt.toastId !== p.id)), setTimeout(() => {
      C(p);
    }, b0e);
  }, [p, C, m, ur]);
  B.useEffect(() => {
    if (p.promise && De === "loading" || p.duration === 1 / 0 || p.type === "loading") return;
    let ct;
    return S || y || U && ja ? (() => {
      if (Hs.current < Us.current) {
        let Pt = (/* @__PURE__ */ new Date()).getTime() - Us.current;
        ce.current = ce.current - Pt;
      }
      Hs.current = (/* @__PURE__ */ new Date()).getTime();
    })() : ce.current !== 1 / 0 && (Us.current = (/* @__PURE__ */ new Date()).getTime(), ct = setTimeout(() => {
      var Pt;
      (Pt = p.onAutoClose) == null || Pt.call(p, p), qr();
    }, ce.current)), () => clearTimeout(ct);
  }, [S, y, p, De, U, ja, qr]), B.useEffect(() => {
    p.delete && qr();
  }, [qr, p.delete]);
  function Wo() {
    var ct, Pt, sn;
    return z != null && z.loading ? B.createElement("div", { className: _c(L == null ? void 0 : L.loader, (ct = p == null ? void 0 : p.classNames) == null ? void 0 : ct.loader, "sonner-loader"), "data-visible": De === "loading" }, z.loading) : $ ? B.createElement("div", { className: _c(L == null ? void 0 : L.loader, (Pt = p == null ? void 0 : p.classNames) == null ? void 0 : Pt.loader, "sonner-loader"), "data-visible": De === "loading" }, $) : B.createElement(Jwe, { className: _c(L == null ? void 0 : L.loader, (sn = p == null ? void 0 : p.classNames) == null ? void 0 : sn.loader), visible: De === "loading" });
  }
  return B.createElement("li", { tabIndex: 0, ref: Ie, className: _c(D, Nt, L == null ? void 0 : L.toast, (e = p == null ? void 0 : p.classNames) == null ? void 0 : e.toast, L == null ? void 0 : L.default, L == null ? void 0 : L[De], (n = p == null ? void 0 : p.classNames) == null ? void 0 : n[De]), "data-sonner-toast": "", "data-rich-colors": (r = p.richColors) != null ? r : _, "data-styled": !(p.jsx || p.unstyled || g), "data-mounted": Y, "data-promise": !!p.promise, "data-swiped": ze, "data-removed": ae, "data-visible": Ce, "data-y-position": vi, "data-x-position": ho, "data-index": x, "data-front": ke, "data-swiping": ye, "data-dismissible": ot, "data-type": De, "data-invert": bi, "data-swipe-out": xe, "data-swipe-direction": K, "data-expanded": !!(S || F && Y), style: { "--index": x, "--toasts-before": x, "--z-index": w.length - x, "--offset": `${ae ? Ct : ur.current}px`, "--initial-height": F ? "auto" : `${Yt}px`, ...M, ...p.style }, onDragEnd: () => {
    G(!1), Z(null), Yr.current = null;
  }, onPointerDown: (ct) => {
    Xi || !ot || (pe.current = /* @__PURE__ */ new Date(), vn(ur.current), ct.target.setPointerCapture(ct.pointerId), ct.target.tagName !== "BUTTON" && (G(!0), Yr.current = { x: ct.clientX, y: ct.clientY }));
  }, onPointerUp: () => {
    var ct, Pt, sn, tr;
    if (xe || !ot) return;
    Yr.current = null;
    let Xr = Number(((ct = Ie.current) == null ? void 0 : ct.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), po = Number(((Pt = Ie.current) == null ? void 0 : Pt.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), Ko = (/* @__PURE__ */ new Date()).getTime() - ((sn = pe.current) == null ? void 0 : sn.getTime()), Nn = W === "x" ? Xr : po, Vs = Math.abs(Nn) / Ko;
    if (Math.abs(Nn) >= v0e || Vs > 0.11) {
      vn(ur.current), (tr = p.onDismiss) == null || tr.call(p, p), oe(W === "x" ? Xr > 0 ? "right" : "left" : po > 0 ? "down" : "up"), qr(), ge(!0), Ge(!1);
      return;
    }
    G(!1), Z(null);
  }, onPointerMove: (ct) => {
    var Pt, sn, tr, Xr;
    if (!Yr.current || !ot || ((Pt = window.getSelection()) == null ? void 0 : Pt.toString().length) > 0) return;
    let po = ct.clientY - Yr.current.y, Ko = ct.clientX - Yr.current.x, Nn = (sn = t.swipeDirections) != null ? sn : x0e(R);
    !W && (Math.abs(Ko) > 1 || Math.abs(po) > 1) && Z(Math.abs(Ko) > Math.abs(po) ? "x" : "y");
    let Vs = { x: 0, y: 0 };
    W === "y" ? (Nn.includes("top") || Nn.includes("bottom")) && (Nn.includes("top") && po < 0 || Nn.includes("bottom") && po > 0) && (Vs.y = po) : W === "x" && (Nn.includes("left") || Nn.includes("right")) && (Nn.includes("left") && Ko < 0 || Nn.includes("right") && Ko > 0) && (Vs.x = Ko), (Math.abs(Vs.x) > 0 || Math.abs(Vs.y) > 0) && Ge(!0), (tr = Ie.current) == null || tr.style.setProperty("--swipe-amount-x", `${Vs.x}px`), (Xr = Ie.current) == null || Xr.style.setProperty("--swipe-amount-y", `${Vs.y}px`);
  } }, Mr && !p.jsx ? B.createElement("button", { "aria-label": H, "data-disabled": Xi, "data-close-button": !0, onClick: Xi || !ot ? () => {
  } : () => {
    var ct;
    qr(), (ct = p.onDismiss) == null || ct.call(p, p);
  }, className: _c(L == null ? void 0 : L.closeButton, (s = p == null ? void 0 : p.classNames) == null ? void 0 : s.closeButton) }, (o = z == null ? void 0 : z.close) != null ? o : s0e) : null, p.jsx || jA(p.title) ? p.jsx ? p.jsx : typeof p.title == "function" ? p.title() : p.title : B.createElement(B.Fragment, null, De || p.icon || p.promise ? B.createElement("div", { "data-icon": "", className: _c(L == null ? void 0 : L.icon, (i = p == null ? void 0 : p.classNames) == null ? void 0 : i.icon) }, p.promise || p.type === "loading" && !p.icon ? p.icon || Wo() : null, p.type !== "loading" ? p.icon || (z == null ? void 0 : z[De]) || Zwe(De) : null) : null, B.createElement("div", { "data-content": "", className: _c(L == null ? void 0 : L.content, (a = p == null ? void 0 : p.classNames) == null ? void 0 : a.content) }, B.createElement("div", { "data-title": "", className: _c(L == null ? void 0 : L.title, (c = p == null ? void 0 : p.classNames) == null ? void 0 : c.title) }, typeof p.title == "function" ? p.title() : p.title), p.description ? B.createElement("div", { "data-description": "", className: _c(k, Kn, L == null ? void 0 : L.description, (l = p == null ? void 0 : p.classNames) == null ? void 0 : l.description) }, typeof p.description == "function" ? p.description() : p.description) : null), jA(p.cancel) ? p.cancel : p.cancel && JS(p.cancel) ? B.createElement("button", { "data-button": !0, "data-cancel": !0, style: p.cancelButtonStyle || N, onClick: (ct) => {
    var Pt, sn;
    JS(p.cancel) && ot && ((sn = (Pt = p.cancel).onClick) == null || sn.call(Pt, ct), qr());
  }, className: _c(L == null ? void 0 : L.cancelButton, (d = p == null ? void 0 : p.classNames) == null ? void 0 : d.cancelButton) }, p.cancel.label) : null, jA(p.action) ? p.action : p.action && JS(p.action) ? B.createElement("button", { "data-button": !0, "data-action": !0, style: p.actionButtonStyle || O, onClick: (ct) => {
    var Pt, sn;
    JS(p.action) && ((sn = (Pt = p.action).onClick) == null || sn.call(Pt, ct), !ct.defaultPrevented && qr());
  }, className: _c(L == null ? void 0 : L.actionButton, (u = p == null ? void 0 : p.classNames) == null ? void 0 : u.actionButton) }, p.action.label) : null));
};
function jz() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  let t = document.documentElement.getAttribute("dir");
  return t === "auto" || !t ? window.getComputedStyle(document.documentElement).direction : t;
}
function S0e(t, e) {
  let n = {};
  return [t, e].forEach((r, s) => {
    let o = s === 1, i = o ? "--mobile-offset" : "--offset", a = o ? g0e : p0e;
    function c(l) {
      ["top", "right", "bottom", "left"].forEach((d) => {
        n[`${i}-${d}`] = typeof l == "number" ? `${l}px` : l;
      });
    }
    typeof r == "number" || typeof r == "string" ? c(r) : typeof r == "object" ? ["top", "right", "bottom", "left"].forEach((l) => {
      r[l] === void 0 ? n[`${i}-${l}`] = a : n[`${i}-${l}`] = typeof r[l] == "number" ? `${r[l]}px` : r[l];
    }) : c(a);
  }), n;
}
var C0e = du(function(t, e) {
  let { invert: n, position: r = "bottom-right", hotkey: s = ["altKey", "KeyT"], expand: o, closeButton: i, className: a, offset: c, mobileOffset: l, theme: d = "light", richColors: u, duration: f, style: p, visibleToasts: g = h0e, toastOptions: y, dir: m = jz(), gap: v = y0e, loadingIcon: b, icons: x, containerAriaLabel: w = "Notifications", pauseWhenPageIsHidden: S } = t, [C, _] = B.useState([]), E = B.useMemo(() => Array.from(new Set([r].concat(C.filter((U) => U.position).map((U) => U.position)))), [C, r]), [M, N] = B.useState([]), [O, D] = B.useState(!1), [k, A] = B.useState(!1), [R, j] = B.useState(d !== "system" ? d : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), $ = B.useRef(null), F = s.join("+").replace(/Key/g, "").replace(/Digit/g, ""), L = B.useRef(null), z = B.useRef(!1), H = B.useCallback((U) => {
    _((W) => {
      var Z;
      return (Z = W.find((K) => K.id === U.id)) != null && Z.delete || Ti.dismiss(U.id), W.filter(({ id: K }) => K !== U.id);
    });
  }, []);
  return B.useEffect(() => Ti.subscribe((U) => {
    if (U.dismiss) {
      _((W) => W.map((Z) => Z.id === U.id ? { ...Z, delete: !0 } : Z));
      return;
    }
    setTimeout(() => {
      By.flushSync(() => {
        _((W) => {
          let Z = W.findIndex((K) => K.id === U.id);
          return Z !== -1 ? [...W.slice(0, Z), { ...W[Z], ...U }, ...W.slice(Z + 1)] : [U, ...W];
        });
      });
    });
  }), []), B.useEffect(() => {
    if (d !== "system") {
      j(d);
      return;
    }
    if (d === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? j("dark") : j("light")), typeof window > "u") return;
    let U = window.matchMedia("(prefers-color-scheme: dark)");
    try {
      U.addEventListener("change", ({ matches: W }) => {
        j(W ? "dark" : "light");
      });
    } catch {
      U.addListener(({ matches: Z }) => {
        try {
          j(Z ? "dark" : "light");
        } catch (K) {
          console.error(K);
        }
      });
    }
  }, [d]), B.useEffect(() => {
    C.length <= 1 && D(!1);
  }, [C]), B.useEffect(() => {
    let U = (W) => {
      var Z, K;
      s.every((oe) => W[oe] || W.code === oe) && (D(!0), (Z = $.current) == null || Z.focus()), W.code === "Escape" && (document.activeElement === $.current || (K = $.current) != null && K.contains(document.activeElement)) && D(!1);
    };
    return document.addEventListener("keydown", U), () => document.removeEventListener("keydown", U);
  }, [s]), B.useEffect(() => {
    if ($.current) return () => {
      L.current && (L.current.focus({ preventScroll: !0 }), L.current = null, z.current = !1);
    };
  }, [$.current]), B.createElement("section", { ref: e, "aria-label": `${w} ${F}`, tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: !0 }, E.map((U, W) => {
    var Z;
    let [K, oe] = U.split("-");
    return C.length ? B.createElement("ol", { key: U, dir: m === "auto" ? jz() : m, tabIndex: -1, ref: $, className: a, "data-sonner-toaster": !0, "data-theme": R, "data-y-position": K, "data-lifted": O && C.length > 1 && !o, "data-x-position": oe, style: { "--front-toast-height": `${((Z = M[0]) == null ? void 0 : Z.height) || 0}px`, "--width": `${m0e}px`, "--gap": `${v}px`, ...p, ...S0e(c, l) }, onBlur: (Y) => {
      z.current && !Y.currentTarget.contains(Y.relatedTarget) && (z.current = !1, L.current && (L.current.focus({ preventScroll: !0 }), L.current = null));
    }, onFocus: (Y) => {
      Y.target instanceof HTMLElement && Y.target.dataset.dismissible === "false" || z.current || (z.current = !0, L.current = Y.relatedTarget);
    }, onMouseEnter: () => D(!0), onMouseMove: () => D(!0), onMouseLeave: () => {
      k || D(!1);
    }, onDragEnd: () => D(!1), onPointerDown: (Y) => {
      Y.target instanceof HTMLElement && Y.target.dataset.dismissible === "false" || A(!0);
    }, onPointerUp: () => A(!1) }, C.filter((Y) => !Y.position && W === 0 || Y.position === U).map((Y, ee) => {
      var ae, de;
      return B.createElement(w0e, { key: Y.id, icons: x, index: ee, toast: Y, defaultRichColors: u, duration: (ae = y == null ? void 0 : y.duration) != null ? ae : f, className: y == null ? void 0 : y.className, descriptionClassName: y == null ? void 0 : y.descriptionClassName, invert: n, visibleToasts: g, closeButton: (de = y == null ? void 0 : y.closeButton) != null ? de : i, interacting: k, position: U, style: y == null ? void 0 : y.style, unstyled: y == null ? void 0 : y.unstyled, classNames: y == null ? void 0 : y.classNames, cancelButtonStyle: y == null ? void 0 : y.cancelButtonStyle, actionButtonStyle: y == null ? void 0 : y.actionButtonStyle, removeToast: H, toasts: C.filter((ye) => ye.position == Y.position), heights: M.filter((ye) => ye.position == Y.position), setHeights: N, expandByDefault: o, gap: v, loadingIcon: b, expanded: O, pauseWhenPageIsHidden: S, swipeDirections: t.swipeDirections });
    })) : null;
  }));
});
const _0e = ({ ...t }) => {
  const { theme: e = "system" } = Yy();
  return /* @__PURE__ */ h.jsx(
    C0e,
    {
      theme: e,
      className: "toaster group",
      toastOptions: {
        classNames: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      },
      ...t
    }
  );
};
var E0e = T[" useId ".trim().toString()] || (() => {
}), T0e = 0;
function as(t) {
  const [e, n] = T.useState(E0e());
  return vs(() => {
    n((r) => r ?? String(T0e++));
  }, [t]), e ? `radix-${e}` : "";
}
const oX = ["top", "right", "bottom", "left"], Rz = ["start", "end"], $z = /* @__PURE__ */ oX.reduce((t, e) => t.concat(e, e + "-" + Rz[0], e + "-" + Rz[1]), []), el = Math.min, ko = Math.max, G_ = Math.round, e1 = Math.floor, Fl = (t) => ({
  x: t,
  y: t
}), P0e = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, I0e = {
  start: "end",
  end: "start"
};
function DD(t, e, n) {
  return ko(t, el(e, n));
}
function tl(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Sa(t) {
  return t.split("-")[0];
}
function Yc(t) {
  return t.split("-")[1];
}
function Z$(t) {
  return t === "x" ? "y" : "x";
}
function Q$(t) {
  return t === "y" ? "height" : "width";
}
const k0e = /* @__PURE__ */ new Set(["top", "bottom"]);
function Fc(t) {
  return k0e.has(Sa(t)) ? "y" : "x";
}
function J$(t) {
  return Z$(Fc(t));
}
function iX(t, e, n) {
  n === void 0 && (n = !1);
  const r = Yc(t), s = J$(t), o = Q$(s);
  let i = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[o] > e.floating[o] && (i = q_(i)), [i, q_(i)];
}
function A0e(t) {
  const e = q_(t);
  return [Y_(t), e, Y_(e)];
}
function Y_(t) {
  return t.replace(/start|end/g, (e) => I0e[e]);
}
const Lz = ["left", "right"], Fz = ["right", "left"], M0e = ["top", "bottom"], O0e = ["bottom", "top"];
function D0e(t, e, n) {
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? Fz : Lz : e ? Lz : Fz;
    case "left":
    case "right":
      return e ? M0e : O0e;
    default:
      return [];
  }
}
function N0e(t, e, n, r) {
  const s = Yc(t);
  let o = D0e(Sa(t), n === "start", r);
  return s && (o = o.map((i) => i + "-" + s), e && (o = o.concat(o.map(Y_)))), o;
}
function q_(t) {
  return t.replace(/left|right|bottom|top/g, (e) => P0e[e]);
}
function j0e(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function eL(t) {
  return typeof t != "number" ? j0e(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function Ym(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: s
  } = t;
  return {
    width: r,
    height: s,
    top: n,
    left: e,
    right: e + r,
    bottom: n + s,
    x: e,
    y: n
  };
}
function Bz(t, e, n) {
  let {
    reference: r,
    floating: s
  } = t;
  const o = Fc(e), i = J$(e), a = Q$(i), c = Sa(e), l = o === "y", d = r.x + r.width / 2 - s.width / 2, u = r.y + r.height / 2 - s.height / 2, f = r[a] / 2 - s[a] / 2;
  let p;
  switch (c) {
    case "top":
      p = {
        x: d,
        y: r.y - s.height
      };
      break;
    case "bottom":
      p = {
        x: d,
        y: r.y + r.height
      };
      break;
    case "right":
      p = {
        x: r.x + r.width,
        y: u
      };
      break;
    case "left":
      p = {
        x: r.x - s.width,
        y: u
      };
      break;
    default:
      p = {
        x: r.x,
        y: r.y
      };
  }
  switch (Yc(e)) {
    case "start":
      p[i] -= f * (n && l ? -1 : 1);
      break;
    case "end":
      p[i] += f * (n && l ? -1 : 1);
      break;
  }
  return p;
}
async function R0e(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: s,
    platform: o,
    rects: i,
    elements: a,
    strategy: c
  } = t, {
    boundary: l = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: u = "floating",
    altBoundary: f = !1,
    padding: p = 0
  } = tl(e, t), g = eL(p), m = a[f ? u === "floating" ? "reference" : "floating" : u], v = Ym(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(m))) == null || n ? m : m.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: l,
    rootBoundary: d,
    strategy: c
  })), b = u === "floating" ? {
    x: r,
    y: s,
    width: i.floating.width,
    height: i.floating.height
  } : i.reference, x = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), w = await (o.isElement == null ? void 0 : o.isElement(x)) ? await (o.getScale == null ? void 0 : o.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = Ym(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: b,
    offsetParent: x,
    strategy: c
  }) : b);
  return {
    top: (v.top - S.top + g.top) / w.y,
    bottom: (S.bottom - v.bottom + g.bottom) / w.y,
    left: (v.left - S.left + g.left) / w.x,
    right: (S.right - v.right + g.right) / w.x
  };
}
const $0e = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: s = "absolute",
    middleware: o = [],
    platform: i
  } = n, a = o.filter(Boolean), c = await (i.isRTL == null ? void 0 : i.isRTL(e));
  let l = await i.getElementRects({
    reference: t,
    floating: e,
    strategy: s
  }), {
    x: d,
    y: u
  } = Bz(l, r, c), f = r, p = {}, g = 0;
  for (let m = 0; m < a.length; m++) {
    var y;
    const {
      name: v,
      fn: b
    } = a[m], {
      x,
      y: w,
      data: S,
      reset: C
    } = await b({
      x: d,
      y: u,
      initialPlacement: r,
      placement: f,
      strategy: s,
      middlewareData: p,
      rects: l,
      platform: {
        ...i,
        detectOverflow: (y = i.detectOverflow) != null ? y : R0e
      },
      elements: {
        reference: t,
        floating: e
      }
    });
    d = x ?? d, u = w ?? u, p = {
      ...p,
      [v]: {
        ...p[v],
        ...S
      }
    }, C && g <= 50 && (g++, typeof C == "object" && (C.placement && (f = C.placement), C.rects && (l = C.rects === !0 ? await i.getElementRects({
      reference: t,
      floating: e,
      strategy: s
    }) : C.rects), {
      x: d,
      y: u
    } = Bz(l, f, c)), m = -1);
  }
  return {
    x: d,
    y: u,
    placement: f,
    strategy: s,
    middlewareData: p
  };
}, L0e = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: r,
      placement: s,
      rects: o,
      platform: i,
      elements: a,
      middlewareData: c
    } = e, {
      element: l,
      padding: d = 0
    } = tl(t, e) || {};
    if (l == null)
      return {};
    const u = eL(d), f = {
      x: n,
      y: r
    }, p = J$(s), g = Q$(p), y = await i.getDimensions(l), m = p === "y", v = m ? "top" : "left", b = m ? "bottom" : "right", x = m ? "clientHeight" : "clientWidth", w = o.reference[g] + o.reference[p] - f[p] - o.floating[g], S = f[p] - o.reference[p], C = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(l));
    let _ = C ? C[x] : 0;
    (!_ || !await (i.isElement == null ? void 0 : i.isElement(C))) && (_ = a.floating[x] || o.floating[g]);
    const E = w / 2 - S / 2, M = _ / 2 - y[g] / 2 - 1, N = el(u[v], M), O = el(u[b], M), D = N, k = _ - y[g] - O, A = _ / 2 - y[g] / 2 + E, R = DD(D, A, k), j = !c.arrow && Yc(s) != null && A !== R && o.reference[g] / 2 - (A < D ? N : O) - y[g] / 2 < 0, $ = j ? A < D ? A - D : A - k : 0;
    return {
      [p]: f[p] + $,
      data: {
        [p]: R,
        centerOffset: A - R - $,
        ...j && {
          alignmentOffset: $
        }
      },
      reset: j
    };
  }
});
function F0e(t, e, n) {
  return (t ? [...n.filter((s) => Yc(s) === t), ...n.filter((s) => Yc(s) !== t)] : n.filter((s) => Sa(s) === s)).filter((s) => t ? Yc(s) === t || (e ? Y_(s) !== s : !1) : !0);
}
const B0e = function(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(e) {
      var n, r, s;
      const {
        rects: o,
        middlewareData: i,
        placement: a,
        platform: c,
        elements: l
      } = e, {
        crossAxis: d = !1,
        alignment: u,
        allowedPlacements: f = $z,
        autoAlignment: p = !0,
        ...g
      } = tl(t, e), y = u !== void 0 || f === $z ? F0e(u || null, p, f) : f, m = await c.detectOverflow(e, g), v = ((n = i.autoPlacement) == null ? void 0 : n.index) || 0, b = y[v];
      if (b == null)
        return {};
      const x = iX(b, o, await (c.isRTL == null ? void 0 : c.isRTL(l.floating)));
      if (a !== b)
        return {
          reset: {
            placement: y[0]
          }
        };
      const w = [m[Sa(b)], m[x[0]], m[x[1]]], S = [...((r = i.autoPlacement) == null ? void 0 : r.overflows) || [], {
        placement: b,
        overflows: w
      }], C = y[v + 1];
      if (C)
        return {
          data: {
            index: v + 1,
            overflows: S
          },
          reset: {
            placement: C
          }
        };
      const _ = S.map((N) => {
        const O = Yc(N.placement);
        return [N.placement, O && d ? (
          // Check along the mainAxis and main crossAxis side.
          N.overflows.slice(0, 2).reduce((D, k) => D + k, 0)
        ) : (
          // Check only the mainAxis.
          N.overflows[0]
        ), N.overflows];
      }).sort((N, O) => N[1] - O[1]), M = ((s = _.filter((N) => N[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        Yc(N[0]) ? 2 : 3
      ).every((O) => O <= 0))[0]) == null ? void 0 : s[0]) || _[0][0];
      return M !== a ? {
        data: {
          index: v + 1,
          overflows: S
        },
        reset: {
          placement: M
        }
      } : {};
    }
  };
}, z0e = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: s,
        middlewareData: o,
        rects: i,
        initialPlacement: a,
        platform: c,
        elements: l
      } = e, {
        mainAxis: d = !0,
        crossAxis: u = !0,
        fallbackPlacements: f,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: y = !0,
        ...m
      } = tl(t, e);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const v = Sa(s), b = Fc(a), x = Sa(a) === a, w = await (c.isRTL == null ? void 0 : c.isRTL(l.floating)), S = f || (x || !y ? [q_(a)] : A0e(a)), C = g !== "none";
      !f && C && S.push(...N0e(a, y, g, w));
      const _ = [a, ...S], E = await c.detectOverflow(e, m), M = [];
      let N = ((r = o.flip) == null ? void 0 : r.overflows) || [];
      if (d && M.push(E[v]), u) {
        const A = iX(s, i, w);
        M.push(E[A[0]], E[A[1]]);
      }
      if (N = [...N, {
        placement: s,
        overflows: M
      }], !M.every((A) => A <= 0)) {
        var O, D;
        const A = (((O = o.flip) == null ? void 0 : O.index) || 0) + 1, R = _[A];
        if (R && (!(u === "alignment" ? b !== Fc(R) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        N.every((F) => Fc(F.placement) === b ? F.overflows[0] > 0 : !0)))
          return {
            data: {
              index: A,
              overflows: N
            },
            reset: {
              placement: R
            }
          };
        let j = (D = N.filter(($) => $.overflows[0] <= 0).sort(($, F) => $.overflows[1] - F.overflows[1])[0]) == null ? void 0 : D.placement;
        if (!j)
          switch (p) {
            case "bestFit": {
              var k;
              const $ = (k = N.filter((F) => {
                if (C) {
                  const L = Fc(F.placement);
                  return L === b || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  L === "y";
                }
                return !0;
              }).map((F) => [F.placement, F.overflows.filter((L) => L > 0).reduce((L, z) => L + z, 0)]).sort((F, L) => F[1] - L[1])[0]) == null ? void 0 : k[0];
              $ && (j = $);
              break;
            }
            case "initialPlacement":
              j = a;
              break;
          }
        if (s !== j)
          return {
            reset: {
              placement: j
            }
          };
      }
      return {};
    }
  };
};
function zz(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function Uz(t) {
  return oX.some((e) => t[e] >= 0);
}
const U0e = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n,
        platform: r
      } = e, {
        strategy: s = "referenceHidden",
        ...o
      } = tl(t, e);
      switch (s) {
        case "referenceHidden": {
          const i = await r.detectOverflow(e, {
            ...o,
            elementContext: "reference"
          }), a = zz(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: Uz(a)
            }
          };
        }
        case "escaped": {
          const i = await r.detectOverflow(e, {
            ...o,
            altBoundary: !0
          }), a = zz(i, n.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: Uz(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function aX(t) {
  const e = el(...t.map((o) => o.left)), n = el(...t.map((o) => o.top)), r = ko(...t.map((o) => o.right)), s = ko(...t.map((o) => o.bottom));
  return {
    x: e,
    y: n,
    width: r - e,
    height: s - n
  };
}
function H0e(t) {
  const e = t.slice().sort((s, o) => s.y - o.y), n = [];
  let r = null;
  for (let s = 0; s < e.length; s++) {
    const o = e[s];
    !r || o.y - r.y > r.height / 2 ? n.push([o]) : n[n.length - 1].push(o), r = o;
  }
  return n.map((s) => Ym(aX(s)));
}
const V0e = function(t) {
  return t === void 0 && (t = {}), {
    name: "inline",
    options: t,
    async fn(e) {
      const {
        placement: n,
        elements: r,
        rects: s,
        platform: o,
        strategy: i
      } = e, {
        padding: a = 2,
        x: c,
        y: l
      } = tl(t, e), d = Array.from(await (o.getClientRects == null ? void 0 : o.getClientRects(r.reference)) || []), u = H0e(d), f = Ym(aX(d)), p = eL(a);
      function g() {
        if (u.length === 2 && u[0].left > u[1].right && c != null && l != null)
          return u.find((m) => c > m.left - p.left && c < m.right + p.right && l > m.top - p.top && l < m.bottom + p.bottom) || f;
        if (u.length >= 2) {
          if (Fc(n) === "y") {
            const N = u[0], O = u[u.length - 1], D = Sa(n) === "top", k = N.top, A = O.bottom, R = D ? N.left : O.left, j = D ? N.right : O.right, $ = j - R, F = A - k;
            return {
              top: k,
              bottom: A,
              left: R,
              right: j,
              width: $,
              height: F,
              x: R,
              y: k
            };
          }
          const m = Sa(n) === "left", v = ko(...u.map((N) => N.right)), b = el(...u.map((N) => N.left)), x = u.filter((N) => m ? N.left === b : N.right === v), w = x[0].top, S = x[x.length - 1].bottom, C = b, _ = v, E = _ - C, M = S - w;
          return {
            top: w,
            bottom: S,
            left: C,
            right: _,
            width: E,
            height: M,
            x: C,
            y: w
          };
        }
        return f;
      }
      const y = await o.getElementRects({
        reference: {
          getBoundingClientRect: g
        },
        floating: r.floating,
        strategy: i
      });
      return s.reference.x !== y.reference.x || s.reference.y !== y.reference.y || s.reference.width !== y.reference.width || s.reference.height !== y.reference.height ? {
        reset: {
          rects: y
        }
      } : {};
    }
  };
}, cX = /* @__PURE__ */ new Set(["left", "top"]);
async function W0e(t, e) {
  const {
    placement: n,
    platform: r,
    elements: s
  } = t, o = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), i = Sa(n), a = Yc(n), c = Fc(n) === "y", l = cX.has(i) ? -1 : 1, d = o && c ? -1 : 1, u = tl(e, t);
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: g
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: u.mainAxis || 0,
    crossAxis: u.crossAxis || 0,
    alignmentAxis: u.alignmentAxis
  };
  return a && typeof g == "number" && (p = a === "end" ? g * -1 : g), c ? {
    x: p * d,
    y: f * l
  } : {
    x: f * l,
    y: p * d
  };
}
const K0e = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: s,
        y: o,
        placement: i,
        middlewareData: a
      } = e, c = await W0e(e, t);
      return i === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: s + c.x,
        y: o + c.y,
        data: {
          ...c,
          placement: i
        }
      };
    }
  };
}, G0e = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: s,
        platform: o
      } = e, {
        mainAxis: i = !0,
        crossAxis: a = !1,
        limiter: c = {
          fn: (v) => {
            let {
              x: b,
              y: x
            } = v;
            return {
              x: b,
              y: x
            };
          }
        },
        ...l
      } = tl(t, e), d = {
        x: n,
        y: r
      }, u = await o.detectOverflow(e, l), f = Fc(Sa(s)), p = Z$(f);
      let g = d[p], y = d[f];
      if (i) {
        const v = p === "y" ? "top" : "left", b = p === "y" ? "bottom" : "right", x = g + u[v], w = g - u[b];
        g = DD(x, g, w);
      }
      if (a) {
        const v = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", x = y + u[v], w = y - u[b];
        y = DD(x, y, w);
      }
      const m = c.fn({
        ...e,
        [p]: g,
        [f]: y
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - r,
          enabled: {
            [p]: i,
            [f]: a
          }
        }
      };
    }
  };
}, Y0e = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: r,
        placement: s,
        rects: o,
        middlewareData: i
      } = e, {
        offset: a = 0,
        mainAxis: c = !0,
        crossAxis: l = !0
      } = tl(t, e), d = {
        x: n,
        y: r
      }, u = Fc(s), f = Z$(u);
      let p = d[f], g = d[u];
      const y = tl(a, e), m = typeof y == "number" ? {
        mainAxis: y,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...y
      };
      if (c) {
        const x = f === "y" ? "height" : "width", w = o.reference[f] - o.floating[x] + m.mainAxis, S = o.reference[f] + o.reference[x] - m.mainAxis;
        p < w ? p = w : p > S && (p = S);
      }
      if (l) {
        var v, b;
        const x = f === "y" ? "width" : "height", w = cX.has(Sa(s)), S = o.reference[u] - o.floating[x] + (w && ((v = i.offset) == null ? void 0 : v[u]) || 0) + (w ? 0 : m.crossAxis), C = o.reference[u] + o.reference[x] + (w ? 0 : ((b = i.offset) == null ? void 0 : b[u]) || 0) - (w ? m.crossAxis : 0);
        g < S ? g = S : g > C && (g = C);
      }
      return {
        [f]: p,
        [u]: g
      };
    }
  };
}, q0e = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: s,
        rects: o,
        platform: i,
        elements: a
      } = e, {
        apply: c = () => {
        },
        ...l
      } = tl(t, e), d = await i.detectOverflow(e, l), u = Sa(s), f = Yc(s), p = Fc(s) === "y", {
        width: g,
        height: y
      } = o.floating;
      let m, v;
      u === "top" || u === "bottom" ? (m = u, v = f === (await (i.isRTL == null ? void 0 : i.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (v = u, m = f === "end" ? "top" : "bottom");
      const b = y - d.top - d.bottom, x = g - d.left - d.right, w = el(y - d[m], b), S = el(g - d[v], x), C = !e.middlewareData.shift;
      let _ = w, E = S;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (E = x), (r = e.middlewareData.shift) != null && r.enabled.y && (_ = b), C && !f) {
        const N = ko(d.left, 0), O = ko(d.right, 0), D = ko(d.top, 0), k = ko(d.bottom, 0);
        p ? E = g - 2 * (N !== 0 || O !== 0 ? N + O : ko(d.left, d.right)) : _ = y - 2 * (D !== 0 || k !== 0 ? D + k : ko(d.top, d.bottom));
      }
      await c({
        ...e,
        availableWidth: E,
        availableHeight: _
      });
      const M = await i.getDimensions(a.floating);
      return g !== M.width || y !== M.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function zP() {
  return typeof window < "u";
}
function qy(t) {
  return lX(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function ha(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function nd(t) {
  var e;
  return (e = (lX(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function lX(t) {
  return zP() ? t instanceof Node || t instanceof ha(t).Node : !1;
}
function nl(t) {
  return zP() ? t instanceof Element || t instanceof ha(t).Element : !1;
}
function Yl(t) {
  return zP() ? t instanceof HTMLElement || t instanceof ha(t).HTMLElement : !1;
}
function Hz(t) {
  return !zP() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof ha(t).ShadowRoot;
}
const X0e = /* @__PURE__ */ new Set(["inline", "contents"]);
function T0(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: s
  } = rl(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !X0e.has(s);
}
const Z0e = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Q0e(t) {
  return Z0e.has(qy(t));
}
const J0e = [":popover-open", ":modal"];
function UP(t) {
  return J0e.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const eSe = ["transform", "translate", "scale", "rotate", "perspective"], tSe = ["transform", "translate", "scale", "rotate", "perspective", "filter"], nSe = ["paint", "layout", "strict", "content"];
function tL(t) {
  const e = nL(), n = nl(t) ? rl(t) : t;
  return eSe.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || tSe.some((r) => (n.willChange || "").includes(r)) || nSe.some((r) => (n.contain || "").includes(r));
}
function rSe(t) {
  let e = Af(t);
  for (; Yl(e) && !qm(e); ) {
    if (tL(e))
      return e;
    if (UP(e))
      return null;
    e = Af(e);
  }
  return null;
}
function nL() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const sSe = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function qm(t) {
  return sSe.has(qy(t));
}
function rl(t) {
  return ha(t).getComputedStyle(t);
}
function HP(t) {
  return nl(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Af(t) {
  if (qy(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Hz(t) && t.host || // Fallback.
    nd(t)
  );
  return Hz(e) ? e.host : e;
}
function dX(t) {
  const e = Af(t);
  return qm(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Yl(e) && T0(e) ? e : dX(e);
}
function Yx(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const s = dX(t), o = s === ((r = t.ownerDocument) == null ? void 0 : r.body), i = ha(s);
  if (o) {
    const a = ND(i);
    return e.concat(i, i.visualViewport || [], T0(s) ? s : [], a && n ? Yx(a) : []);
  }
  return e.concat(s, Yx(s, [], n));
}
function ND(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function uX(t) {
  const e = rl(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const s = Yl(t), o = s ? t.offsetWidth : n, i = s ? t.offsetHeight : r, a = G_(n) !== o || G_(r) !== i;
  return a && (n = o, r = i), {
    width: n,
    height: r,
    $: a
  };
}
function rL(t) {
  return nl(t) ? t : t.contextElement;
}
function xm(t) {
  const e = rL(t);
  if (!Yl(e))
    return Fl(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: s,
    $: o
  } = uX(e);
  let i = (o ? G_(n.width) : n.width) / r, a = (o ? G_(n.height) : n.height) / s;
  return (!i || !Number.isFinite(i)) && (i = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: i,
    y: a
  };
}
const oSe = /* @__PURE__ */ Fl(0);
function fX(t) {
  const e = ha(t);
  return !nL() || !e.visualViewport ? oSe : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function iSe(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== ha(t) ? !1 : e;
}
function vp(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const s = t.getBoundingClientRect(), o = rL(t);
  let i = Fl(1);
  e && (r ? nl(r) && (i = xm(r)) : i = xm(t));
  const a = iSe(o, n, r) ? fX(o) : Fl(0);
  let c = (s.left + a.x) / i.x, l = (s.top + a.y) / i.y, d = s.width / i.x, u = s.height / i.y;
  if (o) {
    const f = ha(o), p = r && nl(r) ? ha(r) : r;
    let g = f, y = ND(g);
    for (; y && r && p !== g; ) {
      const m = xm(y), v = y.getBoundingClientRect(), b = rl(y), x = v.left + (y.clientLeft + parseFloat(b.paddingLeft)) * m.x, w = v.top + (y.clientTop + parseFloat(b.paddingTop)) * m.y;
      c *= m.x, l *= m.y, d *= m.x, u *= m.y, c += x, l += w, g = ha(y), y = ND(g);
    }
  }
  return Ym({
    width: d,
    height: u,
    x: c,
    y: l
  });
}
function VP(t, e) {
  const n = HP(t).scrollLeft;
  return e ? e.left + n : vp(nd(t)).left + n;
}
function hX(t, e) {
  const n = t.getBoundingClientRect(), r = n.left + e.scrollLeft - VP(t, n), s = n.top + e.scrollTop;
  return {
    x: r,
    y: s
  };
}
function aSe(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: s
  } = t;
  const o = s === "fixed", i = nd(r), a = e ? UP(e.floating) : !1;
  if (r === i || a && o)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = Fl(1);
  const d = Fl(0), u = Yl(r);
  if ((u || !u && !o) && ((qy(r) !== "body" || T0(i)) && (c = HP(r)), Yl(r))) {
    const p = vp(r);
    l = xm(r), d.x = p.x + r.clientLeft, d.y = p.y + r.clientTop;
  }
  const f = i && !u && !o ? hX(i, c) : Fl(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - c.scrollLeft * l.x + d.x + f.x,
    y: n.y * l.y - c.scrollTop * l.y + d.y + f.y
  };
}
function cSe(t) {
  return Array.from(t.getClientRects());
}
function lSe(t) {
  const e = nd(t), n = HP(t), r = t.ownerDocument.body, s = ko(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), o = ko(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let i = -n.scrollLeft + VP(t);
  const a = -n.scrollTop;
  return rl(r).direction === "rtl" && (i += ko(e.clientWidth, r.clientWidth) - s), {
    width: s,
    height: o,
    x: i,
    y: a
  };
}
const Vz = 25;
function dSe(t, e) {
  const n = ha(t), r = nd(t), s = n.visualViewport;
  let o = r.clientWidth, i = r.clientHeight, a = 0, c = 0;
  if (s) {
    o = s.width, i = s.height;
    const d = nL();
    (!d || d && e === "fixed") && (a = s.offsetLeft, c = s.offsetTop);
  }
  const l = VP(r);
  if (l <= 0) {
    const d = r.ownerDocument, u = d.body, f = getComputedStyle(u), p = d.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, g = Math.abs(r.clientWidth - u.clientWidth - p);
    g <= Vz && (o -= g);
  } else l <= Vz && (o += l);
  return {
    width: o,
    height: i,
    x: a,
    y: c
  };
}
const uSe = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function fSe(t, e) {
  const n = vp(t, !0, e === "fixed"), r = n.top + t.clientTop, s = n.left + t.clientLeft, o = Yl(t) ? xm(t) : Fl(1), i = t.clientWidth * o.x, a = t.clientHeight * o.y, c = s * o.x, l = r * o.y;
  return {
    width: i,
    height: a,
    x: c,
    y: l
  };
}
function Wz(t, e, n) {
  let r;
  if (e === "viewport")
    r = dSe(t, n);
  else if (e === "document")
    r = lSe(nd(t));
  else if (nl(e))
    r = fSe(e, n);
  else {
    const s = fX(t);
    r = {
      x: e.x - s.x,
      y: e.y - s.y,
      width: e.width,
      height: e.height
    };
  }
  return Ym(r);
}
function pX(t, e) {
  const n = Af(t);
  return n === e || !nl(n) || qm(n) ? !1 : rl(n).position === "fixed" || pX(n, e);
}
function hSe(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = Yx(t, [], !1).filter((a) => nl(a) && qy(a) !== "body"), s = null;
  const o = rl(t).position === "fixed";
  let i = o ? Af(t) : t;
  for (; nl(i) && !qm(i); ) {
    const a = rl(i), c = tL(i);
    !c && a.position === "fixed" && (s = null), (o ? !c && !s : !c && a.position === "static" && !!s && uSe.has(s.position) || T0(i) && !c && pX(t, i)) ? r = r.filter((d) => d !== i) : s = a, i = Af(i);
  }
  return e.set(t, r), r;
}
function pSe(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: s
  } = t;
  const i = [...n === "clippingAncestors" ? UP(e) ? [] : hSe(e, this._c) : [].concat(n), r], a = i[0], c = i.reduce((l, d) => {
    const u = Wz(e, d, s);
    return l.top = ko(u.top, l.top), l.right = el(u.right, l.right), l.bottom = el(u.bottom, l.bottom), l.left = ko(u.left, l.left), l;
  }, Wz(e, a, s));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function gSe(t) {
  const {
    width: e,
    height: n
  } = uX(t);
  return {
    width: e,
    height: n
  };
}
function mSe(t, e, n) {
  const r = Yl(e), s = nd(e), o = n === "fixed", i = vp(t, !0, o, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = Fl(0);
  function l() {
    c.x = VP(s);
  }
  if (r || !r && !o)
    if ((qy(e) !== "body" || T0(s)) && (a = HP(e)), r) {
      const p = vp(e, !0, o, e);
      c.x = p.x + e.clientLeft, c.y = p.y + e.clientTop;
    } else s && l();
  o && !r && s && l();
  const d = s && !r && !o ? hX(s, a) : Fl(0), u = i.left + a.scrollLeft - c.x - d.x, f = i.top + a.scrollTop - c.y - d.y;
  return {
    x: u,
    y: f,
    width: i.width,
    height: i.height
  };
}
function BA(t) {
  return rl(t).position === "static";
}
function Kz(t, e) {
  if (!Yl(t) || rl(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return nd(t) === n && (n = n.ownerDocument.body), n;
}
function gX(t, e) {
  const n = ha(t);
  if (UP(t))
    return n;
  if (!Yl(t)) {
    let s = Af(t);
    for (; s && !qm(s); ) {
      if (nl(s) && !BA(s))
        return s;
      s = Af(s);
    }
    return n;
  }
  let r = Kz(t, e);
  for (; r && Q0e(r) && BA(r); )
    r = Kz(r, e);
  return r && qm(r) && BA(r) && !tL(r) ? n : r || rSe(t) || n;
}
const ySe = async function(t) {
  const e = this.getOffsetParent || gX, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: mSe(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function vSe(t) {
  return rl(t).direction === "rtl";
}
const bSe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: aSe,
  getDocumentElement: nd,
  getClippingRect: pSe,
  getOffsetParent: gX,
  getElementRects: ySe,
  getClientRects: cSe,
  getDimensions: gSe,
  getScale: xm,
  isElement: nl,
  isRTL: vSe
};
function mX(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function xSe(t, e) {
  let n = null, r;
  const s = nd(t);
  function o() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function i(a, c) {
    a === void 0 && (a = !1), c === void 0 && (c = 1), o();
    const l = t.getBoundingClientRect(), {
      left: d,
      top: u,
      width: f,
      height: p
    } = l;
    if (a || e(), !f || !p)
      return;
    const g = e1(u), y = e1(s.clientWidth - (d + f)), m = e1(s.clientHeight - (u + p)), v = e1(d), x = {
      rootMargin: -g + "px " + -y + "px " + -m + "px " + -v + "px",
      threshold: ko(0, el(1, c)) || 1
    };
    let w = !0;
    function S(C) {
      const _ = C[0].intersectionRatio;
      if (_ !== c) {
        if (!w)
          return i();
        _ ? i(!1, _) : r = setTimeout(() => {
          i(!1, 1e-7);
        }, 1e3);
      }
      _ === 1 && !mX(l, t.getBoundingClientRect()) && i(), w = !1;
    }
    try {
      n = new IntersectionObserver(S, {
        ...x,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(S, x);
    }
    n.observe(t);
  }
  return i(!0), o;
}
function wSe(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: o = !0,
    elementResize: i = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, l = rL(t), d = s || o ? [...l ? Yx(l) : [], ...Yx(e)] : [];
  d.forEach((v) => {
    s && v.addEventListener("scroll", n, {
      passive: !0
    }), o && v.addEventListener("resize", n);
  });
  const u = l && a ? xSe(l, n) : null;
  let f = -1, p = null;
  i && (p = new ResizeObserver((v) => {
    let [b] = v;
    b && b.target === l && p && (p.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var x;
      (x = p) == null || x.observe(e);
    })), n();
  }), l && !c && p.observe(l), p.observe(e));
  let g, y = c ? vp(t) : null;
  c && m();
  function m() {
    const v = vp(t);
    y && !mX(y, v) && n(), y = v, g = requestAnimationFrame(m);
  }
  return n(), () => {
    var v;
    d.forEach((b) => {
      s && b.removeEventListener("scroll", n), o && b.removeEventListener("resize", n);
    }), u == null || u(), (v = p) == null || v.disconnect(), p = null, c && cancelAnimationFrame(g);
  };
}
const SSe = K0e, CSe = B0e, _Se = G0e, ESe = z0e, TSe = q0e, PSe = U0e, Gz = L0e, ISe = V0e, kSe = Y0e, ASe = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), s = {
    platform: bSe,
    ...n
  }, o = {
    ...s.platform,
    _c: r
  };
  return $0e(t, e, {
    ...s,
    platform: o
  });
};
var MSe = typeof document < "u", OSe = function() {
}, DC = MSe ? un : OSe;
function X_(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, s;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!X_(t[r], e[r]))
          return !1;
      return !0;
    }
    if (s = Object.keys(t), n = s.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, s[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = s[r];
      if (!(o === "_owner" && t.$$typeof) && !X_(t[o], e[o]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function yX(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Yz(t, e) {
  const n = yX(t);
  return Math.round(e * n) / n;
}
function zA(t) {
  const e = T.useRef(t);
  return DC(() => {
    e.current = t;
  }), e;
}
function DSe(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: s,
    elements: {
      reference: o,
      floating: i
    } = {},
    transform: a = !0,
    whileElementsMounted: c,
    open: l
  } = t, [d, u] = T.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [f, p] = T.useState(r);
  X_(f, r) || p(r);
  const [g, y] = T.useState(null), [m, v] = T.useState(null), b = T.useCallback((F) => {
    F !== C.current && (C.current = F, y(F));
  }, []), x = T.useCallback((F) => {
    F !== _.current && (_.current = F, v(F));
  }, []), w = o || g, S = i || m, C = T.useRef(null), _ = T.useRef(null), E = T.useRef(d), M = c != null, N = zA(c), O = zA(s), D = zA(l), k = T.useCallback(() => {
    if (!C.current || !_.current)
      return;
    const F = {
      placement: e,
      strategy: n,
      middleware: f
    };
    O.current && (F.platform = O.current), ASe(C.current, _.current, F).then((L) => {
      const z = {
        ...L,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: D.current !== !1
      };
      A.current && !X_(E.current, z) && (E.current = z, b0.flushSync(() => {
        u(z);
      }));
    });
  }, [f, e, n, O, D]);
  DC(() => {
    l === !1 && E.current.isPositioned && (E.current.isPositioned = !1, u((F) => ({
      ...F,
      isPositioned: !1
    })));
  }, [l]);
  const A = T.useRef(!1);
  DC(() => (A.current = !0, () => {
    A.current = !1;
  }), []), DC(() => {
    if (w && (C.current = w), S && (_.current = S), w && S) {
      if (N.current)
        return N.current(w, S, k);
      k();
    }
  }, [w, S, k, N, M]);
  const R = T.useMemo(() => ({
    reference: C,
    floating: _,
    setReference: b,
    setFloating: x
  }), [b, x]), j = T.useMemo(() => ({
    reference: w,
    floating: S
  }), [w, S]), $ = T.useMemo(() => {
    const F = {
      position: n,
      left: 0,
      top: 0
    };
    if (!j.floating)
      return F;
    const L = Yz(j.floating, d.x), z = Yz(j.floating, d.y);
    return a ? {
      ...F,
      transform: "translate(" + L + "px, " + z + "px)",
      ...yX(j.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: L,
      top: z
    };
  }, [n, a, j.floating, d.x, d.y]);
  return T.useMemo(() => ({
    ...d,
    update: k,
    refs: R,
    elements: j,
    floatingStyles: $
  }), [d, k, R, j, $]);
}
const NSe = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: r,
        padding: s
      } = typeof t == "function" ? t(n) : t;
      return r && e(r) ? r.current != null ? Gz({
        element: r.current,
        padding: s
      }).fn(n) : {} : r ? Gz({
        element: r,
        padding: s
      }).fn(n) : {};
    }
  };
}, jSe = (t, e) => ({
  ...SSe(t),
  options: [t, e]
}), RSe = (t, e) => ({
  ..._Se(t),
  options: [t, e]
}), $Se = (t, e) => ({
  ...kSe(t),
  options: [t, e]
}), LSe = (t, e) => ({
  ...ESe(t),
  options: [t, e]
}), FSe = (t, e) => ({
  ...TSe(t),
  options: [t, e]
}), I3t = (t, e) => ({
  ...CSe(t),
  options: [t, e]
}), BSe = (t, e) => ({
  ...PSe(t),
  options: [t, e]
}), k3t = (t, e) => ({
  ...ISe(t),
  options: [t, e]
}), zSe = (t, e) => ({
  ...NSe(t),
  options: [t, e]
});
var USe = "Arrow", vX = T.forwardRef((t, e) => {
  const { children: n, width: r = 10, height: s = 5, ...o } = t;
  return /* @__PURE__ */ h.jsx(
    Re.svg,
    {
      ...o,
      ref: e,
      width: r,
      height: s,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ h.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
vX.displayName = USe;
var HSe = vX;
function WP(t) {
  const [e, n] = T.useState(void 0);
  return vs(() => {
    if (t) {
      n({ width: t.offsetWidth, height: t.offsetHeight });
      const r = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length)
          return;
        const o = s[0];
        let i, a;
        if ("borderBoxSize" in o) {
          const c = o.borderBoxSize, l = Array.isArray(c) ? c[0] : c;
          i = l.inlineSize, a = l.blockSize;
        } else
          i = t.offsetWidth, a = t.offsetHeight;
        n({ width: i, height: a });
      });
      return r.observe(t, { box: "border-box" }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [t]), e;
}
var sL = "Popper", [bX, Kf] = bs(sL), [VSe, xX] = bX(sL), wX = (t) => {
  const { __scopePopper: e, children: n } = t, [r, s] = T.useState(null);
  return /* @__PURE__ */ h.jsx(VSe, { scope: e, anchor: r, onAnchorChange: s, children: n });
};
wX.displayName = sL;
var SX = "PopperAnchor", CX = T.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: r, ...s } = t, o = xX(SX, n), i = T.useRef(null), a = vt(e, i), c = T.useRef(null);
    return T.useEffect(() => {
      const l = c.current;
      c.current = (r == null ? void 0 : r.current) || i.current, l !== c.current && o.onAnchorChange(c.current);
    }), r ? null : /* @__PURE__ */ h.jsx(Re.div, { ...s, ref: a });
  }
);
CX.displayName = SX;
var oL = "PopperContent", [WSe, KSe] = bX(oL), _X = T.forwardRef(
  (t, e) => {
    var Y, ee, ae, de, ye, G;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: s = 0,
      align: o = "center",
      alignOffset: i = 0,
      arrowPadding: a = 0,
      avoidCollisions: c = !0,
      collisionBoundary: l = [],
      collisionPadding: d = 0,
      sticky: u = "partial",
      hideWhenDetached: f = !1,
      updatePositionStrategy: p = "optimized",
      onPlaced: g,
      ...y
    } = t, m = xX(oL, n), [v, b] = T.useState(null), x = vt(e, (xe) => b(xe)), [w, S] = T.useState(null), C = WP(w), _ = (C == null ? void 0 : C.width) ?? 0, E = (C == null ? void 0 : C.height) ?? 0, M = r + (o !== "center" ? "-" + o : ""), N = typeof d == "number" ? d : { top: 0, right: 0, bottom: 0, left: 0, ...d }, O = Array.isArray(l) ? l : [l], D = O.length > 0, k = {
      padding: N,
      boundary: O.filter(YSe),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: D
    }, { refs: A, floatingStyles: R, placement: j, isPositioned: $, middlewareData: F } = DSe({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: M,
      whileElementsMounted: (...xe) => wSe(...xe, {
        animationFrame: p === "always"
      }),
      elements: {
        reference: m.anchor
      },
      middleware: [
        jSe({ mainAxis: s + E, alignmentAxis: i }),
        c && RSe({
          mainAxis: !0,
          crossAxis: !1,
          limiter: u === "partial" ? $Se() : void 0,
          ...k
        }),
        c && LSe({ ...k }),
        FSe({
          ...k,
          apply: ({ elements: xe, rects: ge, availableWidth: ze, availableHeight: Ge }) => {
            const { width: Ct, height: vn } = ge.reference, Yt = xe.floating.style;
            Yt.setProperty("--radix-popper-available-width", `${ze}px`), Yt.setProperty("--radix-popper-available-height", `${Ge}px`), Yt.setProperty("--radix-popper-anchor-width", `${Ct}px`), Yt.setProperty("--radix-popper-anchor-height", `${vn}px`);
          }
        }),
        w && zSe({ element: w, padding: a }),
        qSe({ arrowWidth: _, arrowHeight: E }),
        f && BSe({ strategy: "referenceHidden", ...k })
      ]
    }), [L, z] = PX(j), H = pr(g);
    vs(() => {
      $ && (H == null || H());
    }, [$, H]);
    const U = (Y = F.arrow) == null ? void 0 : Y.x, W = (ee = F.arrow) == null ? void 0 : ee.y, Z = ((ae = F.arrow) == null ? void 0 : ae.centerOffset) !== 0, [K, oe] = T.useState();
    return vs(() => {
      v && oe(window.getComputedStyle(v).zIndex);
    }, [v]), /* @__PURE__ */ h.jsx(
      "div",
      {
        ref: A.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...R,
          transform: $ ? R.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: K,
          "--radix-popper-transform-origin": [
            (de = F.transformOrigin) == null ? void 0 : de.x,
            (ye = F.transformOrigin) == null ? void 0 : ye.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((G = F.hide) == null ? void 0 : G.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ h.jsx(
          WSe,
          {
            scope: n,
            placedSide: L,
            onArrowChange: S,
            arrowX: U,
            arrowY: W,
            shouldHideArrow: Z,
            children: /* @__PURE__ */ h.jsx(
              Re.div,
              {
                "data-side": L,
                "data-align": z,
                ...y,
                ref: x,
                style: {
                  ...y.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: $ ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
_X.displayName = oL;
var EX = "PopperArrow", GSe = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, TX = T.forwardRef(function(e, n) {
  const { __scopePopper: r, ...s } = e, o = KSe(EX, r), i = GSe[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ h.jsx(
      "span",
      {
        ref: o.onArrowChange,
        style: {
          position: "absolute",
          left: o.arrowX,
          top: o.arrowY,
          [i]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o.placedSide],
          visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ h.jsx(
          HSe,
          {
            ...s,
            ref: n,
            style: {
              ...s.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
TX.displayName = EX;
function YSe(t) {
  return t !== null;
}
var qSe = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var m, v, b;
    const { placement: n, rects: r, middlewareData: s } = e, i = ((m = s.arrow) == null ? void 0 : m.centerOffset) !== 0, a = i ? 0 : t.arrowWidth, c = i ? 0 : t.arrowHeight, [l, d] = PX(n), u = { start: "0%", center: "50%", end: "100%" }[d], f = (((v = s.arrow) == null ? void 0 : v.x) ?? 0) + a / 2, p = (((b = s.arrow) == null ? void 0 : b.y) ?? 0) + c / 2;
    let g = "", y = "";
    return l === "bottom" ? (g = i ? u : `${f}px`, y = `${-c}px`) : l === "top" ? (g = i ? u : `${f}px`, y = `${r.floating.height + c}px`) : l === "right" ? (g = `${-c}px`, y = i ? u : `${p}px`) : l === "left" && (g = `${r.floating.width + c}px`, y = i ? u : `${p}px`), { data: { x: g, y } };
  }
});
function PX(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var P0 = wX, I0 = CX, KP = _X, GP = TX, [YP, A3t] = bs("Tooltip", [
  Kf
]), qP = Kf(), IX = "TooltipProvider", XSe = 700, jD = "tooltip.open", [ZSe, iL] = YP(IX), kX = (t) => {
  const {
    __scopeTooltip: e,
    delayDuration: n = XSe,
    skipDelayDuration: r = 300,
    disableHoverableContent: s = !1,
    children: o
  } = t, i = T.useRef(!0), a = T.useRef(!1), c = T.useRef(0);
  return T.useEffect(() => {
    const l = c.current;
    return () => window.clearTimeout(l);
  }, []), /* @__PURE__ */ h.jsx(
    ZSe,
    {
      scope: e,
      isOpenDelayedRef: i,
      delayDuration: n,
      onOpen: T.useCallback(() => {
        window.clearTimeout(c.current), i.current = !1;
      }, []),
      onClose: T.useCallback(() => {
        window.clearTimeout(c.current), c.current = window.setTimeout(
          () => i.current = !0,
          r
        );
      }, [r]),
      isPointerInTransitRef: a,
      onPointerInTransitChange: T.useCallback((l) => {
        a.current = l;
      }, []),
      disableHoverableContent: s,
      children: o
    }
  );
};
kX.displayName = IX;
var qx = "Tooltip", [QSe, XP] = YP(qx), AX = (t) => {
  const {
    __scopeTooltip: e,
    children: n,
    open: r,
    defaultOpen: s,
    onOpenChange: o,
    disableHoverableContent: i,
    delayDuration: a
  } = t, c = iL(qx, t.__scopeTooltip), l = qP(e), [d, u] = T.useState(null), f = as(), p = T.useRef(0), g = i ?? c.disableHoverableContent, y = a ?? c.delayDuration, m = T.useRef(!1), [v, b] = io({
    prop: r,
    defaultProp: s ?? !1,
    onChange: (_) => {
      _ ? (c.onOpen(), document.dispatchEvent(new CustomEvent(jD))) : c.onClose(), o == null || o(_);
    },
    caller: qx
  }), x = T.useMemo(() => v ? m.current ? "delayed-open" : "instant-open" : "closed", [v]), w = T.useCallback(() => {
    window.clearTimeout(p.current), p.current = 0, m.current = !1, b(!0);
  }, [b]), S = T.useCallback(() => {
    window.clearTimeout(p.current), p.current = 0, b(!1);
  }, [b]), C = T.useCallback(() => {
    window.clearTimeout(p.current), p.current = window.setTimeout(() => {
      m.current = !0, b(!0), p.current = 0;
    }, y);
  }, [y, b]);
  return T.useEffect(() => () => {
    p.current && (window.clearTimeout(p.current), p.current = 0);
  }, []), /* @__PURE__ */ h.jsx(P0, { ...l, children: /* @__PURE__ */ h.jsx(
    QSe,
    {
      scope: e,
      contentId: f,
      open: v,
      stateAttribute: x,
      trigger: d,
      onTriggerChange: u,
      onTriggerEnter: T.useCallback(() => {
        c.isOpenDelayedRef.current ? C() : w();
      }, [c.isOpenDelayedRef, C, w]),
      onTriggerLeave: T.useCallback(() => {
        g ? S() : (window.clearTimeout(p.current), p.current = 0);
      }, [S, g]),
      onOpen: w,
      onClose: S,
      disableHoverableContent: g,
      children: n
    }
  ) });
};
AX.displayName = qx;
var RD = "TooltipTrigger", MX = T.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, s = XP(RD, n), o = iL(RD, n), i = qP(n), a = T.useRef(null), c = vt(e, a, s.onTriggerChange), l = T.useRef(!1), d = T.useRef(!1), u = T.useCallback(() => l.current = !1, []);
    return T.useEffect(() => () => document.removeEventListener("pointerup", u), [u]), /* @__PURE__ */ h.jsx(I0, { asChild: !0, ...i, children: /* @__PURE__ */ h.jsx(
      Re.button,
      {
        "aria-describedby": s.open ? s.contentId : void 0,
        "data-state": s.stateAttribute,
        ...r,
        ref: c,
        onPointerMove: Te(t.onPointerMove, (f) => {
          f.pointerType !== "touch" && !d.current && !o.isPointerInTransitRef.current && (s.onTriggerEnter(), d.current = !0);
        }),
        onPointerLeave: Te(t.onPointerLeave, () => {
          s.onTriggerLeave(), d.current = !1;
        }),
        onPointerDown: Te(t.onPointerDown, () => {
          s.open && s.onClose(), l.current = !0, document.addEventListener("pointerup", u, { once: !0 });
        }),
        onFocus: Te(t.onFocus, () => {
          l.current || s.onOpen();
        }),
        onBlur: Te(t.onBlur, s.onClose),
        onClick: Te(t.onClick, s.onClose)
      }
    ) });
  }
);
MX.displayName = RD;
var JSe = "TooltipPortal", [M3t, e1e] = YP(JSe, {
  forceMount: void 0
}), Xm = "TooltipContent", OX = T.forwardRef(
  (t, e) => {
    const n = e1e(Xm, t.__scopeTooltip), { forceMount: r = n.forceMount, side: s = "top", ...o } = t, i = XP(Xm, t.__scopeTooltip);
    return /* @__PURE__ */ h.jsx(Fs, { present: r || i.open, children: i.disableHoverableContent ? /* @__PURE__ */ h.jsx(DX, { side: s, ...o, ref: e }) : /* @__PURE__ */ h.jsx(t1e, { side: s, ...o, ref: e }) });
  }
), t1e = T.forwardRef((t, e) => {
  const n = XP(Xm, t.__scopeTooltip), r = iL(Xm, t.__scopeTooltip), s = T.useRef(null), o = vt(e, s), [i, a] = T.useState(null), { trigger: c, onClose: l } = n, d = s.current, { onPointerInTransitChange: u } = r, f = T.useCallback(() => {
    a(null), u(!1);
  }, [u]), p = T.useCallback(
    (g, y) => {
      const m = g.currentTarget, v = { x: g.clientX, y: g.clientY }, b = i1e(v, m.getBoundingClientRect()), x = a1e(v, b), w = c1e(y.getBoundingClientRect()), S = d1e([...x, ...w]);
      a(S), u(!0);
    },
    [u]
  );
  return T.useEffect(() => () => f(), [f]), T.useEffect(() => {
    if (c && d) {
      const g = (m) => p(m, d), y = (m) => p(m, c);
      return c.addEventListener("pointerleave", g), d.addEventListener("pointerleave", y), () => {
        c.removeEventListener("pointerleave", g), d.removeEventListener("pointerleave", y);
      };
    }
  }, [c, d, p, f]), T.useEffect(() => {
    if (i) {
      const g = (y) => {
        const m = y.target, v = { x: y.clientX, y: y.clientY }, b = (c == null ? void 0 : c.contains(m)) || (d == null ? void 0 : d.contains(m)), x = !l1e(v, i);
        b ? f() : x && (f(), l());
      };
      return document.addEventListener("pointermove", g), () => document.removeEventListener("pointermove", g);
    }
  }, [c, d, i, l, f]), /* @__PURE__ */ h.jsx(DX, { ...t, ref: o });
}), [n1e, r1e] = YP(qx, { isInside: !1 }), s1e = /* @__PURE__ */ sxe("TooltipContent"), DX = T.forwardRef(
  (t, e) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": s,
      onEscapeKeyDown: o,
      onPointerDownOutside: i,
      ...a
    } = t, c = XP(Xm, n), l = qP(n), { onClose: d } = c;
    return T.useEffect(() => (document.addEventListener(jD, d), () => document.removeEventListener(jD, d)), [d]), T.useEffect(() => {
      if (c.trigger) {
        const u = (f) => {
          const p = f.target;
          p != null && p.contains(c.trigger) && d();
        };
        return window.addEventListener("scroll", u, { capture: !0 }), () => window.removeEventListener("scroll", u, { capture: !0 });
      }
    }, [c.trigger, d]), /* @__PURE__ */ h.jsx(
      ng,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: i,
        onFocusOutside: (u) => u.preventDefault(),
        onDismiss: d,
        children: /* @__PURE__ */ h.jsxs(
          KP,
          {
            "data-state": c.stateAttribute,
            ...l,
            ...a,
            ref: e,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ h.jsx(s1e, { children: r }),
              /* @__PURE__ */ h.jsx(n1e, { scope: n, isInside: !0, children: /* @__PURE__ */ h.jsx(Txe, { id: c.contentId, role: "tooltip", children: s || r }) })
            ]
          }
        )
      }
    );
  }
);
OX.displayName = Xm;
var NX = "TooltipArrow", o1e = T.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, s = qP(n);
    return r1e(
      NX,
      n
    ).isInside ? null : /* @__PURE__ */ h.jsx(GP, { ...s, ...r, ref: e });
  }
);
o1e.displayName = NX;
function i1e(t, e) {
  const n = Math.abs(e.top - t.y), r = Math.abs(e.bottom - t.y), s = Math.abs(e.right - t.x), o = Math.abs(e.left - t.x);
  switch (Math.min(n, r, s, o)) {
    case o:
      return "left";
    case s:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function a1e(t, e, n = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push(
        { x: t.x - n, y: t.y + n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x + n, y: t.y - n }
      );
      break;
    case "left":
      r.push(
        { x: t.x + n, y: t.y - n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "right":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x - n, y: t.y + n }
      );
      break;
  }
  return r;
}
function c1e(t) {
  const { top: e, right: n, bottom: r, left: s } = t;
  return [
    { x: s, y: e },
    { x: n, y: e },
    { x: n, y: r },
    { x: s, y: r }
  ];
}
function l1e(t, e) {
  const { x: n, y: r } = t;
  let s = !1;
  for (let o = 0, i = e.length - 1; o < e.length; i = o++) {
    const a = e[o], c = e[i], l = a.x, d = a.y, u = c.x, f = c.y;
    d > r != f > r && n < (u - l) * (r - d) / (f - d) + l && (s = !s);
  }
  return s;
}
function d1e(t) {
  const e = t.slice();
  return e.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), u1e(e);
}
function u1e(t) {
  if (t.length <= 1) return t.slice();
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    for (; e.length >= 2; ) {
      const o = e[e.length - 1], i = e[e.length - 2];
      if ((o.x - i.x) * (s.y - i.y) >= (o.y - i.y) * (s.x - i.x)) e.pop();
      else break;
    }
    e.push(s);
  }
  e.pop();
  const n = [];
  for (let r = t.length - 1; r >= 0; r--) {
    const s = t[r];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], i = n[n.length - 2];
      if ((o.x - i.x) * (s.y - i.y) >= (o.y - i.y) * (s.x - i.x)) n.pop();
      else break;
    }
    n.push(s);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
var f1e = kX, h1e = AX, p1e = MX, jX = OX;
const RX = f1e, $D = h1e, LD = p1e, Z_ = T.forwardRef(({ className: t, sideOffset: e = 4, ...n }, r) => /* @__PURE__ */ h.jsx(
  jX,
  {
    ref: r,
    sideOffset: e,
    className: Oe(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      t
    ),
    ...n
  }
));
Z_.displayName = jX.displayName;
var Xy = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, bp = typeof window > "u" || "Deno" in globalThis;
function Qo() {
}
function g1e(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function FD(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function $X(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function vf(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Wa(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function qz(t, e) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: s,
    predicate: o,
    queryKey: i,
    stale: a
  } = t;
  if (i) {
    if (r) {
      if (e.queryHash !== aL(i, e.options))
        return !1;
    } else if (!Xx(e.queryKey, i))
      return !1;
  }
  if (n !== "all") {
    const c = e.isActive();
    if (n === "active" && !c || n === "inactive" && c)
      return !1;
  }
  return !(typeof a == "boolean" && e.isStale() !== a || s && s !== e.state.fetchStatus || o && !o(e));
}
function Xz(t, e) {
  const { exact: n, status: r, predicate: s, mutationKey: o } = t;
  if (o) {
    if (!e.options.mutationKey)
      return !1;
    if (n) {
      if (xp(e.options.mutationKey) !== xp(o))
        return !1;
    } else if (!Xx(e.options.mutationKey, o))
      return !1;
  }
  return !(r && e.state.status !== r || s && !s(e));
}
function aL(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || xp)(t);
}
function xp(t) {
  return JSON.stringify(
    t,
    (e, n) => zD(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n
  );
}
function Xx(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every((n) => Xx(t[n], e[n])) : !1;
}
function BD(t, e) {
  if (t === e)
    return t;
  const n = Zz(t) && Zz(e);
  if (n || zD(t) && zD(e)) {
    const r = n ? t : Object.keys(t), s = r.length, o = n ? e : Object.keys(e), i = o.length, a = n ? [] : {}, c = new Set(r);
    let l = 0;
    for (let d = 0; d < i; d++) {
      const u = n ? d : o[d];
      (!n && c.has(u) || n) && t[u] === void 0 && e[u] === void 0 ? (a[u] = void 0, l++) : (a[u] = BD(t[u], e[u]), a[u] === t[u] && t[u] !== void 0 && l++);
    }
    return s === i && l === s ? t : a;
  }
  return e;
}
function Q_(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (const n in t)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function Zz(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function zD(t) {
  if (!Qz(t))
    return !1;
  const e = t.constructor;
  if (e === void 0)
    return !0;
  const n = e.prototype;
  return !(!Qz(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function Qz(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function m1e(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function UD(t, e, n) {
  if (typeof n.structuralSharing == "function")
    return n.structuralSharing(t, e);
  if (n.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return BD(t, e);
      } catch (r) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${n.queryHash}]: ${r}`
        ), r;
      }
    return BD(t, e);
  }
  return e;
}
function y1e(t, e, n = 0) {
  const r = [...t, e];
  return n && r.length > n ? r.slice(1) : r;
}
function v1e(t, e, n = 0) {
  const r = [e, ...t];
  return n && r.length > n ? r.slice(0, -1) : r;
}
var J_ = Symbol();
function LX(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === J_ && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === J_ ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
function FX(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
var qh, Qu, Rm, tq, b1e = (tq = class extends Xy {
  constructor() {
    super();
    ft(this, qh);
    ft(this, Qu);
    ft(this, Rm);
    He(this, Rm, (n) => {
      if (!bp && window.addEventListener) {
        const r = () => n();
        return window.addEventListener("visibilitychange", r, !1), () => {
          window.removeEventListener("visibilitychange", r);
        };
      }
    });
  }
  onSubscribe() {
    J(this, Qu) || this.setEventListener(J(this, Rm));
  }
  onUnsubscribe() {
    var n;
    this.hasListeners() || ((n = J(this, Qu)) == null || n.call(this), He(this, Qu, void 0));
  }
  setEventListener(n) {
    var r;
    He(this, Rm, n), (r = J(this, Qu)) == null || r.call(this), He(this, Qu, n((s) => {
      typeof s == "boolean" ? this.setFocused(s) : this.onFocus();
    }));
  }
  setFocused(n) {
    J(this, qh) !== n && (He(this, qh, n), this.onFocus());
  }
  onFocus() {
    const n = this.isFocused();
    this.listeners.forEach((r) => {
      r(n);
    });
  }
  isFocused() {
    var n;
    return typeof J(this, qh) == "boolean" ? J(this, qh) : ((n = globalThis.document) == null ? void 0 : n.visibilityState) !== "hidden";
  }
}, qh = new WeakMap(), Qu = new WeakMap(), Rm = new WeakMap(), tq), cL = new b1e(), $m, Ju, Lm, nq, x1e = (nq = class extends Xy {
  constructor() {
    super();
    ft(this, $m, !0);
    ft(this, Ju);
    ft(this, Lm);
    He(this, Lm, (e) => {
      if (!bp && window.addEventListener) {
        const n = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", n), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    J(this, Ju) || this.setEventListener(J(this, Lm));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = J(this, Ju)) == null || e.call(this), He(this, Ju, void 0));
  }
  setEventListener(e) {
    var n;
    He(this, Lm, e), (n = J(this, Ju)) == null || n.call(this), He(this, Ju, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    J(this, $m) !== e && (He(this, $m, e), this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return J(this, $m);
  }
}, $m = new WeakMap(), Ju = new WeakMap(), Lm = new WeakMap(), nq), eE = new x1e();
function HD() {
  let t, e;
  const n = new Promise((s, o) => {
    t = s, e = o;
  });
  n.status = "pending", n.catch(() => {
  });
  function r(s) {
    Object.assign(n, s), delete n.resolve, delete n.reject;
  }
  return n.resolve = (s) => {
    r({
      status: "fulfilled",
      value: s
    }), t(s);
  }, n.reject = (s) => {
    r({
      status: "rejected",
      reason: s
    }), e(s);
  }, n;
}
function w1e(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function BX(t) {
  return (t ?? "online") === "online" ? eE.isOnline() : !0;
}
var zX = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
};
function UA(t) {
  return t instanceof zX;
}
function UX(t) {
  let e = !1, n = 0, r = !1, s;
  const o = HD(), i = (y) => {
    var m;
    r || (f(new zX(y)), (m = t.abort) == null || m.call(t));
  }, a = () => {
    e = !0;
  }, c = () => {
    e = !1;
  }, l = () => cL.isFocused() && (t.networkMode === "always" || eE.isOnline()) && t.canRun(), d = () => BX(t.networkMode) && t.canRun(), u = (y) => {
    var m;
    r || (r = !0, (m = t.onSuccess) == null || m.call(t, y), s == null || s(), o.resolve(y));
  }, f = (y) => {
    var m;
    r || (r = !0, (m = t.onError) == null || m.call(t, y), s == null || s(), o.reject(y));
  }, p = () => new Promise((y) => {
    var m;
    s = (v) => {
      (r || l()) && y(v);
    }, (m = t.onPause) == null || m.call(t);
  }).then(() => {
    var y;
    s = void 0, r || (y = t.onContinue) == null || y.call(t);
  }), g = () => {
    if (r)
      return;
    let y;
    const m = n === 0 ? t.initialPromise : void 0;
    try {
      y = m ?? t.fn();
    } catch (v) {
      y = Promise.reject(v);
    }
    Promise.resolve(y).then(u).catch((v) => {
      var C;
      if (r)
        return;
      const b = t.retry ?? (bp ? 0 : 3), x = t.retryDelay ?? w1e, w = typeof x == "function" ? x(n, v) : x, S = b === !0 || typeof b == "number" && n < b || typeof b == "function" && b(n, v);
      if (e || !S) {
        f(v);
        return;
      }
      n++, (C = t.onFail) == null || C.call(t, n, v), m1e(w).then(() => l() ? void 0 : p()).then(() => {
        e ? f(v) : g();
      });
    });
  };
  return {
    promise: o,
    cancel: i,
    continue: () => (s == null || s(), o),
    cancelRetry: a,
    continueRetry: c,
    canStart: d,
    start: () => (d() ? g() : p().then(g), o)
  };
}
var S1e = (t) => setTimeout(t, 0);
function C1e() {
  let t = [], e = 0, n = (a) => {
    a();
  }, r = (a) => {
    a();
  }, s = S1e;
  const o = (a) => {
    e ? t.push(a) : s(() => {
      n(a);
    });
  }, i = () => {
    const a = t;
    t = [], a.length && s(() => {
      r(() => {
        a.forEach((c) => {
          n(c);
        });
      });
    });
  };
  return {
    batch: (a) => {
      let c;
      e++;
      try {
        c = a();
      } finally {
        e--, e || i();
      }
      return c;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (a) => (...c) => {
      o(() => {
        a(...c);
      });
    },
    schedule: o,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (a) => {
      n = a;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (a) => {
      r = a;
    },
    setScheduler: (a) => {
      s = a;
    }
  };
}
var ps = C1e(), Xh, rq, HX = (rq = class {
  constructor() {
    ft(this, Xh);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), FD(this.gcTime) && He(this, Xh, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (bp ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    J(this, Xh) && (clearTimeout(J(this, Xh)), He(this, Xh, void 0));
  }
}, Xh = new WeakMap(), rq), Fm, Zh, Va, Qh, Co, g0, Jh, Ic, kd, sq, _1e = (sq = class extends HX {
  constructor(e) {
    super();
    ft(this, Ic);
    ft(this, Fm);
    ft(this, Zh);
    ft(this, Va);
    ft(this, Qh);
    ft(this, Co);
    ft(this, g0);
    ft(this, Jh);
    He(this, Jh, !1), He(this, g0, e.defaultOptions), this.setOptions(e.options), this.observers = [], He(this, Qh, e.client), He(this, Va, J(this, Qh).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, He(this, Fm, E1e(this.options)), this.state = e.state ?? J(this, Fm), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = J(this, Co)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    this.options = { ...J(this, g0), ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && J(this, Va).remove(this);
  }
  setData(e, n) {
    const r = UD(this.state.data, e, this.options);
    return zt(this, Ic, kd).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: n == null ? void 0 : n.updatedAt,
      manual: n == null ? void 0 : n.manual
    }), r;
  }
  setState(e, n) {
    zt(this, Ic, kd).call(this, { type: "setState", state: e, setStateOptions: n });
  }
  cancel(e) {
    var r, s;
    const n = (r = J(this, Co)) == null ? void 0 : r.promise;
    return (s = J(this, Co)) == null || s.cancel(e), n ? n.then(Qo).catch(Qo) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(J(this, Fm));
  }
  isActive() {
    return this.observers.some(
      (e) => Wa(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === J_ || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => vf(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !$X(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var n;
    const e = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (n = J(this, Co)) == null || n.continue();
  }
  onOnline() {
    var n;
    const e = this.observers.find((r) => r.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (n = J(this, Co)) == null || n.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), J(this, Va).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((n) => n !== e), this.observers.length || (J(this, Co) && (J(this, Jh) ? J(this, Co).cancel({ revert: !0 }) : J(this, Co).cancelRetry()), this.scheduleGc()), J(this, Va).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || zt(this, Ic, kd).call(this, { type: "invalidate" });
  }
  fetch(e, n) {
    var l, d, u;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (n != null && n.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (J(this, Co))
        return J(this, Co).continueRetry(), J(this, Co).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const f = this.observers.find((p) => p.options.queryFn);
      f && this.setOptions(f.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), s = (f) => {
      Object.defineProperty(f, "signal", {
        enumerable: !0,
        get: () => (He(this, Jh, !0), r.signal)
      });
    }, o = () => {
      const f = LX(this.options, n), g = (() => {
        const y = {
          client: J(this, Qh),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(y), y;
      })();
      return He(this, Jh, !1), this.options.persister ? this.options.persister(
        f,
        g,
        this
      ) : f(g);
    }, a = (() => {
      const f = {
        fetchOptions: n,
        options: this.options,
        queryKey: this.queryKey,
        client: J(this, Qh),
        state: this.state,
        fetchFn: o
      };
      return s(f), f;
    })();
    (l = this.options.behavior) == null || l.onFetch(a, this), He(this, Zh, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((d = a.fetchOptions) == null ? void 0 : d.meta)) && zt(this, Ic, kd).call(this, { type: "fetch", meta: (u = a.fetchOptions) == null ? void 0 : u.meta });
    const c = (f) => {
      var p, g, y, m;
      UA(f) && f.silent || zt(this, Ic, kd).call(this, {
        type: "error",
        error: f
      }), UA(f) || ((g = (p = J(this, Va).config).onError) == null || g.call(
        p,
        f,
        this
      ), (m = (y = J(this, Va).config).onSettled) == null || m.call(
        y,
        this.state.data,
        f,
        this
      )), this.scheduleGc();
    };
    return He(this, Co, UX({
      initialPromise: n == null ? void 0 : n.initialPromise,
      fn: a.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (f) => {
        var p, g, y, m;
        if (f === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), c(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(f);
        } catch (v) {
          c(v);
          return;
        }
        (g = (p = J(this, Va).config).onSuccess) == null || g.call(p, f, this), (m = (y = J(this, Va).config).onSettled) == null || m.call(
          y,
          f,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: c,
      onFail: (f, p) => {
        zt(this, Ic, kd).call(this, { type: "failed", failureCount: f, error: p });
      },
      onPause: () => {
        zt(this, Ic, kd).call(this, { type: "pause" });
      },
      onContinue: () => {
        zt(this, Ic, kd).call(this, { type: "continue" });
      },
      retry: a.options.retry,
      retryDelay: a.options.retryDelay,
      networkMode: a.options.networkMode,
      canRun: () => !0
    })), J(this, Co).start();
  }
}, Fm = new WeakMap(), Zh = new WeakMap(), Va = new WeakMap(), Qh = new WeakMap(), Co = new WeakMap(), g0 = new WeakMap(), Jh = new WeakMap(), Ic = new WeakSet(), kd = function(e) {
  const n = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...VX(r.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        return He(this, Zh, void 0), {
          ...r,
          data: e.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const s = e.error;
        return UA(s) && s.revert && J(this, Zh) ? { ...J(this, Zh), fetchStatus: "idle" } : {
          ...r,
          error: s,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: s,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...e.state
        };
    }
  };
  this.state = n(this.state), ps.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), J(this, Va).notify({ query: this, type: "updated", action: e });
  });
}, sq);
function VX(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: BX(e.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function E1e(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, n = e !== void 0, r = n ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var Tl, oq, T1e = (oq = class extends Xy {
  constructor(e = {}) {
    super();
    ft(this, Tl);
    this.config = e, He(this, Tl, /* @__PURE__ */ new Map());
  }
  build(e, n, r) {
    const s = n.queryKey, o = n.queryHash ?? aL(s, n);
    let i = this.get(o);
    return i || (i = new _1e({
      client: e,
      queryKey: s,
      queryHash: o,
      options: e.defaultQueryOptions(n),
      state: r,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(i)), i;
  }
  add(e) {
    J(this, Tl).has(e.queryHash) || (J(this, Tl).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const n = J(this, Tl).get(e.queryHash);
    n && (e.destroy(), n === e && J(this, Tl).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    ps.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return J(this, Tl).get(e);
  }
  getAll() {
    return [...J(this, Tl).values()];
  }
  find(e) {
    const n = { exact: !0, ...e };
    return this.getAll().find(
      (r) => qz(n, r)
    );
  }
  findAll(e = {}) {
    const n = this.getAll();
    return Object.keys(e).length > 0 ? n.filter((r) => qz(e, r)) : n;
  }
  notify(e) {
    ps.batch(() => {
      this.listeners.forEach((n) => {
        n(e);
      });
    });
  }
  onFocus() {
    ps.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    ps.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, Tl = new WeakMap(), oq), Pl, Xo, ep, Il, Lu, iq, P1e = (iq = class extends HX {
  constructor(e) {
    super();
    ft(this, Il);
    ft(this, Pl);
    ft(this, Xo);
    ft(this, ep);
    this.mutationId = e.mutationId, He(this, Xo, e.mutationCache), He(this, Pl, []), this.state = e.state || WX(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    J(this, Pl).includes(e) || (J(this, Pl).push(e), this.clearGcTimeout(), J(this, Xo).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    He(this, Pl, J(this, Pl).filter((n) => n !== e)), this.scheduleGc(), J(this, Xo).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    J(this, Pl).length || (this.state.status === "pending" ? this.scheduleGc() : J(this, Xo).remove(this));
  }
  continue() {
    var e;
    return ((e = J(this, ep)) == null ? void 0 : e.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    var o, i, a, c, l, d, u, f, p, g, y, m, v, b, x, w, S, C, _, E;
    const n = () => {
      zt(this, Il, Lu).call(this, { type: "continue" });
    };
    He(this, ep, UX({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (M, N) => {
        zt(this, Il, Lu).call(this, { type: "failed", failureCount: M, error: N });
      },
      onPause: () => {
        zt(this, Il, Lu).call(this, { type: "pause" });
      },
      onContinue: n,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => J(this, Xo).canRun(this)
    }));
    const r = this.state.status === "pending", s = !J(this, ep).canStart();
    try {
      if (r)
        n();
      else {
        zt(this, Il, Lu).call(this, { type: "pending", variables: e, isPaused: s }), await ((i = (o = J(this, Xo).config).onMutate) == null ? void 0 : i.call(
          o,
          e,
          this
        ));
        const N = await ((c = (a = this.options).onMutate) == null ? void 0 : c.call(a, e));
        N !== this.state.context && zt(this, Il, Lu).call(this, {
          type: "pending",
          context: N,
          variables: e,
          isPaused: s
        });
      }
      const M = await J(this, ep).start();
      return await ((d = (l = J(this, Xo).config).onSuccess) == null ? void 0 : d.call(
        l,
        M,
        e,
        this.state.context,
        this
      )), await ((f = (u = this.options).onSuccess) == null ? void 0 : f.call(u, M, e, this.state.context)), await ((g = (p = J(this, Xo).config).onSettled) == null ? void 0 : g.call(
        p,
        M,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((m = (y = this.options).onSettled) == null ? void 0 : m.call(y, M, null, e, this.state.context)), zt(this, Il, Lu).call(this, { type: "success", data: M }), M;
    } catch (M) {
      try {
        throw await ((b = (v = J(this, Xo).config).onError) == null ? void 0 : b.call(
          v,
          M,
          e,
          this.state.context,
          this
        )), await ((w = (x = this.options).onError) == null ? void 0 : w.call(
          x,
          M,
          e,
          this.state.context
        )), await ((C = (S = J(this, Xo).config).onSettled) == null ? void 0 : C.call(
          S,
          void 0,
          M,
          this.state.variables,
          this.state.context,
          this
        )), await ((E = (_ = this.options).onSettled) == null ? void 0 : E.call(
          _,
          void 0,
          M,
          e,
          this.state.context
        )), M;
      } finally {
        zt(this, Il, Lu).call(this, { type: "error", error: M });
      }
    } finally {
      J(this, Xo).runNext(this);
    }
  }
}, Pl = new WeakMap(), Xo = new WeakMap(), ep = new WeakMap(), Il = new WeakSet(), Lu = function(e) {
  const n = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: e.error,
          failureCount: r.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = n(this.state), ps.batch(() => {
    J(this, Pl).forEach((r) => {
      r.onMutationUpdate(e);
    }), J(this, Xo).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, iq);
function WX() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var zd, kc, m0, aq, I1e = (aq = class extends Xy {
  constructor(e = {}) {
    super();
    ft(this, zd);
    ft(this, kc);
    ft(this, m0);
    this.config = e, He(this, zd, /* @__PURE__ */ new Set()), He(this, kc, /* @__PURE__ */ new Map()), He(this, m0, 0);
  }
  build(e, n, r) {
    const s = new P1e({
      mutationCache: this,
      mutationId: ++XS(this, m0)._,
      options: e.defaultMutationOptions(n),
      state: r
    });
    return this.add(s), s;
  }
  add(e) {
    J(this, zd).add(e);
    const n = t1(e);
    if (typeof n == "string") {
      const r = J(this, kc).get(n);
      r ? r.push(e) : J(this, kc).set(n, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (J(this, zd).delete(e)) {
      const n = t1(e);
      if (typeof n == "string") {
        const r = J(this, kc).get(n);
        if (r)
          if (r.length > 1) {
            const s = r.indexOf(e);
            s !== -1 && r.splice(s, 1);
          } else r[0] === e && J(this, kc).delete(n);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const n = t1(e);
    if (typeof n == "string") {
      const r = J(this, kc).get(n), s = r == null ? void 0 : r.find(
        (o) => o.state.status === "pending"
      );
      return !s || s === e;
    } else
      return !0;
  }
  runNext(e) {
    var r;
    const n = t1(e);
    if (typeof n == "string") {
      const s = (r = J(this, kc).get(n)) == null ? void 0 : r.find((o) => o !== e && o.state.isPaused);
      return (s == null ? void 0 : s.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    ps.batch(() => {
      J(this, zd).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), J(this, zd).clear(), J(this, kc).clear();
    });
  }
  getAll() {
    return Array.from(J(this, zd));
  }
  find(e) {
    const n = { exact: !0, ...e };
    return this.getAll().find(
      (r) => Xz(n, r)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((n) => Xz(e, n));
  }
  notify(e) {
    ps.batch(() => {
      this.listeners.forEach((n) => {
        n(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((n) => n.state.isPaused);
    return ps.batch(
      () => Promise.all(
        e.map((n) => n.continue().catch(Qo))
      )
    );
  }
}, zd = new WeakMap(), kc = new WeakMap(), m0 = new WeakMap(), aq);
function t1(t) {
  var e;
  return (e = t.options.scope) == null ? void 0 : e.id;
}
function Jz(t) {
  return {
    onFetch: (e, n) => {
      var d, u, f, p, g;
      const r = e.options, s = (f = (u = (d = e.fetchOptions) == null ? void 0 : d.meta) == null ? void 0 : u.fetchMore) == null ? void 0 : f.direction, o = ((p = e.state.data) == null ? void 0 : p.pages) || [], i = ((g = e.state.data) == null ? void 0 : g.pageParams) || [];
      let a = { pages: [], pageParams: [] }, c = 0;
      const l = async () => {
        let y = !1;
        const m = (x) => {
          Object.defineProperty(x, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? y = !0 : e.signal.addEventListener("abort", () => {
              y = !0;
            }), e.signal)
          });
        }, v = LX(e.options, e.fetchOptions), b = async (x, w, S) => {
          if (y)
            return Promise.reject();
          if (w == null && x.pages.length)
            return Promise.resolve(x);
          const _ = (() => {
            const O = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: w,
              direction: S ? "backward" : "forward",
              meta: e.options.meta
            };
            return m(O), O;
          })(), E = await v(_), { maxPages: M } = e.options, N = S ? v1e : y1e;
          return {
            pages: N(x.pages, E, M),
            pageParams: N(x.pageParams, w, M)
          };
        };
        if (s && o.length) {
          const x = s === "backward", w = x ? k1e : e6, S = {
            pages: o,
            pageParams: i
          }, C = w(r, S);
          a = await b(S, C, x);
        } else {
          const x = t ?? o.length;
          do {
            const w = c === 0 ? i[0] ?? r.initialPageParam : e6(r, a);
            if (c > 0 && w == null)
              break;
            a = await b(a, w), c++;
          } while (c < x);
        }
        return a;
      };
      e.options.persister ? e.fetchFn = () => {
        var y, m;
        return (m = (y = e.options).persister) == null ? void 0 : m.call(
          y,
          l,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          n
        );
      } : e.fetchFn = l;
    }
  };
}
function e6(t, { pages: e, pageParams: n }) {
  const r = e.length - 1;
  return e.length > 0 ? t.getNextPageParam(
    e[r],
    e,
    n[r],
    n
  ) : void 0;
}
function k1e(t, { pages: e, pageParams: n }) {
  var r;
  return e.length > 0 ? (r = t.getPreviousPageParam) == null ? void 0 : r.call(t, e[0], e, n[0], n) : void 0;
}
var Cr, ef, tf, Bm, zm, nf, Um, Hm, cq, A1e = (cq = class {
  constructor(t = {}) {
    ft(this, Cr);
    ft(this, ef);
    ft(this, tf);
    ft(this, Bm);
    ft(this, zm);
    ft(this, nf);
    ft(this, Um);
    ft(this, Hm);
    He(this, Cr, t.queryCache || new T1e()), He(this, ef, t.mutationCache || new I1e()), He(this, tf, t.defaultOptions || {}), He(this, Bm, /* @__PURE__ */ new Map()), He(this, zm, /* @__PURE__ */ new Map()), He(this, nf, 0);
  }
  mount() {
    XS(this, nf)._++, J(this, nf) === 1 && (He(this, Um, cL.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), J(this, Cr).onFocus());
    })), He(this, Hm, eE.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), J(this, Cr).onOnline());
    })));
  }
  unmount() {
    var t, e;
    XS(this, nf)._--, J(this, nf) === 0 && ((t = J(this, Um)) == null || t.call(this), He(this, Um, void 0), (e = J(this, Hm)) == null || e.call(this), He(this, Hm, void 0));
  }
  isFetching(t) {
    return J(this, Cr).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return J(this, ef).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    var n;
    const e = this.defaultQueryOptions({ queryKey: t });
    return (n = J(this, Cr).get(e.queryHash)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), n = J(this, Cr).build(this, e), r = n.state.data;
    return r === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && n.isStaleByTime(vf(e.staleTime, n)) && this.prefetchQuery(e), Promise.resolve(r));
  }
  getQueriesData(t) {
    return J(this, Cr).findAll(t).map(({ queryKey: e, state: n }) => {
      const r = n.data;
      return [e, r];
    });
  }
  setQueryData(t, e, n) {
    const r = this.defaultQueryOptions({ queryKey: t }), s = J(this, Cr).get(
      r.queryHash
    ), o = s == null ? void 0 : s.state.data, i = g1e(e, o);
    if (i !== void 0)
      return J(this, Cr).build(this, r).setData(i, { ...n, manual: !0 });
  }
  setQueriesData(t, e, n) {
    return ps.batch(
      () => J(this, Cr).findAll(t).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, e, n)
      ])
    );
  }
  getQueryState(t) {
    var n;
    const e = this.defaultQueryOptions({ queryKey: t });
    return (n = J(this, Cr).get(
      e.queryHash
    )) == null ? void 0 : n.state;
  }
  removeQueries(t) {
    const e = J(this, Cr);
    ps.batch(() => {
      e.findAll(t).forEach((n) => {
        e.remove(n);
      });
    });
  }
  resetQueries(t, e) {
    const n = J(this, Cr);
    return ps.batch(() => (n.findAll(t).forEach((r) => {
      r.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const n = { revert: !0, ...e }, r = ps.batch(
      () => J(this, Cr).findAll(t).map((s) => s.cancel(n))
    );
    return Promise.all(r).then(Qo).catch(Qo);
  }
  invalidateQueries(t, e = {}) {
    return ps.batch(() => (J(this, Cr).findAll(t).forEach((n) => {
      n.invalidate();
    }), (t == null ? void 0 : t.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: (t == null ? void 0 : t.refetchType) ?? (t == null ? void 0 : t.type) ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const n = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, r = ps.batch(
      () => J(this, Cr).findAll(t).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let o = s.fetch(void 0, n);
        return n.throwOnError || (o = o.catch(Qo)), s.state.fetchStatus === "paused" ? Promise.resolve() : o;
      })
    );
    return Promise.all(r).then(Qo);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const n = J(this, Cr).build(this, e);
    return n.isStaleByTime(
      vf(e.staleTime, n)
    ) ? n.fetch(e) : Promise.resolve(n.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(Qo).catch(Qo);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Jz(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(Qo).catch(Qo);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Jz(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return eE.isOnline() ? J(this, ef).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return J(this, Cr);
  }
  getMutationCache() {
    return J(this, ef);
  }
  getDefaultOptions() {
    return J(this, tf);
  }
  setDefaultOptions(t) {
    He(this, tf, t);
  }
  setQueryDefaults(t, e) {
    J(this, Bm).set(xp(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...J(this, Bm).values()], n = {};
    return e.forEach((r) => {
      Xx(t, r.queryKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  setMutationDefaults(t, e) {
    J(this, zm).set(xp(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...J(this, zm).values()], n = {};
    return e.forEach((r) => {
      Xx(t, r.mutationKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...J(this, tf).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = aL(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === J_ && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...J(this, tf).mutations,
      ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    J(this, Cr).clear(), J(this, ef).clear();
  }
}, Cr = new WeakMap(), ef = new WeakMap(), tf = new WeakMap(), Bm = new WeakMap(), zm = new WeakMap(), nf = new WeakMap(), Um = new WeakMap(), Hm = new WeakMap(), cq), Ci, nn, y0, Zo, tp, Vm, rf, sf, v0, Wm, Km, np, rp, of, Gm, Pn, Cb, VD, WD, KD, GD, YD, qD, XD, KX, lq, M1e = (lq = class extends Xy {
  constructor(e, n) {
    super();
    ft(this, Pn);
    ft(this, Ci);
    ft(this, nn);
    ft(this, y0);
    ft(this, Zo);
    ft(this, tp);
    ft(this, Vm);
    ft(this, rf);
    ft(this, sf);
    ft(this, v0);
    ft(this, Wm);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    ft(this, Km);
    ft(this, np);
    ft(this, rp);
    ft(this, of);
    ft(this, Gm, /* @__PURE__ */ new Set());
    this.options = n, He(this, Ci, e), He(this, sf, null), He(this, rf, HD()), this.options.experimental_prefetchInRender || J(this, rf).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(n);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (J(this, nn).addObserver(this), t6(J(this, nn), this.options) ? zt(this, Pn, Cb).call(this) : this.updateResult(), zt(this, Pn, GD).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return ZD(
      J(this, nn),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return ZD(
      J(this, nn),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), zt(this, Pn, YD).call(this), zt(this, Pn, qD).call(this), J(this, nn).removeObserver(this);
  }
  setOptions(e) {
    const n = this.options, r = J(this, nn);
    if (this.options = J(this, Ci).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Wa(this.options.enabled, J(this, nn)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    zt(this, Pn, XD).call(this), J(this, nn).setOptions(this.options), n._defaulted && !Q_(this.options, n) && J(this, Ci).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: J(this, nn),
      observer: this
    });
    const s = this.hasListeners();
    s && n6(
      J(this, nn),
      r,
      this.options,
      n
    ) && zt(this, Pn, Cb).call(this), this.updateResult(), s && (J(this, nn) !== r || Wa(this.options.enabled, J(this, nn)) !== Wa(n.enabled, J(this, nn)) || vf(this.options.staleTime, J(this, nn)) !== vf(n.staleTime, J(this, nn))) && zt(this, Pn, VD).call(this);
    const o = zt(this, Pn, WD).call(this);
    s && (J(this, nn) !== r || Wa(this.options.enabled, J(this, nn)) !== Wa(n.enabled, J(this, nn)) || o !== J(this, of)) && zt(this, Pn, KD).call(this, o);
  }
  getOptimisticResult(e) {
    const n = J(this, Ci).getQueryCache().build(J(this, Ci), e), r = this.createResult(n, e);
    return D1e(this, r) && (He(this, Zo, r), He(this, Vm, this.options), He(this, tp, J(this, nn).state)), r;
  }
  getCurrentResult() {
    return J(this, Zo);
  }
  trackResult(e, n) {
    return new Proxy(e, {
      get: (r, s) => (this.trackProp(s), n == null || n(s), Reflect.get(r, s))
    });
  }
  trackProp(e) {
    J(this, Gm).add(e);
  }
  getCurrentQuery() {
    return J(this, nn);
  }
  refetch({ ...e } = {}) {
    return this.fetch({
      ...e
    });
  }
  fetchOptimistic(e) {
    const n = J(this, Ci).defaultQueryOptions(e), r = J(this, Ci).getQueryCache().build(J(this, Ci), n);
    return r.fetch().then(() => this.createResult(r, n));
  }
  fetch(e) {
    return zt(this, Pn, Cb).call(this, {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), J(this, Zo)));
  }
  createResult(e, n) {
    var M;
    const r = J(this, nn), s = this.options, o = J(this, Zo), i = J(this, tp), a = J(this, Vm), l = e !== r ? e.state : J(this, y0), { state: d } = e;
    let u = { ...d }, f = !1, p;
    if (n._optimisticResults) {
      const N = this.hasListeners(), O = !N && t6(e, n), D = N && n6(e, r, n, s);
      (O || D) && (u = {
        ...u,
        ...VX(d.data, e.options)
      }), n._optimisticResults === "isRestoring" && (u.fetchStatus = "idle");
    }
    let { error: g, errorUpdatedAt: y, status: m } = u;
    p = u.data;
    let v = !1;
    if (n.placeholderData !== void 0 && p === void 0 && m === "pending") {
      let N;
      o != null && o.isPlaceholderData && n.placeholderData === (a == null ? void 0 : a.placeholderData) ? (N = o.data, v = !0) : N = typeof n.placeholderData == "function" ? n.placeholderData(
        (M = J(this, Km)) == null ? void 0 : M.state.data,
        J(this, Km)
      ) : n.placeholderData, N !== void 0 && (m = "success", p = UD(
        o == null ? void 0 : o.data,
        N,
        n
      ), f = !0);
    }
    if (n.select && p !== void 0 && !v)
      if (o && p === (i == null ? void 0 : i.data) && n.select === J(this, v0))
        p = J(this, Wm);
      else
        try {
          He(this, v0, n.select), p = n.select(p), p = UD(o == null ? void 0 : o.data, p, n), He(this, Wm, p), He(this, sf, null);
        } catch (N) {
          He(this, sf, N);
        }
    J(this, sf) && (g = J(this, sf), p = J(this, Wm), y = Date.now(), m = "error");
    const b = u.fetchStatus === "fetching", x = m === "pending", w = m === "error", S = x && b, C = p !== void 0, E = {
      status: m,
      fetchStatus: u.fetchStatus,
      isPending: x,
      isSuccess: m === "success",
      isError: w,
      isInitialLoading: S,
      isLoading: S,
      data: p,
      dataUpdatedAt: u.dataUpdatedAt,
      error: g,
      errorUpdatedAt: y,
      failureCount: u.fetchFailureCount,
      failureReason: u.fetchFailureReason,
      errorUpdateCount: u.errorUpdateCount,
      isFetched: u.dataUpdateCount > 0 || u.errorUpdateCount > 0,
      isFetchedAfterMount: u.dataUpdateCount > l.dataUpdateCount || u.errorUpdateCount > l.errorUpdateCount,
      isFetching: b,
      isRefetching: b && !x,
      isLoadingError: w && !C,
      isPaused: u.fetchStatus === "paused",
      isPlaceholderData: f,
      isRefetchError: w && C,
      isStale: lL(e, n),
      refetch: this.refetch,
      promise: J(this, rf),
      isEnabled: Wa(n.enabled, e) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const N = (k) => {
        E.status === "error" ? k.reject(E.error) : E.data !== void 0 && k.resolve(E.data);
      }, O = () => {
        const k = He(this, rf, E.promise = HD());
        N(k);
      }, D = J(this, rf);
      switch (D.status) {
        case "pending":
          e.queryHash === r.queryHash && N(D);
          break;
        case "fulfilled":
          (E.status === "error" || E.data !== D.value) && O();
          break;
        case "rejected":
          (E.status !== "error" || E.error !== D.reason) && O();
          break;
      }
    }
    return E;
  }
  updateResult() {
    const e = J(this, Zo), n = this.createResult(J(this, nn), this.options);
    if (He(this, tp, J(this, nn).state), He(this, Vm, this.options), J(this, tp).data !== void 0 && He(this, Km, J(this, nn)), Q_(n, e))
      return;
    He(this, Zo, n);
    const r = () => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: s } = this.options, o = typeof s == "function" ? s() : s;
      if (o === "all" || !o && !J(this, Gm).size)
        return !0;
      const i = new Set(
        o ?? J(this, Gm)
      );
      return this.options.throwOnError && i.add("error"), Object.keys(J(this, Zo)).some((a) => {
        const c = a;
        return J(this, Zo)[c] !== e[c] && i.has(c);
      });
    };
    zt(this, Pn, KX).call(this, { listeners: r() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && zt(this, Pn, GD).call(this);
  }
}, Ci = new WeakMap(), nn = new WeakMap(), y0 = new WeakMap(), Zo = new WeakMap(), tp = new WeakMap(), Vm = new WeakMap(), rf = new WeakMap(), sf = new WeakMap(), v0 = new WeakMap(), Wm = new WeakMap(), Km = new WeakMap(), np = new WeakMap(), rp = new WeakMap(), of = new WeakMap(), Gm = new WeakMap(), Pn = new WeakSet(), Cb = function(e) {
  zt(this, Pn, XD).call(this);
  let n = J(this, nn).fetch(
    this.options,
    e
  );
  return e != null && e.throwOnError || (n = n.catch(Qo)), n;
}, VD = function() {
  zt(this, Pn, YD).call(this);
  const e = vf(
    this.options.staleTime,
    J(this, nn)
  );
  if (bp || J(this, Zo).isStale || !FD(e))
    return;
  const r = $X(J(this, Zo).dataUpdatedAt, e) + 1;
  He(this, np, setTimeout(() => {
    J(this, Zo).isStale || this.updateResult();
  }, r));
}, WD = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(J(this, nn)) : this.options.refetchInterval) ?? !1;
}, KD = function(e) {
  zt(this, Pn, qD).call(this), He(this, of, e), !(bp || Wa(this.options.enabled, J(this, nn)) === !1 || !FD(J(this, of)) || J(this, of) === 0) && He(this, rp, setInterval(() => {
    (this.options.refetchIntervalInBackground || cL.isFocused()) && zt(this, Pn, Cb).call(this);
  }, J(this, of)));
}, GD = function() {
  zt(this, Pn, VD).call(this), zt(this, Pn, KD).call(this, zt(this, Pn, WD).call(this));
}, YD = function() {
  J(this, np) && (clearTimeout(J(this, np)), He(this, np, void 0));
}, qD = function() {
  J(this, rp) && (clearInterval(J(this, rp)), He(this, rp, void 0));
}, XD = function() {
  const e = J(this, Ci).getQueryCache().build(J(this, Ci), this.options);
  if (e === J(this, nn))
    return;
  const n = J(this, nn);
  He(this, nn, e), He(this, y0, e.state), this.hasListeners() && (n == null || n.removeObserver(this), e.addObserver(this));
}, KX = function(e) {
  ps.batch(() => {
    e.listeners && this.listeners.forEach((n) => {
      n(J(this, Zo));
    }), J(this, Ci).getQueryCache().notify({
      query: J(this, nn),
      type: "observerResultsUpdated"
    });
  });
}, lq);
function O1e(t, e) {
  return Wa(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1);
}
function t6(t, e) {
  return O1e(t, e) || t.state.data !== void 0 && ZD(t, e, e.refetchOnMount);
}
function ZD(t, e, n) {
  if (Wa(e.enabled, t) !== !1 && vf(e.staleTime, t) !== "static") {
    const r = typeof n == "function" ? n(t) : n;
    return r === "always" || r !== !1 && lL(t, e);
  }
  return !1;
}
function n6(t, e, n, r) {
  return (t !== e || Wa(r.enabled, t) === !1) && (!n.suspense || t.state.status !== "error") && lL(t, n);
}
function lL(t, e) {
  return Wa(e.enabled, t) !== !1 && t.isStaleByTime(vf(e.staleTime, t));
}
function D1e(t, e) {
  return !Q_(t.getCurrentResult(), e);
}
var af, cf, _i, Ud, Jd, NC, QD, dq, N1e = (dq = class extends Xy {
  constructor(n, r) {
    super();
    ft(this, Jd);
    ft(this, af);
    ft(this, cf);
    ft(this, _i);
    ft(this, Ud);
    He(this, af, n), this.setOptions(r), this.bindMethods(), zt(this, Jd, NC).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(n) {
    var s;
    const r = this.options;
    this.options = J(this, af).defaultMutationOptions(n), Q_(this.options, r) || J(this, af).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: J(this, _i),
      observer: this
    }), r != null && r.mutationKey && this.options.mutationKey && xp(r.mutationKey) !== xp(this.options.mutationKey) ? this.reset() : ((s = J(this, _i)) == null ? void 0 : s.state.status) === "pending" && J(this, _i).setOptions(this.options);
  }
  onUnsubscribe() {
    var n;
    this.hasListeners() || (n = J(this, _i)) == null || n.removeObserver(this);
  }
  onMutationUpdate(n) {
    zt(this, Jd, NC).call(this), zt(this, Jd, QD).call(this, n);
  }
  getCurrentResult() {
    return J(this, cf);
  }
  reset() {
    var n;
    (n = J(this, _i)) == null || n.removeObserver(this), He(this, _i, void 0), zt(this, Jd, NC).call(this), zt(this, Jd, QD).call(this);
  }
  mutate(n, r) {
    var s;
    return He(this, Ud, r), (s = J(this, _i)) == null || s.removeObserver(this), He(this, _i, J(this, af).getMutationCache().build(J(this, af), this.options)), J(this, _i).addObserver(this), J(this, _i).execute(n);
  }
}, af = new WeakMap(), cf = new WeakMap(), _i = new WeakMap(), Ud = new WeakMap(), Jd = new WeakSet(), NC = function() {
  var r;
  const n = ((r = J(this, _i)) == null ? void 0 : r.state) ?? WX();
  He(this, cf, {
    ...n,
    isPending: n.status === "pending",
    isSuccess: n.status === "success",
    isError: n.status === "error",
    isIdle: n.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, QD = function(n) {
  ps.batch(() => {
    var r, s, o, i, a, c, l, d;
    if (J(this, Ud) && this.hasListeners()) {
      const u = J(this, cf).variables, f = J(this, cf).context;
      (n == null ? void 0 : n.type) === "success" ? ((s = (r = J(this, Ud)).onSuccess) == null || s.call(r, n.data, u, f), (i = (o = J(this, Ud)).onSettled) == null || i.call(o, n.data, null, u, f)) : (n == null ? void 0 : n.type) === "error" && ((c = (a = J(this, Ud)).onError) == null || c.call(a, n.error, u, f), (d = (l = J(this, Ud)).onSettled) == null || d.call(
        l,
        void 0,
        n.error,
        u,
        f
      ));
    }
    this.listeners.forEach((u) => {
      u(J(this, cf));
    });
  });
}, dq), GX = T.createContext(
  void 0
), dL = (t) => {
  const e = T.useContext(GX);
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, j1e = ({
  client: t,
  children: e
}) => (T.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ h.jsx(GX.Provider, { value: t, children: e })), YX = T.createContext(!1), R1e = () => T.useContext(YX);
YX.Provider;
function $1e() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var L1e = T.createContext($1e()), F1e = () => T.useContext(L1e), B1e = (t, e) => {
  (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1));
}, z1e = (t) => {
  T.useEffect(() => {
    t.clearReset();
  }, [t]);
}, U1e = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: n,
  query: r,
  suspense: s
}) => t.isError && !e.isReset() && !t.isFetching && r && (s && t.data === void 0 || FX(n, [t.error, r])), H1e = (t) => {
  if (t.suspense) {
    const e = (r) => r === "static" ? r : Math.max(r ?? 1e3, 1e3), n = t.staleTime;
    t.staleTime = typeof n == "function" ? (...r) => e(n(...r)) : e(n), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3));
  }
}, V1e = (t, e) => t.isLoading && t.isFetching && !e, W1e = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending, r6 = (t, e, n) => e.fetchOptimistic(t).catch(() => {
  n.clearReset();
});
function K1e(t, e, n) {
  var u, f, p, g, y;
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = R1e(), s = F1e(), o = dL(), i = o.defaultQueryOptions(t);
  (f = (u = o.getDefaultOptions().queries) == null ? void 0 : u._experimental_beforeQuery) == null || f.call(
    u,
    i
  ), process.env.NODE_ENV !== "production" && (i.queryFn || console.error(
    `[${i.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), i._optimisticResults = r ? "isRestoring" : "optimistic", H1e(i), B1e(i, s), z1e(s);
  const a = !o.getQueryCache().get(i.queryHash), [c] = T.useState(
    () => new e(
      o,
      i
    )
  ), l = c.getOptimisticResult(i), d = !r && t.subscribed !== !1;
  if (T.useSyncExternalStore(
    T.useCallback(
      (m) => {
        const v = d ? c.subscribe(ps.batchCalls(m)) : Qo;
        return c.updateResult(), v;
      },
      [c, d]
    ),
    () => c.getCurrentResult(),
    () => c.getCurrentResult()
  ), T.useEffect(() => {
    c.setOptions(i);
  }, [i, c]), W1e(i, l))
    throw r6(i, c, s);
  if (U1e({
    result: l,
    errorResetBoundary: s,
    throwOnError: i.throwOnError,
    query: o.getQueryCache().get(i.queryHash),
    suspense: i.suspense
  }))
    throw l.error;
  if ((g = (p = o.getDefaultOptions().queries) == null ? void 0 : p._experimental_afterQuery) == null || g.call(
    p,
    i,
    l
  ), i.experimental_prefetchInRender && !bp && V1e(l, r)) {
    const m = a ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      r6(i, c, s)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (y = o.getQueryCache().get(i.queryHash)) == null ? void 0 : y.promise
    );
    m == null || m.catch(Qo).finally(() => {
      c.updateResult();
    });
  }
  return i.notifyOnChangeProps ? l : c.trackResult(l);
}
function G1e(t, e) {
  return K1e(t, M1e);
}
function s6(t, e) {
  const n = dL(), [r] = T.useState(
    () => new N1e(
      n,
      t
    )
  );
  T.useEffect(() => {
    r.setOptions(t);
  }, [r, t]);
  const s = T.useSyncExternalStore(
    T.useCallback(
      (i) => r.subscribe(ps.batchCalls(i)),
      [r]
    ),
    () => r.getCurrentResult(),
    () => r.getCurrentResult()
  ), o = T.useCallback(
    (i, a) => {
      r.mutate(i, a).catch(Qo);
    },
    [r]
  );
  if (s.error && FX(r.options.throwOnError, [s.error]))
    throw s.error;
  return { ...s, mutate: o, mutateAsync: s.mutate };
}
function Y1e({ children: t, ...e }) {
  return /* @__PURE__ */ h.jsx(
    Kwe,
    {
      attribute: "class",
      defaultTheme: "dark",
      enableSystem: !1,
      disableTransitionOnChange: !0,
      storageKey: "blueprint-theme",
      ...e,
      children: t
    }
  );
}
const HA = 768;
function q1e() {
  const [t, e] = T.useState(void 0);
  return T.useEffect(() => {
    const n = window.matchMedia(`(max-width: ${HA - 1}px)`), r = () => {
      e(window.innerWidth < HA);
    };
    return n.addEventListener("change", r), e(window.innerWidth < HA), () => n.removeEventListener("change", r);
  }, []), !!t;
}
const JD = Hy(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), _t = T.forwardRef(
  ({ className: t, variant: e, size: n, asChild: r = !1, ...s }, o) => {
    const i = r ? zy : "button";
    return /* @__PURE__ */ h.jsx(i, { className: Oe(JD({ variant: e, size: n, className: t })), ref: o, ...s });
  }
);
_t.displayName = "Button";
const pa = T.forwardRef(
  ({ className: t, type: e, ...n }, r) => /* @__PURE__ */ h.jsx(
    "input",
    {
      type: e,
      className: Oe(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        t
      ),
      ref: r,
      ...n
    }
  )
);
pa.displayName = "Input";
var X1e = "Separator", o6 = "horizontal", Z1e = ["horizontal", "vertical"], qX = T.forwardRef((t, e) => {
  const { decorative: n, orientation: r = o6, ...s } = t, o = Q1e(r) ? r : o6, a = n ? { role: "none" } : { "aria-orientation": o === "vertical" ? o : void 0, role: "separator" };
  return /* @__PURE__ */ h.jsx(
    Re.div,
    {
      "data-orientation": o,
      ...a,
      ...s,
      ref: e
    }
  );
});
qX.displayName = X1e;
function Q1e(t) {
  return Z1e.includes(t);
}
var uL = qX;
const ix = T.forwardRef(({ className: t, orientation: e = "horizontal", decorative: n = !0, ...r }, s) => /* @__PURE__ */ h.jsx(
  uL,
  {
    ref: s,
    decorative: n,
    orientation: e,
    className: Oe("shrink-0 bg-border", e === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", t),
    ...r
  }
));
ix.displayName = uL.displayName;
var VA = "focusScope.autoFocusOnMount", WA = "focusScope.autoFocusOnUnmount", i6 = { bubbles: !1, cancelable: !0 }, J1e = "FocusScope", k0 = T.forwardRef((t, e) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: s,
    onUnmountAutoFocus: o,
    ...i
  } = t, [a, c] = T.useState(null), l = pr(s), d = pr(o), u = T.useRef(null), f = vt(e, (y) => c(y)), p = T.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  T.useEffect(() => {
    if (r) {
      let y = function(x) {
        if (p.paused || !a) return;
        const w = x.target;
        a.contains(w) ? u.current = w : Fu(u.current, { select: !0 });
      }, m = function(x) {
        if (p.paused || !a) return;
        const w = x.relatedTarget;
        w !== null && (a.contains(w) || Fu(u.current, { select: !0 }));
      }, v = function(x) {
        if (document.activeElement === document.body)
          for (const S of x)
            S.removedNodes.length > 0 && Fu(a);
      };
      document.addEventListener("focusin", y), document.addEventListener("focusout", m);
      const b = new MutationObserver(v);
      return a && b.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", y), document.removeEventListener("focusout", m), b.disconnect();
      };
    }
  }, [r, a, p.paused]), T.useEffect(() => {
    if (a) {
      c6.add(p);
      const y = document.activeElement;
      if (!a.contains(y)) {
        const v = new CustomEvent(VA, i6);
        a.addEventListener(VA, l), a.dispatchEvent(v), v.defaultPrevented || (eCe(oCe(XX(a)), { select: !0 }), document.activeElement === y && Fu(a));
      }
      return () => {
        a.removeEventListener(VA, l), setTimeout(() => {
          const v = new CustomEvent(WA, i6);
          a.addEventListener(WA, d), a.dispatchEvent(v), v.defaultPrevented || Fu(y ?? document.body, { select: !0 }), a.removeEventListener(WA, d), c6.remove(p);
        }, 0);
      };
    }
  }, [a, l, d, p]);
  const g = T.useCallback(
    (y) => {
      if (!n && !r || p.paused) return;
      const m = y.key === "Tab" && !y.altKey && !y.ctrlKey && !y.metaKey, v = document.activeElement;
      if (m && v) {
        const b = y.currentTarget, [x, w] = tCe(b);
        x && w ? !y.shiftKey && v === w ? (y.preventDefault(), n && Fu(x, { select: !0 })) : y.shiftKey && v === x && (y.preventDefault(), n && Fu(w, { select: !0 })) : v === b && y.preventDefault();
      }
    },
    [n, r, p.paused]
  );
  return /* @__PURE__ */ h.jsx(Re.div, { tabIndex: -1, ...i, ref: f, onKeyDown: g });
});
k0.displayName = J1e;
function eCe(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (Fu(r, { select: e }), document.activeElement !== n) return;
}
function tCe(t) {
  const e = XX(t), n = a6(e, t), r = a6(e.reverse(), t);
  return [n, r];
}
function XX(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const s = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function a6(t, e) {
  for (const n of t)
    if (!nCe(n, { upTo: e })) return n;
}
function nCe(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function rCe(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function Fu(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && rCe(t) && e && t.select();
  }
}
var c6 = sCe();
function sCe() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), t = l6(t, e), t.unshift(e);
    },
    remove(e) {
      var n;
      t = l6(t, e), (n = t[0]) == null || n.resume();
    }
  };
}
function l6(t, e) {
  const n = [...t], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function oCe(t) {
  return t.filter((e) => e.tagName !== "A");
}
var KA = 0;
function ZP() {
  T.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", t[0] ?? d6()), document.body.insertAdjacentElement("beforeend", t[1] ?? d6()), KA++, () => {
      KA === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), KA--;
    };
  }, []);
}
function d6() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
var Ml = function() {
  return Ml = Object.assign || function(e) {
    for (var n, r = 1, s = arguments.length; r < s; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Ml.apply(this, arguments);
};
function ZX(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, r = Object.getOwnPropertySymbols(t); s < r.length; s++)
      e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[s]) && (n[r[s]] = t[r[s]]);
  return n;
}
function iCe(t, e, n) {
  if (n || arguments.length === 2) for (var r = 0, s = e.length, o; r < s; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}
var jC = "right-scroll-bar-position", RC = "width-before-scroll-bar", aCe = "with-scroll-bars-hidden", cCe = "--removed-body-scroll-bar-size";
function GA(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function lCe(t, e) {
  var n = he(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var s = n.value;
          s !== r && (n.value = r, n.callback(r, s));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var dCe = typeof window < "u" ? T.useLayoutEffect : T.useEffect, u6 = /* @__PURE__ */ new WeakMap();
function uCe(t, e) {
  var n = lCe(null, function(r) {
    return t.forEach(function(s) {
      return GA(s, r);
    });
  });
  return dCe(function() {
    var r = u6.get(n);
    if (r) {
      var s = new Set(r), o = new Set(t), i = n.current;
      s.forEach(function(a) {
        o.has(a) || GA(a, null);
      }), o.forEach(function(a) {
        s.has(a) || GA(a, i);
      });
    }
    u6.set(n, t);
  }, [t]), n;
}
function fCe(t) {
  return t;
}
function hCe(t, e) {
  e === void 0 && (e = fCe);
  var n = [], r = !1, s = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(o) {
      var i = e(o, r);
      return n.push(i), function() {
        n = n.filter(function(a) {
          return a !== i;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var i = n;
        n = [], i.forEach(o);
      }
      n = {
        push: function(a) {
          return o(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var i = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(o), i = n;
      }
      var c = function() {
        var d = i;
        i = [], d.forEach(o);
      }, l = function() {
        return Promise.resolve().then(c);
      };
      l(), n = {
        push: function(d) {
          i.push(d), l();
        },
        filter: function(d) {
          return i = i.filter(d), n;
        }
      };
    }
  };
  return s;
}
function pCe(t) {
  t === void 0 && (t = {});
  var e = hCe(null);
  return e.options = Ml({ async: !0, ssr: !1 }, t), e;
}
var QX = function(t) {
  var e = t.sideCar, n = ZX(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return T.createElement(r, Ml({}, n));
};
QX.isSideCarExport = !0;
function gCe(t, e) {
  return t.useMedium(e), QX;
}
var JX = pCe(), YA = function() {
}, QP = T.forwardRef(function(t, e) {
  var n = T.useRef(null), r = T.useState({
    onScrollCapture: YA,
    onWheelCapture: YA,
    onTouchMoveCapture: YA
  }), s = r[0], o = r[1], i = t.forwardProps, a = t.children, c = t.className, l = t.removeScrollBar, d = t.enabled, u = t.shards, f = t.sideCar, p = t.noRelative, g = t.noIsolation, y = t.inert, m = t.allowPinchZoom, v = t.as, b = v === void 0 ? "div" : v, x = t.gapMode, w = ZX(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), S = f, C = uCe([n, e]), _ = Ml(Ml({}, w), s);
  return T.createElement(
    T.Fragment,
    null,
    d && T.createElement(S, { sideCar: JX, removeScrollBar: l, shards: u, noRelative: p, noIsolation: g, inert: y, setCallbacks: o, allowPinchZoom: !!m, lockRef: n, gapMode: x }),
    i ? T.cloneElement(T.Children.only(a), Ml(Ml({}, _), { ref: C })) : T.createElement(b, Ml({}, _, { className: c, ref: C }), a)
  );
});
QP.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
QP.classNames = {
  fullWidth: RC,
  zeroRight: jC
};
var mCe = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function yCe() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = mCe();
  return e && t.setAttribute("nonce", e), t;
}
function vCe(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function bCe(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var xCe = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = yCe()) && (vCe(e, n), bCe(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, wCe = function() {
  var t = xCe();
  return function(e, n) {
    T.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, eZ = function() {
  var t = wCe(), e = function(n) {
    var r = n.styles, s = n.dynamic;
    return t(r, s), null;
  };
  return e;
}, SCe = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, qA = function(t) {
  return parseInt(t || "", 10) || 0;
}, CCe = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], s = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [qA(n), qA(r), qA(s)];
}, _Ce = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return SCe;
  var e = CCe(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, ECe = eZ(), wm = "data-scroll-locked", TCe = function(t, e, n, r) {
  var s = t.left, o = t.top, i = t.right, a = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(aCe, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(wm, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(s, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(i, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(jC, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(RC, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(jC, " .").concat(jC, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(RC, " .").concat(RC, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(wm, `] {
    `).concat(cCe, ": ").concat(a, `px;
  }
`);
}, f6 = function() {
  var t = parseInt(document.body.getAttribute(wm) || "0", 10);
  return isFinite(t) ? t : 0;
}, PCe = function() {
  T.useEffect(function() {
    return document.body.setAttribute(wm, (f6() + 1).toString()), function() {
      var t = f6() - 1;
      t <= 0 ? document.body.removeAttribute(wm) : document.body.setAttribute(wm, t.toString());
    };
  }, []);
}, ICe = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, s = r === void 0 ? "margin" : r;
  PCe();
  var o = T.useMemo(function() {
    return _Ce(s);
  }, [s]);
  return T.createElement(ECe, { styles: TCe(o, !e, s, n ? "" : "!important") });
}, eN = !1;
if (typeof window < "u")
  try {
    var n1 = Object.defineProperty({}, "passive", {
      get: function() {
        return eN = !0, !0;
      }
    });
    window.addEventListener("test", n1, n1), window.removeEventListener("test", n1, n1);
  } catch {
    eN = !1;
  }
var kg = eN ? { passive: !1 } : !1, kCe = function(t) {
  return t.tagName === "TEXTAREA";
}, tZ = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !kCe(t) && n[e] === "visible")
  );
}, ACe = function(t) {
  return tZ(t, "overflowY");
}, MCe = function(t) {
  return tZ(t, "overflowX");
}, h6 = function(t, e) {
  var n = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var s = nZ(t, r);
    if (s) {
      var o = rZ(t, r), i = o[1], a = o[2];
      if (i > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, OCe = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, DCe = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, nZ = function(t, e) {
  return t === "v" ? ACe(e) : MCe(e);
}, rZ = function(t, e) {
  return t === "v" ? OCe(e) : DCe(e);
}, NCe = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, jCe = function(t, e, n, r, s) {
  var o = NCe(t, window.getComputedStyle(e).direction), i = o * r, a = n.target, c = e.contains(a), l = !1, d = i > 0, u = 0, f = 0;
  do {
    if (!a)
      break;
    var p = rZ(t, a), g = p[0], y = p[1], m = p[2], v = y - m - o * g;
    (g || v) && nZ(t, a) && (u += v, f += g);
    var b = a.parentNode;
    a = b && b.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? b.host : b;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (e.contains(a) || e === a)
  );
  return (d && (Math.abs(u) < 1 || !s) || !d && (Math.abs(f) < 1 || !s)) && (l = !0), l;
}, r1 = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, p6 = function(t) {
  return [t.deltaX, t.deltaY];
}, g6 = function(t) {
  return t && "current" in t ? t.current : t;
}, RCe = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, $Ce = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, LCe = 0, Ag = [];
function FCe(t) {
  var e = T.useRef([]), n = T.useRef([0, 0]), r = T.useRef(), s = T.useState(LCe++)[0], o = T.useState(eZ)[0], i = T.useRef(t);
  T.useEffect(function() {
    i.current = t;
  }, [t]), T.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(s));
      var y = iCe([t.lockRef.current], (t.shards || []).map(g6), !0).filter(Boolean);
      return y.forEach(function(m) {
        return m.classList.add("allow-interactivity-".concat(s));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(s)), y.forEach(function(m) {
          return m.classList.remove("allow-interactivity-".concat(s));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = T.useCallback(function(y, m) {
    if ("touches" in y && y.touches.length === 2 || y.type === "wheel" && y.ctrlKey)
      return !i.current.allowPinchZoom;
    var v = r1(y), b = n.current, x = "deltaX" in y ? y.deltaX : b[0] - v[0], w = "deltaY" in y ? y.deltaY : b[1] - v[1], S, C = y.target, _ = Math.abs(x) > Math.abs(w) ? "h" : "v";
    if ("touches" in y && _ === "h" && C.type === "range")
      return !1;
    var E = h6(_, C);
    if (!E)
      return !0;
    if (E ? S = _ : (S = _ === "v" ? "h" : "v", E = h6(_, C)), !E)
      return !1;
    if (!r.current && "changedTouches" in y && (x || w) && (r.current = S), !S)
      return !0;
    var M = r.current || S;
    return jCe(M, m, y, M === "h" ? x : w, !0);
  }, []), c = T.useCallback(function(y) {
    var m = y;
    if (!(!Ag.length || Ag[Ag.length - 1] !== o)) {
      var v = "deltaY" in m ? p6(m) : r1(m), b = e.current.filter(function(S) {
        return S.name === m.type && (S.target === m.target || m.target === S.shadowParent) && RCe(S.delta, v);
      })[0];
      if (b && b.should) {
        m.cancelable && m.preventDefault();
        return;
      }
      if (!b) {
        var x = (i.current.shards || []).map(g6).filter(Boolean).filter(function(S) {
          return S.contains(m.target);
        }), w = x.length > 0 ? a(m, x[0]) : !i.current.noIsolation;
        w && m.cancelable && m.preventDefault();
      }
    }
  }, []), l = T.useCallback(function(y, m, v, b) {
    var x = { name: y, delta: m, target: v, should: b, shadowParent: BCe(v) };
    e.current.push(x), setTimeout(function() {
      e.current = e.current.filter(function(w) {
        return w !== x;
      });
    }, 1);
  }, []), d = T.useCallback(function(y) {
    n.current = r1(y), r.current = void 0;
  }, []), u = T.useCallback(function(y) {
    l(y.type, p6(y), y.target, a(y, t.lockRef.current));
  }, []), f = T.useCallback(function(y) {
    l(y.type, r1(y), y.target, a(y, t.lockRef.current));
  }, []);
  T.useEffect(function() {
    return Ag.push(o), t.setCallbacks({
      onScrollCapture: u,
      onWheelCapture: u,
      onTouchMoveCapture: f
    }), document.addEventListener("wheel", c, kg), document.addEventListener("touchmove", c, kg), document.addEventListener("touchstart", d, kg), function() {
      Ag = Ag.filter(function(y) {
        return y !== o;
      }), document.removeEventListener("wheel", c, kg), document.removeEventListener("touchmove", c, kg), document.removeEventListener("touchstart", d, kg);
    };
  }, []);
  var p = t.removeScrollBar, g = t.inert;
  return T.createElement(
    T.Fragment,
    null,
    g ? T.createElement(o, { styles: $Ce(s) }) : null,
    p ? T.createElement(ICe, { noRelative: t.noRelative, gapMode: t.gapMode }) : null
  );
}
function BCe(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const zCe = gCe(JX, FCe);
var A0 = T.forwardRef(function(t, e) {
  return T.createElement(QP, Ml({}, t, { ref: e, sideCar: zCe }));
});
A0.classNames = QP.classNames;
var UCe = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, Mg = /* @__PURE__ */ new WeakMap(), s1 = /* @__PURE__ */ new WeakMap(), o1 = {}, XA = 0, sZ = function(t) {
  return t && (t.host || sZ(t.parentNode));
}, HCe = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = sZ(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, VCe = function(t, e, n, r) {
  var s = HCe(e, Array.isArray(t) ? t : [t]);
  o1[n] || (o1[n] = /* @__PURE__ */ new WeakMap());
  var o = o1[n], i = [], a = /* @__PURE__ */ new Set(), c = new Set(s), l = function(u) {
    !u || a.has(u) || (a.add(u), l(u.parentNode));
  };
  s.forEach(l);
  var d = function(u) {
    !u || c.has(u) || Array.prototype.forEach.call(u.children, function(f) {
      if (a.has(f))
        d(f);
      else
        try {
          var p = f.getAttribute(r), g = p !== null && p !== "false", y = (Mg.get(f) || 0) + 1, m = (o.get(f) || 0) + 1;
          Mg.set(f, y), o.set(f, m), i.push(f), y === 1 && g && s1.set(f, !0), m === 1 && f.setAttribute(n, "true"), g || f.setAttribute(r, "true");
        } catch (v) {
          console.error("aria-hidden: cannot operate on ", f, v);
        }
    });
  };
  return d(e), a.clear(), XA++, function() {
    i.forEach(function(u) {
      var f = Mg.get(u) - 1, p = o.get(u) - 1;
      Mg.set(u, f), o.set(u, p), f || (s1.has(u) || u.removeAttribute(r), s1.delete(u)), p || u.removeAttribute(n);
    }), XA--, XA || (Mg = /* @__PURE__ */ new WeakMap(), Mg = /* @__PURE__ */ new WeakMap(), s1 = /* @__PURE__ */ new WeakMap(), o1 = {});
  };
}, JP = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), s = UCe(t);
  return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live]"))), VCe(r, s, n, "aria-hidden")) : function() {
    return null;
  };
}, eI = "Dialog", [oZ, N3t] = bs(eI), [WCe, ll] = oZ(eI), iZ = (t) => {
  const {
    __scopeDialog: e,
    children: n,
    open: r,
    defaultOpen: s,
    onOpenChange: o,
    modal: i = !0
  } = t, a = T.useRef(null), c = T.useRef(null), [l, d] = io({
    prop: r,
    defaultProp: s ?? !1,
    onChange: o,
    caller: eI
  });
  return /* @__PURE__ */ h.jsx(
    WCe,
    {
      scope: e,
      triggerRef: a,
      contentRef: c,
      contentId: as(),
      titleId: as(),
      descriptionId: as(),
      open: l,
      onOpenChange: d,
      onOpenToggle: T.useCallback(() => d((u) => !u), [d]),
      modal: i,
      children: n
    }
  );
};
iZ.displayName = eI;
var aZ = "DialogTrigger", cZ = T.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = ll(aZ, n), o = vt(e, s.triggerRef);
    return /* @__PURE__ */ h.jsx(
      Re.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": s.open,
        "aria-controls": s.contentId,
        "data-state": gL(s.open),
        ...r,
        ref: o,
        onClick: Te(t.onClick, s.onOpenToggle)
      }
    );
  }
);
cZ.displayName = aZ;
var fL = "DialogPortal", [KCe, lZ] = oZ(fL, {
  forceMount: void 0
}), dZ = (t) => {
  const { __scopeDialog: e, forceMount: n, children: r, container: s } = t, o = ll(fL, e);
  return /* @__PURE__ */ h.jsx(KCe, { scope: e, forceMount: n, children: T.Children.map(r, (i) => /* @__PURE__ */ h.jsx(Fs, { present: n || o.open, children: /* @__PURE__ */ h.jsx(Uy, { asChild: !0, container: s, children: i }) })) });
};
dZ.displayName = fL;
var tE = "DialogOverlay", uZ = T.forwardRef(
  (t, e) => {
    const n = lZ(tE, t.__scopeDialog), { forceMount: r = n.forceMount, ...s } = t, o = ll(tE, t.__scopeDialog);
    return o.modal ? /* @__PURE__ */ h.jsx(Fs, { present: r || o.open, children: /* @__PURE__ */ h.jsx(YCe, { ...s, ref: e }) }) : null;
  }
);
uZ.displayName = tE;
var GCe = /* @__PURE__ */ kf("DialogOverlay.RemoveScroll"), YCe = T.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = ll(tE, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ h.jsx(A0, { as: GCe, allowPinchZoom: !0, shards: [s.contentRef], children: /* @__PURE__ */ h.jsx(
        Re.div,
        {
          "data-state": gL(s.open),
          ...r,
          ref: e,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), wp = "DialogContent", fZ = T.forwardRef(
  (t, e) => {
    const n = lZ(wp, t.__scopeDialog), { forceMount: r = n.forceMount, ...s } = t, o = ll(wp, t.__scopeDialog);
    return /* @__PURE__ */ h.jsx(Fs, { present: r || o.open, children: o.modal ? /* @__PURE__ */ h.jsx(qCe, { ...s, ref: e }) : /* @__PURE__ */ h.jsx(XCe, { ...s, ref: e }) });
  }
);
fZ.displayName = wp;
var qCe = T.forwardRef(
  (t, e) => {
    const n = ll(wp, t.__scopeDialog), r = T.useRef(null), s = vt(e, n.contentRef, r);
    return T.useEffect(() => {
      const o = r.current;
      if (o) return JP(o);
    }, []), /* @__PURE__ */ h.jsx(
      hZ,
      {
        ...t,
        ref: s,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Te(t.onCloseAutoFocus, (o) => {
          var i;
          o.preventDefault(), (i = n.triggerRef.current) == null || i.focus();
        }),
        onPointerDownOutside: Te(t.onPointerDownOutside, (o) => {
          const i = o.detail.originalEvent, a = i.button === 0 && i.ctrlKey === !0;
          (i.button === 2 || a) && o.preventDefault();
        }),
        onFocusOutside: Te(
          t.onFocusOutside,
          (o) => o.preventDefault()
        )
      }
    );
  }
), XCe = T.forwardRef(
  (t, e) => {
    const n = ll(wp, t.__scopeDialog), r = T.useRef(!1), s = T.useRef(!1);
    return /* @__PURE__ */ h.jsx(
      hZ,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          var i, a;
          (i = t.onCloseAutoFocus) == null || i.call(t, o), o.defaultPrevented || (r.current || (a = n.triggerRef.current) == null || a.focus(), o.preventDefault()), r.current = !1, s.current = !1;
        },
        onInteractOutside: (o) => {
          var c, l;
          (c = t.onInteractOutside) == null || c.call(t, o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (s.current = !0));
          const i = o.target;
          ((l = n.triggerRef.current) == null ? void 0 : l.contains(i)) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && s.current && o.preventDefault();
        }
      }
    );
  }
), hZ = T.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: s, onCloseAutoFocus: o, ...i } = t, a = ll(wp, n), c = T.useRef(null), l = vt(e, c);
    return ZP(), /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(
        k0,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: s,
          onUnmountAutoFocus: o,
          children: /* @__PURE__ */ h.jsx(
            ng,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": gL(a.open),
              ...i,
              ref: l,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
        /* @__PURE__ */ h.jsx(ZCe, { titleId: a.titleId }),
        /* @__PURE__ */ h.jsx(JCe, { contentRef: c, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), hL = "DialogTitle", pZ = T.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = ll(hL, n);
    return /* @__PURE__ */ h.jsx(Re.h2, { id: s.titleId, ...r, ref: e });
  }
);
pZ.displayName = hL;
var gZ = "DialogDescription", mZ = T.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = ll(gZ, n);
    return /* @__PURE__ */ h.jsx(Re.p, { id: s.descriptionId, ...r, ref: e });
  }
);
mZ.displayName = gZ;
var yZ = "DialogClose", pL = T.forwardRef(
  (t, e) => {
    const { __scopeDialog: n, ...r } = t, s = ll(yZ, n);
    return /* @__PURE__ */ h.jsx(
      Re.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: Te(t.onClick, () => s.onOpenChange(!1))
      }
    );
  }
);
pL.displayName = yZ;
function gL(t) {
  return t ? "open" : "closed";
}
var vZ = "DialogTitleWarning", [j3t, bZ] = txe(vZ, {
  contentName: wp,
  titleName: hL,
  docsSlug: "dialog"
}), ZCe = ({ titleId: t }) => {
  const e = bZ(vZ), n = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
  return T.useEffect(() => {
    t && (document.getElementById(t) || console.error(n));
  }, [n, t]), null;
}, QCe = "DialogDescriptionWarning", JCe = ({ contentRef: t, descriptionId: e }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${bZ(QCe).contentName}}.`;
  return T.useEffect(() => {
    var o;
    const s = (o = t.current) == null ? void 0 : o.getAttribute("aria-describedby");
    e && s && (document.getElementById(e) || console.warn(r));
  }, [r, t, e]), null;
}, tI = iZ, e_e = cZ, nI = dZ, Zy = uZ, Qy = fZ, M0 = pZ, rI = mZ, xZ = pL;
const wZ = tI, t_e = e_e, n_e = nI, SZ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  Zy,
  {
    className: Oe(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      t
    ),
    ...e,
    ref: n
  }
));
SZ.displayName = Zy.displayName;
const r_e = Hy(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom: "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right: "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm"
      }
    },
    defaultVariants: {
      side: "right"
    }
  }
), mL = T.forwardRef(
  ({ side: t = "right", className: e, children: n, ...r }, s) => /* @__PURE__ */ h.jsxs(n_e, { children: [
    /* @__PURE__ */ h.jsx(SZ, {}),
    /* @__PURE__ */ h.jsxs(Qy, { ref: s, className: Oe(r_e({ side: t }), e), ...r, children: [
      n,
      /* @__PURE__ */ h.jsxs(xZ, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-secondary hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none", children: [
        /* @__PURE__ */ h.jsx(rg, { className: "h-4 w-4" }),
        /* @__PURE__ */ h.jsx("span", { className: "sr-only", children: "Close" })
      ] })
    ] })
  ] })
);
mL.displayName = Qy.displayName;
const CZ = ({ className: t, ...e }) => /* @__PURE__ */ h.jsx("div", { className: Oe("flex flex-col space-y-2 text-center sm:text-left", t), ...e });
CZ.displayName = "SheetHeader";
const _Z = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(M0, { ref: n, className: Oe("text-lg font-semibold text-foreground", t), ...e }));
_Z.displayName = M0.displayName;
const EZ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(rI, { ref: n, className: Oe("text-sm text-muted-foreground", t), ...e }));
EZ.displayName = rI.displayName;
function m6({ className: t, ...e }) {
  return /* @__PURE__ */ h.jsx("div", { className: Oe("animate-pulse rounded-md bg-muted", t), ...e });
}
const s_e = "sidebar:state", o_e = 60 * 60 * 24 * 7, i_e = "16rem", a_e = "18rem", c_e = "3rem", l_e = "b", TZ = T.createContext(null);
function O0() {
  const t = T.useContext(TZ);
  if (!t)
    throw new Error("useSidebar must be used within a SidebarProvider.");
  return t;
}
const PZ = T.forwardRef(({ defaultOpen: t = !0, open: e, onOpenChange: n, className: r, style: s, children: o, ...i }, a) => {
  const c = q1e(), [l, d] = T.useState(!1), [u, f] = T.useState(t), p = e ?? u, g = T.useCallback(
    (b) => {
      const x = typeof b == "function" ? b(p) : b;
      n ? n(x) : f(x), document.cookie = `${s_e}=${x}; path=/; max-age=${o_e}`;
    },
    [n, p]
  ), y = T.useCallback(() => c ? d((b) => !b) : g((b) => !b), [c, g, d]);
  T.useEffect(() => {
    const b = (x) => {
      x.key === l_e && (x.metaKey || x.ctrlKey) && (x.preventDefault(), y());
    };
    return window.addEventListener("keydown", b), () => window.removeEventListener("keydown", b);
  }, [y]);
  const m = p ? "expanded" : "collapsed", v = T.useMemo(
    () => ({
      state: m,
      open: p,
      setOpen: g,
      isMobile: c,
      openMobile: l,
      setOpenMobile: d,
      toggleSidebar: y
    }),
    [m, p, g, c, l, d, y]
  );
  return /* @__PURE__ */ h.jsx(TZ.Provider, { value: v, children: /* @__PURE__ */ h.jsx(RX, { delayDuration: 0, children: /* @__PURE__ */ h.jsx(
    "div",
    {
      style: {
        "--sidebar-width": i_e,
        "--sidebar-width-icon": c_e,
        ...s
      },
      className: Oe("group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar", r),
      ref: a,
      ...i,
      children: o
    }
  ) }) });
});
PZ.displayName = "SidebarProvider";
const IZ = T.forwardRef(({ side: t = "left", variant: e = "sidebar", collapsible: n = "offcanvas", className: r, children: s, ...o }, i) => {
  const { isMobile: a, state: c, openMobile: l, setOpenMobile: d } = O0();
  return n === "none" ? /* @__PURE__ */ h.jsx(
    "div",
    {
      className: Oe("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", r),
      ref: i,
      ...o,
      children: s
    }
  ) : a ? /* @__PURE__ */ h.jsx(wZ, { open: l, onOpenChange: d, ...o, children: /* @__PURE__ */ h.jsx(
    mL,
    {
      "data-sidebar": "sidebar",
      "data-mobile": "true",
      className: "w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
      style: {
        "--sidebar-width": a_e
      },
      side: t,
      children: /* @__PURE__ */ h.jsx("div", { className: "flex h-full w-full flex-col", children: s })
    }
  ) }) : /* @__PURE__ */ h.jsxs(
    "div",
    {
      ref: i,
      className: "group peer hidden text-sidebar-foreground md:block",
      "data-state": c,
      "data-collapsible": c === "collapsed" ? n : "",
      "data-variant": e,
      "data-side": t,
      children: [
        /* @__PURE__ */ h.jsx(
          "div",
          {
            className: Oe(
              "relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
              "group-data-[collapsible=offcanvas]:w-0",
              "group-data-[side=right]:rotate-180",
              e === "floating" || e === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
            )
          }
        ),
        /* @__PURE__ */ h.jsx(
          "div",
          {
            className: Oe(
              "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
              t === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
              // Adjust the padding for floating and inset variants.
              e === "floating" || e === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
              r
            ),
            ...o,
            children: /* @__PURE__ */ h.jsx(
              "div",
              {
                "data-sidebar": "sidebar",
                className: "flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow",
                children: s
              }
            )
          }
        )
      ]
    }
  );
});
IZ.displayName = "Sidebar";
const d_e = T.forwardRef(
  ({ className: t, onClick: e, ...n }, r) => {
    const { toggleSidebar: s } = O0();
    return /* @__PURE__ */ h.jsxs(
      _t,
      {
        ref: r,
        "data-sidebar": "trigger",
        variant: "ghost",
        size: "icon",
        className: Oe("h-7 w-7", t),
        onClick: (o) => {
          e == null || e(o), s();
        },
        ...n,
        children: [
          /* @__PURE__ */ h.jsx(Vq, {}),
          /* @__PURE__ */ h.jsx("span", { className: "sr-only", children: "Toggle Sidebar" })
        ]
      }
    );
  }
);
d_e.displayName = "SidebarTrigger";
const u_e = T.forwardRef(
  ({ className: t, ...e }, n) => {
    const { toggleSidebar: r } = O0();
    return /* @__PURE__ */ h.jsx(
      "button",
      {
        ref: n,
        "data-sidebar": "rail",
        "aria-label": "Toggle Sidebar",
        tabIndex: -1,
        onClick: r,
        title: "Toggle Sidebar",
        className: Oe(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] group-data-[side=left]:-right-4 group-data-[side=right]:left-0 hover:after:bg-sidebar-border sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          t
        ),
        ...e
      }
    );
  }
);
u_e.displayName = "SidebarRail";
const kZ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  "main",
  {
    ref: n,
    className: Oe(
      "relative flex min-h-svh flex-1 flex-col bg-background",
      "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
      t
    ),
    ...e
  }
));
kZ.displayName = "SidebarInset";
const f_e = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
    pa,
    {
      ref: n,
      "data-sidebar": "input",
      className: Oe(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        t
      ),
      ...e
    }
  )
);
f_e.displayName = "SidebarInput";
const AZ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("div", { ref: n, "data-sidebar": "header", className: Oe("flex flex-col gap-2 p-2", t), ...e }));
AZ.displayName = "SidebarHeader";
const MZ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("div", { ref: n, "data-sidebar": "footer", className: Oe("flex flex-col gap-2 p-2", t), ...e }));
MZ.displayName = "SidebarFooter";
const h_e = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
    ix,
    {
      ref: n,
      "data-sidebar": "separator",
      className: Oe("mx-2 w-auto bg-sidebar-border", t),
      ...e
    }
  )
);
h_e.displayName = "SidebarSeparator";
const OZ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  "div",
  {
    ref: n,
    "data-sidebar": "content",
    className: Oe(
      "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
      t
    ),
    ...e
  }
));
OZ.displayName = "SidebarContent";
const $C = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  "div",
  {
    ref: n,
    "data-sidebar": "group",
    className: Oe("relative flex w-full min-w-0 flex-col p-2", t),
    ...e
  }
));
$C.displayName = "SidebarGroup";
const LC = T.forwardRef(
  ({ className: t, asChild: e = !1, ...n }, r) => {
    const s = e ? zy : "div";
    return /* @__PURE__ */ h.jsx(
      s,
      {
        ref: r,
        "data-sidebar": "group-label",
        className: Oe(
          "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          t
        ),
        ...n
      }
    );
  }
);
LC.displayName = "SidebarGroupLabel";
const p_e = T.forwardRef(
  ({ className: t, asChild: e = !1, ...n }, r) => {
    const s = e ? zy : "button";
    return /* @__PURE__ */ h.jsx(
      s,
      {
        ref: r,
        "data-sidebar": "group-action",
        className: Oe(
          "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          // Increases the hit area of the button on mobile.
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          t
        ),
        ...n
      }
    );
  }
);
p_e.displayName = "SidebarGroupAction";
const FC = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("div", { ref: n, "data-sidebar": "group-content", className: Oe("w-full text-sm", t), ...e })
);
FC.displayName = "SidebarGroupContent";
const _b = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("ul", { ref: n, "data-sidebar": "menu", className: Oe("flex w-full min-w-0 flex-col gap-1", t), ...e }));
_b.displayName = "SidebarMenu";
const Ad = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("li", { ref: n, "data-sidebar": "menu-item", className: Oe("group/menu-item relative", t), ...e }));
Ad.displayName = "SidebarMenuItem";
const g_e = Hy(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Md = T.forwardRef(({ asChild: t = !1, isActive: e = !1, variant: n = "default", size: r = "default", tooltip: s, className: o, ...i }, a) => {
  const c = t ? zy : "button", { isMobile: l, state: d } = O0(), u = /* @__PURE__ */ h.jsx(
    c,
    {
      ref: a,
      "data-sidebar": "menu-button",
      "data-size": r,
      "data-active": e,
      className: Oe(g_e({ variant: n, size: r }), o),
      ...i
    }
  );
  return s ? (typeof s == "string" && (s = {
    children: s
  }), /* @__PURE__ */ h.jsxs($D, { children: [
    /* @__PURE__ */ h.jsx(LD, { asChild: !0, children: u }),
    /* @__PURE__ */ h.jsx(Z_, { side: "right", align: "center", hidden: d !== "collapsed" || l, ...s })
  ] })) : u;
});
Md.displayName = "SidebarMenuButton";
const m_e = T.forwardRef(({ className: t, asChild: e = !1, showOnHover: n = !1, ...r }, s) => {
  const o = e ? zy : "button";
  return /* @__PURE__ */ h.jsx(
    o,
    {
      ref: s,
      "data-sidebar": "menu-action",
      className: Oe(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform peer-hover/menu-button:text-sidebar-accent-foreground hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        n && "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        t
      ),
      ...r
    }
  );
});
m_e.displayName = "SidebarMenuAction";
const y_e = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
    "div",
    {
      ref: n,
      "data-sidebar": "menu-badge",
      className: Oe(
        "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        t
      ),
      ...e
    }
  )
);
y_e.displayName = "SidebarMenuBadge";
const v_e = T.forwardRef(({ className: t, showIcon: e = !1, ...n }, r) => {
  const s = T.useMemo(() => `${Math.floor(Math.random() * 40) + 50}%`, []);
  return /* @__PURE__ */ h.jsxs(
    "div",
    {
      ref: r,
      "data-sidebar": "menu-skeleton",
      className: Oe("flex h-8 items-center gap-2 rounded-md px-2", t),
      ...n,
      children: [
        e && /* @__PURE__ */ h.jsx(m6, { className: "size-4 rounded-md", "data-sidebar": "menu-skeleton-icon" }),
        /* @__PURE__ */ h.jsx(
          m6,
          {
            className: "h-4 max-w-[--skeleton-width] flex-1",
            "data-sidebar": "menu-skeleton-text",
            style: {
              "--skeleton-width": s
            }
          }
        )
      ]
    }
  );
});
v_e.displayName = "SidebarMenuSkeleton";
const b_e = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
    "ul",
    {
      ref: n,
      "data-sidebar": "menu-sub",
      className: Oe(
        "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        t
      ),
      ...e
    }
  )
);
b_e.displayName = "SidebarMenuSub";
const x_e = T.forwardRef(({ ...t }, e) => /* @__PURE__ */ h.jsx("li", { ref: e, ...t }));
x_e.displayName = "SidebarMenuSubItem";
const w_e = T.forwardRef(({ asChild: t = !1, size: e = "md", isActive: n, className: r, ...s }, o) => {
  const i = t ? zy : "a";
  return /* @__PURE__ */ h.jsx(
    i,
    {
      ref: o,
      "data-sidebar": "menu-sub-button",
      "data-size": e,
      "data-active": n,
      className: Oe(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring aria-disabled:pointer-events-none aria-disabled:opacity-50 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        e === "sm" && "text-xs",
        e === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        r
      ),
      ...s
    }
  );
});
w_e.displayName = "SidebarMenuSubButton";
const DZ = zn(""), S_e = DZ.Provider;
function sI() {
  return tn(DZ);
}
function rd() {
  const t = Wbe(), e = sI();
  return (n, r) => typeof n == "string" && n.startsWith("/") ? t(e + n, r) : t(n, r);
}
const Bd = du(
  ({ className: t, activeClassName: e, pendingClassName: n, to: r, ...s }, o) => {
    const i = sI(), a = typeof r == "string" && r.startsWith("/") ? i + r : r;
    return /* @__PURE__ */ h.jsx(
      Kbe,
      {
        ref: o,
        to: a,
        className: ({ isActive: c, isPending: l }) => Oe(t, c && e, l && n),
        ...s
      }
    );
  }
);
Bd.displayName = "NavLink";
const Za = ["canvas", "diagram", "board", "notes", "calendar"], ss = 1;
function C_e(t) {
  return typeof t == "string" && Za.includes(t);
}
function y6(t, e) {
  if (typeof t != "string") return e;
  const n = Date.parse(t);
  return Number.isNaN(n) ? e : new Date(n).toISOString();
}
function Ii(t) {
  if (!t || typeof t != "object" || !t.id || typeof t.id != "string" || !C_e(t.type)) return null;
  const e = (/* @__PURE__ */ new Date()).toISOString(), n = y6(t.createdAt, e), r = y6(t.updatedAt, n), s = {
    id: t.id,
    type: t.type,
    name: typeof t.name == "string" && t.name.trim().length > 0 ? t.name : "Untitled",
    data: t.data ?? null,
    createdAt: n,
    updatedAt: r,
    favorite: !!t.favorite,
    pinned: !!t.pinned,
    schemaVersion: typeof t.schemaVersion == "number" && t.schemaVersion > 0 ? t.schemaVersion : ss,
    tags: Array.isArray(t.tags) ? t.tags.filter((o) => typeof o == "string") : void 0
  };
  return __e(s);
}
function __e(t) {
  let e = { ...t };
  return (!e.schemaVersion || e.schemaVersion < 1) && (e = { ...e, schemaVersion: 1 }), e.pinned === void 0 && (e = { ...e, pinned: !1 }), e.schemaVersion > ss && (e.schemaVersion = ss), e;
}
const v6 = "blueprint:settings", ZA = "blueprint:artifact:", QA = "blueprint:artifacts", JA = "blueprint:calendar:events";
class NZ {
  async getSettings() {
    try {
      const e = localStorage.getItem(v6);
      if (e) {
        const n = JSON.parse(e);
        return {
          enabledTools: Array.isArray(n.enabledTools) ? n.enabledTools : [...Za],
          seededNoteCreated: n.seededNoteCreated
        };
      }
    } catch (e) {
      console.error("Failed to load settings:", e);
    }
    return { enabledTools: [...Za] };
  }
  async saveSettings(e) {
    try {
      localStorage.setItem(v6, JSON.stringify(e));
    } catch (n) {
      console.error("Failed to save settings:", n);
    }
  }
  async getArtifact(e) {
    try {
      const n = localStorage.getItem(ZA + e);
      if (n) {
        const r = JSON.parse(n);
        return Ii(r);
      }
    } catch (n) {
      console.error("Failed to load artifact:", n);
    }
    return null;
  }
  async saveArtifact(e) {
    try {
      const n = Ii({
        ...e,
        favorite: e.favorite ?? !1,
        pinned: e.pinned ?? !1,
        schemaVersion: e.schemaVersion ?? ss
      });
      if (!n) return;
      localStorage.setItem(ZA + n.id, JSON.stringify(n));
      const r = await this.getArtifactIndex();
      r.includes(n.id) || (r.push(n.id), localStorage.setItem(QA, JSON.stringify(r)));
    } catch (n) {
      console.error("Failed to save artifact:", n);
    }
  }
  async deleteArtifact(e) {
    try {
      localStorage.removeItem(ZA + e);
      const r = (await this.getArtifactIndex()).filter((s) => s !== e);
      localStorage.setItem(QA, JSON.stringify(r));
    } catch (n) {
      console.error("Failed to delete artifact:", n);
    }
  }
  async listArtifacts(e) {
    try {
      const n = await this.getArtifactIndex(), r = [];
      for (const s of n) {
        const o = await this.getArtifact(s);
        if (o && (!e || o.type === e)) {
          const i = Ii(o);
          i && r.push(i);
        }
      }
      return r.sort(
        (s, o) => new Date(o.updatedAt).getTime() - new Date(s.updatedAt).getTime()
      );
    } catch (n) {
      return console.error("Failed to list artifacts:", n), [];
    }
  }
  async listFavorites() {
    try {
      const e = await this.getArtifactIndex(), n = [];
      for (const r of e) {
        const s = await this.getArtifact(r);
        if (s && s.favorite) {
          const o = Ii(s);
          o && n.push(o);
        }
      }
      return n.sort(
        (r, s) => new Date(s.updatedAt).getTime() - new Date(r.updatedAt).getTime()
      );
    } catch (e) {
      return console.error("Failed to list favorites:", e), [];
    }
  }
  async listByTag(e) {
    var n;
    try {
      const r = await this.getArtifactIndex(), s = [];
      for (const o of r) {
        const i = await this.getArtifact(o);
        if (i && ((n = i.tags) != null && n.includes(e))) {
          const a = Ii(i);
          a && s.push(a);
        }
      }
      return s.sort(
        (o, i) => new Date(i.updatedAt).getTime() - new Date(o.updatedAt).getTime()
      );
    } catch (r) {
      return console.error("Failed to list by tag:", r), [];
    }
  }
  async getArtifactIndex() {
    try {
      const e = localStorage.getItem(QA);
      if (e)
        return JSON.parse(e);
    } catch (e) {
      console.error("Failed to load artifact index:", e);
    }
    return [];
  }
  // Calendar events
  async listCalendarEvents() {
    try {
      const e = localStorage.getItem(JA);
      if (e)
        return JSON.parse(e);
    } catch (e) {
      console.error("Failed to load calendar events:", e);
    }
    return [];
  }
  async saveCalendarEvent(e) {
    try {
      const n = await this.listCalendarEvents(), r = n.findIndex((s) => s.id === e.id);
      r >= 0 ? n[r] = e : n.push(e), localStorage.setItem(JA, JSON.stringify(n));
    } catch (n) {
      console.error("Failed to save calendar event:", n);
    }
  }
  async deleteCalendarEvent(e) {
    try {
      const r = (await this.listCalendarEvents()).filter((s) => s.id !== e);
      localStorage.setItem(JA, JSON.stringify(r));
    } catch (n) {
      console.error("Failed to delete calendar event:", n);
    }
  }
}
const jZ = "blueprint:db-config";
function RZ() {
  try {
  } catch {
  }
  return null;
}
function $Z() {
  const t = RZ();
  if (t)
    return { provider: "instantdb", instantAppId: t, source: "env" };
  if (typeof localStorage > "u") return null;
  try {
    const e = localStorage.getItem(jZ);
    if (!e) return null;
    const n = JSON.parse(e);
    return n.provider === "local" ? { provider: "local", source: "localStorage" } : n.provider === "instantdb" ? !n.instantAppId || typeof n.instantAppId != "string" ? null : { provider: "instantdb", instantAppId: n.instantAppId.trim(), source: "localStorage" } : null;
  } catch {
    return null;
  }
}
function E_e() {
  return RZ() !== null;
}
function b6(t) {
  typeof localStorage > "u" || localStorage.setItem(jZ, JSON.stringify(t));
}
function Ps(t) {
  if (typeof t == "number")
    return (Math.abs(t * 2654435761) >>> 0).toString(16);
  if (typeof t == "boolean")
    return t ? "1" : "0";
  if (t === null)
    return "null";
  if (t === void 0)
    return "undefined";
  if (typeof t == "string") {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++)
      e ^= t.charCodeAt(n), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24), e = e >>> 0;
    return e.toString(16);
  }
  if (Array.isArray(t)) {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++) {
      e ^= (n + 1) * 2654435761;
      const r = Ps(t[n]);
      for (let s = 0; s < r.length; s++)
        e ^= r.charCodeAt(s), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  if (typeof t == "object") {
    let e = 2166136261;
    const n = Object.keys(t).sort();
    for (let r = 0; r < n.length; r++) {
      const s = n[r], o = Ps(s);
      e ^= parseInt(o, 16), e *= 16777619, e = e >>> 0;
      const i = Ps(t[s]);
      e ^= parseInt(i, 16), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  return Ps(String(t));
}
const Nr = {
  Remove: "remove",
  Replace: "replace",
  Add: "add"
}, LZ = Symbol.for("__MUTATIVE_PROXY_DRAFT__"), T_e = Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__"), BC = Symbol.iterator, ga = {
  mutable: "mutable",
  immutable: "immutable"
}, yL = {};
function ax(t, e) {
  return t instanceof Map ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function x6(t, e) {
  if (e in t) {
    let n = Reflect.getPrototypeOf(t);
    for (; n; ) {
      const r = Reflect.getOwnPropertyDescriptor(n, e);
      if (r)
        return r;
      n = Reflect.getPrototypeOf(n);
    }
  }
}
function vL(t) {
  return Object.getPrototypeOf(t) === Set.prototype;
}
function bL(t) {
  return Object.getPrototypeOf(t) === Map.prototype;
}
function oa(t) {
  var e;
  return (e = t.copy) !== null && e !== void 0 ? e : t.original;
}
function Mf(t) {
  return !!Qt(t);
}
function Qt(t) {
  return typeof t != "object" ? null : t == null ? void 0 : t[LZ];
}
function xL(t) {
  var e;
  const n = Qt(t);
  return n ? (e = n.copy) !== null && e !== void 0 ? e : n.original : t;
}
function sl(t, e) {
  if (!t || typeof t != "object")
    return !1;
  let n;
  return Object.getPrototypeOf(t) === Object.prototype || Array.isArray(t) || t instanceof Map || t instanceof Set || !!(e != null && e.mark) && ((n = e.mark(t, ga)) === ga.immutable || typeof n == "function");
}
function FZ(t, e = []) {
  if (Object.hasOwnProperty.call(t, "key")) {
    const n = t.parent.copy, r = Qt(tu(n, t.key));
    if (r !== null && (r == null ? void 0 : r.original) !== t.original)
      return null;
    const s = t.parent.type === 3, o = s ? Array.from(t.parent.setMap.keys()).indexOf(t.key) : t.key;
    if (!(s && n.size > o || ax(n, o)))
      return null;
    e.push(o);
  }
  if (t.parent)
    return FZ(t.parent, e);
  e.reverse();
  try {
    P_e(t.copy, e);
  } catch {
    return null;
  }
  return e;
}
function sg(t) {
  return Array.isArray(t) ? 1 : t instanceof Map ? 2 : t instanceof Set ? 3 : 0;
}
function tu(t, e) {
  return sg(t) === 2 ? t.get(e) : t[e];
}
function D0(t, e, n) {
  sg(t) === 2 ? t.set(e, n) : t[e] = n;
}
function eM(t, e) {
  const n = Qt(t);
  return (n ? oa(n) : t)[e];
}
function Yd(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function tN(t) {
  if (t)
    for (; t.finalities.revoke.length > 0; )
      t.finalities.revoke.pop()();
}
function Lh(t, e) {
  return e ? t : [""].concat(t).map((n) => {
    const r = `${n}`;
    return r.indexOf("/") === -1 && r.indexOf("~") === -1 ? r : r.replace(/~/g, "~0").replace(/\//g, "~1");
  }).join("/");
}
function P_e(t, e) {
  for (let n = 0; n < e.length - 1; n += 1) {
    const r = e[n];
    if (t = tu(sg(t) === 3 ? Array.from(t) : t, r), typeof t != "object")
      throw new Error(`Cannot resolve patch at '${e.join("/")}'.`);
  }
  return t;
}
function I_e(t) {
  const e = Object.create(Object.getPrototypeOf(t));
  return Reflect.ownKeys(t).forEach((n) => {
    let r = Reflect.getOwnPropertyDescriptor(t, n);
    if (r.enumerable && r.configurable && r.writable) {
      e[n] = t[n];
      return;
    }
    r.writable || (r.writable = !0, r.configurable = !0), (r.get || r.set) && (r = {
      configurable: !0,
      writable: !0,
      enumerable: r.enumerable,
      value: t[n]
    }), Reflect.defineProperty(e, n, r);
  }), e;
}
const k_e = Object.prototype.propertyIsEnumerable;
function BZ(t, e) {
  let n;
  if (Array.isArray(t))
    return Array.prototype.concat.call(t);
  if (t instanceof Set) {
    if (!vL(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(t.values());
    }
    return Set.prototype.difference ? Set.prototype.difference.call(t, /* @__PURE__ */ new Set()) : new Set(t.values());
  } else if (t instanceof Map) {
    if (!bL(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(t);
    }
    return new Map(t);
  } else if (e != null && e.mark && (n = e.mark(t, ga), n !== void 0) && n !== ga.mutable) {
    if (n === ga.immutable)
      return I_e(t);
    if (typeof n == "function") {
      if (e.enablePatches || e.enableAutoFreeze)
        throw new Error("You can't use mark and patches or auto freeze together.");
      return n();
    }
    throw new Error(`Unsupported mark result: ${n}`);
  } else if (typeof t == "object" && Object.getPrototypeOf(t) === Object.prototype) {
    const r = {};
    return Object.keys(t).forEach((s) => {
      r[s] = t[s];
    }), Object.getOwnPropertySymbols(t).forEach((s) => {
      k_e.call(t, s) && (r[s] = t[s]);
    }), r;
  } else
    throw new Error("Please check mark() to ensure that it is a stable marker draftable function.");
}
function si(t) {
  t.copy || (t.copy = BZ(t.original, t.options));
}
function Eb(t) {
  if (!sl(t))
    return xL(t);
  if (Array.isArray(t))
    return t.map(Eb);
  if (t instanceof Map) {
    const n = Array.from(t.entries()).map(([r, s]) => [
      r,
      Eb(s)
    ]);
    if (!bL(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(n);
    }
    return new Map(n);
  }
  if (t instanceof Set) {
    const n = Array.from(t).map(Eb);
    if (!vL(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(n);
    }
    return new Set(n);
  }
  const e = Object.create(Object.getPrototypeOf(t));
  for (const n in t)
    e[n] = Eb(t[n]);
  return e;
}
function zC(t) {
  return Mf(t) ? Eb(t) : t;
}
function Bl(t) {
  var e;
  t.assignedMap = (e = t.assignedMap) !== null && e !== void 0 ? e : /* @__PURE__ */ new Map(), t.operated || (t.operated = !0, t.parent && Bl(t.parent));
}
function w6() {
  throw new Error("Cannot modify frozen object");
}
function Yg(t, e, n, r, s) {
  {
    n = n ?? /* @__PURE__ */ new WeakMap(), r = r ?? [], s = s ?? [];
    const i = n.has(t) ? n.get(t) : t;
    if (r.length > 0) {
      const a = r.indexOf(i);
      if (i && typeof i == "object" && a !== -1)
        throw r[0] === i ? new Error("Forbids circular reference") : new Error(`Forbids circular reference: ~/${s.slice(0, a).map((c, l) => {
          if (typeof c == "symbol")
            return `[${c.toString()}]`;
          const d = r[l];
          return typeof c == "object" && (d instanceof Map || d instanceof Set) ? Array.from(d.keys()).indexOf(c) : c;
        }).join("/")}`);
      r.push(i), s.push(e);
    } else
      r.push(i);
  }
  if (Object.isFrozen(t) || Mf(t)) {
    r.pop(), s.pop();
    return;
  }
  switch (sg(t)) {
    case 2:
      for (const [a, c] of t)
        Yg(a, a, n, r, s), Yg(c, a, n, r, s);
      t.set = t.clear = t.delete = w6;
      break;
    case 3:
      for (const a of t)
        Yg(a, a, n, r, s);
      t.add = t.clear = t.delete = w6;
      break;
    case 1:
      Object.freeze(t);
      let i = 0;
      for (const a of t)
        Yg(a, i, n, r, s), i += 1;
      break;
    default:
      Object.freeze(t), Object.keys(t).forEach((a) => {
        const c = t[a];
        Yg(c, a, n, r, s);
      });
  }
  r.pop(), s.pop();
}
function wL(t, e) {
  const n = sg(t);
  if (n === 0)
    Reflect.ownKeys(t).forEach((r) => {
      e(r, t[r], t);
    });
  else if (n === 1) {
    let r = 0;
    for (const s of t)
      e(r, s, t), r += 1;
  } else
    t.forEach((r, s) => e(s, r, t));
}
function zZ(t, e, n) {
  if (Mf(t) || !sl(t, n) || e.has(t) || Object.isFrozen(t))
    return;
  const r = t instanceof Set, s = r ? /* @__PURE__ */ new Map() : void 0;
  if (e.add(t), wL(t, (o, i) => {
    var a;
    if (Mf(i)) {
      const c = Qt(i);
      si(c);
      const l = !((a = c.assignedMap) === null || a === void 0) && a.size || c.operated ? c.copy : c.original;
      D0(r ? s : t, o, l);
    } else
      zZ(i, e, n);
  }), s) {
    const o = t, i = Array.from(o);
    o.clear(), i.forEach((a) => {
      o.add(s.has(a) ? s.get(a) : a);
    });
  }
}
function A_e(t, e) {
  const n = t.type === 3 ? t.setMap : t.copy;
  t.finalities.revoke.length > 1 && t.assignedMap.get(e) && n && zZ(tu(n, e), t.finalities.handledSet, t.options);
}
function nN(t) {
  t.type === 3 && t.copy && (t.copy.clear(), t.setMap.forEach((e) => {
    t.copy.add(xL(e));
  }));
}
function rN(t, e, n, r) {
  if (t.operated && t.assignedMap && t.assignedMap.size > 0 && !t.finalized) {
    if (n && r) {
      const o = FZ(t);
      o && e(t, o, n, r);
    }
    t.finalized = !0;
  }
}
function SL(t, e, n, r) {
  const s = Qt(n);
  s && (s.callbacks || (s.callbacks = []), s.callbacks.push((o, i) => {
    var a;
    const c = t.type === 3 ? t.setMap : t.copy;
    if (Yd(tu(c, e), n)) {
      let l = s.original;
      s.copy && (l = s.copy), nN(t), rN(t, r, o, i), t.options.enableAutoFreeze && (t.options.updatedValues = (a = t.options.updatedValues) !== null && a !== void 0 ? a : /* @__PURE__ */ new WeakMap(), t.options.updatedValues.set(l, s.original)), D0(c, e, l);
    }
  }), t.options.enableAutoFreeze && s.finalities !== t.finalities && (t.options.enableAutoFreeze = !1)), sl(n, t.options) && t.finalities.draft.push(() => {
    const o = t.type === 3 ? t.setMap : t.copy;
    Yd(tu(o, e), n) && A_e(t, e);
  });
}
function M_e(t, e, n, r, s) {
  let { original: o, assignedMap: i, options: a } = t, c = t.copy;
  c.length < o.length && ([o, c] = [c, o], [n, r] = [r, n]);
  for (let l = 0; l < o.length; l += 1)
    if (i.get(l.toString()) && c[l] !== o[l]) {
      const d = e.concat([l]), u = Lh(d, s);
      n.push({
        op: Nr.Replace,
        path: u,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: zC(c[l])
      }), r.push({
        op: Nr.Replace,
        path: u,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: zC(o[l])
      });
    }
  for (let l = o.length; l < c.length; l += 1) {
    const d = e.concat([l]), u = Lh(d, s);
    n.push({
      op: Nr.Add,
      path: u,
      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
      value: zC(c[l])
    });
  }
  if (o.length < c.length) {
    const { arrayLengthAssignment: l = !0 } = a.enablePatches;
    if (l) {
      const d = e.concat(["length"]), u = Lh(d, s);
      r.push({
        op: Nr.Replace,
        path: u,
        value: o.length
      });
    } else
      for (let d = c.length; o.length < d; d -= 1) {
        const u = e.concat([d - 1]), f = Lh(u, s);
        r.push({
          op: Nr.Remove,
          path: f
        });
      }
  }
}
function O_e({ original: t, copy: e, assignedMap: n }, r, s, o, i) {
  n.forEach((a, c) => {
    const l = tu(t, c), d = zC(tu(e, c)), u = a ? ax(t, c) ? Nr.Replace : Nr.Add : Nr.Remove;
    if (Yd(l, d) && u === Nr.Replace)
      return;
    const f = r.concat(c), p = Lh(f, i);
    s.push(u === Nr.Remove ? { op: u, path: p } : { op: u, path: p, value: d }), o.push(u === Nr.Add ? { op: Nr.Remove, path: p } : u === Nr.Remove ? { op: Nr.Add, path: p, value: l } : { op: Nr.Replace, path: p, value: l });
  });
}
function D_e({ original: t, copy: e }, n, r, s, o) {
  let i = 0;
  t.forEach((a) => {
    if (!e.has(a)) {
      const c = n.concat([i]), l = Lh(c, o);
      r.push({
        op: Nr.Remove,
        path: l,
        value: a
      }), s.unshift({
        op: Nr.Add,
        path: l,
        value: a
      });
    }
    i += 1;
  }), i = 0, e.forEach((a) => {
    if (!t.has(a)) {
      const c = n.concat([i]), l = Lh(c, o);
      r.push({
        op: Nr.Add,
        path: l,
        value: a
      }), s.unshift({
        op: Nr.Remove,
        path: l,
        value: a
      });
    }
    i += 1;
  });
}
function Zx(t, e, n, r) {
  const { pathAsArray: s = !0 } = t.options.enablePatches;
  switch (t.type) {
    case 0:
    case 2:
      return O_e(t, e, n, r, s);
    case 1:
      return M_e(t, e, n, r, s);
    case 3:
      return D_e(t, e, n, r, s);
  }
}
let N_e = !1;
const nE = (t, e, n = !1) => {
  if (typeof t == "object" && t !== null && (!sl(t, e) || n) && !N_e)
    throw new Error("Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.");
}, sN = {
  get size() {
    return oa(Qt(this)).size;
  },
  has(t) {
    return oa(Qt(this)).has(t);
  },
  set(t, e) {
    const n = Qt(this), r = oa(n);
    return (!r.has(t) || !Yd(r.get(t), e)) && (si(n), Bl(n), n.assignedMap.set(t, !0), n.copy.set(t, e), SL(n, t, e, Zx)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = Qt(this);
    return si(e), Bl(e), e.original.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.copy.delete(t), !0;
  },
  clear() {
    const t = Qt(this);
    if (this.size) {
      si(t), Bl(t), t.assignedMap = /* @__PURE__ */ new Map();
      for (const [e] of t.original)
        t.assignedMap.set(e, !1);
      t.copy.clear();
    }
  },
  forEach(t, e) {
    const n = Qt(this);
    oa(n).forEach((r, s) => {
      t.call(e, this.get(s), s, this);
    });
  },
  get(t) {
    var e, n;
    const r = Qt(this), s = oa(r).get(t), o = ((n = (e = r.options).mark) === null || n === void 0 ? void 0 : n.call(e, s, ga)) === ga.mutable;
    if (r.options.strict && nE(s, r.options, o), o || r.finalized || !sl(s, r.options) || s !== r.original.get(t))
      return s;
    const i = yL.createDraft({
      original: s,
      parentDraft: r,
      key: t,
      finalities: r.finalities,
      options: r.options
    });
    return si(r), r.copy.set(t, i), i;
  },
  keys() {
    return oa(Qt(this)).keys();
  },
  values() {
    const t = this.keys();
    return {
      [BC]: () => this.values(),
      next: () => {
        const e = t.next();
        return e.done ? e : {
          done: !1,
          value: this.get(e.value)
        };
      }
    };
  },
  entries() {
    const t = this.keys();
    return {
      [BC]: () => this.entries(),
      next: () => {
        const e = t.next();
        if (e.done)
          return e;
        const n = this.get(e.value);
        return {
          done: !1,
          value: [e.value, n]
        };
      }
    };
  },
  [BC]() {
    return this.entries();
  }
}, j_e = Reflect.ownKeys(sN), S6 = (t, e, { isValuesIterator: n }) => () => {
  var r, s;
  const o = e.next();
  if (o.done)
    return o;
  const i = o.value;
  let a = t.setMap.get(i);
  const c = Qt(a), l = ((s = (r = t.options).mark) === null || s === void 0 ? void 0 : s.call(r, a, ga)) === ga.mutable;
  if (t.options.strict && nE(i, t.options, l), !l && !c && sl(i, t.options) && !t.finalized && t.original.has(i)) {
    const d = yL.createDraft({
      original: i,
      parentDraft: t,
      key: i,
      finalities: t.finalities,
      options: t.options
    });
    t.setMap.set(i, d), a = d;
  } else c && (a = c.proxy);
  return {
    done: !1,
    value: n ? a : [a, a]
  };
}, rE = {
  get size() {
    return Qt(this).setMap.size;
  },
  has(t) {
    const e = Qt(this);
    if (e.setMap.has(t))
      return !0;
    si(e);
    const n = Qt(t);
    return !!(n && e.setMap.has(n.original));
  },
  add(t) {
    const e = Qt(this);
    return this.has(t) || (si(e), Bl(e), e.assignedMap.set(t, !0), e.setMap.set(t, t), SL(e, t, t, Zx)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = Qt(this);
    si(e), Bl(e);
    const n = Qt(t);
    return n && e.setMap.has(n.original) ? (e.assignedMap.set(n.original, !1), e.setMap.delete(n.original)) : (!n && e.setMap.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.setMap.delete(t));
  },
  clear() {
    if (!this.size)
      return;
    const t = Qt(this);
    si(t), Bl(t);
    for (const e of t.original)
      t.assignedMap.set(e, !1);
    t.setMap.clear();
  },
  values() {
    const t = Qt(this);
    si(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.values(),
      next: S6(t, e, { isValuesIterator: !0 })
    };
  },
  entries() {
    const t = Qt(this);
    si(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.entries(),
      next: S6(t, e, {
        isValuesIterator: !1
      })
    };
  },
  keys() {
    return this.values();
  },
  [BC]() {
    return this.values();
  },
  forEach(t, e) {
    const n = this.values();
    let r = n.next();
    for (; !r.done; )
      t.call(e, r.value, r.value, this), r = n.next();
  }
};
Set.prototype.difference && Object.assign(rE, {
  intersection(t) {
    return Set.prototype.intersection.call(new Set(this.values()), t);
  },
  union(t) {
    return Set.prototype.union.call(new Set(this.values()), t);
  },
  difference(t) {
    return Set.prototype.difference.call(new Set(this.values()), t);
  },
  symmetricDifference(t) {
    return Set.prototype.symmetricDifference.call(new Set(this.values()), t);
  },
  isSubsetOf(t) {
    return Set.prototype.isSubsetOf.call(new Set(this.values()), t);
  },
  isSupersetOf(t) {
    return Set.prototype.isSupersetOf.call(new Set(this.values()), t);
  },
  isDisjointFrom(t) {
    return Set.prototype.isDisjointFrom.call(new Set(this.values()), t);
  }
});
const R_e = Reflect.ownKeys(rE), UZ = {
  get(t, e, n) {
    var r, s;
    const o = (r = t.copy) === null || r === void 0 ? void 0 : r[e];
    if (o && t.finalities.draftsCache.has(o))
      return o;
    if (e === LZ)
      return t;
    let i;
    if (t.options.mark) {
      const l = e === "size" && (t.original instanceof Map || t.original instanceof Set) ? Reflect.get(t.original, e) : Reflect.get(t.original, e, n);
      if (i = t.options.mark(l, ga), i === ga.mutable)
        return t.options.strict && nE(l, t.options, !0), l;
    }
    const a = oa(t);
    if (a instanceof Map && j_e.includes(e))
      return e === "size" ? Object.getOwnPropertyDescriptor(sN, "size").get.call(t.proxy) : sN[e].bind(t.proxy);
    if (a instanceof Set && R_e.includes(e))
      return e === "size" ? Object.getOwnPropertyDescriptor(rE, "size").get.call(t.proxy) : rE[e].bind(t.proxy);
    if (!ax(a, e)) {
      const l = x6(a, e);
      return l ? "value" in l ? l.value : (
        // !case: support for getter
        (s = l.get) === null || s === void 0 ? void 0 : s.call(t.proxy)
      ) : void 0;
    }
    const c = a[e];
    if (t.options.strict && nE(c, t.options), t.finalized || !sl(c, t.options))
      return c;
    if (c === eM(t.original, e)) {
      if (si(t), t.copy[e] = CL({
        original: t.original[e],
        parentDraft: t,
        key: t.type === 1 ? Number(e) : e,
        finalities: t.finalities,
        options: t.options
      }), typeof i == "function") {
        const l = Qt(t.copy[e]);
        return si(l), Bl(l), l.copy;
      }
      return t.copy[e];
    }
    return Mf(c) && t.finalities.draftsCache.add(c), c;
  },
  set(t, e, n) {
    var r;
    if (t.type === 3 || t.type === 2)
      throw new Error("Map/Set draft does not support any property assignment.");
    let s;
    if (t.type === 1 && e !== "length" && !(Number.isInteger(s = Number(e)) && s >= 0 && (e === 0 || s === 0 || String(s) === String(e))))
      throw new Error("Only supports setting array indices and the 'length' property.");
    const o = x6(oa(t), e);
    if (o != null && o.set)
      return o.set.call(t.proxy, n), !0;
    const i = eM(oa(t), e), a = Qt(i);
    return a && Yd(a.original, n) ? (t.copy[e] = n, t.assignedMap = (r = t.assignedMap) !== null && r !== void 0 ? r : /* @__PURE__ */ new Map(), t.assignedMap.set(e, !1), !0) : (Yd(n, i) && (n !== void 0 || ax(t.original, e)) || (si(t), Bl(t), ax(t.original, e) && Yd(n, t.original[e]) ? t.assignedMap.delete(e) : t.assignedMap.set(e, !0), t.copy[e] = n, SL(t, e, n, Zx)), !0);
  },
  has(t, e) {
    return e in oa(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(oa(t));
  },
  getOwnPropertyDescriptor(t, e) {
    const n = oa(t), r = Reflect.getOwnPropertyDescriptor(n, e);
    return r && {
      writable: !0,
      configurable: t.type !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: n[e]
    };
  },
  getPrototypeOf(t) {
    return Reflect.getPrototypeOf(t.original);
  },
  setPrototypeOf() {
    throw new Error("Cannot call 'setPrototypeOf()' on drafts");
  },
  defineProperty() {
    throw new Error("Cannot call 'defineProperty()' on drafts");
  },
  deleteProperty(t, e) {
    var n;
    return t.type === 1 ? UZ.set.call(this, t, e, void 0, t.proxy) : (eM(t.original, e) !== void 0 || e in t.original ? (si(t), Bl(t), t.assignedMap.set(e, !1)) : (t.assignedMap = (n = t.assignedMap) !== null && n !== void 0 ? n : /* @__PURE__ */ new Map(), t.assignedMap.delete(e)), t.copy && delete t.copy[e], !0);
  }
};
function CL(t) {
  const { original: e, parentDraft: n, key: r, finalities: s, options: o } = t, i = sg(e), a = {
    type: i,
    finalized: !1,
    parent: n,
    original: e,
    copy: null,
    proxy: null,
    finalities: s,
    options: o,
    // Mapping of draft Set items to their corresponding draft values.
    setMap: i === 3 ? new Map(e.entries()) : void 0
  };
  (r || "key" in t) && (a.key = r);
  const { proxy: c, revoke: l } = Proxy.revocable(i === 1 ? Object.assign([], a) : a, UZ);
  if (s.revoke.push(l), a.proxy = c, n) {
    const d = n;
    d.finalities.draft.push((u, f) => {
      var p, g;
      const y = Qt(c);
      let m = d.type === 3 ? d.setMap : d.copy;
      const v = tu(m, r), b = Qt(v);
      if (b) {
        let x = b.original;
        b.operated && (x = xL(v)), nN(b), rN(b, Zx, u, f), d.options.enableAutoFreeze && (d.options.updatedValues = (p = d.options.updatedValues) !== null && p !== void 0 ? p : /* @__PURE__ */ new WeakMap(), d.options.updatedValues.set(x, b.original)), D0(m, r, x);
      }
      (g = y.callbacks) === null || g === void 0 || g.forEach((x) => {
        x(u, f);
      });
    });
  } else {
    const d = Qt(c);
    d.finalities.draft.push((u, f) => {
      nN(d), rN(d, Zx, u, f);
    });
  }
  return c;
}
yL.createDraft = CL;
function $_e(t, e, n, r, s) {
  var o;
  const i = Qt(t), a = (o = i == null ? void 0 : i.original) !== null && o !== void 0 ? o : t, c = !!e.length;
  if (i != null && i.operated)
    for (; i.finalities.draft.length > 0; )
      i.finalities.draft.pop()(n, r);
  const l = c ? e[0] : i ? i.operated ? i.copy : i.original : t;
  return i && tN(i), s && Yg(l, l, i == null ? void 0 : i.options.updatedValues), [
    l,
    n && c ? [{ op: Nr.Replace, path: [], value: e[0] }] : n,
    r && c ? [{ op: Nr.Replace, path: [], value: a }] : r
  ];
}
function L_e(t, e) {
  var n;
  const r = {
    draft: [],
    revoke: [],
    handledSet: /* @__PURE__ */ new WeakSet(),
    draftsCache: /* @__PURE__ */ new WeakSet()
  };
  let s, o;
  e.enablePatches && (s = [], o = []);
  const a = ((n = e.mark) === null || n === void 0 ? void 0 : n.call(e, t, ga)) === ga.mutable || !sl(t, e) ? t : CL({
    original: t,
    parentDraft: null,
    finalities: r,
    options: e
  });
  return [
    a,
    (c = []) => {
      const [l, d, u] = $_e(a, c, s, o, e.enableAutoFreeze);
      return e.enablePatches ? [l, d, u] : l;
    }
  ];
}
function oN(t) {
  const { rootDraft: e, value: n, useRawReturn: r = !1, isRoot: s = !0 } = t;
  wL(n, (o, i, a) => {
    const c = Qt(i);
    if (c && e && c.finalities === e.finalities) {
      t.isContainDraft = !0;
      const l = c.original;
      if (a instanceof Set) {
        const d = Array.from(a);
        a.clear(), d.forEach((u) => a.add(o === u ? l : u));
      } else
        D0(a, o, l);
    } else typeof i == "object" && i !== null && (t.value = i, t.isRoot = !1, oN(t));
  }), s && (t.isContainDraft || console.warn("The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance."), r && console.warn("The return value contains drafts, please don't use 'rawReturn()' to wrap the return value."));
}
function HZ(t) {
  var e;
  const n = Qt(t);
  if (!sl(t, n == null ? void 0 : n.options))
    return t;
  const r = sg(t);
  if (n && !n.operated)
    return n.original;
  let s;
  function o() {
    s = r === 2 ? bL(t) ? new Map(t) : new (Object.getPrototypeOf(t)).constructor(t) : r === 3 ? Array.from(n.setMap.values()) : BZ(t, n == null ? void 0 : n.options);
  }
  if (n) {
    n.finalized = !0;
    try {
      o();
    } finally {
      n.finalized = !1;
    }
  } else
    s = t;
  if (wL(s, (i, a) => {
    if (n && Yd(tu(n.original, i), a))
      return;
    const c = HZ(a);
    c !== a && (s === t && o(), D0(s, i, c));
  }), r === 3) {
    const i = (e = n == null ? void 0 : n.original) !== null && e !== void 0 ? e : s;
    return vL(i) ? new Set(s) : new (Object.getPrototypeOf(i)).constructor(s);
  }
  return s;
}
function C6(t) {
  if (!Mf(t))
    throw new Error(`current() is only used for Draft, parameter: ${t}`);
  return HZ(t);
}
const F_e = (t) => function e(n, r, s) {
  var o, i, a;
  if (typeof n == "function" && typeof r != "function")
    return function(S, ...C) {
      return e(S, (_) => n.call(this, _, ...C), r);
    };
  const c = n, l = r;
  let d = s;
  if (typeof r != "function" && (d = r), d !== void 0 && Object.prototype.toString.call(d) !== "[object Object]")
    throw new Error(`Invalid options: ${d}, 'options' should be an object.`);
  d = Object.assign(Object.assign({}, t), d);
  const u = Mf(c) ? C6(c) : c, f = Array.isArray(d.mark) ? (S, C) => {
    for (const _ of d.mark) {
      if (typeof _ != "function")
        throw new Error(`Invalid mark: ${_}, 'mark' should be a function.`);
      const E = _(S, C);
      if (E)
        return E;
    }
  } : d.mark, p = (o = d.enablePatches) !== null && o !== void 0 ? o : !1, g = (i = d.strict) !== null && i !== void 0 ? i : !1, m = {
    enableAutoFreeze: (a = d.enableAutoFreeze) !== null && a !== void 0 ? a : !1,
    mark: f,
    strict: g,
    enablePatches: p
  };
  if (!sl(u, m) && typeof u == "object" && u !== null)
    throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
  const [v, b] = L_e(u, m);
  if (typeof r != "function") {
    if (!sl(u, m))
      throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
    return [v, b];
  }
  let x;
  try {
    x = l(v);
  } catch (S) {
    throw tN(Qt(v)), S;
  }
  const w = (S) => {
    const C = Qt(v);
    if (!Mf(S)) {
      if (S !== void 0 && !Yd(S, v) && (C != null && C.operated))
        throw new Error("Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.");
      const E = S == null ? void 0 : S[T_e];
      if (E) {
        const M = E[0];
        return m.strict && typeof S == "object" && S !== null && oN({
          rootDraft: C,
          value: S,
          useRawReturn: !0
        }), b([M]);
      }
      if (S !== void 0)
        return typeof S == "object" && S !== null && oN({ rootDraft: C, value: S }), b([S]);
    }
    if (S === v || S === void 0)
      return b([]);
    const _ = Qt(S);
    if (m === _.options) {
      if (_.operated)
        throw new Error("Cannot return a modified child draft.");
      return b([C6(S)]);
    }
    return b([S]);
  };
  return x instanceof Promise ? x.then(w, (S) => {
    throw tN(Qt(v)), S;
  }) : w(x);
}, sE = F_e();
Object.prototype.constructor.toString();
function VZ(t, e) {
  const n = Object.keys(t), r = Object.keys(e);
  return n.length === r.length && Object.keys(t).every((s) => e.hasOwnProperty(s));
}
function _6(t, e) {
  return Object.keys(t).length === Object.keys(e).length && Object.keys(t).every((n) => e.hasOwnProperty(n) && t[n] === e[n]);
}
function UC(t, e) {
  return typeof t != "object" || typeof e != "object" || t === null || e === null ? t === e : VZ(t, e) ? Object.keys(t).every((n) => UC(t[n], e[n])) : !1;
}
function _L(t) {
  if (!Tb(t))
    return t;
  const e = {};
  for (const [n, r] of Object.entries(t))
    r !== void 0 && (e[n] = r);
  return e;
}
function WZ(t, e) {
  if (!Tb(t) || !Tb(e))
    return e;
  const n = { ...t };
  for (const r of Object.keys(e)) {
    if (e[r] === void 0)
      continue;
    if (e[r] === null) {
      delete n[r];
      continue;
    }
    const s = Tb(t[r]) && Tb(e[r]);
    n[r] = s ? WZ(t[r], e[r]) : e[r];
  }
  return n;
}
function Tb(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function B_e(t, e, n) {
  if (!t || e.length === 0)
    return;
  let r = t || {};
  for (let o = 0; o < e.length - 1; o++) {
    const i = e[o];
    (!(i in r) || typeof r[i] != "object") && (r[i] = typeof e[o + 1] == "number" ? [] : {}), r = r[i];
  }
  const s = e[e.length - 1];
  Array.isArray(r) && typeof s == "number" ? r.splice(s, 0, n) : r[s] = n;
}
function E6(t, e, n) {
  if (!t || e.length === 0)
    return;
  let r = t || {};
  for (let s = 0; s < e.length - 1; s++) {
    const o = e[s];
    (!(o in r) || typeof r[o] != "object") && (r[o] = typeof e[s + 1] == "number" ? [] : {}), r = r[o];
  }
  r[e[e.length - 1]] = n;
}
function KZ(t, e) {
  if (!t || e.length === 0)
    return;
  const [n, ...r] = e;
  if (n in t) {
    if (r.length === 0) {
      Array.isArray(t) ? t.splice(n, 1) : delete t[n];
      return;
    }
    KZ(t[n], r), z_e(t[n]) && delete t[n];
  }
}
function z_e(t) {
  return t && Object.keys(t).length === 0;
}
const T6 = /ZULU|YEKT|YEKST|YAPT|YAKT|YAKST|XJT|WGT|WGST|WFT|WETDST|WET|WDT|WAT|WAST|WAKT|WADT|VUT|VOLT|VLAT|VLAST|VET|UZT|UZST|UYT|UYST|UTC|UT|ULAT|ULAST|UCT|TVT|TRUT|TOT|TMT|TKT|TJT|TFT|TAHT|SGT|SCT|SAST|SADT|RET|PYT|PYST|PWT|PST|PONT|PMST|PMDT|PKT|PKST|PHT|PGT|PETT|PETST|PET|PDT|OMST|OMSST|NZT|NZST|NZDT|NUT|NST|NPT|NOVT|NOVST|NFT|NDT|MYT|MVT|MUT|MUST|MST|MSK|MSD|MPT|MMT|MHT|MEZ|METDST|MET|MESZ|MEST|MDT|MAWT|MART|MAGT|MAGST|LKT|LINT|LIGT|LHST|LHDT|KST|KRAT|KRAST|KOST|KGT|KGST|KDT|JST|JAYT|IST|IRT|IRKT|IRKST|IOT|IDT|ICT|HST|HKT|GYT|GMT|GILT|GFT|GET|GEST|GAMT|GALT|FNT|FNST|FKT|FKST|FJT|FJST|FET|EST|EGT|EGST|EETDST|EET|EEST|EDT|EAT|EAST|EASST|DDUT|DAVT|CXT|CST|COT|CLT|CLST|CKT|CHUT|CHAST|CHADT|CETDST|CET|CEST|CDT|CCT|CAST|CADT|BTT|BST|BRT|BRST|BRA|BOT|BORT|BNT|BDT|BDST|AZT|AZST|AZOT|AZOST|AWST|AWSST|AST|ART|ARST|ANAT|ANAST|AMT|AMST|ALMT|ALMST|AKST|AKDT|AFT|AEST|AESST|AEDT|ADT|ACWST|ACT|ACST|ACSST|ACDT$/, U_e = {
  ZULU: 0,
  YEKT: 18e3,
  YEKST: 21600,
  YAPT: 36e3,
  YAKT: 32400,
  YAKST: 32400,
  XJT: 21600,
  WGT: -10800,
  WGST: -7200,
  WFT: 43200,
  WETDST: 3600,
  WET: 0,
  WDT: 32400,
  WAT: 3600,
  WAST: 25200,
  WAKT: 43200,
  WADT: 28800,
  VUT: 39600,
  VOLT: 10800,
  VLAT: 36e3,
  VLAST: 36e3,
  VET: -14400,
  UZT: 18e3,
  UZST: 21600,
  UYT: -10800,
  UYST: -7200,
  UTC: 0,
  UT: 0,
  ULAT: 28800,
  ULAST: 32400,
  UCT: 0,
  TVT: 43200,
  TRUT: 36e3,
  TOT: 46800,
  TMT: 18e3,
  TKT: 46800,
  TJT: 18e3,
  TFT: 18e3,
  TAHT: -36e3,
  SGT: 28800,
  SCT: 14400,
  SAST: 7200,
  SADT: 37800,
  RET: 14400,
  PYT: -14400,
  PYST: -10800,
  PWT: 32400,
  PST: -28800,
  PONT: 39600,
  PMST: -10800,
  PMDT: -7200,
  PKT: 18e3,
  PKST: 21600,
  PHT: 28800,
  PGT: 36e3,
  PETT: 43200,
  PETST: 43200,
  PET: -18e3,
  PDT: -25200,
  OMST: 21600,
  OMSST: 21600,
  NZT: 43200,
  NZST: 43200,
  NZDT: 46800,
  NUT: -39600,
  NST: -12600,
  NPT: 20700,
  NOVT: 25200,
  NOVST: 25200,
  NFT: -12600,
  NDT: -9e3,
  MYT: 28800,
  MVT: 18e3,
  MUT: 14400,
  MUST: 18e3,
  MST: -25200,
  MSK: 10800,
  MSD: 14400,
  MPT: 36e3,
  MMT: 23400,
  MHT: 43200,
  MEZ: 3600,
  METDST: 7200,
  MET: 3600,
  MESZ: 7200,
  MEST: 7200,
  MDT: -21600,
  MAWT: 18e3,
  MART: -34200,
  MAGT: 39600,
  MAGST: 39600,
  LKT: 19800,
  LINT: 50400,
  LIGT: 36e3,
  LHST: 37800,
  LHDT: 37800,
  KST: 32400,
  KRAT: 25200,
  KRAST: 25200,
  KOST: 39600,
  KGT: 21600,
  KGST: 21600,
  KDT: 36e3,
  JST: 32400,
  JAYT: 32400,
  IST: 7200,
  IRT: 12600,
  IRKT: 28800,
  IRKST: 28800,
  IOT: 21600,
  IDT: 10800,
  ICT: 25200,
  HST: -36e3,
  HKT: 28800,
  GYT: -14400,
  GMT: 0,
  GILT: 43200,
  GFT: -10800,
  GET: 14400,
  GEST: 14400,
  GAMT: -32400,
  GALT: -21600,
  FNT: -7200,
  FNST: -3600,
  FKT: -10800,
  FKST: -10800,
  FJT: 43200,
  FJST: 46800,
  FET: 10800,
  EST: -18e3,
  EGT: -3600,
  EGST: 0,
  EETDST: 10800,
  EET: 7200,
  EEST: 10800,
  EDT: -14400,
  EAT: 10800,
  EAST: -21600,
  EASST: -21600,
  DDUT: 36e3,
  DAVT: 25200,
  CXT: 25200,
  CST: -21600,
  COT: -18e3,
  CLT: -14400,
  CLST: -10800,
  CKT: -36e3,
  CHUT: 36e3,
  CHAST: 45900,
  CHADT: 49500,
  CETDST: 7200,
  CET: 3600,
  CEST: 7200,
  CDT: -18e3,
  CCT: 28800,
  CAST: 34200,
  CADT: 37800,
  BTT: 21600,
  BST: 3600,
  BRT: -10800,
  BRST: -7200,
  BRA: -10800,
  BOT: -14400,
  BORT: 28800,
  BNT: 28800,
  BDT: 21600,
  BDST: 7200,
  AZT: 14400,
  AZST: 14400,
  AZOT: -3600,
  AZOST: 0,
  AWST: 28800,
  AWSST: 32400,
  AST: -14400,
  ART: -10800,
  ARST: -10800,
  ANAT: 43200,
  ANAST: 43200,
  AMT: -14400,
  AMST: 14400,
  ALMT: 21600,
  ALMST: 25200,
  AKST: -32400,
  AKDT: -28800,
  AFT: 16200,
  AEST: 36e3,
  AESST: 39600,
  AEDT: 39600,
  ADT: -10800,
  ACWST: 31500,
  ACT: -18e3,
  ACST: 34200,
  ACSST: 37800,
  ACDT: 37800
};
function H_e(t) {
  return new Date(t);
}
function V_e(t) {
  return /* @__PURE__ */ new Date(t + "Z");
}
const W_e = /^(\d+)[\./-](\d+)[\./-](\d+)$/;
function K_e(t) {
  const e = t.match(W_e);
  if (!e)
    return null;
  const [n, r, s, o] = e;
  return r <= 0 || s <= 0 || o <= 0 ? null : r > 999 ? new Date(Date.UTC(r, s - 1, o, 0, 0, 0, 0)) : new Date(Date.UTC(o, r - 1, s, 0, 0, 0, 0));
}
function G_e(t) {
  const [e, n] = t.split(" ");
  return /* @__PURE__ */ new Date(e + "T" + n + "Z");
}
function Y_e(t) {
  const [e, n] = t.split(" ");
  return /* @__PURE__ */ new Date(e + "T" + n + "Z");
}
function q_e(t) {
  return new Date(t);
}
function X_e(t) {
  const e = /^(\w{3}) (\w{3}) (\d{2}) (\d{4})$/;
  if (!t.match(e))
    throw new Error(`Unable to parse \`${t}\` as a date.`);
  const r = /* @__PURE__ */ new Date(t + " UTC");
  return new Date(Date.UTC(r.getUTCFullYear(), r.getUTCMonth(), r.getUTCDate(), 0, 0, 0, 0));
}
function Z_e(t) {
  const e = /^(.+T.+)([+-])(\d{2})$/, n = t.match(e);
  if (n) {
    const [, r, s, o] = n, i = `${r}${s}${o}:00`;
    return new Date(i);
  }
  return null;
}
function Q_e(t) {
  const e = /^(\d+)-(\d{1,2})-(\d{1,2})([ T])(.+)$/, n = t.match(e);
  if (n) {
    const [, r, s, o, i, a] = n, c = s.padStart(2, "0"), l = o.padStart(2, "0"), d = `${r}-${c}-${l}T${a}`;
    return new Date(d);
  }
  return null;
}
function J_e(t) {
  const [e, n] = t.split(", "), [r, s, o] = e.split("/").map(Number), i = n.match(/(\d{1,2}):(\d{2}):(\d{2}) (AM|PM)/);
  if (!i)
    throw new Error(`Unable to parse time from: ${t}`);
  let [, a, c, l, d] = i;
  return a = Number(a), c = Number(c), l = Number(l), d === "PM" && a !== 12 ? a += 12 : d === "AM" && a === 12 && (a = 0), new Date(Date.UTC(o, r - 1, s, a, c, l));
}
function eEe(t) {
  switch (t) {
    case "epoch":
      return /* @__PURE__ */ new Date(0);
    case "infinity":
    case "-infinity":
    case "today":
    case "tomorrow":
    case "yesterday":
      return null;
  }
}
function tEe(t) {
  const e = t.match(T6);
  if (!e)
    return null;
  const [n] = e, r = U_e[n], s = new Date(t.replace(T6, "Z"));
  return new Date(s.getTime() - r * 1e3);
}
const nEe = [
  K_e,
  Y_e,
  X_e,
  J_e,
  q_e,
  V_e,
  Z_e,
  G_e,
  H_e,
  eEe,
  tEe,
  Q_e
];
function rEe(t, e) {
  try {
    const n = t(e);
    return n instanceof Date && !isNaN(n.getTime()) ? n : null;
  } catch {
    return null;
  }
}
function iN(t) {
  for (const e of nEe) {
    const n = rEe(e, t);
    if (n)
      return n;
  }
  return null;
}
function sEe(t) {
  try {
    const e = JSON.parse(t);
    return typeof e == "string" ? iN(e) : null;
  } catch {
    return null;
  }
}
function oI(t) {
  if (t !== void 0) {
    if (t === null)
      return null;
    if (t instanceof Date)
      return t;
    if (typeof t == "string") {
      const e = iN(t) || sEe(t) || iN(t.trim());
      if (!e)
        throw new Error(`Unable to parse \`${t}\` as a date.`);
      return e;
    } else if (typeof t == "number")
      return new Date(t);
    throw new Error(`Invalid date value \`${t}\`. Expected a date, number, or string, got type ${typeof t}.`);
  }
}
class sp {
  constructor(e, n) {
    P(this, "attrs");
    P(this, "linkIndex");
    P(this, "_blobAttrs", null);
    P(this, "_primaryKeys", null);
    P(this, "_forwardIdents", null);
    P(this, "_revIdents", null);
    this.attrs = e, this.linkIndex = n;
  }
  resetAttrIndexes() {
    this._blobAttrs = null, this._primaryKeys = null, this._forwardIdents = null, this._revIdents = null;
  }
  addAttr(e) {
    this.attrs[e.id] = e, this.resetAttrIndexes();
  }
  deleteAttr(e) {
    delete this.attrs[e], this.resetAttrIndexes();
  }
  updateAttr(e) {
    const n = this.attrs[e.id];
    n && (this.attrs[e.id] = { ...n, ...e }, this.resetAttrIndexes());
  }
  getAttr(e) {
    return this.attrs[e];
  }
  get blobAttrs() {
    if (this._blobAttrs)
      return this._blobAttrs;
    this._blobAttrs = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs))
      if (TL(e)) {
        const [n, r, s] = e["forward-identity"];
        ji(this.blobAttrs, [r, s], e);
      }
    return this._blobAttrs;
  }
  get primaryKeys() {
    if (this._primaryKeys)
      return this._primaryKeys;
    this._primaryKeys = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs))
      if (e["primary?"]) {
        const [n, r] = e["forward-identity"];
        ji(this._primaryKeys, [r], e);
      }
    return this._primaryKeys;
  }
  get forwardIdents() {
    if (this._forwardIdents)
      return this._forwardIdents;
    this._forwardIdents = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs)) {
      const n = e["forward-identity"], [r, s, o] = n;
      ji(this._forwardIdents, [s, o], e);
    }
    return this._forwardIdents;
  }
  get revIdents() {
    if (this._revIdents)
      return this._revIdents;
    this._revIdents = /* @__PURE__ */ new Map();
    for (const e of Object.values(this.attrs)) {
      const n = e["reverse-identity"];
      if (n) {
        const [r, s, o] = n;
        ji(this._revIdents, [s, o], e);
      }
    }
    return this._revIdents;
  }
  toJSON() {
    return { attrs: this.attrs, linkIndex: this.linkIndex };
  }
}
function oEe(t) {
  return t.cardinality === "one";
}
function EL(t) {
  return t["value-type"] === "ref";
}
function TL(t) {
  return t["value-type"] === "blob";
}
function Jy(t, e) {
  return e.reduce((n, r) => n && n.get(r), t);
}
function Ac(t, e) {
  if (e.length === 0)
    throw new Error("path must have at least one element");
  if (e.length === 1) {
    t.delete(e[0]);
    return;
  }
  const [n, ...r] = e;
  t.has(n) && Ac(t.get(n), r);
}
function ji(t, e, n) {
  let r = t;
  const s = e.length - 1;
  for (let o = 0; o < s; o++) {
    const i = e[o];
    let a = r.get(i);
    a === void 0 && (a = /* @__PURE__ */ new Map(), r.set(i, a)), r = a;
  }
  s > -1 && r.set(e[s], n);
}
function GZ(t, e, n) {
  const r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const i of e) {
    let [a, c, l] = i;
    const d = t.getAttr(c);
    if (!d) {
      console.warn("no such attr", c, a);
      continue;
    }
    d["checked-data-type"] === "date" && n && (l = oI(l), i[2] = l), EL(d) && ji(o, [l, c, a], i), ji(r, [a, c, l], i), ji(s, [c, a, l], i);
  }
  return { eav: r, aev: s, vae: o };
}
function YZ(t) {
  return {
    triples: Ri(t.eav, 3),
    cardinalityInference: t.cardinalityInference,
    useDateObjects: t.useDateObjects,
    version: 1
  };
}
function qZ(t, e) {
  return Pb(t, e.triples, e.cardinalityInference, e.useDateObjects);
}
function XZ(t, e) {
  if (t)
    return new sp(t.attrs, t.linkIndex);
  if (e && "__type" in e)
    return new sp(e.attrs, e.linkIndex);
}
function iEe(t, e) {
  return Jy(t.eav, [e]) !== void 0;
}
function Pb(t, e, n, r) {
  const s = GZ(t, e, r);
  return s.cardinalityInference = n, s.useDateObjects = r, s;
}
function N0(t, e) {
  var s, o;
  let n;
  if (Array.isArray(e[0])) {
    const [i, a] = e[0], c = t.aev.get(i);
    if (!c)
      return null;
    n = (s = Ri(c, 2).find((d) => d[2] === a)) == null ? void 0 : s[0];
  } else
    n = e[0];
  if (!n)
    return null;
  const r = e[2];
  if (Array.isArray(r) && r.length === 2 && t.aev.get(r[0])) {
    const [i, a] = r, c = t.aev.get(i);
    if (!c)
      return null;
    const d = (o = Ri(c, 2).find((y) => y[2] === a)) == null ? void 0 : o[0];
    if (!d)
      return null;
    const [u, f, p, ...g] = e;
    return [n, f, d, ...g];
  } else {
    const [i, ...a] = e;
    return [n, ...a];
  }
}
function ZZ(t, e, n) {
  const r = N0(t, n);
  if (!r)
    return;
  const [s, o, i] = r, a = e.getAttr(o);
  a && (Ac(t.eav, [s, o, i]), Ac(t.aev, [o, s, i]), EL(a) && Ac(t.vae, [i, o, s]));
}
let aEe = 0;
function QZ(t, e, n) {
  const [r, s, o] = n;
  let i;
  const a = Jy(t.eav, [r, s, o]);
  return a && (i = a[3]), i || Date.now() * 10 + aEe++;
}
function JZ(t, e, n) {
  const r = N0(t, n);
  if (!r)
    return;
  let [s, o, i] = r;
  const a = e.getAttr(o);
  if (!a)
    return;
  a["checked-data-type"] === "date" && t.useDateObjects && (i = oI(i));
  const c = Jy(t.eav, [s, o, i]), l = (c == null ? void 0 : c[3]) ?? QZ(t, a, r), d = [s, o, i, l];
  oEe(a) ? (ji(t.eav, [s, o], /* @__PURE__ */ new Map([[i, d]])), ji(t.aev, [o, s], /* @__PURE__ */ new Map([[i, d]]))) : (ji(t.eav, [s, o, i], d), ji(t.aev, [o, s, i], d)), EL(a) && ji(t.vae, [i, o, s], d);
}
function cEe(t, e, n) {
  var p;
  const r = N0(t, n);
  if (!r)
    return;
  const [s, o, i] = r, a = e.getAttr(o);
  if (!a)
    return;
  if (!TL(a))
    throw new Error("merge operation is not supported for links");
  const c = Jy(t.eav, [s, o]);
  if (!c)
    return;
  const l = (p = c.values().next()) == null ? void 0 : p.value;
  if (!l)
    return;
  const d = l[2], u = WZ(d, i), f = [
    s,
    o,
    u,
    QZ(t, a, l)
  ];
  ji(t.eav, [s, o], /* @__PURE__ */ new Map([[u, f]])), ji(t.aev, [o, s], /* @__PURE__ */ new Map([[u, f]]));
}
function aN(t, e, n) {
  var l, d;
  const [r, s] = n, o = N0(t, [r]);
  if (!o)
    return;
  const [i] = o, a = t.eav.get(i);
  if (a) {
    for (const u of a.keys()) {
      const f = e.getAttr(u);
      f && f["on-delete-reverse"] === "cascade" && Ri(a.get(u), 1).forEach(([p, g, y]) => {
        var m;
        return aN(t, e, [y, (m = f["reverse-identity"]) == null ? void 0 : m[1]]);
      }), // Fall back to deleting everything if we've rehydrated tx-steps from
      // the store that didn't set `etype` in deleteEntity
      (!s || // If we don't know about the attr, let's just get rid of it
      !f || // Make sure it matches the etype
      ((l = f["forward-identity"]) == null ? void 0 : l[1]) === s) && (Ac(t.aev, [u, i]), Ac(t.eav, [i, u]));
    }
    a.size === 0 && Ac(t.eav, [i]);
  }
  const c = t.vae.get(i) && Ri(t.vae.get(i), 2);
  c && c.forEach((u) => {
    var m, v, b;
    const [f, p, g] = u, y = e.getAttr(p);
    (!s || !y || ((m = y["reverse-identity"]) == null ? void 0 : m[1]) === s) && (Ac(t.eav, [f, p, g]), Ac(t.aev, [p, f, g]), Ac(t.vae, [g, p, f])), y && y["on-delete"] === "cascade" && ((v = y["reverse-identity"]) == null ? void 0 : v[1]) === s && aN(t, e, [f, (b = y["forward-identity"]) == null ? void 0 : b[1]]);
  }), ((d = t.vae.get(i)) == null ? void 0 : d.size) === 0 && Ac(t.vae, [i]);
}
function eQ(t, e, n) {
  const r = GZ(e, n, t.useDateObjects);
  Object.keys(r).forEach((s) => {
    t[s] = r[s];
  });
}
function lEe(t, [e]) {
  t.addAttr(e);
}
function tQ(t) {
  return Ri(t.eav, 3);
}
function dEe(t, e, [n]) {
  if (!e.getAttr(n))
    return;
  const r = tQ(t).filter(([s, o]) => o !== n);
  e.deleteAttr(n), eQ(t, e, r);
}
function uEe(t, e, [n]) {
  e.getAttr(n.id) && (e.updateAttr(n), eQ(t, e, tQ(t)));
}
function fEe(t, e, n) {
  const [r, ...s] = n;
  switch (r) {
    case "add-triple":
      JZ(t, e, s);
      break;
    case "deep-merge-triple":
      cEe(t, e, s);
      break;
    case "retract-triple":
      ZZ(t, e, s);
      break;
    case "delete-entity":
      aN(t, e, s);
      break;
    case "add-attr":
      lEe(e, s);
      break;
    case "delete-attr":
      dEe(t, e, s);
      break;
    case "update-attr":
      uEe(t, e, s);
      break;
    case "restore-attr":
      break;
    case "rule-params":
      break;
    default:
      throw new Error(`unhandled transaction action: ${r}`);
  }
}
function Ri(t, e, n = []) {
  if (!t || e === 0)
    return n;
  if (e === 1) {
    for (const r of t.values())
      n.push(r);
    return n;
  }
  for (const r of t.values())
    Ri(r, e - 1, n);
  return n;
}
function i1(t, e, n) {
  var o;
  const r = [];
  if (n != null && n.hasOwnProperty("$not")) {
    for (const i of e.keys())
      n.$not !== i && r.push(e.get(i));
    return r;
  }
  if (n != null && n.hasOwnProperty("$isNull")) {
    const { attrId: i, isNull: a, reverse: c } = n.$isNull;
    if (c)
      for (const l of e.keys()) {
        const d = t.vae.get(l), u = !d || !d.get(i);
        (a ? u : !u) && r.push(e.get(l));
      }
    else {
      const l = t.aev.get(i);
      for (const d of e.keys()) {
        const u = !l || ((o = l.get(d)) == null ? void 0 : o.get(null)) || !l.get(d);
        (a ? u : !u) && r.push(e.get(d));
      }
    }
    return r;
  }
  if (n != null && n.$comparator)
    return Ri(e, 1).filter(n.$op);
  const s = n.in || n.$in || [n];
  for (const i of s) {
    const a = e.get(i);
    a && r.push(a);
  }
  return r;
}
function hEe(t, e, n) {
  let r = "";
  return t !== void 0 && (r += "e"), e !== void 0 && (r += "a"), n !== void 0 && (r += "v"), r;
}
function pEe(t, [e, n, r]) {
  var o, i;
  switch (hEe(e, n, r)) {
    case "e": {
      const a = t.eav.get(e);
      return Ri(a, 2);
    }
    case "ea": {
      const a = (o = t.eav.get(e)) == null ? void 0 : o.get(n);
      return Ri(a, 1);
    }
    case "eav": {
      const a = (i = t.eav.get(e)) == null ? void 0 : i.get(n);
      return a ? i1(t, a, r) : [];
    }
    case "ev": {
      const a = t.eav.get(e);
      if (!a)
        return [];
      const c = [];
      for (const l of a.values())
        c.push(...i1(t, l, r));
      return c;
    }
    case "a": {
      const a = t.aev.get(n);
      return Ri(a, 2);
    }
    case "av": {
      const a = t.aev.get(n);
      if (!a)
        return [];
      const c = [];
      for (const l of a.values())
        c.push(...i1(t, l, r));
      return c;
    }
    case "v": {
      const a = [];
      for (const c of t.eav.values())
        for (const l of c.values())
          a.push(...i1(t, l, r));
      return a;
    }
    default:
      return Ri(t.eav, 3);
  }
}
function gEe(t, e, n) {
  var s;
  const r = {};
  if (!e)
    return r;
  for (const [o, i] of e.entries()) {
    const a = (s = t.eav.get(n)) == null ? void 0 : s.get(i.id), c = Ri(a, 1);
    for (const l of c)
      r[o] = l[2];
  }
  return r;
}
function ls(t, e, n) {
  var r;
  return (r = t.forwardIdents.get(e)) == null ? void 0 : r.get(n);
}
function og(t, e, n) {
  var r;
  return (r = t.revIdents.get(e)) == null ? void 0 : r.get(n);
}
function mEe(t, e) {
  return t.blobAttrs.get(e);
}
function nQ(t, e) {
  var r;
  const n = t.primaryKeys.get(e);
  return n || ((r = t.forwardIdents.get(e)) == null ? void 0 : r.get("id"));
}
function yEe(t, e, n) {
  const r = N0(t, n);
  if (!r)
    return;
  const [s, o, i] = r;
  if (e.getAttr(o))
    return Jy(t.eav, [s, o]);
}
function vEe(t, e, n) {
  const r = n.filter(([s, o, i, a, c]) => {
    if (s !== "add-triple" && s !== "deep-merge-triple")
      return !0;
    const l = c == null ? void 0 : c.mode;
    if (l !== "create" && l !== "update")
      return !0;
    let d = !1;
    const u = e.getAttr(i);
    if (u) {
      const f = nQ(e, u["forward-identity"][1]);
      d = !!yEe(t, e, [
        o,
        f == null ? void 0 : f.id,
        o
      ]);
    }
    return !(l === "create" && d || l === "update" && !d);
  });
  return sE({ store: t, attrsStore: e }, (s) => {
    r.forEach((o) => {
      fEe(s.store, s.attrsStore, o);
    });
  }, {
    mark: (s) => {
      if (s instanceof sp)
        return "immutable";
    }
  });
}
function bEe(t) {
  return typeof t == "string" && t.startsWith("?");
}
function xEe(t, e, n) {
  if (n.hasOwnProperty(t)) {
    const r = n[t];
    return rQ(r, e, n);
  }
  return { ...n, [t]: e };
}
function P6(t, e, n) {
  return t === e ? n : null;
}
function wEe(t) {
  switch (typeof t) {
    case "string":
      return t.startsWith("?") ? xEe : P6;
    default:
      return P6;
  }
}
const SEe = [
  "in",
  "$in",
  "$not",
  "$isNull",
  "$comparator"
  // covers all of $gt, $lt, etc.
];
function CEe(t) {
  for (const e of SEe)
    if (t.hasOwnProperty(e))
      return !0;
  return !1;
}
function rQ(t, e, n) {
  return n ? typeof t == "object" ? CEe(t) ? n : null : wEe(t)(t, e, n) : null;
}
function _Ee(t, e, n) {
  return t.reduce((r, s, o) => {
    const i = e[o];
    return rQ(s, i, r);
  }, n);
}
function EEe(t, e, n) {
  return IEe(t, e, n).map((r) => _Ee(e, r, n)).filter((r) => r);
}
function TEe(t, e, n) {
  return e.or ? e.or.patterns.flatMap((r) => cN(t, r, n)) : e.and ? e.and.patterns.reduce((r, s) => cN(t, s, r), n) : n.flatMap((r) => EEe(t, e, r));
}
function cN(t, e, n = [{}]) {
  return e.reduce((r, s) => TEe(t, s, r), n);
}
function PL(t, e) {
  return Array.isArray(e) ? e.map((n) => PL(t, n)) : bEe(e) ? t[e] : e;
}
function PEe(t, { find: e, where: n }) {
  return cN(t, n).map((s) => PL(s, e));
}
function IEe(t, e, n) {
  return pEe(t, PL(n, e));
}
const kEe = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function Zm(t) {
  return typeof t == "string" && kEe.test(t);
}
const Ks = [];
for (let t = 0; t < 256; ++t)
  Ks.push((t + 256).toString(16).slice(1));
function AEe(t, e = 0) {
  return (Ks[t[e + 0]] + Ks[t[e + 1]] + Ks[t[e + 2]] + Ks[t[e + 3]] + "-" + Ks[t[e + 4]] + Ks[t[e + 5]] + "-" + Ks[t[e + 6]] + Ks[t[e + 7]] + "-" + Ks[t[e + 8]] + Ks[t[e + 9]] + "-" + Ks[t[e + 10]] + Ks[t[e + 11]] + Ks[t[e + 12]] + Ks[t[e + 13]] + Ks[t[e + 14]] + Ks[t[e + 15]]).toLowerCase();
}
let tM;
const MEe = new Uint8Array(16);
function OEe() {
  if (!tM) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    tM = crypto.getRandomValues.bind(crypto);
  }
  return tM(MEe);
}
const DEe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), I6 = { randomUUID: DEe };
function NEe(t, e, n) {
  var s;
  if (I6.randomUUID && !e && !t)
    return I6.randomUUID();
  t = t || {};
  const r = t.random ?? ((s = t.rng) == null ? void 0 : s.call(t)) ?? OEe();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, AEe(r);
}
function k6(t) {
  const e = t.replace(/-/g, ""), n = [];
  for (let r = 0; r < e.length; r += 2)
    n.push(parseInt(e.substring(r, r + 2), 16));
  return n;
}
function jEe(t, e) {
  for (let n = 0; n < t.length; n++) {
    if (t[n] < e[n])
      return -1;
    if (t[n] > e[n])
      return 1;
  }
  return 0;
}
function REe(t, e) {
  return jEe(k6(t), k6(e));
}
function Is() {
  return NEe();
}
function $Ee(t, e) {
  return t.localeCompare(e);
}
function LEe() {
  let t = $Ee;
  if (typeof Intl == "object" && Intl.hasOwnProperty("Collator"))
    try {
      t = Intl.Collator("en-US").compare;
    } catch {
    }
  return t;
}
const FEe = LEe();
let BEe = 0;
function cx(t) {
  return iI(`_${t}`, BEe++);
}
function iI(t, e) {
  return `?${t}-${e}`;
}
class Qm extends Error {
  constructor(e) {
    super(e), this.name = "AttrNotFoundError";
  }
}
function zEe(t, e) {
  const n = nQ(t, e);
  if (!n)
    throw new Qm(`Could not find id attr for ${e}`);
  return n;
}
function A6(t, e, n, r) {
  return [UEe(t, e, n, r)];
}
function UEe(t, e, n, r) {
  return [
    t(n, r),
    zEe(e, n).id,
    t(n, r),
    t("time", r)
  ];
}
function HEe(t, e, n) {
  return t.map((r) => r === e ? n : r);
}
function sQ(t, e, n, r, s) {
  const o = ls(e, n, s), i = og(e, n, s), a = o || i;
  if (!a)
    throw new Qm(`Could not find attr for ${[n, s]}`);
  if (a["value-type"] !== "ref")
    throw new Error(`Attr ${a.id} is not a ref`);
  const [c, l] = a["forward-identity"], [d, u] = a["reverse-identity"], f = r + 1, p = o ? [
    t(l, r),
    a.id,
    t(u, f),
    cx("time")
  ] : [
    t(l, f),
    a.id,
    t(u, r),
    cx("time")
  ];
  return [o ? u : l, f, p, a, !!o];
}
function M6(t, e) {
  if (typeof e != "string")
    return function(i) {
      return !1;
    };
  const r = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/%/g, ".*").replace(/_/g, "."), s = new RegExp(`^${r}$`, t ? void 0 : "i");
  return function(i) {
    return typeof i != "string" ? !1 : s.test(i);
  };
}
function VEe(t, e) {
  if (typeof e != "object" || e.hasOwnProperty("$in") || e.hasOwnProperty("in"))
    return e;
  const n = t["checked-data-type"] === "date";
  if (e.hasOwnProperty("$gt"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) > new Date(e.$gt);
      } : function(s) {
        return s[2] > e.$gt;
      }
    };
  if (e.hasOwnProperty("$gte"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) >= new Date(e.$gte);
      } : function(s) {
        return s[2] >= e.$gte;
      }
    };
  if (e.hasOwnProperty("$lt"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) < new Date(e.$lt);
      } : function(s) {
        return s[2] < e.$lt;
      }
    };
  if (e.hasOwnProperty("$lte"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) <= new Date(e.$lte);
      } : function(s) {
        return s[2] <= e.$lte;
      }
    };
  if (e.hasOwnProperty("$like")) {
    const r = M6(!0, e.$like);
    return {
      $comparator: !0,
      $op: function(o) {
        return r(o[2]);
      }
    };
  }
  if (e.hasOwnProperty("$ilike")) {
    const r = M6(!1, e.$ilike);
    return {
      $comparator: !0,
      $op: function(o) {
        return r(o[2]);
      }
    };
  }
  return e;
}
function WEe(t, e, n, r, s, o) {
  const i = ls(e, n, s), a = og(e, n, s), c = i || a;
  if (!c)
    throw new Qm(`No attr for etype = ${n} label = ${s}`);
  if (o != null && o.hasOwnProperty("$isNull")) {
    const l = ls(e, n, "id");
    if (!l)
      throw new Qm(`No attr for etype = ${n} label = id`);
    return [
      t(n, r),
      l.id,
      { $isNull: { attrId: c.id, isNull: o.$isNull, reverse: !i } },
      cx("time")
    ];
  }
  return i ? [
    t(n, r),
    c.id,
    VEe(c, o),
    cx("time")
  ] : [o, c.id, t(n, r), cx("time")];
}
function KEe(t, e, n, r, s) {
  const [o, i, a] = s.reduce((c, l) => {
    const [d, u, f] = c, [p, g, y] = sQ(t, e, d, u, l);
    return [p, g, [...f, y]];
  }, [n, r, []]);
  return [o, i, a];
}
function lN(t, e, n, r, s, o) {
  const i = s.slice(0, s.length - 1), a = s[s.length - 1], [c, l, d] = KEe(t, e, n, r, i), u = WEe(t, e, c, l, a, o);
  return d.concat([u]);
}
function GEe(t, e) {
  return e ? [e].concat(t) : t;
}
function YEe([t, e]) {
  return t === "or" && Array.isArray(e);
}
function qEe([t, e]) {
  return t === "and" && Array.isArray(e);
}
function XEe(t, e, n) {
  return (r, s) => {
    const o = t(r, s);
    return e == o ? o : `${o}-${n}`;
  };
}
function O6(t, e, n, r, s, o) {
  const i = t(r, s), a = o.map((c, l) => {
    const d = XEe(t, i, l);
    return oQ(d, n, r, s, c);
  });
  return { [e]: { patterns: a, joinSym: i } };
}
function ZEe(t) {
  const e = [];
  for (let n = 1; n <= t.length; n++)
    e.push(t.slice(0, n));
  return e;
}
function D6(t, e, n, r, s) {
  return ZEe(s).map((o) => lN(t, e, n, r, o, {
    $isNull: !0
  }));
}
function oQ(t, e, n, r, s) {
  return Object.entries(s).flatMap(([o, i]) => {
    if (YEe([o, i]))
      return O6(t, "or", e, n, r, i);
    if (qEe([o, i]))
      return O6(t, "and", e, n, r, i);
    if (o === "$entityIdStartsWith")
      return [];
    const a = o.split(".");
    if (i != null && i.hasOwnProperty("$ne") && (i = { ...i, $not: i.$ne }, delete i.$ne), i != null && i.hasOwnProperty("$not")) {
      const c = lN(t, e, n, r, a, i), l = D6(t, e, n, r, a);
      return [
        {
          or: {
            patterns: [c, ...l],
            joinSym: t(n, r)
          }
        }
      ];
    }
    return i != null && i.hasOwnProperty("$isNull") && i.$isNull === !0 && a.length > 1 ? [
      {
        or: {
          patterns: D6(t, e, n, r, a),
          joinSym: t(n, r)
        }
      }
    ] : lN(t, e, n, r, a, i);
  });
}
function QEe(t, e, n, r) {
  const s = iI;
  return r ? oQ(s, t, e, n, r).concat(A6(s, t, e, n)) : A6(s, t, e, n);
}
function JEe(t, e, n) {
  return [t(e, n), t("time", n)];
}
function eTe(t, e, n, r, s, o) {
  const [i, a, c, l, d] = sQ(t, e, n, r, s), u = HEe(c, t(n, r), o);
  return [i, a, u, l, d];
}
function tTe(t, e, n, { etype: r, level: s, form: o }, i) {
  const a = Object.keys(o).filter((c) => c !== "$");
  return a.length ? Object.entries(i).map(function([l, d]) {
    return a.map(function(p) {
      var y, m, v;
      const g = !!(e.cardinalityInference && ((v = (m = (y = n.linkIndex) == null ? void 0 : y[r]) == null ? void 0 : m[p]) != null && v.isSingular));
      try {
        const [b, x, w] = eTe(t, n, r, s, p, l), S = aQ(e, n, {
          etype: b,
          level: x,
          form: o[p],
          join: w
        }), C = g ? S[0] : S;
        return { [p]: C };
      } catch (b) {
        if (b instanceof Qm)
          return { [p]: g ? void 0 : [] };
        throw b;
      }
    }).reduce(function(p, g) {
      return { ...p, ...g };
    }, d);
  }) : Object.values(i);
}
function nTe(t, e, n) {
  return n === "string" ? FEe(t, e) : t > e ? 1 : -1;
}
function Ib(t, e, n, r, s) {
  return e === r || e == null && r == null ? REe(t, n) : r == null ? 1 : e == null ? -1 : nTe(e, r, s);
}
function oE([t, e], [n, r], s) {
  return Ib(t, e, n, r, s);
}
function dN(t) {
  return t == null ? t : new Date(t).getTime();
}
function rTe(t, e, n, r) {
  var g;
  const [s, o, i, a] = t, c = n === "desc" ? 1 : -1;
  if (((g = e["forward-identity"]) == null ? void 0 : g[2]) === "id")
    return oE(r, [s, a], null) === c;
  const [l, d] = r, u = e["checked-data-type"], f = u === "date" ? dN(d) : d, p = u === "date" ? dN(i) : i;
  return oE([l, f], [s, p], u) === c;
}
function sTe(t, e) {
  const n = e[1];
  return t.getAttr(n);
}
function oTe(t, e, n) {
  const r = Object.keys(n)[0];
  return ls(t, e, r);
}
function iTe(t, e, n, r) {
  if (n)
    return sTe(t, n);
  if (r)
    return oTe(t, e, r);
}
function aTe(t, e, n) {
  var s, o;
  if (!Array.isArray(n.fields))
    return mEe(t, e);
  const r = /* @__PURE__ */ new Map();
  for (const i of n.fields) {
    const a = ls(t, e, i), c = (s = a == null ? void 0 : a["forward-identity"]) == null ? void 0 : s[2];
    c && TL(a) && r.set(c, a);
  }
  if (!r.has("id")) {
    const i = ls(t, e, "id"), a = (o = i == null ? void 0 : i["forward-identity"]) == null ? void 0 : o[2];
    a && r.set(a, i);
  }
  return r;
}
function cTe(t, e, { etype: n, pageInfo: r, dq: s, form: o }) {
  var g, y;
  const i = (g = o == null ? void 0 : o.$) == null ? void 0 : g.order, a = iQ(o), c = lTe(o);
  let l = PEe(t, s);
  const d = r == null ? void 0 : r["start-cursor"], u = iTe(e, n, d, i);
  if (u && ((y = u == null ? void 0 : u["forward-identity"]) == null ? void 0 : y[2]) !== "id") {
    const m = u["checked-data-type"] === "date", v = u.id;
    l = l.map(([b]) => {
      var w, S, C, _, E;
      let x = (E = (_ = (C = (S = (w = t.eav.get(b)) == null ? void 0 : w.get(v)) == null ? void 0 : S.values()) == null ? void 0 : C.next()) == null ? void 0 : _.value) == null ? void 0 : E[2];
      return m && (x = dN(x)), [b, x];
    });
  }
  l.sort(c === "asc" ? function(v, b) {
    return oE(v, b, u == null ? void 0 : u["checked-data-type"]);
  } : function(v, b) {
    return oE(b, v, u == null ? void 0 : u["checked-data-type"]);
  });
  let f = {};
  const p = aTe(e, n, s);
  for (const m of l) {
    const [v] = m;
    if (f[v] || !a && d && u && rTe(d, u, c, m))
      continue;
    const b = gEe(t, p, v);
    b && (f[v] = b);
  }
  return f;
}
function lTe(t) {
  var n;
  const e = (n = t.$) == null ? void 0 : n.order;
  return e && e[Object.keys(e)[0]] || "asc";
}
function iQ(t) {
  var s, o, i;
  const e = (s = t.$) == null ? void 0 : s.offset, n = (o = t.$) == null ? void 0 : o.before, r = (i = t.$) == null ? void 0 : i.after;
  return !e && !n && !r;
}
function dTe(t, e, { etype: n, level: r, form: s, join: o, pageInfo: i }) {
  var f, p, g, y, m;
  if (!iQ(s) && (!i || !i["start-cursor"]))
    return [];
  const a = GEe(QEe(e, n, r, (f = s.$) == null ? void 0 : f.where), o), c = JEe(iI, n, r), l = (p = s.$) == null ? void 0 : p.fields, d = cTe(t, e, {
    etype: n,
    pageInfo: i,
    form: s,
    dq: { where: a, find: c, fields: l }
  }), u = ((g = s.$) == null ? void 0 : g.limit) || ((y = s.$) == null ? void 0 : y.first) || ((m = s.$) == null ? void 0 : m.last);
  if (u != null) {
    r > 0 && console.warn("WARNING: Limits in child queries are only run client-side. Data returned from the server will not have a limit.");
    const v = Object.entries(d);
    return v.length <= u ? d : Object.fromEntries(v.slice(0, u));
  }
  return d;
}
function uTe(t, e, n) {
  try {
    return dTe(t, e, n);
  } catch (r) {
    if (r instanceof Qm)
      return {};
    throw r;
  }
}
function aQ(t, e, n) {
  const r = uTe(t, e, n);
  return tTe(iI, t, e, n, r);
}
function fTe(t) {
  const e = {};
  for (const [n, r] of Object.entries(t))
    e[n] = {
      startCursor: r["start-cursor"],
      endCursor: r["end-cursor"],
      hasNextPage: r["has-next-page?"],
      hasPreviousPage: r["has-previous-page?"]
    };
  return e;
}
function cQ({ store: t, attrsStore: e, pageInfo: n, aggregate: r }, s) {
  const i = { data: Object.keys(s).reduce(function(c, l) {
    return r != null && r[l] || l === "$$ruleParams" || (c[l] = aQ(t, e, {
      etype: l,
      form: s[l],
      level: 0,
      pageInfo: n == null ? void 0 : n[l]
    })), c;
  }, {}) };
  return n && (i.pageInfo = fTe(n)), r && (i.aggregate = r), i;
}
function hTe() {
  const e = {
    __etype: 1,
    __ops: 1,
    create: 1,
    update: 1,
    link: 1,
    unlink: 1,
    delete: 1,
    merge: 1,
    ruleParams: 1
  };
  return new Set(Object.keys(e));
}
const pTe = hTe();
function HC(t, e, n) {
  const r = {
    __etype: t,
    __ops: n
  };
  return new Proxy(r, {
    get: (s, o) => {
      if (o === "__ops")
        return n;
      if (o === "__etype")
        return t;
      if (pTe.has(o))
        return (i, a) => HC(t, e, [
          ...n,
          a ? [o, t, e, i, a] : [o, t, e, i]
        ]);
    }
  });
}
function gTe(t, e) {
  return `lookup__${t}__${JSON.stringify(e)}`;
}
function iE(t) {
  return t.startsWith("lookup__");
}
function uN(t) {
  const [e, n, ...r] = t.split("__");
  return [n, JSON.parse(r.join("__"))];
}
function mTe(t) {
  return new Proxy({
    __etype: t
  }, {
    get(e, n) {
      if (n === "lookup")
        return (s, o) => HC(t, uN(gTe(s, o)), []);
      if (n === "__etype")
        return t;
      const r = n;
      return iE(r) ? HC(t, uN(r), []) : HC(t, r, []);
    }
  });
}
function IL() {
  return new Proxy({}, {
    get(t, e) {
      return mTe(e);
    }
  });
}
IL();
function yTe(t) {
  return t.__ops;
}
function vTe(t, e) {
  const { attrIdMap: n, refSwapAttrIds: r } = t, s = [];
  for (const i of e) {
    const a = n[i];
    if (a)
      s.push(a);
    else if (Array.isArray(i) && i.length == 2 && n[i[0]]) {
      const [c, l] = i;
      s.push([n[c], l]);
    } else
      s.push(i);
  }
  const [o] = e;
  if ((o === "add-triple" || o === "retract-triple") && r.has(e[2])) {
    const i = s[1];
    s[1] = s[3], s[3] = i;
  }
  return s;
}
function bTe(t) {
  if (Array.isArray(t))
    return t;
  const e = Object.entries(t);
  if (e.length !== 1)
    throw new Error("lookup must be an object with a single unique attr and value.");
  return e[0];
}
function xTe(t, e, n) {
  return n.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
  // before assuming it's a ref lookup.
  !ls(t, e, n);
}
function fN(t) {
  const [e, n, ...r] = t.split(".");
  if (r.length > 0 || n !== "id")
    throw new Error(`${t} is not a valid lookup attribute.`);
  return e;
}
function wTe(t, e, n) {
  if (!xTe(t, e, n))
    return ls(t, e, n);
  const r = fN(n), s = ls(t, e, r) || og(t, e, r);
  if (s && s["value-type"] !== "ref")
    throw new Error(`${n} does not reference a valid link attribute.`);
  return s;
}
function hN(t) {
  return typeof t == "string" && !iE(t) ? null : typeof t == "string" && iE(t) ? uN(t) : bTe(t);
}
function $i(t, e, n) {
  const r = hN(n);
  if (r === null)
    return n;
  const [s, o] = r, i = wTe(t, e, s);
  if (!i || !i["unique?"])
    throw new Error(`${s} is not a unique attribute.`);
  return [i.id, o];
}
function lQ(t, e, n, r) {
  var i;
  const s = $i(t, e, n);
  return Array.isArray(s) ? [[
    "add-triple",
    s,
    (i = ls(t, e, "id")) == null ? void 0 : i.id,
    s
  ]].concat(r) : r;
}
function STe({ attrsStore: t }, [e, n, r]) {
  const s = Object.entries(r).flatMap(([o, i]) => {
    const a = Array.isArray(i) ? i : [i], c = ls(t, e, o), l = og(t, e, o);
    return a.map((d) => c ? [
      "add-triple",
      $i(t, e, n),
      c.id,
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      $i(t, c["reverse-identity"][1], d)
    ] : [
      "add-triple",
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      $i(t, l["forward-identity"][1], d),
      l == null ? void 0 : l.id,
      $i(t, e, n)
    ]);
  });
  return lQ(t, e, n, s);
}
function CTe({ attrsStore: t }, [e, n, r]) {
  const s = Object.entries(r).flatMap(([o, i]) => {
    const a = Array.isArray(i) ? i : [i], c = ls(t, e, o), l = og(t, e, o);
    return a.map((d) => c ? [
      "retract-triple",
      $i(t, e, n),
      c.id,
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      $i(t, c["reverse-identity"][1], d)
    ] : [
      "retract-triple",
      // Uses `!` because if we get here, we should have created the attr if it doesn't
      // already exist
      $i(t, l["forward-identity"][1], d),
      l.id,
      $i(t, e, n)
    ]);
  });
  return lQ(t, e, n, s);
}
function _Te(t, e, n, r) {
  var s;
  if (Array.isArray(r)) {
    const [o, i] = r;
    for (const a of t || []) {
      const c = a == null ? void 0 : a.aev.get(o);
      if (c) {
        for (const [l, d, u] of Ri(c, 2))
          if (u === i)
            return !0;
      }
    }
  } else
    for (const o of t || []) {
      const i = o == null ? void 0 : o.eav.get(r);
      if (i) {
        for (const a of i.keys())
          if (((s = e.getAttr(a)) == null ? void 0 : s["forward-identity"][1]) == n)
            return !0;
      }
    }
  return !1;
}
function dQ({ stores: t, attrsStore: e }, [n, r, s, o]) {
  return (o == null ? void 0 : o.upsert) === !1 ? { mode: "update" } : (o == null ? void 0 : o.upsert) === !0 ? null : _Te(t, e, n, r) ? { mode: "update" } : null;
}
function ETe(t, e) {
  const { attrsStore: n } = t, [r, s, o, i] = e, a = _L(o), c = $i(n, r, s);
  return [["id", c]].concat(Object.entries(a)).map(([d, u]) => {
    const f = ls(n, r, d);
    return f["checked-data-type"] === "date" && t.useDateObjects && (u = oI(u)), ["add-triple", c, f.id, u, { mode: "create" }];
  });
}
function TTe(t, e) {
  const { attrsStore: n } = t, [r, s, o, i] = e, a = _L(o), c = $i(n, r, s), l = dQ(t, [r, c, o, i]);
  return [["id", c]].concat(Object.entries(a)).map(([u, f]) => {
    const p = ls(n, r, u);
    return p["checked-data-type"] === "date" && t.useDateObjects && (f = oI(f)), [
      "add-triple",
      c,
      p.id,
      f,
      ...l ? [l] : []
    ];
  });
}
function PTe({ attrsStore: t }, [e, n]) {
  return [["delete-entity", $i(t, e, n), e]];
}
function ITe(t, e) {
  const { attrsStore: n } = t, [r, s, o, i] = e, a = _L(o), c = $i(n, r, s), l = dQ(t, [r, c, o, i]), d = Object.entries(a).map(([f, p]) => {
    const g = ls(n, r, f);
    return [
      "deep-merge-triple",
      c,
      g.id,
      p,
      ...l ? [l] : []
    ];
  });
  return [[
    "add-triple",
    c,
    ls(n, r, "id").id,
    c,
    ...l ? [l] : []
  ]].concat(d);
}
function kTe({ attrsStore: t }, [e, n, r]) {
  return [["rule-params", $i(t, e, n), e, r]];
}
function ATe(t) {
  const [e, n, r, s, o] = t;
  if (!s)
    return t;
  const i = { ...s };
  return delete i.id, [e, n, r, i, ...o ? [o] : []];
}
function MTe(t, e) {
  const [n, ...r] = ATe(e);
  switch (n) {
    case "merge":
      return ITe(t, r);
    case "create":
      return ETe(t, r);
    case "update":
      return TTe(t, r);
    case "link":
      return STe(t, r);
    case "unlink":
      return CTe(t, r);
    case "delete":
      return PTe(t, r);
    case "ruleParams":
      return kTe(t, r);
    default:
      throw new Error(`unsupported action ${n}`);
  }
}
function OTe(t) {
  switch (t) {
    case "string":
    case "date":
    case "boolean":
    case "number":
      return t;
    default:
      return;
  }
}
function DTe(t, e, n) {
  var a, c;
  const r = (c = (a = t.entities[e]) == null ? void 0 : a.attrs) == null ? void 0 : c[n];
  if (n === "id")
    return null;
  if (!r)
    throw new Error(`${e}.${n} does not exist in your schema`);
  const { unique: s, indexed: o } = r == null ? void 0 : r.config, i = OTe(r == null ? void 0 : r.valueType);
  return {
    "index?": o,
    "unique?": s,
    "checked-data-type": i
  };
}
function a1(t, e, n, r) {
  const s = t ? DTe(t, e, n) : null, o = Is(), a = [Is(), e, n];
  return {
    id: o,
    "forward-identity": a,
    "value-type": "blob",
    cardinality: "one",
    "unique?": !1,
    "index?": !1,
    isUnsynced: !0,
    ...s || {},
    ...r || {}
  };
}
function NTe(t, e, n) {
  return Object.values(t.links).find((o) => o.forward.on === e && o.forward.label === n || o.reverse.on === e && o.reverse.label === n);
}
function jTe(t, e, n) {
  const r = NTe(t, e, n);
  if (!r)
    throw new Error(`Couldn't find the link ${e}.${n} in your schema`);
  const { forward: s, reverse: o } = r;
  return {
    "forward-identity": [Is(), s.on, s.label],
    "reverse-identity": [Is(), o.on, o.label],
    cardinality: s.has === "one" ? "one" : "many",
    "unique?": o.has === "one",
    "on-delete": s.onDelete,
    "on-delete-reverse": o.onDelete
  };
}
function N6(t, e, n, r) {
  const s = t ? jTe(t, e, n) : null, o = Is(), i = [Is(), e, n], a = [Is(), n, e];
  return {
    id: o,
    // @ts-ignore: ts thinks it's any[]
    "forward-identity": i,
    // @ts-ignore: ts thinks it's any[]
    "reverse-identity": a,
    "value-type": "ref",
    // @ts-ignore: ts thinks it's type string
    cardinality: "many",
    "unique?": !1,
    "index?": !1,
    isUnsynced: !0,
    ...s || {},
    ...r || {}
  };
}
const RTe = /* @__PURE__ */ new Set(["create", "update", "merge", "link", "unlink"]), $Te = /* @__PURE__ */ new Set(["link", "unlink"]), LTe = /* @__PURE__ */ new Set(["create", "update", "merge"]), FTe = /* @__PURE__ */ new Set([
  "link",
  "unlink",
  "create",
  "update",
  "merge",
  "delete",
  "ruleParams"
]), pN = { "unique?": !0, "index?": !0 }, BTe = {
  ...pN,
  cardinality: "one"
};
function zTe(t) {
  const e = [], [n, r, s, o] = t;
  if (!FTe.has(n))
    return e;
  const i = hN(s);
  if (i && e.push({ etype: r, lookupPair: i }), n === "link")
    for (const [a, c] of Object.entries(o)) {
      const l = Array.isArray(c) ? c : [c];
      for (const d of l) {
        const u = hN(d);
        u && e.push({
          etype: r,
          lookupPair: u,
          linkLabel: a
        });
      }
    }
  return e;
}
function UTe({ attrsStore: t, schema: e }, n) {
  var f, p;
  const r = /* @__PURE__ */ new Set(), s = [], o = [];
  function i(g, y) {
    return ls(t, g, y) || s.find((m) => m["forward-identity"][1] === g && m["forward-identity"][2] === y);
  }
  function a(g, y) {
    return og(t, g, y) || s.find((m) => {
      var v, b;
      return ((v = m["reverse-identity"]) == null ? void 0 : v[1]) === g && ((b = m["reverse-identity"]) == null ? void 0 : b[2]) === y;
    });
  }
  function c(g) {
    s.push(g), o.push(["add-attr", g]), r.add(g.id);
  }
  function l(g) {
    g && "isUnsynced" in g && g.isUnsynced && !r.has(g.id) && (s.push(g), o.push(["add-attr", g]), r.add(g.id));
  }
  function d(g, y) {
    return y.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
    // before assuming it's a ref lookup.
    !i(g, y);
  }
  function u(g, y) {
    const m = i(g, y), v = a(g, y);
    l(m), l(v), !m && !v && c(N6(e, g, y, BTe));
  }
  for (const g of n)
    for (const { etype: y, lookupPair: m, linkLabel: v } of zTe(g)) {
      const b = m[0];
      if (v) {
        u(y, v);
        const x = i(y, v), w = a(y, v);
        l(x), l(w);
        const S = ((f = x == null ? void 0 : x["reverse-identity"]) == null ? void 0 : f[1]) || ((p = w == null ? void 0 : w["forward-identity"]) == null ? void 0 : p[1]) || v;
        if (d(S, b))
          u(S, fN(b));
        else {
          const C = i(S, b);
          C || c(a1(e, S, b, pN)), l(C);
        }
      } else if (d(y, b))
        u(y, fN(b));
      else {
        const x = i(y, b);
        x || c(a1(e, y, b, pN)), l(x);
      }
    }
  for (const g of n) {
    const [y, m, v, b] = g;
    if (RTe.has(y)) {
      const x = i(m, "id");
      l(x), x || c(a1(e, m, "id", { "unique?": !0 }));
      for (const w of Object.keys(b)) {
        const S = i(m, w);
        if (l(S), LTe.has(y) && (S || c(a1(e, m, w, w === "id" ? { "unique?": !0 } : null))), $Te.has(y)) {
          const C = a(m, w);
          !S && !C && c(N6(e, m, w)), l(C);
        }
      }
    }
  }
  if (s.length) {
    const g = { ...t.attrs };
    for (const y of s)
      g[y.id] = y;
    return [new sp(g, t.linkIndex), o];
  }
  return [t, o];
}
function HTe(t, e) {
  const r = (Array.isArray(e) ? e : [e]).flatMap((c) => yTe(c)), [s, o] = UTe(t, r), i = { ...t, attrsStore: s }, a = r.flatMap((c) => MTe(i, c));
  return [...o, ...a];
}
function j6(t, e) {
  typeof requestIdleCallback > "u" ? t() : requestIdleCallback(t, { timeout: e });
}
const lx = "__meta";
class VTe {
  constructor(e, n) {
  }
}
class gN {
  constructor(e) {
    P(this, "currentValue");
    P(this, "_subs", []);
    P(this, "_persister");
    P(this, "_merge");
    P(this, "serialize");
    P(this, "parse");
    P(this, "_saveThrottleMs");
    P(this, "_idleCallbackMaxWaitMs");
    P(this, "_nextSave", null);
    P(this, "_nextGc", null);
    P(this, "_pendingSaveKeys", /* @__PURE__ */ new Set());
    P(this, "_loadedKeys", /* @__PURE__ */ new Set());
    P(this, "_loadingKeys");
    P(this, "_objectSize");
    P(this, "_log");
    P(this, "onKeyLoaded");
    P(this, "_version", 0);
    P(this, "_meta", {
      isLoading: !0,
      onLoadCbs: [],
      value: null,
      error: null,
      attempts: 0
    });
    P(this, "_gcOpts");
    this._persister = e.persister, this._merge = e.merge, this.serialize = e.serialize, this.parse = e.parse, this._objectSize = e.objectSize, this._log = e.logger, this._saveThrottleMs = e.saveThrottleMs ?? 100, this._idleCallbackMaxWaitMs = e.idleCallbackMaxWaitMs ?? 1e3, this._gcOpts = e.gc, this.currentValue = {}, this._loadedKeys = /* @__PURE__ */ new Set(), this._loadingKeys = {}, this._initMeta(), e.preloadEntryCount && this._preloadEntries(e.preloadEntryCount);
  }
  async _initMeta() {
    var e;
    this._meta.loadingPromise && await this._meta.loadingPromise;
    try {
      const n = this._persister.getItem(lx);
      this._meta.loadingPromise = n;
      const r = await n;
      this._meta.isLoading = !1, this._meta.error = null, this._meta.loadingPromise = null, this._meta.attempts = 0;
      const s = ((e = this._meta.value) == null ? void 0 : e.objects) ?? {}, o = r ?? {}, i = o.objects ?? {};
      this._meta.value = {
        ...o,
        objects: { ...s, ...i }
      };
    } catch (n) {
      this._meta.error = n, this._meta.attempts++, this._meta.loadingPromise = null;
    }
  }
  async _getMeta() {
    return this._meta.value ? this._meta.value : this._meta.loadingPromise ? (await this._meta.loadingPromise, this._meta.value) : (this._initMeta(), await this._meta.loadingPromise, this._meta.value);
  }
  async _refreshMeta() {
    return await this._initMeta(), this._meta.value;
  }
  async _preloadEntries(e) {
    const n = await this.waitForMetaToLoad();
    if (!n)
      return;
    const r = Object.entries(n.objects);
    r.sort(([s, o], [i, a]) => a.updatedAt - o.updatedAt);
    for (const [s] of r.slice(0, e))
      this._loadKey(s);
  }
  async _getFromStorage(e) {
    try {
      const n = await this._persister.getItem(e);
      return n && this.parse(e, n);
    } catch (n) {
      return console.error(`Unable to read from storage for key=${e}`, n), null;
    }
  }
  async waitForKeyToLoad(e) {
    return this._loadedKeys.has(e) ? this.currentValue[e] : (await (this._loadingKeys[e] || this._loadKey(e)), this.currentValue[e]);
  }
  // Used for tests
  async waitForMetaToLoad() {
    return this._getMeta();
  }
  // Unloads the key so that it can be garbage collected, but does not
  // delete it. Removes the key from currentValue.
  unloadKey(e) {
    this._loadedKeys.delete(e), delete this._loadingKeys[e], delete this.currentValue[e];
  }
  async _loadKey(e) {
    if (this._loadedKeys.has(e) || e in this._loadingKeys)
      return;
    const n = this._getFromStorage(e);
    this._loadingKeys[e] = n;
    const r = await n;
    if (delete this._loadingKeys[e], this._loadedKeys.add(e), r) {
      const s = this._merge(e, r, this.currentValue[e]);
      s && (this.currentValue[e] = s);
    }
    this.onKeyLoaded && this.onKeyLoaded(e);
  }
  // Returns a promise with a number so that we can wait for flush
  // to finish in the tests. The number is the number of operations
  // it performed, but it's mostly there so that typescript will warn
  // us if we forget to retun the promise from the function.
  _writeToStorage(e) {
    const n = [], r = e == null ? void 0 : e.skipGc;
    if (this._meta.isLoading) {
      const u = new Promise((f, p) => {
        setTimeout(() => this._enqueuePersist(e ? { ...e, attempts: (e.attempts || 0) + 1 } : { attempts: 1 }).then(f).catch(p), 10 + ((e == null ? void 0 : e.attempts) ?? 0) * 1e3);
      });
      return n.push(u), Promise.all(n).then((f) => f.reduce((p, g) => p + g, 0));
    }
    const s = this._meta.value;
    if (!s)
      return Promise.resolve(0);
    const o = [], i = [];
    for (const u of this._pendingSaveKeys)
      u in this.currentValue ? i.push(u) : (o.push(u), delete s.objects[u]);
    for (const u of o) {
      const f = this._persister.removeItem(u);
      n.push(f.then(() => 1)), this._loadedKeys.delete(u), this._pendingSaveKeys.delete(u);
    }
    const a = [], c = [[lx, s]], l = s.objects ?? {};
    s.objects = l;
    for (const u of i)
      if (this._loadedKeys.has(u)) {
        const f = this.serialize(u, this.currentValue[u]);
        c.push([u, f]);
        const p = this._objectSize(f), g = l[u] ?? {
          createdAt: Date.now(),
          updatedAt: Date.now(),
          size: p
        };
        g.updatedAt = Date.now(), g.size = p, l[u] = g, this._pendingSaveKeys.delete(u);
      } else
        a.push(u);
    const d = this._persister.multiSet(c);
    n.push(d.then(() => 1));
    for (const u of a) {
      const f = this._loadKey(u).then(() => this._enqueuePersist(e));
      n.push(f);
    }
    return r || this.gc(), Promise.all(n).then((u) => u.reduce((f, p) => f + p, 0));
  }
  async flush() {
    return this._nextSave ? (clearTimeout(this._nextSave), this._nextSave = null, this._writeToStorage()) : void 0;
  }
  async _gc() {
    if (!this._gcOpts)
      return;
    const e = new Set(await this._persister.getAllKeys());
    e.delete(lx);
    const n = new Set(Object.keys(this.currentValue));
    for (const f of Object.keys(this._loadingKeys))
      n.add(f);
    for (const f of this._loadedKeys)
      n.add(f);
    const r = await this._refreshMeta();
    if (!r) {
      this._log.info("Could not gc because we were not able to load meta");
      return;
    }
    const s = [], o = {
      gcOpts: this._gcOpts,
      keys: e,
      sacredKeys: n,
      removed: [],
      metaRemoved: [],
      removedMissingCount: 0,
      removedOldCount: 0,
      removedThresholdCount: 0,
      removedSizeCount: 0
    };
    for (const f of e)
      n.has(f) || f in r.objects || (this._log.info("Lost track of key in meta", f), s.push(this._persister.removeItem(f)), o.removed.push(f), o.removedMissingCount++);
    const i = Date.now();
    for (const [f, p] of Object.entries(r.objects))
      !n.has(f) && p.updatedAt < i - this._gcOpts.maxAgeMs && (s.push(this._persister.removeItem(f)), delete r.objects[f], o.removed.push(f), o.removedOldCount++);
    const a = Object.entries(r.objects);
    a.sort(([f, p], [g, y]) => p.updatedAt - y.updatedAt);
    const c = a.filter(([f]) => !n.has(f));
    if (a.length > this._gcOpts.maxEntries)
      for (const [f] of c.slice(0, a.length - this._gcOpts.maxEntries))
        s.push(this._persister.removeItem(f)), delete r.objects[f], o.removed.push(f), o.removedThresholdCount++;
    const l = Object.entries(r.objects);
    l.sort(([f, p], [g, y]) => p.updatedAt - y.updatedAt);
    const d = l.filter(([f]) => !n.has(f));
    let u = l.reduce((f, [p, g]) => f + g.size, 0);
    for (; u > 0 && u > this._gcOpts.maxSize && d.length; ) {
      const [[f, p]] = d.splice(0, 1);
      u -= p.size, s.push(this._persister.removeItem(f)), delete r.objects[f], o.removed.push(f), o.removedSizeCount++;
    }
    for (const f of Object.keys(r.objects))
      !e.has(f) && !n.has(f) && delete r.objects[f];
    return (o.removed.length || o.metaRemoved.length) && s.push(this._enqueuePersist({ skipGc: !0 })), this._log.info("Completed GC", o), await Promise.all(s), o;
  }
  // Schedules a GC to run in one minute (unless it is already scheduled)
  gc() {
    this._nextGc || (this._nextGc = setTimeout(
      () => {
        j6(() => {
          this._nextGc = null, this._gc();
        }, 30 * 1e3);
      },
      // 1 minute + some jitter to keep multiple tabs from running at same time
      1e3 * 60 + Math.random() * 500
    ));
  }
  _enqueuePersist(e) {
    return new Promise((n, r) => {
      if (this._nextSave) {
        n(0);
        return;
      }
      this._nextSave = setTimeout(() => {
        j6(() => {
          this._nextSave = null, this._writeToStorage(e).then(n).catch(r);
        }, this._idleCallbackMaxWaitMs);
      }, this._saveThrottleMs);
    });
  }
  version() {
    return this._version;
  }
  // Takes a function that updates the store in place.
  // Uses `mutative` to get a list of keys that were changed
  // so that we know which entries we need to persist to the store.
  updateInPlace(e) {
    this._version++;
    const [n, r] = sE(this.currentValue, e, {
      enablePatches: !0
    });
    for (const s of r) {
      const o = s.path[0];
      o && typeof o == "string" && (this._pendingSaveKeys.add(o), this._loadedKeys.has(o) || this._loadKey(o));
    }
    this.currentValue = n, this._enqueuePersist();
    for (const s of this._subs)
      s(this.currentValue);
    return n;
  }
  subscribe(e) {
    return this._subs.push(e), e(this.currentValue), () => {
      this._subs = this._subs.filter((n) => n !== e);
    };
  }
}
const WTe = 6, KTe = ["kv", "querySubs", "syncSubs"];
function GTe(t) {
  return function(n) {
    console.error("Error in IndexedDB event", { source: t, event: n });
  };
}
async function YTe(t) {
  return new Promise((e) => {
    const n = indexedDB.open(t);
    n.onerror = (r) => {
      e(null);
    }, n.onsuccess = (r) => {
      const o = r.target.result;
      e(o);
    }, n.onupgradeneeded = (r) => {
      var o;
      (o = r.target.transaction) == null || o.abort(), e(null);
    };
  });
}
async function qTe(t, e, n) {
  const r = (
    // Backwards compatibility for older versions where we JSON.stringified before storing
    typeof e == "string" ? JSON.parse(e) : e
  );
  if (!r)
    return;
  const s = /* @__PURE__ */ new Set();
  return new Promise((o, i) => {
    var d, u, f;
    const a = {};
    for (const [p, g] of Object.entries(r)) {
      const y = typeof g == "string" ? JSON.parse(g) : g;
      if (y.lastAccessed) {
        const v = {
          createdAt: y.lastAccessed,
          updatedAt: y.lastAccessed,
          size: ((f = (u = (d = y.result) == null ? void 0 : d.store) == null ? void 0 : u.triples) == null ? void 0 : f.length) ?? 0
        };
        a[p] = v;
      }
      const m = n.put(y, p);
      s.add(m);
    }
    const c = { objects: a }, l = n.put(c, lx);
    s.add(l);
    for (const p of s)
      p.onsuccess = () => {
        s.delete(p), s.size === 0 && o();
      }, p.onerror = (g) => {
        i(g);
      };
  });
}
async function R6(t, e, n) {
  const r = n.put(e, t);
  return new Promise((s, o) => {
    r.onsuccess = () => s(), r.onerror = (i) => o(i);
  });
}
async function XTe(t, e) {
  const n = await YTe(`instant_${t}_5`);
  if (!n)
    return;
  const r = await new Promise((d, u) => {
    const g = n.transaction(["kv"], "readonly").objectStore("kv").openCursor();
    g.onerror = (m) => {
      u(m);
    };
    const y = [];
    g.onsuccess = () => {
      const m = g.result;
      if (m) {
        const v = m.key, b = m.value;
        y.push([v, b]), m.continue();
      } else
        d(y);
    }, g.onerror = (m) => {
      u(m);
    };
  }), s = e.transaction(["kv", "querySubs"], "readwrite"), o = s.objectStore("kv"), i = s.objectStore("querySubs"), a = [], c = { objects: {} };
  for (const [d, u] of r)
    switch (d) {
      case "querySubs": {
        const f = qTe(d, u, i);
        a.push(f);
        break;
      }
      default: {
        const f = R6(d, u, o);
        a.push(f);
        const p = {
          createdAt: Date.now(),
          updatedAt: Date.now(),
          size: 0
        };
        c.objects[d] = p;
        break;
      }
    }
  const l = R6(lx, c, o);
  a.push(l), await Promise.all(a), await new Promise((d, u) => {
    s.oncomplete = (f) => d(f), s.onerror = (f) => u(f), s.onabort = (f) => u(f);
  });
}
const $6 = /* @__PURE__ */ new Map();
class uQ extends VTe {
  constructor(n, r) {
    super(n, r);
    P(this, "dbName");
    P(this, "_storeName");
    P(this, "_appId");
    P(this, "_prefix");
    P(this, "_dbPromise");
    this.dbName = `instant_${n}_${WTe}`, this._storeName = r, this._appId = n, this._dbPromise = this._init();
  }
  _init() {
    return new Promise((n, r) => {
      let s = !1;
      const o = indexedDB.open(this.dbName, 1);
      o.onerror = (i) => {
        r(i);
      }, o.onsuccess = (i) => {
        const c = i.target.result;
        if (s) {
          const l = XTe(this._appId, c).catch((d) => {
            GTe("Error upgrading store from version 5 to 6.")(d);
          });
          $6.set(this.dbName, l), l.then(() => n(c)).catch(() => n(c));
        } else {
          const l = $6.get(this.dbName);
          l ? l.then(() => n(c)).catch(() => n(c)) : n(c);
        }
      }, o.onupgradeneeded = (i) => {
        s = !0, this._upgradeStore(i);
      };
    });
  }
  _upgradeStore(n) {
    const s = n.target.result;
    for (const o of KTe)
      s.objectStoreNames.contains(o) || s.createObjectStore(o);
  }
  async getItem(n) {
    const r = await this._dbPromise;
    return new Promise((s, o) => {
      const c = r.transaction([this._storeName], "readonly").objectStore(this._storeName).get(n);
      c.onerror = (l) => {
        o(l);
      }, c.onsuccess = (l) => {
        c.result ? s(c.result) : s(null);
      };
    });
  }
  async setItem(n, r) {
    const s = await this._dbPromise;
    return new Promise((o, i) => {
      const l = s.transaction([this._storeName], "readwrite").objectStore(this._storeName).put(r, n);
      l.onerror = (d) => {
        i(d);
      }, l.onsuccess = (d) => {
        o();
      };
    });
  }
  // Performs all writes in a transaction so that all succeed or none succeed.
  async multiSet(n) {
    const r = await this._dbPromise;
    return new Promise((s, o) => {
      const i = r.transaction([this._storeName], "readwrite"), a = i.objectStore(this._storeName), c = /* @__PURE__ */ new Set();
      for (const [l, d] of n) {
        const u = a.put(d, l);
        c.add(u);
      }
      for (const l of c)
        l.onerror = (d) => {
          i.abort(), o(d);
        }, l.onsuccess = (d) => {
          c.delete(l), c.size === 0 && s();
        };
    });
  }
  async removeItem(n) {
    const r = await this._dbPromise;
    return new Promise((s, o) => {
      const c = r.transaction([this._storeName], "readwrite").objectStore(this._storeName).delete(n);
      c.onerror = (l) => {
        o(l);
      }, c.onsuccess = (l) => {
        s();
      };
    });
  }
  async getAllKeys() {
    const n = await this._dbPromise;
    return new Promise((r, s) => {
      const a = n.transaction([this._storeName], "readonly").objectStore(this._storeName).getAllKeys();
      a.onerror = (c) => {
        s(c);
      }, a.onsuccess = (c) => {
        r(a.result.filter((l) => typeof l == "string"));
      };
    });
  }
}
class fQ {
  static async getIsOnline() {
    return navigator.onLine;
  }
  static listen(e) {
    const n = () => {
      e(!0);
    }, r = () => {
      e(!1);
    };
    return addEventListener("online", n), addEventListener("offline", r), () => {
      removeEventListener("online", n), removeEventListener("offline", r);
    };
  }
}
class Jm extends Error {
  constructor(n, r) {
    super(n);
    P(this, "hint");
    this.hint = r;
    const s = new.target.prototype;
    Object.setPrototypeOf && Object.setPrototypeOf(this, s), Error.captureStackTrace && Error.captureStackTrace(this, Jm), this.name = "InstantError";
  }
  get [Symbol.toStringTag]() {
    return "InstantError";
  }
}
class aI extends Jm {
  constructor(n) {
    var o;
    const r = ((o = n.body) == null ? void 0 : o.message) || `API Error (${n.status})`;
    super(r, n.body.hint);
    P(this, "body");
    P(this, "status");
    const s = new.target.prototype;
    Object.setPrototypeOf && Object.setPrototypeOf(this, s), Error.captureStackTrace && Error.captureStackTrace(this, aI), this.name = "InstantAPIError", this.status = n.status, this.body = n.body;
  }
  get [Symbol.toStringTag]() {
    return "InstantAPIError";
  }
}
async function dl(t, e) {
  const n = await fetch(t, e), r = await n.json();
  return n.status === 200 ? Promise.resolve(r) : Promise.reject(new aI({ status: n.status, body: r }));
}
function ZTe({ apiURI: t, appId: e, email: n }) {
  return dl(`${t}/runtime/auth/send_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ "app-id": e, email: n })
  });
}
async function QTe({ apiURI: t, appId: e, email: n, code: r, refreshToken: s }) {
  return await dl(`${t}/runtime/auth/verify_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e,
      email: n,
      code: r,
      ...s ? { "refresh-token": s } : {}
    })
  });
}
async function JTe({ apiURI: t, appId: e, refreshToken: n }) {
  return await dl(`${t}/runtime/auth/verify_refresh_token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e,
      "refresh-token": n
    })
  });
}
async function ePe({ apiURI: t, appId: e }) {
  return await dl(`${t}/runtime/auth/sign_in_guest`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e
    })
  });
}
async function L6({ apiURI: t, appId: e, code: n, codeVerifier: r, refreshToken: s }) {
  return await dl(`${t}/runtime/oauth/token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      app_id: e,
      code: n,
      code_verifier: r,
      refresh_token: s
    })
  });
}
async function tPe({ apiURI: t, appId: e, nonce: n, idToken: r, clientName: s, refreshToken: o }) {
  return await dl(`${t}/runtime/oauth/id_token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      app_id: e,
      nonce: n,
      id_token: r,
      client_name: s,
      refresh_token: o
    })
  });
}
async function nPe({ apiURI: t, appId: e, refreshToken: n }) {
  return await dl(`${t}/runtime/signout`, {
    method: "POST",
    headers: {
      "content-type": "application/json"
    },
    body: JSON.stringify({
      app_id: e,
      refresh_token: n
    })
  });
}
async function rPe({ apiURI: t, appId: e, path: n, file: r, refreshToken: s, contentType: o, contentDisposition: i }) {
  const a = {
    app_id: e,
    path: n,
    authorization: `Bearer ${s}`,
    "content-type": o || r.type
  };
  return i && (a["content-disposition"] = i), await dl(`${t}/storage/upload`, {
    method: "PUT",
    headers: a,
    body: r
  });
}
async function sPe({ apiURI: t, appId: e, path: n, refreshToken: r }) {
  const { data: s } = await dl(`${t}/storage/files?app_id=${e}&filename=${encodeURIComponent(n)}`, {
    method: "DELETE",
    headers: {
      "content-type": "application/json",
      authorization: `Bearer ${r}`
    }
  });
  return s;
}
async function oPe({ apiURI: t, appId: e, fileName: n, refreshToken: r, metadata: s = {} }) {
  const { data: o } = await dl(`${t}/storage/signed-upload-url`, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      authorization: `Bearer ${r}`
    },
    body: JSON.stringify({
      app_id: e,
      filename: n
    })
  });
  return o;
}
async function iPe(t, e) {
  return (await fetch(t, {
    method: "PUT",
    body: e,
    headers: {
      "Content-Type": e.type
    }
  })).ok;
}
async function aPe({ apiURI: t, appId: e, path: n, refreshToken: r }) {
  const { data: s } = await dl(`${t}/storage/signed-download-url?app_id=${e}&filename=${encodeURIComponent(n)}`, {
    method: "GET",
    headers: {
      "content-type": "application/json",
      authorization: `Bearer ${r}`
    }
  });
  return s;
}
let kL = !1, hQ = !1, pQ = !1;
typeof window < "u" && typeof window.localStorage < "u" && (kL = !!window.localStorage.getItem("devBackend"), hQ = !!window.localStorage.getItem("__instantLogging"), pQ = !!window.localStorage.getItem("__devtoolLocalDash"));
function F6(t, e) {
  if (!e)
    return t;
  const n = {};
  return e.forEach((r) => {
    n[r] = t[r];
  }), n;
}
function cPe(t, e, n) {
  const r = {
    peers: {}
  };
  if (e && "user" in e ? e.user : !0) {
    const o = F6(t.user ?? {}, e == null ? void 0 : e.keys);
    r.user = { ...o, peerId: n };
  }
  for (const o of Object.keys(t.peers ?? {})) {
    const i = (e == null ? void 0 : e.peers) === void 0, a = Array.isArray(e == null ? void 0 : e.peers) && (e == null ? void 0 : e.peers.includes(o));
    if (i || a) {
      const c = F6(t.peers[o], e == null ? void 0 : e.keys);
      r.peers[o] = { ...c, peerId: o };
    }
  }
  return r;
}
function lPe(t, e) {
  if (t.isLoading !== e.isLoading || t.error !== e.error || (t.user || e.user) && (!t.user || !e.user || !_6(t.user, e.user)) || !VZ(t.peers, e.peers))
    return !0;
  for (const r of Object.keys(t.peers))
    if (!_6(t.peers[r], e.peers[r]))
      return !0;
  return !1;
}
class B6 {
  constructor() {
    P(this, "promise");
    P(this, "_resolve");
    P(this, "_reject");
    this.promise = new Promise((e, n) => {
      this._resolve = e, this._reject = n;
    });
  }
  resolve(e) {
    this._resolve(e);
  }
  reject(e) {
    this._reject(e);
  }
}
function gQ(t, e = []) {
  t.forEach((n) => {
    const { data: r } = n, { "datalog-result": s } = r, { "join-rows": o } = s;
    for (const i of o)
      for (const a of i)
        e.push(a);
    gQ(n["child-nodes"], e);
  });
}
function z6(t) {
  const e = [];
  return gQ(t, e), e;
}
function U6(t) {
  return Object.values(t.links).reduce((e, n) => {
    var r, s;
    return e[r = n.forward.on] ?? (e[r] = {}), e[n.forward.on][n.forward.label] = {
      isForward: !0,
      isSingular: n.forward.has === "one",
      link: n
    }, e[s = n.reverse.on] ?? (e[s] = {}), e[n.reverse.on][n.reverse.label] = {
      isForward: !1,
      isSingular: n.reverse.has === "one",
      link: n
    }, e;
  }, {});
}
const AL = "v0.22.123";
function dPe(t, e) {
  return {
    info: t ? (...n) => console.info(...n, e()) : () => {
    },
    debug: t ? (...n) => console.debug(...n, e()) : () => {
    },
    error: t ? (...n) => console.error(...n, e()) : () => {
    }
  };
}
class Vd {
  constructor(e, n, r, s = { indexed: !1, unique: !1 }) {
    P(this, "valueType");
    P(this, "required");
    P(this, "isIndexed");
    P(this, "config");
    P(this, "metadata", {});
    this.valueType = e, this.required = n, this.isIndexed = r, this.config = s;
  }
  /**
   * @deprecated Only use this temporarily for attributes that you want
   * to treat as required in frontend code but cant yet mark as required
   * and enforced for backend
   */
  clientRequired() {
    return new Vd(this.valueType, !1, this.isIndexed, this.config);
  }
  optional() {
    return new Vd(this.valueType, !1, this.isIndexed, this.config);
  }
  unique() {
    return new Vd(this.valueType, this.required, this.isIndexed, {
      ...this.config,
      unique: !0
    });
  }
  indexed() {
    return new Vd(this.valueType, this.required, !0, {
      ...this.config,
      indexed: !0
    });
  }
}
class Qn extends Error {
  constructor(e, n) {
    const r = n ? `At path '${n}': ${e}` : e;
    super(r), this.name = "QueryValidationError";
  }
}
const H6 = [
  "where",
  "order",
  "limit",
  "last",
  "first",
  "offset",
  "after",
  "before",
  "fields",
  "aggregate"
], uPe = (t) => t.valueType || "unknown", mQ = (t, e, n = !1) => {
  if (n || t == null)
    return !0;
  switch (e) {
    case "string":
      return typeof t == "string";
    case "number":
      return typeof t == "number" && !isNaN(t);
    case "boolean":
      return typeof t == "boolean";
    case "date":
      return t instanceof Date || typeof t == "string" || typeof t == "number";
    default:
      return !0;
  }
}, fPe = (t, e, n, r, s, o, i) => {
  const a = o.valueType === "json", c = (l, d, u) => {
    if (!mQ(u, d, a))
      throw new Qn(`Invalid value for operator '${l}' on attribute '${r}' in entity '${s}'. Expected ${d}, but received: ${typeof u}`, i);
  };
  switch (t) {
    case "in":
    case "$in":
      if (!Array.isArray(e))
        throw new Qn(`Operator '${t}' for attribute '${r}' in entity '${s}' must be an array, but received: ${typeof e}`, i);
      for (const l of e)
        c(t, n, l);
      break;
    case "$not":
    case "$ne":
    case "$gt":
    case "$lt":
    case "$gte":
    case "$lte":
      c(t, n, e);
      break;
    case "$like":
    case "$ilike":
      if (c(t, "string", e), t === "$ilike" && !o.isIndexed)
        throw new Qn(`Operator '${t}' can only be used with indexed attributes, but '${r}' in entity '${s}' is not indexed`, i);
      break;
    case "$isNull":
      c(t, "boolean", e);
      break;
    default:
      throw new Qn(`Unknown operator '${t}' for attribute '${r}' in entity '${s}'`, i);
  }
}, Sm = (t, e, n, r, s) => {
  const o = uPe(n), i = n.valueType === "json";
  if (typeof t == "object" && t !== null && !Array.isArray(t)) {
    if (i)
      return;
    const c = t;
    for (const [l, d] of Object.entries(c))
      fPe(l, d, o, e, r, n, `${s}.${l}`);
  } else if (!mQ(t, o, i))
    throw new Qn(`Invalid value for attribute '${e}' in entity '${r}'. Expected ${o}, but received: ${typeof t}`, s);
}, hPe = (t, e, n, r, s) => {
  const o = t.split(".");
  if (o.length < 2)
    throw new Qn(`Invalid dot notation path '${t}'. Must contain at least one dot.`, s);
  let i = n;
  for (let d = 0; d < o.length - 1; d++) {
    const u = o[d], f = r.entities[i];
    if (!f)
      throw new Qn(`Entity '${i}' does not exist in schema while traversing dot notation path '${t}'.`, s);
    const p = f.links[u];
    if (!p) {
      const g = Object.keys(f.links);
      throw new Qn(`Link '${u}' does not exist on entity '${i}' in dot notation path '${t}'. Available links: ${g.length > 0 ? g.join(", ") : "none"}`, s);
    }
    i = p.entityName;
  }
  const a = o[o.length - 1], c = r.entities[i];
  if (!c)
    throw new Qn(`Target entity '${i}' does not exist in schema for dot notation path '${t}'.`, s);
  if (a === "id") {
    if (typeof e == "string" && !Zm(e))
      throw new Qn(`Invalid value for id field in entity '${i}'. Expected a UUID, but received: ${e}`, s);
    Sm(e, t, new Vd("string", !1, !0), n, s);
    return;
  }
  const l = c.attrs[a];
  if (Object.keys(c.links).includes(a)) {
    if (typeof e == "string" && !Zm(e))
      throw new Qn(`Invalid value for link '${a}' in entity '${i}'. Expected a UUID, but received: ${e}`, s);
    Sm(e, t, new Vd("string", !1, !0), n, s);
    return;
  }
  if (!l) {
    const d = Object.keys(c.attrs);
    throw new Qn(`Attribute '${a}' does not exist on entity '${i}' in dot notation path '${t}'. Available attributes: ${d.length > 0 ? d.join(", ") + ", id" : "id"}`, s);
  }
  Sm(e, t, l, n, s);
}, yQ = (t, e, n, r) => {
  for (const [s, o] of Object.entries(t)) {
    if (s === "or" || s === "and") {
      if (Array.isArray(o))
        for (const l of o)
          typeof l == "object" && l !== null && yQ(l, e, n, `${r}.${s}[${l}]`);
      continue;
    }
    if (s === "id") {
      Sm(o, "id", new Vd("string", !1, !0), e, `${r}.id`);
      continue;
    }
    if (s.includes(".")) {
      hPe(s, o, e, n, `${r}.${s}`);
      continue;
    }
    const i = n.entities[e];
    if (!i)
      continue;
    const a = i.attrs[s], c = i.links[s];
    if (!a && !c) {
      const l = Object.keys(i.attrs), d = Object.keys(i.links);
      throw new Qn(`Attribute or link '${s}' does not exist on entity '${e}'. Available attributes: ${l.length > 0 ? l.join(", ") : "none"}. Available links: ${d.length > 0 ? d.join(", ") : "none"}`, `${r}.${s}`);
    }
    if (a)
      Sm(o, s, a, e, `${r}.${s}`);
    else if (c) {
      if (typeof o == "string" && !Zm(o))
        throw new Qn(`Invalid value for link '${s}' in entity '${e}'. Expected a UUID, but received: ${o}`, `${r}.${s}`);
      const l = new Vd("string", !1, !0);
      Sm(o, s, l, e, `${r}.${s}`);
    }
  }
}, pPe = (t, e, n, r, s = 0) => {
  for (const i of Object.keys(t))
    if (!H6.includes(i))
      throw new Qn(`Invalid query parameter '${i}' in $ object. Valid parameters are: ${H6.join(", ")}. Found: ${i}`, r);
  const o = [
    // 'limit', // only supported client side
    "offset",
    "before",
    "after",
    "first",
    "last"
  ];
  for (const i of o)
    if (t[i] !== void 0 && s > 0)
      throw new Qn(`'${i}' can only be used on top-level namespaces. It cannot be used in nested queries.`, r);
  if (t.where && n) {
    if (typeof t.where != "object" || t.where === null)
      throw new Qn(`'where' clause must be an object in entity '${e}', but received: ${typeof t.where}`, r ? `${r}.where` : void 0);
    yQ(t.where, e, n, r ? `${r}.where` : "where");
  }
}, vQ = (t, e, n, r, s = 0) => {
  var o;
  if (!t || typeof t != "object")
    throw new Qn(`Query part for entity '${e}' must be an object, but received: ${typeof t}`, r);
  for (const i of Object.keys(t))
    if (i !== "$") {
      if (n && !(i in n.entities[e].links)) {
        const c = Object.keys(n.entities[e].links);
        throw new Qn(`Link '${i}' does not exist on entity '${e}'. Available links: ${c.length > 0 ? c.join(", ") : "none"}`, `${r}.${i}`);
      }
      const a = t[i];
      if (typeof a == "object" && a !== null) {
        const c = (o = n == null ? void 0 : n.entities[e].links[i]) == null ? void 0 : o.entityName;
        c && vQ(a, c, n, `${r}.${i}`, s + 1);
      }
    } else {
      const a = t[i];
      if (typeof a != "object" || a === null)
        throw new Qn(`Query parameter '$' must be an object in entity '${e}', but received: ${typeof a}`, `${r}.$`);
      pPe(a, e, n, `${r}.$`, s);
    }
}, V6 = (t, e) => {
  if (typeof t != "object" || t === null)
    throw new Qn(`Query must be an object, but received: ${typeof t}${t === null ? " (null)" : ""}`);
  if (Array.isArray(t))
    throw new Qn(`Query must be an object, but received: ${typeof t}`);
  const n = t;
  for (const r of Object.keys(n)) {
    if (Array.isArray(t[r]))
      throw new Qn(`Query keys must be strings, but found key of type: ${typeof r}`, r);
    if (typeof r != "string")
      throw new Qn(`Query keys must be strings, but found key of type: ${typeof r}`, r);
    if (r !== "$$ruleParams") {
      if (e && !e.entities[r]) {
        const s = Object.keys(e.entities);
        throw new Qn(`Entity '${r}' does not exist in schema. Available entities: ${s.length > 0 ? s.join(", ") : "none"}`, r);
      }
      vQ(n[r], r, e, r, 0);
    }
  }
}, W6 = (t) => typeof t != "string" ? !1 : iE(t) ? !0 : Zm(t);
class Ja extends Error {
  constructor(e) {
    super(e), this.name = "TransactionValidationError";
  }
}
const bQ = (t) => t.length > 0 ? t.join(", ") : "none", gPe = (t, e) => new Ja(`Entity '${t}' does not exist in schema. Available entities: ${bQ(e)}`), nM = {
  string: (t) => typeof t == "string",
  number: (t) => typeof t == "number" && !isNaN(t),
  boolean: (t) => typeof t == "boolean",
  date: (t) => t instanceof Date || typeof t == "string" || typeof t == "number",
  json: () => !0
}, mPe = (t, e) => {
  var n;
  return t == null ? !0 : ((n = nM[e.valueType]) == null ? void 0 : n.call(nM, t)) ?? !1;
}, xQ = (t, e) => {
  const n = e.entities[t];
  if (!n)
    throw gPe(t, Object.keys(e.entities));
  return n;
}, rM = (t, e, n) => {
  const r = xQ(t, n);
  if (typeof e != "object" || e === null)
    throw new Ja(`Arguments for data operation on entity '${t}' must be an object, but received: ${typeof e}`);
  for (const [s, o] of Object.entries(e)) {
    if (s === "id")
      continue;
    const i = r.attrs[s];
    if (i && !mPe(o, i))
      throw new Ja(`Invalid value for attribute '${s}' in entity '${t}'. Expected ${i.valueType}, but received: ${typeof o}`);
  }
}, K6 = (t, e, n) => {
  const r = xQ(t, n);
  if (typeof e != "object" || e === null)
    throw new Ja(`Arguments for link operation on entity '${t}' must be an object, but received: ${typeof e}`);
  for (const [s, o] of Object.entries(e)) {
    if (!r.links[s]) {
      const a = Object.keys(r.links);
      throw new Ja(`Link '${s}' does not exist on entity '${t}'. Available links: ${bQ(a)}`);
    }
    if (o != null) {
      if (Array.isArray(o)) {
        for (const a of o)
          if (!W6(a))
            throw new Ja(`Invalid entity ID in link '${s}' for entity '${t}'. Expected a UUID or a lookup, but received: ${a}`);
      } else if (!W6(o))
        throw new Ja(`Invalid UUID in link '${s}' for entity '${t}'. Expected a UUID, but received: ${o}`);
    }
  }
}, yPe = {
  create: rM,
  update: rM,
  merge: rM,
  link: K6,
  unlink: K6,
  delete: () => {
  }
}, vPe = (t, e) => {
  if (!e)
    return;
  const [n, r, s, o] = t;
  if (!Array.isArray(s) && !Zm(s))
    throw new Ja(`Invalid id for entity '${r}'. Expected a UUID, but received: ${s}`);
  if (typeof r != "string")
    throw new Ja(`Entity name must be a string, but received: ${typeof r}`);
  const i = yPe[n];
  i && o !== void 0 && i(r, o, e);
}, bPe = (t, e) => {
  const n = Array.isArray(t) ? t : [t];
  for (const r of n) {
    if (!r || typeof r != "object")
      throw new Ja(`Transaction chunk must be an object, but received: ${typeof r}`);
    if (!Array.isArray(r.__ops))
      throw new Ja(`Transaction chunk must have __ops array, but received: ${typeof r.__ops}`);
    for (const s of r.__ops) {
      if (!Array.isArray(s))
        throw new Ja(`Transaction operation must be an array, but received: ${typeof s}`);
      vPe(s, e);
    }
  }
};
let wQ = 0;
class G6 {
  constructor(e) {
    P(this, "type", "ws");
    P(this, "conn");
    P(this, "id");
    P(this, "onopen");
    P(this, "onmessage");
    P(this, "onclose");
    P(this, "onerror");
    this.id = `${this.type}_${wQ++}`, this.conn = new WebSocket(e), this.conn.onopen = (n) => {
      this.onopen && this.onopen({ target: this });
    }, this.conn.onmessage = (n) => {
      this.onmessage && this.onmessage({
        target: this,
        message: JSON.parse(n.data.toString())
      });
    }, this.conn.onclose = (n) => {
      this.onclose && this.onclose({ target: this });
    }, this.conn.onerror = (n) => {
      this.onerror && this.onerror({ target: this });
    };
  }
  close() {
    this.conn.close();
  }
  isOpen() {
    return this.conn.readyState === (WebSocket.OPEN ?? 1);
  }
  isConnecting() {
    return this.conn.readyState === (WebSocket.CONNECTING ?? 0);
  }
  send(e) {
    return this.conn.send(JSON.stringify(e));
  }
}
class xPe {
  constructor(e, n) {
    P(this, "type", "sse");
    P(this, "initParams", null);
    P(this, "sendQueue", []);
    P(this, "sendPromise");
    P(this, "closeFired", !1);
    P(this, "sseInitTimeout");
    P(this, "ES");
    P(this, "conn");
    P(this, "url");
    P(this, "id");
    P(this, "onopen");
    P(this, "onmessage");
    P(this, "onclose");
    P(this, "onerror");
    this.id = `${this.type}_${wQ++}`, this.url = n, this.ES = e, this.conn = new e(n), this.sseInitTimeout = setTimeout(() => {
      this.initParams || this.handleError();
    }, 1e4), this.conn.onmessage = (r) => {
      const s = JSON.parse(r.data);
      if (Array.isArray(s))
        for (const o of s)
          this.handleMessage(o);
      else
        this.handleMessage(s);
    }, this.conn.onerror = (r) => {
      this.handleError();
    };
  }
  handleMessage(e) {
    if (e.op === "sse-init") {
      this.initParams = {
        machineId: e["machine-id"],
        sessionId: e["session-id"],
        sseToken: e["sse-token"]
      }, this.onopen && this.onopen({ target: this }), clearTimeout(this.sseInitTimeout);
      return;
    }
    this.onmessage && this.onmessage({
      target: this,
      message: e
    });
  }
  // Runs the onerror and closes the connection
  handleError() {
    try {
      this.onerror && this.onerror({ target: this });
    } finally {
      this.handleClose();
    }
  }
  handleClose() {
    this.conn.close(), this.onclose && !this.closeFired && (this.closeFired = !0, this.onclose({ target: this }));
  }
  async postMessages(e) {
    var n, r, s;
    try {
      (await fetch(this.url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          machine_id: (n = this.initParams) == null ? void 0 : n.machineId,
          session_id: (r = this.initParams) == null ? void 0 : r.sessionId,
          sse_token: (s = this.initParams) == null ? void 0 : s.sseToken,
          messages: e
        })
      })).ok || this.handleError();
    } catch {
      this.handleError();
    }
  }
  async flushQueue() {
    if (this.sendPromise || !this.sendQueue.length)
      return;
    const e = this.sendQueue;
    this.sendQueue = [];
    const n = this.postMessages(e);
    this.sendPromise = n, n.then(() => {
      this.sendPromise = null, this.flushQueue();
    });
  }
  send(e) {
    if (!this.isOpen() || !this.initParams)
      throw this.isConnecting() ? new Error("Failed to execute 'send' on 'EventSource': Still in CONNECTING state.") : this.conn.readyState === this.ES.CLOSED ? new Error("EventSource is already in CLOSING or CLOSED state.") : new Error("EventSource is in invalid state.");
    this.sendQueue.push(e), this.flushQueue();
  }
  isOpen() {
    return this.conn.readyState === this.ES.OPEN && this.initParams !== null;
  }
  isConnecting() {
    return this.conn.readyState === this.ES.CONNECTING || this.conn.readyState === this.ES.OPEN && this.initParams === null;
  }
  close() {
    this.handleClose();
  }
}
function wPe(t, e) {
  const n = t.values;
  if (n) {
    const r = XZ(n.attrsStore, null);
    if (r) {
      for (const s of n.entities || [])
        s.store.useDateObjects = e, s.store = qZ(r, s.store);
      n.attrsStore = r;
    }
  }
  return t;
}
function SPe(t, e) {
  var n;
  if (e.values) {
    const r = [];
    for (const s of (n = e.values) == null ? void 0 : n.entities) {
      const o = YZ(s.store);
      r.push({ ...s, store: o });
    }
    return {
      ...e,
      values: { attrsStore: e.values.attrsStore.toJSON(), entities: r }
    };
  } else
    return e;
}
function CPe(t, e, n) {
  var o, i;
  const r = (o = e == null ? void 0 : e.state) == null ? void 0 : o.txId, s = (i = n == null ? void 0 : n.state) == null ? void 0 : i.txId;
  return r && (!s || r > s) ? e : s && (!r || s > r) ? n : e || n;
}
function sM(t, e, n) {
  return cQ({ store: e, attrsStore: n, pageInfo: null, aggregate: null }, t.query).data[t.table][0];
}
function Y6(t, e, n, r) {
  var i;
  const s = (i = ls(n, t.table, "id")) == null ? void 0 : i.id;
  if (!s)
    return -1;
  const o = Jy(e.eav, [r, s, r]);
  return o ? o[3] : -1;
}
function q6(t, e, n) {
  for (const { action: r, triple: s } of n)
    switch (r) {
      case "added":
        JZ(t, e, s);
        break;
      case "removed":
        ZZ(t, e, s);
        break;
    }
}
function _Pe(t, e, n) {
  var s, o;
  const r = {};
  for (const { action: i, triple: a } of n) {
    const [c, l, d] = a, u = (o = (s = e.getAttr(l)) == null ? void 0 : s["forward-identity"]) == null ? void 0 : o[2];
    if (!u)
      continue;
    const f = r[c] ?? {};
    r[c] = f;
    const p = f[u] ?? {};
    switch (i) {
      case "added":
        p.newValue = d;
        break;
      case "removed":
        p.oldValue === void 0 && (p.oldValue = d);
        break;
    }
    f[u] = p;
  }
  for (const [i, a] of Object.entries(r))
    for (const [c, { oldValue: l, newValue: d }] of Object.entries(a))
      l === d && delete a[c];
  return r;
}
function c1(t, e) {
  return { [t.table]: e.map((n) => n.entity) };
}
function EPe(t, e) {
  var r;
  if (t.orderFieldType)
    return t.orderFieldType;
  const n = t.orderField === "serverCreatedAt" ? "number" : (r = ls(e(), t.table, t.orderField)) == null ? void 0 : r["checked-data-type"];
  return t.orderFieldType = n, n;
}
function TPe(t, e, n) {
  const r = e;
  if (t.orderField === "serverCreatedAt") {
    n.sort(t.orderDirection === "asc" ? function(i, a) {
      return Ib(i.entity.id, i.serverCreatedAt, a.entity.id, a.serverCreatedAt, r);
    } : function(i, a) {
      return Ib(a.entity.id, a.serverCreatedAt, i.entity.id, i.serverCreatedAt, r);
    });
    return;
  }
  const s = t.orderField;
  n.sort(t.orderDirection === "asc" ? function(i, a) {
    return Ib(i.entity.id, i.entity[s], a.entity.id, a.entity[s], r);
  } : function(i, a) {
    return Ib(a.entity.id, a.entity[s], i.entity.id, i.entity[s], r);
  });
}
var Oh;
(function(t) {
  t.InitialSyncBatch = "InitialSyncBatch", t.InitialSyncComplete = "InitialSyncComplete", t.LoadFromStorage = "LoadFromStorage", t.SyncTransaction = "SyncTransaction", t.Error = "Error";
})(Oh || (Oh = {}));
class PPe {
  constructor(e, n, r, s, o, i) {
    P(this, "trySend");
    P(this, "subs");
    // Using any for the SyncCallback because we'd need Reactor to be typed
    P(this, "callbacks", {});
    P(this, "config");
    P(this, "idToHash", {});
    P(this, "log");
    P(this, "createStore");
    P(this, "getAttrs");
    this.trySend = e, this.config = r, this.log = s, this.createStore = o, this.getAttrs = i, this.subs = new gN({
      persister: n,
      merge: CPe,
      serialize: SPe,
      parse: (a, c) => wPe(c, this.config.useDateObjects),
      objectSize: (a) => {
        var c;
        return ((c = a.values) == null ? void 0 : c.entities.length) || 0;
      },
      logger: s,
      gc: {
        maxAgeMs: 1e3 * 60 * 60 * 24 * 7 * 52,
        // 1 year
        maxEntries: 1e3,
        // Size of each sub is the number of entity
        maxSize: 1e6
        // 1 million entities
      }
    });
  }
  beforeUnload() {
    this.subs.flush();
  }
  subscribe(e, n) {
    const r = Ps(e);
    return this.callbacks[r] = this.callbacks[r] || [], this.callbacks[r].push(n), this.initSubscription(e, r, n), (s) => {
      this.unsubscribe(r, n, s == null ? void 0 : s.keepSubscription);
    };
  }
  unsubscribe(e, n, r) {
    const s = (this.callbacks[e] || []).filter((o) => o !== n);
    if (this.callbacks[e] = s, !s.length) {
      delete this.callbacks[e];
      const o = this.subs.currentValue[e];
      o != null && o.state && this.clearSubscriptionData(o.state.subscriptionId, !!r), r || this.subs.updateInPlace((i) => {
        delete i[e];
      });
    }
  }
  sendStart(e) {
    this.trySend(Is(), {
      op: "start-sync",
      q: e
    });
  }
  sendResync(e, n, r) {
    this.idToHash[n.subscriptionId] = e.hash, this.trySend(n.subscriptionId, {
      op: "resync-table",
      "subscription-id": n.subscriptionId,
      "tx-id": r,
      token: n.token
    });
  }
  sendRemove(e, n) {
    this.trySend(Is(), {
      op: "remove-sync",
      "subscription-id": e.subscriptionId,
      "keep-subscription": n
    });
  }
  async initSubscription(e, n, r) {
    var l, d, u, f;
    await this.subs.waitForKeyToLoad(n);
    const s = this.subs.currentValue[n];
    if (s && s.state && s.state.txId) {
      this.sendResync(s, s.state, s.state.txId), (l = s.values) != null && l.entities && r && r({
        type: Oh.LoadFromStorage,
        data: c1(s, (d = s.values) == null ? void 0 : d.entities)
      });
      return;
    }
    const o = Object.keys(e)[0], i = ((f = (u = e[o]) == null ? void 0 : u.$) == null ? void 0 : f.order) || { serverCreatedAt: "asc" }, [a, c] = Object.entries(i)[0];
    this.subs.updateInPlace((p) => {
      p[n] = {
        query: e,
        hash: n,
        table: o,
        orderDirection: c,
        orderField: a,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
    }), this.sendStart(e);
  }
  async flushPending() {
    for (const e of Object.keys(this.callbacks)) {
      await this.subs.waitForKeyToLoad(e);
      const n = this.subs.currentValue[e];
      n ? await this.initSubscription(n.query, n.hash) : this.log.error("Missing sub for hash in flushPending", e);
    }
  }
  onStartSyncOk(e) {
    const n = e["subscription-id"], r = e.q, s = Ps(r);
    this.idToHash[n] = s, this.subs.updateInPlace((o) => {
      const i = o[s];
      if (!i)
        return this.log.error("Missing sub for hash", s, "subscription-id", n, "query", r), o;
      i.state = {
        subscriptionId: n,
        token: e.token
      };
    });
  }
  notifyCbs(e, n) {
    for (const r of this.callbacks[e] || [])
      r(n);
  }
  onSyncLoadBatch(e) {
    const n = e["subscription-id"], r = e["join-rows"], s = this.idToHash[n];
    if (!s) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    const o = [], i = this.subs.currentValue[s];
    if (!i) {
      this.log.error("Missing sub for hash", s, e);
      return;
    }
    const a = i.values ?? {
      entities: [],
      attrsStore: this.getAttrs()
    };
    i.values = a;
    const c = a.entities;
    for (const l of r) {
      const d = this.createStore(l), u = sM(i, d, a.attrsStore);
      c.push({
        store: d,
        entity: u,
        serverCreatedAt: Y6(i, d, a.attrsStore, u.id)
      }), o.push(u);
    }
    this.subs.updateInPlace((l) => {
      l[s] = i, l[s].updatedAt = Date.now();
    }), i.values && this.notifyCbs(s, {
      type: Oh.InitialSyncBatch,
      data: c1(i, i.values.entities),
      batch: o
    });
  }
  onSyncInitFinish(e) {
    var o;
    const n = e["subscription-id"], r = this.idToHash[n];
    if (!r) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    this.subs.updateInPlace((i) => {
      const a = i[r];
      if (!a) {
        this.log.error("Missing sub for hash", r, e);
        return;
      }
      const c = a.state;
      if (!c)
        return this.log.error("Sub never set init, missing result", a, e), i;
      c.txId = e["tx-id"], a.updatedAt = Date.now();
    });
    const s = this.subs.currentValue[r];
    s && this.notifyCbs(r, {
      type: Oh.InitialSyncComplete,
      data: c1(s, ((o = s.values) == null ? void 0 : o.entities) || [])
    });
  }
  onSyncUpdateTriples(e) {
    var i;
    const n = e["subscription-id"], r = this.idToHash[n];
    if (!r) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    const s = this.subs.currentValue[r];
    if (!s) {
      this.log.error("Missing sub for hash", r, e);
      return;
    }
    const o = s.state;
    if (!o) {
      this.log.error("Missing state for sub", s, e);
      return;
    }
    for (const a of e.txes) {
      if (o.txId && o.txId >= a["tx-id"])
        continue;
      o.txId = a["tx-id"];
      const c = [], l = {};
      for (const m of a.changes) {
        const v = l[m.triple[0]] ?? [];
        l[m.triple[0]] = v, v.push(m);
      }
      const d = s.values ?? {
        entities: [],
        attrsStore: this.getAttrs()
      }, u = d.entities;
      s.values = d;
      const f = [];
      e: for (const [m, v] of Object.entries(l))
        for (let b = 0; b < u.length; b++) {
          const x = u[b];
          if (iEe(x.store, m)) {
            q6(x.store, d.attrsStore, v);
            const w = sM(s, x.store, d.attrsStore), S = _Pe(x.store, d.attrsStore, v)[m];
            w ? (f.push({
              oldEntity: x.entity,
              newEntity: w,
              changedFields: S || {}
            }), x.entity = w) : c.push(b), delete l[m];
            continue e;
          }
        }
      const p = [];
      for (const [m, v] of Object.entries(l)) {
        const b = this.createStore([]);
        q6(b, d.attrsStore, v);
        const x = sM(s, b, d.attrsStore);
        if (!x) {
          this.log.error("No entity found after applying change", {
            sub: s,
            changes: v,
            store: b
          });
          continue;
        }
        u.push({
          store: b,
          entity: x,
          serverCreatedAt: Y6(s, b, d.attrsStore, x.id)
        }), p.push(x);
      }
      const g = [];
      for (const m of c.sort().reverse())
        g.push(u[m].entity), u.splice(m, 1);
      const y = EPe(s, this.getAttrs);
      TPe(s, y, u), this.notifyCbs(r, {
        type: Oh.SyncTransaction,
        data: c1(s, (i = s.values) == null ? void 0 : i.entities),
        added: p,
        removed: g,
        updated: f
      });
    }
    this.subs.updateInPlace((a) => {
      a[r] = s, a[r].updatedAt = Date.now();
    });
  }
  clearSubscriptionData(e, n) {
    const r = this.idToHash[e];
    if (r) {
      delete this.idToHash[e];
      const s = this.subs.currentValue[r];
      if (s.state && this.sendRemove(s.state, n), n ? this.subs.unloadKey(r) : this.subs.updateInPlace((o) => {
        delete o[r];
      }), s)
        return s;
    }
  }
  onStartSyncError(e) {
    const n = Ps(e["original-event"].q), r = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa.",
      status: e.status,
      type: e.type,
      hint: e.hint
    }, s = Object.keys(e["original-event"].q)[0];
    this.notifyCbs(n, {
      type: Oh.Error,
      data: { [s]: [] },
      error: r
    });
  }
  onResyncError(e) {
    const n = e["original-event"]["subscription-id"], r = this.clearSubscriptionData(n, !1);
    r && this.initSubscription(r.query, r.hash);
  }
}
const yd = {
  CONNECTING: "connecting",
  OPENED: "opened",
  AUTHENTICATED: "authenticated",
  CLOSED: "closed",
  ERRORED: "errored"
}, IPe = 3e4, kPe = 3e4, APe = 200, MPe = 1e3 * 60, OPe = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
}, oM = "_instant_oauth_redirect", Hv = "currentUser";
function DPe({ transportType: t, appId: e, apiURI: n, wsURI: r, EventSourceImpl: s }) {
  if (!s)
    return new G6(`${r}?app_id=${e}`);
  switch (t) {
    case "ws":
      return new G6(`${r}?app_id=${e}`);
    case "sse":
      return new xPe(s, `${n}/runtime/sse?app_id=${e}`);
    default:
      throw new Error("Unknown transport type " + t);
  }
}
function NPe() {
  return typeof window < "u" || typeof chrome < "u";
}
const X6 = {
  "set-presence": !0,
  "set-presence-ok": !0,
  "refresh-presence": !0,
  "patch-presence": !0
};
function jPe(t, e) {
  var r;
  const n = typeof t == "string" ? JSON.parse(t) : t;
  if ((r = n == null ? void 0 : n.result) != null && r.store) {
    const s = XZ(n.result.attrsStore, n.result.store);
    if (s) {
      const o = n.result.store;
      n.result.store = qZ(s, {
        ...o,
        useDateObjects: e
      }), n.result.attrsStore = s;
    }
  }
  return n;
}
function RPe(t, e) {
  const { result: n, ...r } = e, s = (
    /** @type {import('./reactorTypes.ts').QuerySubInStorage} */
    r
  );
  if (n) {
    const o = {
      ...n,
      store: YZ(n.store),
      attrsStore: n.attrsStore.toJSON()
    };
    s.result = o;
  }
  return s;
}
function $Pe(t, e) {
  switch (t) {
    case "pendingMutations":
      return new Map(typeof e == "string" ? JSON.parse(e) : e);
    default:
      return e;
  }
}
function LPe(t, e) {
  switch (t) {
    case "pendingMutations":
      return [...e.entries()];
    default:
      return e;
  }
}
function FPe(t, e, n) {
  const r = e == null ? void 0 : e.result, s = n == null ? void 0 : n.result;
  return r && !s && n && (n.result = r), n || e;
}
function iM(t) {
  return [...t].sort((e, n) => {
    const [r, s] = e, [o, i] = n, a = s.order || 0, c = i.order || 0;
    return a == c ? r < o ? -1 : r > o ? 1 : 0 : a - c;
  });
}
class BPe {
  constructor(e, n = uQ, r = fQ, s, o) {
    /** @type {s.AttrsStore | undefined} */
    P(this, "attrs");
    P(this, "_isOnline", !0);
    P(this, "_isShutdown", !1);
    P(this, "status", yd.CONNECTING);
    /** @type {PersistedObject<string, QuerySub, QuerySubInStorage>} */
    P(this, "querySubs");
    /** @type {PersistedObject} */
    P(this, "kv");
    /** @type {SyncTable} */
    P(this, "_syncTable");
    /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */
    P(this, "queryCbs", {});
    /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */
    P(this, "queryOnceDfds", {});
    P(this, "authCbs", []);
    P(this, "attrsCbs", []);
    P(this, "mutationErrorCbs", []);
    P(this, "connectionStatusCbs", []);
    P(this, "config");
    P(this, "mutationDeferredStore", /* @__PURE__ */ new Map());
    P(this, "_reconnectTimeoutId", null);
    P(this, "_reconnectTimeoutMs", 0);
    /** @type {Connection} */
    P(this, "_transport");
    /** @type {TransportType} */
    P(this, "_transportType", "ws");
    /** @type {EventSourceConstructor} */
    P(this, "_EventSource");
    /** @type {boolean | null} */
    P(this, "_wsOk", null);
    P(this, "_localIdPromises", {});
    P(this, "_errorMessage", null);
    /** @type {Promise<null | {error: {message: string}}> | null}**/
    P(this, "_oauthCallbackResponse", null);
    /** @type {null | import('./utils/linkIndex.ts').LinkIndex}} */
    P(this, "_linkIndex", null);
    /** @type BroadcastChannel | undefined */
    P(this, "_broadcastChannel");
    /** @type {Record<string, {isConnected: boolean; error: any}>} */
    P(this, "_rooms", {});
    /** @type {Record<string, boolean>} */
    P(this, "_roomsPendingLeave", {});
    P(this, "_presence", {});
    P(this, "_broadcastQueue", []);
    P(this, "_broadcastSubs", {});
    /** @type {{isLoading: boolean; error: any | undefined, user: any | undefined}} */
    P(this, "_currentUserCached", { isLoading: !0, error: void 0, user: void 0 });
    P(this, "_beforeUnloadCbs", []);
    P(this, "_dataForQueryCache", {});
    /** @type {Logger} */
    P(this, "_log");
    P(this, "_pendingTxCleanupTimeout");
    P(this, "_pendingMutationCleanupThreshold");
    P(this, "_inFlightMutationEventIds", /* @__PURE__ */ new Set());
    P(this, "_onMergeKv", (e, n, r) => {
      switch (e) {
        case "pendingMutations": {
          const s = (n == null ? void 0 : n.entries()) ?? [], o = (r == null ? void 0 : r.entries()) ?? [], i = new Map([...s, ...o]);
          return (n ? this._rewriteMutationsSorted(this.attrs, n) : []).forEach(([c, l]) => {
            var d;
            !((d = r == null ? void 0 : r.pendingMutations) != null && d.has(c)) && !l["tx-id"] && this._sendMutation(c, l);
          }), i;
        }
        default:
          return r || n;
      }
    });
    // ---------------------------
    // Queries
    P(this, "getPreviousResult", (e) => {
      var r;
      const n = Ps(e);
      return (r = this.dataForQuery(n)) == null ? void 0 : r.data;
    });
    /** Re-run instaql and call all callbacks with new data */
    P(this, "notifyOne", (e) => {
      var o;
      const n = this.queryCbs[e] ?? [], r = (o = this._dataForQueryCache[e]) == null ? void 0 : o.data, s = this.dataForQuery(e);
      s != null && s.data && (this._dataForQueryCache[e] = s, !UC(s.data, r) && n.forEach((i) => i.cb(s.data)));
    });
    P(this, "notifyOneQueryOnce", (e) => {
      var s;
      const n = this.queryOnceDfds[e] ?? [], r = (s = this.dataForQuery(e)) == null ? void 0 : s.data;
      n.forEach((o) => {
        this._completeQueryOnce(o.q, e, o.dfd), o.dfd.resolve(r);
      });
    });
    P(this, "notifyQueryError", (e, n) => {
      (this.queryCbs[e] || []).forEach((s) => s.cb({ error: n }));
    });
    /** Applies transactions locally and sends transact message to server */
    P(this, "pushTx", (e) => {
      this.config.disableValidation || bPe(e, this.config.schema);
      try {
        const n = HTe({
          attrsStore: this.optimisticAttrs(),
          schema: this.config.schema,
          stores: Object.values(this.querySubs.currentValue).map((r) => {
            var s;
            return (s = r == null ? void 0 : r.result) == null ? void 0 : s.store;
          }),
          useDateObjects: this.config.useDateObjects
        }, e);
        return this.pushOps(n);
      } catch (n) {
        return this.pushOps([], n);
      }
    });
    /**
     * @param {*} txSteps
     * @param {*} [error]
     * @returns
     */
    P(this, "pushOps", (e, n) => {
      const r = Is(), s = [...this._pendingMutations().values()], o = Math.max(0, ...s.map((c) => c.order || 0)) + 1, i = {
        op: "transact",
        "tx-steps": e,
        created: Date.now(),
        error: n,
        order: o
      };
      this._updatePendingMutations((c) => {
        c.set(r, i);
      });
      const a = new B6();
      return this.mutationDeferredStore.set(r, a), this._sendMutation(r, i), this.notifyAll(), a.promise;
    });
    P(this, "_transportOnOpen", (e) => {
      const n = e.target;
      if (this._transport !== n) {
        this._log.info("[socket][open]", n.id, "skip; this is no longer the current transport");
        return;
      }
      this._log.info("[socket][open]", this._transport.id), this._setStatus(yd.OPENED), this.getCurrentUser().then((r) => {
        var s;
        this._trySend(Is(), {
          op: "init",
          "app-id": this.config.appId,
          "refresh-token": (s = r.user) == null ? void 0 : s.refresh_token,
          versions: this.versions,
          // If an admin token is provided for an app, we will
          // skip all permission checks. This is an advanced feature,
          // to let users write internal tools
          // This option is not exposed in `Config`, as it's
          // not ready for prime time
          "__admin-token": this.config.__adminToken
        });
      }).catch((r) => {
        this._log.error("[socket][error]", n.id, r);
      });
    });
    P(this, "_transportOnMessage", (e) => {
      const n = e.target, r = e.message;
      if (this._transport !== n) {
        this._log.info("[socket][message]", n.id, r, "skip; this is no longer the current transport");
        return;
      }
      if (!this._wsOk && n.type === "ws" && (this._wsOk = !0), this._transportType = "ws", Array.isArray(e.message))
        for (const s of e.message)
          this._handleReceive(n.id, s);
      else
        this._handleReceive(n.id, e.message);
    });
    P(this, "_transportOnError", (e) => {
      const n = e.target;
      if (this._transport !== n) {
        this._log.info("[socket][error]", n.id, "skip; this is no longer the current transport");
        return;
      }
      this._log.error("[socket][error]", n.id, e);
    });
    P(this, "_scheduleReconnect", () => {
      !this._wsOk && this._transportType !== "sse" && (this._transportType = "sse", this._reconnectTimeoutMs = 0), setTimeout(() => {
        if (this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1e3, 1e4), !this._isOnline) {
          this._log.info("[socket][close]", this._transport.id, "we are offline, no need to start socket");
          return;
        }
        this._startSocket();
      }, this._reconnectTimeoutMs);
    });
    P(this, "_transportOnClose", (e) => {
      const n = e.target;
      if (this._transport !== n) {
        this._log.info("[socket][close]", n.id, "skip; this is no longer the current transport");
        return;
      }
      this._setStatus(yd.CLOSED);
      for (const r of Object.values(this._rooms))
        r.isConnected = !1;
      if (this._isShutdown) {
        this._log.info("[socket][close]", n.id, "Reactor has been shut down and will not reconnect");
        return;
      }
      this._log.info("[socket][close]", n.id, "schedule reconnect, ms =", this._reconnectTimeoutMs), this._scheduleReconnect();
    });
    if (this._EventSource = o, this.config = { ...OPe, ...e }, this.queryCacheLimit = this.config.queryCacheLimit ?? 10, this._pendingTxCleanupTimeout = this.config.pendingTxCleanupTimeout ?? kPe, this._pendingMutationCleanupThreshold = this.config.pendingMutationCleanupThreshold ?? APe, this._log = dPe(e.verbose || kL || hQ, () => this._reactorStats()), this.versions = { ...s || {}, "@instantdb/core": AL }, this.config.schema && (this._linkIndex = U6(this.config.schema)), !!NPe()) {
      if (!e.appId)
        throw new Error("Instant must be initialized with an appId.");
      if (!Zm(e.appId))
        throw new Error(`Instant must be initialized with a valid appId. \`${e.appId}\` is not a valid uuid.`);
      typeof BroadcastChannel == "function" && (this._broadcastChannel = new BroadcastChannel("@instantdb"), this._broadcastChannel.addEventListener("message", async (i) => {
        var a;
        try {
          if (((a = i.data) == null ? void 0 : a.type) === "auth") {
            const c = await this.getCurrentUser();
            this.updateUser(c.user);
          }
        } catch (c) {
          this._log.error("[error] handle broadcast channel", c);
        }
      })), this._initStorage(n), this._syncTable = new PPe(this._trySendAuthed.bind(this), new n(this.config.appId, "syncSubs"), {
        useDateObjects: this.config.useDateObjects
      }, this._log, (i) => Pb(this.ensureAttrs(), i, this.config.enableCardinalityInference, this.config.useDateObjects), () => this.ensureAttrs()), this._oauthCallbackResponse = this._oauthLoginInit(), this.getCurrentUser().then((i) => {
        this.syncUserToEndpoint(i.user);
      }), setInterval(async () => {
        const i = await this.getCurrentUser();
        this.syncUserToEndpoint(i.user);
      }, MPe), r.getIsOnline().then((i) => {
        this._isOnline = i, this._startSocket(), r.listen((a) => {
          a !== this._isOnline && (this._log.info("[network] online =", a), this._isOnline = a, this._isOnline ? this._startSocket() : (this._log.info("Changing status from", this.status, "to", yd.CLOSED), this._setStatus(yd.CLOSED)));
        });
      }), typeof addEventListener < "u" && (this._beforeUnload = this._beforeUnload.bind(this), addEventListener("beforeunload", this._beforeUnload));
    }
  }
  ensureAttrs() {
    if (!this.attrs)
      throw new Error("attrs have not loaded.");
    return this.attrs;
  }
  updateSchema(e) {
    this.config = {
      ...this.config,
      schema: e,
      cardinalityInference: !!e
    }, this._linkIndex = e ? U6(this.config.schema) : null;
  }
  _reactorStats() {
    return {
      inFlightMutationCount: this._inFlightMutationEventIds.size,
      storedMutationCount: this._pendingMutations().size,
      transportType: this._transportType
    };
  }
  _onQuerySubLoaded(e) {
    this.kv.waitForKeyToLoad("pendingMutations").then(() => this.notifyOne(e));
  }
  _initStorage(e) {
    this.querySubs = new gN({
      persister: new e(this.config.appId, "querySubs"),
      merge: FPe,
      serialize: RPe,
      parse: (n, r) => jPe(r, this.config.useDateObjects),
      // objectSize
      objectSize: (n) => {
        var r, s, o;
        return ((o = (s = (r = n == null ? void 0 : n.result) == null ? void 0 : r.store) == null ? void 0 : s.triples) == null ? void 0 : o.length) ?? 0;
      },
      logger: this._log,
      preloadEntryCount: 10,
      gc: {
        maxAgeMs: 1e3 * 60 * 60 * 24 * 7 * 52,
        // 1 year
        maxEntries: 1e3,
        // Size of each query is the number of triples
        maxSize: 1e6
        // 1 million triples
      }
    }), this.querySubs.onKeyLoaded = (n) => this._onQuerySubLoaded(n), this.kv = new gN({
      persister: new e(this.config.appId, "kv"),
      merge: this._onMergeKv,
      serialize: LPe,
      parse: $Pe,
      objectSize: () => 0,
      logger: this._log,
      saveThrottleMs: 100,
      idleCallbackMaxWaitMs: 100,
      // Don't GC the kv store
      gc: null
    }), this.kv.onKeyLoaded = (n) => {
      n === "pendingMutations" && this.notifyAll();
    }, this.kv.waitForKeyToLoad("pendingMutations"), this.kv.waitForKeyToLoad(Hv), this._beforeUnloadCbs.push(() => {
      this.kv.flush(), this.querySubs.flush();
    });
  }
  _beforeUnload() {
    for (const e of this._beforeUnloadCbs)
      e();
    this._syncTable.beforeUnload();
  }
  /**
   * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
   * @param {string} eventId
   * @param {{message?: string, type?: string, status?: number, hint?: unknown}} [errorMsg]
   */
  _finishTransaction(e, n, r) {
    const s = this.mutationDeferredStore.get(n);
    this.mutationDeferredStore.delete(n);
    const o = e !== "error" && e !== "timeout";
    if (!s && !o && console.error("Mutation failed", { status: e, eventId: n, ...r }), !!s)
      if (o)
        s.resolve({ status: e, eventId: n });
      else if (r != null && r.type) {
        const { status: i, ...a } = r;
        s.reject(new aI({
          // @ts-expect-error body.type is not constant typed
          body: a,
          status: i ?? 0
        }));
      } else
        s.reject(new Jm((r == null ? void 0 : r.message) || "Unknown error", r == null ? void 0 : r.hint));
  }
  _setStatus(e, n) {
    this.status = e, this._errorMessage = n, this.notifyConnectionStatusSubs(e);
  }
  _flushEnqueuedRoomData(e) {
    var s, o;
    const n = (o = (s = this._presence[e]) == null ? void 0 : s.result) == null ? void 0 : o.user, r = this._broadcastQueue[e];
    if (this._broadcastQueue[e] = [], n && this._trySetPresence(e, n), r)
      for (const i of r) {
        const { topic: a, roomType: c, data: l } = i;
        this._tryBroadcast(e, c, a, l);
      }
  }
  /**
   * Does the same thing as add-query-ok
   * but called as a result of receiving query info from ssr
   * @param {any} q
   * @param {{ triples: any; pageInfo: any; }} result
   * @param {boolean} enableCardinalityInference
   */
  _addQueryData(e, n, r) {
    if (!this.attrs)
      throw new Error("Attrs in reactor have not been set");
    const s = Ps(e), o = this.ensureAttrs(), i = Pb(this.attrs, n.triples, r, this.config.useDateObjects);
    this.querySubs.updateInPlace((a) => {
      a[s] = {
        result: {
          store: i,
          attrsStore: o,
          pageInfo: n.pageInfo,
          processedTxId: void 0,
          isExternal: !0
        },
        q: e
      };
    }), this._cleanupPendingMutationsQueries(), this.notifyOne(s), this.notifyOneQueryOnce(s), this._cleanupPendingMutationsTimeout();
  }
  _handleReceive(e, n) {
    var s, o, i, a, c, l;
    const r = !!this.config.schema && ("cardinalityInference" in this.config ? !!this.config.cardinalityInference : !0);
    switch (X6[n.op] || this._log.info("[receive]", e, n.op, n), n.op) {
      case "init-ok": {
        this._setStatus(yd.AUTHENTICATED), this._reconnectTimeoutMs = 0, this._setAttrs(n.attrs), this._flushPendingMessages(), this._sessionId = n["session-id"];
        for (const f of Object.keys(this._rooms)) {
          const p = (o = (s = this._presence[f]) == null ? void 0 : s.result) == null ? void 0 : o.user;
          this._tryJoinRoom(f, p);
        }
        break;
      }
      case "add-query-exists": {
        this.notifyOneQueryOnce(Ps(n.q));
        break;
      }
      case "add-query-ok": {
        const { q: f, result: p } = n, g = Ps(f);
        if (!this._hasQueryListeners() && !this.querySubs.currentValue[g])
          break;
        const y = (a = (i = p == null ? void 0 : p[0]) == null ? void 0 : i.data) == null ? void 0 : a["page-info"], m = (l = (c = p == null ? void 0 : p[0]) == null ? void 0 : c.data) == null ? void 0 : l.aggregate, v = z6(p), b = this.ensureAttrs(), x = Pb(b, v, r, this.config.useDateObjects);
        this.querySubs.updateInPlace((w) => {
          if (!w[g]) {
            this._log.info("Missing value in querySubs", { hash: g, q: f });
            return;
          }
          w[g].result = {
            store: x,
            attrsStore: b,
            pageInfo: y,
            aggregate: m,
            processedTxId: n["processed-tx-id"]
          };
        }), this._cleanupPendingMutationsQueries(), this.notifyOne(g), this.notifyOneQueryOnce(g), this._cleanupPendingMutationsTimeout();
        break;
      }
      case "start-sync-ok": {
        this._syncTable.onStartSyncOk(n);
        break;
      }
      case "sync-load-batch": {
        this._syncTable.onSyncLoadBatch(n);
        break;
      }
      case "sync-init-finish": {
        this._syncTable.onSyncInitFinish(n);
        break;
      }
      case "sync-update-triples": {
        this._syncTable.onSyncUpdateTriples(n);
        break;
      }
      case "refresh-ok": {
        const { computations: f, attrs: p } = n, g = n["processed-tx-id"];
        p && this._setAttrs(p), this._cleanupPendingMutationsTimeout();
        const y = this._rewriteMutations(this.ensureAttrs(), this._pendingMutations(), g);
        y !== this._pendingMutations() && this.kv.updateInPlace((b) => {
          b.pendingMutations = y;
        });
        const m = iM(y.entries()), v = f.map((b) => {
          var k, A, R, j;
          const x = b["instaql-query"], w = b["instaql-result"], S = Ps(x), C = z6(w), _ = this.ensureAttrs(), E = Pb(_, C, r, this.config.useDateObjects), { store: M, attrsStore: N } = this._applyOptimisticUpdates(E, _, m, g), O = (A = (k = w == null ? void 0 : w[0]) == null ? void 0 : k.data) == null ? void 0 : A["page-info"], D = (j = (R = w == null ? void 0 : w[0]) == null ? void 0 : R.data) == null ? void 0 : j.aggregate;
          return {
            q: x,
            hash: S,
            store: M,
            attrsStore: N,
            pageInfo: O,
            aggregate: D
          };
        });
        v.forEach(({ hash: b, q: x, store: w, attrsStore: S, pageInfo: C, aggregate: _ }) => {
          this.querySubs.updateInPlace((E) => {
            if (!E[b]) {
              this._log.error("Missing value in querySubs", { hash: b, q: x });
              return;
            }
            E[b].result = {
              store: w,
              attrsStore: S,
              pageInfo: C,
              aggregate: _,
              processedTxId: g
            };
          });
        }), this._cleanupPendingMutationsQueries(), v.forEach(({ hash: b }) => {
          this.notifyOne(b);
        });
        break;
      }
      case "transact-ok": {
        const { "client-event-id": f, "tx-id": p } = n;
        this._inFlightMutationEventIds.delete(f);
        const y = this._rewriteMutations(this.ensureAttrs(), this._pendingMutations()).get(f);
        if (!y)
          break;
        this._updatePendingMutations((v) => {
          v.set(f, {
            ...v.get(f),
            "tx-id": p,
            confirmed: Date.now()
          });
        });
        const m = [];
        for (const v of y["tx-steps"])
          if (v[0] === "add-attr") {
            const b = v[1];
            m.push(b);
          }
        if (m.length) {
          const v = Object.values(this.ensureAttrs().attrs);
          this._setAttrs([...v, ...m]);
        }
        this._finishTransaction("synced", f), this._cleanupPendingMutationsTimeout();
        break;
      }
      case "patch-presence": {
        const f = n["room-id"];
        this._trySetRoomConnected(f, !0), this._patchPresencePeers(f, n.edits), this._notifyPresenceSubs(f);
        break;
      }
      case "refresh-presence": {
        const f = n["room-id"];
        this._trySetRoomConnected(f, !0), this._setPresencePeers(f, n.data), this._notifyPresenceSubs(f);
        break;
      }
      case "server-broadcast": {
        const f = n["room-id"], p = n.topic;
        this._trySetRoomConnected(f, !0), this._notifyBroadcastSubs(f, p, n);
        break;
      }
      case "join-room-ok": {
        const f = n["room-id"];
        if (!this._rooms[f]) {
          this._roomsPendingLeave[f] && (this._tryLeaveRoom(f), delete this._roomsPendingLeave[f]);
          break;
        }
        this._trySetRoomConnected(f, !0), this._flushEnqueuedRoomData(f);
        break;
      }
      case "leave-room-ok": {
        const f = n["room-id"];
        this._trySetRoomConnected(f, !1);
        break;
      }
      case "join-room-error":
        const d = n["room-id"], u = this._rooms[d];
        u && (u.error = n.error), this._notifyPresenceSubs(d);
        break;
      case "error":
        this._handleReceiveError(n);
        break;
      default:
        this._log.info("Uknown op", n.op, n);
        break;
    }
  }
  _pendingMutations() {
    return this.kv.currentValue.pendingMutations ?? /* @__PURE__ */ new Map();
  }
  _updatePendingMutations(e) {
    this.kv.updateInPlace((n) => {
      const r = n.pendingMutations ?? /* @__PURE__ */ new Map();
      n.pendingMutations = r, e(r);
    });
  }
  /**
   * @param {'timeout' | 'error'} status
   * @param {string} eventId
   * @param {{message?: string, type?: string, status?: number, hint?: unknown}} errorMsg
   */
  _handleMutationError(e, n, r) {
    const s = this._pendingMutations().get(n);
    if (s && (e !== "timeout" || !s["tx-id"])) {
      this._updatePendingMutations((i) => (i.delete(n), i)), this._inFlightMutationEventIds.delete(n);
      const o = {
        message: r.message,
        hint: r.hint
      };
      this.notifyAll(), this.notifyAttrsSubs(), this.notifyMutationErrorSubs(o), this._finishTransaction(e, n, r);
    }
  }
  _handleReceiveError(e) {
    var a, c, l, d, u, f, p;
    console.log("error", e);
    const n = e["client-event-id"];
    this._inFlightMutationEventIds.delete(n);
    const r = this._pendingMutations().get(n), s = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa."
    };
    if (e.hint && (s.hint = e.hint), r) {
      this._handleMutationError("error", n, e);
      return;
    }
    if ((a = e["original-event"]) != null && a.hasOwnProperty("q") && ((c = e["original-event"]) == null ? void 0 : c.op) === "add-query") {
      const g = (l = e["original-event"]) == null ? void 0 : l.q, y = Ps(g);
      this.notifyQueryError(Ps(g), s), this.notifyQueryOnceError(g, y, n, s);
      return;
    }
    if (((d = e["original-event"]) == null ? void 0 : d.op) === "init") {
      if (e.type === "record-not-found" && ((u = e.hint) == null ? void 0 : u["record-type"]) === "app-user") {
        this.changeCurrentUser(null);
        return;
      }
      this._setStatus(yd.ERRORED, s), this.notifyAll();
      return;
    }
    if (((f = e["original-event"]) == null ? void 0 : f.op) === "resync-table") {
      this._syncTable.onResyncError(e);
      return;
    }
    if (((p = e["original-event"]) == null ? void 0 : p.op) === "start-sync") {
      this._syncTable.onStartSyncError(e);
      return;
    }
    const i = { ...e };
    delete i.message, delete i.hint, console.error(e.message, i), e.hint && console.error(`This error comes with some debugging information. Here it is: 
`, e.hint);
  }
  notifyQueryOnceError(e, n, r, s) {
    var i;
    const o = (i = this.queryOnceDfds[n]) == null ? void 0 : i.find((a) => a.eventId === r);
    o && (o.dfd.reject(s), this._completeQueryOnce(e, n, o.dfd));
  }
  _setAttrs(e) {
    this.attrs = new sp(e.reduce((n, r) => (n[r.id] = r, n), {}), this._linkIndex), this.notifyAttrsSubs();
  }
  _startQuerySub(e, n) {
    const r = Is();
    return this.querySubs.updateInPlace((s) => {
      s[n] = s[n] || { q: e, result: null, eventId: r }, s[n].lastAccessed = Date.now();
    }), this._trySendAuthed(r, { op: "add-query", q: e }), r;
  }
  subscribeTable(e, n) {
    return this._syncTable.subscribe(e, n);
  }
  /**
   *  When a user subscribes to a query the following side effects occur:
   *
   *  - We update querySubs to include the new query
   *  - We update queryCbs to include the new cb
   *  - If we already have a result for the query we call cb immediately
   *  - We send the server an `add-query` message
   *
   *  Returns an unsubscribe function
   */
  subscribeQuery(e, n, r) {
    this.config.disableValidation || V6(e, this.config.schema), r && "ruleParams" in r && (e = { $$ruleParams: r.ruleParams, ...e });
    const s = Ps(e), o = this.getPreviousResult(e);
    return o && n(o), this.queryCbs[s] = this.queryCbs[s] ?? [], this.queryCbs[s].push({ q: e, cb: n }), this._startQuerySub(e, s), () => {
      this._unsubQuery(e, s, n);
    };
  }
  queryOnce(e, n) {
    this.config.disableValidation || V6(e, this.config.schema), n && "ruleParams" in n && (e = { $$ruleParams: n.ruleParams, ...e });
    const r = new B6();
    if (!this._isOnline)
      return r.reject(new Error("We can't run `queryOnce`, because the device is offline.")), r.promise;
    if (!this.querySubs)
      return r.reject(new Error("We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query")), r.promise;
    const s = Ps(e), o = this._startQuerySub(e, s);
    return this.queryOnceDfds[s] = this.queryOnceDfds[s] ?? [], this.queryOnceDfds[s].push({ q: e, dfd: r, eventId: o }), setTimeout(() => r.reject(new Error("Query timed out")), IPe), r.promise;
  }
  _completeQueryOnce(e, n, r) {
    this.queryOnceDfds[n] && (this.queryOnceDfds[n] = this.queryOnceDfds[n].filter((s) => s.dfd !== r), this._cleanupQuery(e, n));
  }
  _unsubQuery(e, n, r) {
    this.queryCbs[n] && (this.queryCbs[n] = this.queryCbs[n].filter((s) => s.cb !== r), this._cleanupQuery(e, n));
  }
  _hasQueryListeners(e) {
    var n, r;
    return !!((n = this.queryCbs[e]) != null && n.length || (r = this.queryOnceDfds[e]) != null && r.length);
  }
  _cleanupQuery(e, n) {
    this._hasQueryListeners(n) || (delete this.queryCbs[n], delete this.queryOnceDfds[n], delete this._dataForQueryCache[n], this.querySubs.unloadKey(n), this._trySendAuthed(Is(), { op: "remove-query", q: e }));
  }
  // When we `pushTx`, it's possible that we don't yet have `this.attrs`
  // This means that `tx-steps` in `pendingMutations` will include `add-attr`
  // commands for attrs that already exist.
  //
  // This will also affect `add-triple` and `retract-triple` which
  // reference attr-ids that do not match the server.
  //
  // We fix this by rewriting `tx-steps` in each `pendingMutation`.
  // We remove `add-attr` commands for attrs that already exist.
  // We update `add-triple` and `retract-triple` commands to use the
  // server attr-ids.
  /**
   *
   * @param {s.AttrsStore} attrs
   * @param {any} muts
   * @param {number} [processedTxId]
   */
  _rewriteMutations(e, n, r) {
    if (!e)
      return n;
    if (!n)
      return /* @__PURE__ */ new Map();
    const s = (d) => {
      const [u, f, p] = d["forward-identity"];
      return ls(e, f, p);
    }, o = (d) => {
      const [u, f, p] = d["forward-identity"];
      return og(e, f, p);
    }, i = { attrIdMap: {}, refSwapAttrIds: /* @__PURE__ */ new Set() };
    let a = !1;
    const c = (d, u) => {
      const f = [];
      for (const p of d) {
        const [g] = p;
        if (g === "add-attr") {
          const [m, v] = p, b = s(v);
          if (b && v.id !== b.id) {
            i.attrIdMap[v.id] = b.id, a = !0;
            continue;
          }
          if (v["value-type"] === "ref") {
            const x = o(v);
            if (x) {
              i.attrIdMap[v.id] = x.id, i.refSwapAttrIds.add(v.id), a = !0;
              continue;
            }
          }
        }
        if (r && u && r >= u && g === "add-attr" || g === "update-attr" || g === "delete-attr") {
          a = !0;
          continue;
        }
        const y = a ? vTe(i, p) : p;
        f.push(y);
      }
      return a ? f : d;
    }, l = /* @__PURE__ */ new Map();
    for (const [d, u] of n.entries())
      l.set(d, {
        ...u,
        "tx-steps": c(u["tx-steps"], u["tx-id"])
      });
    return a ? l : n;
  }
  _rewriteMutationsSorted(e, n) {
    return iM(this._rewriteMutations(e, n).entries());
  }
  // ---------------------------
  // Transact
  /**
   * @returns {s.AttrsStore}
   */
  optimisticAttrs() {
    var o, i;
    const e = [...this._pendingMutations().values()].flatMap((a) => a["tx-steps"]), n = new Set(e.filter(([a, c]) => a === "delete-attr").map(([a, c]) => c)), r = [];
    for (const [a, c] of e)
      if (a === "add-attr")
        r.push(c);
      else if (a === "update-attr" && c.id && ((o = this.attrs) != null && o.getAttr(c.id))) {
        const l = { ...this.attrs.getAttr(c.id), ...c };
        r.push(l);
      }
    if (!n.size && !r.length)
      return this.attrs || new sp({}, this._linkIndex);
    const s = { ...((i = this.attrs) == null ? void 0 : i.attrs) || {} };
    for (const a of r)
      s[a.id] = a;
    for (const a of n)
      delete s[a];
    return new sp(s, this._linkIndex);
  }
  /** Runs instaql on a query and a store */
  dataForQuery(e, n = !0) {
    const r = this._errorMessage;
    if (r)
      return { error: r };
    if (!this.querySubs || !this.kv.currentValue.pendingMutations)
      return;
    const s = this.querySubs.version(), o = this.querySubs.currentValue, i = this.kv.version(), a = this._pendingMutations(), { q: c, result: l } = o[e] || {};
    if (!l)
      return;
    const d = this._dataForQueryCache[e];
    if (d && s === d.querySubVersion && i === d.pendingMutationsVersion)
      return d;
    let u = l.store, f = l.attrsStore;
    const { pageInfo: p, aggregate: g, processedTxId: y } = l, m = this._rewriteMutationsSorted(f, a);
    if (n) {
      const b = this._applyOptimisticUpdates(u, f, m, y);
      u = b.store, f = b.attrsStore;
    }
    return { data: cQ({ store: u, attrsStore: f, pageInfo: p, aggregate: g }, c), querySubVersion: s, pendingMutationsVersion: i };
  }
  _applyOptimisticUpdates(e, n, r, s) {
    for (const [o, i] of r)
      if (!i["tx-id"] || s && i["tx-id"] > s) {
        const a = vEe(e, n, i["tx-steps"]);
        e = a.store, n = a.attrsStore;
      }
    return { store: e, attrsStore: n };
  }
  /** Re-compute all subscriptions */
  notifyAll() {
    Object.keys(this.queryCbs).forEach((e) => {
      this.querySubs.waitForKeyToLoad(e).then(() => this.notifyOne(e)).catch(() => this.notifyOne(e));
    });
  }
  loadedNotifyAll() {
    this.kv.waitForKeyToLoad("pendingMutations").then(() => this.notifyAll()).catch(() => this.notifyAll());
  }
  shutdown() {
    var e;
    this._log.info("[shutdown]", this.config.appId), this._isShutdown = !0, (e = this._transport) == null || e.close();
  }
  /**
   * Sends mutation to server and schedules a timeout to cancel it if
   * we don't hear back in time.
   * Note: If we're offline we don't schedule a timeout, we'll schedule it
   * later once we're back online and send the mutation again
   *
   */
  _sendMutation(e, n) {
    if (n.error) {
      this._handleMutationError("error", e, {
        message: n.error.message
      });
      return;
    }
    if (this.status !== yd.AUTHENTICATED) {
      this._finishTransaction("enqueued", e);
      return;
    }
    const r = Math.max(6e3, Math.min(
      this._inFlightMutationEventIds.size + 1,
      // Defensive code in case we don't clean up in flight mutation event ids
      this._pendingMutations().size + 1
    ) * 6e3);
    this._isOnline ? (this._trySend(e, n), setTimeout(() => {
      this._isOnline && this._handleMutationError("timeout", e, {
        message: "transaction timed out"
      });
    }, r)) : this._finishTransaction("enqueued", e);
  }
  // ---------------------------
  // Websocket
  /** Send messages we accumulated while we were connecting */
  _flushPendingMessages() {
    Object.keys(this.queryCbs).map((o) => this.querySubs.currentValue[o]).filter((o) => o).forEach(({ eventId: o, q: i }) => {
      this._trySendAuthed(o, { op: "add-query", q: i });
    }), Object.values(this.queryOnceDfds).flat().forEach(({ eventId: o, q: i }) => {
      this._trySendAuthed(o, { op: "add-query", q: i });
    });
    const r = this._rewriteMutations(this.ensureAttrs(), this._pendingMutations());
    r !== this._pendingMutations() && this.kv.updateInPlace((o) => {
      o.pendingMutations = r;
    }), iM(r.entries()).forEach(([o, i]) => {
      i["tx-id"] || this._sendMutation(o, i);
    }), this._syncTable.flushPending();
  }
  /**
   * Clean up pendingMutations that all queries have seen
   */
  _cleanupPendingMutationsQueries() {
    let e = Number.MAX_SAFE_INTEGER;
    for (const { result: n } of Object.values(this.querySubs.currentValue))
      n != null && n.processedTxId && (e = Math.min(e, n == null ? void 0 : n.processedTxId));
    this._updatePendingMutations((n) => {
      for (const [r, s] of Array.from(n.entries()))
        s["tx-id"] && s["tx-id"] <= e && n.delete(r);
    });
  }
  /**
   * After mutations is confirmed by server, we give each query 30 sec
   * to update its results. If that doesn't happen, we assume query is
   * unaffected by this mutation and its safe to delete it from local queue
   */
  _cleanupPendingMutationsTimeout() {
    if (this._pendingMutations().size < this._pendingMutationCleanupThreshold)
      return;
    const e = Date.now();
    this._updatePendingMutations((n) => {
      for (const [r, s] of Array.from(n.entries()))
        s.confirmed && s.confirmed + this._pendingTxCleanupTimeout < e && n.delete(r);
    });
  }
  _trySendAuthed(...e) {
    this.status === yd.AUTHENTICATED && this._trySend(...e);
  }
  _trySend(e, n, r) {
    if (this._transport.isOpen()) {
      switch (X6[n.op] || this._log.info("[send]", this._transport.id, n.op, n), n.op) {
        case "transact": {
          this._inFlightMutationEventIds.add(e);
          break;
        }
        case "init":
          this._inFlightMutationEventIds.clear();
      }
      this._transport.send({ "client-event-id": e, ...n });
    }
  }
  _startSocket() {
    if (this._wsOk = null, this._isShutdown) {
      this._log.info("[socket][start]", this.config.appId, "Reactor has been shut down and will not start a new socket");
      return;
    }
    if (this._transport && this._transport.isConnecting()) {
      this._log.info("[socket][start]", this._transport.id, "maintained as current transport, we were still in a connecting state");
      return;
    }
    const e = this._transport;
    this._transport = DPe({
      transportType: this._transportType,
      appId: this.config.appId,
      apiURI: this.config.apiURI,
      wsURI: this.config.websocketURI,
      EventSourceImpl: this._EventSource
    }), this._transport.onopen = this._transportOnOpen, this._transport.onmessage = this._transportOnMessage, this._transport.onclose = this._transportOnClose, this._transport.onerror = this._transportOnError, this._log.info("[socket][start]", this._transport.id), e != null && e.isOpen() && (this._log.info("[socket][start]", this._transport.id, "close previous transport id = ", e.id), e.close());
  }
  /**
   * Given a key, returns a stable local id, unique to this device and app.
   *
   * This can be useful if you want to create guest ids for example.
   *
   * Note: If the user deletes their local storage, this id will change.
   *
   */
  async getLocalId(e) {
    const n = `localToken_${e}`;
    if (this.kv.currentValue[n])
      return this.kv.currentValue[n];
    const r = await this.kv.waitForKeyToLoad(n);
    if (r)
      return r;
    const s = Is();
    return this.kv.updateInPlace((o) => {
      o[n] || (o[n] = s);
    }), await this.kv.waitForKeyToLoad(n);
  }
  // ----
  // Auth
  _replaceUrlAfterOAuth() {
    if (typeof URL > "u")
      return;
    const e = new URL(window.location.href);
    if (e.searchParams.get(oM)) {
      const n = e.toString();
      e.searchParams.delete(oM), e.searchParams.delete("code"), e.searchParams.delete("error");
      const r = e.pathname + (e.searchParams.size ? "?" + e.searchParams : "") + e.hash;
      if (history.replaceState(history.state, "", r), // @ts-ignore (waiting for ts support)
      typeof navigation == "object" && // @ts-ignore (waiting for ts support)
      typeof navigation.addEventListener == "function" && // @ts-ignore (waiting for ts support)
      typeof navigation.removeEventListener == "function") {
        let s = !1;
        const o = (i) => {
          var a;
          s || (s = !0, navigation.removeEventListener("navigate", o), !i.userInitiated && i.navigationType === "replace" && ((a = i.destination) == null ? void 0 : a.url) === n && history.replaceState(history.state, "", r));
        };
        navigation.addEventListener("navigate", o);
      }
    }
  }
  /**
   *
   * @returns Promise<null | {error: {message: string}}>
   */
  async _oauthLoginInit() {
    var s, o, i, a;
    if (typeof window > "u" || typeof window.location > "u" || typeof URLSearchParams > "u")
      return null;
    const e = new URLSearchParams(window.location.search);
    if (!e.get(oM))
      return null;
    const n = e.get("error");
    if (n)
      return this._replaceUrlAfterOAuth(), { error: { message: n } };
    const r = e.get("code");
    if (!r)
      return null;
    this._replaceUrlAfterOAuth();
    try {
      const c = await this._getCurrentUser(), l = (c == null ? void 0 : c.type) === "guest", { user: d } = await L6({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        code: r,
        refreshToken: l ? c.refresh_token : void 0
      });
      return this.setCurrentUser(d), null;
    } catch (c) {
      return ((s = c == null ? void 0 : c.body) == null ? void 0 : s.type) === "record-not-found" && ((i = (o = c == null ? void 0 : c.body) == null ? void 0 : o.hint) == null ? void 0 : i["record-type"]) === "app-oauth-code" && await this._hasCurrentUser() ? null : { error: { message: ((a = c == null ? void 0 : c.body) == null ? void 0 : a.message) || "Error logging in." } };
    }
  }
  async _waitForOAuthCallbackResponse() {
    return await this._oauthCallbackResponse;
  }
  __subscribeMutationErrors(e) {
    return this.mutationErrorCbs.push(e), () => {
      this.mutationErrorCbs = this.mutationErrorCbs.filter((n) => n !== e);
    };
  }
  subscribeAuth(e) {
    this.authCbs.push(e);
    const n = this._currentUserCached;
    n.isLoading || e(this._currentUserCached);
    let r = !1;
    return this.getCurrentUser().then((s) => {
      r || UC(s, n) || e(s);
    }), () => {
      r = !0, this.authCbs = this.authCbs.filter((s) => s !== e);
    };
  }
  async getAuth() {
    const { user: e, error: n } = await this.getCurrentUser();
    if (n)
      throw new Jm("Could not get current user: " + n.message);
    return e;
  }
  subscribeConnectionStatus(e) {
    return this.connectionStatusCbs.push(e), () => {
      this.connectionStatusCbs = this.connectionStatusCbs.filter((n) => n !== e);
    };
  }
  subscribeAttrs(e) {
    return this.attrsCbs.push(e), this.attrs && e(this.attrs.attrs), () => {
      this.attrsCbs = this.attrsCbs.filter((n) => n !== e);
    };
  }
  notifyAuthSubs(e) {
    this.authCbs.forEach((n) => n(e));
  }
  notifyMutationErrorSubs(e) {
    this.mutationErrorCbs.forEach((n) => n(e));
  }
  notifyAttrsSubs() {
    if (!this.attrs)
      return;
    const e = this.optimisticAttrs();
    this.attrsCbs.forEach((n) => n(e.attrs));
  }
  notifyConnectionStatusSubs(e) {
    this.connectionStatusCbs.forEach((n) => n(e));
  }
  async setCurrentUser(e) {
    this.kv.updateInPlace((n) => {
      n[Hv] = e;
    }), await this.kv.waitForKeyToLoad(Hv);
  }
  getCurrentUserCached() {
    return this._currentUserCached;
  }
  async _getCurrentUser() {
    const e = await this.kv.waitForKeyToLoad(Hv);
    return typeof e == "string" ? JSON.parse(e) : e;
  }
  async getCurrentUser() {
    const e = await this._waitForOAuthCallbackResponse();
    if (e != null && e.error) {
      const n = { error: e.error, user: void 0 };
      return this._currentUserCached = { isLoading: !1, ...n }, n;
    }
    try {
      const r = { user: await this._getCurrentUser(), error: void 0 };
      return this._currentUserCached = {
        isLoading: !1,
        ...r
      }, r;
    } catch (n) {
      return {
        user: void 0,
        isLoading: !1,
        error: { message: (n == null ? void 0 : n.message) || "Error loading user" }
      };
    }
  }
  async _hasCurrentUser() {
    const e = await this.kv.waitForKeyToLoad(Hv);
    return typeof e == "string" ? JSON.parse(e) != null : e != null;
  }
  async changeCurrentUser(e) {
    var r;
    const { user: n } = await this.getCurrentUser();
    if (!UC(n, e)) {
      await this.setCurrentUser(e), this.updateUser(e);
      try {
        (r = this._broadcastChannel) == null || r.postMessage({ type: "auth" });
      } catch (s) {
        console.error("Error posting message to broadcast channel", s);
      }
    }
  }
  async syncUserToEndpoint(e) {
    if (this.config.firstPartyPath)
      try {
        fetch(this.config.firstPartyPath + "/", {
          method: "POST",
          body: JSON.stringify({
            type: "sync-user",
            appId: this.config.appId,
            user: e
          }),
          headers: {
            "Content-Type": "application/json"
          }
        });
      } catch (n) {
        this._log.error("Error syncing user with external endpoint", n);
      }
  }
  updateUser(e) {
    this.syncUserToEndpoint(e);
    const n = { error: void 0, user: e };
    this._currentUserCached = { isLoading: !1, ...n }, this._dataForQueryCache = {}, this.querySubs.updateInPlace((r) => {
      Object.keys(r).forEach((s) => {
        delete r[s].result;
      });
    }), this._reconnectTimeoutMs = 0, this._transport.close(), this._oauthCallbackResponse = null, this.notifyAuthSubs(n);
  }
  sendMagicCode({ email: e }) {
    return ZTe({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e
    });
  }
  async signInWithMagicCode({ email: e, code: n }) {
    var i;
    const r = await this.getCurrentUser(), s = ((i = r == null ? void 0 : r.user) == null ? void 0 : i.type) === "guest", o = await QTe({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e,
      code: n,
      refreshToken: s ? r.user.refresh_token : void 0
    });
    return await this.changeCurrentUser(o.user), o;
  }
  async signInWithCustomToken(e) {
    const n = await JTe({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      refreshToken: e
    });
    return await this.changeCurrentUser(n.user), n;
  }
  async signInAsGuest() {
    const e = await ePe({
      apiURI: this.config.apiURI,
      appId: this.config.appId
    });
    return await this.changeCurrentUser(e.user), e;
  }
  potentiallyInvalidateToken(e, n) {
    var o;
    const r = (o = e == null ? void 0 : e.user) == null ? void 0 : o.refresh_token;
    if (!r)
      return;
    if (n.invalidateToken === !1) {
      this._log.info("[auth-invalidate] skipped invalidateToken");
      return;
    }
    nPe({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      refreshToken: r
    }).then(() => {
      this._log.info("[auth-invalidate] completed invalidateToken");
    }).catch((i) => {
    });
  }
  async signOut(e) {
    const n = await this.getCurrentUser();
    this.potentiallyInvalidateToken(n, e), await this.changeCurrentUser(null);
  }
  /**
   * Creates an OAuth authorization URL.
   *
   * @param {Object} params - The parameters to create the authorization URL.
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.redirectURL - The URL to redirect users to after authorization.
   * @returns {string} The created authorization URL.
   */
  createAuthorizationURL({ clientName: e, redirectURL: n }) {
    const { apiURI: r, appId: s } = this.config;
    return `${r}/runtime/oauth/start?app_id=${s}&client_name=${e}&redirect_uri=${n}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.code - The code received from the OAuth service.
   * @param {string} [params.codeVerifier] - The code verifier used to generate the code challenge.
   */
  async exchangeCodeForToken({ code: e, codeVerifier: n }) {
    var i;
    const r = await this.getCurrentUser(), s = ((i = r == null ? void 0 : r.user) == null ? void 0 : i.type) === "guest", o = await L6({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      code: e,
      codeVerifier: n,
      refreshToken: s ? r.user.refresh_token : void 0
    });
    return await this.changeCurrentUser(o.user), o;
  }
  issuerURI() {
    const { apiURI: e, appId: n } = this.config;
    return `${e}/runtime/${n}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.idToken - The id_token from the external service
   * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
   */
  async signInWithIdToken({ idToken: e, clientName: n, nonce: r }) {
    var a;
    const s = await this.getCurrentUser(), o = (a = s == null ? void 0 : s.user) == null ? void 0 : a.refresh_token, i = await tPe({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      idToken: e,
      clientName: n,
      nonce: r,
      refreshToken: o
    });
    return await this.changeCurrentUser(i.user), i;
  }
  // --------
  // Rooms
  /**
   * @param {string} roomId
   * @param {any | null | undefined} [initialPresence] -- initial presence data to send when joining the room
   * @returns () => void
   */
  joinRoom(e, n) {
    let r = !1;
    this._rooms[e] || (r = !0, this._rooms[e] = {
      isConnected: !1,
      error: void 0
    }), this._presence[e] = this._presence[e] || {};
    const s = this._presence[e].result;
    return n && !s && (this._presence[e].result = this._presence[e].result || {}, this._presence[e].result.user = n, this._notifyPresenceSubs(e)), r && this._tryJoinRoom(e, n), () => {
      this._cleanupRoom(e);
    };
  }
  _cleanupRoom(e) {
    var n, r, s;
    if (!((r = (n = this._presence[e]) == null ? void 0 : n.handlers) != null && r.length) && !Object.keys(this._broadcastSubs[e] ?? {}).length) {
      const o = (s = this._rooms[e]) == null ? void 0 : s.isConnected;
      delete this._rooms[e], delete this._presence[e], delete this._broadcastSubs[e], o ? this._tryLeaveRoom(e) : this._roomsPendingLeave[e] = !0;
    }
  }
  // --------
  // Presence
  // TODO: look into typing again
  getPresence(e, n, r = {}) {
    const s = this._rooms[n], o = this._presence[n];
    return !s || !o || !o.result ? null : {
      ...cPe(o.result, r, this._sessionId),
      isLoading: !s.isConnected,
      error: s.error
    };
  }
  // TODO: look into typing again
  publishPresence(e, n, r) {
    const s = this._rooms[n], o = this._presence[n];
    if (!s || !o)
      return;
    o.result = o.result || {};
    const i = {
      ...o.result.user,
      ...r
    };
    o.result.user = i, s.isConnected && (this._trySetPresence(n, i), this._notifyPresenceSubs(n));
  }
  _trySetPresence(e, n) {
    this._trySendAuthed(Is(), {
      op: "set-presence",
      "room-id": e,
      data: n
    });
  }
  _tryJoinRoom(e, n) {
    this._trySendAuthed(Is(), { op: "join-room", "room-id": e, data: n }), delete this._roomsPendingLeave[e];
  }
  _tryLeaveRoom(e) {
    this._trySendAuthed(Is(), { op: "leave-room", "room-id": e });
  }
  _trySetRoomConnected(e, n) {
    const r = this._rooms[e];
    r && (r.isConnected = n);
  }
  // TODO: look into typing again
  subscribePresence(e, n, r, s) {
    const o = this.joinRoom(
      n,
      // Oct 28, 2025
      // Note: initialData is deprecated.
      // Keeping here for backwards compatibility
      r.initialPresence || r.initialData
    ), i = { ...r, roomId: n, cb: s, prev: null };
    return this._presence[n] = this._presence[n] || {}, this._presence[n].handlers = this._presence[n].handlers || [], this._presence[n].handlers.push(i), this._notifyPresenceSub(n, i), () => {
      var a, c;
      this._presence[n].handlers = ((c = (a = this._presence[n]) == null ? void 0 : a.handlers) == null ? void 0 : c.filter((l) => l !== i)) ?? [], o();
    };
  }
  _notifyPresenceSubs(e) {
    var n, r;
    (r = (n = this._presence[e]) == null ? void 0 : n.handlers) == null || r.forEach((s) => {
      this._notifyPresenceSub(e, s);
    });
  }
  _notifyPresenceSub(e, n) {
    const r = this.getPresence("", e, n);
    r && (n.prev && !lPe(r, n.prev) || (n.prev = r, n.cb(r)));
  }
  _patchPresencePeers(e, n) {
    var i, a, c;
    const r = ((a = (i = this._presence[e]) == null ? void 0 : i.result) == null ? void 0 : a.peers) || {};
    let s = Object.fromEntries(Object.entries(r).map(([l, d]) => [l, { data: d }]));
    (c = this._presence[e]) == null || c.result;
    const o = sE(s, (l) => {
      for (let [d, u, f] of n)
        switch (u) {
          case "+":
            B_e(l, d, f);
            break;
          case "r":
            E6(l, d, f);
            break;
          case "-":
            KZ(l, d);
            break;
        }
      delete l[this._sessionId];
    });
    this._setPresencePeers(e, o);
  }
  _setPresencePeers(e, n) {
    const r = { ...n };
    delete r[this._sessionId];
    const s = Object.fromEntries(Object.entries(r).map(([o, i]) => [o, i.data]));
    this._presence = sE(this._presence, (o) => {
      E6(o, [e, "result", "peers"], s);
    });
  }
  // --------
  // Broadcast
  publishTopic({ roomType: e, roomId: n, topic: r, data: s }) {
    const o = this._rooms[n];
    if (o) {
      if (!o.isConnected) {
        this._broadcastQueue[n] = this._broadcastQueue[n] ?? [], this._broadcastQueue[n].push({ topic: r, roomType: e, data: s });
        return;
      }
      this._tryBroadcast(n, e, r, s);
    }
  }
  _tryBroadcast(e, n, r, s) {
    this._trySendAuthed(Is(), {
      op: "client-broadcast",
      "room-id": e,
      roomType: n,
      topic: r,
      data: s
    });
  }
  subscribeTopic(e, n, r) {
    const s = this.joinRoom(e);
    return this._broadcastSubs[e] = this._broadcastSubs[e] || {}, this._broadcastSubs[e][n] = this._broadcastSubs[e][n] || [], this._broadcastSubs[e][n].push(r), this._presence[e] = this._presence[e] || {}, () => {
      this._broadcastSubs[e][n] = this._broadcastSubs[e][n].filter((o) => o !== r), this._broadcastSubs[e][n].length || delete this._broadcastSubs[e][n], s();
    };
  }
  _notifyBroadcastSubs(e, n, r) {
    var s, o, i;
    (i = (o = (s = this._broadcastSubs) == null ? void 0 : s[e]) == null ? void 0 : o[n]) == null || i.forEach((a) => {
      var d, u, f, p, g, y;
      const c = (d = r.data) == null ? void 0 : d.data, l = r.data["peer-id"] === this._sessionId ? (f = (u = this._presence[e]) == null ? void 0 : u.result) == null ? void 0 : f.user : (y = (g = (p = this._presence[e]) == null ? void 0 : p.result) == null ? void 0 : g.peers) == null ? void 0 : y[r.data["peer-id"]];
      return a(c, l);
    });
  }
  // --------
  // Storage
  async uploadFile(e, n, r) {
    var i;
    const s = await this.getCurrentUser(), o = (i = s == null ? void 0 : s.user) == null ? void 0 : i.refresh_token;
    return rPe({
      ...r,
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      file: n,
      refreshToken: o
    });
  }
  async deleteFile(e) {
    var o;
    const n = await this.getCurrentUser(), r = (o = n == null ? void 0 : n.user) == null ? void 0 : o.refresh_token;
    return await sPe({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      refreshToken: r
    });
  }
  // Deprecated Storage API (Jan 2025)
  // ---------------------------------
  async upload(e, n) {
    var c;
    const r = await this.getCurrentUser(), s = (c = r == null ? void 0 : r.user) == null ? void 0 : c.refresh_token, o = e || n.name, i = await oPe({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      fileName: o,
      refreshToken: s
    });
    return await iPe(i, n);
  }
  async getDownloadUrl(e) {
    var o;
    const n = await this.getCurrentUser(), r = (o = n == null ? void 0 : n.user) == null ? void 0 : o.refresh_token;
    return await aPe({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      refreshToken: r
    });
  }
}
let l1;
function zPe(t, e) {
  l1 == null || l1.dispose();
  const n = GPe(e), r = VPe(e, a), s = HPe(UPe(t));
  function o(d) {
    var u;
    d.source === s.element.contentWindow && ((u = d.data) == null ? void 0 : u.type) === "close" && n.isVisible() && a();
  }
  function i(d) {
    const u = d.shiftKey && d.ctrlKey && d.key === "0", f = d.key === "Escape" || d.key === "Esc";
    (u || f && n.isVisible()) && a();
  }
  function a() {
    n.isVisible() ? n.element.style.display = "none" : (n.element.style.display = "block", n.element.contains(s.element) || n.element.appendChild(s.element));
  }
  function c() {
    n.element.remove(), r.element.remove(), removeEventListener("keydown", i), removeEventListener("message", o);
  }
  function l() {
    document.body.appendChild(n.element), document.body.appendChild(r.element), addEventListener("keydown", i), addEventListener("message", o), l1 = {
      dispose: c
    };
  }
  return l();
}
function UPe(t) {
  return `${kL || pQ ? "http://localhost:3000" : "https://instantdb.com"}/_devtool?appId=${t}`;
}
function HPe(t) {
  const e = document.createElement("iframe");
  return e.src = t, e.className = "instant-devtool-iframe", Object.assign(e.style, {
    width: "100%",
    height: "100%",
    backgroundColor: "white",
    border: "none"
  }), { element: e };
}
function VPe(t, e) {
  const n = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `, r = document.createElement("button");
  return r.innerHTML = n, r.className = "instant-devtool-toggler", Object.assign(r.style, {
    // pos
    position: "fixed",
    ...WPe(t.position),
    height: "32px",
    width: "32px",
    // layout
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    zIndex: "9010",
    // look
    padding: "0",
    margin: "0",
    border: "none",
    cursor: "pointer"
  }), r.addEventListener("click", e), { element: r };
}
function WPe(t) {
  switch (t) {
    case "bottom-left":
      return { bottom: "24px", left: "24px" };
    case "bottom-right":
      return { bottom: "24px", right: "24px" };
    case "top-right":
      return { top: "24px", right: "24px" };
    case "top-left":
      return { top: "24px", left: "24px" };
  }
}
function KPe(t) {
  switch (t) {
    case "bottom-left":
      return { bottom: "24px", right: "24px", left: "60px", top: "72px" };
    case "bottom-right":
      return { bottom: "24px", left: "24px", right: "60px", top: "72px" };
    case "top-right":
      return { top: "24px", left: "24px", right: "60px", bottom: "72px" };
    case "top-left":
      return { top: "24px", right: "24px", left: "60px", bottom: "72px" };
  }
}
function GPe(t) {
  const e = document.createElement("div");
  Object.assign(e.style, {
    position: "fixed",
    ...KPe(t.position),
    display: "block",
    borderRadius: "4px",
    border: "1px #ccc solid",
    boxShadow: "0px 0px 8px #00000044",
    backgroundColor: "#eee",
    zIndex: "999990"
  }), e.style.display = "none", e.className = "instant-devtool-container";
  function n() {
    return e.style.display !== "none";
  }
  return { element: e, isVisible: n };
}
const YPe = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
function qPe() {
  return globalThis.__instantDbSchemaHashStore = globalThis.__instantDbSchemaHashStore ?? /* @__PURE__ */ new WeakMap(), globalThis.__instantDbSchemaHashStore;
}
function XPe() {
  return globalThis.__instantDbStore = globalThis.__instantDbStore ?? {}, globalThis.__instantDbStore;
}
function mN(t) {
  const e = t.__adminToken;
  return t.appId + "_" + (t.websocketURI || "default_ws_uri") + "_" + (t.apiURI || "default_api_uri") + "_" + (e || "client_only") + "_" + t.useDateObjects;
}
const yN = XPe(), Z6 = qPe();
class ZPe {
  constructor(e) {
    P(this, "db");
    /**
     * Sends a magic code to the user's email address.
     *
     * Once you send the magic code, see {@link auth.signInWithMagicCode} to let the
     * user verify.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *  db.auth.sendMagicCode({email: "example@gmail.com"})
     *    .catch((err) => console.error(err.body?.message))
     */
    P(this, "sendMagicCode", (e) => this.db.sendMagicCode(e));
    /**
     * Verify a magic code that was sent to the user's email address.
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  db.auth.signInWithMagicCode({email: "example@gmail.com", code: "123456"})
     *       .catch((err) => console.error(err.body?.message))
     */
    P(this, "signInWithMagicCode", (e) => this.db.signInWithMagicCode(e));
    /**
     * Sign in a user with a refresh token
     *
     * @see https://instantdb.com/docs/backend#frontend-auth-sign-in-with-token
     *
     * @example
     *   // Get the token from your backend
     *   const token = await fetch('/signin', ...);
     *   //Sign in
     *   db.auth.signInWithToken(token);
     */
    P(this, "signInWithToken", (e) => this.db.signInWithCustomToken(e));
    /**
     * Sign in as guest, creating a new user without email
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *   db.auth.signInAsGuest();
     */
    P(this, "signInAsGuest", () => this.db.signInAsGuest());
    /**
     * Create an authorization url to sign in with an external provider.
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *   // Get the authorization url from your backend
     *   const url = db.auth.createAuthorizationUrl({
     *     clientName: "google",
     *     redirectURL: window.location.href,
     *   });
     *
     *   // Put it in a sign in link
     *   <a href={url}>Log in with Google</a>
     */
    P(this, "createAuthorizationURL", (e) => this.db.createAuthorizationURL(e));
    /**
     * Sign in with the id_token from an external provider like Google
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   db.auth
     *  .signInWithIdToken({
     *    // Token from external service
     *    idToken: id_token,
     *    // The name you gave the client when you registered it with Instant
     *    clientName: "google",
     *    // The nonce, if any, that you used when you initiated the auth flow
     *    // with the external service.
     *    nonce: your_nonce
     *  })
     *  .catch((err) => console.error(err.body?.message));
     *
     */
    P(this, "signInWithIdToken", (e) => this.db.signInWithIdToken(e));
    /**
     * Sign in with the id_token from an external provider like Google
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   db.auth
     *  .exchangeOAuthCode({
     *    // code received in redirect from OAuth callback
     *    code: code
     *    // The PKCE code_verifier, if any, that you used when you
     *    // initiated the auth flow
     *    codeVerifier: your_code_verifier
     *  })
     *  .catch((err) => console.error(err.body?.message));
     *
     */
    P(this, "exchangeOAuthCode", (e) => this.db.exchangeCodeForToken(e));
    /**
     * OpenID Discovery path for use with tools like
     * expo-auth-session that use auto-discovery of
     * OAuth parameters.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const discovery = useAutoDiscovery(
     *     db.auth.issuerURI()
     *   );
     */
    P(this, "issuerURI", () => this.db.issuerURI());
    /**
     * Sign out the current user
     */
    P(this, "signOut", (e = { invalidateToken: !0 }) => this.db.signOut(e));
    this.db = e;
  }
}
class QPe {
  constructor(e) {
    P(this, "db");
    /**
     * Uploads file at the provided path.
     *
     * @see https://instantdb.com/docs/storage
     * @example
     *   const [file] = e.target.files; // result of file input
     *   const data = await db.storage.uploadFile('photos/demo.png', file);
     */
    P(this, "uploadFile", (e, n, r = {}) => this.db.uploadFile(e, n, r));
    /**
     * Deletes a file by path name.
     *
     * @see https://instantdb.com/docs/storage
     * @example
     *   await db.storage.delete('photos/demo.png');
     */
    P(this, "delete", (e) => this.db.deleteFile(e));
    // Deprecated Storage API (Jan 2025)
    // ---------------------------------
    /**
     * @deprecated. Use `db.storage.uploadFile` instead
     * remove in the future.
     */
    P(this, "upload", (e, n) => this.db.upload(e, n));
    /**
     * @deprecated Use `db.storage.uploadFile` instead
     */
    P(this, "put", this.upload);
    /**
     * @deprecated. getDownloadUrl will be removed in the future.
     * Use `useQuery` instead to query and fetch for valid urls
     *
     * db.useQuery({
     *   $files: {
     *     $: {
     *       where: {
     *         path: "moop.png"
     *       }
     *     }
     *   }
     * })
     */
    P(this, "getDownloadUrl", (e) => this.db.getDownloadUrl(e));
    this.db = e;
  }
}
function JPe(t) {
  return JSON.parse(JSON.stringify(t));
}
class eIe {
  constructor(e) {
    P(this, "_reactor");
    P(this, "auth");
    P(this, "storage");
    P(this, "tx", IL());
    this._reactor = e, this.auth = new ZPe(this._reactor), this.storage = new QPe(this._reactor);
  }
  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(db.tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(db.tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(db.tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    db.tx.todos[todoId].update({ title: 'Go on a run' }),
   *    db.tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact(e) {
    return this._reactor.pushTx(e);
  }
  getLocalId(e) {
    return this._reactor.getLocalId(e);
  }
  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.subscribeQuery({ goals: {} }, (resp) => {
   *    console.log(resp.data.goals)
   *  })
   *
   *  // goals where the title is "Get Fit"
   *  db.subscribeQuery(
   *    { goals: { $: { where: { title: "Get Fit" } } } },
   *    (resp) => {
   *      console.log(resp.data.goals)
   *    }
   *  )
   *
   *  // all goals, _alongside_ their todos
   *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
   *    console.log(resp.data.goals)
   *  });
   */
  subscribeQuery(e, n, r) {
    return this._reactor.subscribeQuery(e, n, r);
  }
  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const unsub = db.subscribeAuth((auth) => {
   *     if (auth.user) {
   *     console.log('logged in as', auth.user.email)
   *    } else {
   *      console.log('logged out')
   *    }
   *  })
   */
  subscribeAuth(e) {
    return this._reactor.subscribeAuth(e);
  }
  /**
   * One time query for the logged in state. This is useful
   * for scenarios where you want to know the current auth
   * state without subscribing to changes.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const user = await db.getAuth();
   *   console.log('logged in as', user.email)
   */
  getAuth() {
    return this._reactor.getAuth();
  }
  /**
   * Listen for connection status changes to Instant. This is useful
   * for building things like connectivity indicators
   *
   * @see https://www.instantdb.com/docs/patterns#connection-status
   * @example
   *   const unsub = db.subscribeConnectionStatus((status) => {
   *     const connectionState =
   *       status === 'connecting' || status === 'opened'
   *         ? 'authenticating'
   *       : status === 'authenticated'
   *         ? 'connected'
   *       : status === 'closed'
   *         ? 'closed'
   *       : status === 'errored'
   *         ? 'errored'
   *       : 'unexpected state';
   *
   *     console.log('Connection status:', connectionState);
   *   });
   */
  subscribeConnectionStatus(e) {
    return this._reactor.subscribeConnectionStatus(e);
  }
  /**
   * Join a room to publish and subscribe to topics and presence.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   * @example
   * // init
   * const db = init();
   * const room = db.joinRoom(roomType, roomId);
   * // usage
   * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
   * const unsubscribePresence = room.subscribePresence({}, console.log);
   * room.publishTopic("hello", { message: "hello world!" });
   * room.publishPresence({ name: "joe" });
   * // later
   * unsubscribePresence();
   * unsubscribeTopic();
   * room.leaveRoom();
   */
  joinRoom(e = "_defaultRoomType", n = "_defaultRoomId", r) {
    return {
      leaveRoom: this._reactor.joinRoom(n, r == null ? void 0 : r.initialPresence),
      subscribeTopic: (o, i) => this._reactor.subscribeTopic(n, o, i),
      subscribePresence: (o, i) => this._reactor.subscribePresence(e, n, o, i),
      publishTopic: (o, i) => this._reactor.publishTopic({ roomType: e, roomId: n, topic: o, data: i }),
      publishPresence: (o) => this._reactor.publishPresence(e, n, o),
      getPresence: (o) => this._reactor.getPresence(e, n, o)
    };
  }
  shutdown() {
    delete yN[mN(this._reactor.config)], this._reactor.shutdown();
  }
  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce(e, n) {
    return this._reactor.queryOnce(e, n);
  }
  /**
   * @deprecated This is an experimental function that is not yet ready for production use.
   * Use this function to sync an entire namespace.
   * It has many limitations that will be removed in the future:
   * 1. Must be used with an admin token
   * 2. Does not support permissions
   * 3. Does not support where clauses
   * 4. Does not support links
   * It also does not support multiple top-level namespaces. For example,
   *  {posts: {}, users: {}} is invalid. Only `posts` or `users` is allowed, but not both.
   */
  _syncTableExperimental(e, n) {
    return this._reactor.subscribeTable(e, n);
  }
}
function Q6(t) {
  if (!t)
    return "0";
  const e = Z6.get(t);
  if (e)
    return e;
  const n = Ps(t);
  return Z6.set(t, n), n;
}
function tIe(t, e) {
  return Q6(t._reactor.config.schema) !== Q6(e);
}
function nIe(t, e, n, r, s) {
  var l;
  const o = {
    ...t,
    appId: (l = t.appId) == null ? void 0 : l.trim(),
    useDateObjects: t.useDateObjects ?? !1
  }, i = yN[mN(o)];
  if (i)
    return tIe(i, o.schema) && i._reactor.updateSchema(o.schema), i;
  const a = new BPe({
    ...YPe,
    ...o,
    cardinalityInference: !!o.schema
  }, e || uQ, n || fQ, { ...r || {}, "@instantdb/core": AL }, s), c = new eIe(a);
  return yN[mN(o)] = c, rIe(o.appId, o.devtool), c;
}
function rIe(t, e) {
  if (typeof window > "u" || typeof window.location > "u" || typeof document > "u" || typeof e == "boolean" && !e)
    return;
  const n = {
    position: "bottom-right",
    allowedHosts: ["localhost"],
    ...typeof e == "object" ? e : {}
  };
  n.allowedHosts.includes(window.location.hostname) && zPe(t, n);
}
const sIe = {
  isLoading: !0,
  data: void 0,
  pageInfo: void 0,
  error: void 0
};
function J6(t) {
  return {
    isLoading: !t,
    data: void 0,
    pageInfo: void 0,
    error: void 0,
    ...t || {}
  };
}
function oIe(t, e, n) {
  e && n && "ruleParams" in n && (e = { $$ruleParams: n.ruleParams, ...e });
  const r = e ? JPe(e) : null, s = Ps(r), o = fe(J6(t._reactor.getPreviousResult(r))), i = re(
    (c) => (o.current = J6(t._reactor.getPreviousResult(r)), c(), r ? t.subscribeQuery(r, (d) => {
      o.current = {
        isLoading: !d,
        // @ts-expect-error: ts thinks this will always be overwritten
        data: void 0,
        // @ts-expect-error: ts thinks this will always be overwritten
        pageInfo: void 0,
        // @ts-expect-error: ts thinks this will always be overwritten
        error: void 0,
        ...d
      }, c();
    }) : () => {
    }),
    // Build a new subscribe function if the query changes
    [s]
  );
  return { state: Gx(i, () => o.current, () => sIe), query: r };
}
function iIe() {
  const t = fe(null);
  me(() => {
    n();
  }, []);
  function e(r, s) {
    n(), t.current = setTimeout(s, r);
  }
  function n() {
    t.current && clearTimeout(t.current);
  }
  return { set: e, clear: n };
}
const aIe = 1e3;
function cIe(t, e, n) {
  const r = fe(n);
  r.current = n, me(() => t.core._reactor.subscribeTopic(t.id, e, (o, i) => {
    r.current(o, i);
  }), [t.id, e]);
}
function lIe(t, e) {
  return me(() => t.core._reactor.joinRoom(t.id), [t.id]), re((r) => {
    t.core._reactor.publishTopic({
      roomType: t.type,
      roomId: t.id,
      topic: e,
      data: r
    });
  }, [t.id, e]);
}
function dIe(t, e = {}) {
  var i, a;
  const [n, r] = he(() => t.core._reactor.getPresence(t.type, t.id, e) ?? {
    peers: {},
    isLoading: !0
  });
  me(() => t.core._reactor.subscribePresence(t.type, t.id, e, (l) => {
    r(l);
  }), [t.id, e.user, (i = e.peers) == null ? void 0 : i.join(), (a = e.keys) == null ? void 0 : a.join()]);
  const s = re((c) => {
    t.core._reactor.publishPresence(t.type, t.id, c);
  }, [t.type, t.id]);
  return Ke(() => ({
    ...n,
    publishPresence: s
  }), [n, s]);
}
function uIe(t, e, n) {
  me(() => t.core._reactor.joinRoom(t.id, e), [t.id]), me(() => t.core._reactor.publishPresence(t.type, t.id, e), [t.type, t.id, n ?? JSON.stringify(e)]);
}
function fIe(t, e, n = {}) {
  const r = iIe(), s = Dh.usePresence(t, {
    keys: [e]
  }), o = Ke(() => {
    const d = t._core._reactor.getPresence(t.type, t.id);
    return n != null && n.writeOnly ? [] : Object.values((d == null ? void 0 : d.peers) ?? {}).filter((u) => u[e] === !0);
  }, [n == null ? void 0 : n.writeOnly, s]), i = re((d) => {
    t.core._reactor.publishPresence(t.type, t.id, {
      [e]: d
    }), d && ((n == null ? void 0 : n.timeout) === null || (n == null ? void 0 : n.timeout) === 0 || r.set((n == null ? void 0 : n.timeout) ?? aIe, () => {
      t.core._reactor.publishPresence(t.type, t.id, {
        [e]: null
      });
    }));
  }, [t.type, t.id, e, n == null ? void 0 : n.timeout, r]), a = re((d) => {
    const f = !((n == null ? void 0 : n.stopOnEnter) && d.key === "Enter");
    i(f);
  }, [n.stopOnEnter, i]), c = re(() => {
    i(!1);
  }, [i]), l = Ke(() => ({ onKeyDown: a, onBlur: c }), [a, c]);
  return {
    active: o,
    setActive: i,
    inputProps: l
  };
}
const Dh = {
  useTopicEffect: cIe,
  usePublishTopic: lIe,
  usePresence: dIe,
  useSyncPresence: uIe,
  useTypingIndicator: fIe
};
class hIe {
  constructor(e, n, r) {
    P(this, "core");
    /** @deprecated use `core` instead */
    P(this, "_core");
    P(this, "type");
    P(this, "id");
    /**
     * @deprecated
     * `db.room(...).useTopicEffect` is deprecated. You can replace it with `db.rooms.useTopicEffect`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * room.useTopicEffect('emoji', (message, peer) => {  });
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * db.rooms.useTopicEffect(room, 'emoji', (message, peer) => {  });
     */
    P(this, "useTopicEffect", (e, n) => {
      Dh.useTopicEffect(this, e, n);
    });
    /**
     * @deprecated
     * `db.room(...).usePublishTopic` is deprecated. You can replace it with `db.rooms.usePublishTopic`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * const publish = room.usePublishTopic('emoji');
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * const publish = db.rooms.usePublishTopic(room, 'emoji');
     */
    P(this, "usePublishTopic", (e) => Dh.usePublishTopic(this, e));
    /**
     * @deprecated
     * `db.room(...).usePresence` is deprecated. You can replace it with `db.rooms.usePresence`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * const { peers } = room.usePresence({ keys: ["name", "avatar"] });
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * const { peers } = db.rooms.usePresence(room, { keys: ["name", "avatar"] });
     */
    P(this, "usePresence", (e = {}) => Dh.usePresence(this, e));
    /**
     * @deprecated
     * `db.room(...).useSyncPresence` is deprecated. You can replace it with `db.rooms.useSyncPresence`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * room.useSyncPresence(room, { nickname });
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * db.rooms.useSyncPresence(room, { nickname });
     */
    P(this, "useSyncPresence", (e, n) => Dh.useSyncPresence(this, e, n));
    /**
     * @deprecated
     * `db.room(...).useTypingIndicator` is deprecated. You can replace it with `db.rooms.useTypingIndicator`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * const typing = room.useTypingIndiactor(room, 'chat-input');
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * const typing = db.rooms.useTypingIndiactor(room, 'chat-input');
     */
    P(this, "useTypingIndicator", (e, n = {}) => Dh.useTypingIndicator(this, e, n));
    this.core = e, this._core = this.core, this.type = n, this.id = r;
  }
}
const pIe = {
  isLoading: !0,
  user: void 0,
  error: void 0
};
class VC {
  constructor(e, n) {
    P(this, "tx", IL());
    P(this, "auth");
    P(this, "storage");
    P(this, "core");
    /** @deprecated use `core` instead */
    P(this, "_core");
    /**
     * Returns a unique ID for a given `name`. It's stored in local storage,
     * so you will get the same ID across sessions.
     *
     * This is useful for generating IDs that could identify a local device or user.
     *
     * @example
     *  const deviceId = await db.getLocalId('device');
     */
    P(this, "getLocalId", (e) => this.core.getLocalId(e));
    /**
     * A hook that returns a unique ID for a given `name`. localIds are
     * stored in local storage, so you will get the same ID across sessions.
     *
     * Initially returns `null`, and then loads the localId.
     *
     * @example
     * const deviceId = db.useLocalId('device');
     * if (!deviceId) return null; // loading
     * console.log('Device ID:', deviceId)
     */
    P(this, "useLocalId", (e) => {
      const [n, r] = he(null);
      return me(() => {
        (async () => {
          const o = await this.getLocalId(e);
          r(o);
        })();
      }, [e]), n;
    });
    /**
     * Hooks for working with rooms
     *
     * @see https://instantdb.com/docs/presence-and-topics
     *
     * @example
     *  const room = db.room('chat', roomId);
     *  const { peers } = db.rooms.usePresence(room);
     *  const publish = db.rooms.usePublishTopic(room, 'emoji');
     *  // ...
     */
    P(this, "rooms", Dh);
    /**
     * Use this to write data! You can create, update, delete, and link objects
     *
     * @see https://instantdb.com/docs/instaml
     *
     * @example
     *   // Create a new object in the `goals` namespace
     *   const goalId = id();
     *   db.transact(db.tx.goals[goalId].update({title: "Get fit"}))
     *
     *   // Update the title
     *   db.transact(db.tx.goals[goalId].update({title: "Get super fit"}))
     *
     *   // Delete it
     *   db.transact(db.tx.goals[goalId].delete())
     *
     *   // Or create an association:
     *   todoId = id();
     *   db.transact([
     *    db.tx.todos[todoId].update({ title: 'Go on a run' }),
     *    db.tx.goals[goalId].link({todos: todoId}),
     *  ])
     */
    P(this, "transact", (e) => this.core.transact(e));
    /**
     * Use this to query your data!
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *   // listen to all goals
     *   const { isLoading, error, data } = db.useQuery({ goals: {} });
     *
     *   // goals where the title is "Get Fit"
     *   const { isLoading, error, data } = db.useQuery({
     *     goals: { $: { where: { title: 'Get Fit' } } },
     *   });
     *
     *   // all goals, _alongside_ their todos
     *   const { isLoading, error, data } = db.useQuery({
     *     goals: { todos: {} },
     *   });
     *
     *   // skip if `user` is not logged in
     *   const { isLoading, error, data } = db.useQuery(
     *     auth.user ? { goals: {} } : null,
     *   );
     */
    P(this, "useQuery", (e, n) => oIe(this.core, e, n).state);
    /**
     * Listen for the logged in state. This is useful
     * for deciding when to show a login screen.
     *
     * Check out the docs for an example `Login` component too!
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *  function App() {
     *    const { isLoading, user, error } = db.useAuth()
     *    if (isLoading) {
     *      return <div>Loading...</div>
     *    }
     *    if (error) {
     *      return <div>Uh oh! {error.message}</div>
     *    }
     *    if (user) {
     *      return <Main user={user} />
     *    }
     *    return <Login />
     *  }
     *
     */
    P(this, "useAuth", () => this._useAuth());
    /**
     * Subscribe to the currently logged in user.
     * If the user is not logged in, this hook with throw an Error.
     * You will want to protect any calls of this hook with a
     * <db.SignedIn> component, or your own logic based on db.useAuth()
     *
     * @see https://instantdb.com/docs/auth
     * @throws Error indicating user not signed in
     * @example
     *  function UserDisplay() {
     *    const user = db.useUser()
     *    return <div>Logged in as: {user.email}</div>
     *  }
     *
     *  <db.SignedIn>
     *    <UserDisplay />
     *  </db.SignedIn>
     *
     */
    P(this, "useUser", () => {
      const { user: e } = this.useAuth();
      if (!e)
        throw new Jm("useUser must be used within an auth-protected route");
      return e;
    });
    /**
     * Listen for connection status changes to Instant. Use this for things like
     * showing connection state to users
     *
     * @see https://www.instantdb.com/docs/patterns#connection-status
     * @example
     *  function App() {
     *    const status = db.useConnectionStatus()
     *    const connectionState =
     *      status === 'connecting' || status === 'opened'
     *        ? 'authenticating'
     *      : status === 'authenticated'
     *        ? 'connected'
     *      : status === 'closed'
     *        ? 'closed'
     *      : status === 'errored'
     *        ? 'errored'
     *      : 'unexpected state';
     *
     *    return <div>Connection state: {connectionState}</div>
     *  }
     */
    P(this, "useConnectionStatus", () => {
      const e = fe(this.core._reactor.status), n = re((s) => this.core.subscribeConnectionStatus((i) => {
        i !== e.current && (e.current = i, s());
      }), []);
      return Gx(
        n,
        () => e.current,
        // For SSR, always return 'connecting' as the initial state
        () => "connecting"
      );
    });
    /**
     * Use this for one-off queries.
     * Returns local data if available, otherwise fetches from the server.
     * Because we want to avoid stale data, this method will throw an error
     * if the user is offline or there is no active connection to the server.
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *
     *  const resp = await db.queryOnce({ goals: {} });
     *  console.log(resp.data.goals)
     */
    P(this, "queryOnce", (e, n) => this.core.queryOnce(e, n));
    /**
     * Only render children if the user is signed in.
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  <db.SignedIn>
     *    <MyComponent />
     *  </db.SignedIn>
     *
     */
    P(this, "SignedIn", ({ children: e }) => {
      const n = this.useAuth();
      return n.isLoading || n.error || !n.user ? null : h.jsx(h.Fragment, { children: e });
    });
    /**
     * Only render children if the user is signed out.
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  <db.SignedOut>
     *    <MyComponent />
     *  </db.SignedOut>
     *
     */
    P(this, "SignedOut", ({ children: e }) => {
      const n = this.useAuth();
      return n.isLoading || n.error || n.user ? null : h.jsx(h.Fragment, { children: e });
    });
    this.core = nIe(
      e,
      // @ts-expect-error because TS can't resolve subclass statics
      e.Store || this.constructor.Store,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.NetworkListener,
      n,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.EventSourceImpl
    ), this._core = this.core, this.auth = this.core.auth, this.storage = this.core.storage;
  }
  /**
   * Obtain a handle to a room, which allows you to listen to topics and presence data
   *
   * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
   * as the room type and id, respectively.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   *
   * @example
   *  const room = db.room('chat', roomId);
   *  const { peers } = db.rooms.usePresence(room);
   */
  room(e = "_defaultRoomType", n = "_defaultRoomId") {
    return new hIe(this.core, e, n);
  }
  _useAuth() {
    const e = fe(this.core._reactor._currentUserCached), n = re((s) => this.core.subscribeAuth((i) => {
      e.current = { isLoading: !1, ...i }, s();
    }), []);
    return Gx(n, () => e.current, () => pIe);
  }
  /**
   * One time query for the logged in state. This is useful
   * for scenarios where you want to know the current auth
   * state without subscribing to changes.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const user = await db.getAuth();
   *   console.log('logged in as', user.email)
   */
  getAuth() {
    return this.core.getAuth();
  }
}
P(VC, "Store"), P(VC, "NetworkListener"), P(VC, "EventSourceImpl");
class eU extends Error {
  constructor(e, n) {
    super(e), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
}
function aM(t) {
}
function gIe(t) {
  if (typeof t == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: e = aM, onError: n = aM, onRetry: r = aM, onComment: s } = t;
  let o = "", i = !0, a, c = "", l = "";
  function d(y) {
    const m = i ? y.replace(/^\xEF\xBB\xBF/, "") : y, [v, b] = mIe(`${o}${m}`);
    for (const x of v)
      u(x);
    o = b, i = !1;
  }
  function u(y) {
    if (y === "") {
      p();
      return;
    }
    if (y.startsWith(":")) {
      s && s(y.slice(y.startsWith(": ") ? 2 : 1));
      return;
    }
    const m = y.indexOf(":");
    if (m !== -1) {
      const v = y.slice(0, m), b = y[m + 1] === " " ? 2 : 1, x = y.slice(m + b);
      f(v, x, y);
      return;
    }
    f(y, "", y);
  }
  function f(y, m, v) {
    switch (y) {
      case "event":
        l = m;
        break;
      case "data":
        c = `${c}${m}
`;
        break;
      case "id":
        a = m.includes("\0") ? void 0 : m;
        break;
      case "retry":
        /^\d+$/.test(m) ? r(parseInt(m, 10)) : n(
          new eU(`Invalid \`retry\` value: "${m}"`, {
            type: "invalid-retry",
            value: m,
            line: v
          })
        );
        break;
      default:
        n(
          new eU(
            `Unknown field "${y.length > 20 ? `${y.slice(0, 20)}` : y}"`,
            { type: "unknown-field", field: y, value: m, line: v }
          )
        );
        break;
    }
  }
  function p() {
    c.length > 0 && e({
      id: a,
      event: l || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: c.endsWith(`
`) ? c.slice(0, -1) : c
    }), a = void 0, c = "", l = "";
  }
  function g(y = {}) {
    o && y.consume && u(o), i = !0, a = void 0, c = "", l = "", o = "";
  }
  return { feed: d, reset: g };
}
function mIe(t) {
  const e = [];
  let n = "", r = 0;
  for (; r < t.length; ) {
    const s = t.indexOf("\r", r), o = t.indexOf(`
`, r);
    let i = -1;
    if (s !== -1 && o !== -1 ? i = Math.min(s, o) : s !== -1 ? s === t.length - 1 ? i = -1 : i = s : o !== -1 && (i = o), i === -1) {
      n = t.slice(r);
      break;
    } else {
      const a = t.slice(r, i);
      e.push(a), r = i + 1, t[r - 1] === "\r" && t[r] === `
` && r++;
    }
  }
  return [e, n];
}
class tU extends Event {
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(e, n) {
    var r, s;
    super(e), this.code = (r = n == null ? void 0 : n.code) != null ? r : void 0, this.message = (s = n == null ? void 0 : n.message) != null ? s : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [Symbol.for("nodejs.util.inspect.custom")](e, n, r) {
    return r(nU(this), n);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [Symbol.for("Deno.customInspect")](e, n) {
    return e(nU(this), n);
  }
}
function yIe(t) {
  const e = globalThis.DOMException;
  return typeof e == "function" ? new e(t, "SyntaxError") : new SyntaxError(t);
}
function vN(t) {
  return t instanceof Error ? "errors" in t && Array.isArray(t.errors) ? t.errors.map(vN).join(", ") : "cause" in t && t.cause instanceof Error ? `${t}: ${vN(t.cause)}` : t.message : `${t}`;
}
function nU(t) {
  return {
    type: t.type,
    message: t.message,
    code: t.code,
    defaultPrevented: t.defaultPrevented,
    cancelable: t.cancelable,
    timeStamp: t.timeStamp
  };
}
var SQ = (t) => {
  throw TypeError(t);
}, ML = (t, e, n) => e.has(t) || SQ("Cannot " + n), Xt = (t, e, n) => (ML(t, e, "read from private field"), n ? n.call(t) : e.get(t)), us = (t, e, n) => e.has(t) ? SQ("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), rr = (t, e, n, r) => (ML(t, e, "write to private field"), e.set(t, n), n), Od = (t, e, n) => (ML(t, e, "access private method"), n), ki, Nh, qg, WC, aE, dx, am, ux, Gu, Xg, Cm, Zg, kb, Tc, bN, xN, wN, rU, SN, CN, Ab, _N, EN;
class fx extends EventTarget {
  constructor(e, n) {
    var r, s;
    super(), us(this, Tc), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, us(this, ki), us(this, Nh), us(this, qg), us(this, WC), us(this, aE), us(this, dx), us(this, am), us(this, ux, null), us(this, Gu), us(this, Xg), us(this, Cm, null), us(this, Zg, null), us(this, kb, null), us(this, xN, async (o) => {
      var i;
      Xt(this, Xg).reset();
      const { body: a, redirected: c, status: l, headers: d } = o;
      if (l === 204) {
        Od(this, Tc, Ab).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (c ? rr(this, qg, new URL(o.url)) : rr(this, qg, void 0), l !== 200) {
        Od(this, Tc, Ab).call(this, `Non-200 status code (${l})`, l);
        return;
      }
      if (!(d.get("content-type") || "").startsWith("text/event-stream")) {
        Od(this, Tc, Ab).call(this, 'Invalid content type, expected "text/event-stream"', l);
        return;
      }
      if (Xt(this, ki) === this.CLOSED)
        return;
      rr(this, ki, this.OPEN);
      const u = new Event("open");
      if ((i = Xt(this, kb)) == null || i.call(this, u), this.dispatchEvent(u), typeof a != "object" || !a || !("getReader" in a)) {
        Od(this, Tc, Ab).call(this, "Invalid response body, expected a web ReadableStream", l), this.close();
        return;
      }
      const f = new TextDecoder(), p = a.getReader();
      let g = !0;
      do {
        const { done: y, value: m } = await p.read();
        m && Xt(this, Xg).feed(f.decode(m, { stream: !y })), y && (g = !1, Xt(this, Xg).reset(), Od(this, Tc, _N).call(this));
      } while (g);
    }), us(this, wN, (o) => {
      rr(this, Gu, void 0), !(o.name === "AbortError" || o.type === "aborted") && Od(this, Tc, _N).call(this, vN(o));
    }), us(this, SN, (o) => {
      typeof o.id == "string" && rr(this, ux, o.id);
      const i = new MessageEvent(o.event || "message", {
        data: o.data,
        origin: Xt(this, qg) ? Xt(this, qg).origin : Xt(this, Nh).origin,
        lastEventId: o.id || ""
      });
      Xt(this, Zg) && (!o.event || o.event === "message") && Xt(this, Zg).call(this, i), this.dispatchEvent(i);
    }), us(this, CN, (o) => {
      rr(this, dx, o);
    }), us(this, EN, () => {
      rr(this, am, void 0), Xt(this, ki) === this.CONNECTING && Od(this, Tc, bN).call(this);
    });
    try {
      if (e instanceof URL)
        rr(this, Nh, e);
      else if (typeof e == "string")
        rr(this, Nh, new URL(e, vIe()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw yIe("An invalid or illegal string was specified");
    }
    rr(this, Xg, gIe({
      onEvent: Xt(this, SN),
      onRetry: Xt(this, CN)
    })), rr(this, ki, this.CONNECTING), rr(this, dx, 3e3), rr(this, aE, (r = n == null ? void 0 : n.fetch) != null ? r : globalThis.fetch), rr(this, WC, (s = n == null ? void 0 : n.withCredentials) != null ? s : !1), Od(this, Tc, bN).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return Xt(this, ki);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return Xt(this, Nh).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return Xt(this, WC);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return Xt(this, Cm);
  }
  set onerror(e) {
    rr(this, Cm, e);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return Xt(this, Zg);
  }
  set onmessage(e) {
    rr(this, Zg, e);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return Xt(this, kb);
  }
  set onopen(e) {
    rr(this, kb, e);
  }
  addEventListener(e, n, r) {
    const s = n;
    super.addEventListener(e, s, r);
  }
  removeEventListener(e, n, r) {
    const s = n;
    super.removeEventListener(e, s, r);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    Xt(this, am) && clearTimeout(Xt(this, am)), Xt(this, ki) !== this.CLOSED && (Xt(this, Gu) && Xt(this, Gu).abort(), rr(this, ki, this.CLOSED), rr(this, Gu, void 0));
  }
}
ki = /* @__PURE__ */ new WeakMap(), Nh = /* @__PURE__ */ new WeakMap(), qg = /* @__PURE__ */ new WeakMap(), WC = /* @__PURE__ */ new WeakMap(), aE = /* @__PURE__ */ new WeakMap(), dx = /* @__PURE__ */ new WeakMap(), am = /* @__PURE__ */ new WeakMap(), ux = /* @__PURE__ */ new WeakMap(), Gu = /* @__PURE__ */ new WeakMap(), Xg = /* @__PURE__ */ new WeakMap(), Cm = /* @__PURE__ */ new WeakMap(), Zg = /* @__PURE__ */ new WeakMap(), kb = /* @__PURE__ */ new WeakMap(), Tc = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
bN = function() {
  rr(this, ki, this.CONNECTING), rr(this, Gu, new AbortController()), Xt(this, aE)(Xt(this, Nh), Od(this, Tc, rU).call(this)).then(Xt(this, xN)).catch(Xt(this, wN));
}, xN = /* @__PURE__ */ new WeakMap(), wN = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
rU = function() {
  var t;
  const e = {
    // [spec] Let `corsAttributeState` be `Anonymous`
    // [spec] will have their mode set to "cors"
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...Xt(this, ux) ? { "Last-Event-ID": Xt(this, ux) } : void 0 },
    cache: "no-store",
    signal: (t = Xt(this, Gu)) == null ? void 0 : t.signal
  };
  return "window" in globalThis && (e.credentials = this.withCredentials ? "include" : "same-origin"), e;
}, SN = /* @__PURE__ */ new WeakMap(), CN = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
Ab = function(t, e) {
  var n;
  Xt(this, ki) !== this.CLOSED && rr(this, ki, this.CLOSED);
  const r = new tU("error", { code: e, message: t });
  (n = Xt(this, Cm)) == null || n.call(this, r), this.dispatchEvent(r);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
_N = function(t, e) {
  var n;
  if (Xt(this, ki) === this.CLOSED)
    return;
  rr(this, ki, this.CONNECTING);
  const r = new tU("error", { code: e, message: t });
  (n = Xt(this, Cm)) == null || n.call(this, r), this.dispatchEvent(r), rr(this, am, setTimeout(Xt(this, EN), Xt(this, dx)));
}, EN = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
fx.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
fx.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
fx.CLOSED = 2;
Object.defineProperty(fx, Symbol.for("eventsource.supports-fetch-override"), {
  value: !0,
  writable: !1,
  configurable: !1,
  enumerable: !1
});
function vIe() {
  const t = "document" in globalThis ? globalThis.document : void 0;
  return t && typeof t == "object" && "baseURI" in t && typeof t.baseURI == "string" ? t.baseURI : void 0;
}
class CQ extends VC {
}
P(CQ, "EventSourceImpl", fx);
function bIe(t) {
  const e = {
    ...t,
    useDateObjects: t.useDateObjects ?? !1
  };
  return new CQ(e, {
    "@instantdb/react": AL
  });
}
const gl = "blueprint_artifacts", d1 = "blueprint_settings", bh = "blueprint_calendar_events", cM = "default", xIe = ["blueprint_notes", "blueprint_diagrams", "blueprint_canvases", "blueprint_boards"];
class wIe {
  constructor(e) {
    P(this, "db");
    P(this, "appId");
    P(this, "cacheKeyPrefix");
    this.db = bIe({ appId: e }), this.appId = e, this.cacheKeyPrefix = `blueprint:instant:${e}`, this.flushOutbox();
  }
  cacheKey(e) {
    return `${this.cacheKeyPrefix}:${e}`;
  }
  loadCache(e) {
    try {
      const n = localStorage.getItem(this.cacheKey(e));
      return n ? JSON.parse(n) : null;
    } catch {
      return null;
    }
  }
  saveCache(e, n) {
    try {
      localStorage.setItem(this.cacheKey(e), JSON.stringify(n));
    } catch {
    }
  }
  loadOutbox() {
    const e = this.loadCache("outbox");
    return {
      artifacts: (e == null ? void 0 : e.artifacts) ?? {},
      settings: e == null ? void 0 : e.settings,
      calendarEvents: (e == null ? void 0 : e.calendarEvents) ?? {},
      calendarDeletes: (e == null ? void 0 : e.calendarDeletes) ?? []
    };
  }
  saveOutbox(e) {
    this.saveCache("outbox", e);
  }
  async flushOutbox() {
    const e = this.loadOutbox(), n = Object.values(e.artifacts ?? {}), r = Object.values(e.calendarEvents ?? {}), s = e.calendarDeletes ?? [];
    if (n.length === 0 && !e.settings && r.length === 0 && s.length === 0)
      return;
    const o = { artifacts: {}, calendarEvents: {}, calendarDeletes: [] };
    for (const i of n)
      try {
        const a = this.db.tx[gl][i.id].update(i);
        await this.db.transact(a);
      } catch {
        o.artifacts[i.id] = i;
      }
    if (e.settings)
      try {
        const i = this.db.tx[d1][cM].update(e.settings);
        await this.db.transact(i);
      } catch {
        o.settings = e.settings;
      }
    for (const i of s)
      try {
        const a = this.db.tx[bh][i].delete();
        await this.db.transact(a);
      } catch {
        o.calendarDeletes.push(i);
      }
    for (const i of r)
      try {
        const a = this.db.tx[bh][i.id].update(i);
        await this.db.transact(a);
      } catch {
        o.calendarEvents[i.id] = i;
      }
    this.saveOutbox(o);
  }
  async getSettings() {
    var e, n;
    try {
      const s = (n = (e = (await this.db.queryOnce({
        [d1]: {
          $: { where: { id: cM } }
        }
      })).data) == null ? void 0 : e[d1]) == null ? void 0 : n[0];
      if (s != null && s.enabledTools && Array.isArray(s.enabledTools)) {
        const o = {
          enabledTools: s.enabledTools.filter((i) => Za.includes(i)),
          seededNoteCreated: s.seededNoteCreated
        };
        return this.saveCache("settings", o), o;
      }
    } catch (r) {
      console.error("Failed to load settings from InstantDB:", r);
    }
    return this.loadCache("settings") ?? { enabledTools: [...Za] };
  }
  async saveSettings(e) {
    try {
      const n = this.db.tx[d1][cM].update({
        enabledTools: e.enabledTools,
        seededNoteCreated: e.seededNoteCreated ?? !1
      });
      await this.db.transact(n), this.saveCache("settings", e);
    } catch (n) {
      console.error("Failed to save settings to InstantDB:", n);
      const r = this.loadOutbox();
      r.settings = e, this.saveOutbox(r);
    }
  }
  async getArtifact(e) {
    var s, o;
    try {
      const a = (o = (s = (await this.db.queryOnce({
        [gl]: { $: { where: { id: e } } }
      })).data) == null ? void 0 : s[gl]) == null ? void 0 : o[0];
      if (a) return Ii(a);
    } catch (i) {
      console.error("Failed to load artifact from InstantDB:", i);
    }
    const r = (this.loadCache("artifacts") ?? []).find((i) => i.id === e);
    return r ? Ii(r) : null;
  }
  async saveArtifact(e) {
    try {
      const n = Ii({
        ...e,
        favorite: e.favorite ?? !1,
        pinned: e.pinned ?? !1,
        schemaVersion: e.schemaVersion ?? ss
      });
      if (!n) return;
      const r = this.db.tx[gl][n.id].update(n);
      await this.db.transact(r);
      const o = (this.loadCache("artifacts") ?? []).filter((i) => i.id !== n.id);
      o.unshift(n), this.saveCache("artifacts", o);
    } catch (n) {
      console.error("Failed to save artifact to InstantDB:", n);
      const r = Ii(e);
      if (r) {
        const s = this.loadOutbox();
        s.artifacts[r.id] = r, this.saveOutbox(s);
      }
    }
  }
  async deleteArtifact(e) {
    try {
      const r = this.db.tx[gl][e].delete();
      await this.db.transact(r);
    } catch (r) {
      console.error("Failed to delete artifact from InstantDB:", r);
    }
    const n = this.loadCache("artifacts") ?? [];
    this.saveCache("artifacts", n.filter((r) => r.id !== e));
  }
  async listArtifacts(e) {
    var n;
    try {
      const i = (((n = (await this.db.queryOnce({
        [gl]: e ? { $: { where: { type: e } } } : {}
      })).data) == null ? void 0 : n[gl]) ?? []).map((a) => Ii(a)).filter((a) => !!a).sort(
        (a, c) => new Date(c.updatedAt).getTime() - new Date(a.updatedAt).getTime()
      );
      if (!e)
        this.saveCache("artifacts", i);
      else {
        const c = (this.loadCache("artifacts") ?? []).filter((d) => d.type !== e), l = [...i, ...c].sort(
          (d, u) => new Date(u.updatedAt).getTime() - new Date(d.updatedAt).getTime()
        );
        this.saveCache("artifacts", l);
      }
      return i;
    } catch (r) {
      console.error("Failed to list artifacts from InstantDB:", r);
      const s = this.loadCache("artifacts") ?? [];
      return (e ? s.filter((i) => i.type === e) : s).map((i) => Ii(i)).filter((i) => !!i).sort((i, a) => new Date(a.updatedAt).getTime() - new Date(i.updatedAt).getTime());
    }
  }
  async listFavorites() {
    var e;
    try {
      return (((e = (await this.db.queryOnce({
        [gl]: { $: { where: { favorite: !0 } } }
      })).data) == null ? void 0 : e[gl]) ?? []).map((s) => Ii(s)).filter((s) => !!s).sort((s, o) => new Date(o.updatedAt).getTime() - new Date(s.updatedAt).getTime());
    } catch (n) {
      return console.error("Failed to list favorites from InstantDB:", n), (this.loadCache("artifacts") ?? []).filter((s) => s.favorite).map((s) => Ii(s)).filter((s) => !!s).sort((s, o) => new Date(o.updatedAt).getTime() - new Date(s.updatedAt).getTime());
    }
  }
  async listByTag(e) {
    try {
      return (await this.listArtifacts()).filter((r) => {
        var s;
        return (s = r.tags) == null ? void 0 : s.includes(e);
      });
    } catch (n) {
      return console.error("Failed to list by tag from InstantDB:", n), [];
    }
  }
  // Calendar events
  async listCalendarEvents() {
    var n;
    const e = this.loadCache("calendar_events") ?? [];
    try {
      console.log("Blueprint: Fetching calendar events from InstantDB...");
      const s = ((n = (await this.db.queryOnce({
        [bh]: {}
      })).data) == null ? void 0 : n[bh]) ?? [];
      console.log(`Blueprint: Received ${s.length} events from database.`);
      const o = this.loadOutbox(), i = new Set(o.calendarDeletes ?? []), a = /* @__PURE__ */ new Map();
      for (const l of s)
        i.has(l.id) || a.set(l.id, l);
      for (const l of Object.values(o.calendarEvents ?? {}))
        a.set(l.id, l);
      const c = Array.from(a.values());
      return c.length === 0 && s.length === 0 && e.length > 0 ? (console.warn("Blueprint: Database returned 0 events, but local cache has data. Preserving local cache as fail-safe."), e) : (this.saveCache("calendar_events", c), c);
    } catch (r) {
      return console.error("Blueprint: Failed to list calendar events from InstantDB:", r), e;
    }
  }
  async saveCalendarEvent(e) {
    console.log("Blueprint: Saving calendar event...", e.id);
    const r = (this.loadCache("calendar_events") ?? []).filter((s) => s.id !== e.id);
    r.push(e), this.saveCache("calendar_events", r);
    try {
      const s = this.loadOutbox();
      this.saveOutbox({
        ...s,
        calendarEvents: { ...s.calendarEvents ?? {}, [e.id]: e },
        calendarDeletes: (s.calendarDeletes ?? []).filter((l) => l !== e.id)
      });
      const o = this.db.tx[bh][e.id].update(e);
      await this.db.transact(o), console.log("Blueprint: Calendar event transaction sent.");
      const i = this.loadOutbox(), { [e.id]: a, ...c } = i.calendarEvents ?? {};
      this.saveOutbox({
        ...i,
        calendarEvents: c
      });
    } catch (s) {
      console.error("Blueprint: Failed to sync calendar event to InstantDB:", s);
    }
  }
  async deleteCalendarEvent(e) {
    console.log("Blueprint: Deleting calendar event...", e);
    const n = this.loadCache("calendar_events") ?? [];
    this.saveCache("calendar_events", n.filter((r) => r.id !== e));
    try {
      const r = this.loadOutbox(), s = r.calendarDeletes ?? [];
      this.saveOutbox({
        ...r,
        calendarEvents: Object.fromEntries(
          Object.entries(r.calendarEvents ?? {}).filter(([a]) => a !== e)
        ),
        calendarDeletes: s.includes(e) ? s : [...s, e]
      });
      const o = this.db.tx[bh][e].delete();
      await this.db.transact(o), console.log("Blueprint: Delete transaction sent.");
      const i = this.loadOutbox();
      this.saveOutbox({
        ...i,
        calendarDeletes: (i.calendarDeletes ?? []).filter((a) => a !== e)
      });
    } catch (r) {
      console.error("Blueprint: Failed to sync delete to InstantDB:", r);
    }
  }
  /**
   * Clean up legacy split tables and optionally all data.
   * Returns count of deleted records.
   */
  async cleanupLegacyTables(e = !1) {
    let n = 0;
    const r = [], s = {};
    for (const o of xIe)
      s[o] = {};
    e && (s[gl] = {}, s[bh] = {});
    try {
      const i = (await this.db.queryOnce(s)).data;
      for (const a of Object.keys(s)) {
        const c = (i == null ? void 0 : i[a]) ?? [];
        if (c.length !== 0) {
          for (const l of c)
            try {
              const d = this.db.tx[a][l.id].delete();
              await this.db.transact(d), n++;
            } catch (d) {
              console.error(`Failed to delete ${l.id} from ${a}:`, d);
            }
          r.push(a);
        }
      }
      e && (this.saveCache("artifacts", []), this.saveCache("calendar_events", [])), console.log(`Blueprint: Cleaned ${n} records from tables: ${r.join(", ")}`);
    } catch (o) {
      console.error("Blueprint: Failed to cleanup legacy tables:", o);
    }
    return { deleted: n, tables: r };
  }
}
let OL = new NZ(), _Q = "localStorage";
function sU(t, e) {
  OL = t, _Q = e;
}
function nu() {
  return OL;
}
function SIe() {
  return _Q;
}
function CIe() {
  const t = $Z();
  return (t == null ? void 0 : t.provider) === "instantdb" && t.instantAppId ? t.instantAppId : null;
}
function TN() {
  const t = CIe();
  return t ? sU(new wIe(t), "instantdb") : sU(new NZ(), "localStorage"), OL;
}
const DL = zn(null), NL = zn(null);
function _Ie({ children: t }) {
  const [e, n] = he([...Za]), [r, s] = he({ enabledTools: [...Za] }), [o, i] = he(!0), a = Ke(() => nu(), []);
  me(() => {
    (async () => {
      try {
        const p = await a.getSettings(), g = p.enabledTools.filter((y) => Za.includes(y));
        n(g.length > 0 ? g : [...Za]), s({
          ...p,
          enabledTools: g.length > 0 ? g : [...Za]
        });
      } catch (p) {
        console.error("Failed to load blueprint settings:", p);
      } finally {
        i(!1);
      }
    })();
  }, [a]);
  const c = re(async (f) => {
    n((p) => {
      const g = p.includes(f) ? p.filter((m) => m !== f) : [...p, f], y = { ...r, enabledTools: g };
      return s(y), a.saveSettings(y).catch((m) => {
        console.error("Failed to save settings:", m);
      }), g;
    });
  }, [a, r]), l = re((f) => e.includes(f), [e]), d = Ke(() => ({
    enabledTools: e,
    loading: o,
    settings: r,
    storage: a
  }), [e, o, r, a]), u = Ke(() => ({
    toggleTool: c,
    isToolEnabled: l
  }), [c, l]);
  return /* @__PURE__ */ h.jsx(DL.Provider, { value: d, children: /* @__PURE__ */ h.jsx(NL.Provider, { value: u, children: t }) });
}
function cI() {
  const t = tn(DL), e = tn(NL);
  if (!t || !e)
    throw new Error("useBlueprint must be used within a BlueprintProvider");
  return { ...t, ...e };
}
function EIe() {
  const t = tn(NL);
  if (!t) throw new Error("useBlueprintActions must be used within a BlueprintProvider");
  return t;
}
function TIe() {
  const t = tn(DL);
  if (!t) throw new Error("useBlueprintState must be used within a BlueprintProvider");
  return t;
}
const er = {
  canvas: {
    type: "canvas",
    title: "Whiteboard",
    description: "Freeform drawings, whiteboards, sketches, and visual notes",
    icon: Hq,
    path: "/canvas",
    shortcut: "W",
    typeLabel: "whiteboard"
  },
  diagram: {
    type: "diagram",
    title: "Flow",
    description: "Flow charts, mind maps, system diagrams, and process flows",
    icon: C0,
    path: "/diagram",
    shortcut: "F",
    typeLabel: "flow"
  },
  board: {
    type: "board",
    title: "Tasks",
    description: "Kanban boards, task trackers, and project roadmaps",
    icon: Fq,
    path: "/board",
    shortcut: "T",
    typeLabel: "task board"
  },
  notes: {
    type: "notes",
    title: "Docs",
    description: "Rich text documents, notes, and Notion-style content",
    icon: yp,
    path: "/notes",
    shortcut: "D",
    typeLabel: "doc"
  },
  calendar: {
    type: "calendar",
    title: "Calendar",
    description: "Schedules, meetings, deadlines, and time-based planning",
    icon: mp,
    path: "/calendar",
    shortcut: "C",
    typeLabel: "calendar",
    singular: !0
  }
}, Sp = Object.values(er);
function bf(t) {
  return [...t].sort((e, n) => e.pinned !== n.pinned ? e.pinned ? -1 : 1 : new Date(n.updatedAt).getTime() - new Date(e.updatedAt).getTime());
}
function PIe(t) {
  const e = [t.name, t.type, t.updatedAt];
  if (t.data)
    try {
      e.push(JSON.stringify(t.data));
    } catch {
    }
  return e.join(" ").toLowerCase();
}
function uu() {
  const [t, e] = he([]), [n, r] = he(!0), [s, o] = he(null), i = nu(), a = re(async () => {
    r(!0), o(null);
    try {
      const f = await i.listArtifacts();
      e(bf(f));
    } catch (f) {
      o(f instanceof Error ? f.message : "Failed to load");
    } finally {
      r(!1);
    }
  }, [i]);
  me(() => {
    a();
  }, [a]);
  const c = re(async (f) => {
    await i.deleteArtifact(f), e((p) => p.filter((g) => g.id !== f));
  }, [i]), l = re(async (f) => {
    const p = t.find((y) => y.id === f);
    if (!p) return;
    const g = {
      ...p,
      favorite: !p.favorite,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      schemaVersion: p.schemaVersion ?? ss
    };
    await i.saveArtifact(g), e((y) => y.map((m) => m.id === f ? g : m));
  }, [t, i]), d = re(async (f) => {
    const p = t.find((y) => y.id === f);
    if (!p) return;
    const g = {
      ...p,
      pinned: !p.pinned,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      schemaVersion: p.schemaVersion ?? ss
    };
    await i.saveArtifact(g), e((y) => bf(y.map((m) => m.id === f ? g : m)));
  }, [t, i]), u = re(async (f, p) => {
    const g = t.find((m) => m.id === f);
    if (!g) return;
    const y = {
      ...g,
      tags: p.length > 0 ? p : void 0,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      schemaVersion: g.schemaVersion ?? ss
    };
    await i.saveArtifact(y), e((m) => m.map((v) => v.id === f ? y : v));
  }, [t, i]);
  return { artifacts: t, loading: n, error: s, refresh: a, deleteArtifact: c, toggleFavorite: l, togglePinned: d, updateTags: u };
}
const IIe = Hy(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function cE({ className: t, variant: e, ...n }) {
  return /* @__PURE__ */ h.jsx("div", { className: Oe(IIe({ variant: e }), t), ...n });
}
function kIe({ artifacts: t, collapsed: e }) {
  const n = rd(), r = N$(), s = r.pathname.startsWith("/tag/") ? decodeURIComponent(r.pathname.split("/tag/")[1]) : null, o = Ke(() => {
    const a = {};
    for (const c of t)
      if (c.tags)
        for (const l of c.tags)
          a[l] = (a[l] || 0) + 1;
    return Object.entries(a).sort(([c, l], [d, u]) => u !== l ? u - l : c.localeCompare(d));
  }, [t]);
  if (o.length === 0)
    return null;
  const i = (a) => {
    n(s === a ? "/" : `/tag/${encodeURIComponent(a)}`);
  };
  return e ? /* @__PURE__ */ h.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ h.jsx(E0, { className: "h-4 w-4 text-muted-foreground" }) }) : /* @__PURE__ */ h.jsx("div", { className: "flex flex-wrap gap-1.5", children: o.map(([a, c]) => /* @__PURE__ */ h.jsxs(
    cE,
    {
      variant: s === a ? "default" : "secondary",
      className: Oe(
        "cursor-pointer text-[10px] px-2 py-0.5 transition-colors",
        s === a ? "bg-primary text-primary-foreground" : "hover:bg-accent"
      ),
      onClick: () => i(a),
      children: [
        a,
        /* @__PURE__ */ h.jsx("span", { className: "ml-1 opacity-70", children: c })
      ]
    },
    a
  )) });
}
var lI = "Collapsible", [AIe, R3t] = bs(lI), [MIe, jL] = AIe(lI), EQ = T.forwardRef(
  (t, e) => {
    const {
      __scopeCollapsible: n,
      open: r,
      defaultOpen: s,
      disabled: o,
      onOpenChange: i,
      ...a
    } = t, [c, l] = io({
      prop: r,
      defaultProp: s ?? !1,
      onChange: i,
      caller: lI
    });
    return /* @__PURE__ */ h.jsx(
      MIe,
      {
        scope: n,
        disabled: o,
        contentId: as(),
        open: c,
        onOpenToggle: T.useCallback(() => l((d) => !d), [l]),
        children: /* @__PURE__ */ h.jsx(
          Re.div,
          {
            "data-state": $L(c),
            "data-disabled": o ? "" : void 0,
            ...a,
            ref: e
          }
        )
      }
    );
  }
);
EQ.displayName = lI;
var TQ = "CollapsibleTrigger", PQ = T.forwardRef(
  (t, e) => {
    const { __scopeCollapsible: n, ...r } = t, s = jL(TQ, n);
    return /* @__PURE__ */ h.jsx(
      Re.button,
      {
        type: "button",
        "aria-controls": s.contentId,
        "aria-expanded": s.open || !1,
        "data-state": $L(s.open),
        "data-disabled": s.disabled ? "" : void 0,
        disabled: s.disabled,
        ...r,
        ref: e,
        onClick: Te(t.onClick, s.onOpenToggle)
      }
    );
  }
);
PQ.displayName = TQ;
var RL = "CollapsibleContent", IQ = T.forwardRef(
  (t, e) => {
    const { forceMount: n, ...r } = t, s = jL(RL, t.__scopeCollapsible);
    return /* @__PURE__ */ h.jsx(Fs, { present: n || s.open, children: ({ present: o }) => /* @__PURE__ */ h.jsx(OIe, { ...r, ref: e, present: o }) });
  }
);
IQ.displayName = RL;
var OIe = T.forwardRef((t, e) => {
  const { __scopeCollapsible: n, present: r, children: s, ...o } = t, i = jL(RL, n), [a, c] = T.useState(r), l = T.useRef(null), d = vt(e, l), u = T.useRef(0), f = u.current, p = T.useRef(0), g = p.current, y = i.open || a, m = T.useRef(y), v = T.useRef(void 0);
  return T.useEffect(() => {
    const b = requestAnimationFrame(() => m.current = !1);
    return () => cancelAnimationFrame(b);
  }, []), vs(() => {
    const b = l.current;
    if (b) {
      v.current = v.current || {
        transitionDuration: b.style.transitionDuration,
        animationName: b.style.animationName
      }, b.style.transitionDuration = "0s", b.style.animationName = "none";
      const x = b.getBoundingClientRect();
      u.current = x.height, p.current = x.width, m.current || (b.style.transitionDuration = v.current.transitionDuration, b.style.animationName = v.current.animationName), c(r);
    }
  }, [i.open, r]), /* @__PURE__ */ h.jsx(
    Re.div,
    {
      "data-state": $L(i.open),
      "data-disabled": i.disabled ? "" : void 0,
      id: i.contentId,
      hidden: !y,
      ...o,
      ref: d,
      style: {
        "--radix-collapsible-content-height": f ? `${f}px` : void 0,
        "--radix-collapsible-content-width": g ? `${g}px` : void 0,
        ...t.style
      },
      children: y && s
    }
  );
});
function $L(t) {
  return t ? "open" : "closed";
}
var DIe = EQ;
const kQ = DIe, AQ = PQ, MQ = IQ;
function NIe() {
  const { state: t, toggleSidebar: e } = O0(), { isToolEnabled: n, loading: r } = cI(), { resolvedTheme: s, setTheme: o } = Yy(), i = t === "collapsed", { artifacts: a } = uu(), c = SIe(), l = r ? Sp : Sp.filter((g) => n(g.type)), d = a.reduce((g, y) => (g[y.type] = (g[y.type] ?? 0) + 1, g), {}), u = a.filter((g) => g.favorite).length, f = () => {
    o(s === "dark" ? "light" : "dark");
  }, p = a.some((g) => g.tags && g.tags.length > 0);
  return /* @__PURE__ */ h.jsxs(IZ, { collapsible: "icon", children: [
    /* @__PURE__ */ h.jsx(AZ, { children: /* @__PURE__ */ h.jsx(_b, { children: /* @__PURE__ */ h.jsx(Ad, { children: /* @__PURE__ */ h.jsx(Md, { asChild: !0, tooltip: "Blueprints", children: /* @__PURE__ */ h.jsxs(
      Bd,
      {
        to: "/",
        end: !0,
        className: "flex items-center gap-2",
        activeClassName: "bg-sidebar-accent text-sidebar-accent-foreground",
        children: [
          /* @__PURE__ */ h.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ h.jsx(Bq, { className: "h-4 w-4" }),
            /* @__PURE__ */ h.jsx(
              "span",
              {
                className: `absolute -top-0.5 -right-0.5 h-2 w-2 rounded-full border border-sidebar-background ${c === "instantdb" ? "bg-emerald-500" : "bg-red-500"}`,
                title: c === "instantdb" ? "Connected to InstantDB" : "No database connected (local only)"
              }
            )
          ] }),
          !i && /* @__PURE__ */ h.jsx("span", { className: "font-semibold", children: "Blueprint" })
        ]
      }
    ) }) }) }) }),
    /* @__PURE__ */ h.jsxs(OZ, { children: [
      /* @__PURE__ */ h.jsxs($C, { children: [
        /* @__PURE__ */ h.jsx(LC, { children: "Tools" }),
        /* @__PURE__ */ h.jsx(FC, { children: /* @__PURE__ */ h.jsx(_b, { children: l.map((g) => /* @__PURE__ */ h.jsx(Ad, { children: /* @__PURE__ */ h.jsx(Md, { asChild: !0, tooltip: `${g.title} (${g.shortcut})`, children: /* @__PURE__ */ h.jsxs(
          Bd,
          {
            to: g.path,
            className: "flex items-center gap-2",
            activeClassName: "bg-sidebar-accent text-sidebar-accent-foreground",
            children: [
              /* @__PURE__ */ h.jsx(g.icon, { className: "h-4 w-4" }),
              !i && /* @__PURE__ */ h.jsxs("span", { className: "flex-1 flex items-center justify-between", children: [
                /* @__PURE__ */ h.jsxs("span", { className: "flex items-center gap-2", children: [
                  /* @__PURE__ */ h.jsx("span", { children: g.title }),
                  !er[g.type].singular && d[g.type] > 0 && /* @__PURE__ */ h.jsx("span", { className: "min-w-6 rounded-full bg-muted px-2 py-0.5 text-[10px] text-muted-foreground text-center", children: d[g.type] })
                ] }),
                /* @__PURE__ */ h.jsx("kbd", { className: "text-[10px] font-mono text-muted-foreground", children: g.shortcut })
              ] })
            ]
          }
        ) }) }, g.type)) }) })
      ] }),
      /* @__PURE__ */ h.jsxs($C, { children: [
        /* @__PURE__ */ h.jsx(LC, { children: "Library" }),
        /* @__PURE__ */ h.jsx(FC, { children: /* @__PURE__ */ h.jsxs(_b, { children: [
          /* @__PURE__ */ h.jsx(Ad, { children: /* @__PURE__ */ h.jsx(Md, { asChild: !0, tooltip: "Favorites (S)", children: /* @__PURE__ */ h.jsxs(
            Bd,
            {
              to: "/favorites",
              className: "flex items-center gap-2",
              activeClassName: "bg-sidebar-accent text-sidebar-accent-foreground",
              children: [
                /* @__PURE__ */ h.jsx(yf, { className: "h-4 w-4" }),
                !i && /* @__PURE__ */ h.jsxs("span", { className: "flex-1 flex items-center justify-between", children: [
                  /* @__PURE__ */ h.jsxs("span", { className: "flex items-center gap-2", children: [
                    /* @__PURE__ */ h.jsx("span", { children: "Favorites" }),
                    u > 0 && /* @__PURE__ */ h.jsx("span", { className: "min-w-6 rounded-full bg-muted px-2 py-0.5 text-[10px] text-muted-foreground text-center", children: u })
                  ] }),
                  /* @__PURE__ */ h.jsx("kbd", { className: "text-[10px] font-mono text-muted-foreground", children: "S" })
                ] })
              ]
            }
          ) }) }),
          /* @__PURE__ */ h.jsx(Ad, { children: /* @__PURE__ */ h.jsx(Md, { asChild: !0, tooltip: "Relationships (R)", children: /* @__PURE__ */ h.jsxs(
            Bd,
            {
              to: "/relationships",
              className: "flex items-center gap-2",
              activeClassName: "bg-sidebar-accent text-sidebar-accent-foreground",
              children: [
                /* @__PURE__ */ h.jsx(W_, { className: "h-4 w-4" }),
                !i && /* @__PURE__ */ h.jsxs("span", { className: "flex-1 flex items-center justify-between", children: [
                  /* @__PURE__ */ h.jsx("span", { children: "Relationships" }),
                  /* @__PURE__ */ h.jsx("kbd", { className: "text-[10px] font-mono text-muted-foreground", children: "R" })
                ] })
              ]
            }
          ) }) }),
          /* @__PURE__ */ h.jsx(Ad, { children: /* @__PURE__ */ h.jsx(Md, { asChild: !0, tooltip: "Help", children: /* @__PURE__ */ h.jsxs(
            Bd,
            {
              to: "/help",
              className: "flex items-center gap-2",
              activeClassName: "bg-sidebar-accent text-sidebar-accent-foreground",
              children: [
                /* @__PURE__ */ h.jsx(Vy, { className: "h-4 w-4" }),
                !i && /* @__PURE__ */ h.jsx("span", { children: "Help" })
              ]
            }
          ) }) })
        ] }) })
      ] }),
      p && /* @__PURE__ */ h.jsx($C, { children: /* @__PURE__ */ h.jsxs(kQ, { defaultOpen: !0, children: [
        /* @__PURE__ */ h.jsx(AQ, { asChild: !0, children: /* @__PURE__ */ h.jsxs(LC, { className: "cursor-pointer hover:bg-sidebar-accent/50 rounded px-2 -mx-2 flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(E0, { className: "h-3 w-3" }),
          "Tags"
        ] }) }),
        /* @__PURE__ */ h.jsx(MQ, { children: /* @__PURE__ */ h.jsx(FC, { className: "pt-2", children: /* @__PURE__ */ h.jsx(kIe, { artifacts: a, collapsed: i }) }) })
      ] }) })
    ] }),
    /* @__PURE__ */ h.jsx(MZ, { children: /* @__PURE__ */ h.jsxs(_b, { children: [
      /* @__PURE__ */ h.jsx(Ad, { children: /* @__PURE__ */ h.jsx(Md, { asChild: !0, tooltip: "Settings", children: /* @__PURE__ */ h.jsxs(
        Bd,
        {
          to: "/settings",
          className: "flex items-center gap-2",
          activeClassName: "bg-sidebar-accent text-sidebar-accent-foreground",
          children: [
            /* @__PURE__ */ h.jsx(_0, { className: "h-4 w-4" }),
            !i && /* @__PURE__ */ h.jsx("span", { children: "Settings" })
          ]
        }
      ) }) }),
      /* @__PURE__ */ h.jsx(Ad, { children: /* @__PURE__ */ h.jsxs(Md, { tooltip: "Toggle theme (\\)", onClick: f, children: [
        /* @__PURE__ */ h.jsx(iwe, { className: "h-4 w-4 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" }),
        /* @__PURE__ */ h.jsx(swe, { className: "absolute h-4 w-4 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" }),
        !i && /* @__PURE__ */ h.jsx("span", { children: "Toggle theme" })
      ] }) }),
      /* @__PURE__ */ h.jsx(Ad, { children: /* @__PURE__ */ h.jsx(Md, { tooltip: i ? "Expand sidebar" : "Collapse sidebar", onClick: e, children: i ? /* @__PURE__ */ h.jsx(Vq, { className: "h-4 w-4" }) : /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
        /* @__PURE__ */ h.jsx(owe, { className: "h-4 w-4" }),
        /* @__PURE__ */ h.jsx("span", { children: "Collapse" })
      ] }) }) })
    ] }) })
  ] });
}
function jIe() {
  const t = rd(), e = N$(), { resolvedTheme: n, setTheme: r } = Yy(), [s, o] = he(!1), i = re(() => {
    const c = e.pathname;
    for (const l of Sp)
      if (c.startsWith(l.path))
        return l.type;
    return null;
  }, [e.pathname]), a = re((c) => {
    var g;
    if ((c.metaKey || c.ctrlKey) && c.key === "k") {
      c.preventDefault(), o(!0);
      return;
    }
    const l = c.target, d = (g = l.tagName) == null ? void 0 : g.toUpperCase();
    if (d === "INPUT" || d === "TEXTAREA" || l.isContentEditable || l.closest('[contenteditable="true"]') || l.closest(".tl-container") || // tldraw
    l.closest(".react-flow") || // xyflow/react-flow
    l.closest(".bn-container") || // BlockNote
    l.closest("[data-editor]") || // Generic editor marker
    l.closest('[role="textbox"]') || c.ctrlKey || c.metaKey || c.altKey)
      return;
    const u = c.key, f = u.toUpperCase(), p = i();
    if (u === "\\") {
      c.preventDefault(), r(n === "dark" ? "light" : "dark");
      return;
    }
    if (f === "S") {
      c.preventDefault(), t("/favorites");
      return;
    }
    if (f === "R") {
      c.preventDefault(), t("/relationships");
      return;
    }
    for (const y of Sp)
      if (f === y.shortcut) {
        c.preventDefault(), t(y.path);
        return;
      }
    if (f === "N") {
      c.preventDefault(), t(p ? `${er[p].path}/new` : "/canvas/new");
      return;
    }
    if (f === "G") {
      c.preventDefault(), p && t(er[p].path);
      return;
    }
  }, [t, i, n, r]);
  return me(() => (window.addEventListener("keydown", a), () => window.removeEventListener("keydown", a)), [a]), { commandPaletteOpen: s, setCommandPaletteOpen: o };
}
const RIe = "blueprint-seed-note";
function $Ie() {
  return [
    {
      type: "heading",
      props: { level: 1 },
      content: [{ type: "text", text: "Project Spark" }],
      children: []
    },
    {
      type: "paragraph",
      content: [
        { type: "text", text: "Why does this project exist? What was the spark?" }
      ],
      children: []
    },
    {
      type: "heading",
      props: { level: 2 },
      content: [{ type: "text", text: "Current Status" }],
      children: []
    },
    {
      type: "paragraph",
      content: [{ type: "text", text: "What is true today?" }],
      children: []
    },
    {
      type: "heading",
      props: { level: 2 },
      content: [{ type: "text", text: "Artifacts" }],
      children: []
    },
    {
      type: "paragraph",
      content: [{ type: "text", text: "Links to key diagrams, sketches, and notes." }],
      children: []
    },
    {
      type: "heading",
      props: { level: 2 },
      content: [{ type: "text", text: "Open Questions" }],
      children: []
    },
    {
      type: "paragraph",
      content: [{ type: "text", text: "What are we unsure about?" }],
      children: []
    }
  ];
}
async function LIe(t) {
  const e = await t.getSettings();
  if (e.seededNoteCreated) return;
  if ((await t.listArtifacts("notes")).length > 0) {
    await t.saveSettings({ ...e, seededNoteCreated: !0 });
    return;
  }
  const r = (/* @__PURE__ */ new Date()).toISOString(), s = {
    id: RIe,
    type: "notes",
    name: "Project Spark",
    data: $Ie(),
    createdAt: r,
    updatedAt: r,
    favorite: !1,
    pinned: !0,
    schemaVersion: ss
  };
  await t.saveArtifact(s), await t.saveSettings({ ...e, seededNoteCreated: !0 });
}
var oU = 1, FIe = 0.9, BIe = 0.8, zIe = 0.17, lM = 0.1, dM = 0.999, UIe = 0.9999, HIe = 0.99, VIe = /[\\\/_+.#"@\[\(\{&]/, WIe = /[\\\/_+.#"@\[\(\{&]/g, KIe = /[\s-]/, OQ = /[\s-]/g;
function PN(t, e, n, r, s, o, i) {
  if (o === e.length) return s === t.length ? oU : HIe;
  var a = `${s},${o}`;
  if (i[a] !== void 0) return i[a];
  for (var c = r.charAt(o), l = n.indexOf(c, s), d = 0, u, f, p, g; l >= 0; ) u = PN(t, e, n, r, l + 1, o + 1, i), u > d && (l === s ? u *= oU : VIe.test(t.charAt(l - 1)) ? (u *= BIe, p = t.slice(s, l - 1).match(WIe), p && s > 0 && (u *= Math.pow(dM, p.length))) : KIe.test(t.charAt(l - 1)) ? (u *= FIe, g = t.slice(s, l - 1).match(OQ), g && s > 0 && (u *= Math.pow(dM, g.length))) : (u *= zIe, s > 0 && (u *= Math.pow(dM, l - s))), t.charAt(l) !== e.charAt(o) && (u *= UIe)), (u < lM && n.charAt(l - 1) === r.charAt(o + 1) || r.charAt(o + 1) === r.charAt(o) && n.charAt(l - 1) !== r.charAt(o)) && (f = PN(t, e, n, r, l + 1, o + 2, i), f * lM > u && (u = f * lM)), u > d && (d = u), l = n.indexOf(c, l + 1);
  return i[a] = d, d;
}
function iU(t) {
  return t.toLowerCase().replace(OQ, " ");
}
function GIe(t, e, n) {
  return t = n && n.length > 0 ? `${t + " " + n.join(" ")}` : t, PN(t, e, iU(t), iU(e), 0, 0, {});
}
var Vv = '[cmdk-group=""]', uM = '[cmdk-group-items=""]', YIe = '[cmdk-group-heading=""]', DQ = '[cmdk-item=""]', aU = `${DQ}:not([aria-disabled="true"])`, IN = "cmdk-item-select", Qg = "data-value", qIe = (t, e, n) => GIe(t, e, n), NQ = T.createContext(void 0), j0 = () => T.useContext(NQ), jQ = T.createContext(void 0), LL = () => T.useContext(jQ), RQ = T.createContext(void 0), $Q = T.forwardRef((t, e) => {
  let n = Jg(() => {
    var U, W;
    return { search: "", value: (W = (U = t.value) != null ? U : t.defaultValue) != null ? W : "", selectedItemId: void 0, filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
  }), r = Jg(() => /* @__PURE__ */ new Set()), s = Jg(() => /* @__PURE__ */ new Map()), o = Jg(() => /* @__PURE__ */ new Map()), i = Jg(() => /* @__PURE__ */ new Set()), a = LQ(t), { label: c, children: l, value: d, onValueChange: u, filter: f, shouldFilter: p, loop: g, disablePointerSelection: y = !1, vimBindings: m = !0, ...v } = t, b = as(), x = as(), w = as(), S = T.useRef(null), C = ike();
  Cp(() => {
    if (d !== void 0) {
      let U = d.trim();
      n.current.value = U, _.emit();
    }
  }, [d]), Cp(() => {
    C(6, k);
  }, []);
  let _ = T.useMemo(() => ({ subscribe: (U) => (i.current.add(U), () => i.current.delete(U)), snapshot: () => n.current, setState: (U, W, Z) => {
    var K, oe, Y, ee;
    if (!Object.is(n.current[U], W)) {
      if (n.current[U] = W, U === "search") D(), N(), C(1, O);
      else if (U === "value") {
        if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) {
          let ae = document.getElementById(w);
          ae ? ae.focus() : (K = document.getElementById(b)) == null || K.focus();
        }
        if (C(7, () => {
          var ae;
          n.current.selectedItemId = (ae = A()) == null ? void 0 : ae.id, _.emit();
        }), Z || C(5, k), ((oe = a.current) == null ? void 0 : oe.value) !== void 0) {
          let ae = W ?? "";
          (ee = (Y = a.current).onValueChange) == null || ee.call(Y, ae);
          return;
        }
      }
      _.emit();
    }
  }, emit: () => {
    i.current.forEach((U) => U());
  } }), []), E = T.useMemo(() => ({ value: (U, W, Z) => {
    var K;
    W !== ((K = o.current.get(U)) == null ? void 0 : K.value) && (o.current.set(U, { value: W, keywords: Z }), n.current.filtered.items.set(U, M(W, Z)), C(2, () => {
      N(), _.emit();
    }));
  }, item: (U, W) => (r.current.add(U), W && (s.current.has(W) ? s.current.get(W).add(U) : s.current.set(W, /* @__PURE__ */ new Set([U]))), C(3, () => {
    D(), N(), n.current.value || O(), _.emit();
  }), () => {
    o.current.delete(U), r.current.delete(U), n.current.filtered.items.delete(U);
    let Z = A();
    C(4, () => {
      D(), (Z == null ? void 0 : Z.getAttribute("id")) === U && O(), _.emit();
    });
  }), group: (U) => (s.current.has(U) || s.current.set(U, /* @__PURE__ */ new Set()), () => {
    o.current.delete(U), s.current.delete(U);
  }), filter: () => a.current.shouldFilter, label: c || t["aria-label"], getDisablePointerSelection: () => a.current.disablePointerSelection, listId: b, inputId: w, labelId: x, listInnerRef: S }), []);
  function M(U, W) {
    var Z, K;
    let oe = (K = (Z = a.current) == null ? void 0 : Z.filter) != null ? K : qIe;
    return U ? oe(U, n.current.search, W) : 0;
  }
  function N() {
    if (!n.current.search || a.current.shouldFilter === !1) return;
    let U = n.current.filtered.items, W = [];
    n.current.filtered.groups.forEach((K) => {
      let oe = s.current.get(K), Y = 0;
      oe.forEach((ee) => {
        let ae = U.get(ee);
        Y = Math.max(ae, Y);
      }), W.push([K, Y]);
    });
    let Z = S.current;
    R().sort((K, oe) => {
      var Y, ee;
      let ae = K.getAttribute("id"), de = oe.getAttribute("id");
      return ((Y = U.get(de)) != null ? Y : 0) - ((ee = U.get(ae)) != null ? ee : 0);
    }).forEach((K) => {
      let oe = K.closest(uM);
      oe ? oe.appendChild(K.parentElement === oe ? K : K.closest(`${uM} > *`)) : Z.appendChild(K.parentElement === Z ? K : K.closest(`${uM} > *`));
    }), W.sort((K, oe) => oe[1] - K[1]).forEach((K) => {
      var oe;
      let Y = (oe = S.current) == null ? void 0 : oe.querySelector(`${Vv}[${Qg}="${encodeURIComponent(K[0])}"]`);
      Y == null || Y.parentElement.appendChild(Y);
    });
  }
  function O() {
    let U = R().find((Z) => Z.getAttribute("aria-disabled") !== "true"), W = U == null ? void 0 : U.getAttribute(Qg);
    _.setState("value", W || void 0);
  }
  function D() {
    var U, W, Z, K;
    if (!n.current.search || a.current.shouldFilter === !1) {
      n.current.filtered.count = r.current.size;
      return;
    }
    n.current.filtered.groups = /* @__PURE__ */ new Set();
    let oe = 0;
    for (let Y of r.current) {
      let ee = (W = (U = o.current.get(Y)) == null ? void 0 : U.value) != null ? W : "", ae = (K = (Z = o.current.get(Y)) == null ? void 0 : Z.keywords) != null ? K : [], de = M(ee, ae);
      n.current.filtered.items.set(Y, de), de > 0 && oe++;
    }
    for (let [Y, ee] of s.current) for (let ae of ee) if (n.current.filtered.items.get(ae) > 0) {
      n.current.filtered.groups.add(Y);
      break;
    }
    n.current.filtered.count = oe;
  }
  function k() {
    var U, W, Z;
    let K = A();
    K && (((U = K.parentElement) == null ? void 0 : U.firstChild) === K && ((Z = (W = K.closest(Vv)) == null ? void 0 : W.querySelector(YIe)) == null || Z.scrollIntoView({ block: "nearest" })), K.scrollIntoView({ block: "nearest" }));
  }
  function A() {
    var U;
    return (U = S.current) == null ? void 0 : U.querySelector(`${DQ}[aria-selected="true"]`);
  }
  function R() {
    var U;
    return Array.from(((U = S.current) == null ? void 0 : U.querySelectorAll(aU)) || []);
  }
  function j(U) {
    let W = R()[U];
    W && _.setState("value", W.getAttribute(Qg));
  }
  function $(U) {
    var W;
    let Z = A(), K = R(), oe = K.findIndex((ee) => ee === Z), Y = K[oe + U];
    (W = a.current) != null && W.loop && (Y = oe + U < 0 ? K[K.length - 1] : oe + U === K.length ? K[0] : K[oe + U]), Y && _.setState("value", Y.getAttribute(Qg));
  }
  function F(U) {
    let W = A(), Z = W == null ? void 0 : W.closest(Vv), K;
    for (; Z && !K; ) Z = U > 0 ? ske(Z, Vv) : oke(Z, Vv), K = Z == null ? void 0 : Z.querySelector(aU);
    K ? _.setState("value", K.getAttribute(Qg)) : $(U);
  }
  let L = () => j(R().length - 1), z = (U) => {
    U.preventDefault(), U.metaKey ? L() : U.altKey ? F(1) : $(1);
  }, H = (U) => {
    U.preventDefault(), U.metaKey ? j(0) : U.altKey ? F(-1) : $(-1);
  };
  return T.createElement(Re.div, { ref: e, tabIndex: -1, ...v, "cmdk-root": "", onKeyDown: (U) => {
    var W;
    (W = v.onKeyDown) == null || W.call(v, U);
    let Z = U.nativeEvent.isComposing || U.keyCode === 229;
    if (!(U.defaultPrevented || Z)) switch (U.key) {
      case "n":
      case "j": {
        m && U.ctrlKey && z(U);
        break;
      }
      case "ArrowDown": {
        z(U);
        break;
      }
      case "p":
      case "k": {
        m && U.ctrlKey && H(U);
        break;
      }
      case "ArrowUp": {
        H(U);
        break;
      }
      case "Home": {
        U.preventDefault(), j(0);
        break;
      }
      case "End": {
        U.preventDefault(), L();
        break;
      }
      case "Enter": {
        U.preventDefault();
        let K = A();
        if (K) {
          let oe = new Event(IN);
          K.dispatchEvent(oe);
        }
      }
    }
  } }, T.createElement("label", { "cmdk-label": "", htmlFor: E.inputId, id: E.labelId, style: cke }, c), dI(t, (U) => T.createElement(jQ.Provider, { value: _ }, T.createElement(NQ.Provider, { value: E }, U))));
}), XIe = T.forwardRef((t, e) => {
  var n, r;
  let s = as(), o = T.useRef(null), i = T.useContext(RQ), a = j0(), c = LQ(t), l = (r = (n = c.current) == null ? void 0 : n.forceMount) != null ? r : i == null ? void 0 : i.forceMount;
  Cp(() => {
    if (!l) return a.item(s, i == null ? void 0 : i.id);
  }, [l]);
  let d = FQ(s, o, [t.value, t.children, o], t.keywords), u = LL(), f = Of((C) => C.value && C.value === d.current), p = Of((C) => l || a.filter() === !1 ? !0 : C.search ? C.filtered.items.get(s) > 0 : !0);
  T.useEffect(() => {
    let C = o.current;
    if (!(!C || t.disabled)) return C.addEventListener(IN, g), () => C.removeEventListener(IN, g);
  }, [p, t.onSelect, t.disabled]);
  function g() {
    var C, _;
    y(), (_ = (C = c.current).onSelect) == null || _.call(C, d.current);
  }
  function y() {
    u.setState("value", d.current, !0);
  }
  if (!p) return null;
  let { disabled: m, value: v, onSelect: b, forceMount: x, keywords: w, ...S } = t;
  return T.createElement(Re.div, { ref: eu(o, e), ...S, id: s, "cmdk-item": "", role: "option", "aria-disabled": !!m, "aria-selected": !!f, "data-disabled": !!m, "data-selected": !!f, onPointerMove: m || a.getDisablePointerSelection() ? void 0 : y, onClick: m ? void 0 : g }, t.children);
}), ZIe = T.forwardRef((t, e) => {
  let { heading: n, children: r, forceMount: s, ...o } = t, i = as(), a = T.useRef(null), c = T.useRef(null), l = as(), d = j0(), u = Of((p) => s || d.filter() === !1 ? !0 : p.search ? p.filtered.groups.has(i) : !0);
  Cp(() => d.group(i), []), FQ(i, a, [t.value, t.heading, c]);
  let f = T.useMemo(() => ({ id: i, forceMount: s }), [s]);
  return T.createElement(Re.div, { ref: eu(a, e), ...o, "cmdk-group": "", role: "presentation", hidden: u ? void 0 : !0 }, n && T.createElement("div", { ref: c, "cmdk-group-heading": "", "aria-hidden": !0, id: l }, n), dI(t, (p) => T.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n ? l : void 0 }, T.createElement(RQ.Provider, { value: f }, p))));
}), QIe = T.forwardRef((t, e) => {
  let { alwaysRender: n, ...r } = t, s = T.useRef(null), o = Of((i) => !i.search);
  return !n && !o ? null : T.createElement(Re.div, { ref: eu(s, e), ...r, "cmdk-separator": "", role: "separator" });
}), JIe = T.forwardRef((t, e) => {
  let { onValueChange: n, ...r } = t, s = t.value != null, o = LL(), i = Of((l) => l.search), a = Of((l) => l.selectedItemId), c = j0();
  return T.useEffect(() => {
    t.value != null && o.setState("search", t.value);
  }, [t.value]), T.createElement(Re.input, { ref: e, ...r, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: !1, "aria-autocomplete": "list", role: "combobox", "aria-expanded": !0, "aria-controls": c.listId, "aria-labelledby": c.labelId, "aria-activedescendant": a, id: c.inputId, type: "text", value: s ? t.value : i, onChange: (l) => {
    s || o.setState("search", l.target.value), n == null || n(l.target.value);
  } });
}), eke = T.forwardRef((t, e) => {
  let { children: n, label: r = "Suggestions", ...s } = t, o = T.useRef(null), i = T.useRef(null), a = Of((l) => l.selectedItemId), c = j0();
  return T.useEffect(() => {
    if (i.current && o.current) {
      let l = i.current, d = o.current, u, f = new ResizeObserver(() => {
        u = requestAnimationFrame(() => {
          let p = l.offsetHeight;
          d.style.setProperty("--cmdk-list-height", p.toFixed(1) + "px");
        });
      });
      return f.observe(l), () => {
        cancelAnimationFrame(u), f.unobserve(l);
      };
    }
  }, []), T.createElement(Re.div, { ref: eu(o, e), ...s, "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": a, "aria-label": r, id: c.listId }, dI(t, (l) => T.createElement("div", { ref: eu(i, c.listInnerRef), "cmdk-list-sizer": "" }, l)));
}), tke = T.forwardRef((t, e) => {
  let { open: n, onOpenChange: r, overlayClassName: s, contentClassName: o, container: i, ...a } = t;
  return T.createElement(tI, { open: n, onOpenChange: r }, T.createElement(nI, { container: i }, T.createElement(Zy, { "cmdk-overlay": "", className: s }), T.createElement(Qy, { "aria-label": t.label, "cmdk-dialog": "", className: o }, T.createElement($Q, { ref: e, ...a }))));
}), nke = T.forwardRef((t, e) => Of((n) => n.filtered.count === 0) ? T.createElement(Re.div, { ref: e, ...t, "cmdk-empty": "", role: "presentation" }) : null), rke = T.forwardRef((t, e) => {
  let { progress: n, children: r, label: s = "Loading...", ...o } = t;
  return T.createElement(Re.div, { ref: e, ...o, "cmdk-loading": "", role: "progressbar", "aria-valuenow": n, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": s }, dI(t, (i) => T.createElement("div", { "aria-hidden": !0 }, i)));
}), Ki = Object.assign($Q, { List: eke, Item: XIe, Input: JIe, Group: ZIe, Separator: QIe, Dialog: tke, Empty: nke, Loading: rke });
function ske(t, e) {
  let n = t.nextElementSibling;
  for (; n; ) {
    if (n.matches(e)) return n;
    n = n.nextElementSibling;
  }
}
function oke(t, e) {
  let n = t.previousElementSibling;
  for (; n; ) {
    if (n.matches(e)) return n;
    n = n.previousElementSibling;
  }
}
function LQ(t) {
  let e = T.useRef(t);
  return Cp(() => {
    e.current = t;
  }), e;
}
var Cp = typeof window > "u" ? T.useEffect : T.useLayoutEffect;
function Jg(t) {
  let e = T.useRef();
  return e.current === void 0 && (e.current = t()), e;
}
function Of(t) {
  let e = LL(), n = () => t(e.snapshot());
  return T.useSyncExternalStore(e.subscribe, n, n);
}
function FQ(t, e, n, r = []) {
  let s = T.useRef(), o = j0();
  return Cp(() => {
    var i;
    let a = (() => {
      var l;
      for (let d of n) {
        if (typeof d == "string") return d.trim();
        if (typeof d == "object" && "current" in d) return d.current ? (l = d.current.textContent) == null ? void 0 : l.trim() : s.current;
      }
    })(), c = r.map((l) => l.trim());
    o.value(t, a, c), (i = e.current) == null || i.setAttribute(Qg, a), s.current = a;
  }), s;
}
var ike = () => {
  let [t, e] = T.useState(), n = Jg(() => /* @__PURE__ */ new Map());
  return Cp(() => {
    n.current.forEach((r) => r()), n.current = /* @__PURE__ */ new Map();
  }, [t]), (r, s) => {
    n.current.set(r, s), e({});
  };
};
function ake(t) {
  let e = t.type;
  return typeof e == "function" ? e(t.props) : "render" in e ? e.render(t.props) : t;
}
function dI({ asChild: t, children: e }, n) {
  return t && T.isValidElement(e) ? T.cloneElement(ake(e), { ref: e.ref }, n(e.props.children)) : n(e);
}
var cke = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };
const ig = tI, lke = nI, BQ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  Zy,
  {
    ref: n,
    className: Oe(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      t
    ),
    ...e
  }
));
BQ.displayName = Zy.displayName;
const Gf = T.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ h.jsxs(lke, { children: [
  /* @__PURE__ */ h.jsx(BQ, {}),
  /* @__PURE__ */ h.jsxs(
    Qy,
    {
      ref: r,
      className: Oe(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        t
      ),
      ...n,
      children: [
        e,
        /* @__PURE__ */ h.jsxs(xZ, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-accent data-[state=open]:text-muted-foreground hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none", children: [
          /* @__PURE__ */ h.jsx(rg, { className: "h-4 w-4" }),
          /* @__PURE__ */ h.jsx("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
Gf.displayName = Qy.displayName;
const ag = ({ className: t, ...e }) => /* @__PURE__ */ h.jsx("div", { className: Oe("flex flex-col space-y-1.5 text-center sm:text-left", t), ...e });
ag.displayName = "DialogHeader";
const FL = ({ className: t, ...e }) => /* @__PURE__ */ h.jsx("div", { className: Oe("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", t), ...e });
FL.displayName = "DialogFooter";
const cg = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  M0,
  {
    ref: n,
    className: Oe("text-lg font-semibold leading-none tracking-tight", t),
    ...e
  }
));
cg.displayName = M0.displayName;
const dke = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(rI, { ref: n, className: Oe("text-sm text-muted-foreground", t), ...e }));
dke.displayName = rI.displayName;
const zQ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  Ki,
  {
    ref: n,
    className: Oe(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      t
    ),
    ...e
  }
));
zQ.displayName = Ki.displayName;
const uke = ({ children: t, ...e }) => /* @__PURE__ */ h.jsx(ig, { ...e, children: /* @__PURE__ */ h.jsx(Gf, { className: "overflow-hidden p-0 shadow-lg", children: /* @__PURE__ */ h.jsx(zQ, { className: "[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5", children: t }) }) }), UQ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsxs("div", { className: "flex items-center border-b px-3", "cmdk-input-wrapper": "", children: [
  /* @__PURE__ */ h.jsx(Kq, { className: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
  /* @__PURE__ */ h.jsx(
    Ki.Input,
    {
      ref: n,
      className: Oe(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        t
      ),
      ...e
    }
  )
] }));
UQ.displayName = Ki.Input.displayName;
const HQ = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  Ki.List,
  {
    ref: n,
    className: Oe("max-h-[300px] overflow-y-auto overflow-x-hidden", t),
    ...e
  }
));
HQ.displayName = Ki.List.displayName;
const VQ = T.forwardRef((t, e) => /* @__PURE__ */ h.jsx(Ki.Empty, { ref: e, className: "py-6 text-center text-sm", ...t }));
VQ.displayName = Ki.Empty.displayName;
const Mb = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  Ki.Group,
  {
    ref: n,
    className: Oe(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      t
    ),
    ...e
  }
));
Mb.displayName = Ki.Group.displayName;
const KC = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(Ki.Separator, { ref: n, className: Oe("-mx-1 h-px bg-border", t), ...e }));
KC.displayName = Ki.Separator.displayName;
const Dd = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  Ki.Item,
  {
    ref: n,
    className: Oe(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      t
    ),
    ...e
  }
));
Dd.displayName = Ki.Item.displayName;
const GC = ({ className: t, ...e }) => /* @__PURE__ */ h.jsx("span", { className: Oe("ml-auto text-xs tracking-widest text-muted-foreground", t), ...e });
GC.displayName = "CommandShortcut";
function Qx(t) {
  const e = Date.parse(t);
  if (Number.isNaN(e)) return "just now";
  const n = Date.now() - e, r = Math.floor(n / 6e4);
  if (r < 1) return "just now";
  if (r < 60) return `${r}m ago`;
  const s = Math.floor(r / 60);
  return s < 24 ? `${s}h ago` : `${Math.floor(s / 24)}d ago`;
}
function fke({ open: t, onOpenChange: e }) {
  const n = rd(), { artifacts: r } = uu(), { isToolEnabled: s } = cI(), [o, i] = he(""), a = Ke(() => {
    if (!o.trim()) return r.slice(0, 8);
    const d = o.toLowerCase();
    return r.filter((u) => u.name.toLowerCase().includes(d)).slice(0, 10);
  }, [r, o]), c = Ke(
    () => Sp.filter((d) => s(d.type)),
    [s]
  ), l = re((d) => {
    e(!1), d();
  }, [e]);
  return me(() => {
    t || i("");
  }, [t]), /* @__PURE__ */ h.jsxs(uke, { open: t, onOpenChange: e, children: [
    /* @__PURE__ */ h.jsx(
      UQ,
      {
        placeholder: "Search artifacts, create new, or navigate...",
        value: o,
        onValueChange: i
      }
    ),
    /* @__PURE__ */ h.jsxs(HQ, { children: [
      /* @__PURE__ */ h.jsx(VQ, { children: "No results found." }),
      /* @__PURE__ */ h.jsxs(Mb, { heading: "Quick Actions", children: [
        /* @__PURE__ */ h.jsxs(Dd, { onSelect: () => l(() => n("/")), children: [
          /* @__PURE__ */ h.jsx(Bq, { className: "mr-2 h-4 w-4" }),
          /* @__PURE__ */ h.jsx("span", { children: "Go to Home" })
        ] }),
        /* @__PURE__ */ h.jsxs(Dd, { onSelect: () => l(() => n("/favorites")), children: [
          /* @__PURE__ */ h.jsx(yf, { className: "mr-2 h-4 w-4" }),
          /* @__PURE__ */ h.jsx("span", { children: "View Favorites" }),
          /* @__PURE__ */ h.jsx(GC, { children: "S" })
        ] }),
        /* @__PURE__ */ h.jsxs(Dd, { onSelect: () => l(() => n("/relationships")), children: [
          /* @__PURE__ */ h.jsx(W_, { className: "mr-2 h-4 w-4" }),
          /* @__PURE__ */ h.jsx("span", { children: "Relationship Graph" })
        ] }),
        /* @__PURE__ */ h.jsxs(Dd, { onSelect: () => l(() => n("/settings")), children: [
          /* @__PURE__ */ h.jsx(_0, { className: "mr-2 h-4 w-4" }),
          /* @__PURE__ */ h.jsx("span", { children: "Settings" })
        ] }),
        /* @__PURE__ */ h.jsxs(Dd, { onSelect: () => l(() => n("/help")), children: [
          /* @__PURE__ */ h.jsx(Vy, { className: "mr-2 h-4 w-4" }),
          /* @__PURE__ */ h.jsx("span", { children: "Help" })
        ] })
      ] }),
      /* @__PURE__ */ h.jsx(KC, {}),
      /* @__PURE__ */ h.jsx(Mb, { heading: "Create New", children: c.filter((d) => !d.singular).map((d) => (d.icon, /* @__PURE__ */ h.jsxs(
        Dd,
        {
          onSelect: () => l(() => n(`${d.path}/new`)),
          children: [
            /* @__PURE__ */ h.jsx(Jc, { className: "mr-2 h-4 w-4" }),
            /* @__PURE__ */ h.jsxs("span", { children: [
              "New ",
              d.title
            ] }),
            /* @__PURE__ */ h.jsx(GC, { children: d.shortcut })
          ]
        },
        d.type
      ))) }),
      /* @__PURE__ */ h.jsx(KC, {}),
      /* @__PURE__ */ h.jsx(Mb, { heading: "Tools", children: c.map((d) => {
        const u = d.icon;
        return /* @__PURE__ */ h.jsxs(
          Dd,
          {
            onSelect: () => l(() => n(d.path)),
            children: [
              /* @__PURE__ */ h.jsx(u, { className: "mr-2 h-4 w-4" }),
              /* @__PURE__ */ h.jsx("span", { children: d.title }),
              /* @__PURE__ */ h.jsx(GC, { children: d.shortcut })
            ]
          },
          d.type
        );
      }) }),
      a.length > 0 && /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
        /* @__PURE__ */ h.jsx(KC, {}),
        /* @__PURE__ */ h.jsx(Mb, { heading: o.trim() ? "Search Results" : "Recent Artifacts", children: a.map((d) => {
          const u = er[d.type], f = u.icon;
          return /* @__PURE__ */ h.jsxs(
            Dd,
            {
              onSelect: () => l(() => n(`${u.path}/${d.id}`)),
              children: [
                /* @__PURE__ */ h.jsx(f, { className: "mr-2 h-4 w-4 text-muted-foreground" }),
                /* @__PURE__ */ h.jsx("span", { className: "flex-1", children: d.name }),
                /* @__PURE__ */ h.jsx("span", { className: "text-xs text-muted-foreground", children: Qx(d.updatedAt) })
              ]
            },
            d.id
          );
        }) })
      ] })
    ] })
  ] });
}
function hke() {
  const { commandPaletteOpen: t, setCommandPaletteOpen: e } = jIe(), { storage: n } = cI();
  return me(() => {
    LIe(n).catch((r) => {
      console.error("Failed to seed default note:", r);
    });
  }, [n]), /* @__PURE__ */ h.jsxs("div", { className: "flex min-h-screen w-full", children: [
    /* @__PURE__ */ h.jsx(NIe, {}),
    /* @__PURE__ */ h.jsx(kZ, { className: "flex flex-col flex-1", children: /* @__PURE__ */ h.jsx("main", { className: "flex-1 flex flex-col", children: /* @__PURE__ */ h.jsx(Gbe, {}) }) }),
    /* @__PURE__ */ h.jsx(fke, { open: t, onOpenChange: e })
  ] });
}
function pke() {
  return /* @__PURE__ */ h.jsx(_Ie, { children: /* @__PURE__ */ h.jsx(PZ, { children: /* @__PURE__ */ h.jsx(hke, {}) }) });
}
const uI = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("div", { ref: n, className: Oe("rounded-lg border bg-card text-card-foreground shadow-sm", t), ...e }));
uI.displayName = "Card";
const BL = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("div", { ref: n, className: Oe("flex flex-col space-y-1.5 p-6", t), ...e })
);
BL.displayName = "CardHeader";
const zL = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("h3", { ref: n, className: Oe("text-2xl font-semibold leading-none tracking-tight", t), ...e })
);
zL.displayName = "CardTitle";
const WQ = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("p", { ref: n, className: Oe("text-sm text-muted-foreground", t), ...e })
);
WQ.displayName = "CardDescription";
const UL = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("div", { ref: n, className: Oe("p-6 pt-0", t), ...e })
);
UL.displayName = "CardContent";
const gke = T.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx("div", { ref: n, className: Oe("flex items-center p-6 pt-0", t), ...e })
);
gke.displayName = "CardFooter";
const mke = () => {
  const t = rd(), e = sI(), { isToolEnabled: n, loading: r } = cI(), { artifacts: s } = uu(), [o, i] = he(""), a = r ? Sp : Sp.filter((u) => n(u.type)), c = Ke(() => s.slice(0, 5), [s]), l = async (u) => {
    const f = `${window.location.origin}${e}${er[u.type].path}/${u.id}`;
    try {
      await navigator.clipboard.writeText(f), Fd({ title: "Link copied" });
    } catch {
      Fd({ title: "Copy failed", description: "Unable to access clipboard.", variant: "destructive" });
    }
  }, d = Ke(() => {
    const u = o.trim().toLowerCase();
    return u ? s.filter((f) => PIe(f).includes(u)) : [];
  }, [s, o]);
  return /* @__PURE__ */ h.jsx("div", { className: "flex-1 p-6 overflow-auto", children: /* @__PURE__ */ h.jsxs("div", { className: "max-w-4xl mx-auto space-y-8", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "text-center space-y-2", children: [
      /* @__PURE__ */ h.jsx("h1", { className: "text-3xl font-bold tracking-tight text-foreground", children: "Idea Room" }),
      /* @__PURE__ */ h.jsx("p", { className: "text-muted-foreground max-w-lg mx-auto", children: "Your project's creative memory. Capture the spark, map the vision, track the journey." })
    ] }),
    /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ h.jsx("h2", { className: "text-lg font-semibold text-foreground", children: "Search" }),
      /* @__PURE__ */ h.jsx(
        pa,
        {
          placeholder: "Search notes, flows, boards, and sketches...",
          value: o,
          onChange: (u) => i(u.target.value)
        }
      ),
      o.trim().length > 0 && /* @__PURE__ */ h.jsx("div", { className: "mt-3 space-y-2", children: d.length === 0 ? /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground", children: "No matches yet." }) : /* @__PURE__ */ h.jsx("div", { className: "space-y-2", children: d.slice(0, 10).map((u) => /* @__PURE__ */ h.jsx(
        Bd,
        {
          to: `${er[u.type].path}/${u.id}`,
          className: "block rounded-lg border border-border bg-card p-3 transition hover:border-ring",
          children: /* @__PURE__ */ h.jsxs("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ h.jsxs("div", { children: [
              /* @__PURE__ */ h.jsx("p", { className: "text-sm font-medium text-foreground", children: u.name }),
              /* @__PURE__ */ h.jsxs("p", { className: "text-xs text-muted-foreground", children: [
                er[u.type].title,
                "  Updated ",
                Qx(u.updatedAt)
              ] })
            ] }),
            /* @__PURE__ */ h.jsx("span", { className: "text-xs text-muted-foreground", children: u.type })
          ] })
        },
        u.id
      )) }) })
    ] }),
    /* @__PURE__ */ h.jsx("div", { className: "grid gap-4 sm:grid-cols-2 lg:grid-cols-3", children: a.map((u) => {
      const f = u.icon;
      return /* @__PURE__ */ h.jsxs(
        uI,
        {
          className: "cursor-pointer transition-all hover:shadow-md hover:border-ring",
          onClick: () => t(u.path),
          children: [
            /* @__PURE__ */ h.jsx(BL, { className: "pb-2", children: /* @__PURE__ */ h.jsxs("div", { className: "flex items-center justify-between", children: [
              /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ h.jsx("div", { className: "p-2 rounded-md bg-muted", children: /* @__PURE__ */ h.jsx(f, { className: "h-5 w-5 text-muted-foreground" }) }),
                /* @__PURE__ */ h.jsx(zL, { className: "text-lg", children: u.title })
              ] }),
              /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded text-muted-foreground", children: u.shortcut })
            ] }) }),
            /* @__PURE__ */ h.jsx(UL, { children: /* @__PURE__ */ h.jsx(WQ, { children: u.description }) })
          ]
        },
        u.type
      );
    }) }),
    /* @__PURE__ */ h.jsxs("div", { className: "space-y-3", children: [
      /* @__PURE__ */ h.jsx("h2", { className: "text-lg font-semibold text-foreground", children: "Recent Activity" }),
      /* @__PURE__ */ h.jsx("div", { className: "space-y-2", children: c.length === 0 ? /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground", children: "No artifacts yet. Create your first one." }) : c.map((u) => /* @__PURE__ */ h.jsxs(
        "div",
        {
          className: "flex items-center justify-between rounded-lg border border-border bg-card p-3 transition hover:border-ring",
          children: [
            /* @__PURE__ */ h.jsx(
              Bd,
              {
                to: `${er[u.type].path}/${u.id}`,
                className: "flex-1",
                children: /* @__PURE__ */ h.jsxs("div", { children: [
                  /* @__PURE__ */ h.jsx("p", { className: "text-sm font-medium text-foreground", children: u.name }),
                  /* @__PURE__ */ h.jsxs("p", { className: "text-xs text-muted-foreground", children: [
                    er[u.type].title,
                    "  Updated ",
                    Qx(u.updatedAt)
                  ] })
                ] })
              }
            ),
            /* @__PURE__ */ h.jsx(
              _t,
              {
                variant: "ghost",
                size: "icon",
                onClick: () => l(u),
                "aria-label": "Copy artifact link",
                children: /* @__PURE__ */ h.jsx(Qxe, { className: "h-4 w-4 text-muted-foreground" })
              }
            )
          ]
        },
        u.id
      )) })
    ] }),
    /* @__PURE__ */ h.jsxs("div", { className: "text-center text-sm text-muted-foreground space-y-1", children: [
      /* @__PURE__ */ h.jsxs("p", { children: [
        /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 text-xs font-mono bg-muted rounded", children: "K" }),
        " quick capture ",
        /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 text-xs font-mono bg-muted rounded ml-2", children: "N" }),
        " new ",
        /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 text-xs font-mono bg-muted rounded ml-2", children: "R" }),
        " relationships"
      ] }),
      /* @__PURE__ */ h.jsxs("p", { className: "text-xs text-muted-foreground/70", children: [
        "Link artifacts with ",
        /* @__PURE__ */ h.jsx("code", { className: "px-1 bg-muted rounded", children: "[[artifact name]]" }),
        " syntax in Docs & Tasks"
      ] })
    ] }),
    /* @__PURE__ */ h.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ h.jsxs(_t, { variant: "ghost", onClick: () => t("/settings"), className: "gap-2", children: [
      /* @__PURE__ */ h.jsx(_0, { className: "h-4 w-4" }),
      "Customize visible tools"
    ] }) })
  ] }) });
}, yke = {
  canvas: "canvas",
  diagram: "diagram",
  board: "board",
  notes: "note",
  calendar: "calendar"
};
function vke({ artifactId: t, type: e, className: n }) {
  const { toast: r } = j$(), s = async () => {
    const i = `Here is the link I want you to reference: ${`${window.location.origin}/${e}/${t}`}
Please check the page source for LLM instructions (look for the "blueprint-llm" JSON block).`;
    try {
      await navigator.clipboard.writeText(i), r({
        title: "Link copied!",
        description: `Share this link to show your ${yke[e]}.`
      });
    } catch {
      r({
        title: "Failed to copy",
        description: "Please copy the URL from the address bar.",
        variant: "destructive"
      });
    }
  };
  return /* @__PURE__ */ h.jsxs(
    _t,
    {
      variant: "outline",
      size: "sm",
      onClick: s,
      className: n,
      children: [
        /* @__PURE__ */ h.jsx(Gq, { className: "h-4 w-4 mr-1" }),
        "Share"
      ]
    }
  );
}
function KQ({ tags: t, onTagsChange: e, placeholder: n = "Add tag...", className: r }) {
  const [s, o] = he(""), [i, a] = he(!1), c = re((u) => {
    const f = u.trim().toLowerCase();
    f && !t.includes(f) && e([...t, f]), o(""), a(!1);
  }, [t, e]), l = re((u) => {
    e(t.filter((f) => f !== u));
  }, [t, e]), d = re((u) => {
    u.key === "Enter" ? (u.preventDefault(), c(s)) : u.key === "Escape" ? (o(""), a(!1)) : u.key === "Backspace" && !s && t.length > 0 && l(t[t.length - 1]);
  }, [s, c, t, l]);
  return /* @__PURE__ */ h.jsx("div", { className: r, children: /* @__PURE__ */ h.jsxs("div", { className: "flex flex-wrap gap-1.5 items-center", children: [
    t.map((u) => /* @__PURE__ */ h.jsxs(
      cE,
      {
        variant: "secondary",
        className: "text-xs px-2 py-0.5 pr-1 flex items-center gap-1",
        children: [
          u,
          /* @__PURE__ */ h.jsx(
            "button",
            {
              type: "button",
              onClick: () => l(u),
              className: "hover:bg-muted-foreground/20 rounded-full p-0.5 transition-colors",
              children: /* @__PURE__ */ h.jsx(rg, { className: "h-3 w-3" })
            }
          )
        ]
      },
      u
    )),
    i ? /* @__PURE__ */ h.jsx(
      pa,
      {
        value: s,
        onChange: (u) => o(u.target.value),
        onKeyDown: d,
        onBlur: () => {
          s ? c(s) : a(!1);
        },
        placeholder: n,
        className: "h-6 w-24 text-xs px-2",
        autoFocus: !0
      }
    ) : /* @__PURE__ */ h.jsxs(
      _t,
      {
        variant: "ghost",
        size: "sm",
        onClick: () => a(!0),
        className: "h-6 px-2 text-xs text-muted-foreground hover:text-foreground",
        children: [
          /* @__PURE__ */ h.jsx(Jc, { className: "h-3 w-3 mr-1" }),
          "Add tag"
        ]
      }
    )
  ] }) });
}
var fI = "Popover", [GQ, $3t] = bs(fI, [
  Kf
]), R0 = Kf(), [bke, Yf] = GQ(fI), YQ = (t) => {
  const {
    __scopePopover: e,
    children: n,
    open: r,
    defaultOpen: s,
    onOpenChange: o,
    modal: i = !1
  } = t, a = R0(e), c = T.useRef(null), [l, d] = T.useState(!1), [u, f] = io({
    prop: r,
    defaultProp: s ?? !1,
    onChange: o,
    caller: fI
  });
  return /* @__PURE__ */ h.jsx(P0, { ...a, children: /* @__PURE__ */ h.jsx(
    bke,
    {
      scope: e,
      contentId: as(),
      triggerRef: c,
      open: u,
      onOpenChange: f,
      onOpenToggle: T.useCallback(() => f((p) => !p), [f]),
      hasCustomAnchor: l,
      onCustomAnchorAdd: T.useCallback(() => d(!0), []),
      onCustomAnchorRemove: T.useCallback(() => d(!1), []),
      modal: i,
      children: n
    }
  ) });
};
YQ.displayName = fI;
var qQ = "PopoverAnchor", xke = T.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, s = Yf(qQ, n), o = R0(n), { onCustomAnchorAdd: i, onCustomAnchorRemove: a } = s;
    return T.useEffect(() => (i(), () => a()), [i, a]), /* @__PURE__ */ h.jsx(I0, { ...o, ...r, ref: e });
  }
);
xke.displayName = qQ;
var XQ = "PopoverTrigger", ZQ = T.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, s = Yf(XQ, n), o = R0(n), i = vt(e, s.triggerRef), a = /* @__PURE__ */ h.jsx(
      Re.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": s.open,
        "aria-controls": s.contentId,
        "data-state": nJ(s.open),
        ...r,
        ref: i,
        onClick: Te(t.onClick, s.onOpenToggle)
      }
    );
    return s.hasCustomAnchor ? a : /* @__PURE__ */ h.jsx(I0, { asChild: !0, ...o, children: a });
  }
);
ZQ.displayName = XQ;
var HL = "PopoverPortal", [wke, Ske] = GQ(HL, {
  forceMount: void 0
}), QQ = (t) => {
  const { __scopePopover: e, forceMount: n, children: r, container: s } = t, o = Yf(HL, e);
  return /* @__PURE__ */ h.jsx(wke, { scope: e, forceMount: n, children: /* @__PURE__ */ h.jsx(Fs, { present: n || o.open, children: /* @__PURE__ */ h.jsx(Uy, { asChild: !0, container: s, children: r }) }) });
};
QQ.displayName = HL;
var ey = "PopoverContent", JQ = T.forwardRef(
  (t, e) => {
    const n = Ske(ey, t.__scopePopover), { forceMount: r = n.forceMount, ...s } = t, o = Yf(ey, t.__scopePopover);
    return /* @__PURE__ */ h.jsx(Fs, { present: r || o.open, children: o.modal ? /* @__PURE__ */ h.jsx(_ke, { ...s, ref: e }) : /* @__PURE__ */ h.jsx(Eke, { ...s, ref: e }) });
  }
);
JQ.displayName = ey;
var Cke = /* @__PURE__ */ kf("PopoverContent.RemoveScroll"), _ke = T.forwardRef(
  (t, e) => {
    const n = Yf(ey, t.__scopePopover), r = T.useRef(null), s = vt(e, r), o = T.useRef(!1);
    return T.useEffect(() => {
      const i = r.current;
      if (i) return JP(i);
    }, []), /* @__PURE__ */ h.jsx(A0, { as: Cke, allowPinchZoom: !0, children: /* @__PURE__ */ h.jsx(
      eJ,
      {
        ...t,
        ref: s,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Te(t.onCloseAutoFocus, (i) => {
          var a;
          i.preventDefault(), o.current || (a = n.triggerRef.current) == null || a.focus();
        }),
        onPointerDownOutside: Te(
          t.onPointerDownOutside,
          (i) => {
            const a = i.detail.originalEvent, c = a.button === 0 && a.ctrlKey === !0, l = a.button === 2 || c;
            o.current = l;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Te(
          t.onFocusOutside,
          (i) => i.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), Eke = T.forwardRef(
  (t, e) => {
    const n = Yf(ey, t.__scopePopover), r = T.useRef(!1), s = T.useRef(!1);
    return /* @__PURE__ */ h.jsx(
      eJ,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          var i, a;
          (i = t.onCloseAutoFocus) == null || i.call(t, o), o.defaultPrevented || (r.current || (a = n.triggerRef.current) == null || a.focus(), o.preventDefault()), r.current = !1, s.current = !1;
        },
        onInteractOutside: (o) => {
          var c, l;
          (c = t.onInteractOutside) == null || c.call(t, o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (s.current = !0));
          const i = o.target;
          ((l = n.triggerRef.current) == null ? void 0 : l.contains(i)) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && s.current && o.preventDefault();
        }
      }
    );
  }
), eJ = T.forwardRef(
  (t, e) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: s,
      onCloseAutoFocus: o,
      disableOutsidePointerEvents: i,
      onEscapeKeyDown: a,
      onPointerDownOutside: c,
      onFocusOutside: l,
      onInteractOutside: d,
      ...u
    } = t, f = Yf(ey, n), p = R0(n);
    return ZP(), /* @__PURE__ */ h.jsx(
      k0,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: s,
        onUnmountAutoFocus: o,
        children: /* @__PURE__ */ h.jsx(
          ng,
          {
            asChild: !0,
            disableOutsidePointerEvents: i,
            onInteractOutside: d,
            onEscapeKeyDown: a,
            onPointerDownOutside: c,
            onFocusOutside: l,
            onDismiss: () => f.onOpenChange(!1),
            children: /* @__PURE__ */ h.jsx(
              KP,
              {
                "data-state": nJ(f.open),
                role: "dialog",
                id: f.contentId,
                ...p,
                ...u,
                ref: e,
                style: {
                  ...u.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), tJ = "PopoverClose", Tke = T.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, s = Yf(tJ, n);
    return /* @__PURE__ */ h.jsx(
      Re.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: Te(t.onClick, () => s.onOpenChange(!1))
      }
    );
  }
);
Tke.displayName = tJ;
var Pke = "PopoverArrow", Ike = T.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, s = R0(n);
    return /* @__PURE__ */ h.jsx(GP, { ...s, ...r, ref: e });
  }
);
Ike.displayName = Pke;
function nJ(t) {
  return t ? "open" : "closed";
}
var hI = YQ, pI = ZQ, gI = QQ, $0 = JQ;
const Jx = hI, ew = pI, ty = T.forwardRef(({ className: t, align: e = "center", sideOffset: n = 4, ...r }, s) => /* @__PURE__ */ h.jsx(gI, { children: /* @__PURE__ */ h.jsx(
  $0,
  {
    ref: s,
    align: e,
    sideOffset: n,
    className: Oe(
      "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      t
    ),
    ...r
  }
) }));
ty.displayName = $0.displayName;
const kke = [];
function zl({
  title: t,
  icon: e,
  artifactId: n,
  artifactName: r,
  artifactType: s,
  artifactFavorite: o,
  artifactTags: i = kke,
  saving: a,
  onRename: c,
  onToggleFavorite: l,
  onUpdateTags: d,
  headerActions: u
}) {
  const f = rd(), [p, g] = he(!1), [y, m] = he(r || ""), [v, b] = he(!1), x = re(() => {
    g(!1), y.trim() && y !== r && c && c(y.trim());
  }, [y, r, c]), w = re((M) => {
    M.key === "Enter" ? x() : M.key === "Escape" && (m(r || ""), g(!1));
  }, [x, r]), S = n && r && s, C = s ? er[s].path : "/", _ = () => {
    f(C);
  }, E = () => {
    f("/");
  };
  return /* @__PURE__ */ h.jsxs("div", { className: "flex items-center justify-between border-b border-border bg-background px-4 py-3", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 min-w-0 flex-1", children: [
      /* @__PURE__ */ h.jsxs($D, { children: [
        /* @__PURE__ */ h.jsx(LD, { asChild: !0, children: /* @__PURE__ */ h.jsx(
          _t,
          {
            variant: "ghost",
            size: "icon",
            onClick: _,
            className: "h-8 w-8 flex-shrink-0",
            children: /* @__PURE__ */ h.jsx(BP, { className: "h-4 w-4" })
          }
        ) }),
        /* @__PURE__ */ h.jsxs(Z_, { side: "bottom", children: [
          /* @__PURE__ */ h.jsx("span", { children: "Back to gallery" }),
          /* @__PURE__ */ h.jsx("kbd", { className: "ml-2 px-1.5 py-0.5 text-xs font-mono bg-muted rounded", children: "G" })
        ] })
      ] }),
      /* @__PURE__ */ h.jsx(e, { className: "h-5 w-5 text-muted-foreground flex-shrink-0" }),
      S ? p ? /* @__PURE__ */ h.jsx(
        pa,
        {
          value: y,
          onChange: (M) => m(M.target.value),
          onBlur: x,
          onKeyDown: w,
          className: "h-7 text-lg font-semibold max-w-xs",
          autoFocus: !0
        }
      ) : /* @__PURE__ */ h.jsx(
        "h1",
        {
          className: "text-lg font-semibold text-foreground truncate cursor-pointer hover:text-primary transition-colors",
          onClick: () => {
            m(r || ""), g(!0);
          },
          title: "Click to rename",
          children: r
        }
      ) : /* @__PURE__ */ h.jsx("h1", { className: "text-lg font-semibold text-foreground", children: t }),
      a && /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-1 text-muted-foreground text-sm", children: [
        /* @__PURE__ */ h.jsx(Wy, { className: "h-3 w-3 animate-spin" }),
        /* @__PURE__ */ h.jsx("span", { children: "Saving..." })
      ] }),
      !a && S && /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-1 text-muted-foreground text-sm", children: [
        /* @__PURE__ */ h.jsx(W$, { className: "h-3 w-3" }),
        /* @__PURE__ */ h.jsx("span", { children: "Saved" })
      ] })
    ] }),
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
      u,
      S && d && /* @__PURE__ */ h.jsxs(Jx, { open: v, onOpenChange: b, children: [
        /* @__PURE__ */ h.jsx(ew, { asChild: !0, children: /* @__PURE__ */ h.jsxs(
          _t,
          {
            variant: "ghost",
            size: "sm",
            className: "h-8 gap-1.5",
            children: [
              /* @__PURE__ */ h.jsx(E0, { className: "h-4 w-4" }),
              i.length > 0 && /* @__PURE__ */ h.jsx("span", { className: "text-xs", children: i.length })
            ]
          }
        ) }),
        /* @__PURE__ */ h.jsx(ty, { className: "w-80", align: "end", children: /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx("h4", { className: "font-medium text-sm", children: "Tags" }),
          /* @__PURE__ */ h.jsx(
            KQ,
            {
              tags: i,
              onTagsChange: d,
              placeholder: "Add tag..."
            }
          )
        ] }) })
      ] }),
      S && l && /* @__PURE__ */ h.jsx(
        _t,
        {
          variant: "ghost",
          size: "icon",
          onClick: l,
          className: "h-8 w-8",
          children: /* @__PURE__ */ h.jsx(yf, { className: `h-4 w-4 ${o ? "text-yellow-500 fill-yellow-500" : ""}` })
        }
      ),
      S && /* @__PURE__ */ h.jsx(vke, { artifactId: n, type: s }),
      /* @__PURE__ */ h.jsxs($D, { children: [
        /* @__PURE__ */ h.jsx(LD, { asChild: !0, children: /* @__PURE__ */ h.jsx(
          _t,
          {
            variant: "ghost",
            size: "icon",
            onClick: E,
            className: "h-8 w-8",
            children: /* @__PURE__ */ h.jsx(rg, { className: "h-4 w-4" })
          }
        ) }),
        /* @__PURE__ */ h.jsx(Z_, { side: "bottom", children: /* @__PURE__ */ h.jsx("span", { children: "Close to home" }) })
      ] })
    ] })
  ] });
}
function qe(t) {
  const e = Object.prototype.toString.call(t);
  return t instanceof Date || typeof t == "object" && e === "[object Date]" ? new t.constructor(+t) : typeof t == "number" || e === "[object Number]" || typeof t == "string" || e === "[object String]" ? new Date(t) : /* @__PURE__ */ new Date(NaN);
}
function On(t, e) {
  return t instanceof Date ? new t.constructor(e) : new Date(e);
}
function Xs(t, e) {
  const n = qe(t);
  return isNaN(e) ? On(t, NaN) : (e && n.setDate(n.getDate() + e), n);
}
function Ca(t, e) {
  const n = qe(t);
  if (isNaN(e)) return On(t, NaN);
  if (!e)
    return n;
  const r = n.getDate(), s = On(t, n.getTime());
  s.setMonth(n.getMonth() + e + 1, 0);
  const o = s.getDate();
  return r >= o ? s : (n.setFullYear(
    s.getFullYear(),
    s.getMonth(),
    r
  ), n);
}
function Ake(t) {
  return qe(t).getDay() === 6;
}
function Mke(t) {
  return qe(t).getDay() === 0;
}
function Oke(t, e) {
  const n = +qe(t);
  return On(t, n + e);
}
const VL = 6048e5, Dke = 864e5, Nke = 6e4, rJ = 36e5, jke = 1e3, u1 = 43200, cU = 1440;
function lU(t, e) {
  return Oke(t, e * rJ);
}
let Rke = {};
function qf() {
  return Rke;
}
function Wi(t, e) {
  var a, c, l, d;
  const n = qf(), r = (e == null ? void 0 : e.weekStartsOn) ?? ((c = (a = e == null ? void 0 : e.locale) == null ? void 0 : a.options) == null ? void 0 : c.weekStartsOn) ?? n.weekStartsOn ?? ((d = (l = n.locale) == null ? void 0 : l.options) == null ? void 0 : d.weekStartsOn) ?? 0, s = qe(t), o = s.getDay(), i = (o < r ? 7 : 0) + o - r;
  return s.setDate(s.getDate() - i), s.setHours(0, 0, 0, 0), s;
}
function ru(t) {
  return Wi(t, { weekStartsOn: 1 });
}
function sJ(t) {
  const e = qe(t), n = e.getFullYear(), r = On(t, 0);
  r.setFullYear(n + 1, 0, 4), r.setHours(0, 0, 0, 0);
  const s = ru(r), o = On(t, 0);
  o.setFullYear(n, 0, 4), o.setHours(0, 0, 0, 0);
  const i = ru(o);
  return e.getTime() >= s.getTime() ? n + 1 : e.getTime() >= i.getTime() ? n : n - 1;
}
function ny(t) {
  const e = qe(t);
  return e.setHours(0, 0, 0, 0), e;
}
function Df(t) {
  const e = qe(t), n = new Date(
    Date.UTC(
      e.getFullYear(),
      e.getMonth(),
      e.getDate(),
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    )
  );
  return n.setUTCFullYear(e.getFullYear()), +t - +n;
}
function jl(t, e) {
  const n = ny(t), r = ny(e), s = +n - Df(n), o = +r - Df(r);
  return Math.round((s - o) / Dke);
}
function $ke(t) {
  const e = sJ(t), n = On(t, 0);
  return n.setFullYear(e, 0, 4), n.setHours(0, 0, 0, 0), ru(n);
}
function kN(t, e) {
  const n = e * 7;
  return Xs(t, n);
}
function WL(t, e) {
  return Ca(t, e * 12);
}
function Lke(t) {
  let e;
  return t.forEach(function(n) {
    const r = qe(n);
    (e === void 0 || e < r || isNaN(Number(r))) && (e = r);
  }), e || /* @__PURE__ */ new Date(NaN);
}
function Fke(t) {
  let e;
  return t.forEach((n) => {
    const r = qe(n);
    (!e || e > r || isNaN(+r)) && (e = r);
  }), e || /* @__PURE__ */ new Date(NaN);
}
function YC(t, e) {
  const n = qe(t), r = qe(e), s = n.getTime() - r.getTime();
  return s < 0 ? -1 : s > 0 ? 1 : s;
}
function oJ(t) {
  return On(t, Date.now());
}
function Ao(t, e) {
  const n = ny(t), r = ny(e);
  return +n == +r;
}
function KL(t) {
  return t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]";
}
function Bke(t) {
  if (!KL(t) && typeof t != "number")
    return !1;
  const e = qe(t);
  return !isNaN(Number(e));
}
function ry(t, e) {
  const n = qe(t), r = qe(e), s = n.getFullYear() - r.getFullYear(), o = n.getMonth() - r.getMonth();
  return s * 12 + o;
}
function zke(t, e, n) {
  const r = Wi(t, n), s = Wi(e, n), o = +r - Df(r), i = +s - Df(s);
  return Math.round((o - i) / VL);
}
function Uke(t) {
  return (e) => {
    const r = (t ? Math[t] : Math.trunc)(e);
    return r === 0 ? 0 : r;
  };
}
function Hke(t, e) {
  return +qe(t) - +qe(e);
}
function Vke(t) {
  const e = qe(t);
  return e.setHours(23, 59, 59, 999), e;
}
function L0(t) {
  const e = qe(t), n = e.getMonth();
  return e.setFullYear(e.getFullYear(), n + 1, 0), e.setHours(23, 59, 59, 999), e;
}
function Wke(t) {
  const e = qe(t);
  return +Vke(e) == +L0(e);
}
function Kke(t, e) {
  const n = qe(t), r = qe(e), s = YC(n, r), o = Math.abs(
    ry(n, r)
  );
  let i;
  if (o < 1)
    i = 0;
  else {
    n.getMonth() === 1 && n.getDate() > 27 && n.setDate(30), n.setMonth(n.getMonth() - s * o);
    let a = YC(n, r) === -s;
    Wke(qe(t)) && o === 1 && YC(t, r) === 1 && (a = !1), i = s * (o - Number(a));
  }
  return i === 0 ? 0 : i;
}
function Gke(t, e, n) {
  const r = Hke(t, e) / 1e3;
  return Uke(n == null ? void 0 : n.roundingMethod)(r);
}
function Yke(t, e) {
  const n = qe(t.start), r = qe(t.end);
  let s = +n > +r;
  const o = s ? +n : +r, i = s ? r : n;
  i.setHours(0, 0, 0, 0);
  let a = 1;
  const c = [];
  for (; +i <= o; )
    c.push(qe(i)), i.setDate(i.getDate() + a), i.setHours(0, 0, 0, 0);
  return s ? c.reverse() : c;
}
function qke(t, e) {
  const n = qe(t.start), r = qe(t.end);
  let s = +n > +r;
  const o = s ? +n : +r, i = s ? r : n;
  i.setHours(0, 0, 0, 0), i.setDate(1);
  let a = 1;
  const c = [];
  for (; +i <= o; )
    c.push(qe(i)), i.setMonth(i.getMonth() + a);
  return s ? c.reverse() : c;
}
function ii(t) {
  const e = qe(t);
  return e.setDate(1), e.setHours(0, 0, 0, 0), e;
}
function Xke(t) {
  const e = qe(t), n = e.getFullYear();
  return e.setFullYear(n + 1, 0, 0), e.setHours(23, 59, 59, 999), e;
}
function GL(t) {
  const e = qe(t), n = On(t, 0);
  return n.setFullYear(e.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;
}
function YL(t, e) {
  var a, c, l, d;
  const n = qf(), r = (e == null ? void 0 : e.weekStartsOn) ?? ((c = (a = e == null ? void 0 : e.locale) == null ? void 0 : a.options) == null ? void 0 : c.weekStartsOn) ?? n.weekStartsOn ?? ((d = (l = n.locale) == null ? void 0 : l.options) == null ? void 0 : d.weekStartsOn) ?? 0, s = qe(t), o = s.getDay(), i = (o < r ? -7 : 0) + 6 - (o - r);
  return s.setDate(s.getDate() + i), s.setHours(23, 59, 59, 999), s;
}
function iJ(t) {
  return YL(t, { weekStartsOn: 1 });
}
const Zke = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, Qke = (t, e, n) => {
  let r;
  const s = Zke[t];
  return typeof s == "string" ? r = s : e === 1 ? r = s.one : r = s.other.replace("{{count}}", e.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r;
};
function fM(t) {
  return (e = {}) => {
    const n = e.width ? String(e.width) : t.defaultWidth;
    return t.formats[n] || t.formats[t.defaultWidth];
  };
}
const Jke = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, eAe = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, tAe = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, nAe = {
  date: fM({
    formats: Jke,
    defaultWidth: "full"
  }),
  time: fM({
    formats: eAe,
    defaultWidth: "full"
  }),
  dateTime: fM({
    formats: tAe,
    defaultWidth: "full"
  })
}, rAe = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, sAe = (t, e, n, r) => rAe[t];
function Wv(t) {
  return (e, n) => {
    const r = n != null && n.context ? String(n.context) : "standalone";
    let s;
    if (r === "formatting" && t.formattingValues) {
      const i = t.defaultFormattingWidth || t.defaultWidth, a = n != null && n.width ? String(n.width) : i;
      s = t.formattingValues[a] || t.formattingValues[i];
    } else {
      const i = t.defaultWidth, a = n != null && n.width ? String(n.width) : t.defaultWidth;
      s = t.values[a] || t.values[i];
    }
    const o = t.argumentCallback ? t.argumentCallback(e) : e;
    return s[o];
  };
}
const oAe = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, iAe = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, aAe = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, cAe = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, lAe = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, dAe = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, uAe = (t, e) => {
  const n = Number(t), r = n % 100;
  if (r > 20 || r < 10)
    switch (r % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd";
    }
  return n + "th";
}, fAe = {
  ordinalNumber: uAe,
  era: Wv({
    values: oAe,
    defaultWidth: "wide"
  }),
  quarter: Wv({
    values: iAe,
    defaultWidth: "wide",
    argumentCallback: (t) => t - 1
  }),
  month: Wv({
    values: aAe,
    defaultWidth: "wide"
  }),
  day: Wv({
    values: cAe,
    defaultWidth: "wide"
  }),
  dayPeriod: Wv({
    values: lAe,
    defaultWidth: "wide",
    formattingValues: dAe,
    defaultFormattingWidth: "wide"
  })
};
function Kv(t) {
  return (e, n = {}) => {
    const r = n.width, s = r && t.matchPatterns[r] || t.matchPatterns[t.defaultMatchWidth], o = e.match(s);
    if (!o)
      return null;
    const i = o[0], a = r && t.parsePatterns[r] || t.parsePatterns[t.defaultParseWidth], c = Array.isArray(a) ? pAe(a, (u) => u.test(i)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      hAe(a, (u) => u.test(i))
    );
    let l;
    l = t.valueCallback ? t.valueCallback(c) : c, l = n.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      n.valueCallback(l)
    ) : l;
    const d = e.slice(i.length);
    return { value: l, rest: d };
  };
}
function hAe(t, e) {
  for (const n in t)
    if (Object.prototype.hasOwnProperty.call(t, n) && e(t[n]))
      return n;
}
function pAe(t, e) {
  for (let n = 0; n < t.length; n++)
    if (e(t[n]))
      return n;
}
function gAe(t) {
  return (e, n = {}) => {
    const r = e.match(t.matchPattern);
    if (!r) return null;
    const s = r[0], o = e.match(t.parsePattern);
    if (!o) return null;
    let i = t.valueCallback ? t.valueCallback(o[0]) : o[0];
    i = n.valueCallback ? n.valueCallback(i) : i;
    const a = e.slice(s.length);
    return { value: i, rest: a };
  };
}
const mAe = /^(\d+)(th|st|nd|rd)?/i, yAe = /\d+/i, vAe = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, bAe = {
  any: [/^b/i, /^(a|c)/i]
}, xAe = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, wAe = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, SAe = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, CAe = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, _Ae = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, EAe = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, TAe = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, PAe = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, IAe = {
  ordinalNumber: gAe({
    matchPattern: mAe,
    parsePattern: yAe,
    valueCallback: (t) => parseInt(t, 10)
  }),
  era: Kv({
    matchPatterns: vAe,
    defaultMatchWidth: "wide",
    parsePatterns: bAe,
    defaultParseWidth: "any"
  }),
  quarter: Kv({
    matchPatterns: xAe,
    defaultMatchWidth: "wide",
    parsePatterns: wAe,
    defaultParseWidth: "any",
    valueCallback: (t) => t + 1
  }),
  month: Kv({
    matchPatterns: SAe,
    defaultMatchWidth: "wide",
    parsePatterns: CAe,
    defaultParseWidth: "any"
  }),
  day: Kv({
    matchPatterns: _Ae,
    defaultMatchWidth: "wide",
    parsePatterns: EAe,
    defaultParseWidth: "any"
  }),
  dayPeriod: Kv({
    matchPatterns: TAe,
    defaultMatchWidth: "any",
    parsePatterns: PAe,
    defaultParseWidth: "any"
  })
}, F0 = {
  code: "en-US",
  formatDistance: Qke,
  formatLong: nAe,
  formatRelative: sAe,
  localize: fAe,
  match: IAe,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function kAe(t) {
  const e = qe(t);
  return jl(e, GL(e)) + 1;
}
function qL(t) {
  const e = qe(t), n = +ru(e) - +$ke(e);
  return Math.round(n / VL) + 1;
}
function XL(t, e) {
  var d, u, f, p;
  const n = qe(t), r = n.getFullYear(), s = qf(), o = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((u = (d = e == null ? void 0 : e.locale) == null ? void 0 : d.options) == null ? void 0 : u.firstWeekContainsDate) ?? s.firstWeekContainsDate ?? ((p = (f = s.locale) == null ? void 0 : f.options) == null ? void 0 : p.firstWeekContainsDate) ?? 1, i = On(t, 0);
  i.setFullYear(r + 1, 0, o), i.setHours(0, 0, 0, 0);
  const a = Wi(i, e), c = On(t, 0);
  c.setFullYear(r, 0, o), c.setHours(0, 0, 0, 0);
  const l = Wi(c, e);
  return n.getTime() >= a.getTime() ? r + 1 : n.getTime() >= l.getTime() ? r : r - 1;
}
function AAe(t, e) {
  var a, c, l, d;
  const n = qf(), r = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((c = (a = e == null ? void 0 : e.locale) == null ? void 0 : a.options) == null ? void 0 : c.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((d = (l = n.locale) == null ? void 0 : l.options) == null ? void 0 : d.firstWeekContainsDate) ?? 1, s = XL(t, e), o = On(t, 0);
  return o.setFullYear(s, 0, r), o.setHours(0, 0, 0, 0), Wi(o, e);
}
function ZL(t, e) {
  const n = qe(t), r = +Wi(n, e) - +AAe(n, e);
  return Math.round(r / VL) + 1;
}
function Mn(t, e) {
  const n = t < 0 ? "-" : "", r = Math.abs(t).toString().padStart(e, "0");
  return n + r;
}
const ku = {
  // Year
  y(t, e) {
    const n = t.getFullYear(), r = n > 0 ? n : 1 - n;
    return Mn(e === "yy" ? r % 100 : r, e.length);
  },
  // Month
  M(t, e) {
    const n = t.getMonth();
    return e === "M" ? String(n + 1) : Mn(n + 1, 2);
  },
  // Day of the month
  d(t, e) {
    return Mn(t.getDate(), e.length);
  },
  // AM or PM
  a(t, e) {
    const n = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return n.toUpperCase();
      case "aaa":
        return n;
      case "aaaaa":
        return n[0];
      case "aaaa":
      default:
        return n === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(t, e) {
    return Mn(t.getHours() % 12 || 12, e.length);
  },
  // Hour [0-23]
  H(t, e) {
    return Mn(t.getHours(), e.length);
  },
  // Minute
  m(t, e) {
    return Mn(t.getMinutes(), e.length);
  },
  // Second
  s(t, e) {
    return Mn(t.getSeconds(), e.length);
  },
  // Fraction of second
  S(t, e) {
    const n = e.length, r = t.getMilliseconds(), s = Math.trunc(
      r * Math.pow(10, n - 3)
    );
    return Mn(s, e.length);
  }
}, Og = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, dU = {
  // Era
  G: function(t, e, n) {
    const r = t.getFullYear() > 0 ? 1 : 0;
    switch (e) {
      case "G":
      case "GG":
      case "GGG":
        return n.era(r, { width: "abbreviated" });
      case "GGGGG":
        return n.era(r, { width: "narrow" });
      case "GGGG":
      default:
        return n.era(r, { width: "wide" });
    }
  },
  // Year
  y: function(t, e, n) {
    if (e === "yo") {
      const r = t.getFullYear(), s = r > 0 ? r : 1 - r;
      return n.ordinalNumber(s, { unit: "year" });
    }
    return ku.y(t, e);
  },
  // Local week-numbering year
  Y: function(t, e, n, r) {
    const s = XL(t, r), o = s > 0 ? s : 1 - s;
    if (e === "YY") {
      const i = o % 100;
      return Mn(i, 2);
    }
    return e === "Yo" ? n.ordinalNumber(o, { unit: "year" }) : Mn(o, e.length);
  },
  // ISO week-numbering year
  R: function(t, e) {
    const n = sJ(t);
    return Mn(n, e.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(t, e) {
    const n = t.getFullYear();
    return Mn(n, e.length);
  },
  // Quarter
  Q: function(t, e, n) {
    const r = Math.ceil((t.getMonth() + 1) / 3);
    switch (e) {
      case "Q":
        return String(r);
      case "QQ":
        return Mn(r, 2);
      case "Qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      case "QQQ":
        return n.quarter(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return n.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(t, e, n) {
    const r = Math.ceil((t.getMonth() + 1) / 3);
    switch (e) {
      case "q":
        return String(r);
      case "qq":
        return Mn(r, 2);
      case "qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      case "qqq":
        return n.quarter(r, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return n.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(t, e, n) {
    const r = t.getMonth();
    switch (e) {
      case "M":
      case "MM":
        return ku.M(t, e);
      case "Mo":
        return n.ordinalNumber(r + 1, { unit: "month" });
      case "MMM":
        return n.month(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return n.month(r, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return n.month(r, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(t, e, n) {
    const r = t.getMonth();
    switch (e) {
      case "L":
        return String(r + 1);
      case "LL":
        return Mn(r + 1, 2);
      case "Lo":
        return n.ordinalNumber(r + 1, { unit: "month" });
      case "LLL":
        return n.month(r, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return n.month(r, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return n.month(r, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(t, e, n, r) {
    const s = ZL(t, r);
    return e === "wo" ? n.ordinalNumber(s, { unit: "week" }) : Mn(s, e.length);
  },
  // ISO week of year
  I: function(t, e, n) {
    const r = qL(t);
    return e === "Io" ? n.ordinalNumber(r, { unit: "week" }) : Mn(r, e.length);
  },
  // Day of the month
  d: function(t, e, n) {
    return e === "do" ? n.ordinalNumber(t.getDate(), { unit: "date" }) : ku.d(t, e);
  },
  // Day of year
  D: function(t, e, n) {
    const r = kAe(t);
    return e === "Do" ? n.ordinalNumber(r, { unit: "dayOfYear" }) : Mn(r, e.length);
  },
  // Day of week
  E: function(t, e, n) {
    const r = t.getDay();
    switch (e) {
      case "E":
      case "EE":
      case "EEE":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(t, e, n, r) {
    const s = t.getDay(), o = (s - r.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "e":
        return String(o);
      case "ee":
        return Mn(o, 2);
      case "eo":
        return n.ordinalNumber(o, { unit: "day" });
      case "eee":
        return n.day(s, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return n.day(s, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return n.day(s, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return n.day(s, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(t, e, n, r) {
    const s = t.getDay(), o = (s - r.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "c":
        return String(o);
      case "cc":
        return Mn(o, e.length);
      case "co":
        return n.ordinalNumber(o, { unit: "day" });
      case "ccc":
        return n.day(s, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return n.day(s, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return n.day(s, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return n.day(s, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(t, e, n) {
    const r = t.getDay(), s = r === 0 ? 7 : r;
    switch (e) {
      case "i":
        return String(s);
      case "ii":
        return Mn(s, e.length);
      case "io":
        return n.ordinalNumber(s, { unit: "day" });
      case "iii":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(t, e, n) {
    const s = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return n.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return n.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return n.dayPeriod(s, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(s, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(t, e, n) {
    const r = t.getHours();
    let s;
    switch (r === 12 ? s = Og.noon : r === 0 ? s = Og.midnight : s = r / 12 >= 1 ? "pm" : "am", e) {
      case "b":
      case "bb":
        return n.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return n.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return n.dayPeriod(s, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(s, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(t, e, n) {
    const r = t.getHours();
    let s;
    switch (r >= 17 ? s = Og.evening : r >= 12 ? s = Og.afternoon : r >= 4 ? s = Og.morning : s = Og.night, e) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(s, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(s, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(t, e, n) {
    if (e === "ho") {
      let r = t.getHours() % 12;
      return r === 0 && (r = 12), n.ordinalNumber(r, { unit: "hour" });
    }
    return ku.h(t, e);
  },
  // Hour [0-23]
  H: function(t, e, n) {
    return e === "Ho" ? n.ordinalNumber(t.getHours(), { unit: "hour" }) : ku.H(t, e);
  },
  // Hour [0-11]
  K: function(t, e, n) {
    const r = t.getHours() % 12;
    return e === "Ko" ? n.ordinalNumber(r, { unit: "hour" }) : Mn(r, e.length);
  },
  // Hour [1-24]
  k: function(t, e, n) {
    let r = t.getHours();
    return r === 0 && (r = 24), e === "ko" ? n.ordinalNumber(r, { unit: "hour" }) : Mn(r, e.length);
  },
  // Minute
  m: function(t, e, n) {
    return e === "mo" ? n.ordinalNumber(t.getMinutes(), { unit: "minute" }) : ku.m(t, e);
  },
  // Second
  s: function(t, e, n) {
    return e === "so" ? n.ordinalNumber(t.getSeconds(), { unit: "second" }) : ku.s(t, e);
  },
  // Fraction of second
  S: function(t, e) {
    return ku.S(t, e);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(t, e, n) {
    const r = t.getTimezoneOffset();
    if (r === 0)
      return "Z";
    switch (e) {
      case "X":
        return fU(r);
      case "XXXX":
      case "XX":
        return _h(r);
      case "XXXXX":
      case "XXX":
      default:
        return _h(r, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(t, e, n) {
    const r = t.getTimezoneOffset();
    switch (e) {
      case "x":
        return fU(r);
      case "xxxx":
      case "xx":
        return _h(r);
      case "xxxxx":
      case "xxx":
      default:
        return _h(r, ":");
    }
  },
  // Timezone (GMT)
  O: function(t, e, n) {
    const r = t.getTimezoneOffset();
    switch (e) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + uU(r, ":");
      case "OOOO":
      default:
        return "GMT" + _h(r, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(t, e, n) {
    const r = t.getTimezoneOffset();
    switch (e) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + uU(r, ":");
      case "zzzz":
      default:
        return "GMT" + _h(r, ":");
    }
  },
  // Seconds timestamp
  t: function(t, e, n) {
    const r = Math.trunc(t.getTime() / 1e3);
    return Mn(r, e.length);
  },
  // Milliseconds timestamp
  T: function(t, e, n) {
    const r = t.getTime();
    return Mn(r, e.length);
  }
};
function uU(t, e = "") {
  const n = t > 0 ? "-" : "+", r = Math.abs(t), s = Math.trunc(r / 60), o = r % 60;
  return o === 0 ? n + String(s) : n + String(s) + e + Mn(o, 2);
}
function fU(t, e) {
  return t % 60 === 0 ? (t > 0 ? "-" : "+") + Mn(Math.abs(t) / 60, 2) : _h(t, e);
}
function _h(t, e = "") {
  const n = t > 0 ? "-" : "+", r = Math.abs(t), s = Mn(Math.trunc(r / 60), 2), o = Mn(r % 60, 2);
  return n + s + e + o;
}
const hU = (t, e) => {
  switch (t) {
    case "P":
      return e.date({ width: "short" });
    case "PP":
      return e.date({ width: "medium" });
    case "PPP":
      return e.date({ width: "long" });
    case "PPPP":
    default:
      return e.date({ width: "full" });
  }
}, aJ = (t, e) => {
  switch (t) {
    case "p":
      return e.time({ width: "short" });
    case "pp":
      return e.time({ width: "medium" });
    case "ppp":
      return e.time({ width: "long" });
    case "pppp":
    default:
      return e.time({ width: "full" });
  }
}, MAe = (t, e) => {
  const n = t.match(/(P+)(p+)?/) || [], r = n[1], s = n[2];
  if (!s)
    return hU(t, e);
  let o;
  switch (r) {
    case "P":
      o = e.dateTime({ width: "short" });
      break;
    case "PP":
      o = e.dateTime({ width: "medium" });
      break;
    case "PPP":
      o = e.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      o = e.dateTime({ width: "full" });
      break;
  }
  return o.replace("{{date}}", hU(r, e)).replace("{{time}}", aJ(s, e));
}, AN = {
  p: aJ,
  P: MAe
}, OAe = /^D+$/, DAe = /^Y+$/, NAe = ["D", "DD", "YY", "YYYY"];
function cJ(t) {
  return OAe.test(t);
}
function lJ(t) {
  return DAe.test(t);
}
function MN(t, e, n) {
  const r = jAe(t, e, n);
  if (console.warn(r), NAe.includes(t)) throw new RangeError(r);
}
function jAe(t, e, n) {
  const r = t[0] === "Y" ? "years" : "days of the month";
  return `Use \`${t.toLowerCase()}\` instead of \`${t}\` (in \`${e}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const RAe = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, $Ae = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, LAe = /^'([^]*?)'?$/, FAe = /''/g, BAe = /[a-zA-Z]/;
function Rr(t, e, n) {
  var d, u, f, p, g, y, m, v;
  const r = qf(), s = (n == null ? void 0 : n.locale) ?? r.locale ?? F0, o = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((u = (d = n == null ? void 0 : n.locale) == null ? void 0 : d.options) == null ? void 0 : u.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((p = (f = r.locale) == null ? void 0 : f.options) == null ? void 0 : p.firstWeekContainsDate) ?? 1, i = (n == null ? void 0 : n.weekStartsOn) ?? ((y = (g = n == null ? void 0 : n.locale) == null ? void 0 : g.options) == null ? void 0 : y.weekStartsOn) ?? r.weekStartsOn ?? ((v = (m = r.locale) == null ? void 0 : m.options) == null ? void 0 : v.weekStartsOn) ?? 0, a = qe(t);
  if (!Bke(a))
    throw new RangeError("Invalid time value");
  let c = e.match($Ae).map((b) => {
    const x = b[0];
    if (x === "p" || x === "P") {
      const w = AN[x];
      return w(b, s.formatLong);
    }
    return b;
  }).join("").match(RAe).map((b) => {
    if (b === "''")
      return { isToken: !1, value: "'" };
    const x = b[0];
    if (x === "'")
      return { isToken: !1, value: zAe(b) };
    if (dU[x])
      return { isToken: !0, value: b };
    if (x.match(BAe))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + x + "`"
      );
    return { isToken: !1, value: b };
  });
  s.localize.preprocessor && (c = s.localize.preprocessor(a, c));
  const l = {
    firstWeekContainsDate: o,
    weekStartsOn: i,
    locale: s
  };
  return c.map((b) => {
    if (!b.isToken) return b.value;
    const x = b.value;
    (!(n != null && n.useAdditionalWeekYearTokens) && lJ(x) || !(n != null && n.useAdditionalDayOfYearTokens) && cJ(x)) && MN(x, e, String(t));
    const w = dU[x[0]];
    return w(a, x, s.localize, l);
  }).join("");
}
function zAe(t) {
  const e = t.match(LAe);
  return e ? e[1].replace(FAe, "'") : t;
}
function UAe(t, e, n) {
  const r = qf(), s = (n == null ? void 0 : n.locale) ?? r.locale ?? F0, o = 2520, i = YC(t, e);
  if (isNaN(i))
    throw new RangeError("Invalid time value");
  const a = Object.assign({}, n, {
    addSuffix: n == null ? void 0 : n.addSuffix,
    comparison: i
  });
  let c, l;
  i > 0 ? (c = qe(e), l = qe(t)) : (c = qe(t), l = qe(e));
  const d = Gke(l, c), u = (Df(l) - Df(c)) / 1e3, f = Math.round((d - u) / 60);
  let p;
  if (f < 2)
    return n != null && n.includeSeconds ? d < 5 ? s.formatDistance("lessThanXSeconds", 5, a) : d < 10 ? s.formatDistance("lessThanXSeconds", 10, a) : d < 20 ? s.formatDistance("lessThanXSeconds", 20, a) : d < 40 ? s.formatDistance("halfAMinute", 0, a) : d < 60 ? s.formatDistance("lessThanXMinutes", 1, a) : s.formatDistance("xMinutes", 1, a) : f === 0 ? s.formatDistance("lessThanXMinutes", 1, a) : s.formatDistance("xMinutes", f, a);
  if (f < 45)
    return s.formatDistance("xMinutes", f, a);
  if (f < 90)
    return s.formatDistance("aboutXHours", 1, a);
  if (f < cU) {
    const g = Math.round(f / 60);
    return s.formatDistance("aboutXHours", g, a);
  } else {
    if (f < o)
      return s.formatDistance("xDays", 1, a);
    if (f < u1) {
      const g = Math.round(f / cU);
      return s.formatDistance("xDays", g, a);
    } else if (f < u1 * 2)
      return p = Math.round(f / u1), s.formatDistance("aboutXMonths", p, a);
  }
  if (p = Kke(l, c), p < 12) {
    const g = Math.round(f / u1);
    return s.formatDistance("xMonths", g, a);
  } else {
    const g = p % 12, y = Math.trunc(p / 12);
    return g < 3 ? s.formatDistance("aboutXYears", y, a) : g < 9 ? s.formatDistance("overXYears", y, a) : s.formatDistance("almostXYears", y + 1, a);
  }
}
function HAe(t, e) {
  return UAe(t, oJ(t), e);
}
function VAe(t) {
  return qe(t).getDay();
}
function WAe(t) {
  const e = qe(t), n = e.getFullYear(), r = e.getMonth(), s = On(t, 0);
  return s.setFullYear(n, r + 1, 0), s.setHours(0, 0, 0, 0), s.getDate();
}
function KAe() {
  return Object.assign({}, qf());
}
function GAe(t) {
  let n = qe(t).getDay();
  return n === 0 && (n = 7), n;
}
function YAe(t) {
  return Math.trunc(+qe(t) / 1e3);
}
function qAe(t) {
  const e = qe(t), n = e.getMonth();
  return e.setFullYear(e.getFullYear(), n + 1, 0), e.setHours(0, 0, 0, 0), e;
}
function XAe(t, e) {
  return zke(
    qAe(t),
    ii(t),
    e
  ) + 1;
}
function ON(t, e) {
  const n = qe(t), r = qe(e);
  return n.getTime() > r.getTime();
}
function dJ(t, e) {
  const n = qe(t), r = qe(e);
  return +n < +r;
}
function ZAe(t, e) {
  const n = e instanceof Date ? On(e, 0) : new e(0);
  return n.setFullYear(
    t.getFullYear(),
    t.getMonth(),
    t.getDate()
  ), n.setHours(
    t.getHours(),
    t.getMinutes(),
    t.getSeconds(),
    t.getMilliseconds()
  ), n;
}
const QAe = 10;
class uJ {
  constructor() {
    P(this, "subPriority", 0);
  }
  validate(e, n) {
    return !0;
  }
}
class JAe extends uJ {
  constructor(e, n, r, s, o) {
    super(), this.value = e, this.validateValue = n, this.setValue = r, this.priority = s, o && (this.subPriority = o);
  }
  validate(e, n) {
    return this.validateValue(e, this.value, n);
  }
  set(e, n, r) {
    return this.setValue(e, n, this.value, r);
  }
}
class eMe extends uJ {
  constructor() {
    super(...arguments);
    P(this, "priority", QAe);
    P(this, "subPriority", -1);
  }
  set(n, r) {
    return r.timestampIsSet ? n : On(n, ZAe(n, Date));
  }
}
class xn {
  run(e, n, r, s) {
    const o = this.parse(e, n, r, s);
    return o ? {
      setter: new JAe(
        o.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: o.rest
    } : null;
  }
  validate(e, n, r) {
    return !0;
  }
}
class tMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 140);
    P(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "G":
      case "GG":
      case "GGG":
        return s.era(n, { width: "abbreviated" }) || s.era(n, { width: "narrow" });
      case "GGGGG":
        return s.era(n, { width: "narrow" });
      case "GGGG":
      default:
        return s.era(n, { width: "wide" }) || s.era(n, { width: "abbreviated" }) || s.era(n, { width: "narrow" });
    }
  }
  set(n, r, s) {
    return r.era = s, n.setFullYear(s, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
const $r = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, Ol = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function Lr(t, e) {
  return t && {
    value: e(t.value),
    rest: t.rest
  };
}
function gr(t, e) {
  const n = e.match(t);
  return n ? {
    value: parseInt(n[0], 10),
    rest: e.slice(n[0].length)
  } : null;
}
function Dl(t, e) {
  const n = e.match(t);
  if (!n)
    return null;
  if (n[0] === "Z")
    return {
      value: 0,
      rest: e.slice(1)
    };
  const r = n[1] === "+" ? 1 : -1, s = n[2] ? parseInt(n[2], 10) : 0, o = n[3] ? parseInt(n[3], 10) : 0, i = n[5] ? parseInt(n[5], 10) : 0;
  return {
    value: r * (s * rJ + o * Nke + i * jke),
    rest: e.slice(n[0].length)
  };
}
function fJ(t) {
  return gr($r.anyDigitsSigned, t);
}
function Ar(t, e) {
  switch (t) {
    case 1:
      return gr($r.singleDigit, e);
    case 2:
      return gr($r.twoDigits, e);
    case 3:
      return gr($r.threeDigits, e);
    case 4:
      return gr($r.fourDigits, e);
    default:
      return gr(new RegExp("^\\d{1," + t + "}"), e);
  }
}
function lE(t, e) {
  switch (t) {
    case 1:
      return gr($r.singleDigitSigned, e);
    case 2:
      return gr($r.twoDigitsSigned, e);
    case 3:
      return gr($r.threeDigitsSigned, e);
    case 4:
      return gr($r.fourDigitsSigned, e);
    default:
      return gr(new RegExp("^-?\\d{1," + t + "}"), e);
  }
}
function QL(t) {
  switch (t) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function hJ(t, e) {
  const n = e > 0, r = n ? e : 1 - e;
  let s;
  if (r <= 50)
    s = t || 100;
  else {
    const o = r + 50, i = Math.trunc(o / 100) * 100, a = t >= o % 100;
    s = t + i - (a ? 100 : 0);
  }
  return n ? s : 1 - s;
}
function pJ(t) {
  return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0;
}
class nMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 130);
    P(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(n, r, s) {
    const o = (i) => ({
      year: i,
      isTwoDigitYear: r === "yy"
    });
    switch (r) {
      case "y":
        return Lr(Ar(4, n), o);
      case "yo":
        return Lr(
          s.ordinalNumber(n, {
            unit: "year"
          }),
          o
        );
      default:
        return Lr(Ar(r.length, n), o);
    }
  }
  validate(n, r) {
    return r.isTwoDigitYear || r.year > 0;
  }
  set(n, r, s) {
    const o = n.getFullYear();
    if (s.isTwoDigitYear) {
      const a = hJ(
        s.year,
        o
      );
      return n.setFullYear(a, 0, 1), n.setHours(0, 0, 0, 0), n;
    }
    const i = !("era" in r) || r.era === 1 ? s.year : 1 - s.year;
    return n.setFullYear(i, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class rMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 130);
    P(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(n, r, s) {
    const o = (i) => ({
      year: i,
      isTwoDigitYear: r === "YY"
    });
    switch (r) {
      case "Y":
        return Lr(Ar(4, n), o);
      case "Yo":
        return Lr(
          s.ordinalNumber(n, {
            unit: "year"
          }),
          o
        );
      default:
        return Lr(Ar(r.length, n), o);
    }
  }
  validate(n, r) {
    return r.isTwoDigitYear || r.year > 0;
  }
  set(n, r, s, o) {
    const i = XL(n, o);
    if (s.isTwoDigitYear) {
      const c = hJ(
        s.year,
        i
      );
      return n.setFullYear(
        c,
        0,
        o.firstWeekContainsDate
      ), n.setHours(0, 0, 0, 0), Wi(n, o);
    }
    const a = !("era" in r) || r.era === 1 ? s.year : 1 - s.year;
    return n.setFullYear(a, 0, o.firstWeekContainsDate), n.setHours(0, 0, 0, 0), Wi(n, o);
  }
}
class sMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 130);
    P(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, r) {
    return lE(r === "R" ? 4 : r.length, n);
  }
  set(n, r, s) {
    const o = On(n, 0);
    return o.setFullYear(s, 0, 4), o.setHours(0, 0, 0, 0), ru(o);
  }
}
class oMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 130);
    P(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(n, r) {
    return lE(r === "u" ? 4 : r.length, n);
  }
  set(n, r, s) {
    return n.setFullYear(s, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class iMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 120);
    P(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, r, s) {
    switch (r) {
      case "Q":
      case "QQ":
        return Ar(r.length, n);
      case "Qo":
        return s.ordinalNumber(n, { unit: "quarter" });
      case "QQQ":
        return s.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return s.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return s.quarter(n, {
          width: "wide",
          context: "formatting"
        }) || s.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 4;
  }
  set(n, r, s) {
    return n.setMonth((s - 1) * 3, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class aMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 120);
    P(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, r, s) {
    switch (r) {
      case "q":
      case "qq":
        return Ar(r.length, n);
      case "qo":
        return s.ordinalNumber(n, { unit: "quarter" });
      case "qqq":
        return s.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return s.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return s.quarter(n, {
          width: "wide",
          context: "standalone"
        }) || s.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 4;
  }
  set(n, r, s) {
    return n.setMonth((s - 1) * 3, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class cMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    P(this, "priority", 110);
  }
  parse(n, r, s) {
    const o = (i) => i - 1;
    switch (r) {
      case "M":
        return Lr(
          gr($r.month, n),
          o
        );
      case "MM":
        return Lr(Ar(2, n), o);
      case "Mo":
        return Lr(
          s.ordinalNumber(n, {
            unit: "month"
          }),
          o
        );
      case "MMM":
        return s.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.month(n, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return s.month(n, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return s.month(n, { width: "wide", context: "formatting" }) || s.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.month(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 11;
  }
  set(n, r, s) {
    return n.setMonth(s, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class lMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 110);
    P(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, r, s) {
    const o = (i) => i - 1;
    switch (r) {
      case "L":
        return Lr(
          gr($r.month, n),
          o
        );
      case "LL":
        return Lr(Ar(2, n), o);
      case "Lo":
        return Lr(
          s.ordinalNumber(n, {
            unit: "month"
          }),
          o
        );
      case "LLL":
        return s.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.month(n, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return s.month(n, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return s.month(n, { width: "wide", context: "standalone" }) || s.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.month(n, { width: "narrow", context: "standalone" });
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 11;
  }
  set(n, r, s) {
    return n.setMonth(s, 1), n.setHours(0, 0, 0, 0), n;
  }
}
function dMe(t, e, n) {
  const r = qe(t), s = ZL(r, n) - e;
  return r.setDate(r.getDate() - s * 7), r;
}
class uMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 100);
    P(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(n, r, s) {
    switch (r) {
      case "w":
        return gr($r.week, n);
      case "wo":
        return s.ordinalNumber(n, { unit: "week" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 53;
  }
  set(n, r, s, o) {
    return Wi(dMe(n, s, o), o);
  }
}
function fMe(t, e) {
  const n = qe(t), r = qL(n) - e;
  return n.setDate(n.getDate() - r * 7), n;
}
class hMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 100);
    P(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, r, s) {
    switch (r) {
      case "I":
        return gr($r.week, n);
      case "Io":
        return s.ordinalNumber(n, { unit: "week" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 53;
  }
  set(n, r, s) {
    return ru(fMe(n, s));
  }
}
const pMe = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], gMe = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class mMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 90);
    P(this, "subPriority", 1);
    P(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, r, s) {
    switch (r) {
      case "d":
        return gr($r.date, n);
      case "do":
        return s.ordinalNumber(n, { unit: "date" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    const s = n.getFullYear(), o = pJ(s), i = n.getMonth();
    return o ? r >= 1 && r <= gMe[i] : r >= 1 && r <= pMe[i];
  }
  set(n, r, s) {
    return n.setDate(s), n.setHours(0, 0, 0, 0), n;
  }
}
class yMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 90);
    P(this, "subpriority", 1);
    P(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, r, s) {
    switch (r) {
      case "D":
      case "DD":
        return gr($r.dayOfYear, n);
      case "Do":
        return s.ordinalNumber(n, { unit: "date" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    const s = n.getFullYear();
    return pJ(s) ? r >= 1 && r <= 366 : r >= 1 && r <= 365;
  }
  set(n, r, s) {
    return n.setMonth(0, s), n.setHours(0, 0, 0, 0), n;
  }
}
function JL(t, e, n) {
  var u, f, p, g;
  const r = qf(), s = (n == null ? void 0 : n.weekStartsOn) ?? ((f = (u = n == null ? void 0 : n.locale) == null ? void 0 : u.options) == null ? void 0 : f.weekStartsOn) ?? r.weekStartsOn ?? ((g = (p = r.locale) == null ? void 0 : p.options) == null ? void 0 : g.weekStartsOn) ?? 0, o = qe(t), i = o.getDay(), c = (e % 7 + 7) % 7, l = 7 - s, d = e < 0 || e > 6 ? e - (i + l) % 7 : (c + l) % 7 - (i + l) % 7;
  return Xs(o, d);
}
class vMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 90);
    P(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "E":
      case "EE":
      case "EEE":
        return s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, { width: "short", context: "formatting" }) || s.day(n, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return s.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return s.day(n, { width: "short", context: "formatting" }) || s.day(n, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return s.day(n, { width: "wide", context: "formatting" }) || s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, { width: "short", context: "formatting" }) || s.day(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 6;
  }
  set(n, r, s, o) {
    return n = JL(n, s, o), n.setHours(0, 0, 0, 0), n;
  }
}
class bMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 90);
    P(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, r, s, o) {
    const i = (a) => {
      const c = Math.floor((a - 1) / 7) * 7;
      return (a + o.weekStartsOn + 6) % 7 + c;
    };
    switch (r) {
      case "e":
      case "ee":
        return Lr(Ar(r.length, n), i);
      case "eo":
        return Lr(
          s.ordinalNumber(n, {
            unit: "day"
          }),
          i
        );
      case "eee":
        return s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, { width: "short", context: "formatting" }) || s.day(n, { width: "narrow", context: "formatting" });
      case "eeeee":
        return s.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return s.day(n, { width: "short", context: "formatting" }) || s.day(n, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return s.day(n, { width: "wide", context: "formatting" }) || s.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.day(n, { width: "short", context: "formatting" }) || s.day(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 6;
  }
  set(n, r, s, o) {
    return n = JL(n, s, o), n.setHours(0, 0, 0, 0), n;
  }
}
class xMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 90);
    P(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(n, r, s, o) {
    const i = (a) => {
      const c = Math.floor((a - 1) / 7) * 7;
      return (a + o.weekStartsOn + 6) % 7 + c;
    };
    switch (r) {
      case "c":
      case "cc":
        return Lr(Ar(r.length, n), i);
      case "co":
        return Lr(
          s.ordinalNumber(n, {
            unit: "day"
          }),
          i
        );
      case "ccc":
        return s.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.day(n, { width: "short", context: "standalone" }) || s.day(n, { width: "narrow", context: "standalone" });
      case "ccccc":
        return s.day(n, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return s.day(n, { width: "short", context: "standalone" }) || s.day(n, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return s.day(n, { width: "wide", context: "standalone" }) || s.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || s.day(n, { width: "short", context: "standalone" }) || s.day(n, { width: "narrow", context: "standalone" });
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 6;
  }
  set(n, r, s, o) {
    return n = JL(n, s, o), n.setHours(0, 0, 0, 0), n;
  }
}
function wMe(t, e) {
  const n = qe(t), r = GAe(n), s = e - r;
  return Xs(n, s);
}
class SMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 90);
    P(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, r, s) {
    const o = (i) => i === 0 ? 7 : i;
    switch (r) {
      case "i":
      case "ii":
        return Ar(r.length, n);
      case "io":
        return s.ordinalNumber(n, { unit: "day" });
      case "iii":
        return Lr(
          s.day(n, {
            width: "abbreviated",
            context: "formatting"
          }) || s.day(n, {
            width: "short",
            context: "formatting"
          }) || s.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
      case "iiiii":
        return Lr(
          s.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
      case "iiiiii":
        return Lr(
          s.day(n, {
            width: "short",
            context: "formatting"
          }) || s.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
      case "iiii":
      default:
        return Lr(
          s.day(n, {
            width: "wide",
            context: "formatting"
          }) || s.day(n, {
            width: "abbreviated",
            context: "formatting"
          }) || s.day(n, {
            width: "short",
            context: "formatting"
          }) || s.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          o
        );
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 7;
  }
  set(n, r, s) {
    return n = wMe(n, s), n.setHours(0, 0, 0, 0), n;
  }
}
class CMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 80);
    P(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "a":
      case "aa":
      case "aaa":
        return s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return s.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, r, s) {
    return n.setHours(QL(s), 0, 0, 0), n;
  }
}
class _Me extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 80);
    P(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "b":
      case "bb":
      case "bbb":
        return s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return s.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, r, s) {
    return n.setHours(QL(s), 0, 0, 0), n;
  }
}
class EMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 80);
    P(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "B":
      case "BB":
      case "BBB":
        return s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return s.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || s.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, r, s) {
    return n.setHours(QL(s), 0, 0, 0), n;
  }
}
class TMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 70);
    P(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "h":
        return gr($r.hour12h, n);
      case "ho":
        return s.ordinalNumber(n, { unit: "hour" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 12;
  }
  set(n, r, s) {
    const o = n.getHours() >= 12;
    return o && s < 12 ? n.setHours(s + 12, 0, 0, 0) : !o && s === 12 ? n.setHours(0, 0, 0, 0) : n.setHours(s, 0, 0, 0), n;
  }
}
class PMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 70);
    P(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "H":
        return gr($r.hour23h, n);
      case "Ho":
        return s.ordinalNumber(n, { unit: "hour" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 23;
  }
  set(n, r, s) {
    return n.setHours(s, 0, 0, 0), n;
  }
}
class IMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 70);
    P(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "K":
        return gr($r.hour11h, n);
      case "Ko":
        return s.ordinalNumber(n, { unit: "hour" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 11;
  }
  set(n, r, s) {
    return n.getHours() >= 12 && s < 12 ? n.setHours(s + 12, 0, 0, 0) : n.setHours(s, 0, 0, 0), n;
  }
}
class kMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 70);
    P(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "k":
        return gr($r.hour24h, n);
      case "ko":
        return s.ordinalNumber(n, { unit: "hour" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    return r >= 1 && r <= 24;
  }
  set(n, r, s) {
    const o = s <= 24 ? s % 24 : s;
    return n.setHours(o, 0, 0, 0), n;
  }
}
class AMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 60);
    P(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "m":
        return gr($r.minute, n);
      case "mo":
        return s.ordinalNumber(n, { unit: "minute" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 59;
  }
  set(n, r, s) {
    return n.setMinutes(s, 0, 0), n;
  }
}
class MMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 50);
    P(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, r, s) {
    switch (r) {
      case "s":
        return gr($r.second, n);
      case "so":
        return s.ordinalNumber(n, { unit: "second" });
      default:
        return Ar(r.length, n);
    }
  }
  validate(n, r) {
    return r >= 0 && r <= 59;
  }
  set(n, r, s) {
    return n.setSeconds(s, 0), n;
  }
}
class OMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 30);
    P(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, r) {
    const s = (o) => Math.trunc(o * Math.pow(10, -r.length + 3));
    return Lr(Ar(r.length, n), s);
  }
  set(n, r, s) {
    return n.setMilliseconds(s), n;
  }
}
class DMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 10);
    P(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(n, r) {
    switch (r) {
      case "X":
        return Dl(
          Ol.basicOptionalMinutes,
          n
        );
      case "XX":
        return Dl(Ol.basic, n);
      case "XXXX":
        return Dl(
          Ol.basicOptionalSeconds,
          n
        );
      case "XXXXX":
        return Dl(
          Ol.extendedOptionalSeconds,
          n
        );
      case "XXX":
      default:
        return Dl(Ol.extended, n);
    }
  }
  set(n, r, s) {
    return r.timestampIsSet ? n : On(
      n,
      n.getTime() - Df(n) - s
    );
  }
}
class NMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 10);
    P(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(n, r) {
    switch (r) {
      case "x":
        return Dl(
          Ol.basicOptionalMinutes,
          n
        );
      case "xx":
        return Dl(Ol.basic, n);
      case "xxxx":
        return Dl(
          Ol.basicOptionalSeconds,
          n
        );
      case "xxxxx":
        return Dl(
          Ol.extendedOptionalSeconds,
          n
        );
      case "xxx":
      default:
        return Dl(Ol.extended, n);
    }
  }
  set(n, r, s) {
    return r.timestampIsSet ? n : On(
      n,
      n.getTime() - Df(n) - s
    );
  }
}
class jMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 40);
    P(this, "incompatibleTokens", "*");
  }
  parse(n) {
    return fJ(n);
  }
  set(n, r, s) {
    return [On(n, s * 1e3), { timestampIsSet: !0 }];
  }
}
class RMe extends xn {
  constructor() {
    super(...arguments);
    P(this, "priority", 20);
    P(this, "incompatibleTokens", "*");
  }
  parse(n) {
    return fJ(n);
  }
  set(n, r, s) {
    return [On(n, s), { timestampIsSet: !0 }];
  }
}
const $Me = {
  G: new tMe(),
  y: new nMe(),
  Y: new rMe(),
  R: new sMe(),
  u: new oMe(),
  Q: new iMe(),
  q: new aMe(),
  M: new cMe(),
  L: new lMe(),
  w: new uMe(),
  I: new hMe(),
  d: new mMe(),
  D: new yMe(),
  E: new vMe(),
  e: new bMe(),
  c: new xMe(),
  i: new SMe(),
  a: new CMe(),
  b: new _Me(),
  B: new EMe(),
  h: new TMe(),
  H: new PMe(),
  K: new IMe(),
  k: new kMe(),
  m: new AMe(),
  s: new MMe(),
  S: new OMe(),
  X: new DMe(),
  x: new NMe(),
  t: new jMe(),
  T: new RMe()
}, LMe = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, FMe = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, BMe = /^'([^]*?)'?$/, zMe = /''/g, UMe = /\S/, HMe = /[a-zA-Z]/;
function VMe(t, e, n, r) {
  var y, m, v, b, x, w, S, C;
  const s = KAe(), o = (r == null ? void 0 : r.locale) ?? s.locale ?? F0, i = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((m = (y = r == null ? void 0 : r.locale) == null ? void 0 : y.options) == null ? void 0 : m.firstWeekContainsDate) ?? s.firstWeekContainsDate ?? ((b = (v = s.locale) == null ? void 0 : v.options) == null ? void 0 : b.firstWeekContainsDate) ?? 1, a = (r == null ? void 0 : r.weekStartsOn) ?? ((w = (x = r == null ? void 0 : r.locale) == null ? void 0 : x.options) == null ? void 0 : w.weekStartsOn) ?? s.weekStartsOn ?? ((C = (S = s.locale) == null ? void 0 : S.options) == null ? void 0 : C.weekStartsOn) ?? 0;
  if (e === "")
    return t === "" ? qe(n) : On(n, NaN);
  const c = {
    firstWeekContainsDate: i,
    weekStartsOn: a,
    locale: o
  }, l = [new eMe()], d = e.match(FMe).map((_) => {
    const E = _[0];
    if (E in AN) {
      const M = AN[E];
      return M(_, o.formatLong);
    }
    return _;
  }).join("").match(LMe), u = [];
  for (let _ of d) {
    !(r != null && r.useAdditionalWeekYearTokens) && lJ(_) && MN(_, e, t), !(r != null && r.useAdditionalDayOfYearTokens) && cJ(_) && MN(_, e, t);
    const E = _[0], M = $Me[E];
    if (M) {
      const { incompatibleTokens: N } = M;
      if (Array.isArray(N)) {
        const D = u.find(
          (k) => N.includes(k.token) || k.token === E
        );
        if (D)
          throw new RangeError(
            `The format string mustn't contain \`${D.fullToken}\` and \`${_}\` at the same time`
          );
      } else if (M.incompatibleTokens === "*" && u.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${_}\` and any other token at the same time`
        );
      u.push({ token: E, fullToken: _ });
      const O = M.run(
        t,
        _,
        o.match,
        c
      );
      if (!O)
        return On(n, NaN);
      l.push(O.setter), t = O.rest;
    } else {
      if (E.match(HMe))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + E + "`"
        );
      if (_ === "''" ? _ = "'" : E === "'" && (_ = WMe(_)), t.indexOf(_) === 0)
        t = t.slice(_.length);
      else
        return On(n, NaN);
    }
  }
  if (t.length > 0 && UMe.test(t))
    return On(n, NaN);
  const f = l.map((_) => _.priority).sort((_, E) => E - _).filter((_, E, M) => M.indexOf(_) === E).map(
    (_) => l.filter((E) => E.priority === _).sort((E, M) => M.subPriority - E.subPriority)
  ).map((_) => _[0]);
  let p = qe(n);
  if (isNaN(p.getTime()))
    return On(n, NaN);
  const g = {};
  for (const _ of f) {
    if (!_.validate(p, c))
      return On(n, NaN);
    const E = _.set(p, g, c);
    Array.isArray(E) ? (p = E[0], Object.assign(g, E[1])) : p = E;
  }
  return On(n, p);
}
function WMe(t) {
  return t.match(BMe)[1].replace(zMe, "'");
}
function eF(t, e) {
  const n = qe(t), r = qe(e);
  return n.getFullYear() === r.getFullYear() && n.getMonth() === r.getMonth();
}
function KMe(t, e) {
  const n = qe(t), r = qe(e);
  return n.getFullYear() === r.getFullYear();
}
function pU(t) {
  return Ao(t, oJ(t));
}
function hM(t, e) {
  return Xs(t, -e);
}
function pM(t, e) {
  const n = qe(t), r = n.getFullYear(), s = n.getDate(), o = On(t, 0);
  o.setFullYear(r, e, 15), o.setHours(0, 0, 0, 0);
  const i = WAe(o);
  return n.setMonth(e, Math.min(s, i)), n;
}
function GMe(t, e) {
  const n = qe(t);
  return n.setHours(e), n;
}
function YMe(t, e) {
  const n = qe(t);
  return n.setMinutes(e), n;
}
function gU(t, e) {
  const n = qe(t);
  return isNaN(+n) ? On(t, NaN) : (n.setFullYear(e), n);
}
function qMe(t, e) {
  return Ca(t, -e);
}
function XMe(t, e) {
  return WL(t, -e);
}
function ZMe({ artifact: t }) {
  const e = t.data;
  if (t.type === "canvas")
    return /* @__PURE__ */ h.jsx("div", { className: "w-full h-full bg-gradient-to-br from-muted/50 to-muted flex items-center justify-center", children: /* @__PURE__ */ h.jsx(Hq, { className: "h-12 w-12 text-muted-foreground/30" }) });
  if (t.type === "diagram") {
    const n = (e == null ? void 0 : e.nodes) || [], r = (e == null ? void 0 : e.edges) || [];
    return /* @__PURE__ */ h.jsxs("div", { className: "w-full h-full bg-gradient-to-br from-muted/50 to-muted flex flex-col items-center justify-center gap-2", children: [
      /* @__PURE__ */ h.jsx(C0, { className: "h-10 w-10 text-muted-foreground/30" }),
      (n.length > 0 || r.length > 0) && /* @__PURE__ */ h.jsxs("span", { className: "text-xs text-muted-foreground", children: [
        n.length,
        " nodes  ",
        r.length,
        " edges"
      ] })
    ] });
  }
  if (t.type === "board") {
    const n = (e == null ? void 0 : e.columns) || [], r = (e == null ? void 0 : e.tasks) || {}, s = Object.keys(r).length;
    return /* @__PURE__ */ h.jsxs("div", { className: "w-full h-full bg-gradient-to-br from-muted/50 to-muted flex flex-col items-center justify-center gap-2", children: [
      /* @__PURE__ */ h.jsx(Fq, { className: "h-10 w-10 text-muted-foreground/30" }),
      (n.length > 0 || s > 0) && /* @__PURE__ */ h.jsxs("span", { className: "text-xs text-muted-foreground", children: [
        n.length,
        " columns  ",
        s,
        " tasks"
      ] })
    ] });
  }
  if (t.type === "notes") {
    const n = e;
    let r = "";
    if (Array.isArray(n))
      for (const s of n) {
        if (s.content && Array.isArray(s.content)) {
          for (const o of s.content)
            if (o.text && (r += o.text + " ", r.length > 150))
              break;
        }
        if (r.length > 150) break;
      }
    return r.trim() ? /* @__PURE__ */ h.jsx("div", { className: "w-full h-full bg-gradient-to-br from-muted/50 to-muted p-4 overflow-hidden", children: /* @__PURE__ */ h.jsx("p", { className: "text-xs text-muted-foreground line-clamp-6 leading-relaxed", children: r.trim() }) }) : /* @__PURE__ */ h.jsx("div", { className: "w-full h-full bg-gradient-to-br from-muted/50 to-muted flex items-center justify-center", children: /* @__PURE__ */ h.jsx(yp, { className: "h-10 w-10 text-muted-foreground/30" }) });
  }
  return /* @__PURE__ */ h.jsx("div", { className: "w-full h-full bg-muted flex items-center justify-center", children: /* @__PURE__ */ h.jsx("div", { className: "h-8 w-8 rounded bg-muted-foreground/10" }) });
}
function QMe(t) {
  const e = t.data;
  if (t.type === "notes") {
    const n = e;
    return Array.isArray(n) && n.length > 3 ? "h-48" : "h-36";
  }
  if (t.type === "diagram")
    return ((e == null ? void 0 : e.nodes) || []).length > 5 ? "h-44" : "h-36";
  if (t.type === "board") {
    const n = (e == null ? void 0 : e.tasks) || {};
    return Object.keys(n).length > 5 ? "h-44" : "h-36";
  }
  return "h-40";
}
function tF({ artifact: t, onDelete: e, onToggleFavorite: n, onTogglePinned: r }) {
  const s = rd(), o = sI(), { toast: i } = j$(), a = er[t.type], c = a.icon, l = QMe(t), d = () => {
    s(`/${t.type}/${t.id}`);
  }, u = async (m) => {
    m.stopPropagation();
    const v = `${window.location.origin}${o}/${t.type}/${t.id}`;
    try {
      await navigator.clipboard.writeText(v), i({
        title: "Link copied!",
        description: `Share this link to show your ${a.typeLabel}.`
      });
    } catch {
      i({
        title: "Failed to copy",
        variant: "destructive"
      });
    }
  }, f = (m) => {
    m.stopPropagation(), n == null || n(t.id);
  }, p = (m) => {
    m.stopPropagation(), r == null || r(t.id);
  }, g = (m) => {
    m.stopPropagation(), e(t.id);
  }, y = (m, v) => {
    m.stopPropagation(), s(`/tag/${encodeURIComponent(v)}`);
  };
  return /* @__PURE__ */ h.jsxs(
    uI,
    {
      className: "group cursor-pointer transition-all hover:shadow-lg hover:border-primary/50 overflow-hidden",
      onClick: d,
      children: [
        /* @__PURE__ */ h.jsxs("div", { className: `relative ${l} overflow-hidden`, children: [
          /* @__PURE__ */ h.jsx(ZMe, { artifact: t }),
          /* @__PURE__ */ h.jsxs("div", { className: "absolute inset-0 bg-background/80 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-2", children: [
            r && /* @__PURE__ */ h.jsx(
              _t,
              {
                variant: "secondary",
                size: "icon",
                className: "h-9 w-9",
                onClick: p,
                children: /* @__PURE__ */ h.jsx(kz, { className: `h-4 w-4 ${t.pinned ? "text-foreground" : "text-muted-foreground"}` })
              }
            ),
            n && /* @__PURE__ */ h.jsx(
              _t,
              {
                variant: "secondary",
                size: "icon",
                className: "h-9 w-9",
                onClick: f,
                children: /* @__PURE__ */ h.jsx(yf, { className: `h-4 w-4 ${t.favorite ? "text-yellow-500 fill-yellow-500" : ""}` })
              }
            ),
            /* @__PURE__ */ h.jsx(
              _t,
              {
                variant: "secondary",
                size: "icon",
                className: "h-9 w-9",
                onClick: u,
                children: /* @__PURE__ */ h.jsx(Gq, { className: "h-4 w-4" })
              }
            ),
            /* @__PURE__ */ h.jsx(
              _t,
              {
                variant: "secondary",
                size: "icon",
                className: "h-9 w-9 text-destructive hover:text-destructive",
                onClick: g,
                children: /* @__PURE__ */ h.jsx(Ky, { className: "h-4 w-4" })
              }
            )
          ] }),
          t.favorite && /* @__PURE__ */ h.jsx("div", { className: "absolute top-2 right-2", children: /* @__PURE__ */ h.jsx(yf, { className: "h-4 w-4 text-primary fill-primary drop-shadow" }) }),
          t.pinned && /* @__PURE__ */ h.jsx("div", { className: "absolute top-2 left-2", children: /* @__PURE__ */ h.jsx(kz, { className: "h-4 w-4 text-foreground drop-shadow" }) })
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "p-3", children: [
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 min-w-0", children: [
            /* @__PURE__ */ h.jsx("div", { className: "flex-shrink-0 p-1.5 rounded bg-muted", children: /* @__PURE__ */ h.jsx(c, { className: "h-3.5 w-3.5 text-muted-foreground" }) }),
            /* @__PURE__ */ h.jsxs("div", { className: "min-w-0 flex-1", children: [
              /* @__PURE__ */ h.jsx("h3", { className: "font-medium text-sm text-foreground truncate", children: t.name }),
              /* @__PURE__ */ h.jsx("p", { className: "text-xs text-muted-foreground", children: HAe(new Date(t.updatedAt), { addSuffix: !0 }) })
            ] })
          ] }),
          t.tags && t.tags.length > 0 && /* @__PURE__ */ h.jsxs("div", { className: "flex flex-wrap gap-1 mt-2", children: [
            t.tags.slice(0, 3).map((m) => /* @__PURE__ */ h.jsx(
              cE,
              {
                variant: "secondary",
                className: "text-[10px] px-1.5 py-0 cursor-pointer hover:bg-accent",
                onClick: (v) => y(v, m),
                children: m
              },
              m
            )),
            t.tags.length > 3 && /* @__PURE__ */ h.jsxs(cE, { variant: "outline", className: "text-[10px] px-1.5 py-0", children: [
              "+",
              t.tags.length - 3
            ] })
          ] })
        ] })
      ]
    }
  );
}
function JMe(t) {
  const [e, n] = he([]), [r, s] = he(!0), [o, i] = he(null), a = nu(), c = re(async () => {
    s(!0);
    try {
      const f = await a.listArtifacts(t);
      n(bf(f));
    } catch (f) {
      i(f instanceof Error ? f.message : "Failed to load");
    } finally {
      s(!1);
    }
  }, [a, t]), l = re(async (f) => {
    await a.deleteArtifact(f), n((p) => p.filter((g) => g.id !== f));
  }, [a]), d = re(async (f) => {
    const p = e.find((g) => g.id === f);
    if (p) {
      const g = {
        ...p,
        favorite: !p.favorite,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        schemaVersion: p.schemaVersion ?? ss
      };
      await a.saveArtifact(g), n((y) => bf(y.map((m) => m.id === f ? g : m)));
    }
  }, [e, a]), u = re(async (f) => {
    const p = e.find((g) => g.id === f);
    if (p) {
      const g = {
        ...p,
        pinned: !p.pinned,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        schemaVersion: p.schemaVersion ?? ss
      };
      await a.saveArtifact(g), n((y) => bf(y.map((m) => m.id === f ? g : m)));
    }
  }, [e, a]);
  return me(() => {
    c();
  }, [c]), { artifacts: e, loading: r, error: o, refresh: c, deleteArtifact: l, toggleFavorite: d, togglePinned: u };
}
function nF({
  type: t,
  newPath: e,
  emptyTitle: n,
  emptyDescription: r,
  newButtonLabel: s
}) {
  const o = rd(), { artifacts: i, loading: a, deleteArtifact: c, toggleFavorite: l, togglePinned: d } = JMe(t);
  return a ? /* @__PURE__ */ h.jsx("div", { className: "flex items-center justify-center h-full", children: /* @__PURE__ */ h.jsx(Wy, { className: "h-8 w-8 animate-spin text-muted-foreground" }) }) : /* @__PURE__ */ h.jsxs("div", { className: "p-6", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
      /* @__PURE__ */ h.jsx("div", { children: /* @__PURE__ */ h.jsxs("p", { className: "text-sm text-muted-foreground", children: [
        i.length,
        " ",
        i.length === 1 ? "item" : "items"
      ] }) }),
      /* @__PURE__ */ h.jsxs(_t, { onClick: () => o(e), className: "gap-2", children: [
        /* @__PURE__ */ h.jsx(Jc, { className: "h-4 w-4" }),
        s
      ] })
    ] }),
    i.length === 0 ? /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col items-center justify-center py-16 text-center", children: [
      /* @__PURE__ */ h.jsx("h3", { className: "text-lg font-medium text-foreground mb-1", children: n }),
      /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground mb-4 max-w-sm", children: r }),
      /* @__PURE__ */ h.jsxs(_t, { onClick: () => o(e), className: "gap-2", children: [
        /* @__PURE__ */ h.jsx(Jc, { className: "h-4 w-4" }),
        s
      ] })
    ] }) : /* @__PURE__ */ h.jsx("div", { className: "columns-1 sm:columns-2 lg:columns-3 xl:columns-4 gap-4 space-y-4", children: i.map((u) => /* @__PURE__ */ h.jsx("div", { className: "break-inside-avoid", children: /* @__PURE__ */ h.jsx(
      tF,
      {
        artifact: u,
        onDelete: c,
        onToggleFavorite: l,
        onTogglePinned: d
      }
    ) }, u.id)) })
  ] });
}
const f1 = er.canvas;
function eOe() {
  return /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(zl, { title: f1.title, icon: f1.icon }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 overflow-auto", children: /* @__PURE__ */ h.jsx(
      nF,
      {
        type: "canvas",
        newPath: "/canvas/new",
        emptyTitle: `No ${f1.typeLabel}s yet`,
        emptyDescription: "Create your first drawing, whiteboard, or sketch",
        newButtonLabel: `New ${f1.title}`
      }
    ) })
  ] });
}
function tOe({ artifact: t }) {
  if (!t) return null;
  const e = {
    llm: {
      instructions: "This JSON block is for LLM context. Use it for high-level understanding. If you need full data, ask the user to export.",
      version: 1
    },
    artifact: {
      id: t.id,
      type: t.type,
      name: t.name,
      createdAt: t.createdAt,
      updatedAt: t.updatedAt,
      favorite: t.favorite,
      schemaVersion: t.schemaVersion
    },
    summary: t.llmSummary ?? null
  };
  return /* @__PURE__ */ h.jsx(
    "script",
    {
      id: "blueprint-llm",
      type: "application/json",
      dangerouslySetInnerHTML: { __html: JSON.stringify(e) }
    }
  );
}
const mU = /\[\[([^\]]+)\]\]/g;
function gJ(t) {
  const e = [];
  let n;
  for (; (n = mU.exec(t)) !== null; )
    e.push(n[1].trim());
  return mU.lastIndex = 0, [...new Set(e)];
}
function nOe(t) {
  if (!Array.isArray(t)) return "";
  const e = [];
  function n(r) {
    if (!r || typeof r != "object") return;
    const s = r;
    if (Array.isArray(s.content)) {
      for (const o of s.content)
        if (typeof o == "object" && o !== null) {
          const i = o;
          typeof i.text == "string" && e.push(i.text);
        }
    }
    if (Array.isArray(s.children))
      for (const o of s.children)
        n(o);
  }
  for (const r of t)
    n(r);
  return e.join(" ");
}
function rOe(t) {
  if (!t || typeof t != "object") return "";
  const e = t, n = [];
  if (Array.isArray(e.nodes)) {
    for (const r of e.nodes)
      if (typeof r == "object" && r !== null) {
        const s = r;
        if (s.data && typeof s.data == "object") {
          const o = s.data;
          typeof o.label == "string" && n.push(o.label);
        }
      }
  }
  return n.join(" ");
}
function sOe(t) {
  if (!t || typeof t != "object") return "";
  const e = t, n = [];
  if (Array.isArray(e.columns)) {
    for (const r of e.columns)
      if (typeof r == "object" && r !== null) {
        const s = r;
        if (typeof s.title == "string" && n.push(s.title), Array.isArray(s.cards)) {
          for (const o of s.cards)
            if (typeof o == "object" && o !== null) {
              const i = o;
              typeof i.title == "string" && n.push(i.title), typeof i.description == "string" && n.push(i.description);
            }
        }
      }
  }
  return n.join(" ");
}
function mJ(t) {
  const e = [t.name];
  switch (t.type) {
    case "notes":
      e.push(nOe(t.data));
      break;
    case "diagram":
      e.push(rOe(t.data));
      break;
    case "board":
      e.push(sOe(t.data));
      break;
  }
  return e.join(" ");
}
function yJ(t, e) {
  const n = mJ(t), r = gJ(n);
  return e.filter(
    (s) => s.id !== t.id && r.some((o) => s.name.toLowerCase() === o.toLowerCase())
  );
}
function oOe(t, e) {
  return e.filter((n) => {
    if (n.id === t.id) return !1;
    const r = mJ(n);
    return gJ(r).some((o) => t.name.toLowerCase() === o.toLowerCase());
  });
}
function iOe(t) {
  const e = t.map((r) => ({
    id: r.id,
    name: r.name,
    type: r.type
  })), n = [];
  for (const r of t) {
    const s = yJ(r, t);
    for (const o of s)
      n.push({
        source: r.id,
        target: o.id
      });
  }
  return { nodes: e, edges: n };
}
function aOe(t) {
  const { artifacts: e } = uu();
  return Ke(() => {
    if (!t)
      return { outgoingLinks: [], backlinks: [], artifact: null };
    const n = e.find((r) => r.id === t);
    return n ? {
      outgoingLinks: yJ(n, e),
      backlinks: oOe(n, e),
      artifact: n
    } : { outgoingLinks: [], backlinks: [], artifact: null };
  }, [t, e]);
}
function cOe() {
  const { artifacts: t, loading: e } = uu();
  return { ...Ke(() => iOe(t), [t]), loading: e };
}
function lOe({ artifactId: t }) {
  const { outgoingLinks: e, backlinks: n } = aOe(t), [r, s] = he(!0), o = e.length + n.length;
  return o === 0 ? null : /* @__PURE__ */ h.jsxs(kQ, { open: r, onOpenChange: s, className: "border-t border-border", children: [
    /* @__PURE__ */ h.jsx(AQ, { asChild: !0, children: /* @__PURE__ */ h.jsx(
      _t,
      {
        variant: "ghost",
        className: "w-full justify-between px-4 py-2 h-auto rounded-none",
        children: /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 text-sm", children: [
          /* @__PURE__ */ h.jsx(AD, { className: "h-4 w-4" }),
          /* @__PURE__ */ h.jsx("span", { children: "Links" }),
          /* @__PURE__ */ h.jsxs("span", { className: "text-muted-foreground", children: [
            "(",
            o,
            ")"
          ] })
        ] })
      }
    ) }),
    /* @__PURE__ */ h.jsxs(MQ, { className: "px-4 pb-3 space-y-3", children: [
      e.length > 0 && /* @__PURE__ */ h.jsxs("div", { className: "space-y-1.5", children: [
        /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-1.5 text-xs font-medium text-muted-foreground", children: [
          /* @__PURE__ */ h.jsx(Yxe, { className: "h-3 w-3" }),
          /* @__PURE__ */ h.jsxs("span", { children: [
            "Links to (",
            e.length,
            ")"
          ] })
        ] }),
        /* @__PURE__ */ h.jsx("div", { className: "space-y-1", children: e.map((i) => {
          const a = er[i.type], c = a.icon;
          return /* @__PURE__ */ h.jsxs(
            vz,
            {
              to: `${a.path}/${i.id}`,
              className: "flex items-center gap-2 text-sm p-1.5 rounded hover:bg-muted transition-colors",
              children: [
                /* @__PURE__ */ h.jsx(c, { className: "h-3.5 w-3.5 text-muted-foreground" }),
                /* @__PURE__ */ h.jsx("span", { className: "flex-1 truncate", children: i.name })
              ]
            },
            i.id
          );
        }) })
      ] }),
      n.length > 0 && /* @__PURE__ */ h.jsxs("div", { className: "space-y-1.5", children: [
        /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-1.5 text-xs font-medium text-muted-foreground", children: [
          /* @__PURE__ */ h.jsx(Gxe, { className: "h-3 w-3" }),
          /* @__PURE__ */ h.jsxs("span", { children: [
            "Linked from (",
            n.length,
            ")"
          ] })
        ] }),
        /* @__PURE__ */ h.jsx("div", { className: "space-y-1", children: n.map((i) => {
          const a = er[i.type], c = a.icon;
          return /* @__PURE__ */ h.jsxs(
            vz,
            {
              to: `${a.path}/${i.id}`,
              className: "flex items-center gap-2 text-sm p-1.5 rounded hover:bg-muted transition-colors",
              children: [
                /* @__PURE__ */ h.jsx(c, { className: "h-3.5 w-3.5 text-muted-foreground" }),
                /* @__PURE__ */ h.jsx("span", { className: "flex-1 truncate", children: i.name }),
                /* @__PURE__ */ h.jsx("span", { className: "text-xs text-muted-foreground", children: Qx(i.updatedAt) })
              ]
            },
            i.id
          );
        }) })
      ] })
    ] })
  ] });
}
function rF({
  title: t,
  icon: e,
  artifact: n,
  loading: r,
  error: s,
  saving: o,
  onRename: i,
  onToggleFavorite: a,
  onUpdateTags: c,
  headerActions: l,
  children: d
}) {
  return r ? /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(zl, { title: t, icon: e }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ h.jsx(Wy, { className: "h-8 w-8 animate-spin text-muted-foreground" }) })
  ] }) : s || !n ? /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(zl, { title: t, icon: e }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ h.jsx("p", { className: "text-destructive", children: s || "Failed to load" }) })
  ] }) : /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(
      zl,
      {
        title: t,
        icon: e,
        artifactId: n.id,
        artifactName: n.name,
        artifactType: n.type,
        artifactFavorite: n.favorite,
        artifactTags: n.tags,
        saving: o,
        onRename: i,
        onToggleFavorite: a,
        onUpdateTags: c,
        headerActions: l
      }
    ),
    /* @__PURE__ */ h.jsx(tOe, { artifact: n }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 overflow-hidden", children: d }),
    /* @__PURE__ */ h.jsx(lOe, { artifactId: n.id })
  ] });
}
const gM = "__TLDRAW_LIBRARY_VERSIONS__";
function dOe() {
  if (globalThis[gM])
    return globalThis[gM];
  const t = {
    versions: [],
    didWarn: !1,
    scheduledNotice: null
  };
  return Object.defineProperty(globalThis, gM, {
    value: t,
    writable: !1,
    configurable: !1,
    enumerable: !1
  }), t;
}
function Xf(t, e, n) {
  if (!t || !e || !n)
    throw new Error("Missing name/version/module system in built version of tldraw library");
  const r = dOe();
  if (r.versions.push({ name: t, version: e, modules: n }), !r.scheduledNotice)
    try {
      r.scheduledNotice = setTimeout(() => {
        r.scheduledNotice = null, yU(r);
      }, 100);
    } catch {
      yU(r);
    }
}
function yU(t) {
  if (!t.versions.length || t.didWarn) return;
  const e = t.versions.sort((a, c) => vU(a.version, c.version)), n = e[e.length - 1].version, r = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Map();
  for (const a of e) {
    if (s.has(a.name)) {
      r.delete(a.name), mM(s, a.name, /* @__PURE__ */ new Set()).add(a.version);
      continue;
    }
    a.version === n ? r.add(a.name) : (r.delete(a.name), mM(s, a.name, /* @__PURE__ */ new Set()).add(a.version));
  }
  if (s.size > 0) {
    const a = [
      `${vd("[tldraw]", ["bold", "bgRed", "textWhite"])} ${vd("You have multiple versions of tldraw libraries installed. This can lead to bugs and unexpected behavior.", ["textRed", "bold"])}`,
      "",
      `The latest version you have installed is ${vd(`v${n}`, ["bold", "textBlue"])}. The following libraries are on the latest version:`,
      ...Array.from(r, (c) => `    ${vd(c, ["bold"])}`),
      "",
      "The following libraries are not on the latest version, or have multiple versions installed:",
      ...Array.from(s, ([c, l]) => {
        const d = Array.from(l).sort(vU).map((u) => vd(`v${u}`, u === n ? ["textGreen"] : ["textRed"]));
        return `    ${vd(c, ["bold"])} (${d.join(", ")})`;
      })
    ];
    console.log(a.join(`
`)), t.didWarn = !0;
    return;
  }
  const o = /* @__PURE__ */ new Map();
  for (const a of e)
    mM(o, a.name, { version: a.version, modules: [] }).modules.push(
      a.modules
    );
  const i = /* @__PURE__ */ new Map();
  for (const [a, c] of o)
    c.modules.length > 1 && i.set(a, c);
  if (i.size > 0) {
    const a = [
      `${vd("[tldraw]", ["bold", "bgRed", "textWhite"])} ${vd("You have multiple instances of some tldraw libraries active. This can lead to bugs and unexpected behavior. ", ["textRed", "bold"])}`,
      "",
      "This usually means that your bundler is misconfigured, and is importing the same library multiple times - usually once as an ES Module, and once as a CommonJS module.",
      "",
      "The following libraries have been imported multiple times:",
      ...Array.from(i, ([c, l]) => {
        const d = l.modules.map((u, f) => u === "esm" ? `      ${f + 1}. ES Modules` : `      ${f + 1}. CommonJS`).join(`
`);
        return `    ${vd(c, ["bold"])} v${l.version}: 
${d}`;
      }),
      "",
      "You should configure your bundler to only import one version of each library."
    ];
    console.log(a.join(`
`)), t.didWarn = !0;
    return;
  }
}
function vU(t, e) {
  const n = t.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/), r = e.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/);
  return !n || !r ? t.localeCompare(e) : n[1] !== r[1] ? Number(n[1]) - Number(r[1]) : n[2] !== r[2] ? Number(n[2]) - Number(r[2]) : n[3] !== r[3] ? Number(n[3]) - Number(r[3]) : n[4] && r[4] ? n[4].localeCompare(r[4]) : n[4] ? 1 : r[4] ? -1 : 0;
}
const uOe = {
  bold: "1",
  textBlue: "94",
  textRed: "31",
  textGreen: "32",
  bgRed: "41",
  textWhite: "97"
};
function vd(t, e = []) {
  return `\x1B[${e.map((n) => uOe[n]).join(";")}m${t}\x1B[m`;
}
function mM(t, e, n) {
  return t.has(e) ? t.get(e) : (t.set(e, n), n);
}
var dE = { exports: {} };
dE.exports;
(function(t, e) {
  var n = 200, r = "__lodash_hash_undefined__", s = 1, o = 2, i = 9007199254740991, a = "[object Arguments]", c = "[object Array]", l = "[object AsyncFunction]", d = "[object Boolean]", u = "[object Date]", f = "[object Error]", p = "[object Function]", g = "[object GeneratorFunction]", y = "[object Map]", m = "[object Number]", v = "[object Null]", b = "[object Object]", x = "[object Promise]", w = "[object Proxy]", S = "[object RegExp]", C = "[object Set]", _ = "[object String]", E = "[object Symbol]", M = "[object Undefined]", N = "[object WeakMap]", O = "[object ArrayBuffer]", D = "[object DataView]", k = "[object Float32Array]", A = "[object Float64Array]", R = "[object Int8Array]", j = "[object Int16Array]", $ = "[object Int32Array]", F = "[object Uint8Array]", L = "[object Uint8ClampedArray]", z = "[object Uint16Array]", H = "[object Uint32Array]", U = /[\\^$.*+?()[\]{}|]/g, W = /^\[object .+?Constructor\]$/, Z = /^(?:0|[1-9]\d*)$/, K = {};
  K[k] = K[A] = K[R] = K[j] = K[$] = K[F] = K[L] = K[z] = K[H] = !0, K[a] = K[c] = K[O] = K[d] = K[D] = K[u] = K[f] = K[p] = K[y] = K[m] = K[b] = K[S] = K[C] = K[_] = K[N] = !1;
  var oe = typeof yn == "object" && yn && yn.Object === Object && yn, Y = typeof self == "object" && self && self.Object === Object && self, ee = oe || Y || Function("return this")(), ae = e && !e.nodeType && e, de = ae && !0 && t && !t.nodeType && t, ye = de && de.exports === ae, G = ye && oe.process, xe = function() {
    try {
      return G && G.binding && G.binding("util");
    } catch {
    }
  }(), ge = xe && xe.isTypedArray;
  function ze(V, se) {
    for (var Se = -1, Ye = V == null ? 0 : V.length, Gn = 0, Lt = []; ++Se < Ye; ) {
      var wr = V[Se];
      se(wr, Se, V) && (Lt[Gn++] = wr);
    }
    return Lt;
  }
  function Ge(V, se) {
    for (var Se = -1, Ye = se.length, Gn = V.length; ++Se < Ye; )
      V[Gn + Se] = se[Se];
    return V;
  }
  function Ct(V, se) {
    for (var Se = -1, Ye = V == null ? 0 : V.length; ++Se < Ye; )
      if (se(V[Se], Se, V))
        return !0;
    return !1;
  }
  function vn(V, se) {
    for (var Se = -1, Ye = Array(V); ++Se < V; )
      Ye[Se] = se(Se);
    return Ye;
  }
  function Yt(V) {
    return function(se) {
      return V(se);
    };
  }
  function X(V, se) {
    return V.has(se);
  }
  function ce(V, se) {
    return V == null ? void 0 : V[se];
  }
  function pe(V) {
    var se = -1, Se = Array(V.size);
    return V.forEach(function(Ye, Gn) {
      Se[++se] = [Gn, Ye];
    }), Se;
  }
  function Ie(V, se) {
    return function(Se) {
      return V(se(Se));
    };
  }
  function ke(V) {
    var se = -1, Se = Array(V.size);
    return V.forEach(function(Ye) {
      Se[++se] = Ye;
    }), Se;
  }
  var Ce = Array.prototype, De = Function.prototype, ot = Object.prototype, Nt = ee["__core-js_shared__"], Kn = De.toString, In = ot.hasOwnProperty, Mr = function() {
    var V = /[^.]+$/.exec(Nt && Nt.keys && Nt.keys.IE_PROTO || "");
    return V ? "Symbol(src)_1." + V : "";
  }(), qi = ot.toString, Us = RegExp(
    "^" + Kn.call(In).replace(U, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), ur = ye ? ee.Buffer : void 0, Hs = ee.Symbol, Yr = ee.Uint8Array, vi = ot.propertyIsEnumerable, ho = Ce.splice, Ss = Hs ? Hs.toStringTag : void 0, ja = Object.getOwnPropertySymbols, bi = ur ? ur.isBuffer : void 0, Xi = Ie(Object.keys, Object), qr = hd(ee, "DataView"), Wo = hd(ee, "Map"), ct = hd(ee, "Promise"), Pt = hd(ee, "Set"), sn = hd(ee, "WeakMap"), tr = hd(Object, "create"), Xr = Qe(qr), po = Qe(Wo), Ko = Qe(ct), Nn = Qe(Pt), Vs = Qe(sn), _u = Hs ? Hs.prototype : void 0, dd = _u ? _u.valueOf : void 0;
  function Zi(V) {
    var se = -1, Se = V == null ? 0 : V.length;
    for (this.clear(); ++se < Se; ) {
      var Ye = V[se];
      this.set(Ye[0], Ye[1]);
    }
  }
  function ph() {
    this.__data__ = tr ? tr(null) : {}, this.size = 0;
  }
  function Q(V) {
    var se = this.has(V) && delete this.__data__[V];
    return this.size -= se ? 1 : 0, se;
  }
  function Ee(V) {
    var se = this.__data__;
    if (tr) {
      var Se = se[V];
      return Se === r ? void 0 : Se;
    }
    return In.call(se, V) ? se[V] : void 0;
  }
  function $e(V) {
    var se = this.__data__;
    return tr ? se[V] !== void 0 : In.call(se, V);
  }
  function ut(V, se) {
    var Se = this.__data__;
    return this.size += this.has(V) ? 0 : 1, Se[V] = tr && se === void 0 ? r : se, this;
  }
  Zi.prototype.clear = ph, Zi.prototype.delete = Q, Zi.prototype.get = Ee, Zi.prototype.has = $e, Zi.prototype.set = ut;
  function It(V) {
    var se = -1, Se = V == null ? 0 : V.length;
    for (this.clear(); ++se < Se; ) {
      var Ye = V[se];
      this.set(Ye[0], Ye[1]);
    }
  }
  function on() {
    this.__data__ = [], this.size = 0;
  }
  function jt(V) {
    var se = this.__data__, Se = xc(se, V);
    if (Se < 0)
      return !1;
    var Ye = se.length - 1;
    return Se == Ye ? se.pop() : ho.call(se, Se, 1), --this.size, !0;
  }
  function Rt(V) {
    var se = this.__data__, Se = xc(se, V);
    return Se < 0 ? void 0 : se[Se][1];
  }
  function Or(V) {
    return xc(this.__data__, V) > -1;
  }
  function an(V, se) {
    var Se = this.__data__, Ye = xc(Se, V);
    return Ye < 0 ? (++this.size, Se.push([V, se])) : Se[Ye][1] = se, this;
  }
  It.prototype.clear = on, It.prototype.delete = jt, It.prototype.get = Rt, It.prototype.has = Or, It.prototype.set = an;
  function hn(V) {
    var se = -1, Se = V == null ? 0 : V.length;
    for (this.clear(); ++se < Se; ) {
      var Ye = V[se];
      this.set(Ye[0], Ye[1]);
    }
  }
  function Cs() {
    this.size = 0, this.__data__ = {
      hash: new Zi(),
      map: new (Wo || It)(),
      string: new Zi()
    };
  }
  function Qi(V) {
    var se = Ig(this, V).delete(V);
    return this.size -= se ? 1 : 0, se;
  }
  function Ji(V) {
    return Ig(this, V).get(V);
  }
  function Zr(V) {
    return Ig(this, V).has(V);
  }
  function ud(V, se) {
    var Se = Ig(this, V), Ye = Se.size;
    return Se.set(V, se), this.size += Se.size == Ye ? 0 : 1, this;
  }
  hn.prototype.clear = Cs, hn.prototype.delete = Qi, hn.prototype.get = Ji, hn.prototype.has = Zr, hn.prototype.set = ud;
  function ea(V) {
    var se = -1, Se = V == null ? 0 : V.length;
    for (this.__data__ = new hn(); ++se < Se; )
      this.add(V[se]);
  }
  function gh(V) {
    return this.__data__.set(V, r), this;
  }
  function Sg(V) {
    return this.__data__.has(V);
  }
  ea.prototype.add = ea.prototype.push = gh, ea.prototype.has = Sg;
  function Ra(V) {
    var se = this.__data__ = new It(V);
    this.size = se.size;
  }
  function Cg() {
    this.__data__ = new It(), this.size = 0;
  }
  function Dv(V) {
    var se = this.__data__, Se = se.delete(V);
    return this.size = se.size, Se;
  }
  function Nv(V) {
    return this.__data__.get(V);
  }
  function _g(V) {
    return this.__data__.has(V);
  }
  function jv(V, se) {
    var Se = this.__data__;
    if (Se instanceof It) {
      var Ye = Se.__data__;
      if (!Wo || Ye.length < n - 1)
        return Ye.push([V, se]), this.size = ++Se.size, this;
      Se = this.__data__ = new hn(Ye);
    }
    return Se.set(V, se), this.size = Se.size, this;
  }
  Ra.prototype.clear = Cg, Ra.prototype.delete = Dv, Ra.prototype.get = Nv, Ra.prototype.has = _g, Ra.prototype.set = jv;
  function Rv(V, se) {
    var Se = Qr(V), Ye = !Se && $t(V), Gn = !Se && !Ye && Jr(V), Lt = !Se && !Ye && !Gn && Yo(V), wr = Se || Ye || Gn || Lt, Ts = wr ? vn(V.length, String) : [], Ws = Ts.length;
    for (var fr in V)
      In.call(V, fr) && !(wr && // Safari 9 has enumerable `arguments.length` in strict mode.
      (fr == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Gn && (fr == "offset" || fr == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Lt && (fr == "buffer" || fr == "byteLength" || fr == "byteOffset") || // Skip index properties.
      DA(fr, Ws))) && Ts.push(fr);
    return Ts;
  }
  function xc(V, se) {
    for (var Se = V.length; Se--; )
      if (nr(V[Se][0], se))
        return Se;
    return -1;
  }
  function hl(V, se, Se) {
    var Ye = se(V);
    return Qr(V) ? Ye : Ge(Ye, Se(V));
  }
  function go(V) {
    return V == null ? V === void 0 ? M : v : Ss && Ss in Object(V) ? KS(V) : Me(V);
  }
  function fd(V) {
    return Es(V) && go(V) == a;
  }
  function Eg(V, se, Se, Ye, Gn) {
    return V === se ? !0 : V == null || se == null || !Es(V) && !Es(se) ? V !== V && se !== se : Tg(V, se, Se, Ye, Eg, Gn);
  }
  function Tg(V, se, Se, Ye, Gn, Lt) {
    var wr = Qr(V), Ts = Qr(se), Ws = wr ? c : $a(V), fr = Ts ? c : $a(se);
    Ws = Ws == a ? b : Ws, fr = fr == a ? b : fr;
    var ta = Ws == b, Cc = fr == b, vo = Ws == fr;
    if (vo && Jr(V)) {
      if (!Jr(se))
        return !1;
      wr = !0, ta = !1;
    }
    if (vo && !ta)
      return Lt || (Lt = new Ra()), wr || Yo(V) ? Pg(V, se, Se, Ye, Gn, Lt) : mh(V, se, Ws, Se, Ye, Gn, Lt);
    if (!(Se & s)) {
      var La = ta && In.call(V, "__wrapped__"), Fa = Cc && In.call(se, "__wrapped__");
      if (La || Fa) {
        var Tu = La ? V.value() : V, gd = Fa ? se.value() : se;
        return Lt || (Lt = new Ra()), Gn(Tu, gd, Se, Ye, Lt);
      }
    }
    return vo ? (Lt || (Lt = new Ra()), yh(V, se, Se, Ye, Gn, Lt)) : !1;
  }
  function $v(V) {
    if (!_s(V) || q(V))
      return !1;
    var se = Go(V) ? Us : W;
    return se.test(Qe(V));
  }
  function wc(V) {
    return Es(V) && xi(V.length) && !!K[go(V)];
  }
  function Eu(V) {
    if (!ue(V))
      return Xi(V);
    var se = [];
    for (var Se in Object(V))
      In.call(V, Se) && Se != "constructor" && se.push(Se);
    return se;
  }
  function Pg(V, se, Se, Ye, Gn, Lt) {
    var wr = Se & s, Ts = V.length, Ws = se.length;
    if (Ts != Ws && !(wr && Ws > Ts))
      return !1;
    var fr = Lt.get(V);
    if (fr && Lt.get(se))
      return fr == se;
    var ta = -1, Cc = !0, vo = Se & o ? new ea() : void 0;
    for (Lt.set(V, se), Lt.set(se, V); ++ta < Ts; ) {
      var La = V[ta], Fa = se[ta];
      if (Ye)
        var Tu = wr ? Ye(Fa, La, ta, se, V, Lt) : Ye(La, Fa, ta, V, se, Lt);
      if (Tu !== void 0) {
        if (Tu)
          continue;
        Cc = !1;
        break;
      }
      if (vo) {
        if (!Ct(se, function(gd, vh) {
          if (!X(vo, vh) && (La === gd || Gn(La, gd, Se, Ye, Lt)))
            return vo.push(vh);
        })) {
          Cc = !1;
          break;
        }
      } else if (!(La === Fa || Gn(La, Fa, Se, Ye, Lt))) {
        Cc = !1;
        break;
      }
    }
    return Lt.delete(V), Lt.delete(se), Cc;
  }
  function mh(V, se, Se, Ye, Gn, Lt, wr) {
    switch (Se) {
      case D:
        if (V.byteLength != se.byteLength || V.byteOffset != se.byteOffset)
          return !1;
        V = V.buffer, se = se.buffer;
      case O:
        return !(V.byteLength != se.byteLength || !Lt(new Yr(V), new Yr(se)));
      case d:
      case u:
      case m:
        return nr(+V, +se);
      case f:
        return V.name == se.name && V.message == se.message;
      case S:
      case _:
        return V == se + "";
      case y:
        var Ts = pe;
      case C:
        var Ws = Ye & s;
        if (Ts || (Ts = ke), V.size != se.size && !Ws)
          return !1;
        var fr = wr.get(V);
        if (fr)
          return fr == se;
        Ye |= o, wr.set(V, se);
        var ta = Pg(Ts(V), Ts(se), Ye, Gn, Lt, wr);
        return wr.delete(V), ta;
      case E:
        if (dd)
          return dd.call(V) == dd.call(se);
    }
    return !1;
  }
  function yh(V, se, Se, Ye, Gn, Lt) {
    var wr = Se & s, Ts = WS(V), Ws = Ts.length, fr = WS(se), ta = fr.length;
    if (Ws != ta && !wr)
      return !1;
    for (var Cc = Ws; Cc--; ) {
      var vo = Ts[Cc];
      if (!(wr ? vo in se : In.call(se, vo)))
        return !1;
    }
    var La = Lt.get(V);
    if (La && Lt.get(se))
      return La == se;
    var Fa = !0;
    Lt.set(V, se), Lt.set(se, V);
    for (var Tu = wr; ++Cc < Ws; ) {
      vo = Ts[Cc];
      var gd = V[vo], vh = se[vo];
      if (Ye)
        var mz = wr ? Ye(vh, gd, vo, se, V, Lt) : Ye(gd, vh, vo, V, se, Lt);
      if (!(mz === void 0 ? gd === vh || Gn(gd, vh, Se, Ye, Lt) : mz)) {
        Fa = !1;
        break;
      }
      Tu || (Tu = vo == "constructor");
    }
    if (Fa && !Tu) {
      var YS = V.constructor, qS = se.constructor;
      YS != qS && "constructor" in V && "constructor" in se && !(typeof YS == "function" && YS instanceof YS && typeof qS == "function" && qS instanceof qS) && (Fa = !1);
    }
    return Lt.delete(V), Lt.delete(se), Fa;
  }
  function WS(V) {
    return hl(V, pl, Lv);
  }
  function Ig(V, se) {
    var Se = V.__data__;
    return GS(se) ? Se[typeof se == "string" ? "string" : "hash"] : Se.map;
  }
  function hd(V, se) {
    var Se = ce(V, se);
    return $v(Se) ? Se : void 0;
  }
  function KS(V) {
    var se = In.call(V, Ss), Se = V[Ss];
    try {
      V[Ss] = void 0;
      var Ye = !0;
    } catch {
    }
    var Gn = qi.call(V);
    return Ye && (se ? V[Ss] = Se : delete V[Ss]), Gn;
  }
  var Lv = ja ? function(V) {
    return V == null ? [] : (V = Object(V), ze(ja(V), function(se) {
      return vi.call(V, se);
    }));
  } : Sc, $a = go;
  (qr && $a(new qr(new ArrayBuffer(1))) != D || Wo && $a(new Wo()) != y || ct && $a(ct.resolve()) != x || Pt && $a(new Pt()) != C || sn && $a(new sn()) != N) && ($a = function(V) {
    var se = go(V), Se = se == b ? V.constructor : void 0, Ye = Se ? Qe(Se) : "";
    if (Ye)
      switch (Ye) {
        case Xr:
          return D;
        case po:
          return y;
        case Ko:
          return x;
        case Nn:
          return C;
        case Vs:
          return N;
      }
    return se;
  });
  function DA(V, se) {
    return se = se ?? i, !!se && (typeof V == "number" || Z.test(V)) && V > -1 && V % 1 == 0 && V < se;
  }
  function GS(V) {
    var se = typeof V;
    return se == "string" || se == "number" || se == "symbol" || se == "boolean" ? V !== "__proto__" : V === null;
  }
  function q(V) {
    return !!Mr && Mr in V;
  }
  function ue(V) {
    var se = V && V.constructor, Se = typeof se == "function" && se.prototype || ot;
    return V === Se;
  }
  function Me(V) {
    return qi.call(V);
  }
  function Qe(V) {
    if (V != null) {
      try {
        return Kn.call(V);
      } catch {
      }
      try {
        return V + "";
      } catch {
      }
    }
    return "";
  }
  function nr(V, se) {
    return V === se || V !== V && se !== se;
  }
  var $t = fd(/* @__PURE__ */ function() {
    return arguments;
  }()) ? fd : function(V) {
    return Es(V) && In.call(V, "callee") && !vi.call(V, "callee");
  }, Qr = Array.isArray;
  function mo(V) {
    return V != null && xi(V.length) && !Go(V);
  }
  var Jr = bi || pd;
  function yo(V, se) {
    return Eg(V, se);
  }
  function Go(V) {
    if (!_s(V))
      return !1;
    var se = go(V);
    return se == p || se == g || se == l || se == w;
  }
  function xi(V) {
    return typeof V == "number" && V > -1 && V % 1 == 0 && V <= i;
  }
  function _s(V) {
    var se = typeof V;
    return V != null && (se == "object" || se == "function");
  }
  function Es(V) {
    return V != null && typeof V == "object";
  }
  var Yo = ge ? Yt(ge) : wc;
  function pl(V) {
    return mo(V) ? Rv(V) : Eu(V);
  }
  function Sc() {
    return [];
  }
  function pd() {
    return !1;
  }
  t.exports = yo;
})(dE, dE.exports);
var fOe = dE.exports;
const Zf = /* @__PURE__ */ Wr(fOe);
var uE = { exports: {} };
uE.exports;
(function(t, e) {
  var n = 200, r = "__lodash_hash_undefined__", s = 1, o = 2, i = 9007199254740991, a = "[object Arguments]", c = "[object Array]", l = "[object Boolean]", d = "[object Date]", u = "[object Error]", f = "[object Function]", p = "[object GeneratorFunction]", g = "[object Map]", y = "[object Number]", m = "[object Object]", v = "[object Promise]", b = "[object RegExp]", x = "[object Set]", w = "[object String]", S = "[object Symbol]", C = "[object WeakMap]", _ = "[object ArrayBuffer]", E = "[object DataView]", M = "[object Float32Array]", N = "[object Float64Array]", O = "[object Int8Array]", D = "[object Int16Array]", k = "[object Int32Array]", A = "[object Uint8Array]", R = "[object Uint8ClampedArray]", j = "[object Uint16Array]", $ = "[object Uint32Array]", F = /[\\^$.*+?()[\]{}|]/g, L = /^\[object .+?Constructor\]$/, z = /^(?:0|[1-9]\d*)$/, H = {};
  H[M] = H[N] = H[O] = H[D] = H[k] = H[A] = H[R] = H[j] = H[$] = !0, H[a] = H[c] = H[_] = H[l] = H[E] = H[d] = H[u] = H[f] = H[g] = H[y] = H[m] = H[b] = H[x] = H[w] = H[C] = !1;
  var U = typeof yn == "object" && yn && yn.Object === Object && yn, W = typeof self == "object" && self && self.Object === Object && self, Z = U || W || Function("return this")(), K = e && !e.nodeType && e, oe = K && !0 && t && !t.nodeType && t, Y = oe && oe.exports === K, ee = Y && U.process, ae = function() {
    try {
      return ee && ee.binding("util");
    } catch {
    }
  }(), de = ae && ae.isTypedArray;
  function ye(q, ue) {
    for (var Me = -1, Qe = q ? q.length : 0; ++Me < Qe; )
      if (ue(q[Me], Me, q))
        return !0;
    return !1;
  }
  function G(q, ue) {
    for (var Me = -1, Qe = Array(q); ++Me < q; )
      Qe[Me] = ue(Me);
    return Qe;
  }
  function xe(q) {
    return function(ue) {
      return q(ue);
    };
  }
  function ge(q, ue) {
    return q == null ? void 0 : q[ue];
  }
  function ze(q) {
    var ue = !1;
    if (q != null && typeof q.toString != "function")
      try {
        ue = !!(q + "");
      } catch {
      }
    return ue;
  }
  function Ge(q) {
    var ue = -1, Me = Array(q.size);
    return q.forEach(function(Qe, nr) {
      Me[++ue] = [nr, Qe];
    }), Me;
  }
  function Ct(q, ue) {
    return function(Me) {
      return q(ue(Me));
    };
  }
  function vn(q) {
    var ue = -1, Me = Array(q.size);
    return q.forEach(function(Qe) {
      Me[++ue] = Qe;
    }), Me;
  }
  var Yt = Array.prototype, X = Function.prototype, ce = Object.prototype, pe = Z["__core-js_shared__"], Ie = function() {
    var q = /[^.]+$/.exec(pe && pe.keys && pe.keys.IE_PROTO || "");
    return q ? "Symbol(src)_1." + q : "";
  }(), ke = X.toString, Ce = ce.hasOwnProperty, De = ce.toString, ot = RegExp(
    "^" + ke.call(Ce).replace(F, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Nt = Z.Symbol, Kn = Z.Uint8Array, In = ce.propertyIsEnumerable, Mr = Yt.splice, qi = Ct(Object.keys, Object), Us = hl(Z, "DataView"), ur = hl(Z, "Map"), Hs = hl(Z, "Promise"), Yr = hl(Z, "Set"), vi = hl(Z, "WeakMap"), ho = hl(Object, "create"), Ss = wc(Us), ja = wc(ur), bi = wc(Hs), Xi = wc(Yr), qr = wc(vi), Wo = Nt ? Nt.prototype : void 0, ct = Wo ? Wo.valueOf : void 0;
  function Pt(q) {
    var ue = -1, Me = q ? q.length : 0;
    for (this.clear(); ++ue < Me; ) {
      var Qe = q[ue];
      this.set(Qe[0], Qe[1]);
    }
  }
  function sn() {
    this.__data__ = ho ? ho(null) : {};
  }
  function tr(q) {
    return this.has(q) && delete this.__data__[q];
  }
  function Xr(q) {
    var ue = this.__data__;
    if (ho) {
      var Me = ue[q];
      return Me === r ? void 0 : Me;
    }
    return Ce.call(ue, q) ? ue[q] : void 0;
  }
  function po(q) {
    var ue = this.__data__;
    return ho ? ue[q] !== void 0 : Ce.call(ue, q);
  }
  function Ko(q, ue) {
    var Me = this.__data__;
    return Me[q] = ho && ue === void 0 ? r : ue, this;
  }
  Pt.prototype.clear = sn, Pt.prototype.delete = tr, Pt.prototype.get = Xr, Pt.prototype.has = po, Pt.prototype.set = Ko;
  function Nn(q) {
    var ue = -1, Me = q ? q.length : 0;
    for (this.clear(); ++ue < Me; ) {
      var Qe = q[ue];
      this.set(Qe[0], Qe[1]);
    }
  }
  function Vs() {
    this.__data__ = [];
  }
  function _u(q) {
    var ue = this.__data__, Me = ea(ue, q);
    if (Me < 0)
      return !1;
    var Qe = ue.length - 1;
    return Me == Qe ? ue.pop() : Mr.call(ue, Me, 1), !0;
  }
  function dd(q) {
    var ue = this.__data__, Me = ea(ue, q);
    return Me < 0 ? void 0 : ue[Me][1];
  }
  function Zi(q) {
    return ea(this.__data__, q) > -1;
  }
  function ph(q, ue) {
    var Me = this.__data__, Qe = ea(Me, q);
    return Qe < 0 ? Me.push([q, ue]) : Me[Qe][1] = ue, this;
  }
  Nn.prototype.clear = Vs, Nn.prototype.delete = _u, Nn.prototype.get = dd, Nn.prototype.has = Zi, Nn.prototype.set = ph;
  function Q(q) {
    var ue = -1, Me = q ? q.length : 0;
    for (this.clear(); ++ue < Me; ) {
      var Qe = q[ue];
      this.set(Qe[0], Qe[1]);
    }
  }
  function Ee() {
    this.__data__ = {
      hash: new Pt(),
      map: new (ur || Nn)(),
      string: new Pt()
    };
  }
  function $e(q) {
    return xc(this, q).delete(q);
  }
  function ut(q) {
    return xc(this, q).get(q);
  }
  function It(q) {
    return xc(this, q).has(q);
  }
  function on(q, ue) {
    return xc(this, q).set(q, ue), this;
  }
  Q.prototype.clear = Ee, Q.prototype.delete = $e, Q.prototype.get = ut, Q.prototype.has = It, Q.prototype.set = on;
  function jt(q) {
    var ue = -1, Me = q ? q.length : 0;
    for (this.__data__ = new Q(); ++ue < Me; )
      this.add(q[ue]);
  }
  function Rt(q) {
    return this.__data__.set(q, r), this;
  }
  function Or(q) {
    return this.__data__.has(q);
  }
  jt.prototype.add = jt.prototype.push = Rt, jt.prototype.has = Or;
  function an(q) {
    this.__data__ = new Nn(q);
  }
  function hn() {
    this.__data__ = new Nn();
  }
  function Cs(q) {
    return this.__data__.delete(q);
  }
  function Qi(q) {
    return this.__data__.get(q);
  }
  function Ji(q) {
    return this.__data__.has(q);
  }
  function Zr(q, ue) {
    var Me = this.__data__;
    if (Me instanceof Nn) {
      var Qe = Me.__data__;
      if (!ur || Qe.length < n - 1)
        return Qe.push([q, ue]), this;
      Me = this.__data__ = new Q(Qe);
    }
    return Me.set(q, ue), this;
  }
  an.prototype.clear = hn, an.prototype.delete = Cs, an.prototype.get = Qi, an.prototype.has = Ji, an.prototype.set = Zr;
  function ud(q, ue) {
    var Me = mh(q) || Pg(q) ? G(q.length, String) : [], Qe = Me.length, nr = !!Qe;
    for (var $t in q)
      Ce.call(q, $t) && !(nr && ($t == "length" || fd($t, Qe))) && Me.push($t);
    return Me;
  }
  function ea(q, ue) {
    for (var Me = q.length; Me--; )
      if (Eu(q[Me][0], ue))
        return Me;
    return -1;
  }
  function gh(q) {
    return De.call(q);
  }
  function Sg(q, ue, Me, Qe, nr) {
    return q === ue ? !0 : q == null || ue == null || !Lv(q) && !$a(ue) ? q !== q && ue !== ue : Ra(q, ue, Sg, Me, Qe, nr);
  }
  function Ra(q, ue, Me, Qe, nr, $t) {
    var Qr = mh(q), mo = mh(ue), Jr = c, yo = c;
    Qr || (Jr = go(q), Jr = Jr == a ? m : Jr), mo || (yo = go(ue), yo = yo == a ? m : yo);
    var Go = Jr == m && !ze(q), xi = yo == m && !ze(ue), _s = Jr == yo;
    if (_s && !Go)
      return $t || ($t = new an()), Qr || DA(q) ? _g(q, ue, Me, Qe, nr, $t) : jv(q, ue, Jr, Me, Qe, nr, $t);
    if (!(nr & o)) {
      var Es = Go && Ce.call(q, "__wrapped__"), Yo = xi && Ce.call(ue, "__wrapped__");
      if (Es || Yo) {
        var pl = Es ? q.value() : q, Sc = Yo ? ue.value() : ue;
        return $t || ($t = new an()), Me(pl, Sc, Qe, nr, $t);
      }
    }
    return _s ? ($t || ($t = new an()), Rv(q, ue, Me, Qe, nr, $t)) : !1;
  }
  function Cg(q) {
    if (!Lv(q) || Tg(q))
      return !1;
    var ue = hd(q) || ze(q) ? ot : L;
    return ue.test(wc(q));
  }
  function Dv(q) {
    return $a(q) && KS(q.length) && !!H[De.call(q)];
  }
  function Nv(q) {
    if (!$v(q))
      return qi(q);
    var ue = [];
    for (var Me in Object(q))
      Ce.call(q, Me) && Me != "constructor" && ue.push(Me);
    return ue;
  }
  function _g(q, ue, Me, Qe, nr, $t) {
    var Qr = nr & o, mo = q.length, Jr = ue.length;
    if (mo != Jr && !(Qr && Jr > mo))
      return !1;
    var yo = $t.get(q);
    if (yo && $t.get(ue))
      return yo == ue;
    var Go = -1, xi = !0, _s = nr & s ? new jt() : void 0;
    for ($t.set(q, ue), $t.set(ue, q); ++Go < mo; ) {
      var Es = q[Go], Yo = ue[Go];
      if (Qe)
        var pl = Qr ? Qe(Yo, Es, Go, ue, q, $t) : Qe(Es, Yo, Go, q, ue, $t);
      if (pl !== void 0) {
        if (pl)
          continue;
        xi = !1;
        break;
      }
      if (_s) {
        if (!ye(ue, function(Sc, pd) {
          if (!_s.has(pd) && (Es === Sc || Me(Es, Sc, Qe, nr, $t)))
            return _s.add(pd);
        })) {
          xi = !1;
          break;
        }
      } else if (!(Es === Yo || Me(Es, Yo, Qe, nr, $t))) {
        xi = !1;
        break;
      }
    }
    return $t.delete(q), $t.delete(ue), xi;
  }
  function jv(q, ue, Me, Qe, nr, $t, Qr) {
    switch (Me) {
      case E:
        if (q.byteLength != ue.byteLength || q.byteOffset != ue.byteOffset)
          return !1;
        q = q.buffer, ue = ue.buffer;
      case _:
        return !(q.byteLength != ue.byteLength || !Qe(new Kn(q), new Kn(ue)));
      case l:
      case d:
      case y:
        return Eu(+q, +ue);
      case u:
        return q.name == ue.name && q.message == ue.message;
      case b:
      case w:
        return q == ue + "";
      case g:
        var mo = Ge;
      case x:
        var Jr = $t & o;
        if (mo || (mo = vn), q.size != ue.size && !Jr)
          return !1;
        var yo = Qr.get(q);
        if (yo)
          return yo == ue;
        $t |= s, Qr.set(q, ue);
        var Go = _g(mo(q), mo(ue), Qe, nr, $t, Qr);
        return Qr.delete(q), Go;
      case S:
        if (ct)
          return ct.call(q) == ct.call(ue);
    }
    return !1;
  }
  function Rv(q, ue, Me, Qe, nr, $t) {
    var Qr = nr & o, mo = GS(q), Jr = mo.length, yo = GS(ue), Go = yo.length;
    if (Jr != Go && !Qr)
      return !1;
    for (var xi = Jr; xi--; ) {
      var _s = mo[xi];
      if (!(Qr ? _s in ue : Ce.call(ue, _s)))
        return !1;
    }
    var Es = $t.get(q);
    if (Es && $t.get(ue))
      return Es == ue;
    var Yo = !0;
    $t.set(q, ue), $t.set(ue, q);
    for (var pl = Qr; ++xi < Jr; ) {
      _s = mo[xi];
      var Sc = q[_s], pd = ue[_s];
      if (Qe)
        var V = Qr ? Qe(pd, Sc, _s, ue, q, $t) : Qe(Sc, pd, _s, q, ue, $t);
      if (!(V === void 0 ? Sc === pd || Me(Sc, pd, Qe, nr, $t) : V)) {
        Yo = !1;
        break;
      }
      pl || (pl = _s == "constructor");
    }
    if (Yo && !pl) {
      var se = q.constructor, Se = ue.constructor;
      se != Se && "constructor" in q && "constructor" in ue && !(typeof se == "function" && se instanceof se && typeof Se == "function" && Se instanceof Se) && (Yo = !1);
    }
    return $t.delete(q), $t.delete(ue), Yo;
  }
  function xc(q, ue) {
    var Me = q.__data__;
    return Eg(ue) ? Me[typeof ue == "string" ? "string" : "hash"] : Me.map;
  }
  function hl(q, ue) {
    var Me = ge(q, ue);
    return Cg(Me) ? Me : void 0;
  }
  var go = gh;
  (Us && go(new Us(new ArrayBuffer(1))) != E || ur && go(new ur()) != g || Hs && go(Hs.resolve()) != v || Yr && go(new Yr()) != x || vi && go(new vi()) != C) && (go = function(q) {
    var ue = De.call(q), Me = ue == m ? q.constructor : void 0, Qe = Me ? wc(Me) : void 0;
    if (Qe)
      switch (Qe) {
        case Ss:
          return E;
        case ja:
          return g;
        case bi:
          return v;
        case Xi:
          return x;
        case qr:
          return C;
      }
    return ue;
  });
  function fd(q, ue) {
    return ue = ue ?? i, !!ue && (typeof q == "number" || z.test(q)) && q > -1 && q % 1 == 0 && q < ue;
  }
  function Eg(q) {
    var ue = typeof q;
    return ue == "string" || ue == "number" || ue == "symbol" || ue == "boolean" ? q !== "__proto__" : q === null;
  }
  function Tg(q) {
    return !!Ie && Ie in q;
  }
  function $v(q) {
    var ue = q && q.constructor, Me = typeof ue == "function" && ue.prototype || ce;
    return q === Me;
  }
  function wc(q) {
    if (q != null) {
      try {
        return ke.call(q);
      } catch {
      }
      try {
        return q + "";
      } catch {
      }
    }
    return "";
  }
  function Eu(q, ue) {
    return q === ue || q !== q && ue !== ue;
  }
  function Pg(q) {
    return WS(q) && Ce.call(q, "callee") && (!In.call(q, "callee") || De.call(q) == a);
  }
  var mh = Array.isArray;
  function yh(q) {
    return q != null && KS(q.length) && !hd(q);
  }
  function WS(q) {
    return $a(q) && yh(q);
  }
  function Ig(q, ue, Me) {
    Me = typeof Me == "function" ? Me : void 0;
    var Qe = Me ? Me(q, ue) : void 0;
    return Qe === void 0 ? Sg(q, ue, Me) : !!Qe;
  }
  function hd(q) {
    var ue = Lv(q) ? De.call(q) : "";
    return ue == f || ue == p;
  }
  function KS(q) {
    return typeof q == "number" && q > -1 && q % 1 == 0 && q <= i;
  }
  function Lv(q) {
    var ue = typeof q;
    return !!q && (ue == "object" || ue == "function");
  }
  function $a(q) {
    return !!q && typeof q == "object";
  }
  var DA = de ? xe(de) : Dv;
  function GS(q) {
    return yh(q) ? ud(q) : Nv(q);
  }
  t.exports = Ig;
})(uE, uE.exports);
var hOe = uE.exports;
const pOe = /* @__PURE__ */ Wr(hOe);
var vJ = "Expected a function", bU = NaN, gOe = "[object Symbol]", mOe = /^\s+|\s+$/g, yOe = /^[-+]0x[0-9a-f]+$/i, vOe = /^0b[01]+$/i, bOe = /^0o[0-7]+$/i, xOe = parseInt, wOe = typeof yn == "object" && yn && yn.Object === Object && yn, SOe = typeof self == "object" && self && self.Object === Object && self, COe = wOe || SOe || Function("return this")(), _Oe = Object.prototype, EOe = _Oe.toString, TOe = Math.max, POe = Math.min, yM = function() {
  return COe.Date.now();
};
function IOe(t, e, n) {
  var r, s, o, i, a, c, l = 0, d = !1, u = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(vJ);
  e = xU(e) || 0, fE(n) && (d = !!n.leading, u = "maxWait" in n, o = u ? TOe(xU(n.maxWait) || 0, e) : o, f = "trailing" in n ? !!n.trailing : f);
  function p(C) {
    var _ = r, E = s;
    return r = s = void 0, l = C, i = t.apply(E, _), i;
  }
  function g(C) {
    return l = C, a = setTimeout(v, e), d ? p(C) : i;
  }
  function y(C) {
    var _ = C - c, E = C - l, M = e - _;
    return u ? POe(M, o - E) : M;
  }
  function m(C) {
    var _ = C - c, E = C - l;
    return c === void 0 || _ >= e || _ < 0 || u && E >= o;
  }
  function v() {
    var C = yM();
    if (m(C))
      return b(C);
    a = setTimeout(v, y(C));
  }
  function b(C) {
    return a = void 0, f && r ? p(C) : (r = s = void 0, i);
  }
  function x() {
    a !== void 0 && clearTimeout(a), l = 0, r = c = s = a = void 0;
  }
  function w() {
    return a === void 0 ? i : b(yM());
  }
  function S() {
    var C = yM(), _ = m(C);
    if (r = arguments, s = this, c = C, _) {
      if (a === void 0)
        return g(c);
      if (u)
        return a = setTimeout(v, e), p(c);
    }
    return a === void 0 && (a = setTimeout(v, e)), i;
  }
  return S.cancel = x, S.flush = w, S;
}
function kOe(t, e, n) {
  var r = !0, s = !0;
  if (typeof t != "function")
    throw new TypeError(vJ);
  return fE(n) && (r = "leading" in n ? !!n.leading : r, s = "trailing" in n ? !!n.trailing : s), IOe(t, e, {
    leading: r,
    maxWait: e,
    trailing: s
  });
}
function fE(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function AOe(t) {
  return !!t && typeof t == "object";
}
function MOe(t) {
  return typeof t == "symbol" || AOe(t) && EOe.call(t) == gOe;
}
function xU(t) {
  if (typeof t == "number")
    return t;
  if (MOe(t))
    return bU;
  if (fE(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = fE(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = t.replace(mOe, "");
  var n = vOe.test(t);
  return n || bOe.test(t) ? xOe(t.slice(2), n ? 2 : 8) : yOe.test(t) ? bU : +t;
}
var OOe = kOe;
const bJ = /* @__PURE__ */ Wr(OOe);
var DOe = 200, sF = "__lodash_hash_undefined__", NOe = 1 / 0, jOe = "[object Function]", ROe = "[object GeneratorFunction]", $Oe = /[\\^$.*+?()[\]{}|]/g, LOe = /^\[object .+?Constructor\]$/, FOe = typeof yn == "object" && yn && yn.Object === Object && yn, BOe = typeof self == "object" && self && self.Object === Object && self, oF = FOe || BOe || Function("return this")();
function zOe(t, e) {
  var n = t ? t.length : 0;
  return !!n && HOe(t, e, 0) > -1;
}
function UOe(t, e, n, r) {
  for (var s = t.length, o = n + -1; ++o < s; )
    if (e(t[o], o, t))
      return o;
  return -1;
}
function HOe(t, e, n) {
  if (e !== e)
    return UOe(t, VOe, n);
  for (var r = n - 1, s = t.length; ++r < s; )
    if (t[r] === e)
      return r;
  return -1;
}
function VOe(t) {
  return t !== t;
}
function WOe(t, e) {
  return t.has(e);
}
function KOe(t, e) {
  return t == null ? void 0 : t[e];
}
function GOe(t) {
  var e = !1;
  if (t != null && typeof t.toString != "function")
    try {
      e = !!(t + "");
    } catch {
    }
  return e;
}
function xJ(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var YOe = Array.prototype, qOe = Function.prototype, wJ = Object.prototype, vM = oF["__core-js_shared__"], wU = function() {
  var t = /[^.]+$/.exec(vM && vM.keys && vM.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}(), SJ = qOe.toString, iF = wJ.hasOwnProperty, XOe = wJ.toString, ZOe = RegExp(
  "^" + SJ.call(iF).replace($Oe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), QOe = YOe.splice, JOe = aF(oF, "Map"), bM = aF(oF, "Set"), tw = aF(Object, "create");
function _p(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
function e2e() {
  this.__data__ = tw ? tw(null) : {};
}
function t2e(t) {
  return this.has(t) && delete this.__data__[t];
}
function n2e(t) {
  var e = this.__data__;
  if (tw) {
    var n = e[t];
    return n === sF ? void 0 : n;
  }
  return iF.call(e, t) ? e[t] : void 0;
}
function r2e(t) {
  var e = this.__data__;
  return tw ? e[t] !== void 0 : iF.call(e, t);
}
function s2e(t, e) {
  var n = this.__data__;
  return n[t] = tw && e === void 0 ? sF : e, this;
}
_p.prototype.clear = e2e;
_p.prototype.delete = t2e;
_p.prototype.get = n2e;
_p.prototype.has = r2e;
_p.prototype.set = s2e;
function ev(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
function o2e() {
  this.__data__ = [];
}
function i2e(t) {
  var e = this.__data__, n = mI(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : QOe.call(e, n, 1), !0;
}
function a2e(t) {
  var e = this.__data__, n = mI(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function c2e(t) {
  return mI(this.__data__, t) > -1;
}
function l2e(t, e) {
  var n = this.__data__, r = mI(n, t);
  return r < 0 ? n.push([t, e]) : n[r][1] = e, this;
}
ev.prototype.clear = o2e;
ev.prototype.delete = i2e;
ev.prototype.get = a2e;
ev.prototype.has = c2e;
ev.prototype.set = l2e;
function tv(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
function d2e() {
  this.__data__ = {
    hash: new _p(),
    map: new (JOe || ev)(),
    string: new _p()
  };
}
function u2e(t) {
  return yI(this, t).delete(t);
}
function f2e(t) {
  return yI(this, t).get(t);
}
function h2e(t) {
  return yI(this, t).has(t);
}
function p2e(t, e) {
  return yI(this, t).set(t, e), this;
}
tv.prototype.clear = d2e;
tv.prototype.delete = u2e;
tv.prototype.get = f2e;
tv.prototype.has = h2e;
tv.prototype.set = p2e;
function hE(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.__data__ = new tv(); ++e < n; )
    this.add(t[e]);
}
function g2e(t) {
  return this.__data__.set(t, sF), this;
}
function m2e(t) {
  return this.__data__.has(t);
}
hE.prototype.add = hE.prototype.push = g2e;
hE.prototype.has = m2e;
function mI(t, e) {
  for (var n = t.length; n--; )
    if (_2e(t[n][0], e))
      return n;
  return -1;
}
function y2e(t) {
  if (!CJ(t) || w2e(t))
    return !1;
  var e = E2e(t) || GOe(t) ? ZOe : LOe;
  return e.test(S2e(t));
}
function v2e(t, e, n) {
  var r = -1, s = zOe, o = t.length, i = !0, a = [], c = a;
  if (o >= DOe) {
    var l = b2e(t);
    if (l)
      return xJ(l);
    i = !1, s = WOe, c = new hE();
  } else
    c = a;
  e:
    for (; ++r < o; ) {
      var d = t[r], u = d;
      if (d = d !== 0 ? d : 0, i && u === u) {
        for (var f = c.length; f--; )
          if (c[f] === u)
            continue e;
        a.push(d);
      } else s(c, u, n) || (c !== a && c.push(u), a.push(d));
    }
  return a;
}
var b2e = bM && 1 / xJ(new bM([, -0]))[1] == NOe ? function(t) {
  return new bM(t);
} : T2e;
function yI(t, e) {
  var n = t.__data__;
  return x2e(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function aF(t, e) {
  var n = KOe(t, e);
  return y2e(n) ? n : void 0;
}
function x2e(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function w2e(t) {
  return !!wU && wU in t;
}
function S2e(t) {
  if (t != null) {
    try {
      return SJ.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
function C2e(t) {
  return t && t.length ? v2e(t) : [];
}
function _2e(t, e) {
  return t === e || t !== t && e !== e;
}
function E2e(t) {
  var e = CJ(t) ? XOe.call(t) : "";
  return e == jOe || e == ROe;
}
function CJ(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function T2e() {
}
var P2e = C2e;
const I2e = /* @__PURE__ */ Wr(P2e);
function cF(t, e) {
  const n = [];
  e: for (const r of t) {
    for (const s of n)
      if (e ? e(r, s) : r === s)
        continue e;
    n.push(r);
  }
  return n;
}
function mt(t) {
  return t.filter((e) => e != null);
}
function Qs(t) {
  return t[t.length - 1];
}
function _J(t, e) {
  let n, r = 1 / 0;
  for (const s of t) {
    const o = e(s);
    o < r && (n = s, r = o);
  }
  return n;
}
function k2e(t, e) {
  let n, r = -1 / 0;
  for (const s of t) {
    const o = e(s);
    o > r && (n = s, r = o);
  }
  return n;
}
function pE(t, e) {
  if (t === e) return !0;
  if (t.length !== e.length) return !1;
  for (let n = 0; n < t.length; n++)
    if (!Object.is(t[n], e[n]))
      return !1;
  return !0;
}
function hx(t, e, n) {
  const r = new Set(e.map((o) => o[t])), s = [];
  for (const o of n)
    r.has(o[t]) || s.push(o);
  for (const o of e)
    s.push(o);
  return s;
}
function EJ(t) {
  const e = (...n) => {
    try {
      return t(...n);
    } catch (r) {
      throw r instanceof Error && Error.captureStackTrace && Error.captureStackTrace(r, e), r;
    }
  };
  return e;
}
const nw = () => {
}, xf = {
  ok(t) {
    return { ok: !0, value: t };
  },
  err(t) {
    return { ok: !1, error: t };
  }
};
function Jt(t, e) {
  const n = e && t && typeof t == "object" && e in t ? t[e] : t;
  throw new Error(`Unknown switch case ${n}`);
}
const tt = EJ(
  (t, e) => {
    if (!t)
      throw new Error(e || "Assertion Error");
  }
), Io = EJ((t, e) => {
  if (t == null)
    throw new Error(e ?? "value must be defined");
  return t;
});
function lF() {
  let t, e;
  const n = new Promise((r, s) => {
    t = r, e = s;
  });
  return Object.assign(n, {
    resolve: t,
    reject: e
  });
}
function DN(t) {
  return new Promise((e) => setTimeout(e, t));
}
/*!
 * MIT License: https://github.com/NoHomey/bind-decorator/blob/master/License
 * Copyright (c) 2016 Ivo Stratev
 */
function Li(...t) {
  if (t.length === 2) {
    const [e, n] = t;
    n.addInitializer(function() {
      tt(Reflect.isExtensible(this), "Cannot bind to a non-extensible class.");
      const s = e.bind(this), o = Reflect.defineProperty(this, n.name, {
        value: s,
        writable: !0,
        configurable: !0
      });
      tt(o, "Cannot bind a non-configurable class method.");
    });
  } else {
    const [e, n, r] = t;
    if (!r || typeof r.value != "function")
      throw new TypeError(
        `Only methods can be decorated with @bind. <${n}> is not a method!`
      );
    return {
      configurable: !0,
      get() {
        const s = r.value.bind(this);
        return Object.defineProperty(this, n, {
          value: s,
          configurable: !0,
          writable: !0
        }), s;
      }
    };
  }
}
class No {
  constructor() {
    /** The map of items to their cached values. */
    P(this, "items", /* @__PURE__ */ new WeakMap());
  }
  /**
   * Get the cached value for a given record. If the record is not present in the map, the callback
   * will be used to create the value (with the result being stored in the cache for next time).
   *
   * @param item - The item to get.
   * @param cb - The callback to use to create the value when a cached value is not found.
   */
  get(e, n) {
    return this.items.has(e) || this.items.set(e, n(e)), this.items.get(e);
  }
}
function vI(t, e) {
  let n;
  const r = (...s) => (n || (n = {}, n.promise = new Promise((o, i) => {
    n.resolve = o, n.reject = i;
  })), clearTimeout(n.timeout), n.latestArgs = s, n.timeout = setTimeout(() => {
    const o = n;
    n = void 0;
    try {
      o.resolve(t(...o.latestArgs));
    } catch (i) {
      o.reject(i);
    }
  }, e), n.promise);
  return r.cancel = () => {
    n && clearTimeout(n.timeout);
  }, r;
}
const SU = /* @__PURE__ */ new WeakMap();
function dF(t, e) {
  if (typeof t != "object" || t === null) return;
  let n = SU.get(t);
  n || (n = { tags: {}, extras: {} }, SU.set(t, n)), e.tags && (n.tags = {
    ...n.tags,
    ...e.tags
  }), e.extras && (n.extras = {
    ...n.extras,
    ...e.extras
  });
}
async function qc(t, e) {
  return window.fetch(t, {
    // We want to make sure that the referrer is not sent to other domains.
    referrerPolicy: "strict-origin-when-cross-origin",
    ...e
  });
}
const rw = (t, e) => {
  const n = new window.Image(t, e);
  return n.referrerPolicy = "strict-origin-when-cross-origin", n;
};
class oi {
  /**
   * @deprecated Use `urlToArrayBuffer` instead.
   */
  static async dataUrlToArrayBuffer(e) {
    return qc(e).then(function(n) {
      return n.arrayBuffer();
    });
  }
  /**
   * @param url - The url of the file.
   */
  static async urlToArrayBuffer(e) {
    return await (await qc(e)).arrayBuffer();
  }
  static async urlToBlob(e) {
    return await (await qc(e)).blob();
  }
  static async urlToDataUrl(e) {
    if (e.startsWith("data:")) return e;
    const n = await oi.urlToBlob(e);
    return await oi.blobToDataUrl(n);
  }
  /**
   * Convert a file to a base64 encoded data url.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.toDataUrl(myImageFile)
   * ```
   *
   * @param file - The file as a blob.
   */
  static async blobToDataUrl(e) {
    return await new Promise((n, r) => {
      if (e) {
        const s = new FileReader();
        s.onload = () => n(s.result), s.onerror = (o) => r(o), s.onabort = (o) => r(o), s.readAsDataURL(e);
      }
    });
  }
  /**
   * Convert a file to a unicode text string.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.fileToDataUrl(myTextFile)
   * ```
   *
   * @param file - The file as a blob.
   */
  static async blobToText(e) {
    return await new Promise((n, r) => {
      if (e) {
        const s = new FileReader();
        s.onload = () => n(s.result), s.onerror = (o) => r(o), s.onabort = (o) => r(o), s.readAsText(e);
      }
    });
  }
  static rewriteMimeType(e, n) {
    return e.type === n ? e : e instanceof File ? new File([e], e.name, { type: n }) : new Blob([e], { type: n });
  }
}
function uF(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++)
    e = (e << 5) - e + t.charCodeAt(n), e |= 0;
  return e + "";
}
function TJ(t) {
  const e = new DataView(t);
  let n = 0;
  for (let r = 0; r < e.byteLength; r++)
    n = (n << 5) - n + e.getUint8(r), n |= 0;
  return n + "";
}
/*!
 * MIT License: https://github.com/ai/nanoid/blob/main/LICENSE
 * Modified code originally from <https://github.com/ai/nanoid>
 * Copyright 2017 Andrey Sitnik <andrey@sitnik.ru>
 *
 * `nanoid` is currently only distributed as an ES module. Some tools (jest, playwright) don't
 * properly support ESM-only code yet, and tldraw itself is distributed as both an ES module and a
 * CommonJS module. By including nanoid here, we can make sure it works well in every environment
 * where tldraw is used. We can also remove some unused features like custom alphabets.
 */
const CU = globalThis.crypto, A2e = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", M2e = 128;
let Eh, cm;
function O2e(t) {
  !Eh || Eh.length < t ? (Eh = new Uint8Array(t * M2e), CU.getRandomValues(Eh), cm = 0) : cm + t > Eh.length && (CU.getRandomValues(Eh), cm = 0), cm += t;
}
function D2e(t = 21) {
  O2e(t -= 0);
  let e = "";
  for (let n = cm - t; n < cm; n++)
    e += A2e[Eh[n] & 63];
  return e;
}
let N2e = D2e;
function bn(t) {
  return N2e(t);
}
/*!
 * MIT License: https://github.com/vHeemstra/is-apng/blob/main/license
 * Copyright (c) Philip van Heemstra
 */
function j2e(t) {
  const e = new Uint8Array(t);
  if (!e || !(typeof Buffer < "u" && Buffer.isBuffer(e) || e instanceof Uint8Array) || e.length < 16 || !(e[0] === 137 && e[1] === 80 && e[2] === 78 && e[3] === 71 && e[4] === 13 && e[5] === 10 && e[6] === 26 && e[7] === 10))
    return !1;
  function r(o, i, a, c, l = 1024) {
    if (!i)
      return -1;
    i = new RegExp(i, "g");
    const d = i.source.length, u = new TextDecoder(), f = o.length;
    if (typeof c > "u" && (c = f), a >= f || c <= 0 || a >= c)
      return -1;
    o = o.subarray(a, c);
    let p = -1, g = 0, y = 0, m = "";
    e: for (; g < o.length; ) {
      const v = g + l, b = o.subarray(g, v), x = u.decode(b, { stream: !0 }), w = m + x;
      let S, C = -1;
      for (; (S = i.exec(w)) !== null; ) {
        C = S.index - m.length, p = y + C;
        break e;
      }
      g = v, y += x.length;
      const _ = C > -1 ? C + d : x.length - d;
      m = x.slice(_);
    }
    return p >= 0 && (p += a >= 0 ? a : f + a), p;
  }
  const s = r(e, "IDAT", 12);
  return s >= 12 ? r(e, "acTL", 8, s) >= 8 : !1;
}
const R2e = (t) => new Uint8Array(t)[3] === 44;
/*!
 * MIT License
 * Modified code originally from <https://github.com/qzb/is-animated>
 * Copyright (c) 2016 Jzef Sokoowski <j.k.sokolowski@gmail.com>
 */
function _U(t, e) {
  let n = 0;
  for (; t[e + n]; )
    n += t[e + n] + 1;
  return n + 1;
}
function $2e(t) {
  return new TextDecoder("ascii").decode(t.slice(0, 3)) === "GIF";
}
function L2e(t) {
  const e = new Uint8Array(t);
  let n, r, s = 0, o = 0;
  if (!$2e(t))
    return !1;
  for (n = e[10] & 128, r = e[10] & 7, s += 6, s += 7, s += n ? 3 * Math.pow(2, r + 1) : 0; o < 2 && s < e.length; )
    switch (e[s]) {
      case 44:
        o += 1, n = e[s + 9] & 128, r = e[s + 9] & 7, s += 10, s += n ? 3 * Math.pow(2, r + 1) : 0, s += _U(e, s + 1) + 1;
        break;
      case 33:
        s += 2, s += _U(e, s);
        break;
      case 59:
        s = e.length;
        break;
      default:
        s = e.length;
        break;
    }
  return o > 1;
}
/*!
 * MIT License: https://github.com/alexgorbatchev/crc/blob/master/LICENSE
 * Copyright: 2014 Alex Gorbatchev
 * Code: crc32, https://github.com/alexgorbatchev/crc/blob/master/src/calculators/crc32.ts
 */
let NN = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
typeof Int32Array < "u" && (NN = new Int32Array(NN));
const F2e = (t, e) => {
  let n = ~~e ^ -1;
  for (let r = 0; r < t.length; r++)
    n = NN[(n ^ t[r]) & 255] ^ n >>> 8;
  return n ^ -1;
}, EU = 4, TU = 4;
class Nl {
  static isPng(e, n) {
    return e.getUint8(n + 0) === 137 && e.getUint8(n + 1) === 80 && e.getUint8(n + 2) === 78 && e.getUint8(n + 3) === 71 && e.getUint8(n + 4) === 13 && e.getUint8(n + 5) === 10 && e.getUint8(n + 6) === 26 && e.getUint8(n + 7) === 10;
  }
  static getChunkType(e, n) {
    return [
      String.fromCharCode(e.getUint8(n)),
      String.fromCharCode(e.getUint8(n + 1)),
      String.fromCharCode(e.getUint8(n + 2)),
      String.fromCharCode(e.getUint8(n + 3))
    ].join("");
  }
  static readChunks(e, n = 0) {
    const r = {};
    if (!Nl.isPng(e, n))
      throw new Error("Not a PNG");
    for (n += 8; n <= e.buffer.byteLength; ) {
      const s = n, o = e.getInt32(n);
      n += 4;
      const i = Nl.getChunkType(e, n);
      if (i === "IDAT" && r[i]) {
        n += o + EU + TU;
        continue;
      }
      if (i === "IEND")
        break;
      r[i] = {
        start: s,
        dataOffset: n + 4,
        size: o
      }, n += o + EU + TU;
    }
    return r;
  }
  static parsePhys(e, n) {
    return {
      ppux: e.getUint32(n),
      ppuy: e.getUint32(n + 4),
      unit: e.getUint8(n + 4)
    };
  }
  static findChunk(e, n) {
    return Nl.readChunks(e)[n];
  }
  static setPhysChunk(e, n = 1, r) {
    let s = 46, o = 0;
    const i = Nl.findChunk(e, "pHYs");
    i && (s = i.start, o = i.size);
    const a = Nl.findChunk(e, "IDAT");
    a && (s = a.start, o = 0);
    const c = new ArrayBuffer(21), l = new DataView(c);
    l.setUint32(0, 9), l.setUint8(4, 112), l.setUint8(5, 72), l.setUint8(6, 89), l.setUint8(7, 115);
    const d = 2835.5;
    l.setInt32(8, d * n), l.setInt32(12, d * n), l.setInt8(16, 1);
    const u = new Uint8Array(c.slice(4, 17));
    l.setInt32(17, F2e(u));
    const f = e.buffer.slice(0, s), p = e.buffer.slice(s + o);
    return new Blob([f, c, p], r);
  }
}
/*!
 * MIT License: https://github.com/sindresorhus/is-webp/blob/main/license
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
 */
function B2e(t) {
  return !t || t.length < 12 ? !1 : t[8] === 87 && t[9] === 69 && t[10] === 66 && t[11] === 80;
}
function z2e(t) {
  const e = new Uint8Array(t);
  return !B2e(e) || !e || e.length < 21 ? !1 : (e[20] >> 1 & 1) === 1;
}
const PJ = Object.freeze(["image/svg+xml"]), IJ = Object.freeze([
  "image/jpeg",
  "image/png",
  "image/webp"
]), kJ = Object.freeze([
  "image/gif",
  "image/apng",
  "image/avif"
]), nv = Object.freeze([
  ...IJ,
  ...PJ,
  ...kJ
]), bI = Object.freeze([
  "video/mp4",
  "video/webm",
  "video/quicktime"
]), U2e = Object.freeze([
  ...nv,
  ...bI
]);
U2e.join(",");
class ca {
  /**
   * Load a video from a url.
   * @public
   */
  static loadVideo(e) {
    return new Promise((n, r) => {
      const s = document.createElement("video");
      s.onloadeddata = () => n(s), s.onerror = (o) => {
        console.error(o), r(new Error("Could not load video"));
      }, s.crossOrigin = "anonymous", s.src = e;
    });
  }
  static async getVideoFrameAsDataUrl(e, n = 0) {
    const r = lF();
    let s = !1;
    const o = () => {
      if (!s)
        if (e.readyState >= e.HAVE_METADATA)
          s = !0, e.currentTime = n;
        else
          return;
      if (e.readyState >= e.HAVE_CURRENT_DATA) {
        const a = document.createElement("canvas");
        a.width = e.videoWidth, a.height = e.videoHeight;
        const c = a.getContext("2d");
        if (!c)
          throw new Error("Could not get 2d context");
        c.drawImage(e, 0, 0), r.resolve(a.toDataURL());
      }
    }, i = (a) => {
      console.error(a), r.reject(new Error("Could not get video frame"));
    };
    e.addEventListener("loadedmetadata", o), e.addEventListener("loadeddata", o), e.addEventListener("canplay", o), e.addEventListener("seeked", o), e.addEventListener("error", i), e.addEventListener("stalled", i), o();
    try {
      return await r;
    } finally {
      e.removeEventListener("loadedmetadata", o), e.removeEventListener("loadeddata", o), e.removeEventListener("canplay", o), e.removeEventListener("seeked", o), e.removeEventListener("error", i), e.removeEventListener("stalled", i);
    }
  }
  /**
   * Load an image from a url.
   * @public
   */
  static getImageAndDimensions(e) {
    return new Promise((n, r) => {
      const s = rw();
      s.onload = () => {
        let o;
        s.naturalWidth ? o = {
          w: s.naturalWidth,
          h: s.naturalHeight
        } : (document.body.appendChild(s), o = {
          w: s.clientWidth,
          h: s.clientHeight
        }, document.body.removeChild(s)), n({ ...o, image: s });
      }, s.onerror = (o) => {
        console.error(o), r(new Error("Could not load image"));
      }, s.crossOrigin = "anonymous", s.referrerPolicy = "strict-origin-when-cross-origin", s.style.visibility = "hidden", s.style.position = "absolute", s.style.opacity = "0", s.style.zIndex = "-9999", s.src = e;
    });
  }
  /**
   * Get the size of a video blob
   *
   * @param blob - A SharedBlob containing the video
   * @public
   */
  static async getVideoSize(e) {
    return ca.usingObjectURL(e, async (n) => {
      const r = await ca.loadVideo(n);
      return { w: r.videoWidth, h: r.videoHeight };
    });
  }
  /**
   * Get the size of an image blob
   *
   * @param blob - A Blob containing the image.
   * @public
   */
  static async getImageSize(e) {
    const { w: n, h: r } = await ca.usingObjectURL(e, ca.getImageAndDimensions);
    try {
      if (e.type === "image/png") {
        const s = new DataView(await e.arrayBuffer());
        if (Nl.isPng(s, 0)) {
          const o = Nl.findChunk(s, "pHYs");
          if (o) {
            const i = Nl.parsePhys(s, o.dataOffset);
            if (i.unit === 0 && i.ppux === i.ppuy) {
              const c = Math.max(i.ppux / 2834.645669291339, 1);
              return {
                w: Math.round(n / c),
                h: Math.round(r / c)
              };
            }
          }
        }
      }
    } catch (s) {
      return console.error(s), { w: n, h: r };
    }
    return { w: n, h: r };
  }
  static async isAnimated(e) {
    return e.type === "image/gif" ? L2e(await e.arrayBuffer()) : e.type === "image/avif" ? R2e(await e.arrayBuffer()) : e.type === "image/webp" ? z2e(await e.arrayBuffer()) : e.type === "image/apng" ? j2e(await e.arrayBuffer()) : !1;
  }
  static isAnimatedImageType(e) {
    return kJ.includes(e || "");
  }
  static isStaticImageType(e) {
    return IJ.includes(e || "");
  }
  static isVectorImageType(e) {
    return PJ.includes(e || "");
  }
  static isImageType(e) {
    return nv.includes(e || "");
  }
  static async usingObjectURL(e, n) {
    const r = URL.createObjectURL(e);
    try {
      return await n(r);
    } finally {
      URL.revokeObjectURL(r);
    }
  }
}
function kt(t, e, n) {
  return t + (e - t) * n;
}
function sw(t, e, n) {
  return (n - t) / (e - t);
}
function lg(t = "") {
  let e = 0, n = 0, r = 0, s = 0;
  function o() {
    const i = e ^ e << 11;
    return e = n, n = r, r = s, s ^= (s >>> 19 ^ i ^ i >>> 8) >>> 0, s / 4294967296 * 2;
  }
  for (let i = 0; i < t.length + 64; i++)
    e ^= t.charCodeAt(i) | 0, o();
  return o;
}
function ql(t, e, n, r = !1) {
  const [s, o] = e, [i, a] = n, c = i + (t - s) / (o - s) * (a - i);
  return r ? i < a ? Math.max(Math.min(c, a), i) : Math.max(Math.min(c, i), a) : c;
}
function rc(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Fr(t, e) {
  if (rc(t, e))
    return t[e];
}
function px(t) {
  return Object.keys(t);
}
function Er(t) {
  return Object.values(t);
}
function ai(t) {
  return Object.entries(t);
}
function AJ(t) {
  return Object.fromEntries(t);
}
function gx(t, e) {
  const n = {};
  let r = !1;
  for (const [s, o] of ai(t))
    e(s, o) ? n[s] = o : r = !0;
  return r ? n : t;
}
function Qf(t, e) {
  const n = {};
  for (const [r, s] of ai(t)) {
    const o = e(r, s);
    n[r] = o;
  }
  return n;
}
function MJ(t, e) {
  if (t === e) return !0;
  const n = new Set(Object.keys(t)), r = new Set(Object.keys(e));
  if (n.size !== r.size) return !1;
  for (const s of n)
    if (!r.has(s) || !Object.is(t[s], e[s])) return !1;
  return !0;
}
function H2e(t, e) {
  const n = [];
  for (const r in t)
    Object.is(t[r], e[r]) || n.push(r);
  return n;
}
function V2e(t, e, n = 1e-6) {
  return pOe(t, e, (r, s) => {
    if (typeof r == "number" && typeof s == "number")
      return Math.abs(r - s) < n;
  });
}
const Ob = {
  Good: "#40C057",
  Mid: "#FFC078",
  Poor: "#E03131"
}, W2e = Ob.Good;
class OJ {
  constructor() {
    P(this, "startTime", 0);
    P(this, "name", "");
    P(this, "frames", 0);
    P(this, "started", !1);
    P(this, "frame", null);
    // eslint-disable-next-line local/prefer-class-methods
    P(this, "recordFrame", () => {
      this.frames++, this.started && (this.frame = requestAnimationFrame(this.recordFrame));
    });
  }
  start(e) {
    this.name = e, this.frames = 0, this.started = !0, this.frame !== null && cancelAnimationFrame(this.frame), this.frame = requestAnimationFrame(this.recordFrame), this.startTime = performance.now();
  }
  stop() {
    this.started = !1, this.frame !== null && cancelAnimationFrame(this.frame);
    const e = (performance.now() - this.startTime) / 1e3, n = e === 0 ? 0 : Math.floor(this.frames / e), r = n > 55 ? Ob.Good : n > 30 ? Ob.Mid : Ob.Poor, s = r === Ob.Mid ? "black" : "white", o = this.name[0].toUpperCase() + this.name.slice(1);
    console.debug(
      `%cPerf%c ${o} %c${n}%c fps`,
      `color: white; background: ${W2e};padding: 2px;border-radius: 3px;`,
      "font-weight: normal",
      `font-weight: bold; padding: 2px; background: ${r};color: ${s};`,
      "font-weight: normal"
    );
  }
  isStarted() {
    return this.started;
  }
}
function K2e(t) {
  const e = G2e(t.chars), n = Y2e(
    e,
    t.firstPositive,
    t.mostPositive,
    t.mostNegative
  ), r = t.jitterRange ?? Math.floor(Math.pow(e.length, 3) / 5), s = q2e(r, e.length);
  return {
    chars: t.chars,
    byChar: e.byChar,
    byCode: e.byCode,
    length: e.length,
    first: e.byCode[0],
    last: e.byCode[e.length - 1],
    firstPositive: n.firstPositive,
    mostPositive: n.mostPositive,
    firstNegative: n.firstNegative,
    mostNegative: n.mostNegative,
    jitterRange: r,
    paddingDict: s
  };
}
function G2e(t) {
  const e = {}, n = {}, r = t.length;
  for (let s = 0; s < r; s++) {
    const o = t[s];
    e[s] = o, n[o] = s;
  }
  return {
    byCode: e,
    byChar: n,
    length: r
  };
}
function Y2e(t, e, n, r) {
  const s = e ? t.byChar[e] : Math.ceil(t.length / 2), o = n ? t.byChar[n] : t.length - 1, i = r ? t.byChar[r] : 0;
  if (s === void 0 || o === void 0 || i === void 0)
    throw new Error("invalid charSet");
  if (o - s < 3)
    throw new Error(
      "mostPositive must be at least 3 characters away from neutral"
    );
  if (s - i < 3)
    throw new Error(
      "mostNegative must be at least 3 characters away from neutral"
    );
  return {
    firstPositive: t.byCode[s],
    mostPositive: t.byCode[o],
    firstNegative: t.byCode[s - 1],
    mostNegative: t.byCode[i]
  };
}
function q2e(t, e) {
  const n = {};
  for (let r = 0; r < 100 && (n[r] = Math.pow(e, r), !(n[r] > t)); r++)
    ;
  return n;
}
var xM = null;
function xI() {
  return xM || (xM = K2e({
    // Base62 are all the alphanumeric characters, database and user friendly
    // For shorter strings and more room you could opt for more characters
    chars: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    // This gives us nice human readable keys to start with a0 a1 etc
    firstPositive: "a",
    mostPositive: "z",
    mostNegative: "A"
  }));
}
function lf(t, e, n) {
  const r = n.byChar[t], s = n.byChar[e];
  return Math.abs(r - s);
}
function fF(t, e) {
  const n = t[0];
  if (n > e.mostPositive || n < e.mostNegative)
    throw new Error("invalid firstChar on key");
  return n === e.mostPositive ? lf(n, e.firstPositive, e) + 1 + gE(t.slice(1), "positive", e) : n === e.mostNegative ? lf(n, e.firstNegative, e) + 1 + gE(t.slice(1), "negative", e) : n >= e.firstPositive ? lf(n, e.firstPositive, e) + 2 : lf(n, e.firstNegative, e) + 2;
}
function gE(t, e, n) {
  const r = t[0];
  if (r > n.mostPositive || r < n.mostNegative)
    throw new Error("invalid firstChar on key");
  return r === n.mostPositive && e === "positive" ? lf(r, n.mostNegative, n) + 1 + gE(t.slice(1), e, n) : r === n.mostNegative && e === "negative" ? lf(r, n.mostPositive, n) + 1 + gE(t.slice(1), e, n) : e === "positive" ? lf(r, n.mostNegative, n) + 2 : lf(r, n.mostPositive, n) + 2;
}
function wI(t, e, n, r, s) {
  const o = Math.max(t.length, e.length);
  return n === "start" ? [t.padStart(o, r), e.padStart(o, r)] : [t.padEnd(o, r), e.padEnd(o, r)];
}
function X2e(t, e, n) {
  let [r, s] = wI(
    t,
    e,
    "end",
    n.first
  ), o = jN(r, s, n);
  o === 1 && (r = r.padEnd(r.length + 1, n.first), o = n.length);
  const i = jJ(Math.floor(o / 2), n);
  return hF(r, i, n);
}
function jN(t, e, n) {
  const [r, s] = wI(t, e, "end", n.first).sort(), o = DJ(s, r, n);
  return Z2e(o, n);
}
function hF(t, e, n) {
  const r = n.length, [s, o] = wI(t, e, "start", n.first), i = [];
  let a = 0;
  for (let c = s.length - 1; c >= 0; c--) {
    const l = n.byChar[s[c]], d = n.byChar[o[c]], u = l + d + a;
    a = Math.floor(u / r);
    const f = u % r;
    i.unshift(n.byCode[f]);
  }
  return a > 0 && i.unshift(n.byCode[a]), i.join("");
}
function DJ(t, e, n, r = !0) {
  const s = n.length, [o, i] = wI(t, e, "start", n.first), a = [];
  let c = 0;
  for (let l = o.length - 1; l >= 0; l--) {
    let d = n.byChar[o[l]];
    const u = n.byChar[i[l]] + c;
    d < u ? (c = 1, d += s) : c = 0;
    const f = d - u;
    a.unshift(n.byCode[f]);
  }
  if (c > 0)
    throw new Error(
      "Subtraction result is negative. Ensure a is greater than or equal to b."
    );
  for (; r && a.length > 1 && a[0] === n.first; )
    a.shift();
  return a.join("");
}
function NJ(t, e) {
  return hF(t, e.byCode[1], e);
}
function RN(t, e) {
  return DJ(t, e.byCode[1], e, !1);
}
function jJ(t, e) {
  if (t === 0)
    return e.byCode[0];
  let n = "";
  const r = e.length;
  for (; t > 0; )
    n = e.byCode[t % r] + n, t = Math.floor(t / r);
  return n;
}
function Z2e(t, e) {
  let n = 0;
  const r = t.length, s = e.length;
  for (let o = 0; o < r; o++)
    n += e.byChar[t[o]] * Math.pow(s, r - o - 1);
  return n;
}
function Q2e(t) {
  return t.firstPositive + t.byCode[0];
}
function J2e(t, e) {
  return fF(t, e) === t.length;
}
function PU(t, e) {
  mE(t, e);
}
function mE(t, e) {
  const n = LJ(t, e), r = fF(n, e);
  if (r > t.length)
    throw new Error("invalid order key length: " + t);
  return t.slice(0, r);
}
function RJ(t, e) {
  if (!J2e(t, e))
    throw new Error("invalid integer length: " + t);
}
function $J(t, e) {
  RJ(t, e);
  const [n, r] = FJ(t, e);
  if (r.split("").some((i) => i !== e.byCode[e.length - 1])) {
    const i = NJ(r, e);
    return n + i;
  }
  const o = tDe(n, e);
  return BJ(o, "lower", e);
}
function eDe(t, e) {
  RJ(t, e);
  const [n, r] = FJ(t, e);
  if (r.split("").some((i) => i !== e.byCode[0])) {
    const i = RN(r, e);
    return n + i;
  }
  const o = nDe(n, e);
  return BJ(o, "upper", e);
}
function LJ(t, e) {
  let n = 0;
  if (t[0] === e.mostPositive)
    for (; t[n] === e.mostPositive; )
      n = n + 1;
  if (t[0] === e.mostNegative)
    for (; t[n] === e.mostNegative; )
      n = n + 1;
  return t.slice(0, n + 1);
}
function FJ(t, e) {
  const n = LJ(t, e), r = t.slice(n.length);
  return [n, r];
}
function tDe(t, e) {
  const n = t >= e.firstPositive, r = NJ(t, e), s = t[t.length - 1] === e.mostPositive, o = r[r.length - 1] === e.mostPositive;
  return n && o ? r + e.mostNegative : !n && s ? t.slice(0, t.length - 1) : r;
}
function nDe(t, e) {
  const n = t >= e.firstPositive, r = t[t.length - 1] === e.mostNegative;
  if (n && r) {
    const s = t.slice(0, t.length - 1);
    return RN(s, e);
  }
  return !n && r ? t + e.mostPositive : RN(t, e);
}
function BJ(t, e, n) {
  const r = fF(t, n), s = e === "upper" ? n.byCode[n.length - 1] : n.byCode[0];
  return t + s.repeat(r - t.length);
}
function zJ(t, e) {
  const n = jJ(
    Math.floor(Math.random() * e.jitterRange),
    e
  );
  return hF(t, n, e);
}
function rDe(t, e, n) {
  const r = t.padEnd(
    t.length + e,
    n.first
  );
  return zJ(r, n);
}
function sDe(t, e, n) {
  const r = mE(t, n), s = $J(r, n);
  let o = 0;
  if (e !== null) {
    const a = jN(t, e, n);
    a < n.jitterRange + 1 && (o = Math.max(o, IU(a, n)));
  }
  const i = jN(t, s, n);
  return i < n.jitterRange + 1 && (o = Math.max(
    o,
    IU(i, n)
  )), o;
}
function IU(t, e) {
  const n = e.jitterRange - t, r = Object.entries(e.paddingDict).find(
    ([s, o]) => o > n
  );
  return r ? parseInt(r[0]) : 0;
}
function UJ(t, e, n = xI()) {
  if (t !== null && PU(t, n), e !== null && PU(e, n), t === null && e === null)
    return Q2e(n);
  if (t === null) {
    const r = mE(e, n);
    return eDe(r, n);
  }
  if (e === null) {
    const r = mE(t, n);
    return $J(r, n);
  }
  if (t >= e)
    throw new Error(t + " >= " + e);
  return X2e(t, e, n);
}
function HJ(t, e, n, r = xI()) {
  return KJ(
    t,
    e,
    n,
    r,
    UJ,
    HJ
  );
}
function VJ(t, e, n = xI()) {
  const r = UJ(t, e, n), s = sDe(r, e, n);
  return s ? rDe(r, s, n) : zJ(r, n);
}
function WJ(t, e, n, r = xI()) {
  return KJ(
    t,
    e,
    n,
    r,
    VJ,
    WJ
  );
}
function KJ(t, e, n, r, s, o) {
  if (n === 0)
    return [];
  if (n === 1)
    return [s(t, e, r)];
  if (e == null) {
    let c = s(t, e, r);
    const l = [c];
    for (let d = 0; d < n - 1; d++)
      c = s(c, e, r), l.push(c);
    return l;
  }
  if (t == null) {
    let c = s(t, e, r);
    const l = [c];
    for (let d = 0; d < n - 1; d++)
      c = s(t, c, r), l.push(c);
    return l.reverse(), l;
  }
  const i = Math.floor(n / 2), a = s(t, e, r);
  return [
    ...o(t, a, i, r),
    a,
    ...o(a, e, n - i - 1, r)
  ];
}
const rv = process.env.NODE_ENV === "test" ? HJ : WJ, GJ = "a0";
function oDe(t) {
  try {
    VJ(t, null);
  } catch {
    throw new Error("invalid index: " + t);
  }
}
function sy(t, e, n) {
  return rv(t ?? null, e ?? null, n);
}
function wM(t, e) {
  return rv(t ?? null, null, e);
}
function oy(t, e) {
  return rv(t ?? null, e ?? null, 1)[0];
}
function Bc(t = null) {
  return rv(t, null, 1)[0];
}
function iDe(t = null) {
  return rv(null, t, 1)[0];
}
function ow(t, e = "a1") {
  return [e, ...rv(e, null, t)];
}
function Js(t, e) {
  return t.index < e.index ? -1 : t.index > e.index ? 1 : 0;
}
function aDe(t, e) {
  return t.id > e.id ? 1 : -1;
}
function pF(t) {
  try {
    return localStorage.getItem(t);
  } catch {
    return null;
  }
}
function gF(t, e) {
  try {
    localStorage.setItem(t, e);
  } catch {
  }
}
function cDe() {
  try {
    localStorage.clear();
  } catch {
  }
}
function YJ(t) {
  try {
    return sessionStorage.getItem(t);
  } catch {
    return null;
  }
}
function mF(t, e) {
  try {
    sessionStorage.setItem(t, e);
  } catch {
  }
}
function qJ(t) {
  try {
    sessionStorage.removeItem(t);
  } catch {
  }
}
function lDe() {
  try {
    sessionStorage.clear();
  } catch {
  }
}
const dDe = () => typeof process < "u" && process.env.NODE_ENV === "test" && // @ts-expect-error
!globalThis.__FORCE_RAF_IN_TESTS__, lm = [], uDe = 60, XJ = Math.floor(1e3 / uDe) * 0.9;
let SM, h1, CM = -XJ;
const kU = () => {
  const t = lm.splice(0, lm.length);
  for (const e of t)
    e();
};
function ZJ(t = !1) {
  if (SM) return;
  const e = Date.now();
  if (e - CM < XJ) {
    SM = requestAnimationFrame(() => {
      SM = void 0, ZJ(!0);
    });
    return;
  }
  if (t) {
    if (h1) return;
    CM = e, kU();
  } else {
    if (h1) return;
    h1 = requestAnimationFrame(() => {
      h1 = void 0, CM = e, kU();
    });
  }
}
function yF(t) {
  return dDe() ? (t(), () => {
  }) : (lm.includes(t) || (lm.push(t), ZJ()), () => {
    const e = lm.indexOf(t);
    e > -1 && lm.splice(e, 1);
  });
}
class fDe {
  constructor() {
    P(this, "timeouts", /* @__PURE__ */ new Map());
    P(this, "intervals", /* @__PURE__ */ new Map());
    P(this, "rafs", /* @__PURE__ */ new Map());
    this.setTimeout = this.setTimeout.bind(this), this.setInterval = this.setInterval.bind(this), this.requestAnimationFrame = this.requestAnimationFrame.bind(this), this.dispose = this.dispose.bind(this);
  }
  /** @public */
  setTimeout(e, n, r, ...s) {
    const o = window.setTimeout(n, r, s), i = this.timeouts.get(e) ?? [];
    return this.timeouts.set(e, [...i, o]), o;
  }
  /** @public */
  setInterval(e, n, r, ...s) {
    const o = window.setInterval(n, r, s), i = this.intervals.get(e) ?? [];
    return this.intervals.set(e, [...i, o]), o;
  }
  /** @public */
  requestAnimationFrame(e, n) {
    const r = window.requestAnimationFrame(n), s = this.rafs.get(e) ?? [];
    return this.rafs.set(e, [...s, r]), r;
  }
  /** @public */
  dispose(e) {
    var n, r, s;
    (n = this.timeouts.get(e)) == null || n.forEach((o) => clearTimeout(o)), (r = this.intervals.get(e)) == null || r.forEach((o) => clearInterval(o)), (s = this.rafs.get(e)) == null || s.forEach((o) => cancelAnimationFrame(o)), this.timeouts.delete(e), this.intervals.delete(e), this.rafs.delete(e);
  }
  disposeAll() {
    for (const e of this.timeouts.keys())
      this.dispose(e);
  }
  forContext(e) {
    return {
      setTimeout: (n, r, ...s) => this.setTimeout(e, n, r, s),
      setInterval: (n, r, ...s) => this.setInterval(e, n, r, s),
      requestAnimationFrame: (n) => this.requestAnimationFrame(e, n),
      dispose: () => this.dispose(e)
    };
  }
}
const bt = (t, e) => {
  try {
    return new URL(t, e);
  } catch {
    return;
  }
};
function hDe(t) {
  return t !== void 0;
}
function pDe() {
  return typeof globalThis < "u" && globalThis.structuredClone ? [globalThis.structuredClone, !0] : typeof global < "u" && global.structuredClone ? [global.structuredClone, !0] : typeof window < "u" && window.structuredClone ? [window.structuredClone, !0] : [(t) => t && JSON.parse(JSON.stringify(t)), !1];
}
const QJ = pDe(), mr = QJ[0];
QJ[1];
const JJ = Object.getPrototypeOf(mr({}));
Xf(
  "@tldraw/utils",
  "3.15.5",
  "esm"
);
var Gv = function(t) {
  return t && t.Math === Math && t;
}, jo = (
  // eslint-disable-next-line es/no-global-this -- safe
  Gv(typeof globalThis == "object" && globalThis) || Gv(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  Gv(typeof self == "object" && self) || Gv(typeof yn == "object" && yn) || Gv(typeof yn == "object" && yn) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), vF = {}, Ro = function(t) {
  try {
    return !!t();
  } catch {
    return !0;
  }
}, gDe = Ro, fu = !gDe(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
}), mDe = Ro, SI = !mDe(function() {
  var t = (function() {
  }).bind();
  return typeof t != "function" || t.hasOwnProperty("prototype");
}), yDe = SI, p1 = Function.prototype.call, hu = yDe ? p1.bind(p1) : function() {
  return p1.apply(p1, arguments);
}, eee = {}, tee = {}.propertyIsEnumerable, nee = Object.getOwnPropertyDescriptor, vDe = nee && !tee.call({ 1: 2 }, 1);
eee.f = vDe ? function(e) {
  var n = nee(this, e);
  return !!n && n.enumerable;
} : tee;
var bF = function(t, e) {
  return {
    enumerable: !(t & 1),
    configurable: !(t & 2),
    writable: !(t & 4),
    value: e
  };
}, ree = SI, see = Function.prototype, $N = see.call, bDe = ree && see.bind.bind($N, $N), Bs = ree ? bDe : function(t) {
  return function() {
    return $N.apply(t, arguments);
  };
}, oee = Bs, xDe = oee({}.toString), wDe = oee("".slice), sv = function(t) {
  return wDe(xDe(t), 8, -1);
}, SDe = Bs, CDe = Ro, _De = sv, _M = Object, EDe = SDe("".split), TDe = CDe(function() {
  return !_M("z").propertyIsEnumerable(0);
}) ? function(t) {
  return _De(t) === "String" ? EDe(t, "") : _M(t);
} : _M, iee = function(t) {
  return t == null;
}, PDe = iee, IDe = TypeError, ov = function(t) {
  if (PDe(t)) throw new IDe("Can't call method on " + t);
  return t;
}, kDe = TDe, ADe = ov, CI = function(t) {
  return kDe(ADe(t));
}, EM = typeof document == "object" && document.all, gi = typeof EM > "u" && EM !== void 0 ? function(t) {
  return typeof t == "function" || t === EM;
} : function(t) {
  return typeof t == "function";
}, MDe = gi, pu = function(t) {
  return typeof t == "object" ? t !== null : MDe(t);
}, TM = jo, ODe = gi, DDe = function(t) {
  return ODe(t) ? t : void 0;
}, _I = function(t, e) {
  return arguments.length < 2 ? DDe(TM[t]) : TM[t] && TM[t][e];
}, NDe = Bs, aee = NDe({}.isPrototypeOf), jDe = jo, AU = jDe.navigator, MU = AU && AU.userAgent, RDe = MU ? String(MU) : "", cee = jo, PM = RDe, OU = cee.process, DU = cee.Deno, NU = OU && OU.versions || DU && DU.version, jU = NU && NU.v8, Dc, yE;
jU && (Dc = jU.split("."), yE = Dc[0] > 0 && Dc[0] < 4 ? 1 : +(Dc[0] + Dc[1]));
!yE && PM && (Dc = PM.match(/Edge\/(\d+)/), (!Dc || Dc[1] >= 74) && (Dc = PM.match(/Chrome\/(\d+)/), Dc && (yE = +Dc[1])));
var $De = yE, RU = $De, LDe = Ro, FDe = jo, BDe = FDe.String, lee = !!Object.getOwnPropertySymbols && !LDe(function() {
  var t = Symbol("symbol detection");
  return !BDe(t) || !(Object(t) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && RU && RU < 41;
}), zDe = lee, dee = zDe && !Symbol.sham && typeof Symbol.iterator == "symbol", UDe = _I, HDe = gi, VDe = aee, WDe = dee, KDe = Object, uee = WDe ? function(t) {
  return typeof t == "symbol";
} : function(t) {
  var e = UDe("Symbol");
  return HDe(e) && VDe(e.prototype, KDe(t));
}, GDe = String, YDe = function(t) {
  try {
    return GDe(t);
  } catch {
    return "Object";
  }
}, qDe = gi, XDe = YDe, ZDe = TypeError, xF = function(t) {
  if (qDe(t)) return t;
  throw new ZDe(XDe(t) + " is not a function");
}, QDe = xF, JDe = iee, wF = function(t, e) {
  var n = t[e];
  return JDe(n) ? void 0 : QDe(n);
}, IM = hu, kM = gi, AM = pu, eNe = TypeError, tNe = function(t, e) {
  var n, r;
  if (e === "string" && kM(n = t.toString) && !AM(r = IM(n, t)) || kM(n = t.valueOf) && !AM(r = IM(n, t)) || e !== "string" && kM(n = t.toString) && !AM(r = IM(n, t))) return r;
  throw new eNe("Can't convert object to primitive value");
}, fee = { exports: {} }, $U = jo, nNe = Object.defineProperty, SF = function(t, e) {
  try {
    nNe($U, t, { value: e, configurable: !0, writable: !0 });
  } catch {
    $U[t] = e;
  }
  return e;
}, rNe = jo, sNe = SF, LU = "__core-js_shared__", FU = fee.exports = rNe[LU] || sNe(LU, {});
(FU.versions || (FU.versions = [])).push({
  version: "3.48.0",
  mode: "global",
  copyright: " 20132025 Denis Pushkarev (zloirock.ru), 20252026 CoreJS Company (core-js.io). All rights reserved.",
  license: "https://github.com/zloirock/core-js/blob/v3.48.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var CF = fee.exports, BU = CF, _F = function(t, e) {
  return BU[t] || (BU[t] = e || {});
}, oNe = ov, iNe = Object, B0 = function(t) {
  return iNe(oNe(t));
}, aNe = Bs, cNe = B0, lNe = aNe({}.hasOwnProperty), Jf = Object.hasOwn || function(e, n) {
  return lNe(cNe(e), n);
}, dNe = Bs, uNe = 0, fNe = Math.random(), hNe = dNe(1.1.toString), hee = function(t) {
  return "Symbol(" + (t === void 0 ? "" : t) + ")_" + hNe(++uNe + fNe, 36);
}, pNe = jo, gNe = _F, zU = Jf, mNe = hee, yNe = lee, vNe = dee, dm = pNe.Symbol, MM = gNe("wks"), bNe = vNe ? dm.for || dm : dm && dm.withoutSetter || mNe, gu = function(t) {
  return zU(MM, t) || (MM[t] = yNe && zU(dm, t) ? dm[t] : bNe("Symbol." + t)), MM[t];
}, xNe = hu, UU = pu, HU = uee, wNe = wF, SNe = tNe, CNe = gu, _Ne = TypeError, ENe = CNe("toPrimitive"), TNe = function(t, e) {
  if (!UU(t) || HU(t)) return t;
  var n = wNe(t, ENe), r;
  if (n) {
    if (e === void 0 && (e = "default"), r = xNe(n, t, e), !UU(r) || HU(r)) return r;
    throw new _Ne("Can't convert object to primitive value");
  }
  return e === void 0 && (e = "number"), SNe(t, e);
}, PNe = TNe, INe = uee, pee = function(t) {
  var e = PNe(t, "string");
  return INe(e) ? e : e + "";
}, kNe = jo, VU = pu, LN = kNe.document, ANe = VU(LN) && VU(LN.createElement), gee = function(t) {
  return ANe ? LN.createElement(t) : {};
}, MNe = fu, ONe = Ro, DNe = gee, mee = !MNe && !ONe(function() {
  return Object.defineProperty(DNe("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
}), NNe = fu, jNe = hu, RNe = eee, $Ne = bF, LNe = CI, FNe = pee, BNe = Jf, zNe = mee, WU = Object.getOwnPropertyDescriptor;
vF.f = NNe ? WU : function(e, n) {
  if (e = LNe(e), n = FNe(n), zNe) try {
    return WU(e, n);
  } catch {
  }
  if (BNe(e, n)) return $Ne(!jNe(RNe.f, e, n), e[n]);
};
var dg = {}, UNe = fu, HNe = Ro, yee = UNe && HNe(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype !== 42;
}), VNe = pu, WNe = String, KNe = TypeError, ug = function(t) {
  if (VNe(t)) return t;
  throw new KNe(WNe(t) + " is not an object");
}, GNe = fu, YNe = mee, qNe = yee, g1 = ug, KU = pee, XNe = TypeError, OM = Object.defineProperty, ZNe = Object.getOwnPropertyDescriptor, DM = "enumerable", NM = "configurable", jM = "writable";
dg.f = GNe ? qNe ? function(e, n, r) {
  if (g1(e), n = KU(n), g1(r), typeof e == "function" && n === "prototype" && "value" in r && jM in r && !r[jM]) {
    var s = ZNe(e, n);
    s && s[jM] && (e[n] = r.value, r = {
      configurable: NM in r ? r[NM] : s[NM],
      enumerable: DM in r ? r[DM] : s[DM],
      writable: !1
    });
  }
  return OM(e, n, r);
} : OM : function(e, n, r) {
  if (g1(e), n = KU(n), g1(r), YNe) try {
    return OM(e, n, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw new XNe("Accessors not supported");
  return "value" in r && (e[n] = r.value), e;
};
var QNe = fu, JNe = dg, eje = bF, EF = QNe ? function(t, e, n) {
  return JNe.f(t, e, eje(1, n));
} : function(t, e, n) {
  return t[e] = n, t;
}, vee = { exports: {} }, FN = fu, tje = Jf, bee = Function.prototype, nje = FN && Object.getOwnPropertyDescriptor, TF = tje(bee, "name"), rje = TF && (function() {
}).name === "something", sje = TF && (!FN || FN && nje(bee, "name").configurable), oje = {
  EXISTS: TF,
  PROPER: rje,
  CONFIGURABLE: sje
}, ije = Bs, aje = gi, BN = CF, cje = ije(Function.toString);
aje(BN.inspectSource) || (BN.inspectSource = function(t) {
  return cje(t);
});
var xee = BN.inspectSource, lje = jo, dje = gi, GU = lje.WeakMap, uje = dje(GU) && /native code/.test(String(GU)), fje = _F, hje = hee, YU = fje("keys"), wee = function(t) {
  return YU[t] || (YU[t] = hje(t));
}, PF = {}, pje = uje, See = jo, gje = pu, mje = EF, RM = Jf, $M = CF, yje = wee, vje = PF, qU = "Object already initialized", zN = See.TypeError, bje = See.WeakMap, vE, iw, bE, xje = function(t) {
  return bE(t) ? iw(t) : vE(t, {});
}, wje = function(t) {
  return function(e) {
    var n;
    if (!gje(e) || (n = iw(e)).type !== t)
      throw new zN("Incompatible receiver, " + t + " required");
    return n;
  };
};
if (pje || $M.state) {
  var ml = $M.state || ($M.state = new bje());
  ml.get = ml.get, ml.has = ml.has, ml.set = ml.set, vE = function(t, e) {
    if (ml.has(t)) throw new zN(qU);
    return e.facade = t, ml.set(t, e), e;
  }, iw = function(t) {
    return ml.get(t) || {};
  }, bE = function(t) {
    return ml.has(t);
  };
} else {
  var Dg = yje("state");
  vje[Dg] = !0, vE = function(t, e) {
    if (RM(t, Dg)) throw new zN(qU);
    return e.facade = t, mje(t, Dg, e), e;
  }, iw = function(t) {
    return RM(t, Dg) ? t[Dg] : {};
  }, bE = function(t) {
    return RM(t, Dg);
  };
}
var Cee = {
  set: vE,
  get: iw,
  has: bE,
  enforce: xje,
  getterFor: wje
}, IF = Bs, Sje = Ro, Cje = gi, m1 = Jf, UN = fu, _je = oje.CONFIGURABLE, Eje = xee, _ee = Cee, Tje = _ee.enforce, Pje = _ee.get, XU = String, qC = Object.defineProperty, Ije = IF("".slice), kje = IF("".replace), Aje = IF([].join), Mje = UN && !Sje(function() {
  return qC(function() {
  }, "length", { value: 8 }).length !== 8;
}), Oje = String(String).split("String"), Dje = vee.exports = function(t, e, n) {
  Ije(XU(e), 0, 7) === "Symbol(" && (e = "[" + kje(XU(e), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), n && n.getter && (e = "get " + e), n && n.setter && (e = "set " + e), (!m1(t, "name") || _je && t.name !== e) && (UN ? qC(t, "name", { value: e, configurable: !0 }) : t.name = e), Mje && n && m1(n, "arity") && t.length !== n.arity && qC(t, "length", { value: n.arity });
  try {
    n && m1(n, "constructor") && n.constructor ? UN && qC(t, "prototype", { writable: !1 }) : t.prototype && (t.prototype = void 0);
  } catch {
  }
  var r = Tje(t);
  return m1(r, "source") || (r.source = Aje(Oje, typeof e == "string" ? e : "")), t;
};
Function.prototype.toString = Dje(function() {
  return Cje(this) && Pje(this).source || Eje(this);
}, "toString");
var Nje = vee.exports, jje = gi, Rje = dg, $je = Nje, Lje = SF, Eee = function(t, e, n, r) {
  r || (r = {});
  var s = r.enumerable, o = r.name !== void 0 ? r.name : e;
  if (jje(n) && $je(n, o, r), r.global)
    s ? t[e] = n : Lje(e, n);
  else {
    try {
      r.unsafe ? t[e] && (s = !0) : delete t[e];
    } catch {
    }
    s ? t[e] = n : Rje.f(t, e, {
      value: n,
      enumerable: !1,
      configurable: !r.nonConfigurable,
      writable: !r.nonWritable
    });
  }
  return t;
}, Tee = {}, Fje = Math.ceil, Bje = Math.floor, zje = Math.trunc || function(e) {
  var n = +e;
  return (n > 0 ? Bje : Fje)(n);
}, Uje = zje, fg = function(t) {
  var e = +t;
  return e !== e || e === 0 ? 0 : Uje(e);
}, Hje = fg, Vje = Math.max, Wje = Math.min, Kje = function(t, e) {
  var n = Hje(t);
  return n < 0 ? Vje(n + e, 0) : Wje(n, e);
}, Gje = fg, Yje = Math.min, Pee = function(t) {
  var e = Gje(t);
  return e > 0 ? Yje(e, 9007199254740991) : 0;
}, qje = Pee, z0 = function(t) {
  return qje(t.length);
}, Xje = CI, Zje = Kje, Qje = z0, ZU = function(t) {
  return function(e, n, r) {
    var s = Xje(e), o = Qje(s);
    if (o === 0) return !t && -1;
    var i = Zje(r, o), a;
    if (t && n !== n) {
      for (; o > i; )
        if (a = s[i++], a !== a) return !0;
    } else for (; o > i; i++)
      if ((t || i in s) && s[i] === n) return t || i || 0;
    return !t && -1;
  };
}, Jje = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: ZU(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: ZU(!1)
}, eRe = Bs, LM = Jf, tRe = CI, nRe = Jje.indexOf, rRe = PF, QU = eRe([].push), Iee = function(t, e) {
  var n = tRe(t), r = 0, s = [], o;
  for (o in n) !LM(rRe, o) && LM(n, o) && QU(s, o);
  for (; e.length > r; ) LM(n, o = e[r++]) && (~nRe(s, o) || QU(s, o));
  return s;
}, kF = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], sRe = Iee, oRe = kF, iRe = oRe.concat("length", "prototype");
Tee.f = Object.getOwnPropertyNames || function(e) {
  return sRe(e, iRe);
};
var kee = {};
kee.f = Object.getOwnPropertySymbols;
var aRe = _I, cRe = Bs, lRe = Tee, dRe = kee, uRe = ug, fRe = cRe([].concat), hRe = aRe("Reflect", "ownKeys") || function(e) {
  var n = lRe.f(uRe(e)), r = dRe.f;
  return r ? fRe(n, r(e)) : n;
}, JU = Jf, pRe = hRe, gRe = vF, mRe = dg, yRe = function(t, e, n) {
  for (var r = pRe(e), s = mRe.f, o = gRe.f, i = 0; i < r.length; i++) {
    var a = r[i];
    !JU(t, a) && !(n && JU(n, a)) && s(t, a, o(e, a));
  }
}, vRe = Ro, bRe = gi, xRe = /#|\.prototype\./, U0 = function(t, e) {
  var n = SRe[wRe(t)];
  return n === _Re ? !0 : n === CRe ? !1 : bRe(e) ? vRe(e) : !!e;
}, wRe = U0.normalize = function(t) {
  return String(t).replace(xRe, ".").toLowerCase();
}, SRe = U0.data = {}, CRe = U0.NATIVE = "N", _Re = U0.POLYFILL = "P", ERe = U0, y1 = jo, TRe = vF.f, PRe = EF, IRe = Eee, kRe = SF, ARe = yRe, MRe = ERe, iv = function(t, e) {
  var n = t.target, r = t.global, s = t.stat, o, i, a, c, l, d;
  if (r ? i = y1 : s ? i = y1[n] || kRe(n, {}) : i = y1[n] && y1[n].prototype, i) for (a in e) {
    if (l = e[a], t.dontCallGetSet ? (d = TRe(i, a), c = d && d.value) : c = i[a], o = MRe(r ? a : n + (s ? "." : "#") + a, t.forced), !o && c !== void 0) {
      if (typeof l == typeof c) continue;
      ARe(l, c);
    }
    (t.sham || c && c.sham) && PRe(l, "sham", !0), IRe(i, a, l, t);
  }
}, Aee = {}, ORe = Iee, DRe = kF, NRe = Object.keys || function(e) {
  return ORe(e, DRe);
}, jRe = fu, RRe = yee, $Re = dg, LRe = ug, FRe = CI, BRe = NRe;
Aee.f = jRe && !RRe ? Object.defineProperties : function(e, n) {
  LRe(e);
  for (var r = FRe(n), s = BRe(n), o = s.length, i = 0, a; o > i; ) $Re.f(e, a = s[i++], r[a]);
  return e;
};
var zRe = _I, URe = zRe("document", "documentElement"), HRe = ug, VRe = Aee, e8 = kF, WRe = PF, KRe = URe, GRe = gee, YRe = wee, t8 = ">", n8 = "<", HN = "prototype", VN = "script", Mee = YRe("IE_PROTO"), FM = function() {
}, Oee = function(t) {
  return n8 + VN + t8 + t + n8 + "/" + VN + t8;
}, r8 = function(t) {
  t.write(Oee("")), t.close();
  var e = t.parentWindow.Object;
  return t = null, e;
}, qRe = function() {
  var t = GRe("iframe"), e = "java" + VN + ":", n;
  return t.style.display = "none", KRe.appendChild(t), t.src = String(e), n = t.contentWindow.document, n.open(), n.write(Oee("document.F=Object")), n.close(), n.F;
}, v1, XC = function() {
  try {
    v1 = new ActiveXObject("htmlfile");
  } catch {
  }
  XC = typeof document < "u" ? document.domain && v1 ? r8(v1) : qRe() : r8(v1);
  for (var t = e8.length; t--; ) delete XC[HN][e8[t]];
  return XC();
};
WRe[Mee] = !0;
var Dee = Object.create || function(e, n) {
  var r;
  return e !== null ? (FM[HN] = HRe(e), r = new FM(), FM[HN] = null, r[Mee] = e) : r = XC(), n === void 0 ? r : VRe.f(r, n);
}, XRe = gu, ZRe = Dee, QRe = dg.f, WN = XRe("unscopables"), KN = Array.prototype;
KN[WN] === void 0 && QRe(KN, WN, {
  configurable: !0,
  value: ZRe(null)
});
var AF = function(t) {
  KN[WN][t] = !0;
}, JRe = iv, e$e = B0, t$e = z0, n$e = fg, r$e = AF;
JRe({ target: "Array", proto: !0 }, {
  at: function(e) {
    var n = e$e(this), r = t$e(n), s = n$e(e), o = s >= 0 ? s : r + s;
    return o < 0 || o >= r ? void 0 : n[o];
  }
});
r$e("at");
var s$e = jo, o$e = Bs, H0 = function(t, e) {
  return o$e(s$e[t].prototype[e]);
}, i$e = H0;
i$e("Array", "at");
var a$e = sv, Nee = Array.isArray || function(e) {
  return a$e(e) === "Array";
}, c$e = TypeError, l$e = 9007199254740991, d$e = function(t) {
  if (t > l$e) throw c$e("Maximum allowed index exceeded");
  return t;
}, u$e = sv, f$e = Bs, h$e = function(t) {
  if (u$e(t) === "Function") return f$e(t);
}, s8 = h$e, p$e = xF, g$e = SI, m$e = s8(s8.bind), y$e = function(t, e) {
  return p$e(t), e === void 0 ? t : g$e ? m$e(t, e) : function() {
    return t.apply(e, arguments);
  };
}, v$e = fu, b$e = dg, x$e = bF, w$e = function(t, e, n) {
  v$e ? b$e.f(t, e, x$e(0, n)) : t[e] = n;
}, S$e = Nee, C$e = z0, _$e = d$e, E$e = y$e, T$e = w$e, jee = function(t, e, n, r, s, o, i, a) {
  for (var c = s, l = 0, d = i ? E$e(i, a) : !1, u, f; l < r; )
    l in n && (u = d ? d(n[l], l, e) : n[l], o > 0 && S$e(u) ? (f = C$e(u), c = jee(t, e, u, f, c, o - 1) - 1) : (_$e(c + 1), T$e(t, c, u)), c++), l++;
  return c;
}, Ree = jee, P$e = gu, I$e = P$e("toStringTag"), $ee = {};
$ee[I$e] = "z";
var k$e = String($ee) === "[object z]", A$e = k$e, M$e = gi, ZC = sv, O$e = gu, D$e = O$e("toStringTag"), N$e = Object, j$e = ZC(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments", R$e = function(t, e) {
  try {
    return t[e];
  } catch {
  }
}, Lee = A$e ? ZC : function(t) {
  var e, n, r;
  return t === void 0 ? "Undefined" : t === null ? "Null" : typeof (n = R$e(e = N$e(t), D$e)) == "string" ? n : j$e ? ZC(e) : (r = ZC(e)) === "Object" && M$e(e.callee) ? "Arguments" : r;
}, $$e = Bs, L$e = Ro, Fee = gi, F$e = Lee, B$e = _I, z$e = xee, Bee = function() {
}, zee = B$e("Reflect", "construct"), MF = /^\s*(?:class|function)\b/, U$e = $$e(MF.exec), H$e = !MF.test(Bee), Yv = function(e) {
  if (!Fee(e)) return !1;
  try {
    return zee(Bee, [], e), !0;
  } catch {
    return !1;
  }
}, Uee = function(e) {
  if (!Fee(e)) return !1;
  switch (F$e(e)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return H$e || !!U$e(MF, z$e(e));
  } catch {
    return !0;
  }
};
Uee.sham = !0;
var V$e = !zee || L$e(function() {
  var t;
  return Yv(Yv.call) || !Yv(Object) || !Yv(function() {
    t = !0;
  }) || t;
}) ? Uee : Yv, o8 = Nee, W$e = V$e, K$e = pu, G$e = gu, Y$e = G$e("species"), i8 = Array, q$e = function(t) {
  var e;
  return o8(t) && (e = t.constructor, W$e(e) && (e === i8 || o8(e.prototype)) ? e = void 0 : K$e(e) && (e = e[Y$e], e === null && (e = void 0))), e === void 0 ? i8 : e;
}, X$e = q$e, Hee = function(t, e) {
  return new (X$e(t))(e === 0 ? 0 : e);
}, Z$e = iv, Q$e = Ree, J$e = xF, eLe = B0, tLe = z0, nLe = Hee;
Z$e({ target: "Array", proto: !0 }, {
  flatMap: function(e) {
    var n = eLe(this), r = tLe(n), s;
    return J$e(e), s = nLe(n, 0), Q$e(s, n, n, r, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), s;
  }
});
var rLe = AF;
rLe("flatMap");
var sLe = H0;
sLe("Array", "flatMap");
var oLe = iv, iLe = Ree, aLe = B0, cLe = z0, lLe = fg, dLe = Hee;
oLe({ target: "Array", proto: !0 }, {
  flat: function() {
    var e = arguments.length ? arguments[0] : void 0, n = aLe(this), r = cLe(n), s = dLe(n, 0);
    return iLe(s, n, n, r, 0, e === void 0 ? 1 : lLe(e)), s;
  }
});
var uLe = AF;
uLe("flat");
var fLe = H0;
fLe("Array", "flat");
var hLe = Lee, pLe = String, V0 = function(t) {
  if (hLe(t) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return pLe(t);
}, gLe = iv, mLe = Bs, yLe = ov, vLe = fg, bLe = V0, xLe = Ro, wLe = mLe("".charAt), SLe = xLe(function() {
  return "".at(-2) !== "\uD842";
});
gLe({ target: "String", proto: !0, forced: SLe }, {
  at: function(e) {
    var n = bLe(yLe(this)), r = n.length, s = vLe(e), o = s >= 0 ? s : r + s;
    return o < 0 || o >= r ? void 0 : wLe(n, o);
  }
});
var CLe = H0;
CLe("String", "at");
var _Le = ug, Vee = function() {
  var t = _Le(this), e = "";
  return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e;
}, OF = Ro, ELe = jo, DF = ELe.RegExp, NF = OF(function() {
  var t = DF("a", "y");
  return t.lastIndex = 2, t.exec("abcd") !== null;
}), TLe = NF || OF(function() {
  return !DF("a", "y").sticky;
}), PLe = NF || OF(function() {
  var t = DF("^r", "gy");
  return t.lastIndex = 2, t.exec("str") !== null;
}), ILe = {
  BROKEN_CARET: PLe,
  MISSED_STICKY: TLe,
  UNSUPPORTED_Y: NF
}, kLe = Ro, ALe = jo, MLe = ALe.RegExp, OLe = kLe(function() {
  var t = MLe(".", "s");
  return !(t.dotAll && t.test(`
`) && t.flags === "s");
}), DLe = Ro, NLe = jo, jLe = NLe.RegExp, RLe = DLe(function() {
  var t = jLe("(?<a>b)", "g");
  return t.exec("b").groups.a !== "b" || "b".replace(t, "$<a>c") !== "bc";
}), um = hu, EI = Bs, $Le = V0, LLe = Vee, FLe = ILe, BLe = _F, zLe = Dee, ULe = Cee.get, HLe = OLe, VLe = RLe, WLe = BLe("native-string-replace", String.prototype.replace), xE = RegExp.prototype.exec, GN = xE, KLe = EI("".charAt), GLe = EI("".indexOf), YLe = EI("".replace), BM = EI("".slice), YN = function() {
  var t = /a/, e = /b*/g;
  return um(xE, t, "a"), um(xE, e, "a"), t.lastIndex !== 0 || e.lastIndex !== 0;
}(), Wee = FLe.BROKEN_CARET, qN = /()??/.exec("")[1] !== void 0, qLe = YN || qN || Wee || HLe || VLe;
qLe && (GN = function(e) {
  var n = this, r = ULe(n), s = $Le(e), o = r.raw, i, a, c, l, d, u, f;
  if (o)
    return o.lastIndex = n.lastIndex, i = um(GN, o, s), n.lastIndex = o.lastIndex, i;
  var p = r.groups, g = Wee && n.sticky, y = um(LLe, n), m = n.source, v = 0, b = s;
  if (g && (y = YLe(y, "y", ""), GLe(y, "g") === -1 && (y += "g"), b = BM(s, n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && KLe(s, n.lastIndex - 1) !== `
`) && (m = "(?: " + m + ")", b = " " + b, v++), a = new RegExp("^(?:" + m + ")", y)), qN && (a = new RegExp("^" + m + "$(?!\\s)", y)), YN && (c = n.lastIndex), l = um(xE, g ? a : n, b), g ? l ? (l.input = BM(l.input, v), l[0] = BM(l[0], v), l.index = n.lastIndex, n.lastIndex += l[0].length) : n.lastIndex = 0 : YN && l && (n.lastIndex = n.global ? l.index + l[0].length : c), qN && l && l.length > 1 && um(WLe, l[0], a, function() {
    for (d = 1; d < arguments.length - 2; d++)
      arguments[d] === void 0 && (l[d] = void 0);
  }), l && p)
    for (l.groups = u = zLe(null), d = 0; d < p.length; d++)
      f = p[d], u[f[0]] = l[f[1]];
  return l;
});
var jF = GN, XLe = iv, a8 = jF;
XLe({ target: "RegExp", proto: !0, forced: /./.exec !== a8 }, {
  exec: a8
});
var ZLe = SI, Kee = Function.prototype, c8 = Kee.apply, l8 = Kee.call, QLe = typeof Reflect == "object" && Reflect.apply || (ZLe ? l8.bind(c8) : function() {
  return l8.apply(c8, arguments);
}), d8 = hu, u8 = Eee, JLe = jF, f8 = Ro, Gee = gu, eFe = EF, tFe = Gee("species"), zM = RegExp.prototype, nFe = function(t, e, n, r) {
  var s = Gee(t), o = !f8(function() {
    var l = {};
    return l[s] = function() {
      return 7;
    }, ""[t](l) !== 7;
  }), i = o && !f8(function() {
    var l = !1, d = /a/;
    if (t === "split") {
      var u = {};
      u[tFe] = function() {
        return d;
      }, d = { constructor: u, flags: "" }, d[s] = /./[s];
    }
    return d.exec = function() {
      return l = !0, null;
    }, d[s](""), !l;
  });
  if (!o || !i || n) {
    var a = /./[s], c = e(s, ""[t], function(l, d, u, f, p) {
      var g = d.exec;
      return g === JLe || g === zM.exec ? o && !p ? { done: !0, value: d8(a, d, u, f) } : { done: !0, value: d8(l, u, d, f) } : { done: !1 };
    });
    u8(String.prototype, t, c[0]), u8(zM, s, c[1]);
  }
  r && eFe(zM[s], "sham", !0);
}, RF = Bs, rFe = fg, sFe = V0, oFe = ov, iFe = RF("".charAt), h8 = RF("".charCodeAt), aFe = RF("".slice), p8 = function(t) {
  return function(e, n) {
    var r = sFe(oFe(e)), s = rFe(n), o = r.length, i, a;
    return s < 0 || s >= o ? t ? "" : void 0 : (i = h8(r, s), i < 55296 || i > 56319 || s + 1 === o || (a = h8(r, s + 1)) < 56320 || a > 57343 ? t ? iFe(r, s) : i : t ? aFe(r, s, s + 2) : (i - 55296 << 10) + (a - 56320) + 65536);
  };
}, cFe = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: p8(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: p8(!0)
}, lFe = cFe.charAt, dFe = function(t, e, n) {
  return e + (n ? lFe(t, e).length : 1);
}, $F = Bs, uFe = B0, fFe = Math.floor, UM = $F("".charAt), hFe = $F("".replace), HM = $F("".slice), pFe = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, gFe = /\$([$&'`]|\d{1,2})/g, Yee = function(t, e, n, r, s, o) {
  var i = n + t.length, a = r.length, c = gFe;
  return s !== void 0 && (s = uFe(s), c = pFe), hFe(o, c, function(l, d) {
    var u;
    switch (UM(d, 0)) {
      case "$":
        return "$";
      case "&":
        return t;
      case "`":
        return HM(e, 0, n);
      case "'":
        return HM(e, i);
      case "<":
        u = s[HM(d, 1, -1)];
        break;
      default:
        var f = +d;
        if (f === 0) return l;
        if (f > a) {
          var p = fFe(f / 10);
          return p === 0 ? l : p <= a ? r[p - 1] === void 0 ? UM(d, 1) : r[p - 1] + UM(d, 1) : l;
        }
        u = r[f - 1];
    }
    return u === void 0 ? "" : u;
  });
}, mFe = jo, yFe = Ro, g8 = mFe.RegExp, vFe = !yFe(function() {
  var t = !0;
  try {
    g8(".", "d");
  } catch {
    t = !1;
  }
  var e = {}, n = "", r = t ? "dgimsy" : "gimsy", s = function(c, l) {
    Object.defineProperty(e, c, { get: function() {
      return n += l, !0;
    } });
  }, o = {
    dotAll: "s",
    global: "g",
    ignoreCase: "i",
    multiline: "m",
    sticky: "y"
  };
  t && (o.hasIndices = "d");
  for (var i in o) s(i, o[i]);
  var a = Object.getOwnPropertyDescriptor(g8.prototype, "flags").get.call(e);
  return a !== r || n !== r;
}), bFe = { correct: vFe }, xFe = hu, wFe = Jf, SFe = aee, m8 = bFe, CFe = Vee, _Fe = RegExp.prototype, qee = m8.correct ? function(t) {
  return t.flags;
} : function(t) {
  return !m8.correct && SFe(_Fe, t) && !wFe(t, "flags") ? xFe(CFe, t) : t.flags;
}, y8 = hu, EFe = ug, TFe = gi, PFe = sv, IFe = jF, kFe = TypeError, AFe = function(t, e) {
  var n = t.exec;
  if (TFe(n)) {
    var r = y8(n, t, e);
    return r !== null && EFe(r), r;
  }
  if (PFe(t) === "RegExp") return y8(IFe, t, e);
  throw new kFe("RegExp#exec called on incompatible receiver");
}, MFe = QLe, v8 = hu, TI = Bs, OFe = nFe, DFe = Ro, NFe = ug, jFe = gi, RFe = pu, $Fe = fg, LFe = Pee, xh = V0, FFe = ov, BFe = dFe, zFe = wF, UFe = Yee, HFe = qee, VFe = AFe, WFe = gu, XN = WFe("replace"), KFe = Math.max, GFe = Math.min, YFe = TI([].concat), VM = TI([].push), b1 = TI("".indexOf), b8 = TI("".slice), qFe = function(t) {
  return t === void 0 ? t : String(t);
}, XFe = function() {
  return "a".replace(/./, "$0") === "$0";
}(), x8 = function() {
  return /./[XN] ? /./[XN]("a", "$0") === "" : !1;
}(), ZFe = !DFe(function() {
  var t = /./;
  return t.exec = function() {
    var e = [];
    return e.groups = { a: "7" }, e;
  }, "".replace(t, "$<a>") !== "7";
});
OFe("replace", function(t, e, n) {
  var r = x8 ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(o, i) {
      var a = FFe(this), c = RFe(o) ? zFe(o, XN) : void 0;
      return c ? v8(c, o, a, i) : v8(e, xh(a), o, i);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(s, o) {
      var i = NFe(this), a = xh(s);
      if (typeof o == "string" && b1(o, r) === -1 && b1(o, "$<") === -1) {
        var c = n(e, i, a, o);
        if (c.done) return c.value;
      }
      var l = jFe(o);
      l || (o = xh(o));
      var d = xh(HFe(i)), u = b1(d, "g") !== -1, f;
      u && (f = b1(d, "u") !== -1, i.lastIndex = 0);
      for (var p = [], g; g = VFe(i, a), !(g === null || (VM(p, g), !u)); ) {
        var y = xh(g[0]);
        y === "" && (i.lastIndex = BFe(a, LFe(i.lastIndex), f));
      }
      for (var m = "", v = 0, b = 0; b < p.length; b++) {
        g = p[b];
        for (var x = xh(g[0]), w = KFe(GFe($Fe(g.index), a.length), 0), S = [], C, _ = 1; _ < g.length; _++) VM(S, qFe(g[_]));
        var E = g.groups;
        if (l) {
          var M = YFe([x], S, w, a);
          E !== void 0 && VM(M, E), C = xh(MFe(o, void 0, M));
        } else
          C = UFe(x, a, w, S, E, o);
        w >= v && (m += b8(a, v, w) + C, v = w + x.length);
      }
      return m + b8(a, v);
    }
  ];
}, !ZFe || !XFe || x8);
var QFe = pu, JFe = sv, e3e = gu, t3e = e3e("match"), n3e = function(t) {
  var e;
  return QFe(t) && ((e = t[t3e]) !== void 0 ? !!e : JFe(t) === "RegExp");
}, r3e = iv, s3e = hu, LF = Bs, w8 = ov, o3e = gi, i3e = pu, a3e = n3e, qv = V0, c3e = wF, l3e = qee, d3e = Yee, u3e = gu, f3e = u3e("replace"), h3e = TypeError, WM = LF("".indexOf);
LF("".replace);
var S8 = LF("".slice), p3e = Math.max;
r3e({ target: "String", proto: !0 }, {
  replaceAll: function(e, n) {
    var r = w8(this), s, o, i, a, c, l, d, u, f, p, g = 0, y = "";
    if (i3e(e)) {
      if (s = a3e(e), s && (o = qv(w8(l3e(e))), !~WM(o, "g")))
        throw new h3e("`.replaceAll` does not allow non-global regexes");
      if (i = c3e(e, f3e), i) return s3e(i, e, r, n);
    }
    for (a = qv(r), c = qv(e), l = o3e(n), l || (n = qv(n)), d = c.length, u = p3e(1, d), f = WM(a, c); f !== -1; )
      p = l ? qv(n(c, f, a)) : d3e(c, a, f, [], void 0, n), y += S8(a, g, f) + p, g = f + d, f = f + u > a.length ? -1 : WM(a, c, f + u);
    return g < a.length && (y += S8(a, g)), y;
  }
});
var g3e = H0;
g3e("String", "replaceAll");
function Xee(t) {
  return t && typeof t == "object" && "parents" in t;
}
function Zee(t) {
  for (let e = 0, n = t.parents.length; e < n; e++)
    if (t.parents[e].__unsafe__getWithoutCapture(!0), t.parents[e].lastChangedEpoch !== t.parentEpochs[e])
      return !0;
  return !1;
}
function wE(t, e) {
  if (t.children.remove(e) && t.children.isEmpty && Xee(t))
    for (let n = 0, r = t.parents.length; n < r; n++)
      wE(t.parents[n], t);
}
function FF(t, e) {
  if (t.children.add(e) && Xee(t))
    for (let n = 0, r = t.parents.length; n < r; n++)
      FF(t.parents[n], t);
}
function Qee(t, e) {
  return t === e || Object.is(t, e) || !!(t && e && typeof t.equals == "function" && t.equals(e));
}
function eh(t, e) {
  const n = Symbol.for(`com.tldraw.state/${t}`), r = globalThis;
  return r[n] ?? (r[n] = e()), r[n];
}
const Br = eh("empty_array", () => Object.freeze([])), C8 = 8;
class SE {
  constructor() {
    P(this, "arraySize", 0);
    P(this, "array", Array(C8));
    P(this, "set", null);
  }
  /**
   * Get whether this ArraySet has any elements.
   *
   * @returns True if this ArraySet has any elements, false otherwise.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isEmpty() {
    if (this.array)
      return this.arraySize === 0;
    if (this.set)
      return this.set.size === 0;
    throw new Error("no set or array");
  }
  /**
   * Add an item to the ArraySet if it is not already present.
   *
   * @param elem - The element to add.
   */
  add(e) {
    if (this.array)
      return this.array.indexOf(e) !== -1 ? !1 : this.arraySize < C8 ? (this.array[this.arraySize] = e, this.arraySize++, !0) : (this.set = new Set(this.array), this.array = null, this.set.add(e), !0);
    if (this.set)
      return this.set.has(e) ? !1 : (this.set.add(e), !0);
    throw new Error("no set or array");
  }
  /**
   * Remove an item from the ArraySet if it is present.
   *
   * @param elem - The element to remove
   */
  remove(e) {
    if (this.array) {
      const n = this.array.indexOf(e);
      return n === -1 ? !1 : (this.array[n] = void 0, this.arraySize--, n !== this.arraySize && (this.array[n] = this.array[this.arraySize], this.array[this.arraySize] = void 0), !0);
    }
    if (this.set)
      return this.set.has(e) ? (this.set.delete(e), !0) : !1;
    throw new Error("no set or array");
  }
  /**
   * Run a callback for each element in the ArraySet.
   *
   * @param visitor - The callback to run for each element.
   */
  visit(e) {
    if (this.array) {
      for (let n = 0; n < this.arraySize; n++) {
        const r = this.array[n];
        typeof r < "u" && e(r);
      }
      return;
    }
    if (this.set) {
      this.set.forEach(e);
      return;
    }
    throw new Error("no set or array");
  }
  *[Symbol.iterator]() {
    if (this.array)
      for (let e = 0; e < this.arraySize; e++) {
        const n = this.array[e];
        typeof n < "u" && (yield n);
      }
    else if (this.set)
      yield* this.set;
    else
      throw new Error("no set or array");
  }
  has(e) {
    return this.array ? this.array.indexOf(e) !== -1 : this.set.has(e);
  }
  clear() {
    this.set ? this.set.clear() : (this.arraySize = 0, this.array = []);
  }
  size() {
    return this.set ? this.set.size : this.arraySize;
  }
}
const ma = Symbol.for("com.tldraw.state/RESET_VALUE");
class Jee {
  constructor(e) {
    P(this, "index", 0);
    // use a wrap around buffer to store the last N values
    P(this, "buffer");
    this.capacity = e, this.buffer = new Array(e);
  }
  /**
   * Add a diff to the history buffer.
   *
   * @param lastComputedEpoch - The epoch when the diff was computed.
   * @param currentEpoch - The current epoch.
   * @param diff - The diff to add, or else a reset value.
   */
  pushEntry(e, n, r) {
    if (r !== void 0) {
      if (r === ma) {
        this.clear();
        return;
      }
      this.buffer[this.index] = [e, n, r], this.index = (this.index + 1) % this.capacity;
    }
  }
  /**
   * Clear the history buffer.
   */
  clear() {
    this.index = 0, this.buffer.fill(void 0);
  }
  /**
   * Get the diffs since the given epoch.
   *
   * @param sinceEpoch - The epoch to get diffs since.
   * @returns An array of diffs or a flag to reset the history buffer.
   */
  getChangesSince(e) {
    const { index: n, capacity: r, buffer: s } = this;
    for (let o = 0; o < r; o++) {
      const i = (n - 1 + r - o) % r, a = s[i];
      if (!a)
        return ma;
      const [c, l] = a;
      if (o === 0 && e >= l)
        return [];
      if (c <= e && e < l) {
        const d = o + 1, u = new Array(d);
        for (let f = 0; f < d; f++)
          u[f] = s[(i + f) % r][2];
        return u;
      }
    }
    return ma;
  }
}
const df = -1;
class m3e {
  constructor(e, n, r) {
    P(this, "_isActivelyListening", !1);
    /** @internal */
    P(this, "lastTraversedEpoch", df);
    P(this, "lastReactedEpoch", df);
    P(this, "_scheduleCount", 0);
    P(this, "__debug_ancestor_epochs__", null);
    /** @internal */
    P(this, "parentSet", new SE());
    /** @internal */
    P(this, "parentEpochs", []);
    /** @internal */
    P(this, "parents", []);
    P(this, "_scheduleEffect");
    /** @internal */
    // eslint-disable-next-line local/prefer-class-methods
    P(this, "maybeExecute", () => {
      this._isActivelyListening && this.execute();
    });
    this.name = e, this.runEffect = n, this._scheduleEffect = r == null ? void 0 : r.scheduleEffect;
  }
  /**
   * Whether this scheduler is attached and actively listening to its parents.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return this._isActivelyListening;
  }
  /**
   * The number of times this effect has been scheduled.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get scheduleCount() {
    return this._scheduleCount;
  }
  /** @internal */
  maybeScheduleEffect() {
    if (this._isActivelyListening && this.lastReactedEpoch !== Mi()) {
      if (this.parents.length && !Zee(this)) {
        this.lastReactedEpoch = Mi();
        return;
      }
      this.scheduleEffect();
    }
  }
  /** @internal */
  scheduleEffect() {
    this._scheduleCount++, this._scheduleEffect ? this._scheduleEffect(this.maybeExecute) : this.execute();
  }
  /**
   * Makes this scheduler become 'actively listening' to its parents.
   * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
   * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling `EffectScheduler.execute`.
   * @public
   */
  attach() {
    this._isActivelyListening = !0;
    for (let e = 0, n = this.parents.length; e < n; e++)
      FF(this.parents[e], this);
  }
  /**
   * Makes this scheduler stop 'actively listening' to its parents.
   * It will no longer be eligible to receive 'maybeScheduleEffect' calls until `EffectScheduler.attach` is called again.
   */
  detach() {
    this._isActivelyListening = !1;
    for (let e = 0, n = this.parents.length; e < n; e++)
      wE(this.parents[e], this);
  }
  /**
   * Executes the effect immediately and returns the result.
   * @returns The result of the effect.
   */
  execute() {
    try {
      rte(this);
      const e = Mi(), n = this.runEffect(this.lastReactedEpoch);
      return this.lastReactedEpoch = e, n;
    } finally {
      ste();
    }
  }
}
const hg = eh(
  "EffectScheduler",
  () => m3e
);
function ya(t, e, n) {
  const r = new hg(t, e, n);
  return r.attach(), r.scheduleEffect(), () => {
    r.detach();
  };
}
function y3e(t, e, n) {
  const r = new hg(t, e, n);
  return {
    scheduler: r,
    start: (s) => {
      const o = (s == null ? void 0 : s.force) ?? !1;
      r.attach(), o ? r.scheduleEffect() : r.maybeScheduleEffect();
    },
    stop: () => {
      r.detach();
    }
  };
}
let v3e = class {
  constructor(e, n) {
    P(this, "asyncProcessCount", 0);
    P(this, "initialAtomValues", /* @__PURE__ */ new Map());
    this.parent = e, this.isSync = n;
  }
  /**
   * Get whether this transaction is a root (no parents).
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isRoot() {
    return this.parent === null;
  }
  /**
   * Commit the transaction's changes.
   *
   * @public
   */
  commit() {
    if (pn.globalIsReacting)
      for (const e of this.initialAtomValues.keys())
        tte(e);
    else this.isRoot ? ete(this.initialAtomValues.keys()) : this.initialAtomValues.forEach((e, n) => {
      this.parent.initialAtomValues.has(n) || this.parent.initialAtomValues.set(n, e);
    });
  }
  /**
   * Abort the transaction.
   *
   * @public
   */
  abort() {
    pn.globalEpoch++, this.initialAtomValues.forEach((e, n) => {
      var r;
      n.set(e), (r = n.historyBuffer) == null || r.clear();
    }), this.commit();
  }
};
const pn = eh("transactions", () => ({
  // The current epoch (global to all atoms).
  globalEpoch: df + 1,
  // Whether any transaction is reacting.
  globalIsReacting: !1,
  currentTransaction: null,
  cleanupReactors: null,
  reactionEpoch: df + 1
}));
function b3e() {
  return pn.reactionEpoch;
}
function Mi() {
  return pn.globalEpoch;
}
function x3e() {
  return pn.globalIsReacting;
}
function BF(t, e) {
  e.lastTraversedEpoch !== pn.globalEpoch && (e.lastTraversedEpoch = pn.globalEpoch, e instanceof hg ? t.add(e) : e.children.visit((n) => BF(t, n)));
}
function ete(t) {
  var n;
  if (pn.globalIsReacting)
    throw new Error("flushChanges cannot be called during a reaction");
  const e = pn.currentTransaction;
  try {
    pn.currentTransaction = null, pn.globalIsReacting = !0, pn.reactionEpoch = pn.globalEpoch;
    const r = /* @__PURE__ */ new Set();
    for (const o of t)
      o.children.visit((i) => BF(r, i));
    for (const o of r)
      o.maybeScheduleEffect();
    let s = 0;
    for (; (n = pn.cleanupReactors) != null && n.size; ) {
      if (s++ > 1e3)
        throw new Error("Reaction update depth limit exceeded");
      const o = pn.cleanupReactors;
      pn.cleanupReactors = null;
      for (const i of o)
        i.maybeScheduleEffect();
    }
  } finally {
    pn.cleanupReactors = null, pn.globalIsReacting = !1, pn.currentTransaction = e;
  }
}
function w3e(t, e) {
  pn.currentTransaction ? pn.currentTransaction.initialAtomValues.has(t) || pn.currentTransaction.initialAtomValues.set(t, e) : pn.globalIsReacting ? tte(t) : ete([t]);
}
function tte(t) {
  const e = pn.cleanupReactors ?? (pn.cleanupReactors = /* @__PURE__ */ new Set());
  t.children.visit((n) => BF(e, n));
}
function S3e() {
  pn.globalEpoch++;
}
function C3e(t) {
  const e = new v3e(pn.currentTransaction, !0);
  pn.currentTransaction = e;
  try {
    let n, r = !1;
    try {
      n = t(() => r = !0);
    } catch (s) {
      throw e.abort(), s;
    }
    if (pn.currentTransaction !== e)
      throw new Error("Transaction boundaries overlap");
    return r ? e.abort() : e.commit(), n;
  } finally {
    pn.currentTransaction = e.parent;
  }
}
function va(t) {
  return pn.currentTransaction ? t() : C3e(t);
}
let _8 = !1;
function _3e() {
  _8 || (_8 = !0, console.warn(
    `Using \`@computed\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \`@computed\` as a decorator for methods.

// Before
@computed
get foo() {
	return 'foo'
}

// After
@computed
getFoo() {
	return 'foo'
}
`
  ));
}
const _o = Symbol.for("com.tldraw.state/UNINITIALIZED");
function op(t) {
  return t === _o;
}
const ZN = eh(
  "WithDiff",
  () => class {
    constructor(e, n) {
      this.value = e, this.diff = n;
    }
  }
);
function Db(t, e) {
  return new ZN(t, e);
}
class E3e {
  constructor(e, n, r) {
    P(this, "lastChangedEpoch", df);
    P(this, "lastTraversedEpoch", df);
    P(this, "__debug_ancestor_epochs__", null);
    /**
     * The epoch when the reactor was last checked.
     */
    P(this, "lastCheckedEpoch", df);
    P(this, "parentSet", new SE());
    P(this, "parents", []);
    P(this, "parentEpochs", []);
    P(this, "children", new SE());
    P(this, "historyBuffer");
    // The last-computed value of this signal.
    P(this, "state", _o);
    // If the signal throws an error we stash it so we can rethrow it on the next get()
    P(this, "error", null);
    P(this, "computeDiff");
    P(this, "isEqual");
    this.name = e, this.derive = n, r != null && r.historyLength && (this.historyBuffer = new Jee(r.historyLength)), this.computeDiff = r == null ? void 0 : r.computeDiff, this.isEqual = (r == null ? void 0 : r.isEqual) ?? Qee;
  }
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return !this.children.isEmpty;
  }
  __unsafe__getWithoutCapture(e) {
    var s;
    const n = this.lastChangedEpoch === df, r = Mi();
    if (!n && (this.lastCheckedEpoch === r || this.isActivelyListening && x3e() && this.lastTraversedEpoch < b3e() || !Zee(this)))
      if (this.lastCheckedEpoch = r, this.error) {
        if (e)
          return this.state;
        throw this.error.thrownValue;
      } else
        return this.state;
    try {
      rte(this);
      const o = this.derive(this.state, this.lastCheckedEpoch), i = o instanceof ZN ? o.value : o, a = this.state === _o;
      if (a || !this.isEqual(i, this.state)) {
        if (this.historyBuffer && !a) {
          const c = o instanceof ZN ? o.diff : void 0;
          this.historyBuffer.pushEntry(
            this.lastChangedEpoch,
            Mi(),
            c ?? ((s = this.computeDiff) == null ? void 0 : s.call(this, this.state, i, this.lastCheckedEpoch, Mi())) ?? ma
          );
        }
        this.lastChangedEpoch = Mi(), this.state = i;
      }
      return this.error = null, this.lastCheckedEpoch = Mi(), this.state;
    } catch (o) {
      if (this.state !== _o && (this.state = _o, this.lastChangedEpoch = Mi()), this.lastCheckedEpoch = Mi(), this.historyBuffer && this.historyBuffer.clear(), this.error = { thrownValue: o }, !e) throw o;
      return this.state;
    } finally {
      ste();
    }
  }
  get() {
    try {
      return this.__unsafe__getWithoutCapture();
    } finally {
      CE(this);
    }
  }
  getDiffSince(e) {
    var n;
    return this.__unsafe__getWithoutCapture(!0), CE(this), e >= this.lastChangedEpoch ? Br : ((n = this.historyBuffer) == null ? void 0 : n.getChangesSince(e)) ?? ma;
  }
}
const W0 = eh("Computed", () => E3e);
function T3e(t = {}, e, n, r) {
  const s = r.value, o = Symbol.for("__@tldraw/state__computed__" + n);
  return r.value = function() {
    let i = this[o];
    return i || (i = new W0(n, s.bind(this), t), Object.defineProperty(this, o, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: i
    })), i.get();
  }, r.value[nte] = !0, r;
}
function P3e(t = {}, e, n, r) {
  const s = r.get, o = Symbol.for("__@tldraw/state__computed__" + n);
  return r.get = function() {
    let i = this[o];
    return i || (i = new W0(n, s.bind(this), t), Object.defineProperty(this, o, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: i
    })), i.get();
  }, r;
}
function I3e(t, e, n) {
  tt(n.kind === "method", "@computed can only be used on methods");
  const r = Symbol.for("__@tldraw/state__computed__" + String(n.name)), s = function() {
    let o = this[r];
    return o || (o = new W0(String(n.name), e.bind(this), t), Object.defineProperty(this, r, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: o
    })), o.get();
  };
  return s[nte] = !0, s;
}
function E8(t = {}, e) {
  if (e.length === 2) {
    const [n, r] = e;
    return I3e(t, n, r);
  } else {
    const [n, r, s] = e;
    return s.get ? (_3e(), P3e(t, n, r, s)) : T3e(t, n, r, s);
  }
}
const nte = "@@__isComputedMethod__@@";
function ve() {
  if (arguments.length === 1) {
    const t = arguments[0];
    return (...e) => E8(t, e);
  } else return typeof arguments[0] == "string" ? new W0(arguments[0], arguments[1], arguments[2]) : E8(void 0, arguments);
}
function zF(t) {
  return t && t instanceof W0;
}
class k3e {
  constructor(e, n) {
    P(this, "offset", 0);
    P(this, "maybeRemoved");
    this.below = e, this.child = n;
  }
}
const sr = eh("capture", () => ({ stack: null }));
function Nb(t) {
  const e = sr.stack;
  sr.stack = null;
  try {
    return t();
  } finally {
    sr.stack = e;
  }
}
function rte(t) {
  if (sr.stack = new k3e(sr.stack, t), t.__debug_ancestor_epochs__) {
    const e = t.__debug_ancestor_epochs__;
    t.__debug_ancestor_epochs__ = null;
    for (const n of t.parents)
      n.__unsafe__getWithoutCapture(!0);
    A3e(t, e);
  }
  t.parentSet.clear();
}
function ste() {
  const t = sr.stack;
  if (sr.stack = t.below, t.offset < t.child.parents.length) {
    for (let e = t.offset; e < t.child.parents.length; e++) {
      const n = t.child.parents[e];
      t.child.parentSet.has(n) || wE(n, t.child);
    }
    t.child.parents.length = t.offset, t.child.parentEpochs.length = t.offset;
  }
  if (t.maybeRemoved)
    for (let e = 0; e < t.maybeRemoved.length; e++) {
      const n = t.maybeRemoved[e];
      t.child.parentSet.has(n) || wE(n, t.child);
    }
  t.child.__debug_ancestor_epochs__ && ote(t.child, t.child.__debug_ancestor_epochs__);
}
function CE(t) {
  if (sr.stack) {
    if (sr.stack.child.parentSet.has(t))
      return;
    if (sr.stack.child.parentSet.add(t), sr.stack.child.isActivelyListening && FF(t, sr.stack.child), sr.stack.offset < sr.stack.child.parents.length) {
      const n = sr.stack.child.parents[sr.stack.offset];
      n !== t && (sr.stack.maybeRemoved ? sr.stack.maybeRemoved.push(n) : sr.stack.maybeRemoved = [n]);
    }
    sr.stack.child.parents[sr.stack.offset] = t, sr.stack.child.parentEpochs[sr.stack.offset] = t.lastChangedEpoch, sr.stack.offset++;
  }
}
function ote(t, e) {
  for (let n = 0; n < t.parents.length; n++) {
    const r = t.parents[n], s = t.parentEpochs[n];
    e.set(r, s), zF(r) && ote(r, e);
  }
  return e;
}
function ite(t, e) {
  const n = {};
  for (let r = 0; r < t.parents.length; r++) {
    const s = t.parents[r];
    if (!e.has(s))
      continue;
    const o = e.get(s);
    s.lastChangedEpoch !== o && (zF(s) ? n[s.name] = ite(s, e) : n[s.name] = null);
  }
  return n;
}
function A3e(t, e) {
  const n = ite(t, e);
  if (Object.keys(n).length === 0) {
    console.log(`Effect(${t.name}) was executed manually.`);
    return;
  }
  let r = zF(t) ? `Computed(${t.name}) is recomputing because:` : `Effect(${t.name}) is executing because:`;
  function s(o, i) {
    const a = `
` + " ".repeat(i) + " ";
    for (const [c, l] of Object.entries(o))
      l ? (r += `${a}Computed(${c}) changed`, s(l, i + 2)) : r += `${a}Atom(${c}) changed`;
  }
  s(n, 1), console.log(r);
}
class M3e {
  constructor(e, n, r) {
    P(this, "isEqual");
    P(this, "computeDiff");
    P(this, "lastChangedEpoch", Mi());
    P(this, "children", new SE());
    P(this, "historyBuffer");
    this.name = e, this.current = n, this.isEqual = (r == null ? void 0 : r.isEqual) ?? null, r && (r.historyLength && (this.historyBuffer = new Jee(r.historyLength)), this.computeDiff = r.computeDiff);
  }
  __unsafe__getWithoutCapture(e) {
    return this.current;
  }
  get() {
    return CE(this), this.current;
  }
  set(e, n) {
    var s, o;
    if (((s = this.isEqual) == null ? void 0 : s.call(this, this.current, e)) ?? Qee(this.current, e))
      return this.current;
    S3e(), this.historyBuffer && this.historyBuffer.pushEntry(
      this.lastChangedEpoch,
      Mi(),
      n ?? ((o = this.computeDiff) == null ? void 0 : o.call(this, this.current, e, this.lastChangedEpoch, Mi())) ?? ma
    ), this.lastChangedEpoch = Mi();
    const r = this.current;
    return this.current = e, w3e(this, r), e;
  }
  update(e) {
    return this.set(e(this.current));
  }
  getDiffSince(e) {
    var n;
    return CE(this), e >= this.lastChangedEpoch ? Br : ((n = this.historyBuffer) == null ? void 0 : n.getChangesSince(e)) ?? ma;
  }
}
const O3e = eh("Atom", () => M3e);
function yr(t, e, n) {
  return new O3e(t, e, n);
}
const ate = 1, D3e = eh("apiVersion", () => ate);
if (D3e !== ate)
  throw new Error(
    "You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package."
  );
Xf(
  "@tldraw/state",
  "3.15.5",
  "esm"
);
function PI(t, e, n = []) {
  const r = B.useRef(e);
  r.current = e;
  const [s, o, i] = B.useMemo(() => {
    let a = null;
    const c = (u) => (a = u, () => {
      a = null;
    }), l = new hg(
      `useStateTracking(${t})`,
      // this is what `scheduler.execute()` will call
      () => {
        var u;
        return (u = r.current) == null ? void 0 : u.call(r);
      },
      // this is what will be invoked when @tldraw/state detects a change in an upstream reactive value
      {
        scheduleEffect() {
          a == null || a();
        }
      }
    );
    return [l, c, () => l.scheduleCount];
  }, [t, ...n]);
  return B.useSyncExternalStore(o, i, i), B.useEffect(() => (s.attach(), s.maybeScheduleEffect(), () => {
    s.detach();
  }), [s]), s.execute();
}
const T8 = {
  /**
   * This is a function call trap for functional components. When this is called, we know it means
   * React did run 'Component()', that means we can use any hooks here to setup our effect and
   * store.
   *
   * With the native Proxy, all other calls such as access/setting to/of properties will be
   * forwarded to the target Component, so we don't need to copy the Component's own or inherited
   * properties.
   *
   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
   */
  apply(t, e, n) {
    return PI(
      t.displayName ?? t.name ?? "tracked(???)",
      () => t.apply(e, n)
    );
  }
}, N3e = Symbol.for("react.memo"), j3e = Symbol.for("react.forward_ref");
function Kr(t) {
  let e = null;
  const n = t.$$typeof;
  return n === N3e && (t = t.type, e = t.compare), n === j3e ? it(du(new Proxy(t.render, T8))) : it(new Proxy(t, T8), e);
}
function K0(t, e, n) {
  return he(() => {
    const r = typeof e == "function" ? e() : e;
    return yr(`useAtom(${t})`, r, n);
  })[0];
}
function R3e() {
  const t = arguments[0], e = arguments[1], n = arguments.length === 3 ? void 0 : arguments[2], r = arguments.length === 3 ? arguments[2] : arguments[3];
  return Ke(() => ve(`useComputed(${t})`, e, n), r);
}
function Ep(t, e, n = Br) {
  me(() => {
    const r = new hg(t, e);
    return r.attach(), r.execute(), () => {
      r.detach();
    };
  }, n);
}
function UF(t, e, n = []) {
  me(() => {
    let r;
    const s = new hg(t, e, {
      scheduleEffect: (o) => {
        r = yF(o);
      }
    });
    return s.attach(), s.execute(), () => {
      s.detach(), r == null || r();
    };
  }, n);
}
function le() {
  const t = arguments, e = t.length === 3 ? t[2] : [t[0]], n = t.length === 3 ? t[0] : `useValue(${t[0].name})`, { $val: r, subscribe: s, getSnapshot: o } = Ke(() => {
    const i = t.length === 1 ? t[0] : ve(n, t[1]);
    return {
      $val: i,
      subscribe: (a) => ya(`useValue(${n})`, () => {
        try {
          i.get();
        } catch {
        }
        a();
      }),
      getSnapshot: () => i.lastChangedEpoch
    };
  }, e);
  return Gx(s, o, o), r.__unsafe__getWithoutCapture();
}
Xf(
  "@tldraw/state-react",
  "3.15.5",
  "esm"
);
/*!
 * This file was lovingly and delicately extracted from Immutable.js
 * MIT License: https://github.com/immutable-js/immutable-js/blob/main/LICENSE
 * Copyright (c) 2014-present, Lee Byron and other contributors.
 */
function HF(t) {
  return t >>> 1 & 1073741824 | t & 3221225471;
}
const $3e = Object.prototype.valueOf;
function Tp(t) {
  if (t == null)
    return P8(t);
  if (typeof t.hashCode == "function")
    return HF(t.hashCode(t));
  const e = U3e(t);
  if (e == null)
    return P8(e);
  switch (typeof e) {
    case "boolean":
      return e ? 1108378657 : 1108378656;
    case "number":
      return L3e(e);
    case "string":
      return e.length > H3e ? F3e(e) : QN(e);
    case "object":
    case "function":
      return z3e(e);
    case "symbol":
      return B3e(e);
    default:
      if (typeof e.toString == "function")
        return QN(e.toString());
      throw new Error("Value type " + typeof e + " cannot be hashed.");
  }
}
function P8(t) {
  return t === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function L3e(t) {
  if (t !== t || t === 1 / 0)
    return 0;
  let e = t | 0;
  for (e !== t && (e ^= t * 4294967295); t > 4294967295; )
    t /= 4294967295, e ^= t;
  return HF(e);
}
function F3e(t) {
  let e = YM[t];
  return e === void 0 && (e = QN(t), GM === V3e && (GM = 0, YM = {}), GM++, YM[t] = e), e;
}
function QN(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++)
    e = 31 * e + t.charCodeAt(n) | 0;
  return HF(e);
}
function B3e(t) {
  let e = k8[t];
  return e !== void 0 || (e = cte(), k8[t] = e), e;
}
function z3e(t) {
  let e = I8.get(t);
  return e !== void 0 || (e = cte(), I8.set(t, e)), e;
}
function U3e(t) {
  return t.valueOf !== $3e && typeof t.valueOf == "function" ? t.valueOf(t) : t;
}
function cte() {
  const t = ++KM;
  return KM & 1073741824 && (KM = 0), t;
}
const I8 = /* @__PURE__ */ new WeakMap(), k8 = /* @__PURE__ */ Object.create(null);
let KM = 0;
const H3e = 16, V3e = 255;
let GM = 0, YM = {};
const iy = 5, G0 = 1 << iy, ay = G0 - 1, su = {};
function A8() {
  return { value: !1 };
}
function zc(t) {
  t && (t.value = !0);
}
function VF(t, e) {
  e = e || 0;
  const n = Math.max(0, t.length - e), r = new Array(n);
  for (let s = 0; s < n; s++)
    r[s] = t[s + e];
  return r;
}
const cy = Object.is;
class lte {
}
class WF {
  constructor(e) {
    // @pragma Construction
    // @ts-ignore
    P(this, "_root");
    // @ts-ignore
    P(this, "size");
    // @ts-ignore
    P(this, "__ownerID");
    // @ts-ignore
    P(this, "__hash");
    // @ts-ignore
    P(this, "__altered");
    return e == null ? _m() : e instanceof WF ? e : _m().withMutations((n) => {
      for (const [r, s] of e)
        n.set(r, s);
    });
  }
  get(e, n) {
    return this._root ? this._root.get(0, void 0, e, n) : n;
  }
  set(e, n) {
    return D8(this, e, n);
  }
  delete(e) {
    return D8(this, e, su);
  }
  deleteAll(e) {
    return this.withMutations((n) => {
      for (const r of e)
        n.delete(r);
    });
  }
  __ensureOwner(e) {
    return e === this.__ownerID ? this : e ? YF(this.size, this._root, e, this.__hash) : this.size === 0 ? _m() : (this.__ownerID = e, this.__altered = !1, this);
  }
  withMutations(e) {
    const n = this.asMutable();
    return e(n), n.wasAltered() ? n.__ensureOwner(this.__ownerID) : this;
  }
  wasAltered() {
    return this.__altered;
  }
  asMutable() {
    return this.__ownerID ? this : this.__ensureOwner(new lte());
  }
  [Symbol.iterator]() {
    return this.entries()[Symbol.iterator]();
  }
  entries() {
    return new qM(this, W3e, !1);
  }
  keys() {
    return new qM(this, dte, !1);
  }
  values() {
    return new qM(this, ute, !1);
  }
}
class KF {
  constructor(e, n) {
    this.ownerID = e, this.entries = n;
  }
  get(e, n, r, s) {
    const o = this.entries;
    for (let i = 0, a = o.length; i < a; i++)
      if (cy(r, o[i][0]))
        return o[i][1];
    return s;
  }
  update(e, n, r, s, o, i, a) {
    const c = o === su, l = this.entries;
    let d = 0;
    const u = l.length;
    for (; d < u && !cy(s, l[d][0]); d++)
      ;
    const f = d < u;
    if (f ? l[d][1] === o : c)
      return this;
    if (zc(a), (c || !f) && zc(i), c && l.length === 1)
      return;
    if (!f && !c && l.length >= J3e)
      return Y3e(e, l, s, o);
    const p = e && e === this.ownerID, g = p ? l : VF(l);
    return f ? c ? d === u - 1 ? g.pop() : g[d] = g.pop() : g[d] = [s, o] : g.push([s, o]), p ? (this.entries = g, this) : new KF(e, g);
  }
}
class II {
  constructor(e, n, r) {
    this.ownerID = e, this.bitmap = n, this.nodes = r;
  }
  get(e, n, r, s) {
    n === void 0 && (n = Tp(r));
    const o = 1 << ((e === 0 ? n : n >>> e) & ay), i = this.bitmap;
    return i & o ? this.nodes[j8(i & o - 1)].get(e + iy, n, r, s) : s;
  }
  update(e, n, r, s, o, i, a) {
    r === void 0 && (r = Tp(s));
    const c = (n === 0 ? r : r >>> n) & ay, l = 1 << c, d = this.bitmap, u = (d & l) !== 0;
    if (!u && o === su)
      return this;
    const f = j8(d & l - 1), p = this.nodes, g = u ? p[f] : void 0, y = qF(
      g,
      e,
      n + iy,
      r,
      s,
      o,
      i,
      a
    );
    if (y === g)
      return this;
    if (!u && y && p.length >= e5e)
      return X3e(e, p, d, c, y);
    if (u && !y && p.length === 2 && N8(p[f ^ 1]))
      return p[f ^ 1];
    if (u && y && p.length === 1 && N8(y))
      return y;
    const m = e && e === this.ownerID, v = u ? y ? d : d ^ l : d | l, b = u ? y ? fte(p, f, y, m) : Q3e(p, f, m) : Z3e(p, f, y, m);
    return m ? (this.bitmap = v, this.nodes = b, this) : new II(e, v, b);
  }
}
class GF {
  constructor(e, n, r) {
    this.ownerID = e, this.count = n, this.nodes = r;
  }
  get(e, n, r, s) {
    n === void 0 && (n = Tp(r));
    const o = (e === 0 ? n : n >>> e) & ay, i = this.nodes[o];
    return i ? i.get(e + iy, n, r, s) : s;
  }
  update(e, n, r, s, o, i, a) {
    r === void 0 && (r = Tp(s));
    const c = (n === 0 ? r : r >>> n) & ay, l = o === su, d = this.nodes, u = d[c];
    if (l && !u)
      return this;
    const f = qF(
      u,
      e,
      n + iy,
      r,
      s,
      o,
      i,
      a
    );
    if (f === u)
      return this;
    let p = this.count;
    if (!u)
      p++;
    else if (!f && (p--, p < t5e))
      return q3e(e, d, p, c);
    const g = e && e === this.ownerID, y = fte(d, c, f, g);
    return g ? (this.count = p, this.nodes = y, this) : new GF(e, p, y);
  }
}
class kI {
  constructor(e, n, r) {
    this.ownerID = e, this.keyHash = n, this.entries = r;
  }
  get(e, n, r, s) {
    const o = this.entries;
    for (let i = 0, a = o.length; i < a; i++)
      if (cy(r, o[i][0]))
        return o[i][1];
    return s;
  }
  update(e, n, r, s, o, i, a) {
    r === void 0 && (r = Tp(s));
    const c = o === su;
    if (r !== this.keyHash)
      return c ? this : (zc(a), zc(i), XF(this, e, n, r, [s, o]));
    const l = this.entries;
    let d = 0;
    const u = l.length;
    for (; d < u && !cy(s, l[d][0]); d++)
      ;
    const f = d < u;
    if (f ? l[d][1] === o : c)
      return this;
    if (zc(a), (c || !f) && zc(i), c && u === 2)
      return new pg(e, this.keyHash, l[d ^ 1]);
    const p = e && e === this.ownerID, g = p ? l : VF(l);
    return f ? c ? d === u - 1 ? g.pop() : g[d] = g.pop() : g[d] = [s, o] : g.push([s, o]), p ? (this.entries = g, this) : new kI(e, this.keyHash, g);
  }
}
class pg {
  constructor(e, n, r) {
    this.ownerID = e, this.keyHash = n, this.entry = r;
  }
  get(e, n, r, s) {
    return cy(r, this.entry[0]) ? this.entry[1] : s;
  }
  update(e, n, r, s, o, i, a) {
    const c = o === su, l = cy(s, this.entry[0]);
    if (l ? o === this.entry[1] : c)
      return this;
    if (zc(a), c) {
      zc(i);
      return;
    }
    return l ? e && e === this.ownerID ? (this.entry[1] = o, this) : new pg(e, this.keyHash, [s, o]) : (zc(i), XF(this, e, n, Tp(s), [s, o]));
  }
}
class qM {
  constructor(e, n, r) {
    P(this, "_stack");
    this._type = n, this._reverse = r, this._stack = e._root && M8(e._root);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const e = this._type;
    let n = this._stack;
    for (; n; ) {
      const r = n.node, s = n.index++;
      let o;
      if (r.entry) {
        if (s === 0)
          return XM(e, r.entry);
      } else if ("entries" in r && r.entries) {
        if (o = r.entries.length - 1, s <= o)
          return XM(e, r.entries[this._reverse ? o - s : s]);
      } else if (o = r.nodes.length - 1, s <= o) {
        const i = r.nodes[this._reverse ? o - s : s];
        if (i) {
          if (i.entry)
            return XM(e, i.entry);
          n = this._stack = M8(i, n);
        }
        continue;
      }
      n = this._stack = this._stack.__prev;
    }
    return G3e();
  }
}
function XM(t, e) {
  return K3e(t, e[0], e[1]);
}
function M8(t, e) {
  return {
    node: t,
    index: 0,
    __prev: e
  };
}
const dte = 0, ute = 1, W3e = 2;
function K3e(t, e, n, r) {
  const s = t === dte ? e : t === ute ? n : [e, n];
  return r ? r.value = s : r = {
    value: s,
    done: !1
  }, r;
}
function G3e() {
  return { value: void 0, done: !0 };
}
function YF(t, e, n, r) {
  const s = Object.create(WF.prototype);
  return s.size = t, s._root = e, s.__ownerID = n, s.__hash = r, s.__altered = !1, s;
}
let O8;
function _m() {
  return O8 || (O8 = YF(0));
}
function D8(t, e, n) {
  let r, s;
  if (t._root) {
    const o = A8(), i = A8();
    if (r = qF(t._root, t.__ownerID, 0, void 0, e, n, o, i), !i.value)
      return t;
    s = t.size + (o.value ? n === su ? -1 : 1 : 0);
  } else {
    if (n === su)
      return t;
    s = 1, r = new KF(t.__ownerID, [[e, n]]);
  }
  return t.__ownerID ? (t.size = s, t._root = r, t.__hash = void 0, t.__altered = !0, t) : r ? YF(s, r) : _m();
}
function qF(t, e, n, r, s, o, i, a) {
  return t ? t.update(e, n, r, s, o, i, a) : o === su ? t : (zc(a), zc(i), new pg(e, r, [s, o]));
}
function N8(t) {
  return t.constructor === pg || t.constructor === kI;
}
function XF(t, e, n, r, s) {
  if (t.keyHash === r)
    return new kI(e, r, [t.entry, s]);
  const o = (n === 0 ? t.keyHash : t.keyHash >>> n) & ay, i = (n === 0 ? r : r >>> n) & ay;
  let a;
  const c = o === i ? [XF(t, e, n + iy, r, s)] : (a = new pg(e, r, s), o < i ? [t, a] : [a, t]);
  return new II(e, 1 << o | 1 << i, c);
}
function Y3e(t, e, n, r) {
  t || (t = new lte());
  let s = new pg(t, Tp(n), [n, r]);
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    s = s.update(t, 0, void 0, i[0], i[1]);
  }
  return s;
}
function q3e(t, e, n, r) {
  let s = 0, o = 0;
  const i = new Array(n);
  for (let a = 0, c = 1, l = e.length; a < l; a++, c <<= 1) {
    const d = e[a];
    d !== void 0 && a !== r && (s |= c, i[o++] = d);
  }
  return new II(t, s, i);
}
function X3e(t, e, n, r, s) {
  let o = 0;
  const i = new Array(G0);
  for (let a = 0; n !== 0; a++, n >>>= 1)
    i[a] = n & 1 ? e[o++] : void 0;
  return i[r] = s, new GF(t, o + 1, i);
}
function j8(t) {
  return t -= t >> 1 & 1431655765, t = (t & 858993459) + (t >> 2 & 858993459), t = t + (t >> 4) & 252645135, t += t >> 8, t += t >> 16, t & 127;
}
function fte(t, e, n, r) {
  const s = r ? t : VF(t);
  return s[e] = n, s;
}
function Z3e(t, e, n, r) {
  const s = t.length + 1;
  if (r && e + 1 === s)
    return t[e] = n, t;
  const o = new Array(s);
  let i = 0;
  for (let a = 0; a < s; a++)
    a === e ? (o[a] = n, i = -1) : o[a] = t[a + i];
  return o;
}
function Q3e(t, e, n) {
  const r = t.length - 1;
  if (n && e === r)
    return t.pop(), t;
  const s = new Array(r);
  let o = 0;
  for (let i = 0; i < r; i++)
    i === e && (o = 1), s[i] = t[i + o];
  return s;
}
const J3e = G0 / 4, e5e = G0 / 2, t5e = G0 / 4;
var uq, fq;
class JN {
  constructor(e, n) {
    P(this, "atoms");
    P(this, uq, "AtomMap");
    this.name = e;
    let r = _m();
    n && (r = r.withMutations((s) => {
      for (const [o, i] of n)
        s.set(o, yr(`${e}:${String(o)}`, i));
    })), this.atoms = yr(`${e}:atoms`, r);
  }
  /** @internal */
  getAtom(e) {
    const n = this.atoms.__unsafe__getWithoutCapture().get(e);
    if (!n) {
      this.atoms.get();
      return;
    }
    return n;
  }
  get(e) {
    var r;
    const n = (r = this.getAtom(e)) == null ? void 0 : r.get();
    return tt(n !== _o), n;
  }
  __unsafe__getWithoutCapture(e) {
    const n = this.atoms.__unsafe__getWithoutCapture().get(e);
    if (!n) return;
    const r = n.__unsafe__getWithoutCapture();
    return tt(r !== _o), r;
  }
  has(e) {
    const n = this.getAtom(e);
    return n ? n.get() !== _o : !1;
  }
  __unsafe__hasWithoutCapture(e) {
    const n = this.atoms.__unsafe__getWithoutCapture().get(e);
    return n ? (tt(n.__unsafe__getWithoutCapture() !== _o), !0) : !1;
  }
  set(e, n) {
    const r = this.atoms.__unsafe__getWithoutCapture().get(e);
    return r ? r.set(n) : this.atoms.update((s) => s.set(e, yr(`${this.name}:${String(e)}`, n))), this;
  }
  update(e, n) {
    const r = this.atoms.__unsafe__getWithoutCapture().get(e);
    if (!r)
      throw new Error(`AtomMap: key ${e} not found`);
    const s = r.__unsafe__getWithoutCapture();
    tt(s !== _o), r.set(n(s));
  }
  delete(e) {
    const n = this.atoms.__unsafe__getWithoutCapture().get(e);
    return n ? (va(() => {
      n.set(_o), this.atoms.update((r) => r.delete(e));
    }), !0) : !1;
  }
  deleteMany(e) {
    return va(() => {
      const n = [], r = this.atoms.get().withMutations((s) => {
        for (const o of e) {
          const i = s.get(o);
          if (!i) continue;
          const a = i.get();
          tt(a !== _o), n.push([o, a]), s.delete(o), i.set(_o);
        }
      });
      return n.length && this.atoms.set(r), n;
    });
  }
  clear() {
    return va(() => {
      for (const e of this.atoms.__unsafe__getWithoutCapture().values())
        e.set(_o);
      this.atoms.set(_m());
    });
  }
  *entries() {
    for (const [e, n] of this.atoms.get()) {
      const r = n.get();
      tt(r !== _o), yield [e, r];
    }
  }
  *keys() {
    for (const e of this.atoms.get().keys())
      yield e;
  }
  *values() {
    for (const e of this.atoms.get().values()) {
      const n = e.get();
      tt(n !== _o), yield n;
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.atoms.get().size;
  }
  forEach(e, n) {
    for (const [r, s] of this.entries())
      e.call(n, s, r, this);
  }
  [(fq = Symbol.iterator, uq = Symbol.toStringTag, fq)]() {
    return this.entries();
  }
}
function mx(t) {
  if (process.env.NODE_ENV === "production")
    return t;
  const e = Object.getPrototypeOf(t);
  if (e && !(Array.isArray(t) || e === Object.prototype || e === null || e === JJ))
    throw console.error("cannot include non-js data in a record", t), new Error("cannot include non-js data in a record");
  const n = Object.getOwnPropertyNames(t);
  for (const r of n) {
    const s = t[r];
    s && typeof s == "object" && mx(s);
  }
  return Object.freeze(t);
}
class QC {
  constructor(e) {
    /**
     * The next value of the set.
     *
     * @internal
     */
    P(this, "nextValue");
    /**
     * The diff of the set.
     *
     * @internal
     */
    P(this, "diff");
    this.previousValue = e;
  }
  /**
   * Get the next value of the set.
   *
   * @public
   */
  get() {
    var r, s, o, i;
    const e = ((s = (r = this.diff) == null ? void 0 : r.removed) == null ? void 0 : s.size) ?? 0, n = ((i = (o = this.diff) == null ? void 0 : o.added) == null ? void 0 : i.size) ?? 0;
    if (!(e === 0 && n === 0))
      return { value: this.nextValue, diff: this.diff };
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _add(e, n) {
    var r, s;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue)), this.nextValue.add(e), this.diff ?? (this.diff = {}), n ? (r = this.diff.removed) == null || r.delete(e) : ((s = this.diff).added ?? (s.added = /* @__PURE__ */ new Set()), this.diff.added.add(e));
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @public
   */
  add(e) {
    var s, o, i;
    const n = this.previousValue.has(e);
    if (n)
      return ((o = (s = this.diff) == null ? void 0 : s.removed) == null ? void 0 : o.has(e)) ? this._add(e, n) : void 0;
    (i = this.nextValue) != null && i.has(e) || this._add(e, n);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _remove(e, n) {
    var r, s;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue)), this.nextValue.delete(e), this.diff ?? (this.diff = {}), n ? ((r = this.diff).removed ?? (r.removed = /* @__PURE__ */ new Set()), this.diff.removed.add(e)) : (s = this.diff.added) == null || s.delete(e);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @public
   */
  remove(e) {
    var s, o, i, a;
    const n = this.previousValue.has(e);
    if (!n)
      return ((o = (s = this.diff) == null ? void 0 : s.added) == null ? void 0 : o.has(e)) ? this._remove(e, n) : void 0;
    (a = (i = this.diff) == null ? void 0 : i.removed) != null && a.has(e) || this._remove(e, n);
  }
}
function n5e(t) {
  const e = [];
  for (let n = t.length - 1; n >= 0; n--) {
    const r = t[n];
    if ("id" in r)
      e.unshift(r);
    else {
      const s = r.dependsOn, o = e[0];
      o && (e[0] = {
        ...o,
        dependsOn: s.concat(o.dependsOn ?? [])
      });
    }
  }
  return e;
}
function Em({
  sequence: t,
  sequenceId: e,
  retroactive: n = !0
}) {
  const r = {
    sequenceId: e,
    retroactive: n,
    sequence: n5e(t)
  };
  return hte(r), r;
}
function Gi(t, e) {
  return Object.fromEntries(
    ai(e).map(([n, r]) => [n, `${t}/${r}`])
  );
}
function Aa(t) {
  const e = t.sequenceId;
  return Em({
    sequenceId: e,
    retroactive: t.retroactive ?? !0,
    sequence: t.sequence.map(
      (n) => "id" in n ? {
        ...n,
        scope: "record",
        filter: (r) => {
          var s, o;
          return r.typeName === t.recordType && (((s = n.filter) == null ? void 0 : s.call(n, r)) ?? !0) && (((o = t.filter) == null ? void 0 : o.call(t, r)) ?? !0);
        }
      } : n
    )
  });
}
function r5e(t) {
  const e = new Map(t.map((o) => [o.id, o])), n = /* @__PURE__ */ new Set(), r = [];
  function s(o) {
    tt(!n.has(o.id), `Circular dependency in migrations: ${o.id}`), n.add(o.id);
    const { version: i, sequenceId: a } = _E(o.id), c = e.get(`${a}/${i - 1}`);
    if (c && s(c), o.dependsOn)
      for (const l of o.dependsOn) {
        const d = e.get(l);
        d && s(d);
      }
    e.delete(o.id), r.push(o);
  }
  for (const o of e.values())
    s(o);
  return r;
}
function _E(t) {
  const [e, n] = t.split("/");
  return { sequenceId: e, version: parseInt(n) };
}
function R8(t, e) {
  e && tt(
    t.startsWith(e + "/"),
    `Every migration in sequence '${e}' must have an id starting with '${e}/'. Got invalid id: '${t}'`
  ), tt(t.match(/^(.*?)\/(0|[1-9]\d*)$/), `Invalid migration id: '${t}'`);
}
function hte(t) {
  if (tt(
    !t.sequenceId.includes("/"),
    `sequenceId cannot contain a '/', got ${t.sequenceId}`
  ), tt(t.sequenceId.length, "sequenceId must be a non-empty string"), t.sequence.length === 0)
    return;
  R8(t.sequence[0].id, t.sequenceId);
  let e = _E(t.sequence[0].id).version;
  tt(
    e === 1,
    `Expected the first migrationId to be '${t.sequenceId}/1' but got '${t.sequence[0].id}'`
  );
  for (let n = 1; n < t.sequence.length; n++) {
    const r = t.sequence[n].id;
    R8(r, t.sequenceId);
    const s = _E(r).version;
    tt(
      s === e + 1,
      `Migration id numbers must increase in increments of 1, expected ${t.sequenceId}/${e + 1} but got '${t.sequence[n].id}'`
    ), e = s;
  }
}
var Bu = /* @__PURE__ */ ((t) => (t.IncompatibleSubtype = "incompatible-subtype", t.UnknownType = "unknown-type", t.TargetVersionTooNew = "target-version-too-new", t.TargetVersionTooOld = "target-version-too-old", t.MigrationError = "migration-error", t.UnrecognizedSubtype = "unrecognized-subtype", t))(Bu || {});
function EE() {
  return { added: {}, updated: {}, removed: {} };
}
function ej(t) {
  const e = { added: t.removed, removed: t.added, updated: {} };
  for (const [n, r] of Object.values(t.updated))
    e.updated[n.id] = [r, n];
  return e;
}
function pte(t) {
  return Object.keys(t.added).length === 0 && Object.keys(t.updated).length === 0 && Object.keys(t.removed).length === 0;
}
function ZF(t) {
  const e = { added: {}, removed: {}, updated: {} };
  return yx(e, t), e;
}
function yx(t, e) {
  for (const n of e) {
    for (const [r, s] of ai(n.added))
      if (t.removed[r]) {
        const o = t.removed[r];
        delete t.removed[r], o !== s && (t.updated[r] = [o, s]);
      } else
        t.added[r] = s;
    for (const [r, [s, o]] of ai(n.updated)) {
      if (t.added[r]) {
        t.added[r] = o, delete t.updated[r], delete t.removed[r];
        continue;
      }
      if (t.updated[r]) {
        t.updated[r] = [t.updated[r][0], o], delete t.removed[r];
        continue;
      }
      t.updated[r] = n.updated[r], delete t.removed[r];
    }
    for (const [r, s] of ai(n.removed))
      t.added[r] ? delete t.added[r] : t.updated[r] ? (t.removed[r] = t.updated[r][0], delete t.updated[r]) : t.removed[r] = s;
  }
}
class AI {
  constructor(e, n) {
    P(this, "createDefaultProperties");
    P(this, "validator");
    P(this, "ephemeralKeys");
    P(this, "ephemeralKeySet");
    P(this, "scope");
    this.typeName = e, this.createDefaultProperties = n.createDefaultProperties, this.validator = n.validator ?? { validate: (s) => s }, this.scope = n.scope ?? "document", this.ephemeralKeys = n.ephemeralKeys;
    const r = /* @__PURE__ */ new Set();
    if (n.ephemeralKeys)
      for (const [s, o] of ai(n.ephemeralKeys))
        o && r.add(s);
    this.ephemeralKeySet = r;
  }
  /**
   * Create a new record of this type.
   *
   * @param properties - The properties of the record.
   * @returns The new record.
   */
  create(e) {
    const n = {
      ...this.createDefaultProperties(),
      id: "id" in e ? e.id : this.createId()
    };
    for (const [r, s] of Object.entries(e))
      s !== void 0 && (n[r] = s);
    return n.typeName = this.typeName, n;
  }
  /**
   * Clone a record of this type.
   *
   * @param record - The record to clone.
   * @returns The cloned record.
   * @public
   */
  clone(e) {
    return { ...mr(e), id: this.createId() };
  }
  /**
   * Create a new ID for this record type.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @returns The new ID.
   * @public
   */
  createId(e) {
    return this.typeName + ":" + (e ?? bn());
  }
  /**
   * Create a new ID for this record type based on the given ID.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createCustomId('myId')
   * ```
   *
   * @deprecated - Use `createId` instead.
   * @param id - The ID to base the new ID on.
   * @returns The new ID.
   */
  createCustomId(e) {
    return this.typeName + ":" + e;
  }
  /**
   * Takes an id like `user:123` and returns the part after the colon `123`
   *
   * @param id - The id
   * @returns
   */
  parseId(e) {
    if (!this.isId(e))
      throw new Error(`ID "${e}" is not a valid ID for type "${this.typeName}"`);
    return e.slice(this.typeName.length + 1);
  }
  /**
   * Check whether a record is an instance of this record type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isInstance(someRecord)
   * ```
   *
   * @param record - The record to check.
   * @returns Whether the record is an instance of this record type.
   */
  isInstance(e) {
    return (e == null ? void 0 : e.typeName) === this.typeName;
  }
  /**
   * Check whether an id is an id of this type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isIn('someId')
   * ```
   *
   * @param id - The id to check.
   * @returns Whether the id is an id of this type.
   */
  isId(e) {
    if (!e) return !1;
    for (let n = 0; n < this.typeName.length; n++)
      if (e[n] !== this.typeName[n]) return !1;
    return e[this.typeName.length] === ":";
  }
  /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given
   * default properties.
   *
   * @example
   *
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param createDefaultProperties - A function that returns the default properties of the new RecordType.
   * @returns The new RecordType.
   */
  withDefaultProperties(e) {
    return new AI(this.typeName, {
      createDefaultProperties: e,
      validator: this.validator,
      scope: this.scope,
      ephemeralKeys: this.ephemeralKeys
    });
  }
  /**
   * Check that the passed in record passes the validations for this type. Returns its input
   * correctly typed if it does, but throws an error otherwise.
   */
  validate(e, n) {
    return n && this.validator.validateUsingKnownGoodVersion ? this.validator.validateUsingKnownGoodVersion(n, e) : this.validator.validate(e);
  }
}
function sd(t, e) {
  return new AI(t, {
    createDefaultProperties: () => ({}),
    validator: e.validator,
    scope: e.scope,
    ephemeralKeys: e.ephemeralKeys
  });
}
function s5e(t) {
  if (t.length === 0) return /* @__PURE__ */ new Set();
  const e = t[0], n = t.slice(1), r = /* @__PURE__ */ new Set();
  for (const s of e)
    n.every((o) => o.has(s)) && r.add(s);
  return r;
}
function o5e(t, e) {
  const n = {};
  for (const r of e)
    t.has(r) || (n.added ?? (n.added = /* @__PURE__ */ new Set()), n.added.add(r));
  for (const r of t)
    e.has(r) || (n.removed ?? (n.removed = /* @__PURE__ */ new Set()), n.removed.add(r));
  return n.added || n.removed ? n : void 0;
}
function $8(t, e) {
  for (const [n, r] of Object.entries(t)) {
    const s = r, o = e[n];
    if ("eq" in s && o !== s.eq || "neq" in s && o === s.neq || "gt" in s && (typeof o != "number" || o <= s.gt)) return !1;
  }
  return !0;
}
function L8(t, e, n) {
  const r = Object.fromEntries(Object.keys(n).map((s) => [s, /* @__PURE__ */ new Set()]));
  for (const [s, o] of Object.entries(n))
    if ("eq" in o) {
      const a = t.index(e, s).get().get(o.eq);
      if (a)
        for (const c of a)
          r[s].add(c);
    } else if ("neq" in o) {
      const i = t.index(e, s);
      for (const [a, c] of i.get())
        if (a !== o.neq)
          for (const l of c)
            r[s].add(l);
    } else if ("gt" in o) {
      const i = t.index(e, s);
      for (const [a, c] of i.get())
        if (a > o.gt)
          for (const l of c)
            r[s].add(l);
    }
  return s5e(Object.values(r));
}
class i5e {
  constructor(e, n) {
    /**
     * A cache of derivations (indexes).
     *
     * @internal
     */
    P(this, "indexCache", /* @__PURE__ */ new Map());
    /**
     * A cache of derivations (filtered histories).
     *
     * @internal
     */
    P(this, "historyCache", /* @__PURE__ */ new Map());
    this.recordMap = e, this.history = n;
  }
  /**
   * Create a derivation that contains the history for a given type
   *
   * @param typeName - The name of the type to filter by.
   * @returns A derivation that returns the ids of all records of the given type.
   * @public
   */
  filterHistory(e) {
    if (this.historyCache.has(e))
      return this.historyCache.get(e);
    const n = ve(
      "filterHistory:" + e,
      (r, s) => {
        if (op(r))
          return this.history.get();
        const o = this.history.getDiffSince(s);
        if (o === ma) return this.history.get();
        const i = { added: {}, removed: {}, updated: {} };
        let a = 0, c = 0, l = 0;
        for (const d of o) {
          for (const u of Er(d.added))
            if (u.typeName === e)
              if (i.removed[u.id]) {
                const f = i.removed[u.id];
                delete i.removed[u.id], c--, f !== u && (i.updated[u.id] = [f, u], l++);
              } else
                i.added[u.id] = u, a++;
          for (const [u, f] of Er(d.updated))
            f.typeName === e && (i.added[f.id] ? i.added[f.id] = f : i.updated[f.id] ? i.updated[f.id] = [i.updated[f.id][0], f] : (i.updated[f.id] = [u, f], l++));
          for (const u of Er(d.removed))
            u.typeName === e && (i.added[u.id] ? (delete i.added[u.id], a--) : i.updated[u.id] ? (i.removed[u.id] = i.updated[u.id][0], delete i.updated[u.id], l--, c++) : (i.removed[u.id] = u, c++));
        }
        return a || c || l ? Db(this.history.get(), i) : r;
      },
      { historyLength: 100 }
    );
    return this.historyCache.set(e, n), n;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type.
   * @param property - The name of the property.
   * @public
   */
  index(e, n) {
    const r = e + ":" + n;
    if (this.indexCache.has(r))
      return this.indexCache.get(r);
    const s = this.__uncached_createIndex(e, n);
    return this.indexCache.set(r, s), s;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type?.
   * @param property - The name of the property?.
   * @internal
   */
  __uncached_createIndex(e, n) {
    const r = this.filterHistory(e), s = () => {
      r.get();
      const o = /* @__PURE__ */ new Map();
      for (const i of this.recordMap.values())
        if (i.typeName === e) {
          const a = i[n];
          o.has(a) || o.set(a, /* @__PURE__ */ new Set()), o.get(a).add(i.id);
        }
      return o;
    };
    return ve(
      "index:" + e + ":" + n,
      (o, i) => {
        if (op(o)) return s();
        const a = r.getDiffSince(i);
        if (a === ma)
          return s();
        const c = /* @__PURE__ */ new Map(), l = (p, g) => {
          let y = c.get(p);
          y || (y = new QC(
            o.get(p) ?? /* @__PURE__ */ new Set()
          )), y.add(g), c.set(p, y);
        }, d = (p, g) => {
          let y = c.get(p);
          y || (y = new QC(o.get(p) ?? /* @__PURE__ */ new Set())), y.remove(g), c.set(p, y);
        };
        for (const p of a) {
          for (const g of Er(p.added))
            if (g.typeName === e) {
              const y = g[n];
              l(y, g.id);
            }
          for (const [g, y] of Er(p.updated))
            if (y.typeName === e) {
              const m = g[n], v = y[n];
              m !== v && (d(m, y.id), l(v, y.id));
            }
          for (const g of Er(p.removed))
            if (g.typeName === e) {
              const y = g[n];
              d(y, g.id);
            }
        }
        let u, f;
        for (const [p, g] of c) {
          const y = g.get();
          y && (u || (u = new Map(o)), f || (f = /* @__PURE__ */ new Map()), y.value.size === 0 ? u.delete(p) : u.set(p, y.value), f.set(p, y.diff));
        }
        return u && f ? Db(u, f) : o;
      },
      { historyLength: 100 }
    );
  }
  /**
   * Create a derivation that will return a signle record matching the given query.
   *
   * It will return undefined if there is no matching record
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optional) The name of the query.
   */
  record(e, n = () => ({}), r = "record:" + e + (n ? ":" + n.toString() : "")) {
    const s = this.ids(e, n, r);
    return ve(r, () => {
      for (const o of s.get())
        return this.recordMap.get(o);
    });
  }
  /**
   * Create a derivation that will return an array of records matching the given query
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  records(e, n = () => ({}), r = "records:" + e + (n ? ":" + n.toString() : "")) {
    const s = this.ids(e, n, "ids:" + r);
    return ve(
      r,
      () => Array.from(s.get(), (o) => this.recordMap.get(o)),
      {
        isEqual: pE
      }
    );
  }
  /**
   * Create a derivation that will return the ids of all records of the given type.
   *
   * @param typeName - The name of the type.
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  ids(e, n = () => ({}), r = "ids:" + e + (n ? ":" + n.toString() : "")) {
    const s = this.filterHistory(e), o = () => {
      s.get();
      const c = n();
      if (Object.keys(c).length === 0) {
        const l = /* @__PURE__ */ new Set();
        for (const d of this.recordMap.values())
          d.typeName === e && l.add(d.id);
        return l;
      }
      return L8(this, e, c);
    }, i = (c) => {
      const l = o(), d = o5e(c, l);
      return d ? Db(l, d) : c;
    }, a = ve("ids_query:" + r, n, {
      isEqual: Zf
    });
    return ve(
      "query:" + r,
      (c, l) => {
        const d = a.get();
        if (op(c))
          return o();
        if (l < a.lastChangedEpoch)
          return i(c);
        const u = s.getDiffSince(l);
        if (u === ma)
          return i(c);
        const f = new QC(
          c
        );
        for (const g of u) {
          for (const y of Er(g.added))
            y.typeName === e && $8(d, y) && f.add(y.id);
          for (const [y, m] of Er(g.updated))
            m.typeName === e && ($8(d, m) ? f.add(m.id) : f.remove(m.id));
          for (const y of Er(g.removed))
            y.typeName === e && f.remove(y.id);
        }
        const p = f.get();
        return p ? Db(p.value, p.diff) : c;
      },
      { historyLength: 50 }
    );
  }
  exec(e, n) {
    const r = L8(this, e, n);
    return r.size === 0 ? Br : Array.from(r, (s) => this.recordMap.get(s));
  }
}
class a5e {
  constructor(e) {
    P(this, "_beforeCreateHandlers", {});
    P(this, "_afterCreateHandlers", {});
    P(this, "_beforeChangeHandlers", {});
    P(this, "_afterChangeHandlers", {});
    P(this, "_beforeDeleteHandlers", {});
    P(this, "_afterDeleteHandlers", {});
    P(this, "_operationCompleteHandlers", []);
    P(this, "_isEnabled", !0);
    this.store = e;
  }
  /** @internal */
  isEnabled() {
    return this._isEnabled;
  }
  /** @internal */
  setIsEnabled(e) {
    this._isEnabled = e;
  }
  /** @internal */
  handleBeforeCreate(e, n) {
    if (!this._isEnabled) return e;
    const r = this._beforeCreateHandlers[e.typeName];
    if (r) {
      let s = e;
      for (const o of r)
        s = o(s, n);
      return s;
    }
    return e;
  }
  /** @internal */
  handleAfterCreate(e, n) {
    if (!this._isEnabled) return;
    const r = this._afterCreateHandlers[e.typeName];
    if (r)
      for (const s of r)
        s(e, n);
  }
  /** @internal */
  handleBeforeChange(e, n, r) {
    if (!this._isEnabled) return n;
    const s = this._beforeChangeHandlers[n.typeName];
    if (s) {
      let o = n;
      for (const i of s)
        o = i(e, o, r);
      return o;
    }
    return n;
  }
  /** @internal */
  handleAfterChange(e, n, r) {
    if (!this._isEnabled) return;
    const s = this._afterChangeHandlers[n.typeName];
    if (s)
      for (const o of s)
        o(e, n, r);
  }
  /** @internal */
  handleBeforeDelete(e, n) {
    if (!this._isEnabled) return !0;
    const r = this._beforeDeleteHandlers[e.typeName];
    if (r) {
      for (const s of r)
        if (s(e, n) === !1)
          return !1;
    }
    return !0;
  }
  /** @internal */
  handleAfterDelete(e, n) {
    if (!this._isEnabled) return;
    const r = this._afterDeleteHandlers[e.typeName];
    if (r)
      for (const s of r)
        s(e, n);
  }
  /** @internal */
  handleOperationComplete(e) {
    if (this._isEnabled)
      for (const n of this._operationCompleteHandlers)
        n(e);
  }
  /**
   * Internal helper for registering a bunch of side effects at once and keeping them organized.
   * @internal
   */
  register(e) {
    const n = [];
    for (const [r, s] of Object.entries(e))
      s != null && s.beforeCreate && n.push(this.registerBeforeCreateHandler(r, s.beforeCreate)), s != null && s.afterCreate && n.push(this.registerAfterCreateHandler(r, s.afterCreate)), s != null && s.beforeChange && n.push(this.registerBeforeChangeHandler(r, s.beforeChange)), s != null && s.afterChange && n.push(this.registerAfterChangeHandler(r, s.afterChange)), s != null && s.beforeDelete && n.push(this.registerBeforeDeleteHandler(r, s.beforeDelete)), s != null && s.afterDelete && n.push(this.registerAfterDeleteHandler(r, s.afterDelete));
    return () => {
      for (const r of n) r();
    };
  }
  /**
   * Register a handler to be called before a record of a certain type is created. Return a
   * modified record from the handler to change the record that will be created.
   *
   * Use this handle only to modify the creation of the record itself. If you want to trigger a
   * side-effect on a different record (for example, moving one shape when another is created),
   * use {@link StoreSideEffects.registerAfterCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
   *     // only modify shapes created by the user
   *     if (source !== 'user') return shape
   *
   *     //by default, arrow shapes have no label. Let's make sure they always have a label.
   *     if (shape.type === 'arrow') {
   *         return {...shape, props: {...shape.props, text: 'an arrow'}}
   *     }
   *
   *     // other shapes get returned unmodified
   *     return shape
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeCreateHandler(e, n) {
    return this._beforeCreateHandlers[e] || (this._beforeCreateHandlers[e] = []), this._beforeCreateHandlers[e].push(n), () => wh(this._beforeCreateHandlers[e], n);
  }
  /**
   * Register a handler to be called after a record is created. This is useful for side-effects
   * that would update _other_ records. If you want to modify the record being created use
   * {@link StoreSideEffects.registerBeforeCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {
   *     // Automatically create a shape when a page is created
   *     editor.createShape<TLTextShape>({
   *         id: createShapeId(),
   *         type: 'text',
   *         props: { richText: toRichText(page.name) },
   *     })
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterCreateHandler(e, n) {
    return this._afterCreateHandlers[e] || (this._afterCreateHandlers[e] = []), this._afterCreateHandlers[e].push(n), () => wh(this._afterCreateHandlers[e], n);
  }
  /**
   * Register a handler to be called before a record is changed. The handler is given the old and
   * new record - you can return a modified record to apply a different update, or the old record
   * to block the update entirely.
   *
   * Use this handler only for intercepting updates to the record itself. If you want to update
   * other records in response to a change, use
   * {@link StoreSideEffects.registerAfterChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
   *     if (next.isLocked && !prev.isLocked) {
   *         // prevent shapes from ever being locked:
   *         return prev
   *     }
   *     // other types of change are allowed
   *     return next
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeChangeHandler(e, n) {
    return this._beforeChangeHandlers[e] || (this._beforeChangeHandlers[e] = []), this._beforeChangeHandlers[e].push(n), () => wh(this._beforeChangeHandlers[e], n);
  }
  /**
   * Register a handler to be called after a record is changed. This is useful for side-effects
   * that would update _other_ records - if you want to modify the record being changed, use
   * {@link StoreSideEffects.registerBeforeChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
   *     if (next.props.color === 'red') {
   *         // there can only be one red shape at a time:
   *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)
   *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterChangeHandler(e, n) {
    return this._afterChangeHandlers[e] || (this._afterChangeHandlers[e] = []), this._afterChangeHandlers[e].push(n), () => wh(this._afterChangeHandlers[e], n);
  }
  /**
   * Register a handler to be called before a record is deleted. The handler can return `false` to
   * prevent the deletion.
   *
   * Use this handler only for intercepting deletions of the record itself. If you want to do
   * something to other records in response to a deletion, use
   * {@link StoreSideEffects.registerAfterDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
   *     if (shape.props.color === 'red') {
   *         // prevent red shapes from being deleted
   * 	       return false
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeDeleteHandler(e, n) {
    return this._beforeDeleteHandlers[e] || (this._beforeDeleteHandlers[e] = []), this._beforeDeleteHandlers[e].push(n), () => wh(this._beforeDeleteHandlers[e], n);
  }
  /**
   * Register a handler to be called after a record is deleted. This is useful for side-effects
   * that would update _other_ records - if you want to block the deletion of the record itself,
   * use {@link StoreSideEffects.registerBeforeDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
   *     // if the last shape in a frame is deleted, delete the frame too:
   *     const parentFrame = editor.getShape(shape.parentId)
   *     if (!parentFrame || parentFrame.type !== 'frame') return
   *
   *     const siblings = editor.getSortedChildIdsForParent(parentFrame)
   *     if (siblings.length === 0) {
   *         editor.deleteShape(parentFrame.id)
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterDeleteHandler(e, n) {
    return this._afterDeleteHandlers[e] || (this._afterDeleteHandlers[e] = []), this._afterDeleteHandlers[e].push(n), () => wh(this._afterDeleteHandlers[e], n);
  }
  /**
   * Register a handler to be called when a store completes an atomic operation.
   *
   * @example
   * ```ts
   * let count = 0
   *
   * editor.sideEffects.registerOperationCompleteHandler(() => count++)
   *
   * editor.selectAll()
   * expect(count).toBe(1)
   *
   * editor.store.atomic(() => {
   *	editor.selectNone()
   * 	editor.selectAll()
   * })
   *
   * expect(count).toBe(2)
   * ```
   *
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   *
   * @public
   */
  registerOperationCompleteHandler(e) {
    return this._operationCompleteHandlers.push(e), () => wh(this._operationCompleteHandlers, e);
  }
}
function wh(t, e) {
  const n = t.indexOf(e);
  n >= 0 && t.splice(n, 1);
}
class QF {
  constructor(e) {
    /**
     * The random id of the store.
     */
    P(this, "id");
    /**
     * An AtomMap containing the stores records.
     *
     * @internal
     * @readonly
     */
    P(this, "records");
    /**
     * An atom containing the store's history.
     *
     * @public
     * @readonly
     */
    P(this, "history", yr("history", 0, {
      historyLength: 1e3
    }));
    /**
     * A StoreQueries instance for this store.
     *
     * @public
     * @readonly
     */
    P(this, "query");
    /**
     * A set containing listeners that have been added to this store.
     *
     * @internal
     */
    P(this, "listeners", /* @__PURE__ */ new Set());
    /**
     * An array of history entries that have not yet been flushed.
     *
     * @internal
     */
    P(this, "historyAccumulator", new l5e());
    /**
     * A reactor that responds to changes to the history by squashing the accumulated history and
     * notifying listeners of the changes.
     *
     * @internal
     */
    P(this, "historyReactor");
    P(this, "schema");
    P(this, "props");
    P(this, "scopedTypes");
    P(this, "sideEffects", new a5e(this));
    P(this, "isMergingRemoteChanges", !1);
    P(this, "_integrityChecker");
    P(this, "_isPossiblyCorrupted", !1);
    P(this, "pendingAfterEvents", null);
    P(this, "_isInAtomicOp", !1);
    const { initialData: n, schema: r, id: s } = e;
    this.id = s ?? bn(), this.schema = r, this.props = e.props, n ? this.records = new JN(
      "store",
      ai(n).map(([o, i]) => [
        o,
        mx(this.schema.validateRecord(this, i, "initialize", null))
      ])
    ) : this.records = new JN("store"), this.query = new i5e(this.records, this.history), this.historyReactor = y3e(
      "Store.historyReactor",
      () => {
        this.history.get(), this._flushHistory();
      },
      { scheduleEffect: (o) => this.cancelHistoryReactor = yF(o) }
    ), this.scopedTypes = {
      document: new Set(
        Er(this.schema.types).filter((o) => o.scope === "document").map((o) => o.typeName)
      ),
      session: new Set(
        Er(this.schema.types).filter((o) => o.scope === "session").map((o) => o.typeName)
      ),
      presence: new Set(
        Er(this.schema.types).filter((o) => o.scope === "presence").map((o) => o.typeName)
      )
    };
  }
  /**
   * Function to dispose of any in-flight timeouts.
   *
   * @internal
   */
  cancelHistoryReactor() {
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const e = this.historyAccumulator.flush();
      for (const { changes: n, source: r } of e) {
        let s = null, o = null, i = null;
        for (const { onHistory: a, filters: c } of this.listeners)
          if (!(c.source !== "all" && c.source !== r))
            if (c.scope !== "all")
              if (c.scope === "document") {
                if (o ?? (o = this.filterChangesByScope(n, "document")), !o) continue;
                a({ changes: o, source: r });
              } else if (c.scope === "session") {
                if (s ?? (s = this.filterChangesByScope(n, "session")), !s) continue;
                a({ changes: s, source: r });
              } else {
                if (i ?? (i = this.filterChangesByScope(n, "presence")), !i) continue;
                a({ changes: i, source: r });
              }
            else
              a({ changes: n, source: r });
      }
    }
  }
  dispose() {
    this.cancelHistoryReactor();
  }
  /**
   * Filters out non-document changes from a diff. Returns null if there are no changes left.
   * @param change - the records diff
   * @param scope - the records scope
   * @returns
   */
  filterChangesByScope(e, n) {
    const r = {
      added: gx(e.added, (s, o) => this.scopedTypes[n].has(o.typeName)),
      updated: gx(e.updated, (s, o) => this.scopedTypes[n].has(o[1].typeName)),
      removed: gx(e.removed, (s, o) => this.scopedTypes[n].has(o.typeName))
    };
    return Object.keys(r.added).length === 0 && Object.keys(r.updated).length === 0 && Object.keys(r.removed).length === 0 ? null : r;
  }
  /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */
  updateHistory(e) {
    this.historyAccumulator.add({
      changes: e,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    }), this.listeners.size === 0 && this.historyAccumulator.clear(), this.history.set(this.history.get() + 1, e);
  }
  validate(e) {
    this.allRecords().forEach((n) => this.schema.validateRecord(this, n, e, null));
  }
  /**
   * Add some records to the store. It's an error if they already exist.
   *
   * @param records - The records to add.
   * @param phaseOverride - The phase override.
   * @public
   */
  put(e, n) {
    this.atomic(() => {
      const r = {}, s = {};
      let o, i = !1;
      const a = this.isMergingRemoteChanges ? "remote" : "user";
      for (let c = 0, l = e.length; c < l; c++) {
        o = e[c];
        const d = this.records.__unsafe__getWithoutCapture(o.id);
        if (d) {
          if (o = this.sideEffects.handleBeforeChange(d, o, a), this.schema.validateRecord(
            this,
            o,
            n ?? "updateRecord",
            d
          ) === d) continue;
          o = mx(o), this.records.set(o.id, o), i = !0, r[o.id] = [d, o], this.addDiffForAfterEvent(d, o);
        } else
          o = this.sideEffects.handleBeforeCreate(o, a), i = !0, o = this.schema.validateRecord(
            this,
            o,
            n ?? "createRecord",
            null
          ), o = mx(o), s[o.id] = o, this.addDiffForAfterEvent(null, o), this.records.set(o.id, o);
      }
      i && this.updateHistory({
        added: s,
        updated: r,
        removed: {}
      });
    });
  }
  /**
   * Remove some records from the store via their ids.
   *
   * @param ids - The ids of the records to remove.
   * @public
   */
  remove(e) {
    this.atomic(() => {
      const n = new Set(e), r = this.isMergingRemoteChanges ? "remote" : "user";
      if (this.sideEffects.isEnabled())
        for (const i of e) {
          const a = this.records.__unsafe__getWithoutCapture(i);
          a && this.sideEffects.handleBeforeDelete(a, r) === !1 && n.delete(i);
        }
      const s = this.records.deleteMany(n);
      if (s.length === 0) return;
      const o = {};
      for (const [i, a] of s)
        o[i] = a, this.addDiffForAfterEvent(a, null);
      this.updateHistory({ added: {}, updated: {}, removed: o });
    });
  }
  /**
   * Get the value of a store record by its id.
   *
   * @param id - The id of the record to get.
   * @public
   */
  get(e) {
    return this.records.get(e);
  }
  /**
   * Get the value of a store record by its id without updating its epoch.
   *
   * @param id - The id of the record to get.
   * @public
   */
  unsafeGetWithoutCapture(e) {
    return this.records.__unsafe__getWithoutCapture(e);
  }
  /**
   * Creates a JSON payload from the record store.
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   * @returns The record store snapshot as a JSON payload.
   */
  serialize(e = "document") {
    const n = {};
    for (const [r, s] of this.records)
      (e === "all" || this.scopedTypes[e].has(s.typeName)) && (n[r] = s);
    return n;
  }
  /**
   * Get a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   *
   * @public
   */
  getStoreSnapshot(e = "document") {
    return {
      store: this.serialize(e),
      schema: this.schema.serialize()
    };
  }
  /**
   * @deprecated use `getSnapshot` from the 'tldraw' package instead.
   */
  getSnapshot(e = "document") {
    return console.warn(
      "[tldraw] `Store.getSnapshot` is deprecated and will be removed in a future release. Use `getSnapshot` from the `tldraw` package instead."
    ), this.getStoreSnapshot(e);
  }
  /**
   * Migrate a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getSnapshot()
   * store.migrateSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  migrateSnapshot(e) {
    const n = this.schema.migrateStoreSnapshot(e);
    if (n.type === "error")
      throw new Error(`Failed to migrate snapshot: ${n.reason}`);
    return {
      store: n.value,
      schema: this.schema.serialize()
    };
  }
  /**
   * Load a serialized snapshot.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  loadStoreSnapshot(e) {
    const n = this.schema.migrateStoreSnapshot(e);
    if (n.type === "error")
      throw new Error(`Failed to migrate snapshot: ${n.reason}`);
    const r = this.sideEffects.isEnabled();
    try {
      this.sideEffects.setIsEnabled(!1), this.atomic(() => {
        this.clear(), this.put(Object.values(n.value)), this.ensureStoreIsUsable();
      });
    } finally {
      this.sideEffects.setIsEnabled(r);
    }
  }
  /**
   * @public
   * @deprecated use `loadSnapshot` from the 'tldraw' package instead.
   */
  loadSnapshot(e) {
    console.warn(
      "[tldraw] `Store.loadSnapshot` is deprecated and will be removed in a future release. Use `loadSnapshot` from the 'tldraw' package instead."
    ), this.loadStoreSnapshot(e);
  }
  /**
   * Get an array of all values in the store.
   *
   * @returns An array of all values in the store.
   * @public
   */
  allRecords() {
    return Array.from(this.records.values());
  }
  /**
   * Removes all records from the store.
   *
   * @public
   */
  clear() {
    this.remove(Array.from(this.records.keys()));
  }
  /**
   * Update a record. To update multiple records at once, use the `update` method of the
   * `TypedStore` class.
   *
   * @param id - The id of the record to update.
   * @param updater - A function that updates the record.
   */
  update(e, n) {
    const r = this.unsafeGetWithoutCapture(e);
    if (!r) {
      console.error(`Record ${e} not found. This is probably an error`);
      return;
    }
    this.put([n(r)]);
  }
  /**
   * Get whether the record store has a id.
   *
   * @param id - The id of the record to check.
   * @public
   */
  has(e) {
    return this.records.has(e);
  }
  /**
   * Add a new listener to the store.
   *
   * @param onHistory - The listener to call when the store updates.
   * @param filters - Filters to apply to the listener.
   * @returns A function to remove the listener.
   */
  listen(e, n) {
    this._flushHistory();
    const r = {
      onHistory: e,
      filters: {
        source: (n == null ? void 0 : n.source) ?? "all",
        scope: (n == null ? void 0 : n.scope) ?? "all"
      }
    };
    return this.historyReactor.scheduler.isActivelyListening || (this.historyReactor.start(), this.historyReactor.scheduler.execute()), this.listeners.add(r), () => {
      this.listeners.delete(r), this.listeners.size === 0 && this.historyReactor.stop();
    };
  }
  /**
   * Merge changes from a remote source
   *
   * @param fn - A function that merges the external changes.
   * @public
   */
  mergeRemoteChanges(e) {
    if (this.isMergingRemoteChanges)
      return e();
    if (this._isInAtomicOp)
      throw new Error("Cannot merge remote changes while in atomic operation");
    try {
      this.atomic(e, !0, !0);
    } finally {
      this.ensureStoreIsUsable();
    }
  }
  /**
   * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.
   */
  extractingChanges(e) {
    const n = [], r = this.historyAccumulator.addInterceptor((s) => n.push(s.changes));
    try {
      return va(e), ZF(n);
    } finally {
      r();
    }
  }
  applyDiff(e, {
    runCallbacks: n = !0,
    ignoreEphemeralKeys: r = !1
  } = {}) {
    this.atomic(() => {
      const s = Er(e.added);
      for (const [i, a] of Er(e.updated)) {
        const c = this.schema.getType(a.typeName);
        if (r && c.ephemeralKeySet.size) {
          const l = this.get(a.id);
          if (!l) {
            s.push(a);
            continue;
          }
          let d = null;
          for (const [u, f] of Object.entries(a))
            c.ephemeralKeySet.has(u) || Object.is(f, Fr(l, u)) || (d || (d = { ...l }), d[u] = f);
          d && s.push(d);
        } else
          s.push(a);
      }
      const o = px(e.removed);
      s.length && this.put(s), o.length && this.remove(o);
    }, n);
  }
  /**
   * Create a cache based on values in the store. Pass in a function that takes and ID and a
   * signal for the underlying record. Return a signal (usually a computed) for the cached value.
   * For simple derivations, use {@link Store.createComputedCache}. This function is useful if you
   * need more precise control over intermediate values.
   */
  createCache(e) {
    const n = new No();
    return {
      get: (r) => {
        const s = this.records.getAtom(r);
        if (s)
          return n.get(s, () => e(r, s)).get();
      }
    };
  }
  /**
   * Create a computed cache.
   *
   * @param name - The name of the derivation cache.
   * @param derive - A function used to derive the value of the cache.
   * @param opts - Options for the computed cache.
   * @public
   */
  createComputedCache(e, n, r) {
    return this.createCache((s, o) => {
      const i = r != null && r.areRecordsEqual ? ve(`${e}:${s}:isEqual`, () => o.get(), { isEqual: r.areRecordsEqual }) : o;
      return ve(
        e + ":" + s,
        () => n(i.get()),
        {
          isEqual: r == null ? void 0 : r.areResultsEqual
        }
      );
    });
  }
  /** @internal */
  ensureStoreIsUsable() {
    this.atomic(() => {
      var e;
      this._integrityChecker ?? (this._integrityChecker = this.schema.createIntegrityChecker(this)), (e = this._integrityChecker) == null || e.call(this);
    });
  }
  /** @internal */
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = !0;
  }
  /** @internal */
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted;
  }
  addDiffForAfterEvent(e, n) {
    if (tt(this.pendingAfterEvents, "must be in event operation"), e === n || (e && n && tt(e.id === n.id), !e && !n)) return;
    const r = (e || n).id, s = this.pendingAfterEvents.get(r);
    s ? s.after = n : this.pendingAfterEvents.set(r, { before: e, after: n });
  }
  flushAtomicCallbacks(e) {
    let n = 0, r = e ? "remote" : "user";
    for (; this.pendingAfterEvents; ) {
      const s = this.pendingAfterEvents;
      if (this.pendingAfterEvents = null, !!this.sideEffects.isEnabled()) {
        if (n++, n > 100)
          throw new Error("Maximum store update depth exceeded, bailing out");
        for (const { before: o, after: i } of s.values())
          o && i && o !== i && !Zf(o, i) ? this.sideEffects.handleAfterChange(o, i, r) : o && !i ? this.sideEffects.handleAfterDelete(o, r) : !o && i && this.sideEffects.handleAfterCreate(i, r);
        this.pendingAfterEvents ? r = "user" : this.sideEffects.handleOperationComplete(r);
      }
    }
  }
  /** @internal */
  atomic(e, n = !0, r = !1) {
    return va(() => {
      if (this._isInAtomicOp) {
        this.pendingAfterEvents || (this.pendingAfterEvents = /* @__PURE__ */ new Map());
        const o = this.sideEffects.isEnabled();
        tt(!r, "cannot call mergeRemoteChanges while in atomic operation");
        try {
          return o && !n && this.sideEffects.setIsEnabled(!1), e();
        } finally {
          this.sideEffects.setIsEnabled(o);
        }
      }
      this.pendingAfterEvents = /* @__PURE__ */ new Map();
      const s = this.sideEffects.isEnabled();
      this.sideEffects.setIsEnabled(n ?? s), this._isInAtomicOp = !0, r && (this.isMergingRemoteChanges = !0);
      try {
        const o = e();
        return this.isMergingRemoteChanges = !1, this.flushAtomicCallbacks(r), o;
      } finally {
        this.pendingAfterEvents = null, this.sideEffects.setIsEnabled(s), this._isInAtomicOp = !1, this.isMergingRemoteChanges = !1;
      }
    });
  }
  /** @internal */
  addHistoryInterceptor(e) {
    return this.historyAccumulator.addInterceptor(
      (n) => e(n, this.isMergingRemoteChanges ? "remote" : "user")
    );
  }
}
function c5e(t) {
  if (t.length === 0) return [];
  const e = [];
  let n = [t[0]], r;
  for (let s = 1, o = t.length; s < o; s++)
    r = t[s], n[0].source !== r.source && (e.push(n), n = []), n.push(r);
  return e.push(n), mx(
    e.map((s) => ({
      source: s[0].source,
      changes: ZF(s.map((o) => o.changes))
    }))
  );
}
class l5e {
  constructor() {
    P(this, "_history", []);
    P(this, "_interceptors", /* @__PURE__ */ new Set());
  }
  addInterceptor(e) {
    return this._interceptors.add(e), () => {
      this._interceptors.delete(e);
    };
  }
  add(e) {
    this._history.push(e);
    for (const n of this._interceptors)
      n(e);
  }
  flush() {
    const e = c5e(this._history);
    return this._history = [], e;
  }
  clear() {
    this._history = [];
  }
  hasChanges() {
    return this._history.length > 0;
  }
}
function MI(t, e, n) {
  const r = new No();
  return {
    get(s, o) {
      return r.get(s, () => (s instanceof QF ? s : s.store).createComputedCache(t, (c) => e(s, c), n)).get(o);
    }
  };
}
function d5e(t) {
  if (t.schemaVersion > 2 || t.schemaVersion < 1) return xf.err("Bad schema version");
  if (t.schemaVersion === 2) return xf.ok(t);
  const e = {
    schemaVersion: 2,
    sequences: {
      "com.tldraw.store": t.storeVersion
    }
  };
  for (const [n, r] of Object.entries(t.recordVersions))
    if (e.sequences[`com.tldraw.${n}`] = r.version, "subTypeKey" in r)
      for (const [s, o] of Object.entries(r.subTypeVersions))
        e.sequences[`com.tldraw.${n}.${s}`] = o;
  return xf.ok(e);
}
class JF {
  constructor(e, n) {
    P(this, "migrations", {});
    P(this, "sortedMigrations");
    var s;
    this.types = e, this.options = n;
    for (const o of n.migrations ?? [])
      tt(!this.migrations[o.sequenceId], `Duplicate migration sequenceId ${o.sequenceId}`), hte(o), this.migrations[o.sequenceId] = o;
    const r = Object.values(this.migrations).flatMap((o) => o.sequence);
    this.sortedMigrations = r5e(r);
    for (const o of this.sortedMigrations)
      if ((s = o.dependsOn) != null && s.length)
        for (const i of o.dependsOn) {
          const a = r.find((c) => c.id === i);
          tt(a, `Migration '${o.id}' depends on missing migration '${i}'`);
        }
  }
  static create(e, n) {
    return new JF(e, n ?? {});
  }
  validateRecord(e, n, r, s) {
    try {
      const o = Fr(this.types, n.typeName);
      if (!o)
        throw new Error(`Missing definition for record type ${n.typeName}`);
      return o.validate(n, s ?? void 0);
    } catch (o) {
      if (this.options.onValidationFailure)
        return this.options.onValidationFailure({
          store: e,
          record: n,
          phase: r,
          recordBefore: s,
          error: o
        });
      throw o;
    }
  }
  // TODO: use a weakmap to store the result of this function
  getMigrationsSince(e) {
    const n = d5e(e);
    if (!n.ok)
      return n;
    const r = n.value, s = new Set(
      // start with any shared sequences
      Object.keys(r.sequences).filter((i) => this.migrations[i])
    );
    for (const i in this.migrations)
      r.sequences[i] === void 0 && this.migrations[i].retroactive && s.add(i);
    if (s.size === 0)
      return xf.ok([]);
    const o = /* @__PURE__ */ new Set();
    for (const i of s) {
      const a = r.sequences[i];
      if (typeof a != "number" && this.migrations[i].retroactive || a === 0) {
        for (const d of this.migrations[i].sequence)
          o.add(d.id);
        continue;
      }
      const c = `${i}/${a}`, l = this.migrations[i].sequence.findIndex((d) => d.id === c);
      if (l === -1)
        return xf.err("Incompatible schema?");
      for (const d of this.migrations[i].sequence.slice(l + 1))
        o.add(d.id);
    }
    return xf.ok(this.sortedMigrations.filter(({ id: i }) => o.has(i)));
  }
  migratePersistedRecord(e, n, r = "up") {
    const s = this.getMigrationsSince(n);
    if (!s.ok)
      return console.error("Error migrating record", s.error), { type: "error", reason: Bu.MigrationError };
    let o = s.value;
    if (o.length === 0)
      return { type: "success", value: e };
    if (o.some((i) => i.scope === "store"))
      return {
        type: "error",
        reason: r === "down" ? Bu.TargetVersionTooOld : Bu.TargetVersionTooNew
      };
    if (r === "down") {
      if (!o.every((i) => i.down))
        return {
          type: "error",
          reason: Bu.TargetVersionTooOld
        };
      o = o.slice().reverse();
    }
    e = mr(e);
    try {
      for (const i of o) {
        if (i.scope === "store") throw new Error(
          /* won't happen, just for TS */
        );
        if (!(i.filter ? i.filter(e) : !0)) continue;
        const c = i[r](e);
        c && (e = mr(c));
      }
    } catch (i) {
      return console.error("Error migrating record", i), { type: "error", reason: Bu.MigrationError };
    }
    return { type: "success", value: e };
  }
  migrateStoreSnapshot(e) {
    let { store: n } = e;
    const r = this.getMigrationsSince(e.schema);
    if (!r.ok)
      return console.error("Error migrating store", r.error), { type: "error", reason: Bu.MigrationError };
    const s = r.value;
    if (s.length === 0)
      return { type: "success", value: n };
    n = mr(n);
    try {
      for (const o of s)
        if (o.scope === "record")
          for (const [i, a] of Object.entries(n)) {
            if (!(o.filter ? o.filter(a) : !0)) continue;
            const l = o.up(a);
            l && (n[i] = mr(l));
          }
        else if (o.scope === "store") {
          const i = o.up(n);
          i && (n = mr(i));
        } else
          Jt(o);
    } catch (o) {
      return console.error("Error migrating store", o), { type: "error", reason: Bu.MigrationError };
    }
    return { type: "success", value: n };
  }
  /** @internal */
  createIntegrityChecker(e) {
    var n, r;
    return ((r = (n = this.options).createIntegrityChecker) == null ? void 0 : r.call(n, e)) ?? void 0;
  }
  serialize() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId: e, sequence: n }) => [
          e,
          n.length ? _E(n.at(-1).id).version : 0
        ])
      )
    };
  }
  /**
   * @deprecated This is only here for legacy reasons, don't use it unless you have david's blessing!
   */
  serializeEarliestVersion() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId: e }) => [e, 0])
      )
    };
  }
  /** @internal */
  getType(e) {
    const n = Fr(this.types, e);
    return tt(n, "record type does not exists"), n;
  }
}
Xf(
  "@tldraw/store",
  "3.15.5",
  "esm"
);
function u5e(t) {
  if (!t.length)
    return null;
  let e = "";
  for (const n of t)
    typeof n == "number" ? e += `.${n}` : n.startsWith("(") ? e.endsWith(")") ? e = `${e.slice(0, -1)}, ${n.slice(1)}` : e += n : e += `.${n}`;
  return e = e.replace(/id = [^,]+, /, "").replace(/id = [^)]+/, ""), e.startsWith(".") ? e.slice(1) : e;
}
class en extends Error {
  constructor(n, r = []) {
    const s = u5e(r), o = n.split(`
`).map((i, a) => a === 0 ? i : `  ${i}`).join(`
`);
    super(r ? `At ${s}: ${o}` : o);
    P(this, "name", "ValidationError");
    this.rawMessage = n, this.path = r;
  }
}
function Bi(t, e) {
  try {
    return e();
  } catch (n) {
    throw n instanceof en ? new en(n.rawMessage, [t, ...n.path]) : new en(n.toString(), [t]);
  }
}
function Nf(t) {
  if (t === null) return "null";
  if (Array.isArray(t)) return "an array";
  const e = typeof t;
  switch (e) {
    case "bigint":
    case "boolean":
    case "function":
    case "number":
    case "string":
    case "symbol":
      return `a ${e}`;
    case "object":
      return `an ${e}`;
    case "undefined":
      return "undefined";
    default:
      Jt(e);
  }
}
class $o {
  constructor(e, n) {
    this.validationFn = e, this.validateUsingKnownGoodVersionFn = n;
  }
  /**
   * Asserts that the passed value is of the correct type and returns it. The returned value is
   * guaranteed to be referentially equal to the passed value.
   */
  validate(e) {
    const n = this.validationFn(e);
    if (process.env.NODE_ENV !== "production" && !Object.is(e, n))
      throw new en("Validator functions must return the same value they were passed");
    return n;
  }
  validateUsingKnownGoodVersion(e, n) {
    return Object.is(e, n) ? e : this.validateUsingKnownGoodVersionFn ? this.validateUsingKnownGoodVersionFn(e, n) : this.validate(n);
  }
  /** Checks that the passed value is of the correct type. */
  isValid(e) {
    try {
      return this.validate(e), !0;
    } catch {
      return !1;
    }
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  nullable() {
    return v5e(this);
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  optional() {
    return mte(this);
  }
  /**
   * Refine this validation to a new type. The passed-in validation function should throw an error
   * if the value can't be converted to the new type, or return the new type otherwise.
   */
  refine(e) {
    return new $o(
      (n) => e(this.validate(n)),
      (n, r) => {
        const s = this.validateUsingKnownGoodVersion(n, r);
        return Object.is(n, s) ? n : e(s);
      }
    );
  }
  check(e, n) {
    return typeof e == "string" ? this.refine((r) => (Bi(`(check ${e})`, () => n(r)), r)) : this.refine((r) => (e(r), r));
  }
}
class f5e extends $o {
  constructor(e) {
    super(
      (n) => {
        const r = F8.validate(n);
        for (let s = 0; s < r.length; s++)
          Bi(s, () => e.validate(r[s]));
        return r;
      },
      (n, r) => {
        if (!e.validateUsingKnownGoodVersion) return this.validate(r);
        const s = F8.validate(r);
        let o = n.length !== s.length;
        for (let i = 0; i < s.length; i++) {
          const a = s[i];
          if (i >= n.length) {
            o = !0, Bi(i, () => e.validate(a));
            continue;
          }
          if (Object.is(n[i], a))
            continue;
          const c = Bi(
            i,
            () => e.validateUsingKnownGoodVersion(n[i], a)
          );
          Object.is(c, n[i]) || (o = !0);
        }
        return o ? r : n;
      }
    ), this.itemValidator = e;
  }
  nonEmpty() {
    return this.check((e) => {
      if (e.length === 0)
        throw new en("Expected a non-empty array");
    });
  }
  lengthGreaterThan1() {
    return this.check((e) => {
      if (e.length <= 1)
        throw new en("Expected an array with length greater than 1");
    });
  }
}
class TE extends $o {
  constructor(e, n = !1) {
    super(
      (r) => {
        if (typeof r != "object" || r === null)
          throw new en(`Expected object, got ${Nf(r)}`);
        for (const [s, o] of Object.entries(e))
          Bi(s, () => {
            o.validate(Fr(r, s));
          });
        if (!n) {
          for (const s of Object.keys(r))
            if (!rc(e, s))
              throw new en("Unexpected property", [s]);
        }
        return r;
      },
      (r, s) => {
        if (typeof s != "object" || s === null)
          throw new en(`Expected object, got ${Nf(s)}`);
        let o = !1;
        for (const [i, a] of Object.entries(e)) {
          const c = Fr(r, i), l = Fr(s, i);
          if (Object.is(c, l))
            continue;
          const d = Bi(i, () => {
            const u = a;
            return u.validateUsingKnownGoodVersion ? u.validateUsingKnownGoodVersion(c, l) : u.validate(l);
          });
          Object.is(d, c) || (o = !0);
        }
        if (!n) {
          for (const i of Object.keys(s))
            if (!rc(e, i))
              throw new en("Unexpected property", [i]);
        }
        for (const i of Object.keys(r))
          if (!rc(s, i)) {
            o = !0;
            break;
          }
        return o ? s : r;
      }
    ), this.config = e, this.shouldAllowUnknownProperties = n;
  }
  allowUnknownProperties() {
    return new TE(this.config, !0);
  }
  /**
   * Extend an object validator by adding additional properties.
   *
   * @example
   *
   * ```ts
   * const animalValidator = T.object({
   * 	name: T.string,
   * })
   * const catValidator = animalValidator.extend({
   * 	meowVolume: T.number,
   * })
   * ```
   */
  extend(e) {
    return new TE({ ...this.config, ...e });
  }
}
class OI extends $o {
  constructor(e, n, r, s) {
    super(
      (o) => {
        this.expectObject(o);
        const { matchingSchema: i, variant: a } = this.getMatchingSchemaAndVariant(o);
        return i === void 0 ? this.unknownValueValidation(o, a) : Bi(`(${e} = ${a})`, () => i.validate(o));
      },
      (o, i) => {
        this.expectObject(i), this.expectObject(o);
        const { matchingSchema: a, variant: c } = this.getMatchingSchemaAndVariant(i);
        return a === void 0 ? this.unknownValueValidation(i, c) : Fr(o, e) !== Fr(i, e) ? Bi(`(${e} = ${c})`, () => a.validate(i)) : Bi(`(${e} = ${c})`, () => a.validateUsingKnownGoodVersion ? a.validateUsingKnownGoodVersion(o, i) : a.validate(i));
      }
    ), this.key = e, this.config = n, this.unknownValueValidation = r, this.useNumberKeys = s;
  }
  expectObject(e) {
    if (typeof e != "object" || e === null)
      throw new en(`Expected an object, got ${Nf(e)}`, []);
  }
  getMatchingSchemaAndVariant(e) {
    const n = Fr(e, this.key);
    if (!this.useNumberKeys && typeof n != "string")
      throw new en(
        `Expected a string for key "${this.key}", got ${Nf(n)}`
      );
    if (this.useNumberKeys && !Number.isFinite(Number(n)))
      throw new en(`Expected a number for key "${this.key}", got "${n}"`);
    return { matchingSchema: rc(this.config, n) ? this.config[n] : void 0, variant: n };
  }
  validateUnknownVariants(e) {
    return new OI(this.key, this.config, e, this.useNumberKeys);
  }
}
class h5e extends $o {
  constructor(e, n) {
    super(
      (r) => {
        if (typeof r != "object" || r === null)
          throw new en(`Expected object, got ${Nf(r)}`);
        for (const [s, o] of Object.entries(r))
          Bi(s, () => {
            e.validate(s), n.validate(o);
          });
        return r;
      },
      (r, s) => {
        if (typeof s != "object" || s === null)
          throw new en(`Expected object, got ${Nf(s)}`);
        let o = !1;
        for (const [i, a] of Object.entries(s)) {
          if (!rc(r, i)) {
            o = !0, Bi(i, () => {
              e.validate(i), n.validate(a);
            });
            continue;
          }
          const c = Fr(r, i), l = a;
          if (Object.is(c, l))
            continue;
          const d = Bi(i, () => n.validateUsingKnownGoodVersion ? n.validateUsingKnownGoodVersion(c, l) : n.validate(l));
          Object.is(d, c) || (o = !0);
        }
        for (const i of Object.keys(r))
          if (!rc(s, i)) {
            o = !0;
            break;
          }
        return o ? s : r;
      }
    ), this.keyValidator = e, this.valueValidator = n;
  }
}
function e3(t) {
  return new $o((e) => {
    if (typeof e !== t)
      throw new en(`Expected ${t}, got ${Nf(e)}`);
    return e;
  });
}
const p5e = new $o((t) => t), g5e = new $o((t) => t), Et = e3("string"), dt = e3("number").check((t) => {
  if (Number.isNaN(t))
    throw new en("Expected a number, got NaN");
  if (!Number.isFinite(t))
    throw new en(`Expected a finite number, got ${t}`);
}), PE = dt.check((t) => {
  if (t < 0) throw new en(`Expected a positive number, got ${t}`);
}), Ur = dt.check((t) => {
  if (t <= 0) throw new en(`Expected a non-zero positive number, got ${t}`);
}), gte = dt.check((t) => {
  if (!Number.isInteger(t)) throw new en(`Expected an integer, got ${t}`);
}), JC = gte.check((t) => {
  if (t < 0) throw new en(`Expected a positive integer, got ${t}`);
}), m5e = gte.check((t) => {
  if (t <= 0) throw new en(`Expected a non-zero positive integer, got ${t}`);
}), Bt = e3("boolean");
function Do(t) {
  return new $o((e) => {
    if (e !== t)
      throw new en(`Expected ${t}, got ${JSON.stringify(e)}`);
    return t;
  });
}
const F8 = new $o((t) => {
  if (!Array.isArray(t))
    throw new en(`Expected an array, got ${Nf(t)}`);
  return t;
});
function Ms(t) {
  return new f5e(t);
}
function Gt(t) {
  return new TE(t);
}
function tj(t) {
  return typeof t == "object" && t !== null && (Object.getPrototypeOf(t) === Object.prototype || Object.getPrototypeOf(t) === null || Object.getPrototypeOf(t) === JJ);
}
function nj(t) {
  return t === null || typeof t == "number" || typeof t == "string" || typeof t == "boolean" ? !0 : Array.isArray(t) ? t.every(nj) : tj(t) ? Object.values(t).every(nj) : !1;
}
const ro = new $o(
  (t) => {
    if (nj(t))
      return t;
    throw new en(`Expected json serializable value, got ${typeof t}`);
  },
  (t, e) => {
    if (Array.isArray(t) && Array.isArray(e)) {
      let n = t.length !== e.length;
      for (let r = 0; r < e.length; r++) {
        if (r >= t.length) {
          n = !0, ro.validate(e[r]);
          continue;
        }
        const s = t[r], o = e[r];
        if (Object.is(s, o))
          continue;
        const i = ro.validateUsingKnownGoodVersion(s, o);
        Object.is(i, s) || (n = !0);
      }
      return n ? e : t;
    } else if (tj(t) && tj(e)) {
      let n = !1;
      for (const r of Object.keys(e)) {
        if (!rc(t, r)) {
          n = !0, ro.validate(e[r]);
          continue;
        }
        const s = t[r], o = e[r];
        if (Object.is(s, o))
          continue;
        const i = ro.validateUsingKnownGoodVersion(s, o);
        Object.is(i, s) || (n = !0);
      }
      for (const r of Object.keys(t))
        if (!rc(e, r)) {
          n = !0;
          break;
        }
      return n ? e : t;
    } else
      return ro.validate(e);
  }
);
function IE(t, e) {
  return new h5e(t, e);
}
function t3(t, e) {
  return new OI(
    t,
    e,
    (n, r) => {
      throw new en(
        `Expected one of ${Object.keys(e).map((s) => JSON.stringify(s)).join(" or ")}, got ${JSON.stringify(r)}`,
        [t]
      );
    },
    !1
  );
}
function y5e(t, e) {
  return new OI(
    t,
    e,
    (n, r) => {
      throw new en(
        `Expected one of ${Object.keys(e).map((s) => JSON.stringify(s)).join(" or ")}, got ${JSON.stringify(r)}`,
        [t]
      );
    },
    !0
  );
}
function od(t, e) {
  return new $o(
    (n) => Bi(t, () => e.validate(n)),
    (n, r) => Bi(t, () => e.validateUsingKnownGoodVersion ? e.validateUsingKnownGoodVersion(n, r) : e.validate(r))
  );
}
function DI(t) {
  return new $o((e) => {
    if (!t.has(e)) {
      const n = Array.from(t, (r) => JSON.stringify(r)).join(" or ");
      throw new en(`Expected ${n}, got ${e}`);
    }
    return e;
  });
}
function mte(t) {
  return new $o(
    (e) => {
      if (e !== void 0)
        return t.validate(e);
    },
    (e, n) => {
      if (!(e === void 0 && n === void 0) && n !== void 0)
        return t.validateUsingKnownGoodVersion && e !== void 0 ? t.validateUsingKnownGoodVersion(e, n) : t.validate(n);
    }
  );
}
function v5e(t) {
  return new $o(
    (e) => e === null ? null : t.validate(e),
    (e, n) => n === null ? null : t.validateUsingKnownGoodVersion && e !== null ? t.validateUsingKnownGoodVersion(e, n) : t.validate(n)
  );
}
function av(...t) {
  return DI(new Set(t));
}
function n3(t) {
  try {
    return new URL(t);
  } catch {
    if (t.startsWith("/") || t.startsWith("./"))
      try {
        return new URL(t, "http://example.com");
      } catch {
        throw new en(`Expected a valid url, got ${JSON.stringify(t)}`);
      }
    throw new en(`Expected a valid url, got ${JSON.stringify(t)}`);
  }
}
const b5e = /* @__PURE__ */ new Set(["http:", "https:", "mailto:"]), _a = Et.check((t) => {
  if (t === "") return;
  const e = n3(t);
  if (!b5e.has(e.protocol.toLowerCase()))
    throw new en(
      `Expected a valid url, got ${JSON.stringify(t)} (invalid protocol)`
    );
}), x5e = /* @__PURE__ */ new Set(["http:", "https:", "data:", "asset:"]), Pp = Et.check((t) => {
  if (t === "") return;
  const e = n3(t);
  if (!x5e.has(e.protocol.toLowerCase()))
    throw new en(
      `Expected a valid url, got ${JSON.stringify(t)} (invalid protocol)`
    );
});
Et.check((t) => {
  if (t === "") return;
  if (!n3(t).protocol.toLowerCase().match(/^https?:$/))
    throw new en(
      `Expected a valid url, got ${JSON.stringify(t)} (invalid protocol)`
    );
});
const r3 = Et.refine((t) => {
  try {
    return oDe(t), t;
  } catch {
    throw new en(`Expected an index key, got ${JSON.stringify(t)}`);
  }
});
Xf(
  "@tldraw/validate",
  "3.15.5",
  "esm"
);
function ba(t) {
  return Et.refine((e) => {
    if (!e.startsWith(`${t}:`))
      throw new Error(`${t} ID must start with "${t}:"`);
    return e;
  });
}
const NI = ba("asset");
function s3(t, e) {
  return Gt({
    id: NI,
    typeName: Do("asset"),
    type: Do(t),
    props: e,
    meta: ro
  });
}
const Ip = Gt({
  x: dt,
  y: dt,
  z: dt.optional()
}), vx = Gt({
  x: dt,
  y: dt,
  w: dt,
  h: dt
}), yte = dt.check((t) => {
  if (t < 0 || t > 1)
    throw new en("Opacity must be between 0 and 1");
}), w5e = Et.refine((t) => {
  if (!t.startsWith("page:") && !t.startsWith("shape:"))
    throw new Error('Parent ID must start with "page:" or "shape:"');
  return t;
}), Ka = ba("shape");
function S5e(t, e, n) {
  return Gt({
    id: Ka,
    typeName: Do("shape"),
    x: dt,
    y: dt,
    rotation: dt,
    index: r3,
    parentId: w5e,
    type: Do(t),
    isLocked: Bt,
    opacity: yte,
    props: e ? Gt(e) : ro,
    meta: n ? Gt(n) : ro
  });
}
const C5e = ba("binding");
function _5e(t, e, n) {
  return Gt({
    id: C5e,
    typeName: Do("binding"),
    type: Do(t),
    fromId: Ka,
    toId: Ka,
    props: e ? Gt(e) : ro,
    meta: n ? Gt(n) : ro
  });
}
Gi("com.tldraw.binding", {});
Aa({
  sequenceId: "com.tldraw.binding",
  recordType: "binding",
  sequence: []
});
function ip(t) {
  return `binding:${bn()}`;
}
function E5e(t, e) {
  return Qf(e, (n, r) => `com.tldraw.binding.${t}/${r}`);
}
function T5e(t) {
  return sd("binding", {
    scope: "document",
    validator: od(
      "binding",
      t3(
        "type",
        Qf(
          t,
          (e, { props: n, meta: r }) => _5e(e, n, r)
        )
      )
    )
  }).withDefaultProperties(() => ({
    meta: {}
  }));
}
class zs {
  /** @internal */
  constructor(e, n, r) {
    this.id = e, this.defaultValue = n, this.type = r;
  }
  /**
   * Define a new {@link StyleProp}.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `type`: Optionally, describe what type of data you expect for this style prop.
   *
   * @example
   * ```ts
   * import {T} from '@tldraw/validate'
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {
   *   defaultValue: 1,
   *   type: T.number,
   * })
   * ```
   * @public
   */
  static define(e, n) {
    const { defaultValue: r, type: s = g5e } = n;
    return new zs(e, r, s);
  }
  /**
   * Define a new {@link StyleProp} as a list of possible values.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `values`: An array of possible values of this style prop.
   *
   * @example
   * ```ts
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MySizeProp = StyleProp.defineEnum('myApp:size', {
   *   defaultValue: 'medium',
   *   values: ['small', 'medium', 'large'],
   * })
   * ```
   */
  static defineEnum(e, n) {
    const { defaultValue: r, values: s } = n;
    return new P5e(e, r, s);
  }
  setDefaultValue(e) {
    this.defaultValue = e;
  }
  validate(e) {
    return this.type.validate(e);
  }
  validateUsingKnownGoodVersion(e, n) {
    return this.type.validateUsingKnownGoodVersion ? this.type.validateUsingKnownGoodVersion(e, n) : this.validate(n);
  }
}
class P5e extends zs {
  /** @internal */
  constructor(e, n, r) {
    super(e, n, av(...r)), this.values = r;
  }
}
const x1 = Gi("com.tldraw.shape", {
  AddIsLocked: 1,
  HoistOpacity: 2,
  AddMeta: 3,
  AddWhite: 4
}), I5e = Aa({
  sequenceId: "com.tldraw.shape",
  recordType: "shape",
  sequence: [
    {
      id: x1.AddIsLocked,
      up: (t) => {
        t.isLocked = !1;
      },
      down: (t) => {
        delete t.isLocked;
      }
    },
    {
      id: x1.HoistOpacity,
      up: (t) => {
        t.opacity = Number(t.props.opacity ?? "1"), delete t.props.opacity;
      },
      down: (t) => {
        const e = t.opacity;
        delete t.opacity, t.props.opacity = e < 0.175 ? "0.1" : e < 0.375 ? "0.25" : e < 0.625 ? "0.5" : e < 0.875 ? "0.75" : "1";
      }
    },
    {
      id: x1.AddMeta,
      up: (t) => {
        t.meta = {};
      }
    },
    {
      id: x1.AddWhite,
      up: (t) => {
      },
      down: (t) => {
        t.props.color === "white" && (t.props.color = "black");
      }
    }
  ]
});
function fm(t) {
  return t ? t.typeName === "shape" : !1;
}
function ei(t) {
  return t ? t.startsWith("shape:") : !1;
}
function $n(t) {
  return `shape:${t ?? bn()}`;
}
function vte(t) {
  const e = /* @__PURE__ */ new Map();
  for (const [n, r] of Object.entries(t))
    if (r instanceof zs) {
      if (e.has(r))
        throw new Error(
          `Duplicate style prop ${r.id}. Each style prop can only be used once within a shape.`
        );
      e.set(r, n);
    }
  return e;
}
function hc(t, e) {
  return Qf(e, (n, r) => `com.tldraw.shape.${t}/${r}`);
}
function k5e(t) {
  return sd("shape", {
    scope: "document",
    validator: od(
      "shape",
      t3(
        "type",
        Qf(
          t,
          (e, { props: n, meta: r }) => S5e(e, n, r)
        )
      )
    )
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    rotation: 0,
    isLocked: !1,
    opacity: 1,
    meta: {}
  }));
}
function B8(t, e) {
  const n = [];
  for (const [r, { migrations: s }] of Object.entries(e)) {
    const o = `com.tldraw.${t}.${r}`;
    s ? "sequenceId" in s ? (tt(
      o === s.sequenceId,
      `sequenceId mismatch for ${r} ${AI} migrations. Expected '${o}', got '${s.sequenceId}'`
    ), n.push(s)) : "sequence" in s ? n.push(
      Em({
        sequenceId: o,
        retroactive: !0,
        sequence: s.sequence.map(
          (i) => "id" in i ? bte(t, r, i) : i
        )
      })
    ) : n.push(
      Em({
        sequenceId: o,
        retroactive: !0,
        sequence: Object.keys(s.migrators).map((i) => Number(i)).sort((i, a) => i - a).map(
          (i) => ({
            id: `${o}/${i}`,
            scope: "record",
            filter: (a) => a.typeName === t && a.type === r,
            up: (a) => {
              const c = s.migrators[i].up(a);
              if (c)
                return c;
            },
            down: (a) => {
              const c = s.migrators[i].down(a);
              if (c)
                return c;
            }
          })
        )
      })
    ) : n.push(
      Em({
        sequenceId: o,
        retroactive: !0,
        sequence: []
      })
    );
  }
  return n;
}
function bte(t, e, n) {
  return {
    id: n.id,
    dependsOn: n.dependsOn,
    scope: "record",
    filter: (r) => r.typeName === t && r.type === e,
    up: (r) => {
      const s = n.up(r.props);
      s && (r.props = s);
    },
    down: typeof n.down == "function" ? (r) => {
      const s = n.down(r.props);
      s && (r.props = s);
    } : void 0
  };
}
const xte = [
  "black",
  "grey",
  "light-violet",
  "violet",
  "blue",
  "light-blue",
  "yellow",
  "orange",
  "green",
  "light-green",
  "light-red",
  "red",
  "white"
], kE = {
  lightMode: {
    id: "light",
    text: "#000000",
    background: "#f9fafb",
    solid: "#fcfffe",
    black: {
      solid: "#1d1d1d",
      fill: "#1d1d1d",
      frame: {
        headingStroke: "#717171",
        headingFill: "#ffffff",
        stroke: "#717171",
        fill: "#ffffff",
        text: "#000000"
      },
      note: {
        fill: "#FCE19C",
        text: "#000000"
      },
      semi: "#e8e8e8",
      pattern: "#494949",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8205 0.05)"
      }
    },
    blue: {
      solid: "#4465e9",
      fill: "#4465e9",
      frame: {
        headingStroke: "#6681ec",
        headingFill: "#f9fafe",
        stroke: "#6681ec",
        fill: "#f9fafe",
        text: "#000000"
      },
      note: {
        fill: "#8AA3FF",
        text: "#000000"
      },
      semi: "#dce1f8",
      pattern: "#6681ee",
      highlight: {
        srgb: "#10acff",
        p3: "color(display-p3 0.308 0.6632 0.9996)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      frame: {
        headingStroke: "#37a684",
        headingFill: "#f8fcfa",
        stroke: "#37a684",
        fill: "#f8fcfa",
        text: "#000000"
      },
      note: {
        fill: "#6FC896",
        text: "#000000"
      },
      semi: "#d3e9e3",
      pattern: "#39a785",
      highlight: {
        srgb: "#00ffc8",
        p3: "color(display-p3 0.2536 0.984 0.7981)"
      }
    },
    grey: {
      solid: "#9fa8b2",
      fill: "#9fa8b2",
      frame: {
        headingStroke: "#aaaaab",
        headingFill: "#fbfcfc",
        stroke: "#aaaaab",
        fill: "#fcfcfd",
        text: "#000000"
      },
      note: {
        fill: "#C0CAD3",
        text: "#000000"
      },
      semi: "#eceef0",
      pattern: "#bcc3c9",
      highlight: {
        srgb: "#cbe7f1",
        p3: "color(display-p3 0.8163 0.9023 0.9416)"
      }
    },
    "light-blue": {
      solid: "#4ba1f1",
      fill: "#4ba1f1",
      frame: {
        headingStroke: "#6cb2f3",
        headingFill: "#f8fbfe",
        stroke: "#6cb2f3",
        fill: "#fafcff",
        text: "#000000"
      },
      note: {
        fill: "#9BC4FD",
        text: "#000000"
      },
      semi: "#ddedfa",
      pattern: "#6fbbf8",
      highlight: {
        srgb: "#00f4ff",
        p3: "color(display-p3 0.1512 0.9414 0.9996)"
      }
    },
    "light-green": {
      solid: "#4cb05e",
      fill: "#4cb05e",
      frame: {
        headingStroke: "#6dbe7c",
        headingFill: "#f8fcf9",
        stroke: "#6dbe7c",
        fill: "#fafdfa",
        text: "#000000"
      },
      note: {
        fill: "#98D08A",
        text: "#000000"
      },
      semi: "#dbf0e0",
      pattern: "#65cb78",
      highlight: {
        srgb: "#65f641",
        p3: "color(display-p3 0.563 0.9495 0.3857)"
      }
    },
    "light-red": {
      solid: "#f87777",
      fill: "#f87777",
      frame: {
        headingStroke: "#f89090",
        headingFill: "#fffafa",
        stroke: "#f89090",
        fill: "#fffbfb",
        text: "#000000"
      },
      note: {
        fill: "#F7A5A1",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#fe9e9e",
      highlight: {
        srgb: "#ff7fa3",
        p3: "color(display-p3 0.9988 0.5301 0.6397)"
      }
    },
    "light-violet": {
      solid: "#e085f4",
      fill: "#e085f4",
      frame: {
        headingStroke: "#e59bf5",
        headingFill: "#fefaff",
        stroke: "#e59bf5",
        fill: "#fefbff",
        text: "#000000"
      },
      note: {
        fill: "#DFB0F9",
        text: "#000000"
      },
      semi: "#f5eafa",
      pattern: "#e9acf8",
      highlight: {
        srgb: "#ff88ff",
        p3: "color(display-p3 0.9676 0.5652 0.9999)"
      }
    },
    orange: {
      solid: "#e16919",
      fill: "#e16919",
      frame: {
        headingStroke: "#e68544",
        headingFill: "#fef9f6",
        stroke: "#e68544",
        fill: "#fef9f6",
        text: "#000000"
      },
      note: {
        fill: "#FAA475",
        text: "#000000"
      },
      semi: "#f8e2d4",
      pattern: "#f78438",
      highlight: {
        srgb: "#ffa500",
        p3: "color(display-p3 0.9988 0.6905 0.266)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      frame: {
        headingStroke: "#e55757",
        headingFill: "#fef7f7",
        stroke: "#e55757",
        fill: "#fef9f9",
        text: "#000000"
      },
      note: {
        fill: "#FC8282",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#e55959",
      highlight: {
        srgb: "#ff636e",
        p3: "color(display-p3 0.9992 0.4376 0.45)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      frame: {
        headingStroke: "#bc62d3",
        headingFill: "#fcf7fd",
        stroke: "#bc62d3",
        fill: "#fdf9fd",
        text: "#000000"
      },
      note: {
        fill: "#DB91FD",
        text: "#000000"
      },
      semi: "#ecdcf2",
      pattern: "#bd63d3",
      highlight: {
        srgb: "#c77cff",
        p3: "color(display-p3 0.7469 0.5089 0.9995)"
      }
    },
    yellow: {
      solid: "#f1ac4b",
      fill: "#f1ac4b",
      frame: {
        headingStroke: "#f3bb6c",
        headingFill: "#fefcf8",
        stroke: "#f3bb6c",
        fill: "#fffdfa",
        text: "#000000"
      },
      note: {
        fill: "#FED49A",
        text: "#000000"
      },
      semi: "#f9f0e6",
      pattern: "#fecb92",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8705 0.05)"
      }
    },
    white: {
      solid: "#FFFFFF",
      fill: "#FFFFFF",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frame: {
        headingStroke: "#7d7d7d",
        headingFill: "#ffffff",
        stroke: "#7d7d7d",
        fill: "#ffffff",
        text: "#000000"
      },
      note: {
        fill: "#FFFFFF",
        text: "#000000"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  },
  darkMode: {
    id: "dark",
    text: "hsl(210, 17%, 98%)",
    background: "hsl(240, 5%, 6.5%)",
    solid: "#010403",
    black: {
      solid: "#f2f2f2",
      fill: "#f2f2f2",
      frame: {
        headingStroke: "#5c5c5c",
        headingFill: "#252525",
        stroke: "#5c5c5c",
        fill: "#0c0c0c",
        text: "#f2f2f2"
      },
      note: {
        fill: "#2c2c2c",
        text: "#f2f2f2"
      },
      semi: "#2c3036",
      pattern: "#989898",
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.6225 0.0312)"
      }
    },
    blue: {
      solid: "#4f72fc",
      // 3c60f0
      fill: "#4f72fc",
      frame: {
        headingStroke: "#384994",
        headingFill: "#1C2036",
        stroke: "#384994",
        fill: "#11141f",
        text: "#f2f2f2"
      },
      note: {
        fill: "#2A3F98",
        text: "#f2f2f2"
      },
      semi: "#262d40",
      pattern: "#3a4b9e",
      highlight: {
        srgb: "#0079d2",
        p3: "color(display-p3 0.0032 0.4655 0.7991)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      frame: {
        headingStroke: "#10513C",
        headingFill: "#14241f",
        stroke: "#10513C",
        fill: "#0E1614",
        text: "#f2f2f2"
      },
      note: {
        fill: "#014429",
        text: "#f2f2f2"
      },
      semi: "#253231",
      pattern: "#366a53",
      highlight: {
        srgb: "#009774",
        p3: "color(display-p3 0.0085 0.582 0.4604)"
      }
    },
    grey: {
      solid: "#9398b0",
      fill: "#9398b0",
      frame: {
        headingStroke: "#42474D",
        headingFill: "#23262A",
        stroke: "#42474D",
        fill: "#151719",
        text: "#f2f2f2"
      },
      note: {
        fill: "#56595F",
        text: "#f2f2f2"
      },
      semi: "#33373c",
      pattern: "#7c8187",
      highlight: {
        srgb: "#9cb4cb",
        p3: "color(display-p3 0.6299 0.7012 0.7856)"
      }
    },
    "light-blue": {
      solid: "#4dabf7",
      fill: "#4dabf7",
      frame: {
        headingStroke: "#075797",
        headingFill: "#142839",
        stroke: "#075797",
        fill: "#0B1823",
        text: "#f2f2f2"
      },
      note: {
        fill: "#1F5495",
        text: "#f2f2f2"
      },
      semi: "#2a3642",
      pattern: "#4d7aa9",
      highlight: {
        srgb: "#00bdc8",
        p3: "color(display-p3 0.0023 0.7259 0.7735)"
      }
    },
    "light-green": {
      solid: "#40c057",
      fill: "#40c057",
      frame: {
        headingStroke: "#1C5427",
        headingFill: "#18251A",
        stroke: "#1C5427",
        fill: "#0F1911",
        text: "#f2f2f2"
      },
      note: {
        fill: "#21581D",
        text: "#f2f2f2"
      },
      semi: "#2a3830",
      pattern: "#4e874e",
      highlight: {
        srgb: "#00a000",
        p3: "color(display-p3 0.2711 0.6172 0.0195)"
      }
    },
    "light-red": {
      solid: "#ff8787",
      fill: "#ff8787",
      frame: {
        headingStroke: "#6f3232",
        // Darker and desaturated variant of solid
        headingFill: "#341818",
        // Deep, muted dark red
        stroke: "#6f3232",
        // Matches headingStroke
        fill: "#181212",
        // Darker, muted background shade
        text: "#f2f2f2"
        // Consistent bright text color
      },
      note: {
        fill: "#7a3333",
        // Medium-dark, muted variant of solid
        text: "#f2f2f2"
      },
      semi: "#3c2b2b",
      // Subdued, darker neutral-red tone
      pattern: "#a56767",
      // Existing pattern shade retained
      highlight: {
        srgb: "#db005b",
        p3: "color(display-p3 0.7849 0.0585 0.3589)"
      }
    },
    "light-violet": {
      solid: "#e599f7",
      fill: "#e599f7",
      frame: {
        headingStroke: "#6c367a",
        headingFill: "#2D2230",
        stroke: "#6c367a",
        fill: "#1C151E",
        text: "#f2f2f2"
      },
      note: {
        fill: "#762F8E",
        text: "#f2f2f2"
      },
      semi: "#383442",
      pattern: "#9770a9",
      highlight: {
        srgb: "#c400c7",
        p3: "color(display-p3 0.7024 0.0403 0.753)"
      }
    },
    orange: {
      solid: "#f76707",
      fill: "#f76707",
      frame: {
        headingStroke: "#773a0e",
        // Darker, muted version of solid
        headingFill: "#2f1d13",
        // Deep, warm, muted background
        stroke: "#773a0e",
        // Matches headingStroke
        fill: "#1c1512",
        // Darker, richer muted background
        text: "#f2f2f2"
        // Bright text for contrast
      },
      note: {
        fill: "#7c3905",
        // Muted dark variant for note fill
        text: "#f2f2f2"
      },
      semi: "#3b2e27",
      // Muted neutral-orange tone
      pattern: "#9f552d",
      // Retained existing shade
      highlight: {
        srgb: "#d07a00",
        p3: "color(display-p3 0.7699 0.4937 0.0085)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      frame: {
        headingStroke: "#701e1e",
        // Darker, muted variation of solid
        headingFill: "#301616",
        // Deep, muted reddish backdrop
        stroke: "#701e1e",
        // Matches headingStroke
        fill: "#1b1313",
        // Rich, dark muted background
        text: "#f2f2f2"
        // Bright text for readability
      },
      note: {
        fill: "#7e201f",
        // Muted dark variant for note fill
        text: "#f2f2f2"
      },
      semi: "#382726",
      // Dark neutral-red tone
      pattern: "#8f3734",
      // Existing pattern color retained
      highlight: {
        srgb: "#de002c",
        p3: "color(display-p3 0.7978 0.0509 0.2035)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      frame: {
        headingStroke: "#6d1583",
        // Darker, muted variation of solid
        headingFill: "#27152e",
        // Deep, rich muted violet backdrop
        stroke: "#6d1583",
        // Matches headingStroke
        fill: "#1b0f21",
        // Darker muted violet background
        text: "#f2f2f2"
        // Consistent bright text color
      },
      note: {
        fill: "#5f1c70",
        // Muted dark variant for note fill
        text: "#f2f2f2"
      },
      semi: "#342938",
      // Dark neutral-violet tone
      pattern: "#763a8b",
      // Retained existing pattern color
      highlight: {
        srgb: "#9e00ee",
        p3: "color(display-p3 0.5651 0.0079 0.8986)"
      }
    },
    yellow: {
      solid: "#ffc034",
      fill: "#ffc034",
      frame: {
        headingStroke: "#684e12",
        // Darker, muted variant of solid
        headingFill: "#2a2113",
        // Rich, muted dark-yellow background
        stroke: "#684e12",
        // Matches headingStroke
        fill: "#1e1911",
        // Darker muted shade for background fill
        text: "#f2f2f2"
        // Bright text color for readability
      },
      note: {
        fill: "#8a5e1c",
        // Muted, dark complementary variant
        text: "#f2f2f2"
      },
      semi: "#3b352b",
      // Dark muted neutral-yellow tone
      pattern: "#fecb92",
      // Existing shade retained
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.7225 0.0312)"
      }
    },
    white: {
      solid: "#f3f3f3",
      fill: "#f3f3f3",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frame: {
        headingStroke: "#ffffff",
        headingFill: "#ffffff",
        stroke: "#ffffff",
        fill: "#ffffff",
        text: "#000000"
      },
      note: {
        fill: "#eaeaea",
        text: "#1d1d1d"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  }
};
function mu(t) {
  return t.isDarkMode ? kE.darkMode : kE.lightMode;
}
const di = zs.defineEnum("tldraw:color", {
  defaultValue: "black",
  values: xte
}), o3 = zs.defineEnum("tldraw:labelColor", {
  defaultValue: "black",
  values: xte
}), kp = zs.defineEnum("tldraw:dash", {
  defaultValue: "draw",
  values: ["draw", "solid", "dashed", "dotted"]
}), Ap = zs.defineEnum("tldraw:fill", {
  defaultValue: "none",
  values: ["none", "semi", "solid", "pattern", "fill"]
}), ou = zs.defineEnum("tldraw:font", {
  defaultValue: "draw",
  values: ["draw", "sans", "serif", "mono"]
}), wte = {
  draw: "'tldraw_draw', sans-serif",
  sans: "'tldraw_sans', sans-serif",
  serif: "'tldraw_serif', serif",
  mono: "'tldraw_mono', monospace"
}, Xl = zs.defineEnum("tldraw:size", {
  defaultValue: "m",
  values: ["s", "m", "l", "xl"]
}), A5e = ["arc", "elbow"], aw = zs.defineEnum("tldraw:arrowKind", {
  defaultValue: "arc",
  values: A5e
}), Ste = [
  "arrow",
  "triangle",
  "square",
  "dot",
  "pipe",
  "diamond",
  "inverted",
  "bar",
  "none"
], AE = zs.defineEnum("tldraw:arrowheadStart", {
  defaultValue: "none",
  values: Ste
}), ME = zs.defineEnum("tldraw:arrowheadEnd", {
  defaultValue: "arrow",
  values: Ste
}), Cte = {
  kind: aw,
  labelColor: o3,
  color: di,
  fill: Ap,
  dash: kp,
  size: Xl,
  arrowheadStart: AE,
  arrowheadEnd: ME,
  font: ou,
  start: Ip,
  end: Ip,
  bend: dt,
  text: Et,
  labelPosition: dt,
  scale: Ur,
  elbowMidPoint: dt
}, Th = hc("arrow", {
  AddLabelColor: 1,
  AddIsPrecise: 2,
  AddLabelPosition: 3,
  ExtractBindings: 4,
  AddScale: 5,
  AddElbow: 6
});
function Xv(t) {
  return bte("shape", "arrow", t);
}
const _te = Em({
  sequenceId: "com.tldraw.shape.arrow",
  retroactive: !1,
  sequence: [
    Xv({
      id: Th.AddLabelColor,
      up: (t) => {
        t.labelColor = "black";
      },
      down: "retired"
    }),
    Xv({
      id: Th.AddIsPrecise,
      up: ({ start: t, end: e }) => {
        t.type === "binding" && (t.isPrecise = !(t.normalizedAnchor.x === 0.5 && t.normalizedAnchor.y === 0.5)), e.type === "binding" && (e.isPrecise = !(e.normalizedAnchor.x === 0.5 && e.normalizedAnchor.y === 0.5));
      },
      down: ({ start: t, end: e }) => {
        t.type === "binding" && (t.isPrecise || (t.normalizedAnchor = { x: 0.5, y: 0.5 }), delete t.isPrecise), e.type === "binding" && (e.isPrecise || (e.normalizedAnchor = { x: 0.5, y: 0.5 }), delete e.isPrecise);
      }
    }),
    Xv({
      id: Th.AddLabelPosition,
      up: (t) => {
        t.labelPosition = 0.5;
      },
      down: (t) => {
        delete t.labelPosition;
      }
    }),
    {
      id: Th.ExtractBindings,
      scope: "store",
      up: (t) => {
        const e = Object.values(t).filter(
          (n) => n.typeName === "shape" && n.type === "arrow"
        );
        for (const n of e) {
          const { start: r, end: s } = n.props;
          if (r.type === "binding") {
            const o = ip(), i = {
              typeName: "binding",
              id: o,
              type: "arrow",
              fromId: n.id,
              toId: r.boundShapeId,
              meta: {},
              props: {
                terminal: "start",
                normalizedAnchor: r.normalizedAnchor,
                isExact: r.isExact,
                isPrecise: r.isPrecise
              }
            };
            t[o] = i, n.props.start = { x: 0, y: 0 };
          } else
            delete n.props.start.type;
          if (s.type === "binding") {
            const o = ip(), i = {
              typeName: "binding",
              id: o,
              type: "arrow",
              fromId: n.id,
              toId: s.boundShapeId,
              meta: {},
              props: {
                terminal: "end",
                normalizedAnchor: s.normalizedAnchor,
                isExact: s.isExact,
                isPrecise: s.isPrecise
              }
            };
            t[o] = i, n.props.end = { x: 0, y: 0 };
          } else
            delete n.props.end.type;
        }
      }
    },
    Xv({
      id: Th.AddScale,
      up: (t) => {
        t.scale = 1;
      },
      down: (t) => {
        delete t.scale;
      }
    }),
    Xv({
      id: Th.AddElbow,
      up: (t) => {
        t.kind = "arc", t.elbowMidPoint = 0.5;
      },
      down: (t) => {
        delete t.kind, delete t.elbowMidPoint;
      }
    })
  ]
}), M5e = av("center", "edge-point", "edge", "none"), Ete = {
  terminal: av("start", "end"),
  normalizedAnchor: Ip,
  isExact: Bt,
  isPrecise: Bt,
  snap: M5e
}, O5e = E5e("arrow", {
  AddSnap: 1
}), Tte = {
  sequence: [
    { dependsOn: [Th.ExtractBindings] },
    {
      id: O5e.AddSnap,
      up: (t) => {
        t.snap = "none";
      },
      down: (t) => {
        delete t.snap;
      }
    }
  ]
}, D5e = od(
  "camera",
  Gt({
    typeName: Do("camera"),
    id: ba("camera"),
    x: dt,
    y: dt,
    z: dt,
    meta: ro
  })
), N5e = Gi("com.tldraw.camera", {
  AddMeta: 1
}), j5e = Aa({
  sequenceId: "com.tldraw.camera",
  recordType: "camera",
  sequence: [
    {
      id: N5e.AddMeta,
      up: (t) => {
        t.meta = {};
      }
    }
  ]
}), Rl = sd("camera", {
  validator: D5e,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    z: 1,
    meta: {}
  })
), R5e = /* @__PURE__ */ new Set([
  "none",
  "default",
  "pointer",
  "cross",
  "grab",
  "rotate",
  "grabbing",
  "resize-edge",
  "resize-corner",
  "text",
  "move",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "nesw-rotate",
  "nwse-rotate",
  "swne-rotate",
  "senw-rotate",
  "zoom-in",
  "zoom-out"
]), Pte = DI(R5e), $5e = Gt({
  type: Pte,
  rotation: dt
}), L5e = /* @__PURE__ */ new Set([
  "accent",
  "white",
  "black",
  "selection-stroke",
  "selection-fill",
  "laser",
  "muted-1"
]), F5e = DI(L5e), B5e = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]), Ite = Gt({
  id: Et,
  points: Ms(Ip),
  size: PE,
  color: F5e,
  opacity: dt,
  state: DI(B5e),
  delay: dt,
  shrink: dt,
  taper: Bt
}), cw = ba("page"), z5e = od(
  "page",
  Gt({
    typeName: Do("page"),
    id: cw,
    name: Et,
    index: r3,
    meta: ro
  })
), U5e = Gi("com.tldraw.page", {
  AddMeta: 1
}), H5e = Aa({
  sequenceId: "com.tldraw.page",
  recordType: "page",
  sequence: [
    {
      id: U5e.AddMeta,
      up: (t) => {
        t.meta = {};
      }
    }
  ]
}), ci = sd("page", {
  validator: z5e,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));
function Ys(t) {
  return ci.isId(t);
}
const V5e = {
  // This object defines keys that should be preserved across calls to loadSnapshot()
  id: !1,
  // meta
  typeName: !1,
  // meta
  currentPageId: !1,
  // does not preserve because who knows if the page still exists
  opacityForNextShape: !1,
  // does not preserve because it's a temporary state
  stylesForNextShape: !1,
  // does not preserve because it's a temporary state
  followingUserId: !1,
  // does not preserve because it's a temporary state
  highlightedUserIds: !1,
  // does not preserve because it's a temporary state
  brush: !1,
  // does not preserve because it's a temporary state
  cursor: !1,
  // does not preserve because it's a temporary state
  scribbles: !1,
  // does not preserve because it's a temporary state
  isFocusMode: !0,
  // preserves because it's a user preference
  isDebugMode: !0,
  // preserves because it's a user preference
  isToolLocked: !0,
  // preserves because it's a user preference
  exportBackground: !0,
  // preserves because it's a user preference
  screenBounds: !0,
  // preserves because it's capturing the user's screen state
  insets: !0,
  // preserves because it's capturing the user's screen state
  zoomBrush: !1,
  // does not preserve because it's a temporary state
  chatMessage: !1,
  // does not preserve because it's a temporary state
  isChatting: !1,
  // does not preserve because it's a temporary state
  isPenMode: !1,
  // does not preserve because it's a temporary state
  isGridMode: !0,
  // preserves because it's a user preference
  isFocused: !0,
  // preserves because obviously
  devicePixelRatio: !0,
  // preserves because it captures the user's screen state
  isCoarsePointer: !0,
  // preserves because it captures the user's screen state
  isHoveringCanvas: !1,
  // does not preserve because it's a temporary state
  openMenus: !1,
  // does not preserve because it's a temporary state
  isChangingStyle: !1,
  // does not preserve because it's a temporary state
  isReadonly: !0,
  // preserves because it's a config option
  meta: !1,
  // does not preserve because who knows what's in there, leave it up to sdk users to save and reinstate
  duplicateProps: !1
  //
};
function kte(t) {
  return t ? gx(t, (e) => V5e[e]) : null;
}
ba("instance");
function W5e(t) {
  const e = {};
  for (const [r, s] of t)
    e[r] = mte(s);
  const n = od(
    "instance",
    Gt({
      typeName: Do("instance"),
      id: ba("instance"),
      currentPageId: cw,
      followingUserId: Et.nullable(),
      brush: vx.nullable(),
      opacityForNextShape: yte,
      stylesForNextShape: Gt(e),
      cursor: $5e,
      scribbles: Ms(Ite),
      isFocusMode: Bt,
      isDebugMode: Bt,
      isToolLocked: Bt,
      exportBackground: Bt,
      screenBounds: vx,
      insets: Ms(Bt),
      zoomBrush: vx.nullable(),
      isPenMode: Bt,
      isGridMode: Bt,
      chatMessage: Et,
      isChatting: Bt,
      highlightedUserIds: Ms(Et),
      isFocused: Bt,
      devicePixelRatio: dt,
      isCoarsePointer: Bt,
      isHoveringCanvas: Bt.nullable(),
      openMenus: Ms(Et),
      isChangingStyle: Bt,
      isReadonly: Bt,
      meta: ro,
      duplicateProps: Gt({
        shapeIds: Ms(ba("shape")),
        offset: Gt({
          x: dt,
          y: dt
        })
      }).nullable()
    })
  );
  return sd("instance", {
    validator: n,
    scope: "session",
    ephemeralKeys: {
      currentPageId: !1,
      meta: !1,
      followingUserId: !0,
      opacityForNextShape: !0,
      stylesForNextShape: !0,
      brush: !0,
      cursor: !0,
      scribbles: !0,
      isFocusMode: !0,
      isDebugMode: !0,
      isToolLocked: !0,
      exportBackground: !0,
      screenBounds: !0,
      insets: !0,
      zoomBrush: !0,
      isPenMode: !0,
      isGridMode: !0,
      chatMessage: !0,
      isChatting: !0,
      highlightedUserIds: !0,
      isFocused: !0,
      devicePixelRatio: !0,
      isCoarsePointer: !0,
      isHoveringCanvas: !0,
      openMenus: !0,
      isChangingStyle: !0,
      isReadonly: !0,
      duplicateProps: !0
    }
  }).withDefaultProperties(
    () => ({
      followingUserId: null,
      opacityForNextShape: 1,
      stylesForNextShape: {},
      brush: null,
      scribbles: [],
      cursor: {
        type: "default",
        rotation: 0
      },
      isFocusMode: !1,
      exportBackground: !1,
      isDebugMode: !1,
      isToolLocked: !1,
      screenBounds: { x: 0, y: 0, w: 1080, h: 720 },
      insets: [!1, !1, !1, !1],
      zoomBrush: null,
      isGridMode: !1,
      isPenMode: !1,
      chatMessage: "",
      isChatting: !1,
      highlightedUserIds: [],
      isFocused: !1,
      devicePixelRatio: typeof window > "u" ? 1 : window.devicePixelRatio,
      isCoarsePointer: !1,
      isHoveringCanvas: null,
      openMenus: [],
      isChangingStyle: !1,
      isReadonly: !1,
      meta: {},
      duplicateProps: null
    })
  );
}
const qn = Gi("com.tldraw.instance", {
  AddTransparentExportBgs: 1,
  RemoveDialog: 2,
  AddToolLockMode: 3,
  RemoveExtraPropsForNextShape: 4,
  AddLabelColor: 5,
  AddFollowingUserId: 6,
  RemoveAlignJustify: 7,
  AddZoom: 8,
  AddVerticalAlign: 9,
  AddScribbleDelay: 10,
  RemoveUserId: 11,
  AddIsPenModeAndIsGridMode: 12,
  HoistOpacity: 13,
  AddChat: 14,
  AddHighlightedUserIds: 15,
  ReplacePropsForNextShapeWithStylesForNextShape: 16,
  AddMeta: 17,
  RemoveCursorColor: 18,
  AddLonelyProperties: 19,
  ReadOnlyReadonly: 20,
  AddHoveringCanvas: 21,
  AddScribbles: 22,
  AddInset: 23,
  AddDuplicateProps: 24,
  RemoveCanMoveCamera: 25
}), K5e = Aa({
  sequenceId: "com.tldraw.instance",
  recordType: "instance",
  sequence: [
    {
      id: qn.AddTransparentExportBgs,
      up: (t) => ({ ...t, exportBackground: !0 })
    },
    {
      id: qn.RemoveDialog,
      up: ({ dialog: t, ...e }) => e
    },
    {
      id: qn.AddToolLockMode,
      up: (t) => ({ ...t, isToolLocked: !1 })
    },
    {
      id: qn.RemoveExtraPropsForNextShape,
      up: ({ propsForNextShape: t, ...e }) => ({
        ...e,
        propsForNextShape: Object.fromEntries(
          Object.entries(t).filter(
            ([n]) => [
              "color",
              "labelColor",
              "dash",
              "fill",
              "size",
              "font",
              "align",
              "verticalAlign",
              "icon",
              "geo",
              "arrowheadStart",
              "arrowheadEnd",
              "spline"
            ].includes(n)
          )
        )
      })
    },
    {
      id: qn.AddLabelColor,
      up: ({ propsForNextShape: t, ...e }) => ({
        ...e,
        propsForNextShape: {
          ...t,
          labelColor: "black"
        }
      })
    },
    {
      id: qn.AddFollowingUserId,
      up: (t) => ({ ...t, followingUserId: null })
    },
    {
      id: qn.RemoveAlignJustify,
      up: (t) => {
        let e = t.propsForNextShape.align;
        return e === "justify" && (e = "start"), {
          ...t,
          propsForNextShape: {
            ...t.propsForNextShape,
            align: e
          }
        };
      }
    },
    {
      id: qn.AddZoom,
      up: (t) => ({ ...t, zoomBrush: null })
    },
    {
      id: qn.AddVerticalAlign,
      up: (t) => ({
        ...t,
        propsForNextShape: {
          ...t.propsForNextShape,
          verticalAlign: "middle"
        }
      })
    },
    {
      id: qn.AddScribbleDelay,
      up: (t) => t.scribble !== null ? { ...t, scribble: { ...t.scribble, delay: 0 } } : { ...t }
    },
    {
      id: qn.RemoveUserId,
      up: ({ userId: t, ...e }) => e
    },
    {
      id: qn.AddIsPenModeAndIsGridMode,
      up: (t) => ({ ...t, isPenMode: !1, isGridMode: !1 })
    },
    {
      id: qn.HoistOpacity,
      up: ({ propsForNextShape: { opacity: t, ...e }, ...n }) => ({ ...n, opacityForNextShape: Number(t ?? "1"), propsForNextShape: e })
    },
    {
      id: qn.AddChat,
      up: (t) => ({ ...t, chatMessage: "", isChatting: !1 })
    },
    {
      id: qn.AddHighlightedUserIds,
      up: (t) => ({ ...t, highlightedUserIds: [] })
    },
    {
      id: qn.ReplacePropsForNextShapeWithStylesForNextShape,
      up: ({ propsForNextShape: t, ...e }) => ({ ...e, stylesForNextShape: {} })
    },
    {
      id: qn.AddMeta,
      up: (t) => ({
        ...t,
        meta: {}
      })
    },
    {
      id: qn.RemoveCursorColor,
      up: (t) => {
        const { color: e, ...n } = t.cursor;
        return {
          ...t,
          cursor: n
        };
      }
    },
    {
      id: qn.AddLonelyProperties,
      up: (t) => ({
        ...t,
        canMoveCamera: !0,
        isFocused: !1,
        devicePixelRatio: 1,
        isCoarsePointer: !1,
        openMenus: [],
        isChangingStyle: !1,
        isReadOnly: !1
      })
    },
    {
      id: qn.ReadOnlyReadonly,
      up: ({ isReadOnly: t, ...e }) => ({
        ...e,
        isReadonly: t
      })
    },
    {
      id: qn.AddHoveringCanvas,
      up: (t) => ({
        ...t,
        isHoveringCanvas: null
      })
    },
    {
      id: qn.AddScribbles,
      up: ({ scribble: t, ...e }) => ({
        ...e,
        scribbles: []
      })
    },
    {
      id: qn.AddInset,
      up: (t) => ({
        ...t,
        insets: [!1, !1, !1, !1]
      }),
      down: ({ insets: t, ...e }) => ({
        ...e
      })
    },
    {
      id: qn.AddDuplicateProps,
      up: (t) => ({
        ...t,
        duplicateProps: null
      }),
      down: ({ duplicateProps: t, ...e }) => ({
        ...e
      })
    },
    {
      id: qn.RemoveCanMoveCamera,
      up: ({ canMoveCamera: t, ...e }) => ({
        ...e
      }),
      down: (t) => ({ ...t, canMoveCamera: !0 })
    }
  ]
}), ti = "instance:instance", G5e = od(
  "instance_page_state",
  Gt({
    typeName: Do("instance_page_state"),
    id: ba("instance_page_state"),
    pageId: cw,
    selectedShapeIds: Ms(Ka),
    hintingShapeIds: Ms(Ka),
    erasingShapeIds: Ms(Ka),
    hoveredShapeId: Ka.nullable(),
    editingShapeId: Ka.nullable(),
    croppingShapeId: Ka.nullable(),
    focusedGroupId: Ka.nullable(),
    meta: ro
  })
), Zv = Gi("com.tldraw.instance_page_state", {
  AddCroppingId: 1,
  RemoveInstanceIdAndCameraId: 2,
  AddMeta: 3,
  RenameProperties: 4,
  RenamePropertiesAgain: 5
}), Y5e = Aa({
  sequenceId: "com.tldraw.instance_page_state",
  recordType: "instance_page_state",
  sequence: [
    {
      id: Zv.AddCroppingId,
      up(t) {
        t.croppingShapeId = null;
      }
    },
    {
      id: Zv.RemoveInstanceIdAndCameraId,
      up(t) {
        delete t.instanceId, delete t.cameraId;
      }
    },
    {
      id: Zv.AddMeta,
      up: (t) => {
        t.meta = {};
      }
    },
    {
      id: Zv.RenameProperties,
      // this migration is cursed: it was written wrong and doesn't do anything.
      // rather than replace it, I've added another migration below that fixes it.
      up: (t) => {
      },
      down: (t) => {
      }
    },
    {
      id: Zv.RenamePropertiesAgain,
      up: (t) => {
        t.selectedShapeIds = t.selectedIds, delete t.selectedIds, t.hintingShapeIds = t.hintingIds, delete t.hintingIds, t.erasingShapeIds = t.erasingIds, delete t.erasingIds, t.hoveredShapeId = t.hoveredId, delete t.hoveredId, t.editingShapeId = t.editingId, delete t.editingId, t.croppingShapeId = t.croppingShapeId ?? t.croppingId ?? null, delete t.croppingId, t.focusedGroupId = t.focusLayerId, delete t.focusLayerId;
      },
      down: (t) => {
        t.selectedIds = t.selectedShapeIds, delete t.selectedShapeIds, t.hintingIds = t.hintingShapeIds, delete t.hintingShapeIds, t.erasingIds = t.erasingShapeIds, delete t.erasingShapeIds, t.hoveredId = t.hoveredShapeId, delete t.hoveredShapeId, t.editingId = t.editingShapeId, delete t.editingShapeId, t.croppingId = t.croppingShapeId, delete t.croppingShapeId, t.focusLayerId = t.focusedGroupId, delete t.focusedGroupId;
      }
    }
  ]
}), Uc = sd(
  "instance_page_state",
  {
    validator: G5e,
    scope: "session",
    ephemeralKeys: {
      pageId: !1,
      selectedShapeIds: !1,
      editingShapeId: !1,
      croppingShapeId: !1,
      meta: !1,
      hintingShapeIds: !0,
      erasingShapeIds: !0,
      hoveredShapeId: !0,
      focusedGroupId: !0
    }
  }
).withDefaultProperties(
  () => ({
    editingShapeId: null,
    croppingShapeId: null,
    selectedShapeIds: [],
    hoveredShapeId: null,
    erasingShapeIds: [],
    hintingShapeIds: [],
    focusedGroupId: null,
    meta: {}
  })
), q5e = od(
  "pointer",
  Gt({
    typeName: Do("pointer"),
    id: ba("pointer"),
    x: dt,
    y: dt,
    lastActivityTimestamp: dt,
    meta: ro
  })
), X5e = Gi("com.tldraw.pointer", {
  AddMeta: 1
}), Z5e = Aa({
  sequenceId: "com.tldraw.pointer",
  recordType: "pointer",
  sequence: [
    {
      id: X5e.AddMeta,
      up: (t) => {
        t.meta = {};
      }
    }
  ]
}), i3 = sd("pointer", {
  validator: q5e,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    lastActivityTimestamp: 0,
    meta: {}
  })
), OE = i3.createId("pointer"), Q5e = od(
  "instance_presence",
  Gt({
    typeName: Do("instance_presence"),
    id: ba("instance_presence"),
    userId: Et,
    userName: Et,
    lastActivityTimestamp: dt.nullable(),
    followingUserId: Et.nullable(),
    cursor: Gt({
      x: dt,
      y: dt,
      type: Pte,
      rotation: dt
    }).nullable(),
    color: Et,
    camera: Gt({
      x: dt,
      y: dt,
      z: dt
    }).nullable(),
    screenBounds: vx.nullable(),
    selectedShapeIds: Ms(ba("shape")),
    currentPageId: ba("page"),
    brush: vx.nullable(),
    scribbles: Ms(Ite),
    chatMessage: Et,
    meta: ro
  })
), Ng = Gi("com.tldraw.instance_presence", {
  AddScribbleDelay: 1,
  RemoveInstanceId: 2,
  AddChatMessage: 3,
  AddMeta: 4,
  RenameSelectedShapeIds: 5,
  NullableCameraCursor: 6
}), J5e = Aa({
  sequenceId: "com.tldraw.instance_presence",
  recordType: "instance_presence",
  sequence: [
    {
      id: Ng.AddScribbleDelay,
      up: (t) => {
        t.scribble !== null && (t.scribble.delay = 0);
      }
    },
    {
      id: Ng.RemoveInstanceId,
      up: (t) => {
        delete t.instanceId;
      }
    },
    {
      id: Ng.AddChatMessage,
      up: (t) => {
        t.chatMessage = "";
      }
    },
    {
      id: Ng.AddMeta,
      up: (t) => {
        t.meta = {};
      }
    },
    {
      id: Ng.RenameSelectedShapeIds,
      up: (t) => {
      }
    },
    {
      id: Ng.NullableCameraCursor,
      up: (t) => {
      },
      down: (t) => {
        t.camera === null && (t.camera = { x: 0, y: 0, z: 1 }), t.lastActivityTimestamp === null && (t.lastActivityTimestamp = 0), t.cursor === null && (t.cursor = { type: "default", x: 0, y: 0, rotation: 0 }), t.screenBounds === null && (t.screenBounds = { x: 0, y: 0, w: 1, h: 1 });
      }
    }
  ]
}), e4e = sd(
  "instance_presence",
  {
    validator: Q5e,
    scope: "presence"
  }
).withDefaultProperties(() => ({
  lastActivityTimestamp: null,
  followingUserId: null,
  color: "#FF0000",
  camera: null,
  cursor: null,
  screenBounds: null,
  selectedShapeIds: [],
  brush: null,
  scribbles: [],
  chatMessage: "",
  meta: {}
})), t4e = od(
  "document",
  Gt({
    typeName: Do("document"),
    id: Do("document:document"),
    gridSize: dt,
    name: Et,
    meta: ro
  })
), z8 = Gi("com.tldraw.document", {
  AddName: 1,
  AddMeta: 2
}), n4e = Aa({
  sequenceId: "com.tldraw.document",
  recordType: "document",
  sequence: [
    {
      id: z8.AddName,
      up: (t) => {
        t.name = "";
      },
      down: (t) => {
        delete t.name;
      }
    },
    {
      id: z8.AddMeta,
      up: (t) => {
        t.meta = {};
      }
    }
  ]
}), a3 = sd("document", {
  validator: t4e,
  scope: "document"
}).withDefaultProperties(
  () => ({
    gridSize: 10,
    name: "",
    meta: {}
  })
), rj = a3.createId("document");
function r4e(t, e) {
  return t.index < e.index ? -1 : t.index > e.index ? 1 : 0;
}
function U8(t) {
  t.typeName === "asset" && ("src" in t && (t.src = "<redacted>"), "src" in t.props && (t.props.src = "<redacted>"));
}
function s4e({
  error: t,
  phase: e,
  record: n,
  recordBefore: r
}) {
  throw dF(t, {
    tags: {
      origin: "store.validateRecord",
      storePhase: e,
      isExistingValidationIssue: (
        // if we're initializing the store for the first time, we should
        // allow invalid records so people can load old buggy data:
        e === "initialize"
      )
    },
    extras: {
      recordBefore: r ? U8(mr(r)) : void 0,
      recordAfter: U8(mr(n))
    }
  }), t;
}
function o4e() {
  return [
    ci.create({
      id: "page:page",
      name: "Page 1",
      index: "a1",
      meta: {}
    })
  ];
}
function i4e(t) {
  const e = t.query.ids("page"), n = t.query.records("instance_page_state"), r = () => {
    if (!t.has(rj))
      return t.put([a3.create({ id: rj, name: t.props.defaultName })]), r();
    if (!t.has(OE))
      return t.put([i3.create({ id: OE })]), r();
    const s = e.get();
    if (s.size === 0)
      return t.put(o4e()), r();
    const o = () => [...s].map((d) => t.get(d)).sort(r4e)[0].id, i = t.get(ti);
    if (i) {
      if (!s.has(i.currentPageId))
        return t.put([{ ...i, currentPageId: o() }]), r();
    } else return t.put([
      t.schema.types.instance.create({
        id: ti,
        currentPageId: o(),
        exportBackground: !0
      })
    ]), r();
    const a = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
    for (const d of s) {
      const u = Uc.createId(d);
      t.get(u) || a.add(u);
      const p = Rl.createId(d);
      t.has(p) || c.add(p);
    }
    a.size > 0 && t.put(
      [...a].map(
        (d) => Uc.create({
          id: d,
          pageId: Uc.parseId(d)
        })
      )
    ), c.size > 0 && t.put([...c].map((d) => Rl.create({ id: d })));
    const l = n.get();
    for (const d of l) {
      if (!s.has(d.pageId)) {
        t.remove([d.id]);
        continue;
      }
      if (d.croppingShapeId && !t.has(d.croppingShapeId))
        return t.put([{ ...d, croppingShapeId: null }]), r();
      if (d.focusedGroupId && !t.has(d.focusedGroupId))
        return t.put([{ ...d, focusedGroupId: null }]), r();
      if (d.hoveredShapeId && !t.has(d.hoveredShapeId))
        return t.put([{ ...d, hoveredShapeId: null }]), r();
      const u = d.selectedShapeIds.filter((g) => t.has(g));
      if (u.length !== d.selectedShapeIds.length)
        return t.put([{ ...d, selectedShapeIds: u }]), r();
      const f = d.hintingShapeIds.filter((g) => t.has(g));
      if (f.length !== d.hintingShapeIds.length)
        return t.put([{ ...d, hintingShapeIds: f }]), r();
      const p = d.erasingShapeIds.filter((g) => t.has(g));
      if (p.length !== d.erasingShapeIds.length)
        return t.put([{ ...d, erasingShapeIds: p }]), r();
    }
  };
  return r;
}
const a4e = s3(
  "bookmark",
  Gt({
    title: Et,
    description: Et,
    image: Et,
    favicon: Et,
    src: Pp.nullable()
  })
), H8 = Gi("com.tldraw.asset.bookmark", {
  MakeUrlsValid: 1,
  AddFavicon: 2
}), c4e = Aa({
  sequenceId: "com.tldraw.asset.bookmark",
  recordType: "asset",
  filter: (t) => t.type === "bookmark",
  sequence: [
    {
      id: H8.MakeUrlsValid,
      up: (t) => {
        Pp.isValid(t.props.src) || (t.props.src = "");
      },
      down: (t) => {
      }
    },
    {
      id: H8.AddFavicon,
      up: (t) => {
        Pp.isValid(t.props.favicon) || (t.props.favicon = "");
      },
      down: (t) => {
        delete t.props.favicon;
      }
    }
  ]
}), l4e = s3(
  "image",
  Gt({
    w: dt,
    h: dt,
    name: Et,
    isAnimated: Bt,
    mimeType: Et.nullable(),
    src: Pp.nullable(),
    fileSize: Ur.optional()
  })
), Qv = Gi("com.tldraw.asset.image", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
}), d4e = Aa({
  sequenceId: "com.tldraw.asset.image",
  recordType: "asset",
  filter: (t) => t.type === "image",
  sequence: [
    {
      id: Qv.AddIsAnimated,
      up: (t) => {
        t.props.isAnimated = !1;
      },
      down: (t) => {
        delete t.props.isAnimated;
      }
    },
    {
      id: Qv.RenameWidthHeight,
      up: (t) => {
        t.props.w = t.props.width, t.props.h = t.props.height, delete t.props.width, delete t.props.height;
      },
      down: (t) => {
        t.props.width = t.props.w, t.props.height = t.props.h, delete t.props.w, delete t.props.h;
      }
    },
    {
      id: Qv.MakeUrlsValid,
      up: (t) => {
        Pp.isValid(t.props.src) || (t.props.src = "");
      },
      down: (t) => {
      }
    },
    {
      id: Qv.AddFileSize,
      up: (t) => {
        t.props.fileSize = -1;
      },
      down: (t) => {
        delete t.props.fileSize;
      }
    },
    {
      id: Qv.MakeFileSizeOptional,
      up: (t) => {
        t.props.fileSize === -1 && (t.props.fileSize = void 0);
      },
      down: (t) => {
        t.props.fileSize === void 0 && (t.props.fileSize = -1);
      }
    }
  ]
}), u4e = s3(
  "video",
  Gt({
    w: dt,
    h: dt,
    name: Et,
    isAnimated: Bt,
    mimeType: Et.nullable(),
    src: Pp.nullable(),
    fileSize: dt.optional()
  })
), Jv = Gi("com.tldraw.asset.video", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
}), f4e = Aa({
  sequenceId: "com.tldraw.asset.video",
  recordType: "asset",
  filter: (t) => t.type === "video",
  sequence: [
    {
      id: Jv.AddIsAnimated,
      up: (t) => {
        t.props.isAnimated = !1;
      },
      down: (t) => {
        delete t.props.isAnimated;
      }
    },
    {
      id: Jv.RenameWidthHeight,
      up: (t) => {
        t.props.w = t.props.width, t.props.h = t.props.height, delete t.props.width, delete t.props.height;
      },
      down: (t) => {
        t.props.width = t.props.w, t.props.height = t.props.h, delete t.props.w, delete t.props.h;
      }
    },
    {
      id: Jv.MakeUrlsValid,
      up: (t) => {
        Pp.isValid(t.props.src) || (t.props.src = "");
      },
      down: (t) => {
      }
    },
    {
      id: Jv.AddFileSize,
      up: (t) => {
        t.props.fileSize = -1;
      },
      down: (t) => {
        delete t.props.fileSize;
      }
    },
    {
      id: Jv.MakeFileSizeOptional,
      up: (t) => {
        t.props.fileSize === -1 && (t.props.fileSize = void 0);
      },
      down: (t) => {
        t.props.fileSize === void 0 && (t.props.fileSize = -1);
      }
    }
  ]
}), h4e = od(
  "asset",
  t3("type", {
    image: l4e,
    video: u4e,
    bookmark: a4e
  })
), p4e = Gi("com.tldraw.asset", {
  AddMeta: 1
}), g4e = Aa({
  sequenceId: "com.tldraw.asset",
  recordType: "asset",
  sequence: [
    {
      id: p4e.AddMeta,
      up: (t) => {
        t.meta = {};
      }
    }
  ]
}), th = sd("asset", {
  validator: h4e,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
})), Ate = {
  w: Ur,
  h: Ur,
  assetId: NI.nullable(),
  url: _a
}, V8 = hc("bookmark", {
  NullAssetId: 1,
  MakeUrlsValid: 2
}), Mte = {
  sequence: [
    {
      id: V8.NullAssetId,
      up: (t) => {
        t.assetId === void 0 && (t.assetId = null);
      },
      down: "retired"
    },
    {
      id: V8.MakeUrlsValid,
      up: (t) => {
        _a.isValid(t.url) || (t.url = "");
      },
      down: (t) => {
      }
    }
  ]
}, Ote = Gt({
  type: av("free", "straight"),
  points: Ms(Ip)
}), Dte = {
  color: di,
  fill: Ap,
  dash: kp,
  size: Xl,
  segments: Ms(Ote),
  isComplete: Bt,
  isClosed: Bt,
  isPen: Bt,
  scale: Ur
}, W8 = hc("draw", {
  AddInPen: 1,
  AddScale: 2
}), Nte = {
  sequence: [
    {
      id: W8.AddInPen,
      up: (t) => {
        const { points: e } = t.segments[0];
        if (e.length === 0) {
          t.isPen = !1;
          return;
        }
        let n = !(e[0].z === 0 || e[0].z === 0.5);
        e[1] && (n = n && !(e[1].z === 0 || e[1].z === 0.5)), t.isPen = n;
      },
      down: "retired"
    },
    {
      id: W8.AddScale,
      up: (t) => {
        t.scale = 1;
      },
      down: (t) => {
        delete t.scale;
      }
    }
  ]
}, m4e = /(^\/r\/[^/]+\/?$)/, y4e = [
  {
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(m4e))
        return t;
    }
  },
  {
    hostnames: ["figma.com"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/?$/)) {
        const n = e.searchParams.get("url");
        if (n)
          return n;
      }
    }
  },
  {
    hostnames: ["google.*"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (!e) return;
      if (e.pathname.match(/^\/maps\/embed\/v1\/view\/?$/) && e.searchParams.has("center") && e.searchParams.get("zoom")) {
        const r = e.searchParams.get("zoom"), [s, o] = e.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${s},${o},${r}z`;
      }
    }
  },
  {
    hostnames: ["val.town"],
    fromEmbedUrl: (t) => {
      const e = bt(t), n = e && e.pathname.match(/\/embed\/(.+)\/?/);
      if (n)
        return `https://www.val.town/v/${n[1]}`;
    }
  },
  {
    hostnames: ["codesandbox.io"],
    fromEmbedUrl: (t) => {
      const e = bt(t), n = e && e.pathname.match(/\/embed\/([^/]+)\/?/);
      if (n)
        return `https://codesandbox.io/s/${n[1]}`;
    }
  },
  {
    hostnames: ["codepen.io"],
    fromEmbedUrl: (t) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, s, o] = n;
        return `https://codepen.io/${s}/pen/${o}`;
      }
    }
  },
  {
    hostnames: ["scratch.mit.edu"],
    fromEmbedUrl: (t) => {
      const e = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, s] = n;
        return `https://scratch.mit.edu/projects/${s}`;
      }
    }
  },
  {
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (!e) return;
      if (e.hostname.replace(/^www./, "") === "youtube.com") {
        const r = e.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (r)
          return `https://www.youtube.com/watch?v=${r[1]}`;
      }
    }
  },
  {
    hostnames: ["calendar.google.*"],
    fromEmbedUrl: (t) => {
      const e = bt(t), n = e == null ? void 0 : e.searchParams.get("src");
      if (e != null && e.pathname.match(/\/calendar\/embed/) && n) {
        e.pathname = "/calendar/u/0";
        const r = Array.from(e.searchParams.keys());
        for (const s of r)
          e.searchParams.delete(s);
        return e.searchParams.set("cid", n), e.href;
      }
    }
  },
  {
    hostnames: ["docs.google.*"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e != null && e.pathname.match(/^\/presentation/) && (e != null && e.pathname.match(/\/embed\/?$/))) {
        e.pathname = e.pathname.replace(/\/embed$/, "/pub");
        const n = Array.from(e.searchParams.keys());
        for (const r of n)
          e.searchParams.delete(r);
        return e.href;
      }
    }
  },
  {
    hostnames: ["gist.github.com"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/\/([^/]+)\/([^/]+)/))
        return t.split("/").pop() ? t : void 0;
    }
  },
  {
    hostnames: ["replit.com"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/) && e.searchParams.has("embed"))
        return e.searchParams.delete("embed"), e.href;
    }
  },
  {
    hostnames: ["felt.com"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/map\//))
        return e.pathname = e.pathname.replace(/^\/embed/, ""), e.href;
    }
  },
  {
    hostnames: ["open.spotify.com"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/(artist|album)\//))
        return e.origin + e.pathname.replace(/^\/embed/, "");
    }
  },
  {
    hostnames: ["vimeo.com", "player.vimeo.com"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.hostname === "player.vimeo.com") {
        const n = e.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (n)
          return "https://vimeo.com/" + n[1];
      }
    }
  },
  {
    hostnames: ["excalidraw.com"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.hash.match(/#room=/))
        return t;
    }
  },
  {
    hostnames: ["observablehq.com"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "")}#cell-*`;
      if (e && e.pathname.match(/^\/embed\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "/d")}#cell-*`;
    }
  },
  {
    hostnames: ["desmos.com"],
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.hostname === "www.desmos.com" && e.pathname.match(/^\/calculator\/([^/]+)\/?$/) && e.search === "?embed" && e.hash === "")
        return t.replace("?embed", "");
    }
  }
], jte = {
  w: Ur,
  h: Ur,
  url: Et
}, w1 = hc("embed", {
  GenOriginalUrlInEmbed: 1,
  RemoveDoesResize: 2,
  RemoveTmpOldUrl: 3,
  RemovePermissionOverrides: 4
}), Rte = {
  sequence: [
    {
      id: w1.GenOriginalUrlInEmbed,
      // add tmpOldUrl property
      up: (t) => {
        try {
          const e = t.url, n = new URL(e).host.replace("www.", "");
          let r;
          for (const s of y4e)
            if (s.hostnames.includes(n))
              try {
                r = s.fromEmbedUrl(e);
              } catch (o) {
                console.warn(o);
              }
          t.tmpOldUrl = t.url, t.url = r ?? "";
        } catch {
          t.url = "", t.tmpOldUrl = t.url;
        }
      },
      down: "retired"
    },
    {
      id: w1.RemoveDoesResize,
      up: (t) => {
        delete t.doesResize;
      },
      down: "retired"
    },
    {
      id: w1.RemoveTmpOldUrl,
      up: (t) => {
        delete t.tmpOldUrl;
      },
      down: "retired"
    },
    {
      id: w1.RemovePermissionOverrides,
      up: (t) => {
        delete t.overridePermissions;
      },
      down: "retired"
    }
  ]
}, $te = {
  w: Ur,
  h: Ur,
  name: Et,
  // because shape colors are an option, we don't want them to be picked up by the editor as a
  // style prop by default, so instead of a proper style we just supply an equivalent validator.
  // Check `FrameShapeUtil.configure` for how we replace this with the original
  // `DefaultColorStyle` style when the option is turned on.
  color: av(...di.values)
}, v4e = hc("frame", {
  AddColorProp: 1
}), Lte = {
  sequence: [
    {
      id: v4e.AddColorProp,
      up: (t) => {
        t.color = "black";
      },
      down: (t) => {
        delete t.color;
      }
    }
  ]
}, c3 = Gt({ type: Et, content: Ms(p5e) });
function dc(t) {
  return {
    type: "doc",
    content: t.split(`
`).map((r) => r ? {
      type: "paragraph",
      content: [{ type: "text", text: r }]
    } : {
      type: "paragraph"
    })
  };
}
const DE = zs.defineEnum("tldraw:horizontalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end", "start-legacy", "end-legacy", "middle-legacy"]
}), NE = zs.defineEnum("tldraw:verticalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end"]
}), Hc = zs.defineEnum("tldraw:geo", {
  defaultValue: "rectangle",
  values: [
    "cloud",
    "rectangle",
    "ellipse",
    "triangle",
    "diamond",
    "pentagon",
    "hexagon",
    "octagon",
    "star",
    "rhombus",
    "rhombus-2",
    "oval",
    "trapezoid",
    "arrow-right",
    "arrow-left",
    "arrow-up",
    "arrow-down",
    "x-box",
    "check-box",
    "heart"
  ]
}), Fte = {
  geo: Hc,
  dash: kp,
  url: _a,
  w: Ur,
  h: Ur,
  growY: PE,
  scale: Ur,
  // Text properties
  labelColor: o3,
  color: di,
  fill: Ap,
  size: Xl,
  font: ou,
  align: DE,
  verticalAlign: NE,
  richText: c3
}, yl = hc("geo", {
  AddUrlProp: 1,
  AddLabelColor: 2,
  RemoveJustify: 3,
  AddCheckBox: 4,
  AddVerticalAlign: 5,
  MigrateLegacyAlign: 6,
  AddCloud: 7,
  MakeUrlsValid: 8,
  AddScale: 9,
  AddRichText: 10
}), Bte = {
  sequence: [
    {
      id: yl.AddUrlProp,
      up: (t) => {
        t.url = "";
      },
      down: "retired"
    },
    {
      id: yl.AddLabelColor,
      up: (t) => {
        t.labelColor = "black";
      },
      down: "retired"
    },
    {
      id: yl.RemoveJustify,
      up: (t) => {
        t.align === "justify" && (t.align = "start");
      },
      down: "retired"
    },
    {
      id: yl.AddCheckBox,
      up: (t) => {
      },
      down: "retired"
    },
    {
      id: yl.AddVerticalAlign,
      up: (t) => {
        t.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: yl.MigrateLegacyAlign,
      up: (t) => {
        let e;
        switch (t.align) {
          case "start":
            e = "start-legacy";
            break;
          case "end":
            e = "end-legacy";
            break;
          default:
            e = "middle-legacy";
            break;
        }
        t.align = e;
      },
      down: "retired"
    },
    {
      id: yl.AddCloud,
      up: (t) => {
      },
      down: "retired"
    },
    {
      id: yl.MakeUrlsValid,
      up: (t) => {
        _a.isValid(t.url) || (t.url = "");
      },
      down: (t) => {
      }
    },
    {
      id: yl.AddScale,
      up: (t) => {
        t.scale = 1;
      },
      down: (t) => {
        delete t.scale;
      }
    },
    {
      id: yl.AddRichText,
      up: (t) => {
        t.richText = dc(t.text), delete t.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
}, zte = {}, Ute = { sequence: [] }, Hte = {
  color: di,
  size: Xl,
  segments: Ms(Ote),
  isComplete: Bt,
  isPen: Bt,
  scale: Ur
}, b4e = hc("highlight", {
  AddScale: 1
}), Vte = {
  sequence: [
    {
      id: b4e.AddScale,
      up: (t) => {
        t.scale = 1;
      },
      down: (t) => {
        delete t.scale;
      }
    }
  ]
}, x4e = Gt({
  topLeft: Ip,
  bottomRight: Ip,
  isCircle: Bt.optional()
}), Wte = {
  w: Ur,
  h: Ur,
  playing: Bt,
  url: _a,
  assetId: NI.nullable(),
  crop: x4e.nullable(),
  flipX: Bt,
  flipY: Bt,
  altText: Et
}, eb = hc("image", {
  AddUrlProp: 1,
  AddCropProp: 2,
  MakeUrlsValid: 3,
  AddFlipProps: 4,
  AddAltText: 5
}), Kte = {
  sequence: [
    {
      id: eb.AddUrlProp,
      up: (t) => {
        t.url = "";
      },
      down: "retired"
    },
    {
      id: eb.AddCropProp,
      up: (t) => {
        t.crop = null;
      },
      down: (t) => {
        delete t.crop;
      }
    },
    {
      id: eb.MakeUrlsValid,
      up: (t) => {
        _a.isValid(t.url) || (t.url = "");
      },
      down: (t) => {
      }
    },
    {
      id: eb.AddFlipProps,
      up: (t) => {
        t.flipX = !1, t.flipY = !1;
      },
      down: (t) => {
        delete t.flipX, delete t.flipY;
      }
    },
    {
      id: eb.AddAltText,
      up: (t) => {
        t.altText = "";
      },
      down: (t) => {
        delete t.altText;
      }
    }
  ]
}, jE = zs.defineEnum("tldraw:spline", {
  defaultValue: "line",
  values: ["cubic", "line"]
}), w4e = Gt({
  id: Et,
  index: r3,
  x: dt,
  y: dt
}), Gte = {
  color: di,
  dash: kp,
  size: Xl,
  spline: jE,
  points: IE(Et, w4e),
  scale: Ur
}, tb = hc("line", {
  AddSnapHandles: 1,
  RemoveExtraHandleProps: 2,
  HandlesToPoints: 3,
  PointIndexIds: 4,
  AddScale: 5
}), Yte = {
  sequence: [
    {
      id: tb.AddSnapHandles,
      up: (t) => {
        for (const e of Object.values(t.handles))
          e.canSnap = !0;
      },
      down: "retired"
    },
    {
      id: tb.RemoveExtraHandleProps,
      up: (t) => {
        t.handles = AJ(
          Object.values(t.handles).map((e) => [
            e.index,
            {
              x: e.x,
              y: e.y
            }
          ])
        );
      },
      down: (t) => {
        const e = Object.entries(t.handles).map(([n, r]) => ({ index: n, ...r })).sort(Js);
        t.handles = Object.fromEntries(
          e.map((n, r) => {
            const s = r === 0 ? "start" : r === e.length - 1 ? "end" : `handle:${n.index}`;
            return [
              s,
              {
                id: s,
                type: "vertex",
                canBind: !1,
                canSnap: !0,
                index: n.index,
                x: n.x,
                y: n.y
              }
            ];
          })
        );
      }
    },
    {
      id: tb.HandlesToPoints,
      up: (t) => {
        const e = Object.entries(t.handles).map(([n, { x: r, y: s }]) => ({ x: r, y: s, index: n })).sort(Js);
        t.points = e.map(({ x: n, y: r }) => ({ x: n, y: r })), delete t.handles;
      },
      down: (t) => {
        const e = ow(t.points.length);
        t.handles = Object.fromEntries(
          t.points.map((n, r) => [
            e[r],
            {
              x: n.x,
              y: n.y
            }
          ])
        ), delete t.points;
      }
    },
    {
      id: tb.PointIndexIds,
      up: (t) => {
        const e = ow(t.points.length);
        t.points = Object.fromEntries(
          t.points.map((n, r) => {
            const s = e[r];
            return [
              s,
              {
                id: s,
                index: s,
                x: n.x,
                y: n.y
              }
            ];
          })
        );
      },
      down: (t) => {
        const e = Object.values(t.points).sort(Js);
        t.points = e.map(({ x: n, y: r }) => ({ x: n, y: r }));
      }
    },
    {
      id: tb.AddScale,
      up: (t) => {
        t.scale = 1;
      },
      down: (t) => {
        delete t.scale;
      }
    }
  ]
}, qte = {
  color: di,
  labelColor: o3,
  size: Xl,
  font: ou,
  fontSizeAdjustment: PE,
  align: DE,
  verticalAlign: NE,
  growY: PE,
  url: _a,
  richText: c3,
  scale: Ur
}, bd = hc("note", {
  AddUrlProp: 1,
  RemoveJustify: 2,
  MigrateLegacyAlign: 3,
  AddVerticalAlign: 4,
  MakeUrlsValid: 5,
  AddFontSizeAdjustment: 6,
  AddScale: 7,
  AddLabelColor: 8,
  AddRichText: 9
}), Xte = {
  sequence: [
    {
      id: bd.AddUrlProp,
      up: (t) => {
        t.url = "";
      },
      down: "retired"
    },
    {
      id: bd.RemoveJustify,
      up: (t) => {
        t.align === "justify" && (t.align = "start");
      },
      down: "retired"
    },
    {
      id: bd.MigrateLegacyAlign,
      up: (t) => {
        switch (t.align) {
          case "start":
            t.align = "start-legacy";
            return;
          case "end":
            t.align = "end-legacy";
            return;
          default:
            t.align = "middle-legacy";
            return;
        }
      },
      down: "retired"
    },
    {
      id: bd.AddVerticalAlign,
      up: (t) => {
        t.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: bd.MakeUrlsValid,
      up: (t) => {
        _a.isValid(t.url) || (t.url = "");
      },
      down: (t) => {
      }
    },
    {
      id: bd.AddFontSizeAdjustment,
      up: (t) => {
        t.fontSizeAdjustment = 0;
      },
      down: (t) => {
        delete t.fontSizeAdjustment;
      }
    },
    {
      id: bd.AddScale,
      up: (t) => {
        t.scale = 1;
      },
      down: (t) => {
        delete t.scale;
      }
    },
    {
      id: bd.AddLabelColor,
      up: (t) => {
        t.labelColor = "black";
      },
      down: (t) => {
        delete t.labelColor;
      }
    },
    {
      id: bd.AddRichText,
      up: (t) => {
        t.richText = dc(t.text), delete t.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
}, sj = zs.defineEnum("tldraw:textAlign", {
  defaultValue: "start",
  values: ["start", "middle", "end"]
}), Zte = {
  color: di,
  size: Xl,
  font: ou,
  textAlign: sj,
  w: Ur,
  richText: c3,
  scale: Ur,
  autoSize: Bt
}, ZM = hc("text", {
  RemoveJustify: 1,
  AddTextAlign: 2,
  AddRichText: 3
}), Qte = {
  sequence: [
    {
      id: ZM.RemoveJustify,
      up: (t) => {
        t.align === "justify" && (t.align = "start");
      },
      down: "retired"
    },
    {
      id: ZM.AddTextAlign,
      up: (t) => {
        t.textAlign = t.align, delete t.align;
      },
      down: (t) => {
        t.align = t.textAlign, delete t.textAlign;
      }
    },
    {
      id: ZM.AddRichText,
      up: (t) => {
        t.richText = dc(t.text), delete t.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
}, Jte = {
  w: Ur,
  h: Ur,
  time: dt,
  playing: Bt,
  autoplay: Bt,
  url: _a,
  assetId: NI.nullable(),
  altText: Et
}, S1 = hc("video", {
  AddUrlProp: 1,
  MakeUrlsValid: 2,
  AddAltText: 3,
  AddAutoplay: 4
}), ene = {
  sequence: [
    {
      id: S1.AddUrlProp,
      up: (t) => {
        t.url = "";
      },
      down: "retired"
    },
    {
      id: S1.MakeUrlsValid,
      up: (t) => {
        _a.isValid(t.url) || (t.url = "");
      },
      down: (t) => {
      }
    },
    {
      id: S1.AddAltText,
      up: (t) => {
        t.altText = "";
      },
      down: (t) => {
        delete t.altText;
      }
    },
    {
      id: S1.AddAutoplay,
      up: (t) => {
        t.autoplay = !0;
      },
      down: (t) => {
        delete t.autoplay;
      }
    }
  ]
}, C1 = Gi("com.tldraw.store", {
  RemoveCodeAndIconShapeTypes: 1,
  AddInstancePresenceType: 2,
  RemoveTLUserAndPresenceAndAddPointer: 3,
  RemoveUserDocument: 4
}), S4e = Em({
  sequenceId: "com.tldraw.store",
  retroactive: !1,
  sequence: [
    {
      id: C1.RemoveCodeAndIconShapeTypes,
      scope: "store",
      up: (t) => {
        for (const [e, n] of ai(t))
          n.typeName === "shape" && (n.type === "icon" || n.type === "code") && delete t[e];
      }
    },
    {
      id: C1.AddInstancePresenceType,
      scope: "store",
      up(t) {
      }
    },
    {
      // remove user and presence records and add pointer records
      id: C1.RemoveTLUserAndPresenceAndAddPointer,
      scope: "store",
      up: (t) => {
        for (const [e, n] of ai(t))
          n.typeName.match(/^(user|user_presence)$/) && delete t[e];
      }
    },
    {
      // remove user document records
      id: C1.RemoveUserDocument,
      scope: "store",
      up: (t) => {
        for (const [e, n] of ai(t))
          n.typeName.match("user_document") && delete t[e];
      }
    }
  ]
}), C4e = {
  arrow: { migrations: _te, props: Cte },
  bookmark: { migrations: Mte, props: Ate },
  draw: { migrations: Nte, props: Dte },
  embed: { migrations: Rte, props: jte },
  frame: { migrations: Lte, props: $te },
  geo: { migrations: Bte, props: Fte },
  group: { migrations: Ute, props: zte },
  highlight: { migrations: Vte, props: Hte },
  image: { migrations: Kte, props: Wte },
  line: { migrations: Yte, props: Gte },
  note: { migrations: Xte, props: qte },
  text: { migrations: Qte, props: Zte },
  video: { migrations: ene, props: Jte }
}, _4e = {
  arrow: { migrations: Tte, props: Ete }
};
function E4e({
  shapes: t = C4e,
  bindings: e = _4e,
  migrations: n
} = {}) {
  const r = /* @__PURE__ */ new Map();
  for (const a of Er(t))
    for (const c of vte(a.props ?? {}).keys()) {
      if (r.has(c.id) && r.get(c.id) !== c)
        throw new Error(`Multiple StyleProp instances with the same id: ${c.id}`);
      r.set(c.id, c);
    }
  const s = k5e(t), o = T5e(e), i = W5e(r);
  return JF.create(
    {
      asset: th,
      binding: o,
      camera: Rl,
      document: a3,
      instance: i,
      instance_page_state: Uc,
      page: ci,
      instance_presence: e4e,
      pointer: i3,
      shape: s
    },
    {
      migrations: [
        S4e,
        g4e,
        j5e,
        n4e,
        K5e,
        Y5e,
        H5e,
        J5e,
        Z5e,
        I5e,
        c4e,
        d4e,
        f4e,
        ...B8("shape", t),
        ...B8("binding", e),
        ...n ?? []
      ],
      onValidationFailure: s4e,
      createIntegrityChecker: i4e
    }
  );
}
const lw = [
  { locale: "id", label: "Bahasa Indonesia" },
  { locale: "ms", label: "Bahasa Melayu" },
  { locale: "ca", label: "Catal" },
  { locale: "cs", label: "etina" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Espaol" },
  { locale: "tl", label: "Filipino" },
  { locale: "fr", label: "Franais" },
  { locale: "gl", label: "Galego" },
  { locale: "hr", label: "Hrvatski" },
  { locale: "it", label: "Italiano" },
  { locale: "hu", label: "Magyar" },
  { locale: "nl", label: "Nederlands" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Portugus - Brasil" },
  { locale: "pt-pt", label: "Portugus - Europeu" },
  { locale: "ro", label: "Romn" },
  { locale: "sl", label: "Slovenina" },
  { locale: "so", label: "Somali" },
  { locale: "fi", label: "Suomi" },
  { locale: "sv", label: "Svenska" },
  { locale: "vi", label: "Ting Vit" },
  { locale: "tr", label: "Trke" },
  { locale: "el", label: "" },
  { locale: "ru", label: "" },
  { locale: "uk", label: "" },
  { locale: "he", label: "" },
  { locale: "ur", label: "" },
  { locale: "ar", label: "" },
  { locale: "fa", label: "" },
  { locale: "ne", label: "" },
  { locale: "mr", label: "" },
  { locale: "hi-in", label: "" },
  { locale: "bn", label: "" },
  { locale: "pa", label: "" },
  { locale: "gu-in", label: "" },
  { locale: "ta", label: "" },
  { locale: "te", label: "" },
  { locale: "kn", label: "" },
  { locale: "ml", label: "" },
  { locale: "th", label: "" },
  { locale: "km-kh", label: "" },
  { locale: "ko-kr", label: "" },
  { locale: "ja", label: "" },
  { locale: "zh-cn", label: "" },
  { locale: "zh-tw", label: " ()" }
];
function T4e() {
  const t = typeof window < "u" ? window.navigator.languages ?? ["en"] : ["en"];
  return P4e(t);
}
function P4e(t) {
  for (const e of t) {
    const n = I4e(e);
    if (n)
      return n;
  }
  return "en";
}
const K8 = {
  zh: "zh-cn",
  pt: "pt-br",
  ko: "ko-kr",
  hi: "hi-in"
};
function I4e(t) {
  const e = lw.find((s) => s.locale === t.toLowerCase());
  if (e)
    return e.locale;
  const [n, r] = t.split(/[-_]/).map((s) => s.toLowerCase());
  if (r) {
    const s = lw.find((o) => o.locale === n);
    if (s)
      return s.locale;
  }
  return n in K8 ? K8[n] : null;
}
Xf(
  "@tldraw/tlschema",
  "3.15.5",
  "esm"
);
function k4e() {
  return /* @__PURE__ */ h.jsx("div", { className: "tl-background" });
}
function Y0(t, e, n, r, s, o) {
  un(() => {
    const i = t.current;
    if (!i || e === void 0) return;
    let a = `translate(${e}px, ${n}px)`;
    r !== void 0 && (a += ` scale(${r})`), s !== void 0 && (a += ` rotate(${s}rad)`), o && (a += ` translate(${o.x}px, ${o.y}px)`), i.style.transform = a;
  });
}
const Mo = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => t * (2 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => --t * t * t + 1,
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - --t * t * t * t,
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 + --t * t * t * t * t,
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  easeInExpo: (t) => t <= 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t >= 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => t <= 0 ? 0 : t >= 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
};
class I {
  constructor(e = 0, n = 0, r = 1) {
    this.x = e, this.y = n, this.z = r;
  }
  // eslint-disable-next-line no-restricted-syntax
  get pressure() {
    return this.z;
  }
  set(e = this.x, n = this.y, r = this.z) {
    return this.x = e, this.y = n, this.z = r, this;
  }
  setTo({ x: e = 0, y: n = 0, z: r = 1 }) {
    return this.x = e, this.y = n, this.z = r, this;
  }
  rot(e) {
    if (e === 0) return this;
    const { x: n, y: r } = this, s = Math.sin(e), o = Math.cos(e);
    return this.x = n * o - r * s, this.y = n * s + r * o, this;
  }
  rotWith(e, n) {
    if (n === 0) return this;
    const r = this.x - e.x, s = this.y - e.y, o = Math.sin(n), i = Math.cos(n);
    return this.x = e.x + (r * i - s * o), this.y = e.y + (r * o + s * i), this;
  }
  clone() {
    const { x: e, y: n, z: r } = this;
    return new I(e, n, r);
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subXY(e, n) {
    return this.x -= e, this.y -= n, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addXY(e, n) {
    return this.x += e, this.y += n, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  clamp(e, n) {
    return this.x = Math.max(this.x, e), this.y = Math.max(this.y, e), n !== void 0 && (this.x = Math.min(this.x, n), this.y = Math.min(this.y, n)), this;
  }
  div(e) {
    return this.x /= e, this.y /= e, this;
  }
  divV(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  mul(e) {
    return this.x *= e, this.y *= e, this;
  }
  mulV(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(e, n) {
    const r = I.Tan(e, this);
    return this.add(r.mul(n));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(e) {
    return this.x = this.y * e.z - this.z * e.y, this.y = this.z * e.x - this.x * e.z, this;
  }
  dpr(e) {
    return I.Dpr(this, e);
  }
  cpr(e) {
    return I.Cpr(this, e);
  }
  len2() {
    return I.Len2(this);
  }
  len() {
    return I.Len(this);
  }
  pry(e) {
    return I.Pry(this, e);
  }
  per() {
    const { x: e, y: n } = this;
    return this.x = n, this.y = -e, this;
  }
  uni() {
    const e = this.len();
    return e === 0 ? this : (this.x /= e, this.y /= e, this);
  }
  tan(e) {
    return this.sub(e).uni();
  }
  dist(e) {
    return I.Dist(this, e);
  }
  distanceToLineSegment(e, n) {
    return I.DistanceToLineSegment(e, n, this);
  }
  slope(e) {
    return I.Slope(this, e);
  }
  snapToGrid(e) {
    return this.x = Math.round(this.x / e) * e, this.y = Math.round(this.y / e) * e, this;
  }
  angle(e) {
    return I.Angle(this, e);
  }
  toAngle() {
    return I.ToAngle(this);
  }
  lrp(e, n) {
    return this.x = this.x + (e.x - this.x) * n, this.y = this.y + (e.y - this.y) * n, this;
  }
  equals(e) {
    return I.Equals(this, e);
  }
  equalsXY(e, n) {
    return I.EqualsXY(this, e, n);
  }
  /** @deprecated use `uni` instead */
  norm() {
    return this.uni();
  }
  toFixed() {
    return this.x = Nc(this.x), this.y = Nc(this.y), this;
  }
  toString() {
    return I.ToString(I.ToFixed(this));
  }
  toJson() {
    return I.ToJson(this);
  }
  toArray() {
    return I.ToArray(this);
  }
  static Add(e, n) {
    return new I(e.x + n.x, e.y + n.y);
  }
  static AddXY(e, n, r) {
    return new I(e.x + n, e.y + r);
  }
  static Sub(e, n) {
    return new I(e.x - n.x, e.y - n.y);
  }
  static SubXY(e, n, r) {
    return new I(e.x - n, e.y - r);
  }
  static AddScalar(e, n) {
    return new I(e.x + n, e.y + n);
  }
  static SubScalar(e, n) {
    return new I(e.x - n, e.y - n);
  }
  static Div(e, n) {
    return new I(e.x / n, e.y / n);
  }
  static Mul(e, n) {
    return new I(e.x * n, e.y * n);
  }
  static DivV(e, n) {
    return new I(e.x / n.x, e.y / n.y);
  }
  static MulV(e, n) {
    return new I(e.x * n.x, e.y * n.y);
  }
  static Neg(e) {
    return new I(-e.x, -e.y);
  }
  /**
   * Get the perpendicular vector to A.
   */
  static Per(e) {
    return new I(e.y, -e.x);
  }
  static Abs(e) {
    return new I(Math.abs(e.x), Math.abs(e.y));
  }
  // Get the distance between two points.
  static Dist(e, n) {
    return ((e.y - n.y) ** 2 + (e.x - n.x) ** 2) ** 0.5;
  }
  // Get the Manhattan distance between two points.
  static ManhattanDist(e, n) {
    return Math.abs(e.x - n.x) + Math.abs(e.y - n.y);
  }
  // Get whether a distance between two points is less than a number. This is faster to calulate than using `Vec.Dist(a, b) < n`.
  static DistMin(e, n, r) {
    return (e.x - n.x) * (e.x - n.x) + (e.y - n.y) * (e.y - n.y) < r ** 2;
  }
  // Get the squared distance between two points. This is faster to calculate (no square root) so useful for "minimum distance" checks where the actual measurement does not matter.
  static Dist2(e, n) {
    return (e.x - n.x) * (e.x - n.x) + (e.y - n.y) * (e.y - n.y);
  }
  /**
   * Dot product of two vectors which is used to calculate the angle between them.
   */
  static Dpr(e, n) {
    return e.x * n.x + e.y * n.y;
  }
  static Cross(e, n) {
    return new I(
      e.y * n.z - e.z * n.y,
      e.z * n.x - e.x * n.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  /**
   * Cross product of two vectors which is used to calculate the area of a parallelogram.
   */
  static Cpr(e, n) {
    return e.x * n.y - n.x * e.y;
  }
  static Len2(e) {
    return e.x * e.x + e.y * e.y;
  }
  static Len(e) {
    return (e.x * e.x + e.y * e.y) ** 0.5;
  }
  /**
   * Get the projection of A onto B.
   */
  static Pry(e, n) {
    return I.Dpr(e, n) / I.Len(n);
  }
  /**
   * Get the unit vector of A.
   */
  static Uni(e) {
    const n = I.Len(e);
    return new I(n === 0 ? 0 : e.x / n, n === 0 ? 0 : e.y / n);
  }
  static Tan(e, n) {
    return I.Uni(I.Sub(e, n));
  }
  static Min(e, n) {
    return new I(Math.min(e.x, n.x), Math.min(e.y, n.y));
  }
  static Max(e, n) {
    return new I(Math.max(e.x, n.x), Math.max(e.y, n.y));
  }
  static From({ x: e, y: n, z: r = 1 }) {
    return new I(e, n, r);
  }
  static FromArray(e) {
    return new I(e[0], e[1]);
  }
  static Rot(e, n = 0) {
    const r = Math.sin(n), s = Math.cos(n);
    return new I(e.x * s - e.y * r, e.x * r + e.y * s);
  }
  static RotWith(e, n, r) {
    const s = e.x - n.x, o = e.y - n.y, i = Math.sin(r), a = Math.cos(r);
    return new I(n.x + (s * a - o * i), n.y + (s * i + o * a));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(e, n, r) {
    return I.Mul(n, I.Sub(r, e).pry(n)).add(e);
  }
  static NearestPointOnLineSegment(e, n, r, s = !0) {
    if (I.Equals(e, r) || I.Equals(n, r)) return I.From(r);
    const o = I.Tan(n, e), i = I.Add(e, I.Mul(o, I.Sub(r, e).pry(o)));
    if (s) {
      if (i.x < Math.min(e.x, n.x)) return I.Cast(e.x < n.x ? e : n);
      if (i.x > Math.max(e.x, n.x)) return I.Cast(e.x > n.x ? e : n);
      if (i.y < Math.min(e.y, n.y)) return I.Cast(e.y < n.y ? e : n);
      if (i.y > Math.max(e.y, n.y)) return I.Cast(e.y > n.y ? e : n);
    }
    return i;
  }
  static DistanceToLineThroughPoint(e, n, r) {
    return I.Dist(r, I.NearestPointOnLineThroughPoint(e, n, r));
  }
  static DistanceToLineSegment(e, n, r, s = !0) {
    return I.Dist(r, I.NearestPointOnLineSegment(e, n, r, s));
  }
  static Snap(e, n = 1) {
    return new I(Math.round(e.x / n) * n, Math.round(e.y / n) * n);
  }
  static Cast(e) {
    return e instanceof I ? e : I.From(e);
  }
  static Slope(e, n) {
    return e.x === n.y ? NaN : (e.y - n.y) / (e.x - n.x);
  }
  static IsNaN(e) {
    return isNaN(e.x) || isNaN(e.y);
  }
  /**
   * Get the angle from position A to position B.
   */
  static Angle(e, n) {
    return Math.atan2(n.y - e.y, n.x - e.x);
  }
  /**
   * Get the angle between vector A and vector B. This will return the smallest angle between the
   * two vectors, between - and . The sign indicates direction of angle.
   */
  static AngleBetween(e, n) {
    const r = e.x * n.x + e.y * n.y, s = Math.sqrt(
      (Math.pow(e.x, 2) + Math.pow(e.y, 2)) * (Math.pow(n.x, 2) + Math.pow(n.y, 2))
    );
    return (e.x * n.y - e.y * n.x < 0 ? -1 : 1) * Math.acos(wt(r / s, -1, 1));
  }
  /**
   * Linearly interpolate between two points.
   * @param A - The first point.
   * @param B - The second point.
   * @param t - The interpolation value between 0 and 1.
   * @returns The interpolated point.
   */
  static Lrp(e, n, r) {
    return I.Sub(n, e).mul(r).add(e);
  }
  static Med(e, n) {
    return new I((e.x + n.x) / 2, (e.y + n.y) / 2);
  }
  static Equals(e, n) {
    return Math.abs(e.x - n.x) < 1e-4 && Math.abs(e.y - n.y) < 1e-4;
  }
  static EqualsXY(e, n, r) {
    return e.x === n && e.y === r;
  }
  static Clockwise(e, n, r) {
    return (r.x - e.x) * (n.y - e.y) - (n.x - e.x) * (r.y - e.y) < 0;
  }
  static Rescale(e, n) {
    const r = I.Len(e);
    return new I(n * e.x / r, n * e.y / r);
  }
  static ScaleWithOrigin(e, n, r) {
    return I.Sub(e, r).mul(n).add(r);
  }
  static ToFixed(e) {
    return new I(Nc(e.x), Nc(e.y));
  }
  static ToInt(e) {
    return new I(
      parseInt(e.x.toFixed(0)),
      parseInt(e.y.toFixed(0)),
      parseInt((e.z ?? 0).toFixed(0))
    );
  }
  static ToCss(e) {
    return `${e.x},${e.y}`;
  }
  static Nudge(e, n, r) {
    return I.Add(e, I.Tan(n, e).mul(r));
  }
  static ToString(e) {
    return `${e.x}, ${e.y}`;
  }
  static ToAngle(e) {
    let n = Math.atan2(e.y, e.x);
    return n < 0 && (n += Math.PI * 2), n;
  }
  static FromAngle(e, n = 1) {
    return new I(Math.cos(e) * n, Math.sin(e) * n);
  }
  static ToArray(e) {
    return [e.x, e.y, e.z];
  }
  static ToJson(e) {
    const { x: n, y: r, z: s } = e;
    return { x: n, y: r, z: s };
  }
  static Average(e) {
    const n = e.length, r = new I(0, 0);
    if (n === 0)
      return r;
    for (let s = 0; s < n; s++)
      r.add(e[s]);
    return r.div(n);
  }
  static Clamp(e, n, r) {
    return r === void 0 ? new I(Math.min(Math.max(e.x, n)), Math.min(Math.max(e.y, n))) : new I(Math.min(Math.max(e.x, n), r), Math.min(Math.max(e.y, n), r));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(e, n, r = 6) {
    const s = [];
    for (let o = 0; o < r; o++) {
      const i = Mo.easeInQuad(o / (r - 1)), a = I.Lrp(e, n, i);
      a.z = Math.min(1, 0.5 + Math.abs(0.5 - A4e(i)) * 0.65), s.push(a);
    }
    return s;
  }
  static SnapToGrid(e, n = 8) {
    return new I(Math.round(e.x / n) * n, Math.round(e.y / n) * n);
  }
}
const A4e = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
function eo(t) {
  return `${ne(t.x)},${ne(t.y)} `;
}
function Oi(t, e) {
  return `${ne((t.x + e.x) / 2)},${ne((t.y + e.y) / 2)} `;
}
const mn = Math.PI, ar = mn / 2, Bn = mn * 2, M4e = Math.sin;
function wt(t, e, n) {
  return Math.max(e, typeof n < "u" ? Math.min(t, n) : t);
}
function _1(t, e = 1e10) {
  return t ? Math.round(t * e) / e : 0;
}
function Hr(t, e, n = 1e-6) {
  return Math.abs(t - e) <= n;
}
function E1(t, e, n = 1e-6) {
  return t < e || Hr(t, e, n);
}
function O4e(t, e) {
  const n = Math.pow(t - e, 2) / Math.pow(t + e, 2);
  return mn * (t + e) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n)));
}
function RE(t) {
  return t = t % Bn, t < 0 ? t = t + Bn : t === 0 && (t = 0), t;
}
function l3(t, e) {
  return t = RE(t), e = RE(e), t > e && (e += Bn), e - t;
}
function D4e(t, e) {
  return Bn - l3(t, e);
}
function e_(t, e) {
  const n = (e - t) % Bn;
  return 2 * n % Bn - n;
}
function oj(t) {
  return (Bn + t) % Bn;
}
function $E(t, e) {
  const n = Bn / e;
  let r = Math.floor((oj(t) + n / 2) / n) * n % Bn;
  return r < mn && (r += Bn), r > mn && (r -= Bn), r;
}
function tne(t, e) {
  return t === e || Hr(t % (Math.PI / 2) - e % (Math.PI / 2), 0);
}
function N4e(t) {
  return t * mn / 180;
}
function j4e(t) {
  return t * 180 / mn;
}
function d3(t, e, n) {
  return new I(t.x, t.y).add(I.FromAngle(n, e));
}
function QM(t, e, n) {
  const r = t / 2, s = e / 2, o = [];
  let i = 1 / 0, a = -1 / 0, c = 1 / 0, l = -1 / 0;
  for (let g = 0; g < n; g++) {
    const y = Bn / n, m = -ar + g * y, v = r + r * Math.cos(m), b = s + s * Math.sin(m);
    v < i && (i = v), b < c && (c = b), v > a && (a = v), b > l && (l = b), o.push(new I(v, b));
  }
  const d = a - i, u = l - c, f = t - d, p = e - u;
  if (f !== 0 || p !== 0)
    for (let g = 0; g < o.length; g++) {
      const y = o[g];
      y.x = (y.x - i) / d * t, y.y = (y.y - c) / u * e;
    }
  return o;
}
function nb(t, e, n, r) {
  return t < r && n < e;
}
function Mc(t, e, n, r) {
  const s = Math.max(t, n), o = Math.min(e, r);
  return s <= o ? [s, o] : null;
}
function G8(t, e, n) {
  return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y);
}
function li(t, e) {
  let n = 0, r, s;
  for (let o = 0; o < e.length; o++) {
    if (r = e[o], r.x === t.x && r.y === t.y || (s = e[(o + 1) % e.length], I.Dist(t, r) + I.Dist(t, s) === I.Dist(r, s))) return !0;
    r.y <= t.y ? s.y > t.y && G8(r, s, t) > 0 && (n += 1) : s.y <= t.y && G8(r, s, t) < 0 && (n -= 1);
  }
  return n !== 0;
}
function ne(t) {
  return Math.round(t * 1e4) / 1e4;
}
function Nc(t) {
  return Math.round(t * 100) / 100;
}
const Y8 = (t) => Math.abs(t) < Number.MAX_SAFE_INTEGER;
function q8(t, e, n, r) {
  let s;
  if (Math.abs(t) > mn) {
    s = e_(e, r);
    const o = e_(r, n);
    return Math.abs(s) < Math.abs(o) ? s / t : (t - o) / t;
  } else {
    s = e_(e, r);
    const o = s / t;
    return Math.sign(s) !== Math.sign(t) ? Math.abs(o) > 0.5 ? 1 : 0 : o;
  }
}
function R4e(t, e, n, r) {
  const s = 2 * ((e - t) % Bn) % Bn - (e - t) % Bn;
  return r ? (Bn - Math.abs(s)) * (n ? 1 : -1) : s;
}
function nne(t, e, n) {
  const r = -2 * (t.x * (e.y - n.y) - t.y * (e.x - n.x) + e.x * n.y - n.x * e.y), s = ((t.x * t.x + t.y * t.y) * (n.y - e.y) + (e.x * e.x + e.y * e.y) * (t.y - n.y) + (n.x * n.x + n.y * n.y) * (e.y - t.y)) / r, o = ((t.x * t.x + t.y * t.y) * (e.x - n.x) + (e.x * e.x + e.y * e.y) * (n.x - t.x) + (n.x * n.x + n.y * n.y) * (t.x - e.x)) / r;
  return !Number.isFinite(s) || !Number.isFinite(o) ? null : new I(s, o);
}
const JM = ({ brush: t, color: e, opacity: n, className: r }) => {
  const s = fe(null);
  Y0(s, t.x, t.y);
  const o = ne(Math.max(1, t.w)), i = ne(Math.max(1, t.h));
  return /* @__PURE__ */ h.jsx("svg", { className: "tl-overlays__item", ref: s, "aria-hidden": "true", children: e ? /* @__PURE__ */ h.jsxs("g", { className: "tl-brush", opacity: n, children: [
    /* @__PURE__ */ h.jsx("rect", { width: o, height: i, fill: e, opacity: 0.75 }),
    /* @__PURE__ */ h.jsx("rect", { width: o, height: i, fill: "none", stroke: e, opacity: 0.1 })
  ] }) : /* @__PURE__ */ h.jsx("rect", { className: `tl-brush tl-brush__default ${r}`, width: o, height: i }) });
};
var rne = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
  (function() {
    var e = {}.hasOwnProperty;
    function n() {
      for (var o = "", i = 0; i < arguments.length; i++) {
        var a = arguments[i];
        a && (o = s(o, r(a)));
      }
      return o;
    }
    function r(o) {
      if (typeof o == "string" || typeof o == "number")
        return o;
      if (typeof o != "object")
        return "";
      if (Array.isArray(o))
        return n.apply(null, o);
      if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]"))
        return o.toString();
      var i = "";
      for (var a in o)
        e.call(o, a) && o[a] && (i = s(i, a));
      return i;
    }
    function s(o, i) {
      return i ? o ? o + " " + i : o + i : o;
    }
    t.exports ? (n.default = n, t.exports = n) : window.classNames = n;
  })();
})(rne);
var $4e = rne.exports;
const Je = /* @__PURE__ */ Wr($4e), dn = {
  isSafari: !1,
  isIos: !1,
  isChromeForIos: !1,
  isFirefox: !1,
  isAndroid: !1,
  isWebview: !1,
  isDarwin: !1,
  hasCanvasSupport: !1
};
typeof window < "u" && "navigator" in window && (dn.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), dn.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i), dn.isChromeForIos = /crios.*safari/i.test(navigator.userAgent), dn.isFirefox = /firefox/i.test(navigator.userAgent), dn.isAndroid = /android/i.test(navigator.userAgent), dn.isDarwin = window.navigator.userAgent.toLowerCase().indexOf("mac") > -1, dn.hasCanvasSupport = typeof window < "u" && "Promise" in window && "HTMLCanvasElement" in window);
const X8 = {
  isLocked: !1,
  wheelBehavior: "pan",
  panSpeed: 1,
  zoomSpeed: 1,
  zoomSteps: [0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8]
}, eO = {
  duration: 0,
  easing: Mo.easeInOutCubic
}, Z8 = {
  CAMERA_MOVE: -10
}, L4e = ["top", "right", "bottom", "left"], Q8 = 0, u3 = 2, T1 = 1, J8 = 5, F4e = 128, B4e = {}, sne = wo(
  "pointerCaptureTrackingObject",
  // ideally we wouldn't store this mutable value in an atom but it's not
  // a big deal for debug values
  {
    defaults: { all: /* @__PURE__ */ new Map() },
    shouldStoreForSession: !1
  }
), ir = {
  // --- DEBUG VALUES ---
  logPreventDefaults: wo("logPreventDefaults", {
    defaults: { all: !1 }
  }),
  logPointerCaptures: wo("logPointerCaptures", {
    defaults: { all: !1 }
  }),
  logElementRemoves: wo("logElementRemoves", {
    defaults: { all: !1 }
  }),
  debugSvg: wo("debugSvg", {
    defaults: { all: !1 }
  }),
  showFps: wo("showFps", {
    defaults: { all: !1 }
  }),
  measurePerformance: wo("measurePerformance", { defaults: { all: !1 } }),
  throwToBlob: wo("throwToBlob", {
    defaults: { all: !1 }
  }),
  reconnectOnPing: wo("reconnectOnPing", {
    defaults: { all: !1 }
  }),
  debugCursors: wo("debugCursors", {
    defaults: { all: !1 }
  }),
  forceSrgb: wo("forceSrgbColors", { defaults: { all: !1 } }),
  debugGeometry: wo("debugGeometry", { defaults: { all: !1 } }),
  hideShapes: wo("hideShapes", { defaults: { all: !1 } }),
  editOnType: wo("editOnType", { defaults: { all: !1 } }),
  a11y: wo("a11y", { defaults: { all: !1 } }),
  debugElbowArrows: wo("debugElbowArrows", { defaults: { all: !1 } })
};
if (typeof Element < "u") {
  const t = Element.prototype.removeChild;
  ya("element removal logging", () => {
    ir.logElementRemoves.get() ? Element.prototype.removeChild = function(e) {
      return console.warn("[tldraw] removing child:", e), t.call(this, e);
    } : Element.prototype.removeChild = t;
  });
}
function wo(t, {
  defaults: e,
  shouldStoreForSession: n = !0
}) {
  return z4e({
    name: t,
    defaults: e,
    shouldStoreForSession: n
  });
}
function z4e(t) {
  const e = H4e(t), n = t.shouldStoreForSession ? U4e(t.name) : null, r = yr(`debug:${t.name}`, n ?? e);
  return typeof window < "u" && (t.shouldStoreForSession && ya(`debug:${t.name}`, () => {
    const s = r.get();
    s === e ? qJ(`tldraw_debug:${t.name}`) : mF(`tldraw_debug:${t.name}`, JSON.stringify(s));
  }), Object.defineProperty(window, `tldraw${t.name.replace(/^[a-z]/, (s) => s.toUpperCase())}`, {
    get() {
      return r.get();
    },
    set(s) {
      r.set(s);
    },
    configurable: !0
  })), Object.assign(r, t, {
    reset: () => r.set(e)
  });
}
function U4e(t) {
  try {
    return JSON.parse(YJ(`tldraw_debug:${t}`) ?? "null");
  } catch {
    return null;
  }
}
function tO(t) {
  try {
    return t();
  } catch {
    return null;
  }
}
function H4e(t) {
  switch (tO(() => process.env.TLDRAW_ENV) ?? tO(() => process.env.VERCEL_PUBLIC_TLDRAW_ENV) ?? tO(() => process.env.NEXT_PUBLIC_TLDRAW_ENV) ?? // default to production because if we don't have one of these, this is probably a library use
  "production") {
    case "production":
      return t.defaults.production ?? t.defaults.all;
    case "preview":
    case "staging":
      return t.defaults.staging ?? t.defaults.all;
    default:
      return t.defaults.development ?? t.defaults.all;
  }
}
function LE(t) {
  if (t.nodeType === Node.ELEMENT_NODE) return t;
  if (t.parentElement) return LE(t.parentElement);
  throw Error("Could not find a parent element of an HTML type!");
}
function xt(t) {
  t.preventDefault(), ir.logPreventDefaults.get() && console.warn("preventDefault called on event:", t);
}
function q0(t, e) {
  if (t.setPointerCapture(e.pointerId), ir.logPointerCaptures.get()) {
    const n = sne.get();
    n.set(t, (n.get(t) ?? 0) + 1), console.warn("setPointerCapture called on element:", t, e);
  }
}
function X0(t, e) {
  if (t.hasPointerCapture(e.pointerId) && (t.releasePointerCapture(e.pointerId), ir.logPointerCaptures.get())) {
    const n = sne.get();
    n.get(t) === 1 ? n.delete(t) : n.has(t) ? n.set(t, n.get(t) - 1) : console.warn("Release without capture"), console.warn("releasePointerCapture called on element:", t, e);
  }
}
const cr = (t) => t.stopPropagation(), So = (t, e, n) => {
  t && t.style.setProperty(e, n);
};
function one(t = !1) {
  const { activeElement: e } = document, n = t ? ["input", "textarea"] : ["input", "select", "button", "textarea"];
  return !!(e && (e.isContentEditable || n.indexOf(e.tagName.toLowerCase()) > -1 || e.classList.contains("tlui-slider__thumb")));
}
const ms = (t) => dn.isDarwin ? t.metaKey : t.ctrlKey || t.metaKey;
function la(t) {
  return t.isKilled = !0, {
    point: {
      x: t.clientX,
      y: t.clientY,
      z: t.pressure
    },
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    ctrlKey: t.metaKey || t.ctrlKey,
    metaKey: t.metaKey,
    accelKey: ms(t),
    pointerId: t.pointerId,
    button: t.button,
    isPen: t.pointerType === "pen"
  };
}
function f3(t, e) {
  return jI(`${t}_${e}`);
}
function gg(t) {
  return jI(`${Bbe()}${t ?? ""}`);
}
function Xc(t) {
  const e = Io(tn(ine));
  return jI(`${e}_${t}`);
}
function jI(t) {
  return t.replace(/:/g, "_");
}
const ine = zn(null);
function V4e({ children: t }) {
  const e = gg();
  return /* @__PURE__ */ h.jsx(ine.Provider, { value: e, children: t });
}
const h3 = zn(null);
function ie() {
  const t = B.useContext(h3);
  if (!t)
    throw new Error(
      "useEditor must be used inside of the <Tldraw /> or <TldrawEditor /> components"
    );
  return t;
}
function uo() {
  return B.useContext(h3);
}
function p3({ editor: t, children: e }) {
  return /* @__PURE__ */ h.jsx(h3.Provider, { value: t, children: /* @__PURE__ */ h.jsx(V4e, { children: e }) });
}
function g3() {
  const t = ie(), e = le("current tool", () => t.getCurrentTool(), [t]);
  return Ke(
    function() {
      let s, o;
      function i(m) {
        if (!m.isKilled) {
          if (m.button === u3) {
            t.dispatch({
              type: "pointer",
              target: "canvas",
              name: "right_click",
              ...la(m)
            });
            return;
          }
          m.button !== 0 && m.button !== 1 && m.button !== 5 || (q0(m.currentTarget, m), t.dispatch({
            type: "pointer",
            target: "canvas",
            name: "pointer_down",
            ...la(m)
          }));
        }
      }
      function a(m) {
        if (m.isKilled || m.clientX === s && m.clientY === o) return;
        s = m.clientX, o = m.clientY;
        const v = e.useCoalescedEvents && m.nativeEvent.getCoalescedEvents ? m.nativeEvent.getCoalescedEvents() : [m];
        for (const b of v)
          t.dispatch({
            type: "pointer",
            target: "canvas",
            name: "pointer_move",
            ...la(b)
          });
      }
      function c(m) {
        m.isKilled || m.button !== 0 && m.button !== 1 && m.button !== 2 && m.button !== 5 || (s = m.clientX, o = m.clientY, X0(m.currentTarget, m), t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_up",
          ...la(m)
        }));
      }
      function l(m) {
        if (m.isKilled || t.getInstanceState().isPenMode && m.pointerType !== "pen") return;
        const v = m.pointerType === "mouse" || m.pointerType === "pen";
        t.updateInstanceState({ isHoveringCanvas: v ? !0 : null });
      }
      function d(m) {
        if (m.isKilled || t.getInstanceState().isPenMode && m.pointerType !== "pen") return;
        const v = m.pointerType === "mouse" || m.pointerType === "pen";
        t.updateInstanceState({ isHoveringCanvas: v ? !1 : null });
      }
      function u(m) {
        m.isKilled = !0, xt(m);
      }
      function f(m) {
        m.isKilled = !0, m.target instanceof HTMLElement && m.target.tagName !== "A" && m.target.tagName !== "TEXTAREA" && !m.target.isContentEditable && // When in EditingShape state, we are actually clicking on a 'DIV'
        // not A/TEXTAREA/contenteditable element yet. So, to preserve cursor position
        // for edit mode on mobile we need to not preventDefault.
        // TODO: Find out if we still need this preventDefault in general though.
        !(t.getEditingShape() && m.target.className.includes("tl-text-content")) && xt(m);
      }
      function p(m) {
        xt(m);
      }
      async function g(m) {
        var b, x;
        if (xt(m), cr(m), (x = (b = m.dataTransfer) == null ? void 0 : b.files) != null && x.length) {
          const w = Array.from(m.dataTransfer.files);
          await t.putExternalContent({
            type: "files",
            files: w,
            point: t.screenToPage({ x: m.clientX, y: m.clientY })
          });
          return;
        }
        const v = m.dataTransfer.getData("url");
        if (v) {
          await t.putExternalContent({
            type: "url",
            url: v,
            point: t.screenToPage({ x: m.clientX, y: m.clientY })
          });
          return;
        }
      }
      function y(m) {
        cr(m);
      }
      return {
        onPointerDown: i,
        onPointerMove: a,
        onPointerUp: c,
        onPointerEnter: l,
        onPointerLeave: d,
        onDragOver: p,
        onDrop: g,
        onTouchStart: u,
        onTouchEnd: f,
        onClick: y
      };
    },
    [t, e]
  );
}
function W4e() {
  const t = ie();
  me(() => {
    let e = t.getInstanceState().isCoarsePointer;
    const n = (i) => {
      const a = i.pointerType !== "mouse";
      e !== a && (e = a, t.updateInstanceState({ isCoarsePointer: a }));
    };
    window.addEventListener("pointerdown", n, { capture: !0 });
    const r = window.matchMedia && window.matchMedia("(any-pointer: coarse)"), s = dn.isFirefox && !dn.isAndroid && !dn.isIos, o = () => {
      const i = s ? !1 : r.matches;
      e === i && (e = i, t.updateInstanceState({ isCoarsePointer: i }));
    };
    return r && (r.addEventListener("change", o), o()), () => {
      window.removeEventListener("pointerdown", n, { capture: !0 }), r && r.removeEventListener("change", o);
    };
  }, [t]);
}
const ane = zn(null);
function cne({ container: t, children: e }) {
  return /* @__PURE__ */ h.jsx(ane.Provider, { value: t, children: e });
}
function Gr() {
  return Io(tn(ane), "useContainer used outside of <Tldraw />");
}
function K4e() {
  const t = ie(), e = Gr(), n = le("isEditing", () => t.getEditingShapeId(), [t]), r = le("isFocused", () => t.getIsFocused(), [t]);
  me(() => {
    if (!e) return;
    function s(o) {
      if (o.isSpecialRedispatchedEvent) return;
      xt(o), cr(o);
      const i = e.querySelector(".tl-canvas");
      if (!i) return;
      const a = new DragEvent(o.type, o);
      a.isSpecialRedispatchedEvent = !0, i.dispatchEvent(a);
    }
    return e.addEventListener("dragover", s), e.addEventListener("drop", s), () => {
      e.removeEventListener("dragover", s), e.removeEventListener("drop", s);
    };
  }, [e]), me(() => {
    if (typeof window > "u" || !("matchMedia" in window)) return;
    let s = null;
    const o = () => {
      s != null && s();
      const i = `(resolution: ${window.devicePixelRatio}dppx)`, a = matchMedia(i), c = (l) => {
        l.type === "change" && o();
      };
      a.addEventListener ? a.addEventListener("change", o) : a.addListener && a.addListener(c), s = () => {
        a.removeEventListener ? a.removeEventListener("change", o) : a.removeListener && a.removeListener(c);
      }, t.updateInstanceState({ devicePixelRatio: window.devicePixelRatio });
    };
    return o(), () => {
      s == null || s();
    };
  }, [t]), me(() => {
    if (!r) return;
    const s = (c) => {
      if (c.altKey && // todo: When should we allow the alt key to be used? Perhaps states should declare which keys matter to them?
      (t.isIn("zoom") || !t.getPath().endsWith(".idle")) && !rb(t) && xt(c), c.isKilled) return;
      c.isKilled = !0;
      const l = !!t.getSelectedShapeIds().length;
      switch (c.key) {
        case "=":
        case "-":
        case "0": {
          if (c.metaKey || c.ctrlKey) {
            xt(c);
            return;
          }
          break;
        }
        case "Tab": {
          if (rb(t))
            return;
          l && !n && xt(c);
          break;
        }
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown": {
          if (rb(t))
            return;
          l && (c.metaKey || c.ctrlKey) && xt(c);
          break;
        }
        case ",":
          return;
        case "Escape": {
          if ((t.getEditingShape() || t.getSelectedShapeIds().length > 0) && xt(c), t.menus.getOpenMenus().length > 0) return;
          t.inputs.keys.has("Escape") || (t.inputs.keys.add("Escape"), t.cancel(), e.focus());
          return;
        }
        default:
          if (rb(t))
            return;
      }
      const d = {
        type: "keyboard",
        name: c.repeat ? "key_repeat" : "key_down",
        key: c.key,
        code: c.code,
        shiftKey: c.shiftKey,
        altKey: c.altKey,
        ctrlKey: c.metaKey || c.ctrlKey,
        metaKey: c.metaKey,
        accelKey: ms(c)
      };
      t.dispatch(d);
    }, o = (c) => {
      if (c.isKilled || (c.isKilled = !0, rb(t)) || c.key === ",")
        return;
      const l = {
        type: "keyboard",
        name: "key_up",
        key: c.key,
        code: c.code,
        shiftKey: c.shiftKey,
        altKey: c.altKey,
        ctrlKey: c.metaKey || c.ctrlKey,
        metaKey: c.metaKey,
        accelKey: ms(c)
      };
      t.dispatch(l);
    };
    function i(c) {
      var l, d;
      if (e.contains(c.target)) {
        const u = c.touches[0].pageX, f = c.touches[0].radiusX || 0;
        (u - f < 10 || u + f > t.getViewportScreenBounds().width - 10) && (((l = c.target) == null ? void 0 : l.tagName) === "BUTTON" && ((d = c.target) == null || d.click()), xt(c));
      }
    }
    const a = (c) => {
      e.contains(c.target) && (c.ctrlKey || c.metaKey) && xt(c);
    };
    return e.addEventListener("touchstart", i, { passive: !1 }), e.addEventListener("wheel", a, { passive: !1 }), document.addEventListener("gesturestart", xt), document.addEventListener("gesturechange", xt), document.addEventListener("gestureend", xt), e.addEventListener("keydown", s), e.addEventListener("keyup", o), () => {
      e.removeEventListener("touchstart", i), e.removeEventListener("wheel", a), document.removeEventListener("gesturestart", xt), document.removeEventListener("gesturechange", xt), document.removeEventListener("gestureend", xt), e.removeEventListener("keydown", s), e.removeEventListener("keyup", o);
    };
  }, [t, e, r, n]);
}
function rb(t) {
  return t.menus.hasOpenMenus() || one();
}
function G4e({
  className: t,
  zoom: e,
  point: n,
  color: r,
  viewport: s,
  opacity: o = 1
}) {
  const i = fe(null);
  Y0(
    i,
    wt(n.x, s.minX + 5 / e, s.maxX - 5 / e),
    wt(n.y, s.minY + 5 / e, s.maxY - 5 / e),
    1 / e,
    I.Angle(s.center, n)
  );
  const a = Xc("cursor_hint");
  return /* @__PURE__ */ h.jsxs("svg", { ref: i, className: Je("tl-overlays__item", t), "aria-hidden": "true", children: [
    /* @__PURE__ */ h.jsx(
      "use",
      {
        href: `#${a}`,
        color: r,
        strokeWidth: 3,
        stroke: "var(--color-background)"
      }
    ),
    /* @__PURE__ */ h.jsx("use", { href: `#${a}`, color: r, opacity: o })
  ] });
}
const eH = it(function({
  className: e,
  zoom: n,
  point: r,
  color: s,
  name: o,
  chatMessage: i
}) {
  const a = fe(null);
  Y0(a, r == null ? void 0 : r.x, r == null ? void 0 : r.y, 1 / n);
  const c = Xc("cursor");
  return r ? /* @__PURE__ */ h.jsxs("div", { ref: a, className: Je("tl-overlays__item", e), children: [
    /* @__PURE__ */ h.jsx("svg", { className: "tl-cursor", "aria-hidden": "true", children: /* @__PURE__ */ h.jsx("use", { href: `#${c}`, color: s }) }),
    i ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      o && /* @__PURE__ */ h.jsx("div", { className: "tl-nametag-title", style: { color: s }, children: o }),
      /* @__PURE__ */ h.jsx("div", { className: "tl-nametag-chat", style: { backgroundColor: s }, children: i })
    ] }) : o && /* @__PURE__ */ h.jsx("div", { className: "tl-nametag", style: { backgroundColor: s }, children: o })
  ] }) : null;
}), RI = {
  openWindow(t, e) {
    window.open(t, e, "noopener noreferrer");
  },
  refreshPage() {
    window.location.reload();
  },
  async hardReset() {
    var t;
    return await ((t = window.__tldraw__hardReset) == null ? void 0 : t.call(window));
  }
};
function lne() {
  RI.hardReset();
}
function Y4e() {
  RI.refreshPage();
}
const q4e = { error: null };
let m3 = class extends T.Component {
  constructor() {
    super(...arguments);
    P(this, "state", q4e);
  }
  static getDerivedStateFromError(n) {
    return { error: n };
  }
  componentDidCatch(n) {
    var r, s;
    (s = (r = this.props).onError) == null || s.call(r, n);
  }
  render() {
    const { error: n } = this.state;
    if (n !== null) {
      const { fallback: r } = this.props;
      return /* @__PURE__ */ h.jsx(r, { error: n });
    }
    return this.props.children;
  }
};
function dw({
  children: t,
  fallback: e,
  ...n
}) {
  return e === null ? t : /* @__PURE__ */ h.jsx(m3, { fallback: e, ...n, children: t });
}
const X4e = "https://github.com/tldraw/tldraw/issues/new", dne = ({ error: t, editor: e }) => {
  const n = fe(null), [r, s] = he(process.env.NODE_ENV === "development"), [o, i] = he(!1), [a, c] = he(!1);
  let l = null;
  try {
    l = Ln().Canvas ?? null;
  } catch {
  }
  const d = t instanceof Error ? t.message : String(t), u = t instanceof Error ? t.stack : null, f = le(
    "isDarkMode",
    () => {
      try {
        if (e)
          return e.user.getIsDarkMode();
      } catch {
      }
      return null;
    },
    [e]
  ), [p, g] = he(null);
  un(() => {
    var S;
    f !== null && g(f);
    let x = (S = n.current) == null ? void 0 : S.parentElement, w = !1;
    for (; x; ) {
      if (x.classList.contains("tl-theme__dark") || x.classList.contains("tl-theme__light")) {
        w = !0;
        break;
      }
      x = x.parentElement;
    }
    if (w) {
      g(null);
      return;
    }
    typeof window < "u" && "matchMedia" in window && g(window.matchMedia("(prefers-color-scheme: dark)").matches);
  }, [f]), me(() => {
    if (o) {
      const x = e == null ? void 0 : e.timers.setTimeout(() => {
        i(!1);
      }, 2e3);
      return () => clearTimeout(x);
    }
  }, [o, e]);
  const y = () => {
    const x = document.createElement("textarea");
    x.value = u ?? d, document.body.appendChild(x), x.select(), document.execCommand("copy"), x.remove(), i(!0);
  }, m = () => {
    Y4e();
  }, v = async () => {
    lne();
  }, b = new URL(X4e);
  return b.searchParams.set("title", d), b.searchParams.set("labels", "bug"), b.searchParams.set(
    "body",
    `Hey, I ran into an error while using tldraw:

\`\`\`js
${u ?? d}
\`\`\`

My browser: ${navigator.userAgent}`
  ), /* @__PURE__ */ h.jsxs(
    "div",
    {
      ref: n,
      className: Je(
        "tl-container tl-error-boundary",
        // error-boundary is sometimes used outside of the theme
        // container, so we need to provide it with a theme for our
        // styles to work correctly
        p === null ? "" : p ? "tl-theme__dark" : "tl-theme__light"
      ),
      children: [
        /* @__PURE__ */ h.jsx("div", { className: "tl-error-boundary__overlay" }),
        e && // opportunistically attempt to render the canvas to reassure
        // the user that their document is still there. there's a good
        // chance this won't work (ie the error that we're currently
        // notifying the user about originates in the canvas) so it's
        // not a big deal if it doesn't work - in that case we just have
        // a plain grey background.
        /* @__PURE__ */ h.jsx(m3, { onError: nw, fallback: () => null, children: /* @__PURE__ */ h.jsx(p3, { editor: e, children: /* @__PURE__ */ h.jsx("div", { className: "tl-overlay tl-error-boundary__canvas", children: l ? /* @__PURE__ */ h.jsx(l, {}) : null }) }) }),
        /* @__PURE__ */ h.jsx(
          "div",
          {
            className: Je("tl-modal", "tl-error-boundary__content", {
              "tl-error-boundary__content__expanded": r && !a
            }),
            children: a ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
              /* @__PURE__ */ h.jsx("h2", { children: "Are you sure?" }),
              /* @__PURE__ */ h.jsx("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
              /* @__PURE__ */ h.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ h.jsx("button", { className: "tlui-button", onClick: () => c(!1), children: "Cancel" }),
                /* @__PURE__ */ h.jsx("button", { className: "tlui-button tl-error-boundary__reset", onClick: v, children: "Reset data" })
              ] })
            ] }) : /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
              /* @__PURE__ */ h.jsx("h2", { children: "Something went wrong" }),
              /* @__PURE__ */ h.jsx("p", { children: "Please refresh your browser." }),
              /* @__PURE__ */ h.jsx("p", { children: "If the issue continues after refreshing, you may need to reset the tldraw data stored on your device." }),
              /* @__PURE__ */ h.jsxs("p", { children: [
                /* @__PURE__ */ h.jsx("strong", { children: "Note:" }),
                " Resetting will erase your current project and any unsaved work."
              ] }),
              process.env.NODE_ENV !== "production" && /* @__PURE__ */ h.jsxs("p", { children: [
                "If you're developing with the SDK and need help, join us on",
                " ",
                /* @__PURE__ */ h.jsx("a", { href: "https://discord.tldraw.com/?utm_source=sdk&utm_medium=organic&utm_campaign=error-screen", children: "Discord" }),
                "."
              ] }),
              r && /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
                "Message:",
                /* @__PURE__ */ h.jsx("h4", { children: /* @__PURE__ */ h.jsx("code", { children: d }) }),
                "Stack trace:",
                /* @__PURE__ */ h.jsxs("div", { className: "tl-error-boundary__content__error", children: [
                  /* @__PURE__ */ h.jsx("pre", { children: /* @__PURE__ */ h.jsx("code", { children: u ?? d }) }),
                  /* @__PURE__ */ h.jsx("button", { className: "tlui-button", onClick: y, children: o ? "Copied!" : "Copy" })
                ] })
              ] }),
              /* @__PURE__ */ h.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ h.jsx("button", { className: "tlui-button", onClick: () => s(!r), children: r ? "Hide details" : "Show details" }),
                /* @__PURE__ */ h.jsxs("div", { className: "tl-error-boundary__content__actions__group", children: [
                  /* @__PURE__ */ h.jsx(
                    "button",
                    {
                      className: "tlui-button tl-error-boundary__reset",
                      onClick: () => c(!0),
                      children: "Reset data"
                    }
                  ),
                  /* @__PURE__ */ h.jsx("button", { className: "tlui-button tl-error-boundary__refresh", onClick: m, children: "Refresh Page" })
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  );
};
function Z4e({ x: t, y: e, z: n, size: r }) {
  const s = gg("grid"), o = ie(), { gridSteps: i } = o.options;
  return /* @__PURE__ */ h.jsxs("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: [
    /* @__PURE__ */ h.jsx("defs", { children: i.map(({ min: a, mid: c, step: l }, d) => {
      const u = l * r * n, f = 0.5 + t * n, p = 0.5 + e * n, g = f > 0 ? f % u : u + f % u, y = p > 0 ? p % u : u + p % u, m = n < c ? ql(n, [a, c], [0, 1]) : 1;
      return /* @__PURE__ */ h.jsx(
        "pattern",
        {
          id: f3(s, `${l}`),
          width: u,
          height: u,
          patternUnits: "userSpaceOnUse",
          children: /* @__PURE__ */ h.jsx("circle", { className: "tl-grid-dot", cx: g, cy: y, r: 1, opacity: m })
        },
        d
      );
    }) }),
    i.map(({ step: a }, c) => /* @__PURE__ */ h.jsx("rect", { width: "100%", height: "100%", fill: `url(#${s}_${a})` }, c))
  ] });
}
function Q4e({ handle: t, isCoarse: e, className: n, zoom: r }) {
  const s = ie(), o = (e ? s.options.coarseHandleRadius : s.options.handleRadius) / r;
  if (t.type === "clone") {
    const a = 3 / r, c = `M0,${-a} A${a},${a} 0 0,1 0,${a}`, l = L4e.indexOf(t.id);
    return /* @__PURE__ */ h.jsxs("g", { className: Je(`tl-handle tl-handle__${t.type}`, n), children: [
      /* @__PURE__ */ h.jsx("circle", { className: "tl-handle__bg", r: o }),
      /* @__PURE__ */ h.jsx("path", { className: "tl-handle__fg", d: c, transform: `rotate(${-90 + 90 * l})` })
    ] });
  }
  const i = (t.type === "create" && e ? 3 : 4) / Math.max(r, 0.25);
  return /* @__PURE__ */ h.jsxs("g", { className: Je(`tl-handle tl-handle__${t.type}`, n), children: [
    /* @__PURE__ */ h.jsx("circle", { className: "tl-handle__bg", r: o }),
    /* @__PURE__ */ h.jsx("circle", { className: "tl-handle__fg", r: i })
  ] });
}
const J4e = ({ children: t }) => /* @__PURE__ */ h.jsx("svg", { className: "tl-user-handles tl-overlays__item", "aria-hidden": "true", children: t }), une = "3.15.5", tH = {
  major: "2024-09-13T14:36:29.063Z",
  minor: "2025-07-30T09:07:27.887Z",
  patch: "2025-09-30T13:16:39.779Z"
};
function fne(t, e) {
  const n = fe(t);
  return e(t, n.current) ? n.current : (n.current = t, t);
}
const eBe = (t, e) => (t ?? (t = null), e ?? (e = null), t === e ? !0 : !t || !e ? !1 : pE(t, e));
function Yu(t) {
  return fne(t, eBe);
}
const tBe = (t, e) => (t ?? (t = null), e ?? (e = null), t === e ? !0 : !t || !e ? !1 : MJ(t, e));
function cv(t) {
  return fne(t, tBe);
}
const hne = "TLDRAW_USER_DATA_v3", pne = Gt({
  id: Et,
  name: Et.nullable().optional(),
  color: Et.nullable().optional(),
  // N.B. These are duplicated in TLdrawAppUser.
  locale: Et.nullable().optional(),
  animationSpeed: dt.nullable().optional(),
  areKeyboardShortcutsEnabled: Bt.nullable().optional(),
  edgeScrollSpeed: dt.nullable().optional(),
  colorScheme: av("light", "dark", "system").optional(),
  isSnapMode: Bt.nullable().optional(),
  isWrapMode: Bt.nullable().optional(),
  isDynamicSizeMode: Bt.nullable().optional(),
  isPasteAtCursorMode: Bt.nullable().optional()
}), xl = {
  AddAnimationSpeed: 1,
  AddIsSnapMode: 2,
  MakeFieldsNullable: 3,
  AddEdgeScrollSpeed: 4,
  AddExcalidrawSelectMode: 5,
  AddDynamicSizeMode: 6,
  AllowSystemColorScheme: 7,
  AddPasteAtCursor: 8,
  AddKeyboardShortcuts: 9
}, y3 = Math.max(...Object.values(xl));
function nBe(t) {
  t.version < xl.AddAnimationSpeed && (t.user.animationSpeed = 1), t.version < xl.AddIsSnapMode && (t.user.isSnapMode = !1), t.version < xl.MakeFieldsNullable, t.version < xl.AddEdgeScrollSpeed && (t.user.edgeScrollSpeed = 1), t.version < xl.AddExcalidrawSelectMode && (t.user.isWrapMode = !1), t.version < xl.AllowSystemColorScheme && (t.user.isDarkMode === !0 ? t.user.colorScheme = "dark" : t.user.isDarkMode === !1 && (t.user.colorScheme = "light"), delete t.user.isDarkMode), t.version < xl.AddDynamicSizeMode && (t.user.isDynamicSizeMode = !1), t.version < xl.AddPasteAtCursor && (t.user.isPasteAtCursorMode = !1), t.version < xl.AddKeyboardShortcuts && (t.user.areKeyboardShortcutsEnabled = !0), t.version = y3;
}
const ij = [
  "#FF802B",
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467"
];
function gne() {
  return ij[Math.floor(Math.random() * ij.length)];
}
function rBe() {
  var t, e;
  return typeof window < "u" && "matchMedia" in window ? ((e = (t = window.matchMedia) == null ? void 0 : t.call(window, "(prefers-reduced-motion: reduce)")) == null ? void 0 : e.matches) ?? !1 : !1;
}
const Ua = Object.freeze({
  name: "",
  locale: T4e(),
  color: gne(),
  // N.B. These are duplicated in TLdrawAppUser.
  edgeScrollSpeed: 1,
  animationSpeed: rBe() ? 0 : 1,
  areKeyboardShortcutsEnabled: !0,
  isSnapMode: !1,
  isWrapMode: !1,
  isDynamicSizeMode: !1,
  isPasteAtCursorMode: !1,
  colorScheme: "light"
});
function nO() {
  return {
    id: bn(),
    color: gne()
  };
}
function mne(t) {
  if (t === null || typeof t != "object" || !("version" in t) || !("user" in t) || typeof t.version != "number")
    return nO();
  const e = mr(t);
  nBe(e);
  try {
    return pne.validate(e.user);
  } catch {
    return nO();
  }
}
function sBe() {
  const t = JSON.parse(pF(hne) || "null") ?? null;
  return mne(t);
}
const $I = yr("globalUserData", null);
function oBe() {
  gF(
    hne,
    JSON.stringify({
      version: y3,
      user: $I.get()
    })
  );
}
function yne(t) {
  pne.validate(t), $I.set(t), oBe(), aBe();
}
const iBe = typeof process < "u" && process.env.NODE_ENV === "test", Tm = typeof BroadcastChannel < "u" && !iBe ? new BroadcastChannel("tldraw-user-sync") : null;
Tm == null || Tm.addEventListener("message", (t) => {
  const e = t.data;
  (e == null ? void 0 : e.type) === bne && (e == null ? void 0 : e.origin) !== vne() && $I.set(mne(e.data));
});
let rO = null;
function vne() {
  return rO === null && (rO = bn()), rO;
}
const bne = "tldraw-user-preferences-change";
function aBe() {
  Tm == null || Tm.postMessage({
    type: bne,
    origin: vne(),
    data: {
      user: xne(),
      version: y3
    }
  });
}
function xne() {
  let t = $I.get();
  return t || (t = sBe(), yne(t)), t;
}
const cBe = ve(
  "defaultLocalStorageUserPrefs",
  () => xne()
);
function wne(t = {}) {
  return {
    userPreferences: t.userPreferences ?? cBe,
    setUserPreferences: t.setUserPreferences ?? yne
  };
}
var Sne = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function s(c, l, d) {
    this.fn = c, this.context = l, this.once = d || !1;
  }
  function o(c, l, d, u, f) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var p = new s(d, u || c, f), g = n ? n + l : l;
    return c._events[g] ? c._events[g].fn ? c._events[g] = [c._events[g], p] : c._events[g].push(p) : (c._events[g] = p, c._eventsCount++), c;
  }
  function i(c, l) {
    --c._eventsCount === 0 ? c._events = new r() : delete c._events[l];
  }
  function a() {
    this._events = new r(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var l = [], d, u;
    if (this._eventsCount === 0) return l;
    for (u in d = this._events)
      e.call(d, u) && l.push(n ? u.slice(1) : u);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(d)) : l;
  }, a.prototype.listeners = function(l) {
    var d = n ? n + l : l, u = this._events[d];
    if (!u) return [];
    if (u.fn) return [u.fn];
    for (var f = 0, p = u.length, g = new Array(p); f < p; f++)
      g[f] = u[f].fn;
    return g;
  }, a.prototype.listenerCount = function(l) {
    var d = n ? n + l : l, u = this._events[d];
    return u ? u.fn ? 1 : u.length : 0;
  }, a.prototype.emit = function(l, d, u, f, p, g) {
    var y = n ? n + l : l;
    if (!this._events[y]) return !1;
    var m = this._events[y], v = arguments.length, b, x;
    if (m.fn) {
      switch (m.once && this.removeListener(l, m.fn, void 0, !0), v) {
        case 1:
          return m.fn.call(m.context), !0;
        case 2:
          return m.fn.call(m.context, d), !0;
        case 3:
          return m.fn.call(m.context, d, u), !0;
        case 4:
          return m.fn.call(m.context, d, u, f), !0;
        case 5:
          return m.fn.call(m.context, d, u, f, p), !0;
        case 6:
          return m.fn.call(m.context, d, u, f, p, g), !0;
      }
      for (x = 1, b = new Array(v - 1); x < v; x++)
        b[x - 1] = arguments[x];
      m.fn.apply(m.context, b);
    } else {
      var w = m.length, S;
      for (x = 0; x < w; x++)
        switch (m[x].once && this.removeListener(l, m[x].fn, void 0, !0), v) {
          case 1:
            m[x].fn.call(m[x].context);
            break;
          case 2:
            m[x].fn.call(m[x].context, d);
            break;
          case 3:
            m[x].fn.call(m[x].context, d, u);
            break;
          case 4:
            m[x].fn.call(m[x].context, d, u, f);
            break;
          default:
            if (!b) for (S = 1, b = new Array(v - 1); S < v; S++)
              b[S - 1] = arguments[S];
            m[x].fn.apply(m[x].context, b);
        }
    }
    return !0;
  }, a.prototype.on = function(l, d, u) {
    return o(this, l, d, u, !1);
  }, a.prototype.once = function(l, d, u) {
    return o(this, l, d, u, !0);
  }, a.prototype.removeListener = function(l, d, u, f) {
    var p = n ? n + l : l;
    if (!this._events[p]) return this;
    if (!d)
      return i(this, p), this;
    var g = this._events[p];
    if (g.fn)
      g.fn === d && (!f || g.once) && (!u || g.context === u) && i(this, p);
    else {
      for (var y = 0, m = [], v = g.length; y < v; y++)
        (g[y].fn !== d || f && !g[y].once || u && g[y].context !== u) && m.push(g[y]);
      m.length ? this._events[p] = m.length === 1 ? m[0] : m : i(this, p);
    }
    return this;
  }, a.prototype.removeAllListeners = function(l) {
    var d;
    return l ? (d = n ? n + l : l, this._events[d] && i(this, d)) : (this._events = new r(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = n, a.EventEmitter = a, t.exports = a;
})(Sne);
var lBe = Sne.exports;
const dBe = /* @__PURE__ */ Wr(lBe), Pm = "TLDRAW_TAB_ID_v2", qd = globalThis.window;
function uBe() {
  return qd ? ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    qd.navigator.platform
  ) || // iPad on iOS 13 detection
  dn.isDarwin && "ontouchend" in document : !1;
}
const FE = qd ? qd[Pm] ?? YJ(Pm) ?? "TLDRAW_INSTANCE_STATE_V1_" + bn() : "<error>";
qd && (qd[Pm] = FE, uBe() ? mF(Pm, FE) : qJ(Pm));
qd == null || qd.addEventListener("beforeunload", () => {
  mF(Pm, FE);
});
const Cne = {
  Initial: 0
}, LI = Math.max(...Object.values(Cne));
function fBe(t) {
  t.version < Cne.Initial, t.version = LI;
}
const _ne = Gt({
  version: dt,
  currentPageId: cw.optional(),
  isFocusMode: Bt.optional(),
  exportBackground: Bt.optional(),
  isDebugMode: Bt.optional(),
  isToolLocked: Bt.optional(),
  isGridMode: Bt.optional(),
  pageStates: Ms(
    Gt({
      pageId: cw,
      camera: Gt({
        x: dt,
        y: dt,
        z: dt
      }).optional(),
      selectedShapeIds: Ms(Ka).optional(),
      focusedGroupId: Ka.nullable().optional()
    })
  ).optional()
});
function hBe(t) {
  if (!t || typeof t != "object")
    return console.warn("Invalid instance state"), null;
  if (!("version" in t) || typeof t.version != "number")
    return console.warn("No version in instance state"), null;
  t.version !== LI && (t = mr(t), fBe(t));
  try {
    return _ne.validate(t);
  } catch (e) {
    return console.warn(e), null;
  }
}
function v3(t) {
  const e = t.query.ids("page");
  return ve(
    "sessionStateSnapshot",
    () => {
      const n = t.get(ti);
      if (!n) return null;
      const r = [...e.get()];
      return {
        version: LI,
        currentPageId: n.currentPageId,
        exportBackground: n.exportBackground,
        isFocusMode: n.isFocusMode,
        isDebugMode: n.isDebugMode,
        isToolLocked: n.isToolLocked,
        isGridMode: n.isGridMode,
        pageStates: r.map((s) => {
          const o = t.get(Uc.createId(s)), i = t.get(Rl.createId(s));
          return {
            pageId: s,
            camera: {
              x: (i == null ? void 0 : i.x) ?? 0,
              y: (i == null ? void 0 : i.y) ?? 0,
              z: (i == null ? void 0 : i.z) ?? 1
            },
            selectedShapeIds: (o == null ? void 0 : o.selectedShapeIds) ?? [],
            focusedGroupId: (o == null ? void 0 : o.focusedGroupId) ?? null
          };
        })
      };
    },
    { isEqual: Zf }
  );
}
function aj(t, e, n) {
  const r = hBe(e);
  if (!r) return;
  const s = kte(t.get(ti)), o = n != null && n.forceOverwrite ? r : s, i = n != null && n.forceOverwrite ? s : r, a = t.schema.types.instance.create({
    id: ti,
    ...s,
    // the integrity checker will ensure that the currentPageId is valid
    currentPageId: r.currentPageId,
    isDebugMode: (o == null ? void 0 : o.isDebugMode) ?? (i == null ? void 0 : i.isDebugMode),
    isFocusMode: (o == null ? void 0 : o.isFocusMode) ?? (i == null ? void 0 : i.isFocusMode),
    isToolLocked: (o == null ? void 0 : o.isToolLocked) ?? (i == null ? void 0 : i.isToolLocked),
    isGridMode: (o == null ? void 0 : o.isGridMode) ?? (i == null ? void 0 : i.isGridMode),
    exportBackground: (o == null ? void 0 : o.exportBackground) ?? (i == null ? void 0 : i.exportBackground)
  });
  t.atomic(() => {
    var c, l, d;
    for (const u of r.pageStates ?? []) {
      if (!t.has(u.pageId)) continue;
      const f = Rl.createId(u.pageId), p = Uc.createId(u.pageId), g = t.get(f), y = t.get(p);
      t.put([
        Rl.create({
          id: f,
          x: ((c = u.camera) == null ? void 0 : c.x) ?? (g == null ? void 0 : g.x),
          y: ((l = u.camera) == null ? void 0 : l.y) ?? (g == null ? void 0 : g.y),
          z: ((d = u.camera) == null ? void 0 : d.z) ?? (g == null ? void 0 : g.z)
        }),
        Uc.create({
          id: p,
          pageId: u.pageId,
          selectedShapeIds: u.selectedShapeIds ?? (y == null ? void 0 : y.selectedShapeIds),
          focusedGroupId: u.focusedGroupId ?? (y == null ? void 0 : y.focusedGroupId)
        })
      ]);
    }
    t.put([a]), t.ensureStoreIsUsable();
  });
}
function pBe(t) {
  var s;
  const e = [];
  for (const o of Object.values(t))
    (s = o.typeName) != null && s.match(/^(instance.*|pointer|camera)$/) && e.push(o);
  const n = e.filter(
    (o) => o.typeName === "instance" && o.id !== ti
  )[0];
  if (!n) return null;
  const r = {
    version: LI,
    currentPageId: n.currentPageId,
    exportBackground: !!n.exportBackground,
    isFocusMode: !!n.isFocusMode,
    isDebugMode: !!n.isDebugMode,
    isToolLocked: !!n.isToolLocked,
    isGridMode: !1,
    pageStates: e.filter((o) => o.typeName === "instance_page_state" && o.instanceId === n.id).map((o) => {
      const i = t[o.cameraId] ?? { x: 0, y: 0, z: 1 };
      return {
        pageId: o.pageId,
        camera: {
          x: i.x,
          y: i.y,
          z: i.z
        },
        selectedShapeIds: o.selectedShapeIds,
        focusedGroupId: o.focusedGroupId
      };
    })
  };
  try {
    return _ne.validate(r), r;
  } catch {
    return null;
  }
}
function Ene(t, e, n) {
  let r = {};
  if ("store" in e) {
    const i = t.schema.migrateStoreSnapshot(e);
    if (i.type !== "success")
      throw new Error("Failed to migrate store snapshot: " + i.reason);
    r.document = {
      schema: t.schema.serialize(),
      store: gx(
        i.value,
        (a, { typeName: c }) => t.scopedTypes.document.has(c)
      )
    };
  } else
    r = e;
  const s = kte(t.get(ti)), o = Tne.get(t, v3).get();
  t.atomic(() => {
    r.document && t.loadStoreSnapshot(r.document), s && t.update(ti, (i) => ({ ...i, ...s })), o && aj(t, o), r.session && aj(t, r.session, {
      forceOverwrite: n == null ? void 0 : n.forceOverwriteSessionState
    });
  });
}
const Tne = new No();
function gBe(t) {
  const n = Tne.get(t, v3).get();
  if (!n)
    throw new Error("Session state is not ready yet");
  return {
    document: t.getStoreSnapshot(),
    session: n
  };
}
function Pne(t) {
  const e = [], n = /* @__PURE__ */ new Set();
  for (const r of t) {
    if (n.has(r.type))
      throw new Error(`Binding type "${r.type}" is defined more than once`);
    e.push(r), n.add(r.type);
  }
  return e;
}
function jf({ children: t, className: e = "", ...n }) {
  return /* @__PURE__ */ h.jsx("svg", { ...n, className: Je("tl-svg-container", e), "aria-hidden": "true", children: t });
}
class _e {
  constructor(e = 0, n = 0, r = 0, s = 0) {
    P(this, "x", 0);
    P(this, "y", 0);
    P(this, "w", 0);
    P(this, "h", 0);
    this.x = e, this.y = n, this.w = r, this.h = s;
  }
  // eslint-disable-next-line no-restricted-syntax
  get point() {
    return new I(this.x, this.y);
  }
  // eslint-disable-next-line no-restricted-syntax
  set point(e) {
    this.x = e.x, this.y = e.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minX() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minX(e) {
    this.x = e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get left() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midX() {
    return this.x + this.w / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxX() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get right() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minY() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minY(e) {
    this.y = e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get top() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midY() {
    return this.y + this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxY() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get bottom() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get width() {
    return this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  set width(e) {
    this.w = e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get height() {
    return this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  set height(e) {
    this.h = e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get aspectRatio() {
    return this.width / this.height;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return new I(this.x + this.w / 2, this.y + this.h / 2);
  }
  // eslint-disable-next-line no-restricted-syntax
  set center(e) {
    this.x = e.x - this.w / 2, this.y = e.y - this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get corners() {
    return [
      new I(this.x, this.y),
      new I(this.x + this.w, this.y),
      new I(this.x + this.w, this.y + this.h),
      new I(this.x, this.y + this.h)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get cornersAndCenter() {
    return [
      new I(this.x, this.y),
      new I(this.x + this.w, this.y),
      new I(this.x + this.w, this.y + this.h),
      new I(this.x, this.y + this.h),
      new I(this.x + this.w / 2, this.y + this.h / 2)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get sides() {
    const { corners: e } = this;
    return [
      [e[0], e[1]],
      [e[1], e[2]],
      [e[2], e[3]],
      [e[3], e[0]]
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return new I(this.w, this.h);
  }
  toFixed() {
    return this.x = _1(this.x), this.y = _1(this.y), this.w = _1(this.w), this.h = _1(this.h), this;
  }
  setTo(e) {
    return this.x = e.x, this.y = e.y, this.w = e.w, this.h = e.h, this;
  }
  set(e = 0, n = 0, r = 0, s = 0) {
    return this.x = e, this.y = n, this.w = r, this.h = s, this;
  }
  expand(e) {
    const n = Math.min(this.x, e.x), r = Math.min(this.y, e.y), s = Math.max(this.x + this.w, e.x + e.w), o = Math.max(this.y + this.h, e.y + e.h);
    return this.x = n, this.y = r, this.w = s - n, this.h = o - r, this;
  }
  expandBy(e) {
    return this.x -= e, this.y -= e, this.w += e * 2, this.h += e * 2, this;
  }
  scale(e) {
    return this.x /= e, this.y /= e, this.w /= e, this.h /= e, this;
  }
  clone() {
    const { x: e, y: n, w: r, h: s } = this;
    return new _e(e, n, r, s);
  }
  translate(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  snapToGrid(e) {
    const n = Math.round(this.x / e) * e, r = Math.round(this.y / e) * e, s = Math.round((this.x + this.w) / e) * e, o = Math.round((this.y + this.h) / e) * e;
    this.minX = n, this.minY = r, this.width = Math.max(1, s - n), this.height = Math.max(1, o - r);
  }
  collides(e) {
    return _e.Collides(this, e);
  }
  contains(e) {
    return _e.Contains(this, e);
  }
  includes(e) {
    return _e.Includes(this, e);
  }
  containsPoint(e, n = 0) {
    return _e.ContainsPoint(this, e, n);
  }
  getHandlePoint(e) {
    switch (e) {
      case "top_left":
        return new I(this.x, this.y);
      case "top_right":
        return new I(this.x + this.w, this.y);
      case "bottom_left":
        return new I(this.x, this.y + this.h);
      case "bottom_right":
        return new I(this.x + this.w, this.y + this.h);
      case "top":
        return new I(this.x + this.w / 2, this.y);
      case "right":
        return new I(this.x + this.w, this.y + this.h / 2);
      case "bottom":
        return new I(this.x + this.w / 2, this.y + this.h);
      case "left":
        return new I(this.x, this.y + this.h / 2);
    }
  }
  toJson() {
    return { x: this.x, y: this.y, w: this.w, h: this.h };
  }
  resize(e, n, r) {
    const { minX: s, minY: o, maxX: i, maxY: a } = this;
    let { minX: c, minY: l, maxX: d, maxY: u } = this;
    switch (e) {
      case "left":
      case "top_left":
      case "bottom_left": {
        c += n;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        d += n;
        break;
      }
    }
    switch (e) {
      case "top":
      case "top_left":
      case "top_right": {
        l += r;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        u += r;
        break;
      }
    }
    const f = (d - c) / (i - s), p = (u - l) / (a - o), g = f < 0, y = p < 0;
    if (g) {
      const m = d;
      d = c, c = m;
    }
    if (y) {
      const m = u;
      u = l, l = m;
    }
    this.minX = c, this.minY = l, this.width = Math.abs(d - c), this.height = Math.abs(u - l);
  }
  union(e) {
    const n = Math.min(this.x, e.x), r = Math.min(this.y, e.y), s = Math.max(this.x + this.w, e.x + e.w), o = Math.max(this.y + this.h, e.y + e.h);
    return this.x = n, this.y = r, this.width = s - n, this.height = o - r, this;
  }
  static From(e) {
    return new _e(e.x, e.y, e.w, e.h);
  }
  static FromCenter(e, n) {
    return new _e(e.x - n.x / 2, e.y - n.y / 2, n.x, n.y);
  }
  static FromPoints(e) {
    if (e.length === 0) return new _e();
    let n = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0, i;
    for (let a = 0, c = e.length; a < c; a++)
      i = e[a], n = Math.min(i.x, n), r = Math.min(i.y, r), s = Math.max(i.x, s), o = Math.max(i.y, o);
    return new _e(n, r, s - n, o - r);
  }
  static Expand(e, n) {
    const r = Math.min(n.minX, e.minX), s = Math.min(n.minY, e.minY), o = Math.max(n.maxX, e.maxX), i = Math.max(n.maxY, e.maxY);
    return new _e(r, s, o - r, i - s);
  }
  static ExpandBy(e, n) {
    return new _e(e.minX - n, e.minY - n, e.width + n * 2, e.height + n * 2);
  }
  static Collides(e, n) {
    return !(e.maxX < n.minX || e.minX > n.maxX || e.maxY < n.minY || e.minY > n.maxY);
  }
  static Contains(e, n) {
    return e.minX < n.minX && e.minY < n.minY && e.maxY > n.maxY && e.maxX > n.maxX;
  }
  static Includes(e, n) {
    return _e.Collides(e, n) || _e.Contains(e, n);
  }
  static ContainsPoint(e, n, r = 0) {
    return !(n.x < e.minX - r || n.y < e.minY - r || n.x > e.maxX + r || n.y > e.maxY + r);
  }
  static Common(e) {
    let n = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0;
    for (let i = 0; i < e.length; i++) {
      const a = e[i];
      n = Math.min(n, a.minX), r = Math.min(r, a.minY), s = Math.max(s, a.maxX), o = Math.max(o, a.maxY);
    }
    return new _e(n, r, s - n, o - r);
  }
  static Sides(e, n = 0) {
    const { corners: r } = e;
    return [
      [r[0], r[1]],
      [r[1], r[2]],
      [r[2], r[3]],
      [r[3], r[0]]
    ];
  }
  static Resize(e, n, r, s, o = !1) {
    const { minX: i, minY: a, maxX: c, maxY: l } = e;
    let { minX: d, minY: u, maxX: f, maxY: p } = e;
    switch (n) {
      case "left":
      case "top_left":
      case "bottom_left": {
        d += r;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        f += r;
        break;
      }
    }
    switch (n) {
      case "top":
      case "top_left":
      case "top_right": {
        u += s;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        p += s;
        break;
      }
    }
    const g = (f - d) / (c - i), y = (p - u) / (l - a), m = g < 0, v = y < 0;
    if (o) {
      const x = (c - i) / (l - a), w = Math.abs(f - d), S = Math.abs(p - u), C = w * (y < 0 ? 1 : -1) * (1 / x), _ = S * (g < 0 ? 1 : -1) * x, E = x < w / S;
      switch (n) {
        case "top_left": {
          E ? u = p + C : d = f + _;
          break;
        }
        case "top_right": {
          E ? u = p + C : f = d - _;
          break;
        }
        case "bottom_right": {
          E ? p = u - C : f = d - _;
          break;
        }
        case "bottom_left": {
          E ? p = u - C : d = f + _;
          break;
        }
        case "bottom":
        case "top": {
          const M = (d + f) / 2, N = S * x;
          d = M - N / 2, f = M + N / 2;
          break;
        }
        case "left":
        case "right": {
          const M = (u + p) / 2, N = w / x;
          u = M - N / 2, p = M + N / 2;
          break;
        }
      }
    }
    if (m) {
      const x = f;
      f = d, d = x;
    }
    if (v) {
      const x = p;
      p = u, u = x;
    }
    const b = new _e(d, u, Math.abs(f - d), Math.abs(p - u));
    return {
      box: b,
      scaleX: +(b.width / e.width * (g > 0 ? 1 : -1)).toFixed(5),
      scaleY: +(b.height / e.height * (y > 0 ? 1 : -1)).toFixed(5)
    };
  }
  equals(e) {
    return _e.Equals(this, e);
  }
  static Equals(e, n) {
    return n.x === e.x && n.y === e.y && n.w === e.w && n.h === e.h;
  }
  zeroFix() {
    return this.w = Math.max(1, this.w), this.h = Math.max(1, this.h), this;
  }
  static ZeroFix(e) {
    return new _e(e.x, e.y, Math.max(1, e.w), Math.max(1, e.h));
  }
}
function mBe(t) {
  switch (t) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return t;
  }
}
function yBe(t) {
  switch (t) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return t;
  }
}
function vBe(t) {
  return t === "top_left" || t === "top_right" || t === "bottom_right" || t === "bottom_left";
}
class we {
  constructor(e, n, r, s, o, i) {
    P(this, "a", 1);
    P(this, "b", 0);
    P(this, "c", 0);
    P(this, "d", 1);
    P(this, "e", 0);
    P(this, "f", 0);
    this.a = e, this.b = n, this.c = r, this.d = s, this.e = o, this.f = i;
  }
  equals(e) {
    return this === e || this.a === e.a && this.b === e.b && this.c === e.c && this.d === e.d && this.e === e.e && this.f === e.f;
  }
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
  }
  multiply(e) {
    const n = e, { a: r, b: s, c: o, d: i, e: a, f: c } = this;
    return this.a = r * n.a + o * n.b, this.c = r * n.c + o * n.d, this.e = r * n.e + o * n.f + a, this.b = s * n.a + i * n.b, this.d = s * n.c + i * n.d, this.f = s * n.e + i * n.f + c, this;
  }
  rotate(e, n, r) {
    return e === 0 ? this : n === void 0 ? this.multiply(we.Rotate(e)) : this.translate(n, r).multiply(we.Rotate(e)).translate(-n, -r);
  }
  translate(e, n) {
    return this.multiply(we.Translate(e, n));
  }
  scale(e, n) {
    return this.multiply(we.Scale(e, n));
  }
  invert() {
    const { a: e, b: n, c: r, d: s, e: o, f: i } = this, a = e * s - n * r;
    return this.a = s / a, this.b = n / -a, this.c = r / -a, this.d = e / a, this.e = (s * o - r * i) / -a, this.f = (n * o - e * i) / a, this;
  }
  applyToPoint(e) {
    return we.applyToPoint(this, e);
  }
  applyToPoints(e) {
    return we.applyToPoints(this, e);
  }
  rotation() {
    return we.Rotation(this);
  }
  point() {
    return we.Point(this);
  }
  decomposed() {
    return we.Decompose(this);
  }
  toCssString() {
    return we.toCssString(this);
  }
  setTo(e) {
    return Object.assign(this, e), this;
  }
  decompose() {
    return we.Decompose(this);
  }
  clone() {
    return new we(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  /* --------------------- Static --------------------- */
  static Identity() {
    return new we(1, 0, 0, 1, 0, 0);
  }
  static Translate(e, n) {
    return new we(1, 0, 0, 1, e, n);
  }
  static Rotate(e, n, r) {
    if (e === 0) return we.Identity();
    const s = Math.cos(e), o = Math.sin(e), i = new we(s, o, -o, s, 0, 0);
    return n === void 0 ? i : we.Compose(we.Translate(n, r), i, we.Translate(-n, -r));
  }
  static Scale(e, n, r, s) {
    const o = new we(e, 0, 0, n, 0, 0);
    return r === void 0 ? o : we.Translate(r, s).multiply(o).translate(-r, -s);
  }
  static Multiply(e, n) {
    return {
      a: e.a * n.a + e.c * n.b,
      c: e.a * n.c + e.c * n.d,
      e: e.a * n.e + e.c * n.f + e.e,
      b: e.b * n.a + e.d * n.b,
      d: e.b * n.c + e.d * n.d,
      f: e.b * n.e + e.d * n.f + e.f
    };
  }
  static Inverse(e) {
    const n = e.a * e.d - e.b * e.c;
    return {
      a: e.d / n,
      b: e.b / -n,
      c: e.c / -n,
      d: e.a / n,
      e: (e.d * e.e - e.c * e.f) / -n,
      f: (e.b * e.e - e.a * e.f) / n
    };
  }
  static Absolute(e) {
    const n = e.a * e.d - e.b * e.c;
    return {
      a: e.d / n,
      b: e.b / -n,
      c: e.c / -n,
      d: e.a / n,
      e: (e.d * e.e - e.c * e.f) / n,
      f: (e.b * e.e - e.a * e.f) / -n
    };
  }
  static Compose(...e) {
    const n = we.Identity();
    for (let r = 0, s = e.length; r < s; r++)
      n.multiply(e[r]);
    return n;
  }
  static Point(e) {
    return new I(e.e, e.f);
  }
  static Rotation(e) {
    let n;
    if (e.a !== 0 || e.c !== 0) {
      const r = (e.a * e.a + e.c * e.c) ** 0.5;
      n = Math.acos(e.a / r) * (e.c > 0 ? -1 : 1);
    } else if (e.b !== 0 || e.d !== 0) {
      const r = (e.b * e.b + e.d * e.d) ** 0.5;
      n = ar + Math.acos(e.b / r) * (e.d > 0 ? -1 : 1);
    } else
      n = 0;
    return oj(n);
  }
  static Decompose(e) {
    let n, r, s;
    if (e.a !== 0 || e.c !== 0) {
      const o = (e.a * e.a + e.c * e.c) ** 0.5;
      n = o, r = (e.a * e.d - e.b * e.c) / o, s = Math.acos(e.a / o) * (e.c > 0 ? -1 : 1);
    } else if (e.b !== 0 || e.d !== 0) {
      const o = (e.b * e.b + e.d * e.d) ** 0.5;
      n = (e.a * e.d - e.b * e.c) / o, r = o, s = ar + Math.acos(e.b / o) * (e.d > 0 ? -1 : 1);
    } else
      n = 0, r = 0, s = 0;
    return {
      x: e.e,
      y: e.f,
      scaleX: n,
      scaleY: r,
      rotation: oj(s)
    };
  }
  static Smooth(e, n = 1e10) {
    return e.a = Math.round(e.a * n) / n, e.b = Math.round(e.b * n) / n, e.c = Math.round(e.c * n) / n, e.d = Math.round(e.d * n) / n, e.e = Math.round(e.e * n) / n, e.f = Math.round(e.f * n) / n, e;
  }
  static toCssString(e) {
    return `matrix(${ne(e.a)}, ${ne(e.b)}, ${ne(
      e.c
    )}, ${ne(e.d)}, ${ne(e.e)}, ${ne(e.f)})`;
  }
  static applyToPoint(e, n) {
    return new I(
      e.a * n.x + e.c * n.y + e.e,
      e.b * n.x + e.d * n.y + e.f,
      n.z
    );
  }
  static applyToXY(e, n, r) {
    return [e.a * n + e.c * r + e.e, e.b * n + e.d * r + e.f];
  }
  static applyToPoints(e, n) {
    return n.map(
      (r) => new I(e.a * r.x + e.c * r.y + e.e, e.b * r.x + e.d * r.y + e.f, r.z)
    );
  }
  static applyToBounds(e, n) {
    return new _e(e.e + n.minX, e.f + n.minY, n.width, n.height);
  }
  static From(e) {
    return new we(e.a, e.b, e.c, e.d, e.e, e.f);
  }
  static Cast(e) {
    return e instanceof we ? e : we.From(e);
  }
}
function FI(t, e, n, r, s = 1e-10) {
  const o = t.x - n.x, i = t.y - n.y, a = r.x - n.x, c = r.y - n.y, l = e.x - t.x, d = e.y - t.y, u = a * i - c * o, f = l * i - d * o, p = c * l - a * d;
  if (Hr(u, 0, s) || Hr(f, 0, s) || Hr(p, 0, s)) return null;
  if (p !== 0) {
    const g = u / p, y = f / p;
    if (E1(0, g, s) && E1(g, 1, s) && E1(0, y, s) && E1(y, 1, s))
      return I.AddXY(t, g * l, g * d);
  }
  return null;
}
function Z0(t, e, n, r) {
  const s = (e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y), o = 2 * ((e.x - t.x) * (t.x - n.x) + (e.y - t.y) * (t.y - n.y)), i = n.x * n.x + n.y * n.y + t.x * t.x + t.y * t.y - 2 * (n.x * t.x + n.y * t.y) - r * r, a = o * o - 4 * s * i;
  if (a < 0 || a === 0) return null;
  const c = Math.sqrt(a), l = (-o + c) / (2 * s), d = (-o - c) / (2 * s);
  if ((l < 0 || l > 1) && (d < 0 || d > 1))
    return null;
  const u = [];
  return 0 <= l && l <= 1 && u.push(I.Lrp(t, e, l)), 0 <= d && d <= 1 && u.push(I.Lrp(t, e, d)), u.length === 0 ? null : u;
}
function bBe(t, e, n) {
  const r = [];
  let s;
  for (let o = 0, i = n.length - 1; o < i; o++)
    s = FI(t, e, n[o], n[o + 1]), s && r.push(s);
  return r.length === 0 ? null : r;
}
function Ine(t, e, n) {
  const r = [];
  let s;
  for (let o = 1, i = n.length; o < i + 1; o++)
    s = FI(
      t,
      e,
      n[o - 1],
      n[o % n.length]
    ), s && r.push(s);
  return r.length === 0 ? null : r;
}
function xBe(t, e, n, r) {
  let s = n.x - t.x, o = n.y - t.y;
  const i = Math.sqrt(s * s + o * o), a = (i * i - r * r + e * e) / (2 * i), c = Math.sqrt(e * e - a * a);
  return s /= i, o /= i, [
    new I(t.x + s * a - o * c, t.y + o * a + s * c),
    new I(t.x + s * a + o * c, t.y + o * a - s * c)
  ];
}
function wBe(t, e, n) {
  const r = [];
  let s, o, i;
  for (let a = 0, c = n.length; a < c; a++)
    s = n[a], o = n[(a + 1) % n.length], i = Z0(s, o, t, e), i && r.push(...i);
  return r.length === 0 ? null : r;
}
function SBe(t, e, n) {
  const r = [];
  let s, o, i;
  for (let a = 1, c = n.length; a < c; a++)
    s = n[a - 1], o = n[a], i = Z0(s, o, t, e), i && r.push(...i);
  return r.length === 0 ? null : r;
}
function P1(t, e, n) {
  return (n.y - t.y) * (e.x - t.x) > (e.y - t.y) * (n.x - t.x);
}
function b3(t, e, n, r) {
  return P1(t, n, r) !== P1(e, n, r) && P1(t, e, n) !== P1(t, e, r);
}
function BE(t, e) {
  const n = /* @__PURE__ */ new Map();
  let r, s, o, i;
  for (let a = 0, c = t.length; a < c; a++)
    if (r = t[a], li(r, e)) {
      const l = t_(r);
      n.has(l) || n.set(l, r);
    }
  for (let a = 0, c = e.length; a < c; a++)
    if (r = e[a], li(r, t)) {
      const l = t_(r);
      n.has(l) || n.set(l, r);
    }
  for (let a = 0, c = t.length; a < c; a++) {
    r = t[a], s = t[(a + 1) % t.length];
    for (let l = 0, d = e.length; l < d; l++) {
      o = e[l], i = e[(l + 1) % e.length];
      const u = FI(r, s, o, i);
      if (u !== null) {
        const f = t_(u);
        n.has(f) || n.set(f, u);
      }
    }
  }
  return n.size === 0 ? null : CBe([...n.values()]);
}
function nH(t, e, n, r) {
  const s = /* @__PURE__ */ new Map();
  for (let o = 0, i = n ? t.length : t.length - 1; o < i; o++) {
    const a = t[o], c = t[(o + 1) % t.length];
    for (let l = 0, d = r ? e.length : e.length - 1; l < d; l++) {
      const u = e[l], f = e[(l + 1) % e.length], p = FI(a, c, u, f);
      if (p !== null) {
        const g = t_(p);
        s.has(g) || s.set(g, p);
      }
    }
  }
  return [...s.values()];
}
function t_(t) {
  return `${t.x},${t.y}`;
}
function CBe(t) {
  const e = I.Average(t);
  return t.sort((n, r) => I.Angle(e, n) - I.Angle(e, r));
}
function kne(t, e) {
  let n, r, s, o;
  for (let i = 0, a = t.length; i < a; i++) {
    n = t[i], r = t[(i + 1) % a];
    for (let c = 0, l = e.length; c < l; c++)
      if (s = e[c], o = e[(c + 1) % l], b3(n, r, s, o)) return !0;
  }
  return !1;
}
function _Be(t, e) {
  let n, r, s, o;
  for (let i = 0, a = t.length; i < a; i++) {
    n = t[i], r = t[(i + 1) % a];
    for (let c = 1, l = e.length; c < l; c++)
      if (s = e[c - 1], o = e[c], b3(n, r, s, o)) return !0;
  }
  return !1;
}
const Ul = {
  EXCLUDE_NON_STANDARD: {
    includeLabels: !1,
    includeInternal: !1
  },
  INCLUDE_ALL: { includeLabels: !0, includeInternal: !0 },
  EXCLUDE_LABELS: { includeLabels: !1, includeInternal: !0 },
  EXCLUDE_INTERNAL: { includeLabels: !0, includeInternal: !1 }
};
class nh {
  constructor(e) {
    // todo: consider making accessors for these too, so that they can be overridden in subclasses by geometries with more complex logic
    P(this, "isFilled", !1);
    P(this, "isClosed", !0);
    P(this, "isLabel", !1);
    P(this, "isEmptyLabel", !1);
    P(this, "isInternal", !1);
    P(this, "debugColor");
    P(this, "ignore");
    P(this, "_vertices");
    P(this, "_bounds");
    P(this, "_area");
    P(this, "_length");
    const { isLabel: n = !1, isEmptyLabel: r = !1, isInternal: s = !1 } = e;
    this.isFilled = e.isFilled, this.isClosed = e.isClosed, this.debugColor = e.debugColor, this.ignore = e.ignore, this.isLabel = n, this.isEmptyLabel = r, this.isInternal = s;
  }
  isExcludedByFilter(e) {
    return e ? !!(this.isLabel && !e.includeLabels || this.isInternal && !e.includeInternal) : !1;
  }
  hitTestPoint(e, n = 0, r = !1, s) {
    return this.isClosed && (this.isFilled || r) && li(e, this.vertices) ? !0 : I.Dist2(e, this.nearestPoint(e)) <= n * n;
  }
  distanceToPoint(e, n = !1, r) {
    return I.Dist(e, this.nearestPoint(e, r)) * (this.isClosed && (this.isFilled || n) && li(e, this.vertices) ? -1 : 1);
  }
  distanceToLineSegment(e, n, r) {
    if (I.Equals(e, n)) return this.distanceToPoint(e, !1, r);
    const { vertices: s } = this;
    let o, i = 1 / 0, a, c, l;
    const d = this.isClosed ? s.length : s.length - 1;
    for (let u = 0; u < s.length; u++) {
      if (c = s[u], u < d) {
        const f = s[(u + 1) % s.length];
        if (b3(e, n, c, f)) return 0;
      }
      l = I.NearestPointOnLineSegment(e, n, c, !0), a = I.Dist2(c, l), a < i && (i = a, o = l);
    }
    if (!o) throw Error("nearest point not found");
    return this.isClosed && this.isFilled && li(o, this.vertices) ? -i : i;
  }
  hitTestLineSegment(e, n, r = 0, s) {
    return this.distanceToLineSegment(e, n, s) <= r;
  }
  intersectLineSegment(e, n, r) {
    return (this.isClosed ? Ine(e, n, this.vertices) : bBe(e, n, this.vertices)) ?? [];
  }
  intersectCircle(e, n, r) {
    return (this.isClosed ? wBe(e, n, this.vertices) : SBe(e, n, this.vertices)) ?? [];
  }
  intersectPolygon(e, n) {
    return nH(e, this.vertices, !0, this.isClosed);
  }
  intersectPolyline(e, n) {
    return nH(e, this.vertices, !1, this.isClosed);
  }
  /**
   * Find a point along the edge of the geometry that is a fraction `t` along the entire way round.
   */
  interpolateAlongEdge(e, n) {
    const { vertices: r } = this;
    if (e <= 0) return r[0];
    const s = e * this.length;
    let o = 0;
    for (let i = 0; i < (this.isClosed ? r.length : r.length - 1); i++) {
      const a = r[i], c = r[(i + 1) % r.length], l = I.Dist(a, c), d = o + l;
      if (d >= s)
        return I.Lrp(
          a,
          c,
          sw(o, d, s)
        );
      o = d;
    }
    return this.isClosed ? r[0] : r[r.length - 1];
  }
  /**
   * Take `point`, find the closest point to it on the edge of the geometry, and return how far
   * along the edge it is as a fraction of the total length.
   */
  uninterpolateAlongEdge(e, n) {
    const { vertices: r, length: s } = this;
    let o = null, i = 1 / 0, a = 0;
    for (let l = 0; l < (this.isClosed ? r.length : r.length - 1); l++) {
      const d = r[l], u = r[(l + 1) % r.length], f = I.NearestPointOnLineSegment(d, u, e, !0), p = I.Dist(f, e);
      p < i && (i = p, o = {
        start: d,
        end: u,
        nearestPoint: f,
        distanceToStart: a
      }), a += I.Dist(d, u);
    }
    return tt(o), (o.distanceToStart + I.Dist(o.start, o.nearestPoint)) / s;
  }
  /** @deprecated Iterate the vertices instead. */
  nearestPointOnLineSegment(e, n) {
    const { vertices: r } = this;
    let s, o = 1 / 0, i, a, c;
    for (let l = 0; l < r.length; l++)
      a = r[l], c = I.NearestPointOnLineSegment(e, n, a, !0), i = I.Dist2(a, c), i < o && (o = i, s = c);
    if (!s) throw Error("nearest point not found");
    return s;
  }
  isPointInBounds(e, n = 0) {
    const { bounds: r } = this;
    return !(e.x < r.minX - n || e.y < r.minY - n || e.x > r.maxX + n || e.y > r.maxY + n);
  }
  transform(e, n) {
    return new x3(this, e, n);
  }
  // eslint-disable-next-line no-restricted-syntax
  get vertices() {
    return this._vertices || (this._vertices = this.getVertices(Ul.EXCLUDE_LABELS)), this._vertices;
  }
  getBounds() {
    return _e.FromPoints(this.vertices);
  }
  // eslint-disable-next-line no-restricted-syntax
  get bounds() {
    return this._bounds || (this._bounds = this.getBounds()), this._bounds;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return this.bounds.center;
  }
  // eslint-disable-next-line no-restricted-syntax
  get area() {
    return this._area || (this._area = this.getArea()), this._area;
  }
  getArea() {
    if (!this.isClosed)
      return 0;
    const { vertices: e } = this;
    let n = 0;
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r], i = e[(r + 1) % s];
      n += o.x * i.y - i.x * o.y;
    }
    return n / 2;
  }
  toSimpleSvgPath() {
    let e = "";
    const { vertices: n } = this, r = n.length;
    if (r === 0) return e;
    e += `M${n[0].x},${n[0].y}`;
    for (let s = 1; s < r; s++)
      e += `L${n[s].x},${n[s].y}`;
    return this.isClosed && (e += "Z"), e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get length() {
    return this._length ? this._length : (this._length = this.getLength(Ul.EXCLUDE_LABELS), this._length);
  }
  getLength(e) {
    const n = this.getVertices(e ?? Ul.EXCLUDE_LABELS);
    if (n.length === 0) return 0;
    let r = n[0], s = 0;
    for (let o = 1; o < n.length; o++) {
      const i = n[o];
      s += I.Dist(r, i), r = i;
    }
    return this.isClosed && (s += I.Dist(n[n.length - 1], n[0])), s;
  }
}
class x3 extends nh {
  constructor(n, r, s) {
    super(n);
    P(this, "inverse");
    P(this, "decomposed");
    this.geometry = n, this.matrix = r, this.inverse = we.Inverse(r), this.decomposed = we.Decompose(r), s && (s.isLabel != null && (this.isLabel = s.isLabel), s.isInternal != null && (this.isInternal = s.isInternal), s.debugColor != null && (this.debugColor = s.debugColor), s.ignore != null && (this.ignore = s.ignore)), tt(
      Hr(this.decomposed.scaleX, this.decomposed.scaleY),
      "non-uniform scaling is not yet supported"
    );
  }
  getVertices(n) {
    return this.geometry.getVertices(n).map((r) => we.applyToPoint(this.matrix, r));
  }
  nearestPoint(n, r) {
    return we.applyToPoint(
      this.matrix,
      this.geometry.nearestPoint(we.applyToPoint(this.inverse, n), r)
    );
  }
  hitTestPoint(n, r = 0, s, o) {
    return this.geometry.hitTestPoint(
      we.applyToPoint(this.inverse, n),
      r / this.decomposed.scaleX,
      s,
      o
    );
  }
  distanceToPoint(n, r = !1, s) {
    return this.geometry.distanceToPoint(we.applyToPoint(this.inverse, n), r, s) * this.decomposed.scaleX;
  }
  distanceToLineSegment(n, r, s) {
    return this.geometry.distanceToLineSegment(
      we.applyToPoint(this.inverse, n),
      we.applyToPoint(this.inverse, r),
      s
    ) * this.decomposed.scaleX;
  }
  hitTestLineSegment(n, r, s = 0, o) {
    return this.geometry.hitTestLineSegment(
      we.applyToPoint(this.inverse, n),
      we.applyToPoint(this.inverse, r),
      s / this.decomposed.scaleX,
      o
    );
  }
  intersectLineSegment(n, r, s) {
    return we.applyToPoints(
      this.matrix,
      this.geometry.intersectLineSegment(
        we.applyToPoint(this.inverse, n),
        we.applyToPoint(this.inverse, r),
        s
      )
    );
  }
  intersectCircle(n, r, s) {
    return we.applyToPoints(
      this.matrix,
      this.geometry.intersectCircle(
        we.applyToPoint(this.inverse, n),
        r / this.decomposed.scaleX,
        s
      )
    );
  }
  intersectPolygon(n, r) {
    return we.applyToPoints(
      this.matrix,
      this.geometry.intersectPolygon(we.applyToPoints(this.inverse, n), r)
    );
  }
  intersectPolyline(n, r) {
    return we.applyToPoints(
      this.matrix,
      this.geometry.intersectPolyline(we.applyToPoints(this.inverse, n), r)
    );
  }
  transform(n, r) {
    return new x3(this.geometry, we.Multiply(n, this.matrix), {
      isLabel: (r == null ? void 0 : r.isLabel) ?? this.isLabel,
      isInternal: (r == null ? void 0 : r.isInternal) ?? this.isInternal,
      debugColor: (r == null ? void 0 : r.debugColor) ?? this.debugColor,
      ignore: (r == null ? void 0 : r.ignore) ?? this.ignore
    });
  }
  getSvgPathData() {
    throw new Error("Cannot get SVG path data for transformed geometry.");
  }
}
class ui extends nh {
  constructor(n) {
    super({ ...n, isClosed: !0, isFilled: !1 });
    P(this, "children", []);
    P(this, "ignoredChildren", []);
    const r = (s) => {
      for (const o of s)
        o instanceof ui ? r(o.children) : o.ignore ? this.ignoredChildren.push(o) : this.children.push(o);
    };
    if (r(n.children), this.children.length === 0) throw Error("Group2d must have at least one child");
  }
  getVertices(n) {
    return this.isExcludedByFilter(n) ? [] : this.children.filter((r) => !r.isExcludedByFilter(n)).flatMap((r) => r.getVertices(n));
  }
  nearestPoint(n, r) {
    let s = 1 / 0, o;
    const { children: i } = this;
    if (i.length === 0)
      throw Error("no children");
    let a, c;
    for (const l of i)
      l.isExcludedByFilter(r) || (a = l.nearestPoint(n, r), c = I.Dist2(a, n), c < s && (s = c, o = a));
    if (!o) throw Error("nearest point not found");
    return o;
  }
  distanceToPoint(n, r = !1, s) {
    let o = 1 / 0;
    for (const i of this.children) {
      if (i.isExcludedByFilter(s)) continue;
      const a = i.distanceToPoint(n, r, s);
      a < o && (o = a);
    }
    return o;
  }
  hitTestPoint(n, r, s, o = Ul.EXCLUDE_LABELS) {
    return !!this.children.filter((i) => !i.isExcludedByFilter(o)).find((i) => i.hitTestPoint(n, r, s));
  }
  hitTestLineSegment(n, r, s, o = Ul.EXCLUDE_LABELS) {
    return !!this.children.filter((i) => !i.isExcludedByFilter(o)).find((i) => i.hitTestLineSegment(n, r, s));
  }
  intersectLineSegment(n, r, s) {
    return this.children.flatMap((o) => o.isExcludedByFilter(s) ? Br : o.intersectLineSegment(n, r, s));
  }
  intersectCircle(n, r, s) {
    return this.children.flatMap((o) => o.isExcludedByFilter(s) ? Br : o.intersectCircle(n, r, s));
  }
  intersectPolygon(n, r) {
    return this.children.flatMap((s) => s.isExcludedByFilter(r) ? Br : s.intersectPolygon(n, r));
  }
  intersectPolyline(n, r) {
    return this.children.flatMap((s) => s.isExcludedByFilter(r) ? Br : s.intersectPolyline(n, r));
  }
  interpolateAlongEdge(n, r) {
    const s = this.getLength(r), o = n * s;
    let i = 0;
    for (const a of this.children) {
      if (a.isExcludedByFilter(r)) continue;
      const c = a.length, l = i + c;
      if (l >= o)
        return a.interpolateAlongEdge(
          sw(i, l, o),
          r
        );
      i = l;
    }
    return this.children[this.children.length - 1].interpolateAlongEdge(1, r);
  }
  uninterpolateAlongEdge(n, r) {
    const s = this.getLength(r);
    let o = null, i = 1 / 0, a = 0;
    for (const d of this.children) {
      if (d.isExcludedByFilter(r)) continue;
      const u = d.getLength(r), f = a + u, p = d.distanceToPoint(n, !1, r);
      p < i && (i = p, o = {
        startLength: a,
        endLength: f,
        child: d
      }), a = f;
    }
    tt(o);
    const c = o.child.uninterpolateAlongEdge(n, r);
    return kt(
      o.startLength,
      o.endLength,
      c
    ) / s;
  }
  transform(n) {
    return new ui({
      children: this.children.map((r) => r.transform(n)),
      isLabel: this.isLabel,
      debugColor: this.debugColor,
      ignore: this.ignore
    });
  }
  getArea() {
    return this.children[0].area;
  }
  toSimpleSvgPath() {
    let n = "";
    for (const s of this.children)
      n += s.toSimpleSvgPath();
    const r = _e.FromPoints(this.vertices).corners;
    for (let s = 0, o = r.length; s < o; s++) {
      const i = r[s], a = r[(s - 1 + o) % o], c = i.dist(a), l = r[(s + 1) % o], d = i.dist(l), u = i.clone().lrp(a, 4 / c), f = i, p = i.clone().lrp(l, 4 / d);
      n += `M${u.x},${u.y} L${f.x},${f.y} L${p.x},${p.y} `;
    }
    return n;
  }
  getLength(n) {
    let r = 0;
    for (const s of this.children)
      s.isExcludedByFilter(n) || (r += s.length);
    return r;
  }
  getSvgPathData() {
    return this.children.map((n, r) => n.isLabel ? "" : n.getSvgPathData(r === 0)).join(" ");
  }
}
class ly extends nh {
  constructor(n) {
    super({ ...n, isClosed: !1, isFilled: !1 });
    P(this, "_start");
    P(this, "_end");
    P(this, "_d");
    P(this, "_u");
    P(this, "_ul");
    const { start: r, end: s } = n;
    this._start = r, this._end = s, this._d = r.clone().sub(s), this._u = this._d.clone().uni(), this._ul = this._u.len();
  }
  getLength() {
    return this._d.len();
  }
  getVertices() {
    return [this._start, this._end];
  }
  nearestPoint(n) {
    const { _start: r, _end: s, _d: o, _u: i, _ul: a } = this;
    if (o.len() === 0 || a === 0) return r;
    const c = I.Sub(n, r).dpr(i) / a, l = r.x + i.x * c;
    if (l < Math.min(r.x, s.x)) return r.x < s.x ? r : s;
    if (l > Math.max(r.x, s.x)) return r.x > s.x ? r : s;
    const d = r.y + i.y * c;
    return d < Math.min(r.y, s.y) ? r.y < s.y ? r : s : d > Math.max(r.y, s.y) ? r.y > s.y ? r : s : new I(l, d);
  }
  getSvgPathData(n = !0) {
    const { _start: r, _end: s } = this;
    return `${n ? `M${r.toFixed()}` : ""} L${s.toFixed()}`;
  }
}
class Q0 extends nh {
  constructor(n) {
    super({ isClosed: !1, isFilled: !1, ...n });
    P(this, "_points");
    P(this, "_segments");
    const { points: r } = n;
    if (this._points = r, r.length < 2)
      throw new Error("Polyline2d: points must be an array of at least 2 points");
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { vertices: n } = this;
      for (let r = 0, s = n.length - 1; r < s; r++) {
        const o = n[r], i = n[r + 1];
        this._segments.push(new ly({ start: o, end: i }));
      }
      this.isClosed && this._segments.push(new ly({ start: n[n.length - 1], end: n[0] }));
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((n, r) => n + r.length, 0);
  }
  getVertices() {
    return this._points;
  }
  nearestPoint(n) {
    const { segments: r } = this;
    let s = this._points[0], o = 1 / 0, i, a;
    for (let c = 0; c < r.length; c++)
      i = r[c].nearestPoint(n), a = I.Dist2(i, n), a < o && (s = i, o = a);
    if (!s) throw Error("nearest point not found");
    return s;
  }
  hitTestLineSegment(n, r, s = 0) {
    const { segments: o } = this;
    for (let i = 0, a = o.length; i < a; i++)
      if (o[i].hitTestLineSegment(n, r, s))
        return !0;
    return !1;
  }
  getSvgPathData() {
    const { vertices: n } = this;
    return n.length < 2 ? "" : n.reduce((r, s, o) => o === 0 ? `M ${s.x} ${s.y}` : `${r} L ${s.x} ${s.y}`, "");
  }
}
class uw extends Q0 {
  constructor(e) {
    if (super({ ...e }), this.isClosed = !0, e.points.length < 3)
      throw new Error("Polygon2d: points must be an array of at least 3 points");
  }
}
class ol extends uw {
  constructor(n) {
    const { x: r = 0, y: s = 0, width: o, height: i } = n;
    super({
      ...n,
      points: [
        new I(r, s),
        new I(r + o, s),
        new I(r + o, s + i),
        new I(r, s + i)
      ]
    });
    P(this, "_x");
    P(this, "_y");
    P(this, "_w");
    P(this, "_h");
    this._x = r, this._y = s, this._w = o, this._h = i;
  }
  getBounds() {
    return new _e(this._x, this._y, this._w, this._h);
  }
  getSvgPathData() {
    const { _x: n, _y: r, _w: s, _h: o } = this;
    return this.negativeZeroFix(), `M${n},${r} h${s} v${o} h${-s}z`;
  }
  negativeZeroFix() {
    this._x = I1(this._x), this._y = I1(this._y), this._w = I1(this._w), this._h = I1(this._h);
  }
}
function I1(t) {
  return Object.is(t, -0) ? 0 : t;
}
class sc {
  constructor(e) {
    /**
     * Options for this shape util. If you're implementing a custom shape util, you can override
     * this to provide customization options for your shape. If using an existing shape util, you
     * can customizing this by calling {@link ShapeUtil.configure}.
     */
    P(this, "options", {});
    this.editor = e;
  }
  /** Configure this shape utils {@link ShapeUtil.options | `options`}. */
  static configure(e) {
    return class extends this {
      constructor() {
        super(...arguments);
        // @ts-expect-error
        P(this, "options", { ...this.options, ...e });
      }
    };
  }
  /**
   * Get the font faces that should be rendered in the document in order for this shape to render
   * correctly.
   *
   * @param shape - The shape.
   * @public
   */
  getFontFaces(e) {
    return Br;
  }
  /**
   * Whether the shape can be snapped to by another shape.
   *
   * @param shape - The shape.
   * @public
   */
  canSnap(e) {
    return !0;
  }
  /**
   * Whether the shape can be tabbed to.
   *
   * @param shape - The shape.
   * @public
   */
  canTabTo(e) {
    return !0;
  }
  /**
   * Whether the shape can be scrolled while editing.
   *
   * @public
   */
  canScroll(e) {
    return !1;
  }
  /**
   * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
   *
   * @public
   */
  canBind(e) {
    return !0;
  }
  /**
   * Whether the shape can be double clicked to edit.
   *
   * @public
   */
  canEdit(e) {
    return !1;
  }
  /**
   * Whether the shape can be resized.
   *
   * @public
   */
  canResize(e) {
    return !0;
  }
  /**
   * When the shape is resized, whether the shape's children should also be resized.
   *
   * @public
   */
  canResizeChildren(e) {
    return !0;
  }
  /**
   * Whether the shape can be edited in read-only mode.
   *
   * @public
   */
  canEditInReadonly(e) {
    return !1;
  }
  /**
   * Whether the shape can be cropped.
   *
   * @public
   */
  canCrop(e) {
    return !1;
  }
  /**
   * Whether the shape can participate in layout functions such as alignment or distribution.
   *
   * @param shape - The shape.
   * @param info - Additional context information: the type of action causing the layout and the
   * @public
   *
   * @public
   */
  canBeLaidOut(e, n) {
    return !0;
  }
  /**
   * Does this shape provide a background for its children? If this is true,
   * then any children with a `renderBackground` method will have their
   * backgrounds rendered _above_ this shape. Otherwise, the children's
   * backgrounds will be rendered above either the next ancestor that provides
   * a background, or the canvas background.
   *
   * @internal
   */
  providesBackgroundForChildren(e) {
    return !1;
  }
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideResizeHandles(e) {
    return !1;
  }
  /**
   * Whether the shape should hide its rotation handles when selected.
   *
   * @public
   */
  hideRotateHandle(e) {
    return !1;
  }
  /**
   * Whether the shape should hide its selection bounds background when selected.
   *
   * @public
   */
  hideSelectionBoundsBg(e) {
    return !1;
  }
  /**
   * Whether the shape should hide its selection bounds foreground when selected.
   *
   * @public
   */
  hideSelectionBoundsFg(e) {
    return !1;
  }
  /**
   * Whether the shape's aspect ratio is locked.
   *
   * @public
   */
  isAspectRatioLocked(e) {
    return !1;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape.
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(e, n) {
    return !1;
  }
  /** @internal */
  expandSelectionOutlinePx(e) {
    return 0;
  }
  /**
   * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
   * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
   * elements returned by `component`.
   *
   * Each def should have a unique `key`. If multiple defs from different shapes all have the same
   * key, only one will be used.
   */
  getCanvasSvgDefs() {
    return [];
  }
  /**
   * Get the geometry to use when snapping to this this shape in translate/resize operations. See
   * {@link BoundsSnapGeometry} for details.
   */
  getBoundsSnapGeometry(e) {
    return {};
  }
  /**
   * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
   * for details.
   */
  getHandleSnapGeometry(e) {
    return {};
  }
  getText(e) {
  }
  getAriaDescriptor(e) {
  }
}
/**
 * Props allow you to define the shape's properties in a way that the editor can understand.
 * This has two main uses:
 *
 * 1. Validation. Shapes will be validated using these props to stop bad data from being saved.
 * 2. Styles. Each {@link @tldraw/tlschema#StyleProp} in the props can be set on many shapes at
 *    once, and will be remembered from one shape to the next.
 *
 * @example
 * ```tsx
 * import {T, TLBaseShape, TLDefaultColorStyle, DefaultColorStyle, ShapeUtil} from 'tldraw'
 *
 * type MyShape = TLBaseShape<'mine', {
 *      color: TLDefaultColorStyle,
 *      text: string,
 * }>
 *
 * class MyShapeUtil extends ShapeUtil<MyShape> {
 *     static props = {
 *         // we use tldraw's built-in color style:
 *         color: DefaultColorStyle,
 *         // validate that the text prop is a string:
 *         text: T.string,
 *     }
 * }
 * ```
 */
P(sc, "props"), /**
 * Migrations allow you to make changes to a shape's props over time. Read the
 * {@link https://www.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
 * guide for more information.
 */
P(sc, "migrations"), /**
 * The type of the shape util, which should match the shape's type.
 *
 * @public
 */
P(sc, "type");
function Ane(t, e, n = {}) {
  const {
    closed: r = !1,
    snap: s = 1,
    start: o = "outset",
    end: i = "outset",
    lengthRatio: a = 2,
    style: c = "dashed",
    forceSolid: l = !1
  } = n;
  let d = 0, u = 0, f = 1, p = 0, g = 0;
  if (l)
    return {
      strokeDasharray: "none",
      strokeDashoffset: "none"
    };
  switch (c) {
    case "dashed": {
      f = 1, d = Math.min(e * a, t / 4);
      break;
    }
    case "dotted": {
      f = 100, d = e / f;
      break;
    }
    default:
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
  }
  return r || (o === "outset" ? (t += d / 2, g += d / 2) : o === "skip" && (t -= d, g -= d), i === "outset" ? t += d / 2 : i === "skip" && (t -= d)), u = Math.floor(t / d / (2 * f)), u -= u % s, u < 3 && c === "dashed" ? t / e < 4 ? (d = t, u = 1, p = 0) : (d = t * (1 / 3), p = t * (1 / 3)) : (d = t / u / (2 * f), r ? (g = d / 2, p = (t - u * d) / u) : p = (t - u * d) / Math.max(1, u - 1)), {
    strokeDasharray: [d, p].join(" "),
    strokeDashoffset: g.toString()
  };
}
function rH({ bounds: t, className: e }) {
  const n = ie(), r = le("zoom level", () => n.getZoomLevel(), [n]);
  return /* @__PURE__ */ h.jsx("g", { className: e, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: t.sides.map((s, o) => {
    const { strokeDasharray: i, strokeDashoffset: a } = Ane(
      s[0].dist(s[1]),
      1 / r,
      {
        style: "dashed",
        lengthRatio: 4
      }
    );
    return /* @__PURE__ */ h.jsx(
      "line",
      {
        x1: s[0].x,
        y1: s[0].y,
        x2: s[1].x,
        y2: s[1].y,
        strokeDasharray: i,
        strokeDashoffset: a
      },
      o
    );
  }) });
}
class n_ extends sc {
  hideSelectionBoundsFg() {
    return !0;
  }
  canBind() {
    return !1;
  }
  canResize() {
    return !0;
  }
  canResizeChildren() {
    return !0;
  }
  getDefaultProps() {
    return {};
  }
  getGeometry(e) {
    const n = this.editor.getSortedChildIdsForParent(e.id);
    return n.length === 0 ? new ol({ width: 1, height: 1, isFilled: !1 }) : new ui({
      children: n.map((r) => {
        const s = this.editor.getShape(r);
        return this.editor.getShapeGeometry(r).transform(this.editor.getShapeLocalTransform(s), { isLabel: !1 });
      })
    });
  }
  component(e) {
    const n = this.editor.getErasingShapeIds().includes(e.id), { hintingShapeIds: r } = this.editor.getCurrentPageState(), s = r.length > 0 && r.some(
      (a) => a !== e.id && this.editor.isShapeOfType(this.editor.getShape(a), "group")
    ), o = this.editor.getCurrentPageState().focusedGroupId !== e.id;
    if (!n && // always show the outline while we're erasing the group
    // show the outline while the group is focused unless something outside of the group is being hinted
    // this happens dropping shapes from a group onto some outside group
    (o || s))
      return null;
    const i = this.editor.getShapeGeometry(e).bounds;
    return /* @__PURE__ */ h.jsx(jf, { children: /* @__PURE__ */ h.jsx(rH, { className: "tl-group", bounds: i }) });
  }
  indicator(e) {
    const n = this.editor.getShapeGeometry(e).bounds;
    return /* @__PURE__ */ h.jsx(rH, { className: "", bounds: n });
  }
  onChildrenChange(e) {
    const n = this.editor.getSortedChildIdsForParent(e.id);
    if (n.length === 0) {
      this.editor.getCurrentPageState().focusedGroupId === e.id && this.editor.popFocusedGroupId(), this.editor.deleteShapes([e.id]);
      return;
    } else if (n.length === 1) {
      this.editor.getCurrentPageState().focusedGroupId === e.id && this.editor.popFocusedGroupId(), this.editor.reparentShapes(n, e.parentId), this.editor.deleteShapes([e.id]);
      return;
    }
  }
}
P(n_, "type", "group"), P(n_, "props", zte), P(n_, "migrations", Ute);
const Mne = [
  // created by grouping interactions, probably the corest core shape that we have
  n_
], EBe = new Set(Mne.map((t) => t.type));
function One(t) {
  const e = [...Mne], n = /* @__PURE__ */ new Set();
  for (const r of t) {
    if (EBe.has(r.type))
      throw new Error(
        `Shape type "${r.type}" is a core shapes type and cannot be overridden`
      );
    if (n.has(r.type))
      throw new Error(`Shape type "${r.type}" is defined more than once`);
    e.push(r), n.add(r.type);
  }
  return e;
}
var cj, k1 = By;
if (process.env.NODE_ENV === "production")
  cj = k1.createRoot, k1.hydrateRoot;
else {
  var sH = k1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  cj = function(t, e) {
    sH.usingClientEntryPoint = !0;
    try {
      return k1.createRoot(t, e);
    } finally {
      sH.usingClientEntryPoint = !1;
    }
  };
}
function Dne(t, e) {
  const n = /* @__PURE__ */ new Map();
  return async function(s) {
    const o = n.get(s);
    if (o) return o;
    const i = (async () => {
      try {
        const a = await qc(s, e);
        return tt(a.ok), await t(a);
      } catch (a) {
        return console.error(a), null;
      }
    })();
    return n.set(s, i), i;
  };
}
const BI = Dne(async (t) => await oi.blobToDataUrl(await t.blob())), TBe = /@import\s+(?:"([^"]+)"|'([^']+)'|url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\))([^;]+);/gi, PBe = /@font-face\s*{([^}]+)}/gi, Nne = /url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\)/gi, IBe = /(?:^|;)\s*font-family\s*:\s*(?:([^'"][^;\n]+)|"([^"]+)"|'([^']+)')\s*(?:;|$)/gi;
function kBe(t) {
  return Array.from(t.matchAll(TBe), (e) => ({
    url: e[1] || e[2] || e[3] || e[4] || e[5],
    extras: e[6]
  }));
}
function jne(t, e) {
  return Array.from(t.matchAll(PBe), (n) => {
    const r = n[1], s = Array.from(r.matchAll(Nne), (i) => {
      var c;
      const a = i[1] || i[2] || i[3];
      return {
        original: a,
        resolved: ((c = bt(a, e)) == null ? void 0 : c.href) ?? null
      };
    }), o = new Set(
      Array.from(r.matchAll(IBe), (i) => (i[1] || i[2] || i[3]).toLowerCase())
    );
    return { fontFace: r, urls: s, fontFamilies: o };
  });
}
function ABe(t) {
  const e = /\s*(?:([^'"][^;\n\s,]+)|"([^"]+)"|'([^']+)')\s*/gi, n = /\s*,\s*/gi, r = /* @__PURE__ */ new Set();
  for (; ; ) {
    const s = e.exec(t);
    if (!s)
      break;
    const o = s[1] || s[2] || s[3];
    if (r.add(o.toLowerCase()), n.lastIndex = e.lastIndex, !n.exec(t))
      break;
    e.lastIndex = n.lastIndex;
  }
  return r;
}
function Rne(t) {
  return !(t.startsWith("-") || t.startsWith("animation") || t.startsWith("transition") || t === "cursor" || t === "pointer-events" || t === "user-select" || t === "touch-action");
}
function MBe(t, e) {
  return {
    imports: kBe(t),
    fontFaces: jne(t, e)
  };
}
function OBe(t) {
  return Array.from(t.matchAll(Nne), (e) => ({
    original: e[0],
    url: e[1] || e[2] || e[3]
  }));
}
var DBe = Object.create, $ne = Object.defineProperty, NBe = Object.getOwnPropertyDescriptor, jBe = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), Lne = (t) => {
  throw TypeError(t);
}, Fne = (t, e, n) => e in t ? $ne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, RBe = (t) => [, , , DBe(null)], Bne = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], zne = (t) => t !== void 0 && typeof t != "function" ? Lne("Function expected") : t, $Be = (t, e, n, r, s) => ({ kind: Bne[t], name: e, metadata: r, addInitializer: (o) => n._ ? Lne("Already initialized") : s.push(zne(o || null)) }), LBe = (t, e) => Fne(e, jBe("metadata"), t[3]), FBe = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, BBe = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = Bne[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, NBe(s, n)), v = r.length - 1; v >= 0; v--)
    c = $Be(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, zne(i) && (m[g] = i);
  return m && $ne(s, n, m), s;
}, A1 = (t, e, n) => Fne(t, typeof e != "symbol" ? e + "" : e, n), Une, zI;
const Hne = "tldraw-svg-export";
Une = [Li];
class w3 {
  constructor() {
    FBe(zI, 5, this), A1(this, "fontFacesPromise", null), A1(this, "foundFontNames", /* @__PURE__ */ new Set()), A1(this, "fontFacesToEmbed", /* @__PURE__ */ new Set()), A1(this, "pendingPromises", []);
  }
  startFindingCurrentDocumentFontFaces() {
    tt(!this.fontFacesPromise, "FontEmbedder already started"), this.fontFacesPromise = zBe();
  }
  onFontFamilyValue(e) {
    tt(this.fontFacesPromise, "FontEmbedder not started");
    const n = ABe(e);
    for (const r of n) {
      if (this.foundFontNames.has(r)) return;
      this.foundFontNames.add(r), this.pendingPromises.push(
        this.fontFacesPromise.then((s) => {
          const o = s.filter((i) => i.fontFamilies.has(r));
          for (const i of o)
            if (!this.fontFacesToEmbed.has(i)) {
              this.fontFacesToEmbed.add(i);
              for (const a of i.urls)
                !a.resolved || a.embedded || (a.embedded = BI(a.resolved));
            }
        })
      );
    }
  }
  async createCss() {
    await Promise.all(this.pendingPromises);
    let e = "";
    for (const n of this.fontFacesToEmbed) {
      let r = `@font-face {${n.fontFace}}`;
      for (const s of n.urls) {
        if (!s.embedded) continue;
        const o = await s.embedded;
        o && (r = r.replace(s.original, o));
      }
      e += r;
    }
    return e;
  }
}
zI = RBe();
BBe(zI, 1, "onFontFamilyValue", Une, w3);
LBe(zI, w3);
async function zBe() {
  var n;
  const t = [], e = Array.from(document.styleSheets).filter(
    (r) => {
      var s;
      return !((s = r.ownerNode) != null && s.closest(`.${Hne}`));
    }
  );
  for (const r of e) {
    let s;
    try {
      s = r.cssRules;
    } catch {
    }
    if (s) {
      for (const o of r.cssRules)
        if (o instanceof CSSFontFaceRule)
          t.push(jne(o.cssText, r.href ?? document.baseURI));
        else if (o instanceof CSSImportRule) {
          const i = new URL(o.href, ((n = o.parentStyleSheet) == null ? void 0 : n.href) ?? document.baseURI);
          t.push(lj(i.href));
        }
    } else r.href && t.push(lj(r.href));
  }
  return mt(await Promise.all(t)).flat();
}
const lj = Dne(async (t) => {
  const e = MBe(await t.text(), t.url), n = await Promise.all(
    e.imports.map(({ url: r }) => lj(new URL(r, t.url).href))
  );
  return [...e.fontFaces, ...mt(n).flat()];
}), na = (t, e, { currentColor: n }) => t === "currentColor" || t === n, Vt = (t, e, { parentStyles: n }) => n[e] === t, hr = (t) => (e, n, { getStyle: r }) => {
  const s = r(`border-${t}-width`), o = r(`border-${t}-style`);
  return s === "0px" || o === "none";
}, Vne = {
  // currentColor properties:
  "border-block-end-color": na,
  "border-block-start-color": na,
  "border-bottom-color": na,
  "border-inline-end-color": na,
  "border-inline-start-color": na,
  "border-left-color": na,
  "border-right-color": na,
  "border-top-color": na,
  "caret-color": na,
  "column-rule-color": na,
  "outline-color": na,
  "text-decoration": (t, e, { currentColor: n }) => t === "none solid currentColor" || t === "none solid " + n,
  "text-decoration-color": na,
  "text-emphasis-color": na,
  // inherited properties:
  "border-collapse": Vt,
  "border-spacing": Vt,
  "caption-side": Vt,
  // N.B. We shouldn't inherit 'color' because there's some UA styling, e.g. `mark` elements
  // 'color': isInherited,
  cursor: Vt,
  direction: Vt,
  "empty-cells": Vt,
  "font-family": Vt,
  "font-size": Vt,
  "font-style": Vt,
  "font-variant": Vt,
  "font-weight": Vt,
  "font-size-adjust": Vt,
  "font-stretch": Vt,
  font: Vt,
  "letter-spacing": Vt,
  "line-height": Vt,
  "list-style-image": Vt,
  "list-style-position": Vt,
  "list-style-type": Vt,
  "list-style": Vt,
  orphans: Vt,
  "overflow-wrap": Vt,
  quotes: Vt,
  "stroke-linecap": Vt,
  "stroke-linejoin": Vt,
  "tab-size": Vt,
  "text-align": Vt,
  "text-align-last": Vt,
  "text-indent": Vt,
  "text-justify": Vt,
  "text-shadow": Vt,
  "text-transform": Vt,
  visibility: Vt,
  "white-space": Vt,
  "white-space-collapse": Vt,
  widows: Vt,
  "word-break": Vt,
  "word-spacing": Vt,
  "word-wrap": Vt,
  // special border cases - we have a weird case (tailwind seems to trigger this) where all
  // border-styles sometimes get set to 'solid', but the border-width is 0 so they don't render.
  // but in SVGs, **sometimes**, the border-width defaults (i think from a UA style-sheet? but
  // honestly can't tell) to 1.5px so the border displays. we work around this by only including
  // border styles at all if both the border-width and border-style are set to something that
  // would show a border.
  "border-top": hr("top"),
  "border-right": hr("right"),
  "border-bottom": hr("bottom"),
  "border-left": hr("left"),
  "border-block-end": hr("block-end"),
  "border-block-start": hr("block-start"),
  "border-inline-end": hr("inline-end"),
  "border-inline-start": hr("inline-start"),
  "border-top-style": hr("top"),
  "border-right-style": hr("right"),
  "border-bottom-style": hr("bottom"),
  "border-left-style": hr("left"),
  "border-block-end-style": hr("block-end"),
  "border-block-start-style": hr("block-start"),
  "border-inline-end-style": hr("inline-end"),
  "border-inline-start-style": hr("inline-start"),
  "border-top-width": hr("top"),
  "border-right-width": hr("right"),
  "border-bottom-width": hr("bottom"),
  "border-left-width": hr("left"),
  "border-block-end-width": hr("block-end"),
  "border-block-start-width": hr("block-start"),
  "border-inline-end-width": hr("inline-end")
};
function Wne(t) {
  if (t.shadowRoot)
    return t.shadowRoot.childNodes;
  if (WBe(t)) {
    const e = t.assignedNodes();
    if (e != null && e.length)
      return e;
  }
  return t.childNodes;
}
function* dj(t) {
  for (const e of Wne(t))
    UBe(e) && (yield e);
}
function UI(t) {
  var e;
  return ((e = t.ownerDocument) == null ? void 0 : e.defaultView) ?? globalThis;
}
function UBe(t) {
  return t instanceof UI(t).Element;
}
function HBe(t) {
  return t instanceof UI(t).ShadowRoot;
}
function VBe(t) {
  return "getRootNode" in t && HBe(t.getRootNode());
}
function WBe(t) {
  return VBe(t) && t instanceof UI(t).HTMLSlotElement;
}
function KBe(t) {
  return t.style;
}
function S3(t, e) {
  return UI(t).getComputedStyle(t, e);
}
const dy = {};
class GBe {
  constructor(e) {
    P(this, "styles", /* @__PURE__ */ new Map());
    P(this, "fonts", new w3());
    this.root = e;
  }
  readRootElementStyles(e) {
    this.readElementStyles(e, {
      shouldRespectDefaults: !1,
      shouldSkipInheritedParentStyles: !1
    });
    const n = Array.from(dj(e));
    for (; n.length; ) {
      const r = n.pop();
      n.push(...dj(r)), this.readElementStyles(r, {
        shouldRespectDefaults: !0,
        shouldSkipInheritedParentStyles: !0
      });
    }
  }
  readElementStyles(e, { shouldRespectDefaults: n = !0, shouldSkipInheritedParentStyles: r = !0 }) {
    var a;
    const s = n ? ZBe(e.tagName.toLowerCase()) : dy, o = Object.assign({}, dy);
    if (r) {
      let c = e.parentElement;
      for (; c; ) {
        const l = (a = this.styles.get(c)) == null ? void 0 : a.self;
        for (const d in l)
          o[d] || (o[d] = l[d]);
        c = c.parentElement;
      }
    }
    const i = {
      self: YBe(e, { defaultStyles: s, parentStyles: o }),
      before: oH(e, "::before"),
      after: oH(e, "::after")
    };
    this.styles.set(e, i);
  }
  fetchResources() {
    const e = [];
    for (const n of this.styles.values())
      for (const r of Er(n))
        if (r)
          for (const [s, o] of Object.entries(r)) {
            if (!o) continue;
            s === "font-family" && this.fonts.onFontFamilyValue(o);
            const i = OBe(o);
            i.length !== 0 && e.push(
              ...i.map(async ({ url: a, original: c }) => {
                const l = await BI(a) ?? "data:";
                r[s] = o.replace(c, `url("${l}")`);
              })
            );
          }
    return Promise.all(e);
  }
  // custom elements are tricky. if we serialize the dom as-is, the custom elements wont have
  // their shadow-dom contents serialized. after we've read all the styles, we need to unwrap the
  // contents of each custom elements shadow dom directly into the parent element itself.
  unwrapCustomElements() {
    const e = /* @__PURE__ */ new Set(), n = (r, s) => {
      if (e.has(r)) return;
      e.add(r);
      const o = r.shadowRoot;
      if (o) {
        const i = document.createElement("div");
        this.styles.set(i, this.styles.get(r)), i.setAttribute("data-tl-custom-element", r.tagName), (s ?? r.parentElement).appendChild(i);
        for (const a of o.childNodes)
          a instanceof Element ? n(a, i) : i.appendChild(a.cloneNode(!0));
        r.remove();
      } else if (s) {
        if (r.tagName.toLowerCase() === "style")
          return;
        const i = r.cloneNode(!1);
        this.styles.set(i, this.styles.get(r)), s.appendChild(i);
        for (const a of Wne(r))
          a instanceof Element ? n(a, i) : i.appendChild(a.cloneNode(!0));
      }
    };
    for (const r of this.styles.keys())
      n(r, null);
  }
  embedStyles() {
    let e = "";
    for (const [n, r] of this.styles) {
      if (r.after || r.before) {
        const o = `pseudo-${bn()}`;
        n.classList.add(o), r.before && (e += `.${o}::before {${iH(r.before)}}
`), r.after && (e += `.${o}::after {${iH(r.after)}}
`);
      }
      const s = KBe(n);
      for (const [o, i] of Object.entries(r.self))
        i && s.setProperty(o, i);
      s.fontKerning === "auto" && (s.fontKerning = "normal");
    }
    return e;
  }
  async getFontFaceCss() {
    return await this.fonts.createCss();
  }
  dispose() {
    XBe();
  }
}
function YBe(t, { defaultStyles: e, parentStyles: n }) {
  return t.computedStyleMap ? Kne(t.computedStyleMap(), { defaultStyles: e, parentStyles: n }) : C3(S3(t), { defaultStyles: e, parentStyles: n });
}
function oH(t, e) {
  const n = S3(t, e), r = n.getPropertyValue("content");
  if (!(r === "" || r === "none"))
    return C3(n, { defaultStyles: dy, parentStyles: dy });
}
function Kne(t, { defaultStyles: e, parentStyles: n }) {
  var i;
  const r = {}, o = {
    currentColor: ((i = t.get("color")) == null ? void 0 : i.toString()) || "",
    parentStyles: n,
    defaultStyles: e,
    getStyle: (a) => {
      var c;
      return ((c = t.get(a)) == null ? void 0 : c.toString()) ?? "";
    }
  };
  for (const a of t.keys()) {
    if (!Rne(a)) continue;
    const c = t.get(a).toString();
    if (e[a] === c) continue;
    const l = Fr(Vne, a);
    l && l(c, a, o) || (r[a] = c);
  }
  return r;
}
function C3(t, { defaultStyles: e, parentStyles: n }) {
  const r = {}, o = {
    currentColor: t.color,
    parentStyles: n,
    defaultStyles: e,
    getStyle: (i) => t.getPropertyValue(i)
  };
  for (const i in t) {
    if (!Rne(i)) continue;
    const a = t.getPropertyValue(i);
    if (e[i] === a) continue;
    const c = Fr(Vne, i);
    c && c(a, i, o) || (r[i] = a);
  }
  return r;
}
function iH(t) {
  let e = "";
  for (const [n, r] of Object.entries(t))
    e += `${n}: ${r};`;
  return e;
}
let Im;
const aH = {};
function qBe() {
  if (!Im) {
    const t = document.createElement("iframe");
    t.style.display = "none", document.body.appendChild(t);
    const e = Io(t.contentDocument, "frame must have a document"), n = document.createElementNS("http://www.w3.org/2000/svg", "svg"), r = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
    n.appendChild(r), e.body.appendChild(n), Im = { iframe: t, foreignObject: r, document: e };
  }
  return Im;
}
function XBe() {
  Im && (document.body.removeChild(Im.iframe), Im = void 0);
}
const cH = { defaultStyles: dy, parentStyles: dy };
function ZBe(t) {
  let e = aH[t];
  if (!e) {
    const { foreignObject: n, document: r } = qBe(), s = r.createElement(t);
    n.appendChild(s), e = s.computedStyleMap ? Kne(s.computedStyleMap(), cH) : C3(S3(s), cH), n.removeChild(s), aH[t] = e;
  }
  return e;
}
function QBe(t, e) {
  Array.from(t.attributes).forEach((r) => {
    e.setAttribute(r.name, r.value);
  });
}
function lH(t, e) {
  return t.replaceWith(e), e;
}
async function bx(t, e) {
  const n = document.createElement("img");
  e && QBe(e, n), n.setAttribute("src", t ?? "data:"), n.setAttribute("decoding", "sync"), n.setAttribute("loading", "eager");
  try {
    await n.decode();
  } catch {
  }
  return n;
}
async function JBe(t) {
  try {
    const e = t.toDataURL();
    return await bx(e, t);
  } catch {
    return await bx(null, t);
  }
}
async function eze(t) {
  try {
    const e = await ca.getVideoFrameAsDataUrl(t);
    return bx(e, t);
  } catch (e) {
    console.error("Could not get video frame", e);
  }
  if (t.poster) {
    const e = await BI(t.poster);
    return bx(e, t);
  }
  return bx(null, t);
}
async function Gne(t) {
  if (t instanceof HTMLCanvasElement)
    return lH(t, await JBe(t));
  if (t instanceof HTMLVideoElement)
    return lH(t, await eze(t));
  if (t instanceof HTMLImageElement) {
    const e = t.currentSrc || t.src, n = await BI(e);
    t.setAttribute("src", n ?? "data:"), t.setAttribute("decoding", "sync"), t.setAttribute("loading", "eager");
    try {
      await t.decode();
    } catch {
    }
    return t;
  } else t instanceof HTMLInputElement ? t.setAttribute("value", t.value) : t instanceof HTMLTextAreaElement && (t.textContent = t.value);
  await Promise.all(
    Array.from(dj(t), (e) => Gne(e))
  );
}
const uj = (t, e) => t.props === e.props && t.meta === e.meta, Yne = it(function({
  id: e,
  shape: n,
  util: r,
  index: s,
  backgroundIndex: o,
  opacity: i,
  dprMultiple: a
}) {
  const c = ie(), { ShapeErrorFallback: l } = Ln(), d = fe(null), u = fe(null);
  me(() => ya("load fonts", () => {
    const y = c.fonts.getShapeFontFaces(e);
    c.fonts.requestFonts(y);
  }), [c, e]);
  const f = fe({
    transform: "",
    clipPath: "none",
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    isCulled: !1
  });
  Ep(
    "set shape stuff",
    () => {
      const y = c.getShape(e);
      if (!y) return;
      const m = f.current, v = c.getShapeClipPath(e) ?? "none";
      v !== m.clipPath && (So(d.current, "clip-path", v), So(u.current, "clip-path", v), m.clipPath = v);
      const b = c.getShapePageTransform(e), x = we.toCssString(b), w = c.getShapeGeometry(y).bounds;
      x !== m.transform && (So(d.current, "transform", x), So(u.current, "transform", x), m.transform = x);
      const S = w.w % a, C = w.h % a, _ = S === 0 ? w.w : w.w + (a - S), E = C === 0 ? w.h : w.h + (a - C);
      (_ !== m.width || E !== m.height) && (So(d.current, "width", Math.max(_, a) + "px"), So(d.current, "height", Math.max(E, a) + "px"), So(u.current, "width", Math.max(_, a) + "px"), So(u.current, "height", Math.max(E, a) + "px"), m.width = _, m.height = E);
    },
    [c]
  ), un(() => {
    const y = d.current, m = u.current;
    So(y, "opacity", i), So(m, "opacity", i), So(y, "z-index", s), So(m, "z-index", o);
  }, [i, s, o]), Ep(
    "set display",
    () => {
      if (!c.getShape(e)) return;
      const v = c.getCulledShapes().has(e);
      v !== f.current.isCulled && (So(d.current, "display", v ? "none" : "block"), So(u.current, "display", v ? "none" : "block"), f.current.isCulled = v);
    },
    [c]
  );
  const p = re(
    (y) => c.annotateError(y, { origin: "shape", willCrashApp: !1 }),
    [c]
  );
  if (!n) return null;
  const g = "fill" in n.props && n.props.fill !== "none";
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    r.backgroundComponent && /* @__PURE__ */ h.jsx(
      "div",
      {
        ref: u,
        className: "tl-shape tl-shape-background",
        "data-shape-type": n.type,
        "data-shape-id": n.id,
        draggable: !1,
        children: /* @__PURE__ */ h.jsx(dw, { fallback: l, onError: p, children: /* @__PURE__ */ h.jsx(Xne, { shape: n, util: r }) })
      }
    ),
    /* @__PURE__ */ h.jsx(
      "div",
      {
        ref: d,
        className: "tl-shape",
        "data-shape-type": n.type,
        "data-shape-is-filled": g,
        "data-shape-id": n.id,
        draggable: !1,
        children: /* @__PURE__ */ h.jsx(dw, { fallback: l, onError: p, children: /* @__PURE__ */ h.jsx(qne, { shape: n, util: r }) })
      }
    )
  ] });
}), qne = it(
  function({ shape: e, util: n }) {
    return PI(
      "InnerShape:" + e.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        n.component(n.editor.store.unsafeGetWithoutCapture(e.id))
      ),
      [n, e.id]
    );
  },
  (t, e) => uj(t.shape, e.shape) && t.util === e.util
), Xne = it(
  function({
    shape: e,
    util: n
  }) {
    return PI(
      "InnerShape:" + e.type,
      () => {
        var r;
        return (
          // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
          // calling the render method with stale data.
          (r = n.backgroundComponent) == null ? void 0 : r.call(n, n.editor.store.unsafeGetWithoutCapture(e.id))
        );
      },
      [n, e.id]
    );
  },
  (t, e) => t.shape.props === e.shape.props && t.shape.meta === e.shape.meta && t.util === e.util
);
function kl(t) {
  const e = fe();
  return un(() => {
    e.current = t;
  }), zbe(t), re((...n) => {
    const r = e.current;
    return tt(r, "fn does not exist"), r(...n);
  }, []);
}
const _3 = zn(null);
function tze({
  context: t,
  editor: e,
  children: n
}) {
  const r = e.options.exportProvider;
  return /* @__PURE__ */ h.jsx(p3, { editor: e, children: /* @__PURE__ */ h.jsx(cne, { container: e.getContainer(), children: /* @__PURE__ */ h.jsx(_3.Provider, { value: t, children: /* @__PURE__ */ h.jsx(r, { children: n }) }) }) });
}
function J0() {
  return tn(_3);
}
function nze() {
  const t = tn(_3), [e] = he(lF);
  return me(() => (t == null || t.waitUntil(e), () => {
    e.resolve();
  }), [e, t]), kl(() => {
    e.resolve();
  });
}
var rze = Object.create, Zne = Object.defineProperty, sze = Object.getOwnPropertyDescriptor, oze = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), Qne = (t) => {
  throw TypeError(t);
}, Jne = (t, e, n) => e in t ? Zne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, ize = (t) => [, , , rze(null)], ere = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], tre = (t) => t !== void 0 && typeof t != "function" ? Qne("Function expected") : t, aze = (t, e, n, r, s) => ({ kind: ere[t], name: e, metadata: r, addInitializer: (o) => n._ ? Qne("Already initialized") : s.push(tre(o || null)) }), cze = (t, e) => Jne(e, oze("metadata"), t[3]), lze = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, dze = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = ere[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, sze(s, n)), v = r.length - 1; v >= 0; v--)
    c = aze(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, tre(i) && (m[g] = i);
  return m && Zne(s, n, m), s;
}, dH = (t, e, n) => Jne(t, typeof e != "symbol" ? e + "" : e, n), nre, HI;
nre = [Li];
class E3 {
  constructor(e) {
    this.maxDelayTimeMs = e, lze(HI, 5, this), dH(this, "isResolved", !1), dH(this, "promisesToWaitFor", []);
  }
  waitUntil(e) {
    if (this.isResolved)
      throw new Error(
        "Cannot `waitUntil` - the export has already been resolved. Make sure to call `waitUntil` as soon as possible during an export - ie within the first react effect after rendering."
      );
    this.promisesToWaitFor.push(
      e.catch((n) => console.error("Error while waiting for export:", n))
    );
  }
  async resolvePromises() {
    let e = null;
    for (; this.promisesToWaitFor.length !== e; )
      e = this.promisesToWaitFor.length, await Promise.allSettled(this.promisesToWaitFor), await DN(0);
  }
  async resolve() {
    const e = DN(this.maxDelayTimeMs).then(() => "timeout"), n = this.resolvePromises().then(() => "resolved");
    await Promise.race([e, n]) === "timeout" && console.warn("[tldraw] Export delay timed out after ${this.maxDelayTimeMs}ms"), this.isResolved = !0;
  }
}
HI = ize();
dze(HI, 1, "waitUntil", nre, E3);
cze(HI, E3);
function uze(t, e, n = {}) {
  var v, b;
  if (!window.document) throw Error("No document");
  const {
    scale: r = 1,
    // should we include the background in the export? or is it transparent?
    background: s = t.getInstanceState().exportBackground,
    padding: o = t.options.defaultSvgPadding,
    preserveAspectRatio: i
  } = n, a = n.darkMode ?? t.user.getIsDarkMode(), c = t.getShapeAndDescendantIds(e), l = t.getUnorderedRenderingShapes(!1).filter(({ id: x }) => c.has(x));
  let d = null;
  if (n.bounds)
    d = n.bounds;
  else
    for (const { id: x } of l) {
      const w = t.getShapeMaskedPageBounds(x);
      w && (d ? d.union(w) : d = w.clone());
    }
  if (!d) return;
  const u = e.length === 1 && t.isShapeOfType(t.getShape(e[0]), "frame") ? e[0] : null;
  u || d.expandBy(o);
  const f = d.width * r, p = d.height * r;
  try {
    (b = (v = document.body).focus) == null || b.call(v);
  } catch {
  }
  const g = new E3(t.options.maxExportDelayMs), y = lF();
  return g.waitUntil(y), { jsx: /* @__PURE__ */ h.jsx(
    fze,
    {
      editor: t,
      preserveAspectRatio: i,
      scale: r,
      pixelRatio: n.pixelRatio ?? null,
      bbox: d,
      background: s,
      singleFrameShapeId: u,
      isDarkMode: a,
      renderingShapes: l,
      onMount: y.resolve,
      waitUntil: g.waitUntil
    }
  ), width: f, height: p, exportDelay: g };
}
function fze({
  editor: t,
  preserveAspectRatio: e,
  scale: n,
  pixelRatio: r,
  bbox: s,
  background: o,
  singleFrameShapeId: i,
  isDarkMode: a,
  renderingShapes: c,
  onMount: l,
  waitUntil: d
}) {
  const u = gg(), f = mu({ isDarkMode: a }), p = K0("export state", { defsById: {}, shapeElements: null }), { defsById: g, shapeElements: y } = le(p), m = kl((w) => {
    p.update((S) => {
      if (rc(S.defsById, w.key)) return S;
      const C = Promise.resolve(w.getElement());
      return d(
        C.then((_) => {
          p.update((E) => ({
            ...E,
            defsById: { ...E.defsById, [w.key]: { pending: !1, element: _ } }
          }));
        })
      ), {
        ...S,
        defsById: { ...S.defsById, [w.key]: { pending: !0, element: C } }
      };
    });
  }), v = Ke(
    () => ({
      isDarkMode: a,
      waitUntil: d,
      addExportDef: m,
      scale: n,
      pixelRatio: r,
      async resolveAssetUrl(w, S) {
        const C = t.getAsset(w);
        return !C || C.type !== "image" && C.type !== "video" ? null : await t.resolveAssetUrl(w, {
          screenScale: n * (S / C.props.w),
          shouldResolveToOriginal: r === null,
          dpr: r ?? void 0
        });
      }
    }),
    [a, d, m, n, r, t]
  ), b = fe(!1);
  un(() => {
    if (b.current)
      throw new Error("SvgExport should only render once - do not use with react strict mode");
    b.current = !0, (async () => {
      const w = {}, S = c.map(
        async ({ id: _, opacity: E, index: M, backgroundIndex: N }) => {
          var A, R;
          if (_ === i) return [];
          const O = t.getShape(_);
          if (t.isShapeOfType(O, "group")) return [];
          const D = [], k = t.getShapeUtil(O);
          if (k.toSvg || k.toBackgroundSvg) {
            const [j, $] = await Promise.all([
              (A = k.toSvg) == null ? void 0 : A.call(k, O, v),
              (R = k.toBackgroundSvg) == null ? void 0 : R.call(k, O, v)
            ]), F = t.getShapePageTransform(O);
            let L = F.toCssString(), z = 1;
            "scale" in O.props && O.props.scale !== 1 && (z = O.props.scale, L = `${L} scale(${O.props.scale}, ${O.props.scale})`);
            const H = t.getShapeMask(O.id), U = H ? we.From(we.Inverse(F)).applyToPoints(H) : null, W = f3(u, O.id);
            U && (w[W] = {
              pending: !1,
              element: /* @__PURE__ */ h.jsx("clipPath", { id: W, children: /* @__PURE__ */ h.jsx(
                "path",
                {
                  d: `M${U.map(({ x: Z, y: K }) => `${Z / z},${K / z}`).join("L")}Z`
                }
              ) })
            }), j && D.push({
              zIndex: M,
              element: /* @__PURE__ */ h.jsx(
                "g",
                {
                  transform: L,
                  opacity: E,
                  clipPath: H ? `url(#${W})` : void 0,
                  children: j
                },
                `fg_${O.id}`
              )
            }), $ && D.push({
              zIndex: N,
              element: /* @__PURE__ */ h.jsx(
                "g",
                {
                  transform: L,
                  opacity: E,
                  clipPath: H ? `url(#${W})` : void 0,
                  children: $
                },
                `bg_${O.id}`
              )
            });
          } else
            D.push({
              zIndex: M,
              element: /* @__PURE__ */ h.jsx(
                uH,
                {
                  shape: O,
                  util: k,
                  component: qne,
                  className: "tl-shape",
                  bbox: s,
                  opacity: E
                },
                `fg_${O.id}`
              )
            }), k.backgroundComponent && D.push({
              zIndex: N,
              element: /* @__PURE__ */ h.jsx(
                uH,
                {
                  shape: O,
                  util: k,
                  component: Xne,
                  className: "tl-shape tl-shape-background",
                  bbox: s,
                  opacity: E
                },
                `bg_${O.id}`
              )
            });
          return D;
        }
      ), C = (await Promise.all(S)).flat();
      x0(() => {
        p.update((_) => ({
          ..._,
          shapeElements: C.sort((E, M) => E.zIndex - M.zIndex).map(({ element: E }) => E),
          defsById: { ..._.defsById, ...w }
        }));
      });
    })();
  }, [s, t, v, u, c, i, p]), me(() => {
    const w = /* @__PURE__ */ new Set();
    for (const { id: S } of c)
      for (const C of t.fonts.getShapeFontFaces(S))
        w.add(C);
    for (const S of w)
      m({
        key: bn(),
        getElement: async () => {
          const C = await t.fonts.toEmbeddedCssDeclaration(S);
          return /* @__PURE__ */ h.jsx("style", { nonce: t.options.nonce, children: C });
        }
      });
  }, [t, c, m]), me(() => {
    y !== null && l();
  }, [l, y]);
  let x = o ? f.background : "transparent";
  if (i && o) {
    const w = t.getShapeUtil("frame");
    if (w != null && w.options.showColors) {
      const S = t.getShape(i);
      x = f[S.props.color].frame.fill;
    } else
      x = f.solid;
  }
  return /* @__PURE__ */ h.jsx(tze, { editor: t, context: v, children: /* @__PURE__ */ h.jsxs(
    "svg",
    {
      preserveAspectRatio: e,
      direction: "ltr",
      width: s.width * n,
      height: s.height * n,
      viewBox: `${s.minX} ${s.minY} ${s.width} ${s.height}`,
      strokeLinecap: "round",
      strokeLinejoin: "round",
      style: { backgroundColor: x },
      "data-color-mode": a ? "dark" : "light",
      className: `tl-container tl-theme__force-sRGB ${a ? "tl-theme__dark" : "tl-theme__light"}`,
      children: [
        /* @__PURE__ */ h.jsx("defs", { children: Object.entries(g).map(
          ([w, S]) => S.pending ? null : /* @__PURE__ */ h.jsx(D$, { children: S.element }, w)
        ) }),
        y
      ]
    }
  ) });
}
function uH({
  shape: t,
  util: e,
  className: n,
  component: r,
  bbox: s,
  opacity: o
}) {
  const i = ie(), a = we.Translate(-s.minX, -s.minY).multiply(
    i.getShapePageTransform(t.id)
  ), c = i.getShapeGeometry(t.id).bounds, l = Math.max(c.width, 1), d = Math.max(c.height, 1);
  return /* @__PURE__ */ h.jsx(m3, { fallback: () => null, children: /* @__PURE__ */ h.jsx(
    "foreignObject",
    {
      x: s.minX,
      y: s.minY,
      width: s.w,
      height: s.h,
      className: "tl-shape-foreign-object tl-export-embed-styles",
      children: /* @__PURE__ */ h.jsx(
        "div",
        {
          className: n,
          "data-shape-type": t.type,
          style: {
            clipPath: i.getShapeClipPath(t.id),
            transform: a.toCssString(),
            width: l,
            height: d,
            opacity: o
          },
          children: /* @__PURE__ */ h.jsx(r, { shape: t, util: e })
        }
      )
    }
  ) });
}
let hze = 1;
async function pze(t, e, n = {}) {
  const r = uze(t, e, n);
  if (!r) return;
  const s = t.getContainer(), o = document.createElement("div");
  o.className = Hne, o.inert = !0, o.tabIndex = -1, Object.assign(o.style, {
    position: "absolute",
    top: "0px",
    left: "0px",
    width: r.width + "px",
    height: r.height + "px",
    pointerEvents: "none",
    opacity: 0
  }), s.appendChild(o);
  const i = cj(o, { identifierPrefix: `export_${hze++}_` });
  try {
    await Promise.resolve(), x0(() => {
      i.render(r.jsx);
    }), await r.exportDelay.resolve();
    const a = o.firstElementChild;
    return tt(a instanceof SVGSVGElement, "Expected an SVG element"), await gze(a), { svg: a, width: r.width, height: r.height };
  } finally {
    setTimeout(() => {
      i.unmount(), s.removeChild(o);
    }, 0);
  }
}
async function gze(t) {
  const e = [
    ...t.querySelectorAll("foreignObject.tl-export-embed-styles > *")
  ];
  if (!e.length) return;
  const n = new GBe(t);
  try {
    n.fonts.startFindingCurrentDocumentFontFaces(), await Promise.all(e.map((o) => Gne(o)));
    for (const o of e)
      n.readRootElementStyles(o);
    await n.fetchResources();
    const r = await n.getFontFaceCss();
    n.unwrapCustomElements();
    const s = n.embedStyles();
    if (r || s) {
      const o = document.createElementNS("http://www.w3.org/2000/svg", "style");
      o.textContent = `${r}
${s}`, t.prepend(o);
    }
  } finally {
    n.dispose();
  }
}
let sO = null;
function mze() {
  return sO || (sO = {
    maxWidth: oO("width"),
    // test very wide but 1 pixel tall canvases
    maxHeight: oO("height"),
    // test very tall but 1 pixel wide canvases
    maxArea: oO("area")
    // test square canvases
  }), sO;
}
/*!
 * Extracted from https://github.com/jhildenbiddle/canvas-size
 * MIT License: https://github.com/jhildenbiddle/canvas-size/blob/master/LICENSE
 * Copyright (c) John Hildenbiddle
 */
const fH = 8192, yze = 4096 * 4096, vze = {
  area: [
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4)
    // Edge 17 (Win)
    // Safari 7-12 (Mac)
    16384,
    // Chrome 68 (Android 7.1-9)
    14188,
    // Chrome 68 (Android 5)
    11402,
    // Firefox 63 (Mac, Win)
    11180,
    // Chrome 68 (Android 6)
    10836,
    // IE 9-11 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    // Safari (iOS 9 - 12)
    4096
  ],
  height: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    8388607,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ],
  width: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    4194303,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ]
};
function oO(t) {
  const e = document.createElement("canvas");
  e.width = 1, e.height = 1;
  const n = e.getContext("2d");
  for (const r of vze[t]) {
    const s = t === "height" ? 1 : r, o = t === "width" ? 1 : r, i = document.createElement("canvas");
    i.width = s, i.height = o, i.getContext("2d").fillRect(s - 1, o - 1, 1, 1), n.drawImage(i, s - 1, o - 1, 1, 1, 0, 0, 1, 1);
    const c = n.getImageData(0, 0, 1, 1).data[3] !== 0;
    if (i.width = 0, i.height = 0, c)
      return e.width = 0, e.height = 0, t === "area" ? r * r : r;
  }
  throw e.width = 0, e.height = 0, Error("Failed to determine maximum canvas dimension");
}
function bze(t, e) {
  if (t <= fH && e <= fH && t * e <= yze)
    return [t, e];
  const { maxWidth: n, maxHeight: r, maxArea: s } = mze(), o = t / e;
  if (t > n && (t = n, e = t / o), e > r && (e = r, t = e * o), t * e > s) {
    const i = Math.sqrt(s / (t * e));
    t *= i, e *= i;
  }
  return [t, e];
}
async function xze(t, e) {
  const { type: n, width: r, height: s, quality: o = 1, pixelRatio: i = 2 } = e;
  let [a, c] = bze(
    r * i,
    s * i
  );
  a = Math.floor(a), c = Math.floor(c);
  const l = a / r, d = await oi.blobToDataUrl(new Blob([t], { type: "image/svg+xml" })), u = await new Promise((p) => {
    const g = rw();
    g.crossOrigin = "anonymous", g.onload = async () => {
      dn.isSafari && await DN(250);
      const y = document.createElement("canvas"), m = y.getContext("2d");
      y.width = a, y.height = c, m.imageSmoothingEnabled = !0, m.imageSmoothingQuality = "high", m.drawImage(g, 0, 0, a, c), URL.revokeObjectURL(d), p(y);
    }, g.onerror = () => {
      p(null);
    }, g.src = d;
  });
  if (!u) return null;
  const f = await new Promise(
    (p) => u.toBlob(
      (g) => {
        (!g || ir.throwToBlob.get()) && p(null), p(g);
      },
      "image/" + n,
      o
    )
  );
  if (!f) return null;
  if (n === "png") {
    const p = new DataView(await f.arrayBuffer());
    return Nl.setPhysChunk(p, l, {
      type: "image/" + n
    });
  } else
    return f;
}
const ni = {
  /**
   * A set of strings representing any open menus. When menus are open,
   * certain interactions will behave differently; for example, when a
   * draw tool is selected and a menu is open, a pointer-down will not
   * create a dot (because the user is probably trying to close the menu)
   * however a pointer-down event followed by a drag will begin drawing
   * a line (because the user is BOTH trying to close the menu AND start
   * drawing a line).
   *
   * @public
   */
  menus: yr("open menus", []),
  /**
   * Get the current open menus.
   *
   * @param contextId - An optional context to get menus for.
   *
   * @public
   */
  getOpenMenus(t) {
    return t ? this.menus.get().filter((e) => e.endsWith("-" + t)) : this.menus.get();
  },
  /**
   * Add an open menu.
   *
   * @example
   * ```ts
   * addOpenMenu('menu-id')
   * addOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to add.
   * @param contextId - An optional context to add the menu to.
   *
   * @public
   */
  addOpenMenu(t, e = "") {
    const n = e ? `${t}-${e}` : t, r = new Set(this.menus.get());
    r.has(n) || (r.add(n), this.menus.set([...r]));
  },
  /**
   * Delete an open menu.
   *
   * @example
   * ```ts
   * deleteOpenMenu('menu-id')
   * deleteOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to delete.
   * @param contextId - An optional context to delete the menu from.
   *
   * @public
   */
  deleteOpenMenu(t, e = "") {
    const n = e ? `${t}-${e}` : t, r = new Set(this.menus.get());
    r.has(n) && (r.delete(n), this.menus.set([...r]));
  },
  /**
   * Clear all open menus.
   *
   * @example
   * ```ts
   * clearOpenMenus()
   * clearOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to clear menus for.
   *
   * @public
   */
  clearOpenMenus(t) {
    this.menus.set(t ? this.menus.get().filter((e) => !e.endsWith("-" + t)) : []);
  },
  _hiddenMenus: [],
  /**
   * Hide all open menus. Restore them with the `showOpenMenus` method.
   *
   * @example
   * ```ts
   * hideOpenMenus()
   * hideOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to hide menus for.
   *
   * @public
   */
  hideOpenMenus(t) {
    if (this._hiddenMenus = [...this.getOpenMenus(t)], this._hiddenMenus.length !== 0)
      for (const e of this._hiddenMenus)
        this.deleteOpenMenu(e, t);
  },
  /**
   * Show all hidden menus.
   *
   * @example
   * ```ts
   * showOpenMenus()
   * showOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to show menus for.
   *
   * @public
   */
  showOpenMenus(t) {
    if (this._hiddenMenus.length !== 0) {
      for (const e of this._hiddenMenus)
        this.addOpenMenu(e, t);
      this._hiddenMenus = [];
    }
  },
  /**
   * Get whether a menu is open for a given context.
   *
   * @example
   * ```ts
   * isMenuOpem(id, myEditorId)
   * ```
   *
   * @param id - The id of the menu to check.
   * @param contextId - An optional context to check menus for.
   *
   * @public
   */
  isMenuOpen(t, e) {
    return this.getOpenMenus(e).includes(t);
  },
  /**
   * Get whether any menus are open for a given context.
   *
   * @example
   * ```ts
   * hasOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - A context to check menus for.
   *
   * @public
   */
  hasOpenMenus(t) {
    return this.getOpenMenus(t).length > 0;
  },
  /**
   * Get whether any menus are open for any context.
   *
   * @example
   * ```ts
   * hasAnyOpenMenus()
   * ```
   *
   * @public
   */
  hasAnyOpenMenus() {
    return this.getOpenMenus().length > 0;
  },
  forContext(t) {
    return {
      getOpenMenus: () => this.getOpenMenus(t),
      addOpenMenu: (e) => this.addOpenMenu(e, t),
      deleteOpenMenu: (e) => this.deleteOpenMenu(e, t),
      clearOpenMenus: () => this.clearOpenMenus(t),
      // Gets whether any menus are open
      isMenuOpen: (e) => this.isMenuOpen(e, t),
      hasOpenMenus: () => this.hasOpenMenus(t),
      hasAnyOpenMenus: () => this.hasAnyOpenMenus()
    };
  }
}, fj = new fDe(), wze = {
  maxShapesPerPage: 4e3,
  maxFilesAtOnce: 100,
  maxPages: 40,
  animationMediumMs: 320,
  followChaseViewportSnap: 2,
  doubleClickDurationMs: 450,
  multiClickDurationMs: 200,
  coarseDragDistanceSquared: 36,
  // 6 squared
  dragDistanceSquared: 16,
  // 4 squared
  defaultSvgPadding: 32,
  cameraSlideFriction: 0.09,
  gridSteps: [
    { min: -1, mid: 0.15, step: 64 },
    { min: 0.05, mid: 0.375, step: 16 },
    { min: 0.15, mid: 1, step: 4 },
    { min: 0.7, mid: 2.5, step: 1 }
  ],
  collaboratorInactiveTimeoutMs: 6e4,
  collaboratorIdleTimeoutMs: 3e3,
  collaboratorCheckIntervalMs: 1200,
  cameraMovingTimeoutMs: 64,
  hitTestMargin: 8,
  edgeScrollDelay: 200,
  edgeScrollEaseDuration: 200,
  edgeScrollSpeed: 25,
  edgeScrollDistance: 8,
  coarsePointerWidth: 12,
  coarseHandleRadius: 20,
  handleRadius: 12,
  longPressDurationMs: 500,
  textShadowLod: 0.35,
  adjacentShapeMargin: 10,
  flattenImageBoundsExpand: 64,
  flattenImageBoundsPadding: 16,
  laserDelayMs: 1200,
  maxExportDelayMs: 5e3,
  temporaryAssetPreviewLifetimeMs: 18e4,
  actionShortcutsLocation: "swap",
  createTextOnCanvasDoubleClick: !0,
  exportProvider: D$,
  enableToolbarKeyboardShortcuts: !0,
  maxFontsToLoadBeforeRender: 1 / 0,
  nonce: void 0
};
function hH(t, e) {
  if (!e) return !1;
  switch (t.type) {
    case "mixed":
      return e.type === "mixed";
    case "shared":
      return e.type === "shared" && t.value === e.value;
    default:
      throw Jt(t);
  }
}
class Sze {
  constructor(e) {
    /** @internal */
    P(this, "map");
    this.map = new Map(e);
  }
  get(e) {
    return this.map.get(e);
  }
  getAsKnownValue(e) {
    const n = this.get(e);
    if (n && n.type !== "mixed")
      return n.value;
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.map.size;
  }
  equals(e) {
    if (this.size !== e.size) return !1;
    const n = /* @__PURE__ */ new Set();
    for (const [r, s] of this) {
      if (!hH(s, e.get(r))) return !1;
      n.add(r);
    }
    for (const [r, s] of e)
      if (!n.has(r) && !hH(s, this.get(r)))
        return !1;
    return !0;
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
  [Symbol.iterator]() {
    return this.map[Symbol.iterator]();
  }
}
class hj extends Sze {
  set(e, n) {
    this.map.set(e, n);
  }
  applyValue(e, n) {
    const r = this.get(e);
    if (!r) {
      this.set(e, { type: "shared", value: n });
      return;
    }
    switch (r.type) {
      case "mixed":
        return;
      case "shared":
        r.value !== n && this.set(e, { type: "mixed" });
        return;
      default:
        Jt(r, "type");
    }
  }
}
function Cze(t, e, n) {
  return qc(t).then(function(r) {
    return r.arrayBuffer();
  }).then(function(r) {
    return new File([r], e, { type: n });
  });
}
const _ze = "https://cdn.tldraw.com";
function ts() {
  return `${_ze}/${une}`;
}
function Eze(t) {
  switch (t.type) {
    case "shapes":
      return `s${t.shapeIds.map((n) => iO(n.slice(6))).join(".")}`;
    case "page":
      return "p" + iO(ci.parseId(t.pageId));
    case "viewport": {
      const { bounds: e, pageId: n } = t;
      let r = `v${Math.round(e.x)}.${Math.round(e.y)}.${Math.round(e.w)}.${Math.round(e.h)}`;
      return n && (r += "." + iO(ci.parseId(n))), r;
    }
    default:
      Jt(t);
  }
}
function Tze(t) {
  switch (t[0]) {
    case "s":
      return { type: "shapes", shapeIds: t.slice(1).split(".").filter(Boolean).map((r) => $n(decodeURIComponent(r))) };
    case "p":
      return { type: "page", pageId: ci.createId(decodeURIComponent(t.slice(1))) };
    case "v": {
      const [n, r, s, o, i] = t.slice(1).split(".");
      return {
        type: "viewport",
        bounds: new _e(Number(n), Number(r), Number(s), Number(o)),
        pageId: i ? ci.createId(decodeURIComponent(i)) : void 0
      };
    }
    default:
      throw Error("Invalid deep link string");
  }
}
function iO(t) {
  return encodeURIComponent(t).replace(/\./g, "%2E");
}
function Pze(t, e) {
  var s;
  let n = t;
  const r = new Set(e);
  for (; r.has(n); )
    n = (s = /^.*(\d+)$/.exec(n)) != null && s[1] ? n.replace(/(\d+)(?=\D?)$/, (o) => (+o + 1).toString()) : `${n} 1`;
  return n;
}
function M1(t, e, n, r) {
  if (n.length === 0) return [];
  const s = /* @__PURE__ */ new Map();
  for (const i of mt(n.map((a) => t.getShape(a)))) {
    const { parentId: a } = i;
    s.has(a) || s.set(a, {
      children: mt(
        t.getSortedChildIdsForParent(a).map((c) => t.getShape(c))
      ),
      moving: /* @__PURE__ */ new Set()
    }), s.get(a).moving.add(i);
  }
  const o = [];
  switch (e) {
    case "toBack": {
      s.forEach(({ moving: i, children: a }) => Ize(i, a, o));
      break;
    }
    case "toFront": {
      s.forEach(({ moving: i, children: a }) => kze(i, a, o));
      break;
    }
    case "forward": {
      s.forEach(
        ({ moving: i, children: a }) => Aze(t, i, a, o, r)
      );
      break;
    }
    case "backward": {
      s.forEach(
        ({ moving: i, children: a }) => Mze(t, i, a, o, r)
      );
      break;
    }
  }
  return o;
}
function Ize(t, e, n) {
  const r = e.length;
  if (t.size === r) return;
  let s, o;
  for (let i = 0; i < r; i++) {
    const a = e[i];
    if (t.has(a))
      s = a.index, t.delete(a);
    else {
      o = a.index;
      break;
    }
  }
  if (t.size !== 0) {
    const i = sy(s, o, t.size);
    n.push(
      ...Array.from(t.values()).sort(Js).map((a, c) => ({ ...a, index: i[c] }))
    );
  }
}
function kze(t, e, n) {
  const r = e.length;
  if (t.size === r) return;
  let s, o;
  for (let i = r - 1; i > -1; i--) {
    const a = e[i];
    if (t.has(a))
      o = a.index, t.delete(a);
    else {
      s = a.index;
      break;
    }
  }
  if (t.size !== 0) {
    const i = sy(s, o, t.size);
    n.push(
      ...Array.from(t.values()).sort(Js).map((a, c) => ({ ...a, index: i[c] }))
    );
  }
}
function rre(t, e) {
  const n = mt(
    Array.from(e).map((s) => {
      const o = t.getShapePageBounds(s);
      return o ? { shape: s, bounds: o } : null;
    })
  );
  return (s) => {
    const o = t.getShapePageBounds(s);
    return o ? n.some((i) => i.bounds.includes(o)) : !1;
  };
}
function Aze(t, e, n, r, s) {
  var c;
  const o = rre(t, e), i = n.length;
  if (e.size === i) return;
  let a = { name: "skipping" };
  for (let l = 0; l < i; l++) {
    const d = e.has(n[l]);
    switch (a.name) {
      case "skipping": {
        if (!d) continue;
        a = { name: "selecting", selectIndex: l };
        break;
      }
      case "selecting": {
        if (d || !(s != null && s.considerAllShapes) && !o(n[l])) continue;
        const { selectIndex: u } = a;
        sy(n[l].index, (c = n[l + 1]) == null ? void 0 : c.index, l - u).forEach(
          (f, p) => {
            const g = n[u + p];
            e.has(g) && r.push({ ...g, index: f });
          }
        ), a = { name: "skipping" };
        break;
      }
    }
  }
}
function Mze(t, e, n, r, s) {
  var c;
  const o = rre(t, e), i = n.length;
  if (e.size === i) return;
  let a = { name: "skipping" };
  for (let l = i - 1; l > -1; l--) {
    const d = e.has(n[l]);
    switch (a.name) {
      case "skipping": {
        if (!d) continue;
        a = { name: "selecting", selectIndex: l };
        break;
      }
      case "selecting": {
        if (d || !(s != null && s.considerAllShapes) && !o(n[l])) continue;
        sy((c = n[l - 1]) == null ? void 0 : c.index, n[l].index, a.selectIndex - l).forEach(
          (u, f) => {
            const p = n[l + f + 1];
            e.has(p) && r.push({ ...p, index: u });
          }
        ), a = { name: "skipping" };
        break;
      }
    }
  }
}
function sre({
  editor: t,
  ids: e
}) {
  const n = mt(e.map((i) => t.getShape(i))), r = t.getShapesSharedRotation(e), s = t.getShapesRotatedPageBounds(e);
  if (!s)
    return null;
  const o = s.center.clone().rotWith(s.point, r);
  return {
    initialPageCenter: o,
    initialCursorAngle: o.angle(t.inputs.originPagePoint),
    initialShapesRotation: r,
    shapeSnapshots: n.map((i) => ({
      shape: i,
      initialPagePoint: t.getShapePageTransform(i.id).point()
    }))
  };
}
function r_({
  delta: t,
  editor: e,
  snapshot: n,
  stage: r,
  centerOverride: s
}) {
  const { initialPageCenter: o, shapeSnapshots: i } = n;
  e.updateShapes(
    i.map(({ shape: c, initialPagePoint: l }) => {
      const d = ei(c.parentId) ? e.getShapePageTransform(c.parentId) : we.Identity(), u = I.RotWith(l, s ?? o, t), f = we.applyToPoint(
        // use the current parent transform in case it has moved/resized since the start
        // (e.g. if rotating a shape at the edge of a group)
        we.Inverse(d),
        u
      ), p = RE(c.rotation + t);
      return {
        id: c.id,
        type: c.type,
        x: f.x,
        y: f.y,
        rotation: p
      };
    })
  );
  const a = [];
  i.forEach(({ shape: c }) => {
    var f, p, g;
    const l = e.getShape(c.id);
    if (!l) return;
    const d = e.getShapeUtil(c);
    if (r === "start" || r === "one-off") {
      const y = (f = d.onRotateStart) == null ? void 0 : f.call(d, c);
      y && a.push(y);
    }
    const u = (p = d.onRotate) == null ? void 0 : p.call(d, c, l);
    if (u && a.push(u), r === "end" || r === "one-off") {
      const y = (g = d.onRotateEnd) == null ? void 0 : g.call(d, c, l);
      y && a.push(y);
    }
  }), a.length > 0 && e.updateShapes(a);
}
function pH(t) {
  const e = t.get(), n = /* @__PURE__ */ new Map();
  for (const r of e) {
    const { fromId: s, toId: o } = r, i = n.get(s);
    i ? i.push(r) : n.set(s, [r]);
    const a = n.get(o);
    a ? a.push(r) : n.set(o, [r]);
  }
  return n;
}
const Oze = (t) => {
  const { store: e } = t, n = e.query.filterHistory("binding"), r = e.query.records("binding");
  return ve("arrowBindingsIndex", (s, o) => {
    if (op(s))
      return pH(r);
    const i = s, a = n.getDiffSince(o);
    if (a === ma)
      return pH(r);
    let c;
    function l(f) {
      c ?? (c = new Map(i));
      const p = c.get(f.fromId), g = p == null ? void 0 : p.filter((v) => v.id !== f.id);
      g != null && g.length ? c.set(f.fromId, g) : c.delete(f.fromId);
      const y = c.get(f.toId), m = y == null ? void 0 : y.filter((v) => v.id !== f.id);
      m != null && m.length ? c.set(f.toId, m) : c.delete(f.toId);
    }
    function d(f) {
      c ?? (c = new Map(i));
      let p = c.get(f);
      return p ? p === i.get(f) && (p = p.slice(0), c.set(f, p)) : (p = [], c.set(f, p)), p;
    }
    function u(f) {
      d(f.fromId).push(f), d(f.toId).push(f);
    }
    for (const f of a) {
      for (const p of Er(f.added))
        u(p);
      for (const [p, g] of Er(f.updated))
        l(p), u(g);
      for (const p of Er(f.removed))
        l(p);
    }
    return c ?? i;
  });
};
function Dze(t) {
  const e = t.getCurrentPageShapeIds(), n = t.getViewportPageBounds(), r = /* @__PURE__ */ new Set();
  return e.forEach((s) => {
    const o = t.getShapePageBounds(s);
    (o === void 0 || !n.includes(o)) && r.add(s);
  }), r;
}
function Nze(t) {
  return ve("notVisibleShapes", function(n) {
    const r = Dze(t);
    if (op(n) || n.size !== r.size) return r;
    for (const s of n)
      if (!r.has(s))
        return r;
    return n;
  });
}
function gH(t, e) {
  const n = {}, r = t.get(), s = Array(r.size);
  return r.forEach((o) => s.push(e.get(o))), s.sort(Js), s.forEach((o) => {
    n[o.parentId] || (n[o.parentId] = []), n[o.parentId].push(o.id);
  }), n;
}
const jze = (t) => {
  const e = t.query.ids("shape"), n = t.query.filterHistory("shape");
  return ve(
    "parentsToChildrenWithIndexes",
    (r, s) => {
      if (op(r))
        return gH(e, t);
      const o = n.getDiffSince(s);
      if (o === ma)
        return gH(e, t);
      if (o.length === 0) return r;
      let i = null;
      const a = (d) => {
        i || (i = { ...r }), i[d] ? i[d] === r[d] && (i[d] = [...i[d]]) : i[d] = [];
      }, c = /* @__PURE__ */ new Set();
      let l;
      for (let d = 0, u = o.length; d < u; d++) {
        l = o[d];
        for (const f of Object.values(l.added))
          fm(f) && (a(f.parentId), i[f.parentId].push(f.id), c.add(i[f.parentId]));
        for (const [f, p] of Object.values(l.updated))
          if (fm(p) && fm(f)) {
            if (f.parentId !== p.parentId)
              a(f.parentId), a(p.parentId), i[f.parentId].splice(i[f.parentId].indexOf(p.id), 1), i[p.parentId].push(p.id), c.add(i[p.parentId]);
            else if (f.index !== p.index) {
              a(p.parentId);
              const g = i[p.parentId].indexOf(p.id);
              i[p.parentId][g] = p.id, c.add(i[p.parentId]);
            }
          }
        for (const f of Object.values(l.removed))
          fm(f) && (a(f.parentId), i[f.parentId].splice(i[f.parentId].indexOf(f.id), 1));
      }
      for (const d of c) {
        const u = mt(d.map((f) => t.get(f)));
        u.sort(Js), d.splice(0, d.length, ...u.map((f) => f.id));
      }
      return i ?? r;
    }
  );
}, aO = (t, e, n) => {
  for (; !Ys(n.parentId); ) {
    const r = t.get(n.parentId);
    if (!r) return !1;
    n = r;
  }
  return n.parentId === e;
}, Rze = (t, e) => {
  const n = t.query.ids("shape");
  let r = null;
  function s() {
    const o = e();
    return r = o, new Set(
      [...n.get()].filter((i) => aO(t, o, t.get(i)))
    );
  }
  return ve("_shapeIdsInCurrentPage", (o, i) => {
    if (op(o))
      return s();
    const a = e();
    if (a !== r)
      return s();
    const c = t.history.getDiffSince(i);
    if (c === ma)
      return s();
    const l = new QC(
      o
    );
    for (const u of c) {
      for (const f of Object.values(u.added))
        fm(f) && aO(t, a, f) && l.add(f.id);
      for (const [f, p] of Object.values(u.updated))
        fm(p) && (aO(t, a, p) ? l.add(p.id) : l.remove(p.id));
      for (const f of Object.keys(u.removed))
        ei(f) && l.remove(f);
    }
    const d = l.get();
    return d ? Db(d.value, d.diff) : o;
  });
};
var $ze = Object.create, ore = Object.defineProperty, Lze = Object.getOwnPropertyDescriptor, Fze = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), ire = (t) => {
  throw TypeError(t);
}, are = (t, e, n) => e in t ? ore(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Bze = (t) => [, , , $ze(null)], cre = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], lre = (t) => t !== void 0 && typeof t != "function" ? ire("Function expected") : t, zze = (t, e, n, r, s) => ({ kind: cre[t], name: e, metadata: r, addInitializer: (o) => n._ ? ire("Already initialized") : s.push(lre(o || null)) }), Uze = (t, e) => are(e, Fze("metadata"), t[3]), Hze = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, dre = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = cre[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, Lze(s, n)), v = r.length - 1; v >= 0; v--)
    c = zze(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, lre(i) && (m[g] = i);
  return m && ore(s, n, m), s;
}, jg = (t, e, n) => are(t, typeof e != "symbol" ? e + "" : e, n), ure, fre, eS;
const Vze = 40;
fre = [Li], ure = [Li];
class VI {
  constructor(e) {
    this.editor = e, Hze(eS, 5, this), jg(this, "_clickId", ""), jg(this, "_clickTimeout"), jg(this, "_clickScreenPoint"), jg(this, "_previousScreenPoint"), jg(this, "_clickState", "idle"), jg(this, "lastPointerInfo", {});
  }
  _getClickTimeout(e, n = bn()) {
    this._clickId = n, clearTimeout(this._clickTimeout), this._clickTimeout = this.editor.timers.setTimeout(
      () => {
        if (this._clickState === e && this._clickId === n) {
          switch (this._clickState) {
            case "pendingTriple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "settle"
              });
              break;
            }
            case "pendingQuadruple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "settle"
              });
              break;
            }
            case "pendingOverflow": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "settle"
              });
              break;
            }
          }
          this._clickState = "idle";
        }
      },
      e === "idle" || e === "pendingDouble" ? this.editor.options.doubleClickDurationMs : this.editor.options.multiClickDurationMs
    );
  }
  /**
   * The current click state.
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get clickState() {
    return this._clickState;
  }
  handlePointerEvent(e) {
    switch (e.name) {
      case "pointer_down": {
        if (!this._clickState) return e;
        switch (this._clickScreenPoint = I.From(e.point), this._previousScreenPoint && I.Dist2(this._previousScreenPoint, this._clickScreenPoint) > Vze ** 2 && (this._clickState = "idle"), this._previousScreenPoint = this._clickScreenPoint, this.lastPointerInfo = e, this._clickState) {
          case "pendingDouble":
            return this._clickState = "pendingTriple", this._clickTimeout = this._getClickTimeout(this._clickState), {
              ...e,
              type: "click",
              name: "double_click",
              phase: "down"
            };
          case "pendingTriple":
            return this._clickState = "pendingQuadruple", this._clickTimeout = this._getClickTimeout(this._clickState), {
              ...e,
              type: "click",
              name: "triple_click",
              phase: "down"
            };
          case "pendingQuadruple":
            return this._clickState = "pendingOverflow", this._clickTimeout = this._getClickTimeout(this._clickState), {
              ...e,
              type: "click",
              name: "quadruple_click",
              phase: "down"
            };
          case "idle": {
            this._clickState = "pendingDouble";
            break;
          }
          case "pendingOverflow": {
            this._clickState = "overflow";
            break;
          }
        }
        return this._clickTimeout = this._getClickTimeout(this._clickState), e;
      }
      case "pointer_up": {
        if (!this._clickState) return e;
        switch (this._clickScreenPoint = I.From(e.point), this._clickState) {
          case "pendingTriple":
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "double_click",
              phase: "up"
            };
          case "pendingQuadruple":
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "triple_click",
              phase: "up"
            };
          case "pendingOverflow":
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "quadruple_click",
              phase: "up"
            };
        }
        return e;
      }
      case "pointer_move":
        return this._clickState !== "idle" && this._clickScreenPoint && I.Dist2(this._clickScreenPoint, this.editor.inputs.currentScreenPoint) > (this.editor.getInstanceState().isCoarsePointer ? this.editor.options.coarseDragDistanceSquared : this.editor.options.dragDistanceSquared) && this.cancelDoubleClickTimeout(), e;
    }
    return e;
  }
  cancelDoubleClickTimeout() {
    this._clickTimeout = clearTimeout(this._clickTimeout), this._clickState = "idle";
  }
}
eS = Bze();
dre(eS, 1, "_getClickTimeout", fre, VI);
dre(eS, 1, "cancelDoubleClickTimeout", ure, VI);
Uze(eS, VI);
class Wze {
  constructor(e) {
    P(this, "_isEdgeScrolling", !1);
    P(this, "_edgeScrollDuration", -1);
    this.editor = e;
  }
  /**
   * Update the camera position when the mouse is close to the edge of the screen.
   * Run this on every tick when in a state where edge scrolling is enabled.
   *
   * @public
   */
  updateEdgeScrolling(e) {
    const { editor: n } = this, r = this.getEdgeScroll();
    if (r.x === 0 && r.y === 0)
      this._isEdgeScrolling && (this._isEdgeScrolling = !1, this._edgeScrollDuration = 0);
    else if (this._isEdgeScrolling || (this._isEdgeScrolling = !0, this._edgeScrollDuration = 0), this._edgeScrollDuration += e, this._edgeScrollDuration > n.options.edgeScrollDelay) {
      const s = n.options.edgeScrollEaseDuration > 0 ? Mo.easeInCubic(
        Math.min(
          1,
          this._edgeScrollDuration / (n.options.edgeScrollDelay + n.options.edgeScrollEaseDuration)
        )
      ) : 1;
      this.moveCameraWhenCloseToEdge({
        x: r.x * s,
        y: r.y * s
      });
    }
  }
  /**
   * Helper function to get the scroll proximity factor for a given position.
   * @param position - The mouse position on the axis.
   * @param dimension - The component dimension on the axis.
   * @param isCoarse - Whether the pointer is coarse.
   * @param insetStart - Whether the pointer is inset at the start of the axis.
   * @param insetEnd - Whether the pointer is inset at the end of the axis.
   * @internal
   */
  getEdgeProximityFactors(e, n, r, s, o) {
    const { editor: i } = this, a = i.options.edgeScrollDistance, c = r ? i.options.coarsePointerWidth : 0, l = e - c, d = e + c, u = s ? 0 : a, f = o ? n : n - a;
    return l < u ? Math.min(1, (u - l) / a) : d > f ? -Math.min(1, (d - f) / a) : 0;
  }
  getEdgeScroll() {
    const { editor: e } = this, {
      inputs: {
        currentScreenPoint: { x: n, y: r }
      }
    } = e, s = e.getViewportScreenBounds(), {
      isCoarsePointer: o,
      insets: [i, a, c, l]
    } = e.getInstanceState(), d = this.getEdgeProximityFactors(n, s.w, o, l, a), u = this.getEdgeProximityFactors(r, s.h, o, i, c);
    return {
      x: d,
      y: u
    };
  }
  /**
   * Moves the camera when the mouse is close to the edge of the screen.
   * @public
   */
  moveCameraWhenCloseToEdge(e) {
    const { editor: n } = this;
    if (!n.inputs.isDragging || n.inputs.isPanning || n.getCameraOptions().isLocked || e.x === 0 && e.y === 0) return;
    const r = n.getViewportScreenBounds(), s = r.w < 1e3 ? 0.612 : 1, o = r.h < 1e3 ? 0.612 : 1, i = n.getZoomLevel(), a = n.user.getEdgeScrollSpeed() * n.options.edgeScrollSpeed, c = a * e.x * s / i, l = a * e.y * o / i, { x: d, y: u, z: f } = n.getCamera();
    n.setCamera(new I(d + c, u + l, f));
  }
}
class Kze {
  constructor(e, n) {
    P(this, "disposeSideEffectListener");
    this.editor = e, this.disposeSideEffectListener = e.sideEffects.registerAfterChangeHandler(
      "instance",
      (s, o) => {
        s.isFocused !== o.isFocused && this.updateContainerClass();
      }
    );
    const r = e.getInstanceState().isFocused;
    n !== r && e.updateInstanceState({ isFocused: !!n }), this.updateContainerClass(), document.body.addEventListener("keydown", this.handleKeyDown.bind(this)), document.body.addEventListener("mousedown", this.handleMouseDown.bind(this));
  }
  /**
   * The editor's focus state and the container's focus state
   * are not necessarily always in sync. For that reason we
   * can't rely on the css `:focus` or `:focus-within` selectors to style the
   * editor when it is in focus.
   *
   * For that reason we synchronize the editor's focus state with a
   * special class on the container: tl-container__focused
   */
  updateContainerClass() {
    const e = this.editor.getContainer();
    this.editor.getInstanceState().isFocused ? e.classList.add("tl-container__focused") : e.classList.remove("tl-container__focused"), e.classList.add("tl-container__no-focus-ring");
  }
  handleKeyDown(e) {
    const n = this.editor.getContainer();
    this.editor.isIn("select.editing_shape") || document.activeElement === n && this.editor.getSelectedShapeIds().length > 0 || ["Tab", "ArrowUp", "ArrowDown"].includes(e.key) && n.classList.remove("tl-container__no-focus-ring");
  }
  handleMouseDown() {
    this.editor.getContainer().classList.add("tl-container__no-focus-ring");
  }
  focus() {
    this.editor.getContainer().focus();
  }
  blur() {
    this.editor.complete(), this.editor.getContainer().blur();
  }
  dispose() {
    var e;
    document.body.removeEventListener("keydown", this.handleKeyDown.bind(this)), document.body.removeEventListener("mousedown", this.handleMouseDown.bind(this)), (e = this.disposeSideEffectListener) == null || e.call(this);
  }
}
class Gze {
  constructor(e, n) {
    P(this, "shapeFontFacesCache");
    P(this, "shapeFontLoadStateCache");
    P(this, "fontStates", new JN("font states"));
    P(this, "fontsToLoad", /* @__PURE__ */ new Set());
    this.editor = e, this.assetUrls = n, this.shapeFontFacesCache = e.store.createComputedCache(
      "shape font faces",
      (r) => this.editor.getShapeUtil(r).getFontFaces(r),
      {
        areResultsEqual: pE,
        areRecordsEqual: (r, s) => r.props === s.props && r.meta === s.meta
      }
    ), this.shapeFontLoadStateCache = e.store.createCache(
      (r) => {
        const s = ve("font faces", () => this.getShapeFontFaces(r));
        return ve(
          "font load state",
          () => s.get().map((i) => this.getFontState(i)),
          { isEqual: pE }
        );
      }
    );
  }
  getShapeFontFaces(e) {
    const n = typeof e == "string" ? e : e.id;
    return this.shapeFontFacesCache.get(n) ?? Br;
  }
  trackFontsForShape(e) {
    const n = typeof e == "string" ? e : e.id;
    this.shapeFontLoadStateCache.get(n);
  }
  async loadRequiredFontsForCurrentPage(e = 1 / 0) {
    const n = /* @__PURE__ */ new Set();
    for (const s of this.editor.getCurrentPageShapeIds())
      for (const o of this.getShapeFontFaces(this.editor.getShape(s)))
        n.add(o);
    if (n.size > e)
      return;
    const r = Array.from(n, (s) => this.ensureFontIsLoaded(s));
    await Promise.all(r);
  }
  getFontState(e) {
    return this.fontStates.get(e) ?? null;
  }
  ensureFontIsLoaded(e) {
    const n = this.getFontState(e);
    if (n) return n.loadingPromise;
    const r = this.findOrCreateFontFace(e), s = {
      state: "loading",
      instance: r,
      loadingPromise: r.load().then(() => {
        document.fonts.add(r), this.fontStates.update(e, (o) => ({ ...o, state: "ready" }));
      }).catch((o) => {
        console.error(o), this.fontStates.update(e, (i) => ({ ...i, state: "error" }));
      })
    };
    return this.fontStates.set(e, s), s.loadingPromise;
  }
  requestFonts(e) {
    this.fontsToLoad.size || queueMicrotask(() => {
      if (this.editor.isDisposed) return;
      const n = this.fontsToLoad;
      this.fontsToLoad = /* @__PURE__ */ new Set(), va(() => {
        for (const r of n)
          this.ensureFontIsLoaded(r);
      });
    });
    for (const n of e)
      this.fontsToLoad.add(n);
  }
  findOrCreateFontFace(e) {
    var s;
    for (const o of document.fonts)
      if (o.family === e.family && ai(mH).every(
        ([i, a]) => o[i] === (e[i] ?? a)
      ))
        return o;
    const n = ((s = this.assetUrls) == null ? void 0 : s[e.src.url]) ?? e.src.url, r = new FontFace(e.family, `url(${JSON.stringify(n)})`, {
      ...Qf(mH, (o) => e[o]),
      display: "swap"
    });
    return document.fonts.add(r), r;
  }
  async toEmbeddedCssDeclaration(e) {
    var o;
    const n = ((o = this.assetUrls) == null ? void 0 : o[e.src.url]) ?? e.src.url, r = await oi.urlToDataUrl(n), s = mt([
      `url("${r}")`,
      e.src.format ? `format(${e.src.format})` : null,
      e.src.tech ? `tech(${e.src.tech})` : null
    ]).join(" ");
    return mt([
      "@font-face {",
      `  font-family: "${e.family}";`,
      e.ascentOverride ? `  ascent-override: ${e.ascentOverride};` : null,
      e.descentOverride ? `  descent-override: ${e.descentOverride};` : null,
      e.stretch ? `  font-stretch: ${e.stretch};` : null,
      e.style ? `  font-style: ${e.style};` : null,
      e.weight ? `  font-weight: ${e.weight};` : null,
      e.featureSettings ? `  font-feature-settings: ${e.featureSettings};` : null,
      e.lineGapOverride ? `  line-gap-override: ${e.lineGapOverride};` : null,
      e.unicodeRange ? `  unicode-range: ${e.unicodeRange};` : null,
      `  src: ${s};`,
      "}"
    ]).join(`
`);
  }
}
const mH = {
  style: "normal",
  weight: "normal",
  stretch: "normal",
  unicodeRange: "U+0-10FFFF",
  featureSettings: "normal",
  ascentOverride: "normal",
  descentOverride: "normal",
  lineGapOverride: "normal"
};
class Yze {
  constructor(e) {
    P(this, "store");
    P(this, "dispose");
    P(this, "state", "recording");
    P(this, "pendingDiff", new Xze());
    P(this, "stacks", yr(
      "HistoryManager.stacks",
      {
        undos: sb(),
        redos: sb()
      },
      {
        isEqual: (e, n) => e.undos === n.undos && e.redos === n.redos
      }
    ));
    P(this, "annotateError");
    /** @internal */
    P(this, "_isInBatch", !1);
    this.store = e.store, this.annotateError = e.annotateError ?? nw, this.dispose = this.store.addHistoryInterceptor((n, r) => {
      if (r === "user")
        switch (this.state) {
          case "recording":
            this.pendingDiff.apply(n.changes), this.stacks.update(({ undos: s }) => ({ undos: s, redos: sb() }));
            break;
          case "recordingPreserveRedoStack":
            this.pendingDiff.apply(n.changes);
            break;
          case "paused":
            break;
          default:
            Jt(this.state);
        }
    });
  }
  flushPendingDiff() {
    if (this.pendingDiff.isEmpty()) return;
    const e = this.pendingDiff.clear();
    this.stacks.update(({ undos: n, redos: r }) => ({
      undos: n.push({ type: "diff", diff: e }),
      redos: r
    }));
  }
  getNumUndos() {
    return this.stacks.get().undos.length + (this.pendingDiff.isEmpty() ? 0 : 1);
  }
  getNumRedos() {
    return this.stacks.get().redos.length;
  }
  batch(e, n) {
    const r = this.state;
    r !== "paused" && (n != null && n.history) && (this.state = qze[n.history]);
    try {
      if (this._isInBatch)
        return va(e), this;
      this._isInBatch = !0;
      try {
        va(e);
      } catch (s) {
        throw this.annotateError(s), s;
      } finally {
        this._isInBatch = !1;
      }
      return this;
    } finally {
      this.state = r;
    }
  }
  // History
  _undo({ pushToRedoStack: e, toMark: n = void 0 }) {
    var s;
    const r = this.state;
    this.state = "paused";
    try {
      let { undos: o, redos: i } = this.stacks.get();
      const a = this.pendingDiff.clear(), c = pte(a), l = ej(a);
      e && !c && (i = i.push({ type: "diff", diff: a }));
      let d = !1;
      if (c)
        for (; ((s = o.head) == null ? void 0 : s.type) === "stop"; ) {
          const u = o.head;
          if (o = o.tail, e && (i = i.push(u)), u.id === n) {
            d = !0;
            break;
          }
        }
      if (!d)
        e: for (; o.head; ) {
          const u = o.head;
          switch (o = o.tail, e && (i = i.push(u)), u.type) {
            case "diff":
              yx(l, [ej(u.diff)]);
              break;
            case "stop":
              if (!n) break e;
              if (u.id === n) {
                d = !0;
                break e;
              }
              break;
            default:
              Jt(u);
          }
        }
      if (!d && n)
        return this;
      this.store.applyDiff(l, { ignoreEphemeralKeys: !0 }), this.store.ensureStoreIsUsable(), this.stacks.set({ undos: o, redos: i });
    } finally {
      this.state = r;
    }
    return this;
  }
  undo() {
    return this._undo({ pushToRedoStack: !0 }), this;
  }
  redo() {
    var n;
    const e = this.state;
    this.state = "paused";
    try {
      this.flushPendingDiff();
      let { undos: r, redos: s } = this.stacks.get();
      if (s.length === 0)
        return this;
      for (; ((n = s.head) == null ? void 0 : n.type) === "stop"; )
        r = r.push(s.head), s = s.tail;
      const o = EE();
      for (; s.head; ) {
        const i = s.head;
        if (r = r.push(i), s = s.tail, i.type === "diff")
          yx(o, [i.diff]);
        else
          break;
      }
      this.store.applyDiff(o, { ignoreEphemeralKeys: !0 }), this.store.ensureStoreIsUsable(), this.stacks.set({ undos: r, redos: s });
    } finally {
      this.state = e;
    }
    return this;
  }
  bail() {
    return this._undo({ pushToRedoStack: !1 }), this;
  }
  bailToMark(e) {
    return e && this._undo({ pushToRedoStack: !1, toMark: e }), this;
  }
  squashToMark(e) {
    var o;
    let n = this.stacks.get().undos;
    const r = [];
    for (; n.head && !(n.head.type === "stop" && n.head.id === e); )
      n.head.type === "diff" && r.push(n.head.diff), n = n.tail;
    if (!n.head || ((o = n.head) == null ? void 0 : o.id) !== e)
      return console.error("Could not find mark to squash to: ", e), this;
    if (r.length === 0)
      return this;
    const s = EE();
    return yx(s, r.reverse()), this.stacks.update(({ redos: i }) => ({
      undos: n.push({
        type: "diff",
        diff: s
      }),
      redos: i
    })), this;
  }
  /** @internal */
  _mark(e) {
    va(() => {
      this.flushPendingDiff(), this.stacks.update(({ undos: n, redos: r }) => ({ undos: n.push({ type: "stop", id: e }), redos: r }));
    });
  }
  clear() {
    this.stacks.set({ undos: sb(), redos: sb() }), this.pendingDiff.clear();
  }
  /** @internal */
  getMarkIdMatching(e) {
    let n = this.stacks.get().undos;
    for (; n.head; ) {
      if (n.head.type === "stop" && n.head.id.includes(e))
        return n.head.id;
      n = n.tail;
    }
    return null;
  }
  /** @internal */
  debug() {
    const { undos: e, redos: n } = this.stacks.get();
    return {
      undos: e.toArray(),
      redos: n.toArray(),
      pendingDiff: this.pendingDiff.debug(),
      state: this.state
    };
  }
}
const qze = {
  record: "recording",
  "record-preserveRedoStack": "recordingPreserveRedoStack",
  ignore: "paused"
  /* Paused */
};
class Xze {
  constructor() {
    P(this, "diff", EE());
    P(this, "isEmptyAtom", yr("PendingDiff.isEmpty", !0));
  }
  clear() {
    const e = this.diff;
    return this.diff = EE(), this.isEmptyAtom.set(!0), e;
  }
  isEmpty() {
    return this.isEmptyAtom.get();
  }
  apply(e) {
    yx(this.diff, [e]), this.isEmptyAtom.set(pte(this.diff));
  }
  debug() {
    return { diff: this.diff, isEmpty: this.isEmpty() };
  }
}
function sb(t) {
  return Qze;
}
class Zze {
  constructor() {
    P(this, "length", 0);
    P(this, "head", null);
    P(this, "tail", this);
  }
  push(e) {
    return new T3(e, this);
  }
  toArray() {
    return Br;
  }
  [Symbol.iterator]() {
    return {
      next() {
        return { value: void 0, done: !0 };
      }
    };
  }
}
const Qze = new Zze();
class T3 {
  constructor(e, n) {
    P(this, "length");
    this.head = e, this.tail = n, this.length = n.length + 1;
  }
  push(e) {
    return new T3(e, this);
  }
  toArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this;
    return {
      next() {
        if (e.length) {
          const n = e.head;
          return e = e.tail, { value: n, done: !1 };
        } else
          return { value: void 0, done: !0 };
      }
    };
  }
}
class Jze {
  constructor(e) {
    P(this, "scribbleItems", /* @__PURE__ */ new Map());
    P(this, "state", "paused");
    this.editor = e;
  }
  addScribble(e, n = bn()) {
    const r = {
      id: n,
      scribble: {
        id: n,
        size: 20,
        color: "accent",
        opacity: 0.8,
        delay: 0,
        points: [],
        shrink: 0.1,
        taper: !0,
        ...e,
        state: "starting"
      },
      timeoutMs: 0,
      delayRemaining: e.delay ?? 0,
      prev: null,
      next: null
    };
    return this.scribbleItems.set(n, r), r;
  }
  reset() {
    this.editor.updateInstanceState({ scribbles: [] }), this.scribbleItems.clear();
  }
  /**
   * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
   *
   * @public
   */
  stop(e) {
    const n = this.scribbleItems.get(e);
    if (!n) throw Error(`Scribble with id ${e} not found`);
    return n.delayRemaining = Math.min(n.delayRemaining, 200), n.scribble.state = "stopping", n;
  }
  /**
   * Set the scribble's next point.
   *
   * @param id - The id of the scribble to add a point to.
   * @param x - The x coordinate of the point.
   * @param y - The y coordinate of the point.
   * @param z - The z coordinate of the point.
   * @public
   */
  addPoint(e, n, r, s = 0.5) {
    const o = this.scribbleItems.get(e);
    if (!o) throw Error(`Scribble with id ${e} not found`);
    const { prev: i } = o, a = { x: n, y: r, z: s };
    return (!i || I.Dist(i, a) >= 1) && (o.next = a), o;
  }
  /**
   * Update on each animation frame.
   *
   * @param elapsed - The number of milliseconds since the last tick.
   * @public
   */
  tick(e) {
    this.scribbleItems.size !== 0 && this.editor.run(() => {
      this.scribbleItems.forEach((n) => {
        if (n.scribble.state === "starting") {
          const { next: c, prev: l } = n;
          c && c !== l && (n.prev = c, n.scribble.points.push(c)), n.scribble.points.length > 8 && (n.scribble.state = "active");
          return;
        }
        n.delayRemaining > 0 && (n.delayRemaining = Math.max(0, n.delayRemaining - e)), n.timeoutMs += e, n.timeoutMs >= 16 && (n.timeoutMs = 0);
        const { delayRemaining: r, timeoutMs: s, prev: o, next: i, scribble: a } = n;
        switch (a.state) {
          case "active": {
            i && i !== o ? (n.prev = i, a.points.push(i), r === 0 && a.points.length > 8 && a.points.shift()) : s === 0 && (a.points.length > 1 ? a.points.shift() : n.delayRemaining = a.delay);
            break;
          }
          case "stopping": {
            if (n.delayRemaining === 0 && s === 0) {
              if (a.points.length === 1) {
                this.scribbleItems.delete(n.id);
                return;
              }
              a.shrink && (a.size = Math.max(1, a.size * (1 - a.shrink))), a.points.shift();
            }
            break;
          }
        }
      }), this.editor.updateInstanceState({
        scribbles: Array.from(this.scribbleItems.values()).map(({ scribble: n }) => ({
          ...n,
          points: [...n.points]
        })).slice(-5)
        // limit to three as a minor sanity check
      });
    });
  }
}
var e6e = Object.create, hre = Object.defineProperty, t6e = Object.getOwnPropertyDescriptor, n6e = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), pre = (t) => {
  throw TypeError(t);
}, gre = (t, e, n) => e in t ? hre(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, r6e = (t) => [, , , e6e(null)], mre = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], yre = (t) => t !== void 0 && typeof t != "function" ? pre("Function expected") : t, s6e = (t, e, n, r, s) => ({ kind: mre[t], name: e, metadata: r, addInitializer: (o) => n._ ? pre("Already initialized") : s.push(yre(o || null)) }), o6e = (t, e) => gre(e, n6e("metadata"), t[3]), i6e = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, WI = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = mre[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, t6e(s, n)), v = r.length - 1; v >= 0; v--)
    c = s6e(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, yre(i) && (m[g] = i);
  return m && hre(s, n, m), s;
}, a6e = (t, e, n) => gre(t, e + "", n), vre, bre, xre, wre, mg;
const pt = (t) => Math.round(t * 10 ** 8) / 10 ** 8;
function Nd(t, e, n, r, s) {
  const o = t.filter(
    (a) => (r === "forward" ? a.startNode.id === e : a.endNode.id === e) && pt(a.length) === pt(n) && Mc(
      a.breadthIntersection[0],
      a.breadthIntersection[1],
      s[0],
      s[1]
    )
  );
  if (o.length === 0) return [];
  const i = /* @__PURE__ */ new Set();
  return o.forEach((a) => {
    const c = r === "forward" ? a.endNode.id : a.startNode.id;
    if (!i.has(c)) {
      i.add(c);
      const l = Nd(
        t,
        c,
        n,
        r,
        Mc(
          a.breadthIntersection[0],
          a.breadthIntersection[1],
          s[0],
          s[1]
        )
      );
      o.push(...l);
    }
  }), o;
}
function c6e(t) {
  t.sort((e, n) => n.gaps.length - e.gaps.length);
  for (let e = t.length - 1; e > 0; e--) {
    const n = t[e];
    for (let r = e - 1; r >= 0; r--) {
      const s = t[r];
      if (s.direction === n.direction && n.gaps.every(
        (o) => s.gaps.some(
          (i) => pt(o.startEdge[0].x) === pt(i.startEdge[0].x) && pt(o.startEdge[0].y) === pt(i.startEdge[0].y) && pt(o.startEdge[1].x) === pt(i.startEdge[1].x) && pt(o.startEdge[1].y) === pt(i.startEdge[1].y)
        ) && s.gaps.some(
          (i) => pt(o.endEdge[0].x) === pt(i.endEdge[0].x) && pt(o.endEdge[0].y) === pt(i.endEdge[0].y) && pt(o.endEdge[1].x) === pt(i.endEdge[1].x) && pt(o.endEdge[1].y) === pt(i.endEdge[1].y)
        )
      )) {
        t.splice(e, 1);
        break;
      }
    }
  }
}
wre = [ve], xre = [ve], bre = [ve], vre = [ve];
class lv {
  constructor(e) {
    this.manager = e, i6e(mg, 5, this), a6e(this, "editor"), this.editor = e.editor;
  }
  getSnapPointsCache() {
    const { editor: e } = this;
    return e.store.createComputedCache("snapPoints", (n) => {
      const r = e.getShapePageTransform(n.id);
      if (!r) return;
      const o = e.getShapeUtil(n).getBoundsSnapGeometry(n).points ?? e.getShapeGeometry(n).bounds.cornersAndCenter;
      if (!(!r || !o))
        return o.map((i, a) => {
          const { x: c, y: l } = we.applyToPoint(r, i);
          return { x: c, y: l, id: `${n.id}:${a}` };
        });
    });
  }
  getSnapPoints(e) {
    return this.getSnapPointsCache().get(e) ?? [];
  }
  getSnappablePoints() {
    const e = this.getSnapPointsCache(), n = this.manager.getSnappableShapes(), r = [];
    for (const s of n) {
      const o = e.get(s);
      o && r.push(...o);
    }
    return r;
  }
  getSnappableGapNodes() {
    return Array.from(this.manager.getSnappableShapes(), (e) => ({
      id: e,
      pageBounds: Io(this.editor.getShapePageBounds(e))
    }));
  }
  getVisibleGaps() {
    const e = [], n = [];
    let r, s;
    const o = this.getSnappableGapNodes().sort((a, c) => a.pageBounds.minX - c.pageBounds.minX);
    for (let a = 0; a < o.length; a++) {
      r = o[a];
      for (let c = a + 1; c < o.length; c++)
        s = o[c], // is there space between the boxes
        r.pageBounds.maxX < s.pageBounds.minX && // and they overlap in the y axis
        nb(
          r.pageBounds.minY,
          r.pageBounds.maxY,
          s.pageBounds.minY,
          s.pageBounds.maxY
        ) && e.push({
          startNode: r,
          endNode: s,
          startEdge: [
            new I(r.pageBounds.maxX, r.pageBounds.minY),
            new I(r.pageBounds.maxX, r.pageBounds.maxY)
          ],
          endEdge: [
            new I(s.pageBounds.minX, s.pageBounds.minY),
            new I(s.pageBounds.minX, s.pageBounds.maxY)
          ],
          length: s.pageBounds.minX - r.pageBounds.maxX,
          breadthIntersection: Mc(
            r.pageBounds.minY,
            r.pageBounds.maxY,
            s.pageBounds.minY,
            s.pageBounds.maxY
          )
        });
    }
    const i = o.sort((a, c) => a.pageBounds.minY - c.pageBounds.minY);
    for (let a = 0; a < i.length; a++) {
      r = i[a];
      for (let c = a + 1; c < i.length; c++)
        s = i[c], // is there space between the boxes
        r.pageBounds.maxY < s.pageBounds.minY && // do they overlap in the x axis
        nb(
          r.pageBounds.minX,
          r.pageBounds.maxX,
          s.pageBounds.minX,
          s.pageBounds.maxX
        ) && n.push({
          startNode: r,
          endNode: s,
          startEdge: [
            new I(r.pageBounds.minX, r.pageBounds.maxY),
            new I(r.pageBounds.maxX, r.pageBounds.maxY)
          ],
          endEdge: [
            new I(s.pageBounds.minX, s.pageBounds.minY),
            new I(s.pageBounds.maxX, s.pageBounds.minY)
          ],
          length: s.pageBounds.minY - r.pageBounds.maxY,
          breadthIntersection: Mc(
            r.pageBounds.minX,
            r.pageBounds.maxX,
            s.pageBounds.minX,
            s.pageBounds.maxX
          )
        });
    }
    return { horizontal: e, vertical: n };
  }
  snapTranslateShapes({
    lockedAxis: e,
    initialSelectionPageBounds: n,
    initialSelectionSnapPoints: r,
    dragDelta: s
  }) {
    var m, v;
    const o = this.manager.getSnapThreshold(), i = this.getSnappablePoints(), a = n.clone().translate(s), c = r.map(
      ({ x: b, y: x }, w) => ({
        id: "selection:" + w,
        x: b + s.x,
        y: x + s.y
      })
    ), l = i, d = [], u = [], f = new I(o, o);
    this.collectPointSnaps({
      minOffset: f,
      nearestSnapsX: d,
      nearestSnapsY: u,
      otherNodeSnapPoints: l,
      selectionSnapPoints: c
    }), this.collectGapSnaps({
      selectionPageBounds: a,
      nearestSnapsX: d,
      nearestSnapsY: u,
      minOffset: f
    });
    const p = new I(
      e === "x" ? 0 : ((m = d[0]) == null ? void 0 : m.nudge) ?? 0,
      e === "y" ? 0 : ((v = u[0]) == null ? void 0 : v.nudge) ?? 0
    );
    f.x = 0, f.y = 0, d.length = 0, u.length = 0, c.forEach((b) => {
      b.x += p.x, b.y += p.y;
    }), a.translate(p), this.collectPointSnaps({
      minOffset: f,
      nearestSnapsX: d,
      nearestSnapsY: u,
      otherNodeSnapPoints: l,
      selectionSnapPoints: c
    }), this.collectGapSnaps({
      selectionPageBounds: a,
      nearestSnapsX: d,
      nearestSnapsY: u,
      minOffset: f
    });
    const g = this.getPointSnapLines({
      nearestSnapsX: d,
      nearestSnapsY: u
    }), y = this.getGapSnapLines({
      selectionPageBounds: a,
      nearestSnapsX: d,
      nearestSnapsY: u
    });
    return this.manager.setIndicators([...y, ...g]), { nudge: p };
  }
  snapResizeShapes({
    initialSelectionPageBounds: e,
    dragDelta: n,
    handle: r,
    isAspectRatioLocked: s,
    isResizingFromCenter: o
  }) {
    var _, E;
    const i = this.manager.getSnapThreshold(), {
      box: a,
      scaleX: c,
      scaleY: l
    } = _e.Resize(
      e,
      r,
      o ? n.x * 2 : n.x,
      o ? n.y * 2 : n.y,
      s
    );
    let d = r;
    c < 0 && (d = yBe(d)), l < 0 && (d = mBe(d)), o && (a.center = e.center);
    const u = d === "top" || d === "bottom", f = d === "left" || d === "right", p = yH(d, a), g = this.getSnappablePoints(), y = [], m = [], v = new I(i, i);
    this.collectPointSnaps({
      minOffset: v,
      nearestSnapsX: y,
      nearestSnapsY: m,
      otherNodeSnapPoints: g,
      selectionSnapPoints: p
    });
    const b = new I(
      u ? 0 : ((_ = y[0]) == null ? void 0 : _.nudge) ?? 0,
      f ? 0 : ((E = m[0]) == null ? void 0 : E.nudge) ?? 0
    );
    if (s && vBe(d) && b.len() !== 0) {
      const M = y.length && m.length ? Math.abs(b.x) < Math.abs(b.y) ? "x" : "y" : y.length ? "x" : "y", N = e.aspectRatio;
      M === "x" ? (m.length = 0, b.y = b.x / N, (d === "bottom_left" || d === "top_right") && (b.y = -b.y)) : (y.length = 0, b.x = b.y * N, (d === "bottom_left" || d === "top_right") && (b.x = -b.x));
    }
    const x = I.Add(n, b), { box: w } = _e.Resize(
      e,
      r,
      o ? x.x * 2 : x.x,
      o ? x.y * 2 : x.y,
      s
    );
    o && (w.center = e.center);
    const S = yH("any", w);
    y.length = 0, m.length = 0, v.x = 0, v.y = 0, this.collectPointSnaps({
      minOffset: v,
      nearestSnapsX: y,
      nearestSnapsY: m,
      otherNodeSnapPoints: g,
      selectionSnapPoints: S
    });
    const C = this.getPointSnapLines({
      nearestSnapsX: y,
      nearestSnapsY: m
    });
    return this.manager.setIndicators([...C]), { nudge: b };
  }
  collectPointSnaps({
    selectionSnapPoints: e,
    otherNodeSnapPoints: n,
    minOffset: r,
    nearestSnapsX: s,
    nearestSnapsY: o
  }) {
    for (const i of e)
      for (const a of n) {
        const c = I.Sub(i, a), l = Math.abs(c.x), d = Math.abs(c.y);
        pt(l) <= pt(r.x) && (pt(l) < pt(r.x) && (s.length = 0), s.push({
          type: "points",
          points: { thisPoint: i, otherPoint: a },
          nudge: a.x - i.x
        }), r.x = l), pt(d) <= pt(r.y) && (pt(d) < pt(r.y) && (o.length = 0), o.push({
          type: "points",
          points: { thisPoint: i, otherPoint: a },
          nudge: a.y - i.y
        }), r.y = d);
      }
  }
  collectGapSnaps({
    selectionPageBounds: e,
    minOffset: n,
    nearestSnapsX: r,
    nearestSnapsY: s
  }) {
    const { horizontal: o, vertical: i } = this.getVisibleGaps();
    for (const a of o) {
      if (!nb(
        a.breadthIntersection[0],
        a.breadthIntersection[1],
        e.minY,
        e.maxY
      ))
        continue;
      const l = a.startEdge[0].x + a.length / 2 - e.center.x;
      if (a.length > e.width && pt(Math.abs(l)) <= pt(n.x)) {
        pt(Math.abs(l)) < pt(n.x) && (r.length = 0), n.x = Math.abs(l);
        const v = {
          type: "gap_center",
          gap: a,
          nudge: l
        }, b = r.find(({ type: w }) => w === "gap_center"), x = b && Mc(
          a.breadthIntersection[0],
          a.breadthIntersection[1],
          b.gap.breadthIntersection[0],
          b.gap.breadthIntersection[1]
        );
        b && b.gap.length > a.length && x ? r[r.indexOf(b)] = v : (!b || !x) && r.push(v);
      }
      const u = a.startNode.pageBounds.minX - a.length, f = e.maxX, p = u - f;
      pt(Math.abs(p)) <= pt(n.x) && (pt(Math.abs(p)) < pt(n.x) && (r.length = 0), n.x = Math.abs(p), r.push({
        type: "gap_duplicate",
        gap: a,
        protrusionDirection: "left",
        nudge: p
      }));
      const g = a.endNode.pageBounds.maxX + a.length, y = e.minX, m = g - y;
      pt(Math.abs(m)) <= pt(n.x) && (pt(Math.abs(m)) < pt(n.x) && (r.length = 0), n.x = Math.abs(m), r.push({
        type: "gap_duplicate",
        gap: a,
        protrusionDirection: "right",
        nudge: m
      }));
    }
    for (const a of i) {
      if (!nb(
        a.breadthIntersection[0],
        a.breadthIntersection[1],
        e.minX,
        e.maxX
      ))
        continue;
      const l = a.startEdge[0].y + a.length / 2 - e.center.y;
      if (a.length > e.height && pt(Math.abs(l)) <= pt(n.y)) {
        pt(Math.abs(l)) < pt(n.y) && (s.length = 0), n.y = Math.abs(l);
        const v = {
          type: "gap_center",
          gap: a,
          nudge: l
        }, b = s.find(({ type: w }) => w === "gap_center"), x = b && nb(
          b.gap.breadthIntersection[0],
          b.gap.breadthIntersection[1],
          a.breadthIntersection[0],
          a.breadthIntersection[1]
        );
        b && b.gap.length > a.length && x ? s[s.indexOf(b)] = v : (!b || !x) && s.push(v);
        continue;
      }
      const u = a.startNode.pageBounds.minY - a.length, f = e.maxY, p = u - f;
      pt(Math.abs(p)) <= pt(n.y) && (pt(Math.abs(p)) < pt(n.y) && (s.length = 0), n.y = Math.abs(p), s.push({
        type: "gap_duplicate",
        gap: a,
        protrusionDirection: "top",
        nudge: p
      }));
      const g = a.endNode.pageBounds.maxY + a.length, y = e.minY, m = g - y;
      pt(Math.abs(m)) <= pt(n.y) && (pt(Math.abs(m)) < pt(n.y) && (s.length = 0), n.y = Math.abs(m), s.push({
        type: "gap_duplicate",
        gap: a,
        protrusionDirection: "bottom",
        nudge: m
      }));
    }
  }
  getPointSnapLines({
    nearestSnapsX: e,
    nearestSnapsY: n
  }) {
    const r = {}, s = {};
    if (e.length > 0) {
      for (const o of e)
        if (o.type === "points") {
          const i = pt(o.points.otherPoint.x);
          r[i] || (r[i] = []), r[i].push(o.points);
        }
    }
    if (n.length > 0) {
      for (const o of n)
        if (o.type === "points") {
          const i = pt(o.points.otherPoint.y);
          s[i] || (s[i] = []), s[i].push(o.points);
        }
    }
    return Object.values(r).concat(Object.values(s)).map((o) => ({
      id: bn(),
      type: "points",
      points: cF(
        o.map((i) => I.From(i.otherPoint)).concat(o.map((i) => I.From(i.thisPoint))),
        (i, a) => i.equals(a)
      )
    }));
  }
  getGapSnapLines({
    selectionPageBounds: e,
    nearestSnapsX: n,
    nearestSnapsY: r
  }) {
    const { vertical: s, horizontal: o } = this.getVisibleGaps(), i = {
      top: e.sides[0],
      right: e.sides[1],
      // need bottom and left to be sorted asc, which .sides is not.
      bottom: [e.corners[3], e.corners[2]],
      left: [e.corners[0], e.corners[3]]
    }, a = [];
    if (n.length > 0)
      for (const c of n) {
        if (c.type === "points") continue;
        const {
          gap: { breadthIntersection: l, startEdge: d, startNode: u, endNode: f, length: p, endEdge: g }
        } = c;
        switch (c.type) {
          case "gap_center": {
            const y = (p - e.width) / 2, m = Mc(
              l[0],
              l[1],
              e.minY,
              e.maxY
            );
            a.push({
              type: "gaps",
              direction: "horizontal",
              id: bn(),
              gaps: [
                ...Nd(
                  o,
                  u.id,
                  y,
                  "backward",
                  m
                ),
                {
                  startEdge: d,
                  endEdge: i.left
                },
                {
                  startEdge: i.right,
                  endEdge: g
                },
                ...Nd(
                  o,
                  f.id,
                  y,
                  "forward",
                  m
                )
              ]
            });
            break;
          }
          case "gap_duplicate": {
            const y = Mc(
              l[0],
              l[1],
              e.minY,
              e.maxY
            );
            a.push({
              type: "gaps",
              direction: "horizontal",
              id: bn(),
              gaps: c.protrusionDirection === "left" ? [
                {
                  startEdge: i.right,
                  endEdge: d.map(
                    (m) => m.clone().addXY(-u.pageBounds.width, 0)
                  )
                },
                { startEdge: d, endEdge: g },
                ...Nd(
                  o,
                  f.id,
                  p,
                  "forward",
                  y
                )
              ] : [
                ...Nd(
                  o,
                  u.id,
                  p,
                  "backward",
                  y
                ),
                { startEdge: d, endEdge: g },
                {
                  startEdge: g.map(
                    (m) => m.clone().addXY(c.gap.endNode.pageBounds.width, 0)
                  ),
                  endEdge: i.left
                }
              ]
            });
            break;
          }
        }
      }
    if (r.length > 0)
      for (const c of r) {
        if (c.type === "points") continue;
        const {
          gap: { breadthIntersection: l, startEdge: d, startNode: u, endNode: f, length: p, endEdge: g }
        } = c;
        switch (c.type) {
          case "gap_center": {
            const y = (p - e.height) / 2, m = Mc(
              l[0],
              l[1],
              e.minX,
              e.maxX
            );
            a.push({
              type: "gaps",
              direction: "vertical",
              id: bn(),
              gaps: [
                ...Nd(
                  s,
                  u.id,
                  y,
                  "backward",
                  m
                ),
                {
                  startEdge: d,
                  endEdge: i.top
                },
                {
                  startEdge: i.bottom,
                  endEdge: g
                },
                ...Nd(
                  s,
                  c.gap.endNode.id,
                  y,
                  "forward",
                  m
                )
              ]
            });
            break;
          }
          case "gap_duplicate":
            {
              const y = Mc(
                l[0],
                l[1],
                e.minX,
                e.maxX
              );
              a.push({
                type: "gaps",
                direction: "vertical",
                id: bn(),
                gaps: c.protrusionDirection === "top" ? [
                  {
                    startEdge: i.bottom,
                    endEdge: d.map(
                      (m) => m.clone().addXY(0, -u.pageBounds.height)
                    )
                  },
                  { startEdge: d, endEdge: g },
                  ...Nd(
                    s,
                    f.id,
                    p,
                    "forward",
                    y
                  )
                ] : [
                  ...Nd(
                    s,
                    u.id,
                    p,
                    "backward",
                    y
                  ),
                  { startEdge: d, endEdge: g },
                  {
                    startEdge: g.map(
                      (m) => m.clone().addXY(0, f.pageBounds.height)
                    ),
                    endEdge: i.top
                  }
                ]
              });
            }
            break;
        }
      }
    return c6e(a), a;
  }
}
mg = r6e();
WI(mg, 1, "getSnapPointsCache", wre, lv);
WI(mg, 1, "getSnappablePoints", xre, lv);
WI(mg, 1, "getSnappableGapNodes", bre, lv);
WI(mg, 1, "getVisibleGaps", vre, lv);
o6e(mg, lv);
function yH(t, e) {
  const { minX: n, maxX: r, minY: s, maxY: o } = e, i = [];
  switch (t) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      i.push({
        id: "top_left",
        handle: "top_left",
        x: n,
        y: s
      });
  }
  switch (t) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      i.push({
        id: "top_right",
        handle: "top_right",
        x: r,
        y: s
      });
  }
  switch (t) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      i.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: r,
        y: o
      });
  }
  switch (t) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      i.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: n,
        y: o
      });
  }
  return i;
}
var l6e = Object.create, Sre = Object.defineProperty, d6e = Object.getOwnPropertyDescriptor, u6e = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), Cre = (t) => {
  throw TypeError(t);
}, _re = (t, e, n) => e in t ? Sre(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, f6e = (t) => [, , , l6e(null)], Ere = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], Tre = (t) => t !== void 0 && typeof t != "function" ? Cre("Function expected") : t, h6e = (t, e, n, r, s) => ({ kind: Ere[t], name: e, metadata: r, addInitializer: (o) => n._ ? Cre("Already initialized") : s.push(Tre(o || null)) }), p6e = (t, e) => _re(e, u6e("metadata"), t[3]), g6e = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, m6e = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = Ere[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, d6e(s, n)), v = r.length - 1; v >= 0; v--)
    c = h6e(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, Tre(i) && (m[g] = i);
  return m && Sre(s, n, m), s;
}, y6e = (t, e, n) => _re(t, e + "", n), Pre, KI;
const v6e = () => null, b6e = () => [];
Pre = [ve];
class P3 {
  constructor(e) {
    this.manager = e, g6e(KI, 5, this), y6e(this, "editor"), this.editor = e.editor;
  }
  getSnapGeometryCache() {
    const { editor: e } = this;
    return e.store.createComputedCache("handle snap geometry", (n) => {
      const r = e.getShapeUtil(n).getHandleSnapGeometry(n), s = r.getSelfSnapOutline ? r.getSelfSnapOutline.bind(r) : v6e, o = r.getSelfSnapPoints ? r.getSelfSnapPoints.bind(r) : b6e;
      return {
        outline: r.outline === void 0 ? e.getShapeGeometry(n) : r.outline,
        points: r.points ?? [],
        getSelfSnapOutline: s,
        getSelfSnapPoints: o
      };
    });
  }
  *iterateSnapPointsInPageSpace(e, n) {
    var s, o;
    const r = (s = this.getSnapGeometryCache().get(e)) == null ? void 0 : s.getSelfSnapPoints(n);
    if (r && r.length) {
      const i = Io(this.editor.getShapePageTransform(e));
      for (const a of r)
        yield i.applyToPoint(a);
    }
    for (const i of this.manager.getSnappableShapes()) {
      if (i === e) continue;
      const a = (o = this.getSnapGeometryCache().get(i)) == null ? void 0 : o.points;
      if (!a || !a.length) continue;
      const c = Io(this.editor.getShapePageTransform(i));
      for (const l of a)
        yield c.applyToPoint(l);
    }
  }
  *iterateSnapOutlines(e, n) {
    var s, o;
    const r = (s = this.getSnapGeometryCache().get(e)) == null ? void 0 : s.getSelfSnapOutline(n);
    r && (yield { shapeId: e, outline: r });
    for (const i of this.manager.getSnappableShapes()) {
      if (i === e) continue;
      const a = (o = this.getSnapGeometryCache().get(i)) == null ? void 0 : o.outline;
      a && (yield { shapeId: i, outline: a });
    }
  }
  getHandleSnapPosition({
    currentShapeId: e,
    handle: n,
    handleInPageSpace: r
  }) {
    const s = this.manager.getSnapThreshold();
    let o = s, i = null;
    for (const l of this.iterateSnapPointsInPageSpace(e, n))
      I.DistMin(r, l, o) && (o = I.Dist(r, l), i = l);
    if (i) return i;
    let a = s, c = null;
    for (const { shapeId: l, outline: d } of this.iterateSnapOutlines(e, n)) {
      const u = Io(this.editor.getShapePageTransform(l)), f = this.editor.getPointInShapeSpace(l, r), p = d.nearestPoint(f), g = u.applyToPoint(p);
      I.DistMin(r, g, a) && (a = I.Dist(r, g), c = g);
    }
    return c || null;
  }
  snapHandle({
    currentShapeId: e,
    handle: n
  }) {
    const s = Io(this.editor.getShapePageTransform(e)).applyToPoint(n), o = this.getHandleSnapPosition({ currentShapeId: e, handle: n, handleInPageSpace: s });
    return o ? (this.manager.setIndicators([
      {
        id: bn(),
        type: "points",
        points: [o]
      }
    ]), { nudge: I.Sub(o, s) }) : null;
  }
}
KI = f6e();
m6e(KI, 1, "getSnapGeometryCache", Pre, P3);
p6e(KI, P3);
var x6e = Object.create, Ire = Object.defineProperty, w6e = Object.getOwnPropertyDescriptor, S6e = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), kre = (t) => {
  throw TypeError(t);
}, Are = (t, e, n) => e in t ? Ire(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, C6e = (t) => [, , , x6e(null)], Mre = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], Ore = (t) => t !== void 0 && typeof t != "function" ? kre("Function expected") : t, _6e = (t, e, n, r, s) => ({ kind: Mre[t], name: e, metadata: r, addInitializer: (o) => n._ ? kre("Already initialized") : s.push(Ore(o || null)) }), E6e = (t, e) => Are(e, S6e("metadata"), t[3]), T6e = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, I3 = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = Mre[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, w6e(s, n)), v = r.length - 1; v >= 0; v--)
    c = _6e(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, Ore(i) && (m[g] = i);
  return m && Ire(s, n, m), s;
}, cO = (t, e, n) => Are(t, typeof e != "symbol" ? e + "" : e, n), Dre, Nre, jre, dv;
jre = [ve], Nre = [ve], Dre = [ve];
class tS {
  constructor(e) {
    this.editor = e, T6e(dv, 5, this), cO(this, "shapeBounds"), cO(this, "handles"), cO(this, "_snapIndicators", yr("snapLines", void 0)), this.shapeBounds = new lv(this), this.handles = new P3(this);
  }
  getIndicators() {
    return this._snapIndicators.get() ?? Br;
  }
  clearIndicators() {
    this.getIndicators().length && this._snapIndicators.set(void 0);
  }
  setIndicators(e) {
    this._snapIndicators.set(e);
  }
  getSnapThreshold() {
    return 8 / this.editor.getZoomLevel();
  }
  getSnappableShapes() {
    const { editor: e } = this, n = e.getViewportPageBounds(), r = e.getSelectedShapeIds(), s = /* @__PURE__ */ new Set(), o = (i) => {
      if (ei(i)) {
        const c = e.getShape(i);
        c && e.isShapeOfType(c, "frame") && s.add(i);
      }
      const a = e.getSortedChildIdsForParent(i);
      for (const c of a) {
        if (r.includes(c)) continue;
        const l = e.getShape(c);
        if (!l || !e.getShapeUtil(l).canSnap(l)) continue;
        const u = e.getShapePageBounds(c);
        if (u && n.includes(u)) {
          if (e.isShapeOfType(l, "group")) {
            o(c);
            continue;
          }
          s.add(c);
        }
      }
    };
    return o(this.getCurrentCommonAncestor() ?? e.getCurrentPageId()), s;
  }
  getCurrentCommonAncestor() {
    return this.editor.findCommonAncestor(this.editor.getSelectedShapes());
  }
}
dv = C6e();
I3(dv, 1, "getSnapThreshold", jre, tS);
I3(dv, 1, "getSnappableShapes", Nre, tS);
I3(dv, 1, "getCurrentCommonAncestor", Dre, tS);
E6e(dv, tS);
const P6e = /\r?\n|\r/g;
function vH(t) {
  return t.replace(P6e, `
`).split(`
`).map((e) => e || " ").join(`
`);
}
const I6e = {
  start: "left",
  "start-legacy": "left",
  middle: "center",
  "middle-legacy": "center",
  end: "right",
  "end-legacy": "right"
}, k6e = /\s/, bH = Object.freeze({
  "overflow-wrap": "break-word",
  "word-break": "auto",
  width: null,
  height: null,
  "max-width": null,
  "min-width": null
});
class A6e {
  constructor(e) {
    P(this, "elm");
    this.editor = e;
    const n = document.createElement("div");
    n.classList.add("tl-text"), n.classList.add("tl-text-measure"), n.setAttribute("dir", "auto"), n.tabIndex = -1, this.editor.getContainer().appendChild(n), this.elm = n;
    for (const r of px(bH))
      n.style.setProperty(r, bH[r]);
  }
  setElementStyles(e) {
    const n = {};
    for (const r of px(e))
      if (typeof e[r] == "string") {
        const s = this.elm.style.getPropertyValue(r);
        if (s === e[r]) continue;
        n[r] = s, this.elm.style.setProperty(r, e[r]);
      }
    return () => {
      for (const r of px(n))
        this.elm.style.setProperty(r, n[r]);
    };
  }
  dispose() {
    return this.elm.remove();
  }
  measureText(e, n) {
    const r = document.createElement("div");
    return r.textContent = vH(e), this.measureHtml(r.innerHTML, n);
  }
  measureHtml(e, n) {
    const { elm: r } = this, s = {
      "font-family": n.fontFamily,
      "font-style": n.fontStyle,
      "font-weight": n.fontWeight,
      "font-size": n.fontSize + "px",
      "line-height": n.lineHeight.toString(),
      padding: n.padding,
      "max-width": n.maxWidth ? n.maxWidth + "px" : void 0,
      "min-width": n.minWidth ? n.minWidth + "px" : void 0,
      "overflow-wrap": n.disableOverflowWrapBreaking ? "normal" : void 0,
      ...n.otherStyles
    }, o = this.setElementStyles(s);
    try {
      r.innerHTML = e;
      const i = n.measureScrollWidth ? r.scrollWidth : 0, a = r.getBoundingClientRect();
      return {
        x: 0,
        y: 0,
        w: a.width,
        h: a.height,
        scrollWidth: i
      };
    } finally {
      o();
    }
  }
  /**
   * Given an html element, measure the position of each span of unbroken
   * word/white-space characters within any text nodes it contains.
   */
  measureElementTextNodeSpans(e, { shouldTruncateToFirstLine: n = !1 } = {}) {
    const r = [], s = e.getBoundingClientRect(), o = -s.left, i = -s.top, a = new Range(), c = e.childNodes[0];
    let l = 0, d = null, u = null, f = 0, p = 0, g = !1;
    for (const y of e.childNodes)
      if (y.nodeType === Node.TEXT_NODE)
        for (const m of y.textContent ?? "") {
          a.setStart(c, l), a.setEnd(c, l + m.length);
          const v = a.getClientRects(), b = v[v.length - 1], x = b.top + i, w = b.left + o, S = b.right + o, C = w < p, _ = k6e.test(m);
          if (
            // If we're at a word boundary...
            _ !== u || // ...or we're on a different line...
            x !== f || // ...or we're at the start of the text and haven't created a span yet...
            !d
          ) {
            if (d) {
              if (n && x !== f) {
                g = !0;
                break;
              }
              r.push(d);
            }
            d = {
              box: { x: w, y: x, w: b.width, h: b.height },
              text: m
            }, p = w;
          } else
            C && (d.box.x = w), d.box.w = C ? d.box.w + b.width : S - d.box.x, d.text += m;
          m === `
` && (p = 0), u = _, f = x, l += m.length;
        }
    return d && r.push(d), { spans: r, didTruncate: g };
  }
  /**
   * Measure text into individual spans. Spans are created by rendering the
   * text, then dividing it up according to line breaks and word boundaries.
   *
   * It works by having the browser render the text, then measuring the
   * position of each character. You can use this to replicate the text-layout
   * algorithm of the current browser in e.g. an SVG export.
   */
  measureTextSpans(e, n) {
    if (e === "") return [];
    const { elm: r } = this, s = n.overflow === "truncate-ellipsis" || n.overflow === "truncate-clip", o = Math.ceil(n.width - n.padding * 2), i = {
      "font-family": n.fontFamily,
      "font-style": n.fontStyle,
      "font-weight": n.fontWeight,
      "font-size": n.fontSize + "px",
      "line-height": n.lineHeight.toString(),
      width: `${o}px`,
      height: "min-content",
      "text-align": I6e[n.textAlign],
      "overflow-wrap": s ? "anywhere" : void 0,
      "word-break": s ? "break-all" : void 0,
      ...n.otherStyles
    }, a = this.setElementStyles(i);
    try {
      const c = vH(e);
      r.textContent = c;
      const { spans: l, didTruncate: d } = this.measureElementTextNodeSpans(r, {
        shouldTruncateToFirstLine: s
      });
      if (n.overflow === "truncate-ellipsis" && d) {
        r.textContent = "";
        const u = Math.ceil(this.measureElementTextNodeSpans(r).spans[0].box.w);
        r.style.setProperty("width", `${o - u}px`), r.textContent = c;
        const f = this.measureElementTextNodeSpans(r, {
          shouldTruncateToFirstLine: !0
        }).spans, p = f[f.length - 1];
        return f.push({
          text: "",
          box: {
            x: Math.min(p.box.x + p.box.w, n.width - n.padding - u),
            y: p.box.y,
            w: u,
            h: p.box.h
          }
        }), f;
      }
      return l;
    } finally {
      a();
    }
  }
}
var M6e = Object.create, Rre = Object.defineProperty, O6e = Object.getOwnPropertyDescriptor, D6e = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), $re = (t) => {
  throw TypeError(t);
}, Lre = (t, e, n) => e in t ? Rre(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, N6e = (t) => [, , , M6e(null)], Fre = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], Bre = (t) => t !== void 0 && typeof t != "function" ? $re("Function expected") : t, j6e = (t, e, n, r, s) => ({ kind: Fre[t], name: e, metadata: r, addInitializer: (o) => n._ ? $re("Already initialized") : s.push(Bre(o || null)) }), R6e = (t, e) => Lre(e, D6e("metadata"), t[3]), $6e = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, zre = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = Fre[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, O6e(s, n)), v = r.length - 1; v >= 0; v--)
    c = j6e(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, Bre(i) && (m[g] = i);
  return m && Rre(s, n, m), s;
}, O1 = (t, e, n) => Lre(t, typeof e != "symbol" ? e + "" : e, n), Ure, Hre, nS;
const xH = typeof process < "u" && process.env.NODE_ENV === "test" ? (
  // At test time we should use actual raf and not throttle, because throttle was set up to evaluate immediately during tests, which causes stack overflow
  // for the tick manager since it sets up a raf loop.
  function(e) {
    const n = requestAnimationFrame(e);
    return () => cancelAnimationFrame(n);
  }
) : yF;
Hre = [Li], Ure = [Li];
class GI {
  constructor(e) {
    this.editor = e, $6e(nS, 5, this), O1(this, "cancelRaf"), O1(this, "isPaused", !0), O1(this, "now", 0), O1(this, "prevPoint", new I()), this.editor.disposables.add(this.dispose), this.start();
  }
  start() {
    var e;
    this.isPaused = !1, (e = this.cancelRaf) == null || e.call(this), this.cancelRaf = xH(this.tick), this.now = Date.now();
  }
  tick() {
    if (this.isPaused)
      return;
    const e = Date.now(), n = e - this.now;
    this.now = e, this.updatePointerVelocity(n), this.editor.emit("frame", n), this.editor.emit("tick", n), this.cancelRaf = xH(this.tick);
  }
  dispose() {
    var e;
    this.isPaused = !0, (e = this.cancelRaf) == null || e.call(this);
  }
  updatePointerVelocity(e) {
    const {
      prevPoint: n,
      editor: {
        inputs: { currentScreenPoint: r, pointerVelocity: s }
      }
    } = this;
    if (e === 0) return;
    const o = I.Sub(r, n);
    this.prevPoint = r.clone();
    const i = o.len(), a = i ? o.div(i) : new I(0, 0), c = s.clone().lrp(a.mul(i / e), 0.5);
    Math.abs(c.x) < 0.01 && (c.x = 0), Math.abs(c.y) < 0.01 && (c.y = 0), s.equals(c) || (this.editor.inputs.pointerVelocity = c);
  }
}
nS = N6e();
zre(nS, 1, "tick", Hre, GI);
zre(nS, 1, "dispose", Ure, GI);
R6e(nS, GI);
var L6e = Object.create, Vre = Object.defineProperty, F6e = Object.getOwnPropertyDescriptor, B6e = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), Wre = (t) => {
  throw TypeError(t);
}, Kre = (t, e, n) => e in t ? Vre(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, z6e = (t) => [, , , L6e(null)], Gre = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], Yre = (t) => t !== void 0 && typeof t != "function" ? Wre("Function expected") : t, U6e = (t, e, n, r, s) => ({ kind: Gre[t], name: e, metadata: r, addInitializer: (o) => n._ ? Wre("Already initialized") : s.push(Yre(o || null)) }), H6e = (t, e) => Kre(e, B6e("metadata"), t[3]), V6e = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, Ma = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = Gre[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, F6e(s, n)), v = r.length - 1; v >= 0; v--)
    c = U6e(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, Yre(i) && (m[g] = i);
  return m && Vre(s, n, m), s;
}, wH = (t, e, n) => Kre(t, typeof e != "symbol" ? e + "" : e, n), qre, Xre, Zre, Qre, Jre, ese, tse, nse, rse, sse, ose, ise, ase, Lo;
ase = [ve], ise = [ve], ose = [ve], sse = [ve], rse = [ve], nse = [ve], tse = [ve], ese = [ve], Jre = [ve], Qre = [ve], Zre = [ve], Xre = [ve], qre = [ve];
class mi {
  constructor(e, n) {
    if (this.user = e, this.inferDarkMode = n, V6e(Lo, 5, this), wH(this, "systemColorScheme", yr("systemColorScheme", "light")), wH(this, "disposables", /* @__PURE__ */ new Set()), typeof window > "u" || !("matchMedia" in window)) return;
    const r = window.matchMedia("(prefers-color-scheme: dark)");
    r != null && r.matches && this.systemColorScheme.set("dark");
    const s = (o) => {
      o.matches ? this.systemColorScheme.set("dark") : this.systemColorScheme.set("light");
    };
    r == null || r.addEventListener("change", s), this.disposables.add(() => r == null ? void 0 : r.removeEventListener("change", s));
  }
  dispose() {
    this.disposables.forEach((e) => e());
  }
  updateUserPreferences(e) {
    this.user.setUserPreferences({
      ...this.user.userPreferences.get(),
      ...e
    });
  }
  getUserPreferences() {
    return {
      id: this.getId(),
      name: this.getName(),
      locale: this.getLocale(),
      color: this.getColor(),
      animationSpeed: this.getAnimationSpeed(),
      areKeyboardShortcutsEnabled: this.getAreKeyboardShortcutsEnabled(),
      isSnapMode: this.getIsSnapMode(),
      colorScheme: this.user.userPreferences.get().colorScheme,
      isDarkMode: this.getIsDarkMode(),
      isWrapMode: this.getIsWrapMode(),
      isDynamicResizeMode: this.getIsDynamicResizeMode()
    };
  }
  getIsDarkMode() {
    switch (this.user.userPreferences.get().colorScheme) {
      case "dark":
        return !0;
      case "light":
        return !1;
      case "system":
        return this.systemColorScheme.get() === "dark";
      default:
        return this.inferDarkMode ? this.systemColorScheme.get() === "dark" : !1;
    }
  }
  getEdgeScrollSpeed() {
    return this.user.userPreferences.get().edgeScrollSpeed ?? Ua.edgeScrollSpeed;
  }
  getAnimationSpeed() {
    return this.user.userPreferences.get().animationSpeed ?? Ua.animationSpeed;
  }
  getAreKeyboardShortcutsEnabled() {
    return this.user.userPreferences.get().areKeyboardShortcutsEnabled ?? Ua.areKeyboardShortcutsEnabled;
  }
  getId() {
    return this.user.userPreferences.get().id;
  }
  getName() {
    var e;
    return ((e = this.user.userPreferences.get().name) == null ? void 0 : e.trim()) ?? Ua.name;
  }
  getLocale() {
    return this.user.userPreferences.get().locale ?? Ua.locale;
  }
  getColor() {
    return this.user.userPreferences.get().color ?? Ua.color;
  }
  getIsSnapMode() {
    return this.user.userPreferences.get().isSnapMode ?? Ua.isSnapMode;
  }
  getIsWrapMode() {
    return this.user.userPreferences.get().isWrapMode ?? Ua.isWrapMode;
  }
  getIsDynamicResizeMode() {
    return this.user.userPreferences.get().isDynamicSizeMode ?? Ua.isDynamicSizeMode;
  }
  getIsPasteAtCursorMode() {
    return this.user.userPreferences.get().isPasteAtCursorMode ?? Ua.isPasteAtCursorMode;
  }
}
Lo = z6e();
Ma(Lo, 1, "getUserPreferences", ase, mi);
Ma(Lo, 1, "getIsDarkMode", ise, mi);
Ma(Lo, 1, "getEdgeScrollSpeed", ose, mi);
Ma(Lo, 1, "getAnimationSpeed", sse, mi);
Ma(Lo, 1, "getAreKeyboardShortcutsEnabled", rse, mi);
Ma(Lo, 1, "getId", nse, mi);
Ma(Lo, 1, "getName", tse, mi);
Ma(Lo, 1, "getLocale", ese, mi);
Ma(Lo, 1, "getColor", Jre, mi);
Ma(Lo, 1, "getIsSnapMode", Qre, mi);
Ma(Lo, 1, "getIsWrapMode", Zre, mi);
Ma(Lo, 1, "getIsDynamicResizeMode", Xre, mi);
Ma(Lo, 1, "getIsPasteAtCursorMode", qre, mi);
H6e(Lo, mi);
const W6e = {
  wheel: "onWheel",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  long_press: "onLongPress",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  key_repeat: "onKeyRepeat",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick",
  tick: "onTick"
}, K6e = [
  "brushing",
  "cropping",
  "dragging",
  "dragging_handle",
  "drawing",
  "erasing",
  "lasering",
  "resizing",
  "rotating",
  "scribble_brushing",
  "translating"
];
class Xe {
  constructor(e, n) {
    P(this, "performanceTracker");
    P(this, "id");
    P(this, "type");
    P(this, "shapeType");
    P(this, "initial");
    P(this, "children");
    P(this, "isLockable");
    P(this, "useCoalescedEvents");
    P(this, "parent");
    P(this, "_path");
    P(this, "_current");
    P(this, "_isActive");
    /**
     * This is a hack / escape hatch that will tell the editor to
     * report a different state as active (in `getCurrentToolId()`) when
     * this state is active. This is usually used when a tool transitions
     * to a child of a different state for a certain interaction and then
     * returns to the original tool when that interaction completes; and
     * where we would want to show the original tool as active in the UI.
     *
     * @public
     */
    P(this, "_currentToolIdMask", yr("curent tool id mask", void 0));
    this.editor = e;
    const { id: r, children: s, initial: o, isLockable: i, useCoalescedEvents: a } = this.constructor;
    this.id = r, this._isActive = yr("toolIsActive" + this.id, !1), this._current = yr("toolState" + this.id, void 0), this._path = ve("toolPath" + this.id, () => {
      const c = this.getCurrent();
      return this.id + (c ? `.${c.getPath()}` : "");
    }), this.parent = n ?? {}, n ? s && o ? (this.type = "branch", this.initial = o, this.children = Object.fromEntries(
      s().map((c) => [c.id, new c(this.editor, this)])
    ), this._current.set(this.children[this.initial])) : this.type = "leaf" : (this.type = "root", s && o && (this.initial = o, this.children = Object.fromEntries(
      s().map((c) => [c.id, new c(this.editor, this)])
    ), this._current.set(this.children[this.initial]))), this.isLockable = i, this.useCoalescedEvents = a, this.performanceTracker = new OJ();
  }
  /**
   * This node's path of active state nodes
   *
   * @public
   */
  getPath() {
    return this._path.get();
  }
  /**
   * This node's current active child node, if any.
   *
   * @public
   */
  getCurrent() {
    return this._current.get();
  }
  /**
   * Whether this node is active.
   *
   * @public
   */
  getIsActive() {
    return this._isActive.get();
  }
  /**
   * Transition to a new active child state node.
   *
   * @example
   * ```ts
   * parentState.transition('childStateA')
   * parentState.transition('childStateB', { myData: 4 })
   *```
   *
   * @param id - The id of the child state node to transition to.
   * @param info - Any data to pass to the `onEnter` and `onExit` handlers.
   *
   * @public
   */
  transition(e, n = {}) {
    var o;
    const r = e.split(".");
    let s = this;
    for (let i = 0; i < r.length; i++) {
      const a = r[i], c = s.getCurrent(), l = (o = s.children) == null ? void 0 : o[a];
      if (!l)
        throw Error(`${s.id} - no child state exists with the id ${a}.`);
      if ((c == null ? void 0 : c.id) !== l.id && (c == null || c.exit(n, a), s._current.set(l), l.enter(n, (c == null ? void 0 : c.id) || "initial"), !l.getIsActive()))
        break;
      s = l;
    }
    return this;
  }
  handleEvent(e) {
    var s;
    const n = W6e[e.name], r = this._current.__unsafe__getWithoutCapture();
    (s = this[n]) == null || s.call(this, e), this._isActive.__unsafe__getWithoutCapture() && r && r === this._current.__unsafe__getWithoutCapture() && r.handleEvent(e);
  }
  // todo: move this logic into transition
  enter(e, n) {
    var r;
    if (ir.measurePerformance.get() && K6e.includes(this.id) && this.performanceTracker.start(this.id), this._isActive.set(!0), (r = this.onEnter) == null || r.call(this, e, n), this.children && this.initial && this.getIsActive()) {
      const s = this.children[this.initial];
      this._current.set(s), s.enter(e, n);
    }
  }
  // todo: move this logic into transition
  exit(e, n) {
    var r, s;
    ir.measurePerformance.get() && this.performanceTracker.isStarted() && this.performanceTracker.stop(), this._isActive.set(!1), (r = this.onExit) == null || r.call(this, e, n), this.getIsActive() || (s = this.getCurrent()) == null || s.exit(e, n);
  }
  getCurrentToolIdMask() {
    return this._currentToolIdMask.get();
  }
  setCurrentToolIdMask(e) {
    this._currentToolIdMask.set(e);
  }
  /**
   * Add a child node to this state node.
   *
   * @public
   */
  addChild(e) {
    if (this.type === "leaf")
      throw new Error("StateNode.addChild: cannot add child to a leaf node");
    this.children || (this.children = {});
    const n = new e(this.editor, this);
    if (this.children[n.id])
      throw new Error(`StateNode.addChild: a child with id '${n.id}' already exists`);
    return this.children[n.id] = n, this;
  }
}
P(Xe, "id"), P(Xe, "initial"), P(Xe, "children"), P(Xe, "isLockable", !0), P(Xe, "useCoalescedEvents", !1);
class pj extends Xe {
  static children() {
    return [];
  }
  onKeyDown(e) {
    var n;
    switch (e.code) {
      case "KeyZ": {
        if (!(e.shiftKey || e.ctrlKey)) {
          const r = this.getCurrent();
          r && ((n = r.getCurrent()) == null ? void 0 : n.id) === "idle" && this.children.zoom && this.editor.setCurrentTool("zoom", { ...e, onInteractionEnd: r.id });
        }
        break;
      }
    }
  }
}
P(pj, "id", "root"), P(pj, "initial", "");
var G6e = Object.create, cse = Object.defineProperty, Y6e = Object.getOwnPropertyDescriptor, lse = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), dse = (t) => {
  throw TypeError(t);
}, use = (t, e, n) => e in t ? cse(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, q6e = (t) => [, , , G6e((t == null ? void 0 : t[lse("metadata")]) ?? null)], fse = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], hse = (t) => t !== void 0 && typeof t != "function" ? dse("Function expected") : t, X6e = (t, e, n, r, s) => ({ kind: fse[t], name: e, metadata: r, addInitializer: (o) => n._ ? dse("Already initialized") : s.push(hse(o || null)) }), Z6e = (t, e) => use(e, lse("metadata"), t[3]), Q6e = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, Ue = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = fse[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, Y6e(s, n)), v = r.length - 1; v >= 0; v--)
    c = X6e(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, hse(i) && (m[g] = i);
  return m && cse(s, n, m), s;
}, rt = (t, e, n) => use(t, typeof e != "symbol" ? e + "" : e, n), pse, gse, mse, yse, vse, bse, xse, wse, Sse, Cse, _se, Ese, Tse, Pse, Ise, kse, Ase, Mse, Ose, Dse, Nse, jse, Rse, $se, Lse, Fse, Bse, zse, Use, Hse, Vse, Wse, Kse, Gse, Yse, qse, Xse, Zse, Qse, Jse, eoe, toe, noe, roe, soe, ooe, ioe, aoe, coe, loe, doe, uoe, foe, hoe, poe, goe, moe, yoe, voe, boe, xoe, woe, Soe, Coe, _oe, Eoe, Toe, Poe, Ioe, koe, Aoe, Moe, Ooe, gj, Be;
let Le = class extends (gj = dBe, Ooe = [ve], Moe = [ve], Aoe = [ve], koe = [ve], Ioe = [ve], Poe = [ve], Toe = [ve], Eoe = [ve], _oe = [ve], Coe = [ve], Soe = [ve], woe = [ve], xoe = [ve], boe = [ve], voe = [ve], yoe = [ve], moe = [ve], goe = [ve], poe = [ve], hoe = [ve], foe = [ve], uoe = [ve], doe = [ve], loe = [ve], coe = [ve], aoe = [ve], ioe = [ve], ooe = [ve], soe = [ve], roe = [ve], noe = [ve], toe = [ve], eoe = [ve], Jse = [ve], Qse = [ve], Zse = [ve], Xse = [ve], qse = [ve], Yse = [ve], Gse = [ve], Kse = [ve], Wse = [ve], Vse = [ve], Hse = [ve], Use = [ve], zse = [ve], Bse = [ve], Fse = [ve], Lse = [ve], $se = [ve], Rse = [ve], jse = [ve], Nse = [ve], Dse = [ve], Ose = [ve], Mse = [ve], Ase = [ve], kse = [ve], Ise = [ve], Pse = [ve], Tse = [ve], Ese = [ve], _se = [ve], Cse = [ve], Sse = [ve], wse = [ve({ isEqual: (e, n) => e.equals(n) })], xse = [ve], bse = [ve], vse = [ve], yse = [Li], mse = [Li], gse = [Li], pse = [Li], gj) {
  constructor({
    store: e,
    user: n,
    shapeUtils: r,
    bindingUtils: s,
    tools: o,
    getContainer: i,
    cameraOptions: a,
    textOptions: c,
    initialState: l,
    autoFocus: d,
    inferDarkMode: u,
    options: f,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    isShapeHidden: p,
    getShapeVisibility: g,
    fontAssetUrls: y
  }) {
    var D;
    super(), Q6e(Be, 5, this), rt(this, "id", bn()), rt(this, "_getShapeVisibility"), rt(this, "options"), rt(this, "contextId", bn()), rt(this, "store"), rt(this, "root"), rt(this, "disposables", /* @__PURE__ */ new Set()), rt(this, "isDisposed", !1), rt(this, "_tickManager"), rt(this, "snaps"), rt(this, "timers", fj.forContext(this.contextId)), rt(this, "user"), rt(this, "textMeasure"), rt(this, "fonts"), rt(this, "environment", dn), rt(this, "scribbles"), rt(this, "sideEffects"), rt(this, "edgeScrollManager"), rt(this, "focusManager"), rt(this, "getContainer"), rt(this, "shapeUtils"), rt(this, "styleProps"), rt(this, "bindingUtils"), rt(this, "history"), rt(this, "_shouldIgnoreShapeLock", !1), rt(this, "_crashingError", null), rt(this, "_isChangingStyleTimeout", -1), rt(this, "menus", ni.forContext(this.contextId)), rt(this, "_currentRichTextEditor", yr("rich text editor", null)), rt(this, "_textOptions"), rt(this, "_cameraOptions", yr("camera options", X8)), rt(this, "_viewportAnimation", null), rt(this, "_willSetInitialBounds", !0), rt(this, "_isLockedOnFollowingUser", yr("isLockedOnFollowingUser", !1)), rt(this, "_cameraState", yr("camera state", "idle")), rt(this, "_cameraStateTimeoutRemaining", 0), rt(this, "_currentPageShapeIds"), rt(this, "_shapeGeometryCaches", {}), rt(this, "_notVisibleShapes", Nze(this)), rt(this, "_parentIdsToChildIds"), rt(this, "animatingShapes", /* @__PURE__ */ new Map()), rt(this, "externalAssetContentHandlers", {
      file: null,
      url: null
    }), rt(this, "temporaryAssetPreview", /* @__PURE__ */ new Map()), rt(this, "externalContentHandlers", {
      text: null,
      files: null,
      "file-replace": null,
      embed: null,
      "svg-text": null,
      url: null,
      tldraw: null,
      excalidraw: null
    }), rt(this, "inputs", {
      /** The most recent pointer down's position in the current page space. */
      originPagePoint: new I(),
      /** The most recent pointer down's position in screen space. */
      originScreenPoint: new I(),
      /** The previous pointer position in the current page space. */
      previousPagePoint: new I(),
      /** The previous pointer position in screen space. */
      previousScreenPoint: new I(),
      /** The most recent pointer position in the current page space. */
      currentPagePoint: new I(),
      /** The most recent pointer position in screen space. */
      currentScreenPoint: new I(),
      /** A set containing the currently pressed keys. */
      keys: /* @__PURE__ */ new Set(),
      /** A set containing the currently pressed buttons. */
      buttons: /* @__PURE__ */ new Set(),
      /** Whether the input is from a pe. */
      isPen: !1,
      /** Whether the shift key is currently pressed. */
      shiftKey: !1,
      /** Whether the meta key is currently pressed. */
      metaKey: !1,
      /** Whether the control or command key is currently pressed. */
      ctrlKey: !1,
      /** Whether the alt or option key is currently pressed. */
      altKey: !1,
      /** Whether the user is dragging. */
      isDragging: !1,
      /** Whether the user is pointing. */
      isPointing: !1,
      /** Whether the user is pinching. */
      isPinching: !1,
      /** Whether the user is editing. */
      isEditing: !1,
      /** Whether the user is panning. */
      isPanning: !1,
      /** Whether the user is spacebar panning. */
      isSpacebarPanning: !1,
      /** Velocity of mouse pointer, in pixels per millisecond */
      pointerVelocity: new I()
    }), rt(this, "_clickManager", new VI(this)), rt(this, "_prevCursor", "default"), rt(this, "_shiftKeyTimeout", -1), rt(this, "_altKeyTimeout", -1), rt(this, "_ctrlKeyTimeout", -1), rt(this, "_metaKeyTimeout", -1), rt(this, "_restoreToolId", "select"), rt(this, "_pinchStart", 1), rt(this, "_didPinch", !1), rt(this, "_selectedShapeIdsAtPointerDown", []), rt(this, "_longPressTimeout", -1), rt(this, "capturedPointerId", null), rt(this, "performanceTracker"), rt(this, "performanceTrackerTimeout", -1), rt(this, "_pendingEventsForNextTick", []), tt(
      !(p && g),
      "Cannot use both isShapeHidden and getShapeVisibility"
    ), this._getShapeVisibility = p ? (
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      (k, A) => p(k, A) ? "hidden" : "inherit"
    ) : g, this.options = { ...wze, ...f }, this.store = e, this.history = new Yze({
      store: e,
      annotateError: (k) => {
        this.annotateError(k, { origin: "history.batch", willCrashApp: !0 }), this.crash(k);
      }
    }), this.snaps = new tS(this), this.disposables.add(this.timers.dispose), this._cameraOptions.set({ ...X8, ...a }), this._textOptions = yr("text options", c ?? null), this.user = new mi(n ?? wne(), u ?? !1), this.disposables.add(() => this.user.dispose()), this.getContainer = i, this.textMeasure = new A6e(this), this.disposables.add(() => this.textMeasure.dispose()), this.fonts = new Gze(this, y), this._tickManager = new GI(this);
    class m extends pj {
    }
    P(m, "initial", l ?? ""), this.root = new m(this), this.root.children = {};
    const v = One(r), b = {}, x = {}, w = /* @__PURE__ */ new Map();
    for (const k of v) {
      const A = new k(this);
      b[k.type] = A;
      const R = vte(k.props ?? {});
      x[k.type] = R;
      for (const j of R.keys())
        if (!w.has(j.id))
          w.set(j.id, j);
        else if (w.get(j.id) !== j)
          throw Error(
            `Multiple style props with id "${j.id}" in use. Style prop IDs must be unique.`
          );
    }
    this.shapeUtils = b, this.styleProps = x;
    const S = Pne(s), C = {};
    for (const k of S) {
      const A = new k(this);
      C[k.type] = A;
    }
    this.bindingUtils = C;
    for (const k of [...o]) {
      if (rc(this.root.children, k.id))
        throw Error(`Can't override tool with id "${k.id}"`);
      this.root.children[k.id] = new k(this, this.root);
    }
    this.scribbles = new Jze(this);
    const _ = (k, A) => {
      let R = null;
      const j = k.selectedShapeIds.filter(
        (L) => !A.has(L)
      );
      j.length !== k.selectedShapeIds.length && (R || (R = { ...k }), R.selectedShapeIds = j);
      const $ = k.erasingShapeIds.filter(
        (L) => !A.has(L)
      );
      $.length !== k.erasingShapeIds.length && (R || (R = { ...k }), R.erasingShapeIds = $), k.hoveredShapeId && A.has(k.hoveredShapeId) && (R || (R = { ...k }), R.hoveredShapeId = null), k.editingShapeId && A.has(k.editingShapeId) && (R || (R = { ...k }), R.editingShapeId = null);
      const F = k.hintingShapeIds.filter(
        (L) => !A.has(L)
      );
      return F.length !== k.hintingShapeIds.length && (R || (R = { ...k }), R.hintingShapeIds = F), k.focusedGroupId && A.has(k.focusedGroupId) && (R || (R = { ...k }), R.focusedGroupId = null), R;
    };
    this.sideEffects = this.store.sideEffects;
    let E = /* @__PURE__ */ new Map();
    const M = /* @__PURE__ */ new Set(), N = /* @__PURE__ */ new Set();
    let O = /* @__PURE__ */ new Set();
    if (this.disposables.add(
      this.sideEffects.registerOperationCompleteHandler(() => {
        var k, A, R, j;
        M.clear();
        for (const $ of N) {
          N.delete($);
          const F = this.getShape($);
          if (!F) continue;
          const L = this.getShapeUtil(F), z = (k = L.onChildrenChange) == null ? void 0 : k.call(L, F);
          z != null && z.length && this.updateShapes(z);
        }
        if (O.size) {
          const $ = O;
          O = /* @__PURE__ */ new Set();
          for (const F of $) {
            const L = this.getBindingUtil(F);
            (A = L.onOperationComplete) == null || A.call(L);
          }
        }
        if (E.size) {
          const $ = E;
          E = /* @__PURE__ */ new Map();
          for (const F of $.values())
            (j = (R = this.getBindingUtil(F.binding)).onAfterDelete) == null || j.call(R, F);
        }
        this.emit("update");
      })
    ), this.disposables.add(
      this.sideEffects.register({
        shape: {
          afterChange: (k, A) => {
            var R, j, $, F;
            for (const L of this.getBindingsInvolvingShape(A))
              O.add(L.type), L.fromId === A.id && ((j = (R = this.getBindingUtil(L)).onAfterChangeFromShape) == null || j.call(R, {
                binding: L,
                shapeBefore: k,
                shapeAfter: A,
                reason: "self"
              })), L.toId === A.id && ((F = ($ = this.getBindingUtil(L)).onAfterChangeToShape) == null || F.call($, {
                binding: L,
                shapeBefore: k,
                shapeAfter: A,
                reason: "self"
              }));
            if (k.parentId !== A.parentId) {
              const L = (z) => {
                var U, W, Z, K;
                const H = this.getShape(z);
                if (H)
                  for (const oe of this.getBindingsInvolvingShape(H))
                    O.add(oe.type), oe.fromId === H.id && ((W = (U = this.getBindingUtil(oe)).onAfterChangeFromShape) == null || W.call(U, {
                      binding: oe,
                      shapeBefore: H,
                      shapeAfter: H,
                      reason: "ancestry"
                    })), oe.toId === H.id && ((K = (Z = this.getBindingUtil(oe)).onAfterChangeToShape) == null || K.call(Z, {
                      binding: oe,
                      shapeBefore: H,
                      shapeAfter: H,
                      reason: "ancestry"
                    }));
              };
              L(A.id), this.visitDescendants(A.id, L);
            }
            if (k.parentId !== A.parentId && Ys(A.parentId)) {
              const L = /* @__PURE__ */ new Set([k.id]);
              this.visitDescendants(k.id, (z) => {
                L.add(z);
              });
              for (const z of this.getPageStates()) {
                if (z.pageId === A.parentId) continue;
                const H = _(z, L);
                H && this.store.put([H]);
              }
            }
            k.parentId && ei(k.parentId) && N.add(k.parentId), A.parentId !== k.parentId && ei(A.parentId) && N.add(A.parentId);
          },
          beforeDelete: (k) => {
            var $, F, L, z;
            if (M.has(k.id)) return;
            k.parentId && ei(k.parentId) && N.add(k.parentId), M.add(k.id);
            const A = [];
            for (const H of this.getBindingsInvolvingShape(k)) {
              O.add(H.type), A.push(H.id);
              const U = this.getBindingUtil(H);
              H.fromId === k.id ? (($ = U.onBeforeIsolateToShape) == null || $.call(U, { binding: H, removedShape: k }), (F = U.onBeforeDeleteFromShape) == null || F.call(U, { binding: H, shape: k })) : ((L = U.onBeforeIsolateFromShape) == null || L.call(U, { binding: H, removedShape: k }), (z = U.onBeforeDeleteToShape) == null || z.call(U, { binding: H, shape: k }));
            }
            A.length && this.deleteBindings(A);
            const R = /* @__PURE__ */ new Set([k.id]), j = mt(
              this.getPageStates().map((H) => _(H, R))
            );
            j.length && this.store.put(j);
          }
        },
        binding: {
          beforeCreate: (k) => {
            var R, j;
            const A = (j = (R = this.getBindingUtil(k)).onBeforeCreate) == null ? void 0 : j.call(R, { binding: k });
            return A || k;
          },
          afterCreate: (k) => {
            var A, R;
            O.add(k.type), (R = (A = this.getBindingUtil(k)).onAfterCreate) == null || R.call(A, { binding: k });
          },
          beforeChange: (k, A) => {
            var j, $;
            const R = ($ = (j = this.getBindingUtil(A)).onBeforeChange) == null ? void 0 : $.call(j, {
              bindingBefore: k,
              bindingAfter: A
            });
            return R || A;
          },
          afterChange: (k, A) => {
            var R, j;
            O.add(A.type), (j = (R = this.getBindingUtil(A)).onAfterChange) == null || j.call(R, { bindingBefore: k, bindingAfter: A });
          },
          beforeDelete: (k) => {
            var A, R;
            (R = (A = this.getBindingUtil(k)).onBeforeDelete) == null || R.call(A, { binding: k });
          },
          afterDelete: (k) => {
            var A, R;
            (R = (A = this.getBindingUtil(k)).onAfterDelete) == null || R.call(A, { binding: k }), O.add(k.type);
          }
        },
        page: {
          afterCreate: (k) => {
            const A = Rl.createId(k.id), R = Uc.createId(k.id);
            this.store.has(A) || this.store.put([Rl.create({ id: A })]), this.store.has(R) || this.store.put([
              Uc.create({ id: R, pageId: k.id })
            ]);
          },
          afterDelete: (k, A) => {
            var $, F;
            if ((($ = this.getInstanceState()) == null ? void 0 : $.currentPageId) === k.id) {
              const L = (F = this.getPages().find((z) => z.id !== k.id)) == null ? void 0 : F.id;
              L ? this.store.put([{ ...this.getInstanceState(), currentPageId: L }]) : A === "user" && this.store.ensureStoreIsUsable();
            }
            const R = Rl.createId(k.id), j = Uc.createId(k.id);
            this.store.remove([R, j]);
          }
        },
        instance: {
          afterChange: (k, A, R) => {
            var j;
            if (!this.store.has(A.currentPageId)) {
              const $ = this.store.has(k.currentPageId) ? k.currentPageId : (j = this.getPages()[0]) == null ? void 0 : j.id;
              $ ? this.store.update(A.id, (F) => ({
                ...F,
                currentPageId: $
              })) : R === "user" && this.store.ensureStoreIsUsable();
            }
          }
        },
        instance_page_state: {
          afterChange: (k, A) => {
            if ((k == null ? void 0 : k.selectedShapeIds) !== (A == null ? void 0 : A.selectedShapeIds)) {
              const R = A.selectedShapeIds.filter(($) => {
                var L, z;
                let F = (L = this.getShape($)) == null ? void 0 : L.parentId;
                for (; ei(F); ) {
                  if (A.selectedShapeIds.includes(F))
                    return !1;
                  F = (z = this.getShape(F)) == null ? void 0 : z.parentId;
                }
                return !0;
              });
              let j = null;
              if (R.length > 0) {
                const $ = this.findCommonAncestor(
                  mt(R.map((F) => this.getShape(F))),
                  (F) => this.isShapeOfType(F, "group")
                );
                $ && (j = $);
              } else
                A != null && A.focusedGroupId && (j = A.focusedGroupId);
              (R.length !== A.selectedShapeIds.length || j !== A.focusedGroupId) && this.store.put([
                {
                  ...A,
                  selectedShapeIds: R,
                  focusedGroupId: j ?? null
                }
              ]);
            }
          }
        }
      })
    ), this._currentPageShapeIds = Rze(
      this.store,
      () => this.getCurrentPageId()
    ), this._parentIdsToChildIds = jze(this.store), this.disposables.add(
      this.store.listen((k) => {
        this.emit("change", k);
      })
    ), this.disposables.add(this.history.dispose), this.run(
      () => {
        this.store.ensureStoreIsUsable(), this._updateCurrentPageState({
          editingShapeId: null,
          hoveredShapeId: null,
          erasingShapeIds: []
        });
      },
      { history: "ignore" }
    ), l && this.root.children[l] === void 0)
      throw Error(`No state found for initialState "${l}".`);
    if (this.root.enter(void 0, "initial"), this.edgeScrollManager = new Wze(this), this.focusManager = new Kze(this, d), this.disposables.add(this.focusManager.dispose.bind(this.focusManager)), this.getInstanceState().followingUserId && this.stopFollowingUser(), this.on("tick", this._flushEventsForTick), this.timers.requestAnimationFrame(() => {
      this._tickManager.start();
    }), this.performanceTracker = new OJ(), (D = this.store.props.collaboration) != null && D.mode) {
      const k = this.store.props.collaboration.mode;
      this.disposables.add(
        ya("update collaboration mode", () => {
          this.store.put([{ ...this.getInstanceState(), isReadonly: k.get() === "readonly" }]);
        })
      );
    }
  }
  getIsShapeHiddenCache() {
    return this._getShapeVisibility ? this.store.createComputedCache("isShapeHidden", (e) => {
      const n = this._getShapeVisibility(e, this);
      return (ci.isId(e.parentId) ? !1 : this.isShapeHidden(e.parentId)) ? n !== "visible" : n === "hidden";
    }) : null;
  }
  isShapeHidden(e) {
    return this._getShapeVisibility ? !!this.getIsShapeHiddenCache().get(
      typeof e == "string" ? e : e.id
    ) : !1;
  }
  /**
   * Dispose the editor.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((e) => e()), this.disposables.clear(), this.store.dispose(), this.isDisposed = !0;
  }
  getShapeUtil(e) {
    const n = typeof e == "string" ? e : e.type, r = Fr(this.shapeUtils, n);
    return tt(r, `No shape util found for type "${n}"`), r;
  }
  hasShapeUtil(e) {
    const n = typeof e == "string" ? e : e.type;
    return rc(this.shapeUtils, n);
  }
  getBindingUtil(e) {
    const n = typeof e == "string" ? e : e.type, r = Fr(this.bindingUtils, n);
    return tt(r, `No binding util found for type "${n}"`), r;
  }
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * editor.undo()
   * ```
   *
   * @public
   */
  undo() {
    return this._flushEventsForTick(0), this.complete(), this.history.undo(), this;
  }
  getCanUndo() {
    return this.history.getNumUndos() > 0;
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * editor.redo()
   * ```
   *
   * @public
   */
  redo() {
    return this._flushEventsForTick(0), this.complete(), this.history.redo(), this;
  }
  clearHistory() {
    return this.history.clear(), this;
  }
  getCanRedo() {
    return this.history.getNumRedos() > 0;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos.
   *
   * @example
   * ```ts
   * editor.mark()
   * editor.mark('flip shapes')
   * ```
   *
   * @param markId - The mark's id, usually the reason for adding the mark.
   *
   * @public
   * @deprecated use {@link Editor.markHistoryStoppingPoint} instead
   */
  mark(e) {
    return console.warn(
      typeof e == "string" ? `[tldraw] \`editor.history.mark("${e}")\` is deprecated. Please use \`const myMarkId = editor.markHistoryStoppingPoint()\` instead.` : "[tldraw] `editor.mark()` is deprecated. Use `editor.markHistoryStoppingPoint()` instead."
    ), this.history._mark(e ?? bn()), this;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos. You typically want to do this just before a user interaction begins or is handled.
   *
   * @example
   * ```ts
   * editor.markHistoryStoppingPoint()
   * editor.flipShapes(editor.getSelectedShapes())
   * ```
   * @example
   * ```ts
   * const beginRotateMark = editor.markHistoryStoppingPoint()
   * // if the use cancels the rotation, you can bail back to this mark
   * editor.bailToMark(beginRotateMark)
   * ```
   *
   * @public
   * @param name - The name of the mark, useful for debugging the undo/redo stacks
   * @returns a unique id for the mark that can be used with `squashToMark` or `bailToMark`.
   */
  markHistoryStoppingPoint(e) {
    const n = `[${e ?? "stop"}]_${bn()}`;
    return this.history._mark(n), n;
  }
  /**
   * @internal this is only used to implement some backwards-compatibility logic. Should be fine to delete after 6 months or whatever.
   */
  getMarkIdMatching(e) {
    return this.history.getMarkIdMatching(e);
  }
  /**
   * Coalesces all changes since the given mark into a single change, removing any intermediate marks.
   *
   * This is useful if you need to 'compress' the recent history to simplify the undo/redo experience of a complex interaction.
   *
   * @example
   * ```ts
   * const bumpShapesMark = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.squashToMark(bumpShapesMark)
   * ```
   *
   * @param markId - The mark id to squash to.
   */
  squashToMark(e) {
    return this.history.squashToMark(e), this;
  }
  /**
   * Undo to the closest mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * editor.bail()
   * ```
   *
   * @public
   */
  bail() {
    return this.history.bail(), this;
  }
  /**
   * Undo to the given mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * const beginDrag = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.bailToMark(beginDrag)
   * ```
   *
   * @public
   */
  bailToMark(e) {
    return this.history.bailToMark(e), this;
  }
  /**
   * Run a function in a transaction with optional options for context.
   * You can use the options to change the way that history is treated
   * or allow changes to locked shapes.
   *
   * @example
   * ```ts
   * // updating with
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * }, { history: "ignore" })
   *
   * // forcing changes / deletions for locked shapes
   * editor.toggleLock([myShape])
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * 	editor.deleteShape(myShape)
   * }, { ignoreShapeLock: true }, )
   * ```
   *
   * @param fn - The callback function to run.
   * @param opts - The options for the batch.
   *
   *
   * @public
   */
  run(e, n) {
    const r = this._shouldIgnoreShapeLock;
    this._shouldIgnoreShapeLock = (n == null ? void 0 : n.ignoreShapeLock) ?? r;
    try {
      this.history.batch(e, n);
    } finally {
      this._shouldIgnoreShapeLock = r;
    }
    return this;
  }
  /**
   * @deprecated Use `Editor.run` instead.
   */
  batch(e, n) {
    return this.run(e, n);
  }
  /* --------------------- Errors --------------------- */
  /** @internal */
  annotateError(e, {
    origin: n,
    willCrashApp: r,
    tags: s,
    extras: o
  }) {
    const i = this.createErrorAnnotations(n, r);
    return dF(e, {
      tags: { ...i.tags, ...s },
      extras: { ...i.extras, ...o }
    }), r && this.store.markAsPossiblyCorrupted(), this;
  }
  /** @internal */
  createErrorAnnotations(e, n) {
    try {
      const r = this.getEditingShapeId();
      return {
        tags: {
          origin: e,
          willCrashApp: n
        },
        extras: {
          activeStateNode: this.root.getPath(),
          selectedShapes: this.getSelectedShapes().map((s) => {
            const { props: o, ...i } = s, { text: a, richText: c, ...l } = o;
            return {
              ...i,
              props: l
            };
          }),
          selectionCount: this.getSelectedShapes().length,
          editingShape: r ? this.getShape(r) : void 0,
          inputs: this.inputs,
          pageState: this.getCurrentPageState(),
          instanceState: this.getInstanceState(),
          collaboratorCount: this.getCollaboratorsOnCurrentPage().length
        }
      };
    } catch {
      return {
        tags: {
          origin: e,
          willCrashApp: n
        },
        extras: {}
      };
    }
  }
  /**
   * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
   * we're in a transaction that's about to be rolled back due to the same error we're currently
   * reporting.
   *
   * Instead, to listen to changes to this value, you need to listen to app's `crash` event.
   *
   * @internal
   */
  getCrashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(e) {
    return this._crashingError = e, this.store.markAsPossiblyCorrupted(), this.emit("crash", { error: e }), this;
  }
  getPath() {
    return this.root.getPath().split("root.")[1];
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * editor.isIn('select')
   * editor.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   *
   * @public
   */
  isIn(e) {
    const n = e.split(".").reverse();
    let r = this.root;
    for (; n.length > 0; ) {
      const s = n.pop();
      if (!s) return !0;
      const o = r.getCurrent();
      if ((o == null ? void 0 : o.id) === s) {
        if (n.length === 0) return !0;
        r = o;
        continue;
      } else return !1;
    }
    return !1;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * state.isInAny('select', 'erase')
   * state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...e) {
    return e.some((n) => this.isIn(n));
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * editor.setCurrentTool('hand')
   * editor.setCurrentTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   *
   * @public
   */
  setCurrentTool(e, n = {}) {
    return this.root.transition(e, n), this;
  }
  getCurrentTool() {
    return this.root.getCurrent();
  }
  getCurrentToolId() {
    const e = this.getCurrentTool();
    return e ? e.getCurrentToolIdMask() ?? e.id : "";
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * editor.getStateDescendant('select')
   * editor.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   *
   * @public
   */
  getStateDescendant(e) {
    var s;
    const n = e.split(".").reverse();
    let r = this.root;
    for (; n.length > 0; ) {
      const o = n.pop();
      if (!o) return r;
      const i = (s = r.children) == null ? void 0 : s[o];
      if (!i) return;
      r = i;
    }
    return r;
  }
  getDocumentSettings() {
    return this.store.get(rj);
  }
  /**
   * Update the global document settings that apply to all users.
   *
   * @public
   **/
  updateDocumentSettings(e) {
    return this.run(
      () => {
        this.store.put([{ ...this.getDocumentSettings(), ...e }]);
      },
      { history: "ignore" }
    ), this;
  }
  getInstanceState() {
    return this.store.get(ti);
  }
  /**
   * Update the instance's state.
   *
   * @param partial - A partial object to update the instance state with.
   * @param historyOptions - History batch options.
   *
   * @public
   */
  updateInstanceState(e, n) {
    return this._updateInstanceState(e, { history: "ignore", ...n }), e.isChangingStyle !== void 0 && (clearTimeout(this._isChangingStyleTimeout), e.isChangingStyle === !0 && (this._isChangingStyleTimeout = this.timers.setTimeout(() => {
      this._updateInstanceState({ isChangingStyle: !1 }, { history: "ignore" });
    }, 1e3))), this;
  }
  /** @internal */
  _updateInstanceState(e, n) {
    this.run(() => {
      this.store.put([
        {
          ...this.getInstanceState(),
          ...e
        }
      ]);
    }, n);
  }
  getOpenMenus() {
    return this.menus.getOpenMenus();
  }
  /**
   * @deprecated Use `editor.menus.addOpenMenu` instead.
   *
   * @public
   */
  addOpenMenu(e) {
    return this.menus.addOpenMenu(e), this;
  }
  /**
   * @deprecated Use `editor.menus.deleteOpenMenu` instead.
   *
   * @public
   */
  deleteOpenMenu(e) {
    return this.menus.deleteOpenMenu(e), this;
  }
  /**
   * @deprecated Use `editor.menus.clearOpenMenus` instead.
   *
   * @public
   */
  clearOpenMenus() {
    return this.menus.clearOpenMenus(), this;
  }
  getIsMenuOpen() {
    return this.menus.hasAnyOpenMenus();
  }
  /* --------------------- Cursor --------------------- */
  /**
   * Set the cursor.
   *
   * @param cursor - The cursor to set.
   * @public
   */
  setCursor(e) {
    return this.updateInstanceState({ cursor: { ...this.getInstanceState().cursor, ...e } }), this;
  }
  getPageStates() {
    return this._getPageStatesQuery().get();
  }
  _getPageStatesQuery() {
    return this.store.query.records("instance_page_state");
  }
  getCurrentPageState() {
    return this.store.get(this._getCurrentPageStateId());
  }
  _getCurrentPageStateId() {
    return Uc.createId(this.getCurrentPageId());
  }
  /**
   * Update this instance's page state.
   *
   * @example
   * ```ts
   * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' })
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   *
   * @public
   */
  updateCurrentPageState(e) {
    return this._updateCurrentPageState(e), this;
  }
  _updateCurrentPageState(e) {
    this.store.update(e.id ?? this.getCurrentPageState().id, (n) => ({
      ...n,
      ...e
    }));
  }
  getSelectedShapeIds() {
    return this.getCurrentPageState().selectedShapeIds;
  }
  getSelectedShapes() {
    return mt(this.getSelectedShapeIds().map((e) => this.store.get(e)));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.setSelectedShapes(['id1'])
   * editor.setSelectedShapes(['id1', 'id2'])
   * ```
   *
   * @param shapes - The shape (or shape ids) to select.
   *
   * @public
   */
  setSelectedShapes(e) {
    return this.run(
      () => {
        const n = e.map((o) => typeof o == "string" ? o : o.id), { selectedShapeIds: r } = this.getCurrentPageState(), s = new Set(r);
        if (n.length === s.size && n.every((o) => s.has(o))) return null;
        this.store.put([{ ...this.getCurrentPageState(), selectedShapeIds: n }]);
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Determine whether or not any of a shape's ancestors are selected.
   *
   * @param shape - The shape (or shape id) of the shape to check.
   *
   * @public
   */
  isAncestorSelected(e) {
    const n = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null, r = this.getShape(n);
    if (!r) return !1;
    const s = this.getSelectedShapeIds();
    return !!this.findShapeAncestor(r, (o) => s.includes(o.id));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.select('id1')
   * editor.select('id1', 'id2')
   * ```
   *
   * @param shapes - The shape (or the shape ids) to select.
   *
   * @public
   */
  select(...e) {
    const n = typeof e[0] == "string" ? e : e.map((r) => r.id);
    return this.setSelectedShapes(n), this;
  }
  /**
   * Remove a shape from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * editor.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...e) {
    const n = typeof e[0] == "string" ? e : e.map((s) => s.id), r = this.getSelectedShapeIds();
    return r.length > 0 && n.length > 0 && this.setSelectedShapes(r.filter((s) => !n.includes(s))), this;
  }
  /**
   * Select all shapes. If the user has selected shapes that share a parent,
   * select all shapes within that parent. If the user has not selected any shapes,
   * or if the shapes shapes are only on select all shapes on the current page.
   *
   * @example
   * ```ts
   * editor.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    let e = null;
    const n = this.getSelectedShapeIds();
    if (n.length > 0)
      for (const s of n) {
        const o = this.getShape(s);
        if (o) {
          if (e === null)
            e = o.parentId;
          else if (e !== o.parentId)
            return this;
        }
      }
    e || (e = this.getCurrentPageId());
    const r = this.getSortedChildIdsForParent(e);
    return r.length <= 0 ? this : (this.setSelectedShapes(this._getUnlockedShapeIds(r)), this);
  }
  /**
   * Select the next shape in the reading order or in cardinal order.
   *
   * @example
   * ```ts
   * editor.selectAdjacentShape('next')
   * ```
   *
   * @public
   */
  selectAdjacentShape(e) {
    var d, u;
    const n = this.getSelectedShapeIds(), r = n[0] ? (d = this.getShape(n[0])) == null ? void 0 : d.parentId : null, s = r && n.every((f) => {
      var p;
      return ((p = this.getShape(f)) == null ? void 0 : p.parentId) === r;
    }) && !Ys(r), o = s ? this.getCurrentPageShapes().filter((f) => f.parentId === r) : this.getCurrentPageShapes().filter((f) => Ys(f.parentId)), i = s ? this._getShapesInReadingOrder(o) : this.getCurrentPageShapesInReadingOrder(), a = n.length === 1 ? n[0] : (u = i.find((f) => n.includes(f.id))) == null ? void 0 : u.id;
    let c;
    if (e === "next" || e === "prev") {
      const f = i.map((y) => y.id), g = ((a ? f.indexOf(a) : -1) + (e === "next" ? 1 : -1) + f.length) % f.length;
      c = f[g];
    } else {
      if (!a) return;
      c = this.getNearestAdjacentShape(o, a, e);
    }
    const l = this.getShape(c);
    l && this._selectShapesAndZoom([l.id]);
  }
  getCurrentPageShapesInReadingOrder() {
    const e = this.getCurrentPageShapes().filter((n) => Ys(n.parentId));
    return this._getShapesInReadingOrder(e);
  }
  _getShapesInReadingOrder(e) {
    const s = e.filter((a) => this.getShapeUtil(a).canTabTo(a));
    if (s.length <= 1) return s;
    const o = s.map((a) => ({
      shape: a,
      center: this.getShapePageBounds(a).center
    }));
    o.sort((a, c) => a.center.y - c.center.y);
    const i = [];
    for (const a of o) {
      let c = -1;
      for (let l = i.length - 1; l >= 0; l--) {
        const d = i[l], u = d[d.length - 1];
        if (Math.abs(a.center.y - u.center.y) < 100) {
          c = l;
          break;
        }
      }
      c === -1 ? i.push([a]) : i[c].push(a);
    }
    for (const a of i)
      a.sort((c, l) => c.center.x - l.center.x);
    for (const a of i)
      if (!(a.length <= 2))
        for (let c = 0; c < a.length - 2; c++) {
          const l = a[c], d = a[c + 1], u = a[c + 2], f = I.Dist2(l.center, d.center);
          I.Dist2(l.center, u.center) < f * 0.9 && Math.abs(
            I.Angle(l.center, u.center) * (180 / Math.PI)
          ) <= 20 && ([a[c + 1], a[c + 2]] = [a[c + 2], a[c + 1]]);
        }
    return i.flat().map((a) => a.shape);
  }
  /**
   * Find the nearest adjacent shape in a specific direction.
   *
   * @public
   */
  getNearestAdjacentShape(e, n, r) {
    const s = { right: 0, left: 180, down: 90, up: 270 }, o = this.getShape(n);
    if (!o) return n;
    const i = e.filter(
      (u) => this.getShapeUtil(u).canTabTo(u) && u.id !== n
    );
    if (!i.length) return n;
    const a = this.getShapePageBounds(o).center, l = i.map((u) => ({
      shape: u,
      center: this.getShapePageBounds(u).center
    })).filter(({ center: u }) => {
      const f = u.x > a.x, p = u.y > a.y, g = u.x - a.x, y = u.y - a.y, m = Math.abs(y) < Math.abs(g) * 2, v = Math.abs(g) < Math.abs(y) * 2;
      if (r === "left" || r === "right")
        return m && (r === "right" ? f : !f);
      if (r === "up" || r === "down")
        return v && (r === "down" ? p : !p);
    });
    return l.length === 0 ? n : _J(l, ({ center: u }) => {
      const f = I.Dist2(a, u), p = ["left", "right"].includes(r) ? "x" : "y", g = Math.abs(u[p] - a[p]), y = ["left", "right"].includes(r) ? "y" : "x", m = Math.abs(u[y] - a[y]), v = Math.abs(I.Angle(a, u) * (180 / Math.PI)), b = Math.abs(v - s[r]);
      return f * 1 + // Base distance
      m * 2 + // Heavy penalty for off-axis deviation
      (f - g) * 1.5 + // Penalty for diagonal distance
      b * 0.5;
    }).shape.id;
  }
  selectParentShape() {
    const e = this.getOnlySelectedShape();
    if (!e) return;
    const n = this.getShape(e.parentId);
    n && this._selectShapesAndZoom([n.id]);
  }
  selectFirstChildShape() {
    const e = this.getSelectedShapes();
    if (!e.length) return;
    const n = e[0], r = this.getSortedChildIdsForParent(n.id).map((o) => this.getShape(o)).filter((o) => o), s = this._getShapesInReadingOrder(r);
    s.length !== 0 && this._selectShapesAndZoom([s[0].id]);
  }
  _selectShapesAndZoom(e) {
    this.setSelectedShapes(e), this.zoomToSelectionIfOffscreen(256, {
      animation: {
        duration: this.options.animationMediumMs
      },
      inset: 0
    });
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * editor.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    return this.getSelectedShapeIds().length > 0 && this.setSelectedShapes([]), this;
  }
  getOnlySelectedShapeId() {
    var e;
    return ((e = this.getOnlySelectedShape()) == null ? void 0 : e.id) ?? null;
  }
  getOnlySelectedShape() {
    const e = this.getSelectedShapes();
    return e.length === 1 ? e[0] : null;
  }
  /**
   * @internal
   */
  getShapesPageBounds(e) {
    const n = mt(e.map((r) => this.getShapePageBounds(r)));
    return n.length === 0 ? null : _e.Common(n);
  }
  getSelectionPageBounds() {
    return this.getShapesPageBounds(this.getSelectedShapeIds());
  }
  /**
   * The bounds of the selection bounding box in the current page space.
   *
   * @readonly
   * @public
   */
  getSelectionScreenBounds() {
    const e = this.getSelectionPageBounds();
    if (!e) return;
    const { x: n, y: r } = this.pageToScreen(e.point), s = this.getZoomLevel();
    return new _e(n, r, e.width * s, e.height * s);
  }
  /**
   * @internal
   */
  getShapesSharedRotation(e) {
    let n = !1, r = 0;
    for (let s = 0, o = e.length; s < o; s++) {
      const i = this.getShapePageTransform(e[s]);
      if (i)
        if (n) {
          if (i.rotation() !== r)
            return 0;
        } else
          n = !0, r = i.rotation();
    }
    return r;
  }
  getSelectionRotation() {
    return this.getShapesSharedRotation(this.getSelectedShapeIds());
  }
  /**
   * @internal
   */
  getShapesRotatedPageBounds(e) {
    if (e.length === 0)
      return;
    const n = this.getShapesSharedRotation(e);
    if (n === 0)
      return this.getShapesPageBounds(e) ?? void 0;
    if (e.length === 1) {
      const s = this.getShapeGeometry(e[0]).bounds.clone(), o = this.getShapePageTransform(e[0]);
      return s.point = o.applyToPoint(s.point), s;
    }
    const r = _e.FromPoints(
      e.flatMap((s) => {
        const o = this.getShapePageTransform(s);
        return o ? o.applyToPoints(this.getShapeGeometry(s).bounds.corners) : [];
      }).map((s) => s.rot(-n))
    );
    return r.point = r.point.rot(n), r;
  }
  getSelectionRotatedPageBounds() {
    return this.getShapesRotatedPageBounds(this.getSelectedShapeIds());
  }
  getSelectionRotatedScreenBounds() {
    const e = this.getSelectionRotatedPageBounds();
    if (!e) return;
    const { x: n, y: r } = this.pageToScreen(e.point), s = this.getZoomLevel();
    return new _e(n, r, e.width * s, e.height * s);
  }
  getFocusedGroupId() {
    return this.getCurrentPageState().focusedGroupId ?? this.getCurrentPageId();
  }
  getFocusedGroup() {
    const e = this.getFocusedGroupId();
    return e ? this.getShape(e) : void 0;
  }
  /**
   * Set the current focused group shape.
   *
   * @param shape - The group shape id (or group shape's id) to set as the focused group shape.
   *
   * @public
   */
  setFocusedGroup(e) {
    const n = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    if (n !== null) {
      const r = this.getShape(n);
      if (!r)
        throw Error(`Editor.setFocusedGroup: Shape with id ${n} does not exist`);
      if (!this.isShapeOfType(r, "group"))
        throw Error(
          `Editor.setFocusedGroup: Cannot set focused group to shape of type ${r.type}`
        );
    }
    return n === this.getFocusedGroupId() ? this : this.run(
      () => {
        this.store.update(this.getCurrentPageState().id, (r) => ({ ...r, focusedGroupId: n }));
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Exit the current focused group, moving up to the next parent group if there is one.
   *
   * @public
   */
  popFocusedGroupId() {
    const e = this.getFocusedGroup();
    if (e) {
      const n = this.findShapeAncestor(
        e,
        (r) => this.isShapeOfType(r, "group")
      );
      this.setFocusedGroup((n == null ? void 0 : n.id) ?? null), this.select(e.id);
    } else
      this.setFocusedGroup(null), this.selectNone();
    return this;
  }
  getEditingShapeId() {
    return this.getCurrentPageState().editingShapeId;
  }
  getEditingShape() {
    const e = this.getEditingShapeId();
    return e ? this.getShape(e) : void 0;
  }
  /**
   * Set the current editing shape.
   *
   * @example
   * ```ts
   * editor.setEditingShape(myShape)
   * editor.setEditingShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as editing.
   *
   * @public
   */
  setEditingShape(e) {
    const n = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    this.setRichTextEditor(null);
    const r = this.getEditingShapeId();
    if (n !== r) {
      if (n) {
        const s = this.getShape(n);
        if (s && this.getShapeUtil(s).canEdit(s))
          return this.run(
            () => {
              var o, i, a, c;
              if (this._updateCurrentPageState({ editingShapeId: n }), r) {
                const l = this.getShape(r);
                l && ((i = (o = this.getShapeUtil(l)).onEditEnd) == null || i.call(o, l));
              }
              (c = (a = this.getShapeUtil(s)).onEditStart) == null || c.call(a, s);
            },
            { history: "ignore" }
          ), this;
      }
      this.run(
        () => {
          var s, o;
          if (this._updateCurrentPageState({ editingShapeId: null }), this._currentRichTextEditor.set(null), r) {
            const i = this.getShape(r);
            i && ((o = (s = this.getShapeUtil(i)).onEditEnd) == null || o.call(s, i));
          }
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  getRichTextEditor() {
    return this._currentRichTextEditor.get();
  }
  /**
   * Set the current editing shape's rich text editor.
   *
   * @example
   * ```ts
   * editor.setRichTextEditor(richTextEditorView)
   * ```
   *
   * @param textEditor - The text editor to set as the current editing shape's text editor.
   *
   * @public
   */
  setRichTextEditor(e) {
    return this._currentRichTextEditor.set(e), this;
  }
  getHoveredShapeId() {
    return this.getCurrentPageState().hoveredShapeId;
  }
  getHoveredShape() {
    const e = this.getHoveredShapeId();
    return e ? this.getShape(e) : void 0;
  }
  /**
   * Set the editor's current hovered shape.
   *
   * @example
   * ```ts
   * editor.setHoveredShape(myShape)
   * editor.setHoveredShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as hovered.
   *
   * @public
   */
  setHoveredShape(e) {
    const n = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    return n === this.getHoveredShapeId() ? this : (this.run(
      () => {
        this.updateCurrentPageState({ hoveredShapeId: n });
      },
      { history: "ignore" }
    ), this);
  }
  getHintingShapeIds() {
    return this.getCurrentPageState().hintingShapeIds;
  }
  getHintingShape() {
    const e = this.getHintingShapeIds();
    return mt(e.map((n) => this.getShape(n)));
  }
  /**
   * Set the editor's current hinting shapes.
   *
   * @example
   * ```ts
   * editor.setHintingShapes([myShape])
   * editor.setHintingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setHintingShapes(e) {
    const n = typeof e[0] == "string" ? e : e.map((r) => r.id);
    return this.run(
      () => {
        this._updateCurrentPageState({ hintingShapeIds: cF(n) });
      },
      { history: "ignore" }
    ), this;
  }
  getErasingShapeIds() {
    return this.getCurrentPageState().erasingShapeIds;
  }
  getErasingShapes() {
    const e = this.getErasingShapeIds();
    return mt(e.map((n) => this.getShape(n)));
  }
  /**
   * Set the editor's current erasing shapes.
   *
   * @example
   * ```ts
   * editor.setErasingShapes([myShape])
   * editor.setErasingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setErasingShapes(e) {
    const n = typeof e[0] == "string" ? e : e.map((s) => s.id);
    n.sort();
    const r = this.getErasingShapeIds();
    return this.run(
      () => {
        if (n.length === r.length) {
          for (let s = 0; s < n.length; s++)
            if (n[s] !== r[s]) {
              this._updateCurrentPageState({ erasingShapeIds: n });
              break;
            }
        } else
          this._updateCurrentPageState({ erasingShapeIds: n });
      },
      { history: "ignore" }
    ), this;
  }
  // Cropping
  /**
   * The current cropping shape's id.
   *
   * @public
   */
  getCroppingShapeId() {
    return this.getCurrentPageState().croppingShapeId;
  }
  /**
   * Set the current cropping shape.
   *
   * @example
   * ```ts
   * editor.setCroppingShape(myShape)
   * editor.setCroppingShape(myShape.id)
   * ```
   *
   *
   * @param shape - The shape (or shape id) to set as cropping.
   *
   * @public
   */
  setCroppingShape(e) {
    const n = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    return n !== this.getCroppingShapeId() && this.run(
      () => {
        if (!n)
          this.updateCurrentPageState({ croppingShapeId: null });
        else {
          const r = this.getShape(n), s = this.getShapeUtil(r);
          r && s.canCrop(r) && this.updateCurrentPageState({ croppingShapeId: n });
        }
      },
      { history: "ignore" }
    ), this;
  }
  /**
   * Get the current text options.
   *
   * @example
   * ```ts
   * editor.getTextOptions()
   * ```
   *
   *  @public */
  getTextOptions() {
    return Io(this._textOptions.get(), "Cannot use text without setting textOptions");
  }
  _unsafe_getCameraId() {
    return Rl.createId(this.getCurrentPageId());
  }
  getCamera() {
    const e = this.store.get(this._unsafe_getCameraId());
    if (this._isLockedOnFollowingUser.get()) {
      const n = this.getCameraForFollowing();
      if (n)
        return { ...e, ...n };
    }
    return e;
  }
  _getFollowingPresence(e) {
    const n = [this.user.getId()], r = this.getCollaborators();
    let s = null;
    for (; e && !n.includes(e); )
      s = r.find((o) => o.userId === e) ?? null, e = (s == null ? void 0 : s.followingUserId) ?? null, s && n.push(s.userId);
    return s;
  }
  getViewportPageBoundsForFollowing() {
    const e = this._getFollowingPresence(this.getInstanceState().followingUserId);
    if (!(e != null && e.camera) || !(e != null && e.screenBounds)) return null;
    const { w: n, h: r } = e.screenBounds, { x: s, y: o, z: i } = e.camera, a = new _e(-s, -o, n / i, r / i), c = this.getViewportScreenBounds().clone(), l = c.width / c.height;
    return c.width = a.width, c.height = c.width / l, c.height < a.height && (c.height = a.height, c.width = c.height * l), c.center = a.center, c;
  }
  getCameraForFollowing() {
    const e = this.getViewportPageBoundsForFollowing();
    return e ? {
      x: -e.x,
      y: -e.y,
      z: this.getViewportScreenBounds().w / e.width
    } : null;
  }
  getZoomLevel() {
    return this.getCamera().z;
  }
  /**
   * Get the camera's initial or reset zoom level.
   *
   * @example
   * ```ts
   * editor.getInitialZoom()
   * ```
   *
   * @public */
  getInitialZoom() {
    const e = this.getCameraOptions();
    if (!e.constraints || e.constraints.initialZoom === "default") return 1;
    const { zx: n, zy: r } = CH(this, e);
    switch (e.constraints.initialZoom) {
      case "fit-min":
        return Math.max(n, r);
      case "fit-max":
        return Math.min(n, r);
      case "fit-x":
        return n;
      case "fit-y":
        return r;
      case "fit-min-100":
        return Math.min(1, Math.max(n, r));
      case "fit-max-100":
        return Math.min(1, Math.min(n, r));
      case "fit-x-100":
        return Math.min(1, n);
      case "fit-y-100":
        return Math.min(1, r);
      default:
        throw Jt(e.constraints.initialZoom);
    }
  }
  /**
   * Get the camera's base level for calculating actual zoom levels based on the zoom steps.
   *
   * @example
   * ```ts
   * editor.getBaseZoom()
   * ```
   *
   * @public */
  getBaseZoom() {
    const e = this.getCameraOptions();
    if (!e.constraints || e.constraints.baseZoom === "default") return 1;
    const { zx: n, zy: r } = CH(this, e);
    switch (e.constraints.baseZoom) {
      case "fit-min":
        return Math.max(n, r);
      case "fit-max":
        return Math.min(n, r);
      case "fit-x":
        return n;
      case "fit-y":
        return r;
      case "fit-min-100":
        return Math.min(1, Math.max(n, r));
      case "fit-max-100":
        return Math.min(1, Math.min(n, r));
      case "fit-x-100":
        return Math.min(1, n);
      case "fit-y-100":
        return Math.min(1, r);
      default:
        throw Jt(e.constraints.baseZoom);
    }
  }
  /**
   * Get the current camera options.
   *
   * @example
   * ```ts
   * editor.getCameraOptions()
   * ```
   *
   *  @public */
  getCameraOptions() {
    return this._cameraOptions.get();
  }
  /**
   * Set the camera options. Changing the options won't immediately change the camera itself, so you may want to call `setCamera` after changing the options.
   *
   * @example
   * ```ts
   * editor.setCameraOptions(myCameraOptions)
   * editor.setCamera(editor.getCamera())
   * ```
   *
   * @param opts - The camera options to set.
   *
   * @public */
  setCameraOptions(e) {
    var r;
    const n = mr({
      ...this._cameraOptions.__unsafe__getWithoutCapture(),
      ...e
    });
    return ((r = n.zoomSteps) == null ? void 0 : r.length) < 1 && (n.zoomSteps = [1]), this._cameraOptions.set(n), this.setCamera(this.getCamera()), this;
  }
  /** @internal */
  getConstrainedCamera(e, n) {
    const r = this.getCamera();
    let { x: s, y: o, z: i = r.z } = e;
    if (!(n != null && n.force)) {
      const a = this.getCameraOptions(), c = a.zoomSteps[0], l = Qs(a.zoomSteps), d = this.getViewportScreenBounds();
      if (a.constraints) {
        const { constraints: u } = a, f = Math.min(u.padding.y, d.w / 2), p = Math.min(u.padding.x, d.h / 2), g = _e.From(a.constraints.bounds), y = (d.w - p * 2) / g.w, m = (d.h - f * 2) / g.h, v = this.getBaseZoom(), b = l * v, x = c * v;
        if (n != null && n.reset && (i = this.getInitialZoom()), i < x || i > b) {
          const { x: D, y: k, z: A } = r, R = -D + d.w / A / 2, j = -k + d.h / A / 2;
          i = wt(i, x, b);
          const $ = -D + d.w / i / 2, F = -k + d.h / i / 2;
          s = D + $ - R, o = k + F - j;
        }
        const w = p / i - g.x, S = f / i - g.y, C = (d.w - p * 2) / i - g.w, _ = (d.h - f * 2) / i - g.h, E = w + C * u.origin.x, M = S + _ * u.origin.y, N = typeof u.behavior == "string" ? u.behavior : u.behavior.x, O = typeof u.behavior == "string" ? u.behavior : u.behavior.y;
        if (n != null && n.reset)
          s = E, o = M;
        else {
          switch (N) {
            case "fixed": {
              s = E;
              break;
            }
            case "contain": {
              i < y ? s = E : s = wt(s, w + C, w);
              break;
            }
            case "inside": {
              i < y ? s = wt(s, w, (d.w - p) / i - g.w) : s = wt(s, w + C, w);
              break;
            }
            case "outside": {
              s = wt(s, p / i - g.w, (d.w - p) / i);
              break;
            }
            case "free":
              break;
            default:
              throw Jt(N);
          }
          switch (O) {
            case "fixed": {
              o = M;
              break;
            }
            case "contain": {
              i < m ? o = M : o = wt(o, S + _, S);
              break;
            }
            case "inside": {
              i < m ? o = wt(o, S, (d.h - f) / i - g.h) : o = wt(o, S + _, S);
              break;
            }
            case "outside": {
              o = wt(o, f / i - g.h, (d.h - f) / i);
              break;
            }
            case "free":
              break;
            default:
              throw Jt(O);
          }
        }
      } else if (i > l || i < c) {
        const { x: u, y: f, z: p } = r;
        i = wt(i, c, l), s = u + (-u + d.w / i / 2) - (-u + d.w / p / 2), o = f + (-f + d.h / i / 2) - (-f + d.h / p / 2);
      }
    }
    return { x: s, y: o, z: i };
  }
  /** @internal */
  _setCamera(e, n) {
    const r = this.getCamera(), { x: s, y: o, z: i } = this.getConstrainedCamera(e, n);
    return r.x === s && r.y === o && r.z === i ? this : (va(() => {
      const a = { ...r, x: s, y: o, z: i };
      this.run(
        () => {
          this.store.put([a]);
        },
        { history: "ignore" }
      );
      const { currentScreenPoint: c, currentPagePoint: l } = this.inputs, { screenBounds: d } = this.store.unsafeGetWithoutCapture(ti);
      if (c.x / i - s !== l.x || c.y / i - o !== l.y) {
        const u = {
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          // weird but true: we need to put the screen point back into client space
          point: I.AddXY(c, d.x, d.y),
          pointerId: Z8.CAMERA_MOVE,
          ctrlKey: this.inputs.ctrlKey,
          altKey: this.inputs.altKey,
          shiftKey: this.inputs.shiftKey,
          metaKey: this.inputs.metaKey,
          accelKey: ms(this.inputs),
          button: 0,
          isPen: this.getInstanceState().isPenMode ?? !1
        };
        n != null && n.immediate ? this._flushEventForTick(u) : this.dispatch(u);
      }
      this._tickCameraState();
    }), this);
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * editor.setCamera({ x: 0, y: 0})
   * editor.setCamera({ x: 0, y: 0, z: 1.5})
   * editor.setCamera({ x: 0, y: 0, z: 1.5}, { animation: { duration: 1000, easing: (t) => t * t } })
   * ```
   *
   * @param point - The new camera position.
   * @param opts - The camera move options.
   *
   * @public
   */
  setCamera(e, n) {
    const { isLocked: r } = this._cameraOptions.__unsafe__getWithoutCapture();
    if (r && !(n != null && n.force)) return this;
    this.stopCameraAnimation(), this.getInstanceState().followingUserId && this.stopFollowingUser();
    const s = I.Cast(e);
    Number.isFinite(s.x) || (s.x = 0), Number.isFinite(s.y) || (s.y = 0), (s.z === void 0 || !Number.isFinite(s.z)) && (e.z = this.getZoomLevel());
    const o = this.getConstrainedCamera(s, n);
    if (n != null && n.animation) {
      const { width: i, height: a } = this.getViewportScreenBounds();
      this._animateToViewport(
        new _e(-o.x, -o.y, i / o.z, a / o.z),
        n
      );
    } else
      this._setCamera(o, {
        ...n,
        // we already did the constraining, so we don't need to do it again
        force: !0
      });
    return this;
  }
  /**
   * Center the camera on a point (in the current page space).
   *
   * @example
   * ```ts
   * editor.centerOnPoint({ x: 100, y: 100 })
   * editor.centerOnPoint({ x: 100, y: 100 }, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The point in the current page space to center on.
   * @param opts - The camera move options.
   *
   * @public
   */
  centerOnPoint(e, n) {
    const { isLocked: r } = this.getCameraOptions();
    if (r && !(n != null && n.force)) return this;
    const { width: s, height: o } = this.getViewportPageBounds();
    return this.setCamera(new I(-(e.x - s / 2), -(e.y - o / 2), this.getCamera().z), n), this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToFit()
   * editor.zoomToFit({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToFit(e) {
    const n = [...this.getCurrentPageShapeIds()];
    if (n.length <= 0) return this;
    const r = _e.Common(mt(n.map((s) => this.getShapePageBounds(s))));
    return this.zoomToBounds(r, e), this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * editor.resetZoom()
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  resetZoom(e = this.getViewportScreenCenter(), n) {
    const { isLocked: r, constraints: s } = this.getCameraOptions();
    if (r && !(n != null && n.force)) return this;
    const o = this.getCamera(), { x: i, y: a, z: c } = o, { x: l, y: d } = e;
    let u = 1;
    if (s) {
      const f = this.getInitialZoom();
      c !== f && (u = f);
    }
    return this.setCamera(
      new I(i + (l / u - l) - (l / c - l), a + (d / u - d) - (d / c - d), u),
      n
    ), this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * editor.zoomIn()
   * editor.zoomIn(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.zoomIn(editor.inputs.currentScreenPoint, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom in on. Defaults to the screen center
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomIn(e = this.getViewportScreenCenter(), n) {
    const { isLocked: r } = this.getCameraOptions();
    if (r && !(n != null && n.force)) return this;
    const { x: s, y: o, z: i } = this.getCamera(), { zoomSteps: a } = this.getCameraOptions();
    if (a !== null && a.length > 1) {
      const c = this.getBaseZoom();
      let l = Qs(a) * c;
      for (let d = 1; d < a.length; d++) {
        const u = a[d - 1] * c, f = a[d] * c;
        if (!(f - i <= (f - u) / 2)) {
          l = f;
          break;
        }
      }
      this.setCamera(
        new I(
          s + (e.x / l - e.x) - (e.x / i - e.x),
          o + (e.y / l - e.y) - (e.y / i - e.y),
          l
        ),
        n
      );
    }
    return this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * editor.zoomOut()
   * editor.zoomOut(editor.getViewportScreenCenter(), { animation: { duration: 120 } })
   * editor.zoomOut(editor.inputs.currentScreenPoint, { animation: { duration: 120 } })
   * ```
   *
   * @param point - The point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomOut(e = this.getViewportScreenCenter(), n) {
    const { isLocked: r } = this.getCameraOptions();
    if (r && !(n != null && n.force)) return this;
    const { zoomSteps: s } = this.getCameraOptions();
    if (s !== null && s.length > 1) {
      const o = this.getBaseZoom(), { x: i, y: a, z: c } = this.getCamera();
      let l = s[0] * o;
      for (let d = s.length - 1; d > 0; d--) {
        const u = s[d - 1] * o, f = s[d] * o;
        if (!(f - c >= (f - u) / 2)) {
          l = u;
          break;
        }
      }
      this.setCamera(
        new I(
          i + (e.x / l - e.x) - (e.x / c - e.x),
          a + (e.y / l - e.y) - (e.y / c - e.y),
          l
        ),
        n
      );
    }
    return this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToSelection()
   * editor.zoomToSelection({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToSelection(e) {
    const { isLocked: n } = this.getCameraOptions();
    if (n && !(e != null && e.force)) return this;
    const r = this.getSelectionPageBounds();
    return r && this.zoomToBounds(r, {
      targetZoom: Math.max(1, this.getZoomLevel()),
      ...e
    }), this;
  }
  /**
   * Zoom the camera to the current selection if offscreen.
   *
   * @public
   */
  zoomToSelectionIfOffscreen(e = 16, n) {
    const r = this.getSelectionPageBounds(), s = this.getViewportPageBounds();
    if (r && !s.contains(r)) {
      const o = r.clone().expandBy(e / this.getZoomLevel()).expand(s), i = s.clone().translate({
        x: (o.center.x - s.center.x) * 2,
        y: (o.center.y - s.center.y) * 2
      });
      this.zoomToBounds(i, n);
    }
  }
  /**
   * Zoom the camera to fit a bounding box (in the current page space).
   *
   * @example
   * ```ts
   * editor.zoomToBounds(myBounds)
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 } })
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 }, inset: 0, targetZoom: 1 })
   * ```
   *
   * @param bounds - The bounding box.
   * @param opts - The camera move options, target zoom, or custom inset amount.
   *
   * @public
   */
  zoomToBounds(e, n) {
    const r = this._cameraOptions.__unsafe__getWithoutCapture();
    if (r.isLocked && !(n != null && n.force)) return this;
    const s = this.getViewportScreenBounds(), o = (n == null ? void 0 : n.inset) ?? Math.min(F4e, s.width * 0.28), i = this.getBaseZoom(), a = r.zoomSteps[0], c = Qs(r.zoomSteps);
    let l = wt(
      Math.min(
        (s.width - o) / e.w,
        (s.height - o) / e.h
      ),
      a * i,
      c * i
    );
    return (n == null ? void 0 : n.targetZoom) !== void 0 && (l = Math.min(n.targetZoom, l)), this.setCamera(
      new I(
        -e.x + (s.width - e.w * l) / 2 / l,
        -e.y + (s.height - e.h * l) / 2 / l,
        l
      ),
      n
    ), this;
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @example
   * ```ts
   * editor.stopCameraAnimation()
   * ```
   *
   * @public
   */
  stopCameraAnimation() {
    return this.emit("stop-camera-animation"), this;
  }
  /** @internal */
  _animateViewport(e) {
    if (!this._viewportAnimation) return;
    this._viewportAnimation.elapsed += e;
    const { elapsed: n, easing: r, duration: s, start: o, end: i } = this._viewportAnimation;
    if (n > s) {
      this.off("tick", this._animateViewport), this._viewportAnimation = null, this._setCamera(new I(-i.x, -i.y, this.getViewportScreenBounds().width / i.width));
      return;
    }
    const a = s - n, c = r(1 - a / s), l = o.minX + (i.minX - o.minX) * c, d = o.minY + (i.minY - o.minY) * c, u = o.maxX + (i.maxX - o.maxX) * c;
    this._setCamera(new I(-l, -d, this.getViewportScreenBounds().width / (u - l)), {
      force: !0
    });
  }
  /** @internal */
  _animateToViewport(e, n = { animation: eO }) {
    const { animation: r, ...s } = n;
    if (!r) return;
    const { duration: o = 0, easing: i = Mo.easeInOutCubic } = r, a = this.user.getAnimationSpeed(), c = this.getViewportPageBounds();
    return this.stopCameraAnimation(), this.getInstanceState().followingUserId && this.stopFollowingUser(), o === 0 || a === 0 ? this._setCamera(
      new I(
        -e.x,
        -e.y,
        this.getViewportScreenBounds().width / e.width
      ),
      { ...s }
    ) : (this._viewportAnimation = {
      elapsed: 0,
      duration: o / a,
      easing: i,
      start: c.clone(),
      end: e.clone()
    }, this.once("stop-camera-animation", () => {
      this.off("tick", this._animateViewport), this._viewportAnimation = null;
    }), this.on("tick", this._animateViewport), this);
  }
  /**
   * Slide the camera in a certain direction.
   *
   * @example
   * ```ts
   * editor.slideCamera({ speed: 1, direction: { x: 1, y: 0 }, friction: 0.1 })
   * ```
   *
   * @param opts - Options for the slide
   * @public
   */
  slideCamera(e = {}) {
    const { isLocked: n } = this.getCameraOptions();
    if (n && !(e != null && e.force)) return this;
    if (this.user.getAnimationSpeed() === 0) return this;
    this.stopCameraAnimation();
    const {
      speed: s,
      friction: o = this.options.cameraSlideFriction,
      direction: i,
      speedThreshold: a = 0.01
    } = e;
    let c = Math.min(s, 1);
    const l = () => {
      this.off("tick", d), this.off("stop-camera-animation", l);
    };
    this.once("stop-camera-animation", l);
    const d = (u) => {
      const { x: f, y: p, z: g } = this.getCamera(), y = I.Mul(i, c * u / g);
      c *= 1 - o, c < a ? l() : this._setCamera(new I(f + y.x, p + y.y, g));
    };
    return this.on("tick", d), this;
  }
  /**
   * Animate the camera to a user's cursor position. This also briefly show the user's cursor if it's not currently visible.
   *
   * @example
   * ```ts
   * editor.zoomToUser(myUserId)
   * editor.zoomToUser(myUserId, { animation: { duration: 200 } })
   * ```
   *
   * @param userId - The id of the user to animate to.
   * @param opts - The camera move options.
   * @public
   */
  zoomToUser(e, n = { animation: { duration: 500 } }) {
    const r = this.getCollaborators().find((o) => o.userId === e);
    if (!r) return this;
    const s = r.cursor;
    return s ? (this.run(() => {
      this.getInstanceState().followingUserId !== null && this.stopFollowingUser();
      const o = r.currentPageId === this.getCurrentPageId();
      o || this.setCurrentPage(r.currentPageId), n && n.animation && !o && (n.animation = void 0), this.centerOnPoint(s, n);
      const { highlightedUserIds: i } = this.getInstanceState();
      this.updateInstanceState({ highlightedUserIds: [...i, e] }), this.timers.setTimeout(() => {
        const a = [...this.getInstanceState().highlightedUserIds], c = a.indexOf(e);
        c < 0 || (a.splice(c, 1), this.updateInstanceState({ highlightedUserIds: a }));
      }, this.options.collaboratorIdleTimeoutMs);
    }), this) : this;
  }
  /**
   * Update the viewport. The viewport will measure the size and screen position of its container
   * element. This should be done whenever the container's position on the screen changes.
   *
   * @example
   * ```ts
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024))
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024), true)
   * ```
   *
   * @param screenBounds - The new screen bounds of the viewport.
   * @param center - Whether to preserve the viewport page center as the viewport changes.
   *
   * @public
   */
  updateViewportScreenBounds(e, n = !1) {
    if (e instanceof _e)
      e.width = Math.max(e.width, 1), e.height = Math.max(e.height, 1);
    else {
      const a = e.getBoundingClientRect();
      e = new _e(
        a.left || a.x,
        a.top || a.y,
        Math.max(a.width, 1),
        Math.max(a.height, 1)
      );
    }
    const r = [
      // top
      e.minY !== 0,
      // right
      !Hr(document.body.scrollWidth, e.maxX, 1),
      // bottom
      !Hr(document.body.scrollHeight, e.maxY, 1),
      // left
      e.minX !== 0
    ], { _willSetInitialBounds: s } = this;
    this._willSetInitialBounds = !1;
    const { screenBounds: o, insets: i } = this.getInstanceState();
    if (e.equals(o) && r.every((a, c) => a === i[c]))
      return this;
    if (s)
      this.updateInstanceState({ screenBounds: e.toJson(), insets: r }), this.setCamera(this.getCamera());
    else if (n && !this.getInstanceState().followingUserId) {
      const a = this.getViewportPageBounds().center;
      this.updateInstanceState({ screenBounds: e.toJson(), insets: r }), this.centerOnPoint(a);
    } else
      this.updateInstanceState({ screenBounds: e.toJson(), insets: r }), this._setCamera(I.From({ ...this.getCamera() }));
    return this._tickCameraState(), this;
  }
  getViewportScreenBounds() {
    const { x: e, y: n, w: r, h: s } = this.getInstanceState().screenBounds;
    return new _e(e, n, r, s);
  }
  getViewportScreenCenter() {
    const e = this.getViewportScreenBounds();
    return new I(e.w / 2, e.h / 2);
  }
  getViewportPageBounds() {
    const { w: e, h: n } = this.getViewportScreenBounds(), { x: r, y: s, z: o } = this.getCamera();
    return new _e(-r, -s, e / o, n / o);
  }
  /**
   * Convert a point in screen space to a point in the current page space.
   *
   * @example
   * ```ts
   * editor.screenToPage({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in screen space.
   *
   * @public
   */
  screenToPage(e) {
    const { screenBounds: n } = this.store.unsafeGetWithoutCapture(ti), { x: r, y: s, z: o = 1 } = this.getCamera();
    return new I(
      (e.x - n.x) / o - r,
      (e.y - n.y) / o - s,
      e.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current screen space.
   *
   * @example
   * ```ts
   * editor.pageToScreen({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToScreen(e) {
    const { screenBounds: n } = this.store.unsafeGetWithoutCapture(ti), { x: r, y: s, z: o = 1 } = this.getCamera();
    return new I(
      (e.x + r) * o + n.x,
      (e.y + s) * o + n.y,
      e.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current viewport space.
   *
   * @example
   * ```ts
   * editor.pageToViewport({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToViewport(e) {
    const { x: n, y: r, z: s = 1 } = this.getCamera();
    return new I((e.x + n) * s, (e.y + r) * s, e.z ?? 0.5);
  }
  _getCollaboratorsQuery() {
    return this.store.query.records("instance_presence", () => ({
      userId: { neq: this.user.getId() }
    }));
  }
  getCollaborators() {
    const e = this._getCollaboratorsQuery().get();
    return e.length ? [...new Set(e.map((r) => r.userId))].sort().map((r) => k2e(
      e.filter((o) => o.userId === r),
      (o) => o.lastActivityTimestamp ?? 0
    )) : Br;
  }
  getCollaboratorsOnCurrentPage() {
    const e = this.getCurrentPageId();
    return this.getCollaborators().filter((n) => n.currentPageId === e);
  }
  /**
   * Start viewport-following a user.
   *
   * @example
   * ```ts
   * editor.startFollowingUser(myUserId)
   * ```
   *
   * @param userId - The id of the user to follow.
   *
   * @public
   */
  startFollowingUser(e) {
    if (this.stopFollowingUser(), this.user.getId() || console.warn("You should set the userId for the current instance before following a user"), !this._getFollowingPresence(e))
      return this;
    const s = ve("latestLeaderPresence", () => this._getFollowingPresence(e));
    return va(() => {
      this.updateInstanceState({ followingUserId: e }, { history: "ignore" });
      const o = ya("update current page", () => {
        const c = s.get();
        if (!c) {
          this.stopFollowingUser();
          return;
        }
        c.currentPageId !== this.getCurrentPageId() && this.getPage(c.currentPageId) && this.run(
          () => {
            this.store.put([
              { ...this.getInstanceState(), currentPageId: c.currentPageId }
            ]), this._isLockedOnFollowingUser.set(!0);
          },
          { history: "ignore" }
        );
      }), i = () => {
        o(), this._isLockedOnFollowingUser.set(!1), this.off("frame", a), this.off("stop-following", i);
      }, a = () => {
        if (!s.get()) {
          this.stopFollowingUser();
          return;
        }
        if (this._isLockedOnFollowingUser.get()) return;
        const l = this.user.getAnimationSpeed();
        if (l === 0) {
          this._isLockedOnFollowingUser.set(!0);
          return;
        }
        const d = this.getViewportPageBoundsForFollowing();
        if (!d) {
          this.stopFollowingUser();
          return;
        }
        const u = this.getViewportPageBounds(), f = Math.abs(d.minX - u.minX) + Math.abs(d.maxX - u.maxX), p = Math.abs(d.minY - u.minY) + Math.abs(d.maxY - u.maxY);
        if (f < this.options.followChaseViewportSnap && p < this.options.followChaseViewportSnap) {
          this._isLockedOnFollowingUser.set(!0);
          return;
        }
        const g = wt(l * 0.5, 0.1, 0.8), y = new _e(
          kt(u.minX, d.minX, g),
          kt(u.minY, d.minY, g),
          kt(u.width, d.width, g),
          kt(u.height, d.height, g)
        ), m = new I(
          -y.x,
          -y.y,
          this.getViewportScreenBounds().width / y.width
        );
        this.stopCameraAnimation(), this._setCamera(m);
      };
      this.once("stop-following", i), this.addListener("frame", a), a();
    }), this;
  }
  /**
   * Stop viewport-following a user.
   *
   * @example
   * ```ts
   * editor.stopFollowingUser()
   * ```
   * @public
   */
  stopFollowingUser() {
    return this.run(
      () => {
        this.store.put([this.getCamera()]), this._isLockedOnFollowingUser.set(!1), this.updateInstanceState({ followingUserId: null }), this.emit("stop-following");
      },
      { history: "ignore" }
    ), this;
  }
  /** @internal */
  getUnorderedRenderingShapes(e) {
    const n = [];
    let r = this.options.maxShapesPerPage * 2, s = this.options.maxShapesPerPage;
    const o = this.getErasingShapeIds(), i = (c, l, d) => {
      const u = this.getShape(c);
      if (!u) return;
      if (this.isShapeHidden(u)) {
        const m = d || o.includes(c);
        for (const v of this.getSortedChildIdsForParent(c))
          i(v, l, m);
        return;
      }
      l *= u.opacity;
      let f = !1;
      const p = this.getShapeUtil(u);
      e && (f = !d && o.includes(c), f && (l *= 0.32)), n.push({
        id: c,
        shape: u,
        util: p,
        index: r,
        backgroundIndex: s,
        opacity: l
      }), r += 1, s += 1;
      const g = this.getSortedChildIdsForParent(c);
      if (!g.length) return;
      let y = null;
      p.providesBackgroundForChildren(u) && (y = s, s = r, r += this.options.maxShapesPerPage);
      for (const m of g)
        i(m, l, d || f);
      y !== null && (s = y);
    }, a = e ? [this.getCurrentPage()] : this.getPages();
    for (const c of a)
      for (const l of this.getSortedChildIdsForParent(c.id))
        i(l, 1, !1);
    return n;
  }
  _decayCameraStateTimeout(e) {
    this._cameraStateTimeoutRemaining -= e, !(this._cameraStateTimeoutRemaining > 0) && (this.off("tick", this._decayCameraStateTimeout), this._cameraState.set("idle"));
  }
  _tickCameraState() {
    this._cameraStateTimeoutRemaining = this.options.cameraMovingTimeoutMs, this._cameraState.__unsafe__getWithoutCapture() === "idle" && (this._cameraState.set("moving"), this.on("tick", this._decayCameraStateTimeout));
  }
  /**
   * Whether the camera is moving or idle.
   *
   * @example
   * ```ts
   * editor.getCameraState()
   * ```
   *
   * @public
   */
  getCameraState() {
    return this._cameraState.get();
  }
  getRenderingShapes() {
    return this.getUnorderedRenderingShapes(!0).sort(aDe);
  }
  _getAllPagesQuery() {
    return this.store.query.records("page");
  }
  getPages() {
    return Array.from(this._getAllPagesQuery().get()).sort(Js);
  }
  /**
   * The current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPage()
   * ```
   *
   * @public
   */
  getCurrentPage() {
    return this.getPage(this.getCurrentPageId());
  }
  getCurrentPageId() {
    return this.getInstanceState().currentPageId;
  }
  /**
   * Get a page.
   *
   * @example
   * ```ts
   * editor.getPage(myPage.id)
   * editor.getPage(myPage)
   * ```
   *
   * @param page - The page (or the page id) to get.
   *
   * @public
   */
  getPage(e) {
    return this.store.get(typeof e == "string" ? e : e.id);
  }
  /**
   * An array of all of the shapes on the current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPageIds()
   * ```
   *
   * @public
   */
  getCurrentPageShapeIds() {
    return this._currentPageShapeIds.get();
  }
  getCurrentPageShapeIdsSorted() {
    return Array.from(this.getCurrentPageShapeIds()).sort();
  }
  /**
   * Get the ids of shapes on a page.
   *
   * @example
   * ```ts
   * const idsOnPage1 = editor.getPageShapeIds('page1')
   * const idsOnPage2 = editor.getPageShapeIds(myPage2)
   * ```
   *
   * @param page - The page (or the page id) to get the shape ids for.
   *
   * @public
   **/
  getPageShapeIds(e) {
    const n = typeof e == "string" ? e : e.id, r = this.store.query.exec("shape", { parentId: { eq: n } });
    return this.getShapeAndDescendantIds(r.map((s) => s.id));
  }
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * editor.setCurrentPage('page1')
   * editor.setCurrentPage(myPage1)
   * ```
   *
   * @param page - The page (or the page id) to set as the current page.
   *
   * @public
   */
  setCurrentPage(e) {
    const n = typeof e == "string" ? e : e.id;
    return this.store.has(n) ? (this.stopFollowingUser(), this.complete(), this.run(
      () => {
        this.store.put([{ ...this.getInstanceState(), currentPageId: n }]), this.setCamera(this.getCamera());
      },
      { history: "record-preserveRedoStack" }
    )) : (console.error("Tried to set the current page id to a page that doesn't exist."), this);
  }
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * editor.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   *
   * @public
   */
  updatePage(e) {
    return this.getIsReadonly() ? this : this.getPage(e.id) ? this.run(() => this.store.update(e.id, (r) => ({ ...r, ...e }))) : this;
  }
  /**
   * Create a page whilst ensuring that the page name is unique.
   *
   * @example
   * ```ts
   * editor.createPage(myPage)
   * editor.createPage({ name: 'Page 2' })
   * ```
   *
   * @param page - The page (or page partial) to create.
   *
   * @public
   */
  createPage(e) {
    return this.run(() => {
      if (this.getIsReadonly() || this.getPages().length >= this.options.maxPages) return;
      const n = this.getPages(), r = Pze(
        e.name ?? "Page 1",
        n.map((i) => i.name)
      );
      let s = e.index;
      (!s || n.some((i) => i.index === s)) && (s = Bc(n[n.length - 1].index));
      const o = ci.create({
        meta: {},
        ...e,
        name: r,
        index: s
      });
      this.store.put([o]);
    }), this;
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * editor.deletePage('page1')
   * ```
   *
   * @param page - The page (or the page id) to delete.
   *
   * @public
   */
  deletePage(e) {
    const n = typeof e == "string" ? e : e.id;
    return this.run(() => {
      if (this.getIsReadonly()) return;
      const r = this.getPages();
      if (r.length === 1) return;
      const s = this.getPage(n);
      if (s) {
        if (n === this.getCurrentPageId()) {
          const o = r.findIndex((a) => a.id === n), i = r[o - 1] ?? r[o + 1];
          this.setCurrentPage(i.id);
        }
        this.store.remove([s.id]);
      }
    }), this;
  }
  /**
   * Duplicate a page.
   *
   * @param page - The page (or the page id) to duplicate. Defaults to the current page.
   * @param createId - The id of the new page. Defaults to a new id.
   *
   * @public
   */
  duplicatePage(e, n = ci.createId()) {
    if (this.getPages().length >= this.options.maxPages) return this;
    const r = typeof e == "string" ? e : e.id, s = this.getPage(r);
    if (!s) return this;
    const o = { ...this.getCamera() }, i = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(s.id));
    return this.run(() => {
      var l;
      const a = this.getPages(), c = oy(s.index, (l = a[a.indexOf(s) + 1]) == null ? void 0 : l.index);
      if (this.createPage({ name: s.name + " Copy", id: n, index: c }), this.setCurrentPage(n), this.setCamera(o), i)
        return this.putContentOntoCurrentPage(i);
    }), this;
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * editor.renamePage('page1', 'My Page')
   * ```
   *
   * @param page - The page (or the page id) to rename.
   * @param name - The new name.
   *
   * @public
   */
  renamePage(e, n) {
    const r = typeof e == "string" ? e : e.id;
    return this.getIsReadonly() ? this : (this.updatePage({ id: r, name: n }), this);
  }
  _getAllAssetsQuery() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the editor.
   *
   * @public
   */
  getAssets() {
    return this._getAllAssetsQuery().get();
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * editor.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   *
   * @public
   */
  createAssets(e) {
    return this.getIsReadonly() ? this : e.length <= 0 ? this : (this.run(() => this.store.put(e), { history: "ignore" }), this);
  }
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * editor.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   *
   * @public
   */
  updateAssets(e) {
    return this.getIsReadonly() ? this : e.length <= 0 ? this : (this.run(
      () => {
        this.store.put(
          e.map((n) => ({
            ...this.store.get(n.id),
            ...n
          }))
        );
      },
      { history: "ignore" }
    ), this);
  }
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * editor.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param assets - The assets (or asset ids) to delete.
   *
   * @public
   */
  deleteAssets(e) {
    if (this.getIsReadonly()) return this;
    const n = typeof e[0] == "string" ? e : e.map((r) => r.id);
    return n.length <= 0 ? this : (this.run(
      () => {
        var r, s;
        (s = (r = this.store.props.assets).remove) == null || s.call(r, n), this.store.remove(n);
      },
      { history: "ignore" }
    ), this);
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * editor.getAsset('asset1')
   * ```
   *
   * @param asset - The asset (or asset id) to get.
   *
   * @public
   */
  getAsset(e) {
    return this.store.get(typeof e == "string" ? e : e.id);
  }
  async resolveAssetUrl(e, n) {
    if (!e) return null;
    const r = this.getAsset(e);
    if (!r) return null;
    const {
      screenScale: s = 1,
      shouldResolveToOriginal: o = !1,
      dpr: i = this.getInstanceState().devicePixelRatio
    } = n, c = ((d) => Math.pow(2, Math.ceil(Math.log2(d))))(s), l = "connection" in navigator ? navigator.connection.effectiveType : null;
    return await this.store.props.assets.resolve(r, {
      screenScale: s || 1,
      steppedScreenScale: c,
      dpr: i,
      networkEffectiveType: l,
      shouldResolveToOriginal: o
    });
  }
  /**
   * Upload an asset to the store's asset service, returning a URL that can be used to resolve the
   * asset.
   */
  async uploadAsset(e, n, r) {
    return await this.store.props.assets.upload(e, n, r);
  }
  /**
   * Get the geometry of a shape in shape-space.
   *
   * @example
   * ```ts
   * editor.getShapeGeometry(myShape)
   * editor.getShapeGeometry(myShapeId)
   * editor.getShapeGeometry(myShapeId, { context: "arrow" })
   * ```
   *
   * @param shape - The shape (or shape id) to get the geometry for.
   * @param opts - Additional options about the request for geometry. Passed to {@link ShapeUtil.getGeometry}.
   *
   * @public
   */
  getShapeGeometry(e, n) {
    const r = (n == null ? void 0 : n.context) ?? "none";
    return this._shapeGeometryCaches[r] || (this._shapeGeometryCaches[r] = this.store.createComputedCache(
      "bounds",
      (s) => (this.fonts.trackFontsForShape(s), this.getShapeUtil(s).getGeometry(s, n)),
      { areRecordsEqual: uj }
    )), this._shapeGeometryCaches[r].get(
      typeof e == "string" ? e : e.id
    );
  }
  _getShapeHandlesCache() {
    return this.store.createComputedCache(
      "handles",
      (e) => {
        var n, r;
        return (r = (n = this.getShapeUtil(e)).getHandles) == null ? void 0 : r.call(n, e);
      },
      {
        areRecordsEqual: uj
      }
    );
  }
  /**
   * Get the handles (if any) for a shape.
   *
   * @example
   * ```ts
   * editor.getShapeHandles(myShape)
   * editor.getShapeHandles(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the handles for.
   * @public
   */
  getShapeHandles(e) {
    return this._getShapeHandlesCache().get(typeof e == "string" ? e : e.id);
  }
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * editor.getShapeLocalTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   *
   * @public
   */
  getShapeLocalTransform(e) {
    const n = typeof e == "string" ? e : e.id, r = this.getShape(n);
    if (!r) throw Error("Editor.getTransform: shape not found");
    return we.Identity().translate(r.x, r.y).rotate(r.rotation);
  }
  _getShapePageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (e) => {
      if (Ys(e.parentId))
        return this.getShapeLocalTransform(e);
      const n = this._getShapePageTransformCache().get(e.parentId) ?? we.Identity();
      return we.Compose(n, this.getShapeLocalTransform(e));
    });
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * editor.getShapeParentTransform(myShape)
   * ```
   *
   * @param shape - The shape (or shape id) to get the parent transform for.
   *
   * @public
   */
  getShapeParentTransform(e) {
    const n = typeof e == "string" ? e : e.id, r = this.getShape(n);
    return !r || Ys(r.parentId) ? we.Identity() : this._getShapePageTransformCache().get(r.parentId) ?? we.Identity();
  }
  /**
   * Get the transform of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageTransform(myShape)
   * editor.getShapePageTransform(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the page transform for.
   *
   * @public
   */
  getShapePageTransform(e) {
    const n = typeof e == "string" ? e : e.id;
    return this._getShapePageTransformCache().get(n) ?? we.Identity();
  }
  _getShapePageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (e) => {
      const n = this.getShapePageTransform(e);
      if (!n) return;
      const r = this.getShapeGeometry(e);
      return _e.FromPoints(n.applyToPoints(r.vertices));
    });
  }
  /**
   * Get the bounds of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageBounds(myShape)
   * editor.getShapePageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the bounds for.
   *
   * @public
   */
  getShapePageBounds(e) {
    return this._getShapePageBoundsCache().get(typeof e == "string" ? e : e.id);
  }
  _getShapeClipPathCache() {
    return this.store.createComputedCache("clipPathCache", (e) => {
      const n = this._getShapeMaskCache().get(e.id);
      if (!n) return;
      if (n.length === 0)
        return "polygon(0px 0px, 0px 0px, 0px 0px)";
      const r = this._getShapePageTransformCache().get(e.id);
      return r ? `polygon(${we.applyToPoints(we.Inverse(r), n).map((o) => `${o.x}px ${o.y}px`).join(",")})` : void 0;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = editor.getShapeClipPath(shape)
   * const clipPath = editor.getShapeClipPath(shape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to get the clip path for.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getShapeClipPath(e) {
    return this._getShapeClipPathCache().get(typeof e == "string" ? e : e.id);
  }
  _getShapeMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (e) => {
      if (Ys(e.parentId)) return;
      const n = this.getShapeAncestors(e.id).filter(
        (s) => this.isShapeOfType(s, "frame")
      );
      return n.length === 0 ? void 0 : n.map((s) => {
        const o = this.getShapeGeometry(s.id);
        return this.getShapePageTransform(s.id).applyToPoints(o.vertices);
      }).reduce((s, o) => {
        if (!(o && s)) return;
        const i = BE(s, o);
        return i ? i.map(I.Cast) : [];
      });
    });
  }
  /**
   * Get the mask (in the current page space) for a shape.
   *
   * @example
   * ```ts
   * const pageMask = editor.getShapeMask(shape.id)
   * ```
   *
   * @param shape - The shape (or the shape id) of the shape to get the mask for.
   *
   * @returns The mask for the shape.
   *
   * @public
   */
  getShapeMask(e) {
    return this._getShapeMaskCache().get(typeof e == "string" ? e : e.id);
  }
  /**
   * Get the bounds of a shape in the current page space, incorporating any masks. For example, if the
   * shape were the child of a frame and was half way out of the frame, the bounds would be the half
   * of the shape that was in the frame.
   *
   * @example
   * ```ts
   * editor.getShapeMaskedPageBounds(myShape)
   * editor.getShapeMaskedPageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   *
   * @public
   */
  getShapeMaskedPageBounds(e) {
    return typeof e != "string" && (e = e.id), this._getShapeMaskedPageBoundsCache().get(e);
  }
  _getShapeMaskedPageBoundsCache() {
    return this.store.createComputedCache("shapeMaskedPageBoundsCache", (e) => {
      const n = this._getShapePageBoundsCache().get(e.id);
      if (!n) return;
      const r = this._getShapeMaskCache().get(e.id);
      if (r) {
        if (r.length === 0) return;
        const { corners: s } = n;
        if (s.every((i, a) => i && I.Equals(i, r[a]))) return n.clone();
        const o = BE(r, s);
        return o ? _e.FromPoints(o) : void 0;
      }
      return n;
    });
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * const ancestors = editor.getShapeAncestors(myShape)
   * const ancestors = editor.getShapeAncestors(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the ancestors for.
   * @param acc - The accumulator.
   *
   * @public
   */
  getShapeAncestors(e, n = []) {
    const r = typeof e == "string" ? e : e.id, s = this.getShape(r);
    if (!s) return n;
    const o = s.parentId;
    if (Ys(o))
      return n.reverse(), n;
    const i = this.store.get(o);
    return i ? (n.push(i), this.getShapeAncestors(i, n)) : n;
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * const ancestor = editor.findShapeAncestor(myShape)
   * const ancestor = editor.findShapeAncestor(myShape.id)
   * const ancestor = editor.findShapeAncestor(myShape.id, (shape) => shape.type === 'frame')
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   * @param predicate - The predicate to match.
   *
   * @public
   */
  findShapeAncestor(e, n) {
    const r = typeof e == "string" ? e : e.id, s = this.getShape(r);
    if (!s) return;
    const o = s.parentId;
    if (Ys(o)) return;
    const i = this.getShape(o);
    if (i)
      return n(i) ? i : this.findShapeAncestor(i, n);
  }
  /**
   * Returns true if the the given shape has the given ancestor.
   *
   * @param shape - The shape.
   * @param ancestorId - The id of the ancestor.
   *
   * @public
   */
  hasAncestor(e, n) {
    const r = typeof e == "string" ? e : e == null ? void 0 : e.id, s = r && this.getShape(r);
    return s ? s.parentId === n ? !0 : this.hasAncestor(this.getShapeParent(s), n) : !1;
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes (or shape ids) to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(e, n) {
    var c;
    if (e.length === 0)
      return;
    const r = typeof e[0] == "string" ? e : e.map((l) => l.id), s = mt(r.map((l) => this.getShape(l)));
    if (s.length === 1) {
      const l = s[0].parentId;
      return Ys(l) ? void 0 : n ? (c = this.findShapeAncestor(s[0], n)) == null ? void 0 : c.id : l;
    }
    const [o, ...i] = s;
    let a = this.getShapeParent(o);
    for (; a; ) {
      if (n && !n(a)) {
        a = this.getShapeParent(a);
        continue;
      }
      if (i.every((l) => this.hasAncestor(l, a.id)))
        return a.id;
      a = this.getShapeParent(a);
    }
  }
  /**
   * Check whether a shape or its parent is locked.
   *
   * @param shape - The shape (or shape id) to check.
   *
   * @public
   */
  isShapeOrAncestorLocked(e) {
    const n = e && this.getShape(e);
    return n === void 0 ? !1 : n.isLocked ? !0 : this.isShapeOrAncestorLocked(this.getShapeParent(n));
  }
  getNotVisibleShapes() {
    return this._notVisibleShapes.get();
  }
  getCulledShapes() {
    const e = this.getNotVisibleShapes(), n = this.getSelectedShapeIds(), r = this.getEditingShapeId(), s = new Set(e);
    return r && s.delete(r), n.forEach((o) => {
      s.delete(o);
    }), s;
  }
  getCurrentPageBounds() {
    let e;
    return this.getCurrentPageShapeIdsSorted().forEach((n) => {
      const r = this.getShapeMaskedPageBounds(n);
      r && (e ? e = e.expand(r) : e = r.clone());
    }), e;
  }
  /**
   * Get the top-most selected shape at the given point, ignoring groups.
   *
   * @param point - The point to check.
   *
   * @returns The top-most selected shape at the given point, or undefined if there is no shape at the point.
   */
  getSelectedShapeAtPoint(e) {
    const n = this.getSelectedShapeIds();
    return this.getCurrentPageShapesSorted().filter((r) => r.type !== "group" && n.includes(r.id)).reverse().find((r) => this.isPointInShape(r, e, { hitInside: !0, margin: 0 }));
  }
  /**
   * Get the shape at the current point.
   *
   * @param point - The point to check.
   * @param opts - Options for the check: `hitInside` to check if the point is inside the shape, `margin` to check if the point is within a margin of the shape, `hitFrameInside` to check if the point is inside the frame, and `filter` to filter the shapes to check.
   *
   * @returns The shape at the given point, or undefined if there is no shape at the point.
   */
  getShapeAtPoint(e, n = {}) {
    var m;
    const r = this.getZoomLevel(), s = this.getViewportPageBounds(), {
      filter: o,
      margin: i = 0,
      hitLocked: a = !1,
      hitLabels: c = !1,
      hitInside: l = !1,
      hitFrameInside: d = !1
    } = n;
    let u = 1 / 0, f = null, p = 1 / 0, g = null;
    const y = (n.renderingOnly ? this.getCurrentPageRenderingShapesSorted() : this.getCurrentPageShapesSorted()).filter((v) => {
      if (v.isLocked && !a || this.isShapeHidden(v) || this.isShapeOfType(v, "group"))
        return !1;
      const b = this.getShapeMask(v);
      return b && !li(e, b) ? !1 : o ? o(v) : !0;
    });
    for (let v = y.length - 1; v >= 0; v--) {
      const b = y[v], x = this.getShapeGeometry(b), w = x instanceof ui, S = this.getPointInShapeSpace(b, e);
      if (this.isShapeOfType(b, "frame") || this.isShapeOfType(b, "arrow") && b.props.text.trim() || (this.isShapeOfType(b, "note") || this.isShapeOfType(b, "geo") && b.props.fill === "none") && ((m = this.getShapeUtil(b).getText(b)) != null && m.trim())) {
        for (const _ of x.children)
          if (_.isLabel && _.isPointInBounds(S))
            return b;
      }
      if (this.isShapeOfType(b, "frame")) {
        const _ = x.distanceToPoint(S, l);
        if (Math.abs(_) <= i)
          return g || b;
        if (x.hitTestPoint(S, 0, !0))
          return g || f || (d ? b : void 0);
        continue;
      }
      let C;
      if (w) {
        let _ = 1 / 0;
        for (const E of x.children) {
          if (E.isLabel && !c) continue;
          const M = E.distanceToPoint(S, l);
          M < _ && (_ = M);
        }
        C = _;
      } else
        i === 0 && (x.bounds.w < 1 || x.bounds.h < 1) || x.bounds.containsPoint(S, i) ? C = x.distanceToPoint(S, l) : C = 1 / 0;
      if (x.isClosed) {
        if (C <= i) {
          if (x.isFilled || w && x.children[0].isFilled)
            return g || b;
          if (this.getShapePageBounds(b).contains(s)) continue;
          if (Math.abs(C) < i)
            Math.abs(C) < p && (p = Math.abs(C), g = b);
          else if (!g) {
            const { area: _ } = x;
            _ < u && (u = _, f = b);
          }
        }
      } else if (C < this.options.hitTestMargin / r)
        return b;
    }
    return g || f || void 0;
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * editor.getShapesAtPoint({ x: 100, y: 100 })
   * editor.getShapesAtPoint({ x: 100, y: 100 }, { hitInside: true, margin: 8 })
   * ```
   *
   * @param point - The page point to test.
   * @param opts - The options for the hit point testing.
   *
   * @returns An array of shapes at the given point, sorted in reverse order of their absolute z-index (top-most shape first).
   *
   * @public
   */
  getShapesAtPoint(e, n = {}) {
    return this.getCurrentPageShapesSorted().filter((r) => !this.isShapeHidden(r) && this.isPointInShape(r, e, n)).reverse();
  }
  /**
   * Test whether a point (in the current page space) will will a shape. This method takes into account masks,
   * such as when a shape is the child of a frame and is partially clipped by the frame.
   *
   * @example
   * ```ts
   * editor.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param shape - The shape to test against.
   * @param point - The page point to test (in the current page space).
   * @param opts - The options for the hit point testing.
   *
   * @public
   */
  isPointInShape(e, n, r = {}) {
    const { hitInside: s = !1, margin: o = 0 } = r, i = typeof e == "string" ? e : e.id, a = this.getShapeMask(i);
    return a && !li(n, a) ? !1 : this.getShapeGeometry(i).hitTestPoint(
      this.getPointInShapeSpace(e, n),
      o,
      s
    );
  }
  /**
   * Convert a point in the current page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInShapeSpace(e, n) {
    const r = typeof e == "string" ? e : e.id;
    return this._getShapePageTransformCache().get(r).clone().invert().applyToPoint(n);
  }
  /**
   * Convert a delta in the current page space to a point in the local space of a shape's parent.
   *
   * @example
   * ```ts
   * editor.getPointInParentSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInParentSpace(e, n) {
    const r = typeof e == "string" ? e : e.id, s = this.getShape(r);
    if (!s) return new I(0, 0);
    if (Ys(s.parentId)) return I.From(n);
    const o = this.getShapePageTransform(s.parentId);
    return o ? o.clone().invert().applyToPoint(n) : I.From(n);
  }
  getCurrentPageShapes() {
    return Array.from(this.getCurrentPageShapeIds(), (e) => this.store.get(e));
  }
  getCurrentPageShapesSorted() {
    const e = [], n = this.getSortedChildIdsForParent(this.getCurrentPageId());
    for (let r = 0, s = n.length; r < s; r++)
      Doe(this, n[r], e);
    return e;
  }
  getCurrentPageRenderingShapesSorted() {
    const e = this.getCulledShapes();
    return this.getCurrentPageShapesSorted().filter(
      ({ id: n }) => !e.has(n) && !this.isShapeHidden(n)
    );
  }
  isShapeOfType(e, n) {
    const r = typeof e == "string" ? this.getShape(e) : e;
    return r ? r.type === n : !1;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * editor.getShape('box1')
   * ```
   *
   * @param shape - The shape (or the id of the shape) to get.
   *
   * @public
   */
  getShape(e) {
    const n = typeof e == "string" ? e : e.id;
    if (ei(n))
      return this.store.get(n);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * editor.getShapeParent(myShape)
   * ```
   *
   * @public
   */
  getShapeParent(e) {
    const n = typeof e == "string" ? e : e == null ? void 0 : e.id;
    if (!n) return;
    const r = this.getShape(n);
    if (!(r === void 0 || !ei(r.parentId)))
      return this.getShape(r.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
   * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
   * undefined.
   *
   * @internal
   */
  getShapeNearestSibling(e, n) {
    return n ? n.parentId === e.parentId ? n : this.findShapeAncestor(
      n,
      (s) => s.parentId === e.parentId
    ) : void 0;
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * editor.isShapeInPage(myShape)
   * editor.isShapeInPage(myShape, 'page1')
   * ```
   *
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   *
   * @public
   */
  isShapeInPage(e, n = this.getCurrentPageId()) {
    const r = typeof e == "string" ? e : e.id, s = this.getShape(r);
    if (!s) return !1;
    let o = !1;
    if (s.parentId === n)
      o = !0;
    else {
      let i = this.getShape(s.parentId);
      e: for (; i; ) {
        if (i.parentId === n) {
          o = !0;
          break e;
        }
        i = this.getShape(i.parentId);
      }
    }
    return o;
  }
  /**
   * Get the id of the containing page for a given shape.
   *
   * @param shape - The shape to get the page id for.
   *
   * @returns The id of the page that contains the shape, or undefined if the shape is undefined.
   *
   * @public
   */
  getAncestorPageId(e) {
    const n = typeof e == "string" ? e : e == null ? void 0 : e.id, r = n && this.getShape(n);
    if (r)
      return Ys(r.parentId) ? r.parentId : this.getAncestorPageId(this.getShape(r.parentId));
  }
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * editor.reparentShapes([box1, box2], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1', 4)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   *
   * @public
   */
  reparentShapes(e, n, r) {
    const s = typeof e[0] == "string" ? e : e.map((f) => f.id);
    if (s.length === 0) return this;
    const o = [], i = Ys(n) ? we.Identity() : this.getShapePageTransform(n), a = i.rotation();
    let c = [];
    const l = mt(this.getSortedChildIdsForParent(n).map((f) => this.getShape(f)));
    if (r) {
      const f = l.find((p) => p.index === r);
      if (f) {
        const p = l[l.indexOf(f) + 1];
        p ? c = sy(r, p.index, s.length) : c = wM(r, s.length);
      } else {
        const p = l.sort(Js).find((g) => g.index > r);
        p ? c = sy(r, p.index, s.length) : c = wM(r, s.length);
      }
    } else {
      const f = l.length && l[l.length - 1];
      c = f ? wM(f.index, s.length) : ow(s.length);
    }
    const d = i.clone().invert(), u = mt(s.map((f) => this.getShape(f))).sort(Js);
    return this.run(
      () => {
        for (let f = 0; f < u.length; f++) {
          const p = u[f], g = this.getShapePageTransform(p);
          if (!g) continue;
          const y = g.point();
          if (!y) continue;
          const m = d.applyToPoint(y), v = g.rotation() - a;
          if (p.id === n)
            throw Error("Attempted to reparent a shape to itself!");
          o.push({
            id: p.id,
            type: p.type,
            parentId: n,
            x: m.x,
            y: m.y,
            rotation: v,
            index: c[f]
          });
        }
        this.updateShapes(o);
      },
      { ignoreShapeLock: !0 }
    ), this;
  }
  /**
   * Get the index above the highest child of a given parent.
   *
   * @param parent - The parent (or the id) of the parent.
   *
   * @returns The index.
   *
   * @public
   */
  getHighestIndexForParent(e) {
    const n = typeof e == "string" ? e : e.id, r = this._parentIdsToChildIds.get()[n];
    if (!r || r.length === 0)
      return "a1";
    const s = this.getShape(r[r.length - 1]);
    return Bc(s.index);
  }
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * editor.getSortedChildIdsForParent('frame1')
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   *
   * @public
   */
  getSortedChildIdsForParent(e) {
    const n = typeof e == "string" ? e : e.id, r = this._parentIdsToChildIds.get()[n];
    return r || Br;
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * editor.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   * @param visitor - The visitor function.
   *
   * @public
   */
  visitDescendants(e, n) {
    const r = this.getSortedChildIdsForParent(e);
    for (const s of r)
      n(s) !== !1 && this.visitDescendants(s, n);
    return this;
  }
  /**
   * Get the shape ids of all descendants of the given shapes (including the shapes themselves). IDs are returned in z-index order.
   *
   * @param ids - The ids of the shapes to get descendants of.
   *
   * @returns The descendant ids.
   *
   * @public
   */
  getShapeAndDescendantIds(e) {
    const n = /* @__PURE__ */ new Set();
    for (const r of e.map((s) => this.getShape(s)).sort(Js))
      n.add(r.id), this.visitDescendants(r, (s) => {
        n.add(s);
      });
    return n;
  }
  /** @deprecated Use {@link Editor.getDraggingOverShape} instead */
  getDroppingOverShape(e, n) {
    return this.getDraggingOverShape(e, n);
  }
  /**
   * Get the shape that some shapes should be dropped on at a given point.
   *
   * @param point - The point to find the parent for.
   * @param droppingShapes - The shapes that are being dropped.
   *
   * @returns The shape to drop on.
   *
   * @public
   */
  getDraggingOverShape(e, n) {
    const r = mt(n.map((o) => this.getShape(o))).filter(
      (o) => !o.isLocked && !this.isShapeHidden(o)
    ), s = this.getShapesAtPoint(e, {
      hitInside: !0,
      margin: 0
    }).filter(
      (o) => !n.includes(o) && !o.isLocked && !this.isShapeHidden(o) && !r.includes(o)
    );
    for (const o of s) {
      const i = this.getShapeUtil(o);
      if (i.onDragShapesOver || i.onDragShapesIn || i.onDragShapesOut || i.onDropShapesOver)
        return o;
    }
  }
  /**
   * Get the shape that should be selected when you click on a given shape, assuming there is
   * nothing already selected. It will not return anything higher than or including the current
   * focus layer.
   *
   * @param shape - The shape to get the outermost selectable shape for.
   * @param filter - A function to filter the selectable shapes.
   *
   * @returns The outermost selectable shape.
   *
   * @public
   */
  getOutermostSelectableShape(e, n) {
    const r = typeof e == "string" ? e : e.id, s = this.getShape(r);
    let o = s, i = s;
    const a = this.getFocusedGroup();
    for (; i; ) {
      if (this.isShapeOfType(i, "group") && (a == null ? void 0 : a.id) !== i.id && !this.hasAncestor(a, i.id) && ((n == null ? void 0 : n(i)) ?? !0))
        o = i;
      else if ((a == null ? void 0 : a.id) === i.id)
        break;
      i = this.getShapeParent(i);
    }
    return o;
  }
  _getBindingsIndexCache() {
    const e = Oze(this);
    return this.store.createComputedCache(
      "bindingsIndex",
      (n) => e.get().get(n.id),
      // we can ignore the shape equality check here because the index is
      // computed incrementally based on what bindings are in the store
      { areRecordsEqual: () => !0 }
    );
  }
  /**
   * Get a binding from the store by its ID if it exists.
   */
  getBinding(e) {
    return this.store.get(e);
  }
  /**
   * Get all bindings of a certain type _from_ a particular shape. These are the bindings whose
   * `fromId` matched the shape's ID.
   */
  getBindingsFromShape(e, n) {
    const r = typeof e == "string" ? e : e.id;
    return this.getBindingsInvolvingShape(r).filter(
      (s) => s.fromId === r && s.type === n
    );
  }
  /**
   * Get all bindings of a certain type _to_ a particular shape. These are the bindings whose
   * `toId` matches the shape's ID.
   */
  getBindingsToShape(e, n) {
    const r = typeof e == "string" ? e : e.id;
    return this.getBindingsInvolvingShape(r).filter(
      (s) => s.toId === r && s.type === n
    );
  }
  /**
   * Get all bindings involving a particular shape. This includes bindings where the shape is the
   * `fromId` or `toId`. If a type is provided, only bindings of that type are returned.
   */
  getBindingsInvolvingShape(e, n) {
    const r = typeof e == "string" ? e : e.id, s = this._getBindingsIndexCache().get(r) ?? Br;
    return n ? s.filter((o) => o.type === n) : s;
  }
  /**
   * Create bindings from a list of partial bindings. You can omit the ID and most props of a
   * binding, but the `type`, `toId`, and `fromId` must all be provided.
   */
  createBindings(e) {
    const n = [];
    for (const r of e) {
      const s = this.getShape(r.fromId), o = this.getShape(r.toId);
      if (!s || !o || !this.canBindShapes({ fromShape: s, toShape: o, binding: r })) continue;
      const a = this.getBindingUtil(r.type).getDefaultProps(), c = this.store.schema.types.binding.create({
        ...r,
        id: r.id ?? ip(),
        props: {
          ...a,
          ...r.props
        }
      });
      n.push(c);
    }
    return this.store.put(n), this;
  }
  /**
   * Create a single binding from a partial. You can omit the ID and most props of a binding, but
   * the `type`, `toId`, and `fromId` must all be provided.
   */
  createBinding(e) {
    return this.createBindings([e]);
  }
  /**
   * Update bindings from a list of partial bindings. Each partial must include an ID, which will
   * be used to match the binding to it's existing record. If there is no existing record, that
   * binding is skipped. The changes from the partial are merged into the existing record.
   */
  updateBindings(e) {
    const n = [];
    for (const r of e) {
      if (!r) continue;
      const s = this.getBinding(r.id);
      if (!s) continue;
      const o = vl(s, r);
      if (o === s) continue;
      const i = this.getShape(o.fromId), a = this.getShape(o.toId);
      !i || !a || this.canBindShapes({ fromShape: i, toShape: a, binding: o }) && n.push(o);
    }
    return this.store.put(n), this;
  }
  /**
   * Update a binding from a partial binding. Each partial must include an ID, which will be used
   * to match the binding to it's existing record. If there is no existing record, that binding is
   * skipped. The changes from the partial are merged into the existing record.
   */
  updateBinding(e) {
    return this.updateBindings([e]);
  }
  /**
   * Delete several bindings by their IDs. If a binding ID doesn't exist, it's ignored.
   */
  deleteBindings(e, { isolateShapes: n = !1 } = {}) {
    const r = e.map((s) => typeof s == "string" ? s : s.id);
    return n ? this.store.atomic(() => {
      var s, o;
      for (const i of r) {
        const a = this.getBinding(i);
        if (!a) continue;
        const c = this.getBindingUtil(a);
        (s = c.onBeforeIsolateFromShape) == null || s.call(c, { binding: a, removedShape: this.getShape(a.toId) }), (o = c.onBeforeIsolateToShape) == null || o.call(c, { binding: a, removedShape: this.getShape(a.fromId) }), this.store.remove([i]);
      }
    }) : this.store.remove(r), this;
  }
  /**
   * Delete a binding by its ID. If the binding doesn't exist, it's ignored.
   */
  deleteBinding(e, n) {
    return this.deleteBindings([e], n);
  }
  canBindShapes({
    fromShape: e,
    toShape: n,
    binding: r
  }) {
    const s = typeof e == "string" ? e : e.type, o = typeof n == "string" ? n : n.type, i = typeof r == "string" ? r : r.type, a = { fromShapeType: s, toShapeType: o, bindingType: i };
    return s === o ? this.getShapeUtil(s).canBind(a) : this.getShapeUtil(s).canBind(a) && this.getShapeUtil(o).canBind(a);
  }
  /* -------------------- Commands -------------------- */
  /**
   * Rotate shapes by a delta in radians.
   *
   * @example
   * ```ts
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI)
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   * @param opts - The options for the rotation.
   */
  rotateShapesBy(e, n, r) {
    const s = typeof e[0] == "string" ? e : e.map((i) => i.id);
    if (s.length <= 0) return this;
    const o = sre({ editor: this, ids: s });
    return o ? (r_({
      delta: n,
      snapshot: o,
      editor: this,
      stage: "one-off",
      centerOverride: r == null ? void 0 : r.center
    }), this) : this;
  }
  // Gets a shape partial that includes life cycle changes: on translate start, on translate, on translate end
  getChangesToTranslateShape(e, n) {
    var c, l, d;
    let r = e;
    const s = this.getShapeUtil(e), o = (c = s.onTranslateStart) == null ? void 0 : c.call(s, r);
    o && (r = vl(r, o)), r = vl(r, {
      id: e.id,
      type: e.type,
      x: n.x,
      y: n.y
    });
    const i = (l = s.onTranslate) == null ? void 0 : l.call(s, e, r);
    i && (r = vl(r, i));
    const a = (d = s.onTranslateEnd) == null ? void 0 : d.call(s, e, r);
    return a && (r = vl(r, a)), r;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * editor.nudgeShapes(['box1', 'box2'], { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param offset - The offset to apply to the shapes.
   */
  nudgeShapes(e, n) {
    const r = typeof e[0] == "string" ? e : e.map((o) => o.id);
    if (r.length <= 0) return this;
    const s = [];
    for (const o of r) {
      const i = this.getShape(o), a = I.From(n), c = this.getShapeParentTransform(i);
      c && a.rot(-c.rotation()), s.push(this.getChangesToTranslateShape(i, a.add(i)));
    }
    return this.updateShapes(s), this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * editor.duplicateShapes(['box1', 'box2'], { x: 8, y: 8 })
   * editor.duplicateShapes(editor.getSelectedShapes(), { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to duplicate.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   *
   * @public
   */
  duplicateShapes(e, n) {
    return this.run(() => {
      const r = typeof e[0] == "string" ? e : e.map((f) => f.id), s = this._shouldIgnoreShapeLock ? r : this._getUnlockedShapeIds(r);
      if (s.length <= 0) return this;
      const o = new Set(s), i = this.getShapeAndDescendantIds(s), a = [...i].reverse(), c = /* @__PURE__ */ new Map();
      for (const f of i)
        c.set(f, $n());
      const { shapesToCreateWithOriginals: l, bindingsToCreate: d } = SH(
        this,
        i,
        (f) => {
          const p = [];
          for (const y of f) {
            const m = this.getBinding(y);
            if (!m) continue;
            const v = ip();
            p.push({
              ...m,
              id: v,
              fromId: Io(c.get(m.fromId)),
              toId: Io(c.get(m.toId))
            });
          }
          const g = [];
          for (const y of a) {
            const m = Io(c.get(y)), v = this.getShape(y);
            if (!v) continue;
            let b = 0, x = 0;
            if (n && o.has(y)) {
              const w = this.getShapeParentTransform(v), S = new I(n.x, n.y).rot(-w.rotation());
              b = S.x, x = S.y;
            }
            g.push({
              shape: {
                ...v,
                id: m,
                x: v.x + b,
                y: v.y + x,
                // Use a dummy index for now, it will get updated outside of the `withIsolatedShapes`
                index: "a1",
                parentId: c.get(v.parentId) ?? v.parentId
              },
              originalShape: v
            });
          }
          return { shapesToCreateWithOriginals: g, bindingsToCreate: p };
        }
      );
      l.forEach(({ shape: f, originalShape: p }) => {
        const g = p.parentId, y = this.getSortedChildIdsForParent(g), m = y.indexOf(p.id), v = y[m + 1], b = v ? this.getShape(v) : void 0, x = oy(p.index, b == null ? void 0 : b.index);
        f.index = x;
      });
      const u = l.map(({ shape: f }) => f);
      if (!this.canCreateShapes(u)) {
        D1(this);
        return;
      }
      if (this.createShapes(u), this.createBindings(d), this.setSelectedShapes(mt(s.map((f) => c.get(f)))), n !== void 0) {
        const f = this.getSelectionPageBounds(), p = this.getViewportPageBounds();
        f && !p.contains(f) && this.centerOnPoint(f.center, {
          animation: { duration: this.options.animationMediumMs }
        });
      }
    }), this;
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * editor.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   *
   * @public
   */
  moveShapesToPage(e, n) {
    const r = typeof e[0] == "string" ? e : e.map((a) => a.id);
    if (r.length === 0) return this;
    if (this.getIsReadonly()) return this;
    const s = this.getCurrentPageId();
    if (n === s) return this;
    if (!this.store.has(n)) return this;
    const o = this.getContentFromCurrentPage(r);
    if (!o) return this;
    if (this.getPageShapeIds(n).size + o.shapes.length > this.options.maxShapesPerPage)
      return D1(this, n), this;
    const i = this.getCamera().z;
    return this.run(() => {
      this.deleteShapes(r), this.setCurrentPage(n), this.setFocusedGroup(null), this.selectNone(), this.putContentOntoCurrentPage(o, {
        select: !0,
        preserveIds: !0,
        preservePosition: !0
      }), this.setCamera({ ...this.getCamera(), z: i }), this.centerOnPoint(this.getSelectionRotatedPageBounds().center);
    }), this;
  }
  /**
   * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.
   *
   * @param shapes - The shapes (or shape ids) to toggle.
   *
   * @public
   */
  toggleLock(e) {
    const n = typeof e[0] == "string" ? e : e.map((i) => i.id);
    if (this.getIsReadonly() || n.length === 0) return this;
    let r = !0, s = !0;
    const o = [];
    for (const i of n) {
      const a = this.getShape(i);
      a && (o.push(a), a.isLocked ? s = !1 : r = !1);
    }
    return this.run(() => {
      s ? (this.updateShapes(
        o.map((i) => ({ id: i.id, type: i.type, isLocked: !0 }))
      ), this.setSelectedShapes([])) : r ? this.updateShapes(
        o.map((i) => ({ id: i.id, type: i.type, isLocked: !1 }))
      ) : this.updateShapes(
        o.map((i) => ({ id: i.id, type: i.type, isLocked: !0 }))
      );
    }), this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * editor.sendToBack(['id1', 'id2'])
   * editor.sendToBack(box1, box2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  sendToBack(e) {
    const n = typeof e[0] == "string" ? e : e.map((s) => s.id), r = M1(this, "toBack", n, {
      considerAllShapes: !0
    });
    return r && this.updateShapes(r), this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'])
   * editor.sendBackward([box1, box2])
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the backward operation.
   *
   * @public
   */
  sendBackward(e, n = {}) {
    const r = typeof e[0] == "string" ? e : e.map((o) => o.id), s = M1(this, "backward", r, n);
    return s && this.updateShapes(s), this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'])
   * editor.bringForward(box1,  box2)
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the forward operation.
   *
   * @public
   */
  bringForward(e, n = {}) {
    const r = typeof e[0] == "string" ? e : e.map((o) => o.id), s = M1(this, "forward", r, n);
    return s && this.updateShapes(s), this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * editor.bringToFront(['id1', 'id2'])
   * editor.bringToFront([box1, box2])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  bringToFront(e) {
    const n = typeof e[0] == "string" ? e : e.map((s) => s.id), r = M1(this, "toFront", n);
    return r && this.updateShapes(r), this;
  }
  /**
   * @internal
   */
  collectShapesViaArrowBindings(e) {
    const { initialShapes: n, resultShapes: r, resultBounds: s, bindings: o, visited: i } = e;
    for (const a of o)
      for (const c of [a.fromId, a.toId])
        if (!i.has(c)) {
          const l = n.find((d) => d.id === c);
          if (l && !i.has(l.id)) {
            i.add(l.id);
            const d = this.getShapePageBounds(l);
            if (!d) continue;
            r.push(l), s.push(d), this.collectShapesViaArrowBindings({
              ...e,
              bindings: this.getBindingsInvolvingShape(l, "arrow")
            });
          }
        }
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * editor.flipShapes([box1, box2], 'horizontal', 32)
   * editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal', 32)
   * ```
   *
   * @param shapes - The ids of the shapes to flip.
   * @param operation - Whether to flip horizontally or vertically.
   *
   * @public
   */
  flipShapes(e, n) {
    if (this.getIsReadonly()) return this;
    const r = typeof e[0] == "string" ? e : e.map((c) => c.id), s = mt(r.map((c) => this.getShape(c)));
    for (const c of s)
      if (this.isShapeOfType(c, "group")) {
        const l = mt(
          this.getSortedChildIdsForParent(c.id).map((d) => this.getShape(d))
        );
        s.push(...l);
      }
    const o = [], i = [];
    for (const c of s) {
      const l = this.getShapeUtil(c);
      if (!l.canBeLaidOut(c, {
        type: "flip",
        shapes: s
      }))
        continue;
      const d = this.getShapePageBounds(c), u = this.getShapeGeometry(c).bounds, f = this.getShapePageTransform(c.id);
      d && u && f && (o.push({
        shape: c,
        localBounds: u,
        pageTransform: f,
        isAspectRatioLocked: l.isAspectRatioLocked(c)
      }), i.push(d));
    }
    if (!o.length) return this;
    const a = _e.Common(i).center;
    return this.run(() => {
      for (const { shape: c, localBounds: l, pageTransform: d, isAspectRatioLocked: u } of o)
        this.resizeShape(
          c.id,
          { x: n === "horizontal" ? -1 : 1, y: n === "vertical" ? -1 : 1 },
          {
            initialBounds: l,
            initialPageTransform: d,
            initialShape: c,
            isAspectRatioLocked: u,
            mode: "scale_shape",
            scaleOrigin: a,
            scaleAxisRotation: 0
          }
        );
    }), this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * editor.stackShapes([box1, box2], 'horizontal')
   * editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stack.
   * @param operation - Whether to stack horizontally or vertically.
   * @param gap - The gap to leave between shapes. By default, uses the editor's `adjacentShapeMargin` option.
   *
   * @public
   */
  stackShapes(e, n, r) {
    var v, b;
    const s = r ?? this.options.adjacentShapeMargin, o = typeof e[0] == "string" ? e : e.map((x) => x.id);
    if (this.getIsReadonly()) return this;
    const i = mt(o.map((x) => this.getShape(x))), a = [], c = /* @__PURE__ */ new Set();
    for (const x of i) {
      if (c.has(x.id)) continue;
      c.add(x.id);
      const w = this.getShapePageBounds(x);
      if (!w || !((b = (v = this.getShapeUtil(x)).canBeLaidOut) != null && b.call(v, x, {
        type: "stack",
        shapes: i
      })))
        continue;
      const S = [x], C = [w];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(x.id, "arrow"),
        initialShapes: i,
        resultShapes: S,
        resultBounds: C,
        visited: c
      });
      const _ = _e.Common(C);
      _ && a.push({
        shapes: S,
        pageBounds: _
      });
    }
    const l = a.length;
    if (s === 0 && l < 3 || l < 2) return this;
    let d, u, f, p;
    n === "horizontal" ? (d = "x", u = "minX", f = "maxX", p = "width") : (d = "y", u = "minY", f = "maxY", p = "height");
    let g = 0;
    if (s === 0) {
      const x = {};
      a.sort((S, C) => S.pageBounds[u] - C.pageBounds[u]);
      for (let S = 0; S < l - 1; S++) {
        const C = a[S], E = a[S + 1].pageBounds[u] - C.pageBounds[f];
        x[E] || (x[E] = 0), x[E]++;
      }
      let w = 1;
      for (const [S, C] of Object.entries(x))
        C > w && (w = C, g = parseFloat(S));
      if (w === 1) {
        let S = 0;
        for (const [C, _] of Object.entries(x))
          g += parseFloat(C) * _, S += _;
        g /= S;
      }
    } else
      g = s;
    const y = [];
    let m = a[0].pageBounds[f];
    for (let x = 1; x < a.length; x++) {
      const { shapes: w, pageBounds: S } = a[x], C = new I();
      C[d] = m + g - S[d];
      for (const _ of w) {
        const E = C.clone(), M = this.getShapeParent(_);
        if (M) {
          const N = this.getShapePageTransform(M);
          N && E.rot(-N.rotation());
        }
        E.add(_), y.push(this.getChangesToTranslateShape(_, E));
      }
      m += S[p] + g;
    }
    return this.updateShapes(y), this;
  }
  /**
   * Pack shapes into a grid centered on their current position. Based on potpack (https://github.com/mapbox/potpack).
   *
   * @example
   * ```ts
   * editor.packShapes([box1, box2])
   * editor.packShapes(editor.getSelectedShapeIds(), 32)
   * ```
   *
   *
   * @param shapes - The shapes (or shape ids) to pack.
   * @param gap - The padding to apply to the packed shapes. Defaults to the editor's `adjacentShapeMargin` option.
   */
  packShapes(e, n) {
    var S, C;
    if (this.getIsReadonly()) return this;
    const r = n ?? this.options.adjacentShapeMargin, s = typeof e[0] == "string" ? e : e.map((_) => _.id), o = mt(s.map((_) => this.getShape(_))), i = [], a = [], c = /* @__PURE__ */ new Set();
    for (const _ of o) {
      if (c.has(_.id)) continue;
      c.add(_.id);
      const E = this.getShapePageBounds(_);
      if (!E || !((C = (S = this.getShapeUtil(_)).canBeLaidOut) != null && C.call(S, _, {
        type: "pack",
        shapes: o
      })))
        continue;
      const M = [_], N = [E];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(_.id, "arrow"),
        initialShapes: o,
        resultShapes: M,
        resultBounds: N,
        visited: c
      });
      const O = _e.Common(N);
      O && (i.push({
        shapes: M,
        pageBounds: O,
        nextPageBounds: O.clone()
      }), a.push(O));
    }
    if (i.length < 2) return this;
    let l = 0;
    for (const { pageBounds: _ } of i)
      l += _.width * _.height;
    const d = _e.Common(a), u = d.width;
    i.sort((_, E) => _.pageBounds.width - E.pageBounds.width).sort((_, E) => _.pageBounds.height - E.pageBounds.height);
    const f = Math.max(Math.ceil(Math.sqrt(l / 0.95)), u), p = [new _e(d.x, d.y, f, 1 / 0)];
    let g = 0, y = 0, m, v;
    for (const { nextPageBounds: _ } of i)
      for (let E = p.length - 1; E >= 0; E--)
        if (m = p[E], !(_.width > m.width || _.height > m.height)) {
          _.x = m.x, _.y = m.y, y = Math.max(y, _.maxY), g = Math.max(g, _.maxX), _.width === m.width && _.height === m.height ? (v = p.pop(), E < p.length && (p[E] = v)) : _.height === m.height ? (m.x += _.width + r, m.width -= _.width + r) : _.width === m.width ? (m.y += _.height + r, m.height -= _.height + r) : (p.push(
            new _e(
              m.x + (_.width + r),
              m.y,
              m.width - (_.width + r),
              _.height
            )
          ), m.y += _.height + r, m.height -= _.height + r);
          break;
        }
    const b = _e.Common(i.map((_) => _.nextPageBounds)), x = I.Sub(d.center, b.center), w = [];
    for (const { shapes: _, pageBounds: E, nextPageBounds: M } of i) {
      const N = I.Sub(M.point, E.point).add(x);
      for (const O of _) {
        const D = N.clone();
        if (this.getShapeParent(O)) {
          const A = this.getShapeParentTransform(O);
          A && D.rot(-A.rotation());
        }
        D.add(O), w.push(this.getChangesToTranslateShape(O, D));
      }
    }
    return w.length && this.updateShapes(w), this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * editor.alignShapes([box1, box2], 'left')
   * editor.alignShapes(editor.getSelectedShapeIds(), 'left')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to align.
   * @param operation - The align operation to apply.
   *
   * @public
   */
  alignShapes(e, n) {
    var d, u;
    if (this.getIsReadonly()) return this;
    const r = typeof e[0] == "string" ? e : e.map((f) => f.id), s = mt(r.map((f) => this.getShape(f))), o = [], i = [], a = /* @__PURE__ */ new Set();
    for (const f of s) {
      if (a.has(f.id)) continue;
      a.add(f.id);
      const p = this.getShapePageBounds(f);
      if (!p || !((u = (d = this.getShapeUtil(f)).canBeLaidOut) != null && u.call(d, f, {
        type: "align",
        shapes: s
      })))
        continue;
      const g = [f], y = [p];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(f.id, "arrow"),
        initialShapes: s,
        resultShapes: g,
        resultBounds: y,
        visited: a
      });
      const m = _e.Common(y);
      m && (o.push({
        shapes: g,
        pageBounds: m
      }), i.push(m));
    }
    if (o.length < 2) return this;
    const c = _e.Common(i), l = [];
    return o.forEach(({ shapes: f, pageBounds: p }) => {
      const g = new I();
      switch (n) {
        case "top": {
          g.y = c.minY - p.minY;
          break;
        }
        case "center-vertical": {
          g.y = c.midY - p.minY - p.height / 2;
          break;
        }
        case "bottom": {
          g.y = c.maxY - p.minY - p.height;
          break;
        }
        case "left": {
          g.x = c.minX - p.minX;
          break;
        }
        case "center-horizontal": {
          g.x = c.midX - p.minX - p.width / 2;
          break;
        }
        case "right": {
          g.x = c.maxX - p.minX - p.width;
          break;
        }
      }
      for (const y of f) {
        const m = g.clone(), v = this.getShapeParent(y);
        if (v) {
          const b = this.getShapePageTransform(v);
          b && m.rot(-b.rotation());
        }
        m.add(y), l.push(this.getChangesToTranslateShape(y, m));
      }
    }), this.updateShapes(l), this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * editor.distributeShapes([box1, box2], 'horizontal')
   * editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to distribute.
   * @param operation - Whether to distribute shapes horizontally or vertically.
   *
   * @public
   */
  distributeShapes(e, n) {
    var x, w;
    if (this.getIsReadonly()) return this;
    const r = typeof e[0] == "string" ? e : e.map((S) => S.id), s = mt(r.map((S) => this.getShape(S))), o = [], i = /* @__PURE__ */ new Set();
    for (const S of s) {
      if (i.has(S.id)) continue;
      i.add(S.id);
      const C = this.getShapePageBounds(S);
      if (!C || !((w = (x = this.getShapeUtil(S)).canBeLaidOut) != null && w.call(x, S, {
        type: "distribute",
        shapes: s
      })))
        continue;
      const _ = [S], E = [C];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(S.id, "arrow"),
        initialShapes: s,
        resultShapes: _,
        resultBounds: E,
        visited: i
      });
      const M = _e.Common(E);
      M && o.push({
        shapes: _,
        pageBounds: M
      });
    }
    if (o.length < 3) return this;
    let a, c, l, d;
    n === "horizontal" ? (a = "x", c = "minX", l = "maxX", d = "width") : (a = "y", c = "minY", l = "maxY", d = "height");
    const u = [], f = o.sort((S, C) => S.pageBounds[c] - C.pageBounds[c])[0], p = o.sort((S, C) => C.pageBounds[l] - S.pageBounds[l])[0];
    if (f === p) {
      const S = new Set(f.shapes.map((C) => C.id));
      return this.distributeShapes(
        r.filter((C) => !S.has(C)),
        n
      );
    }
    const g = o.filter((S) => S !== f && S !== p).sort((S, C) => S.pageBounds[c] === C.pageBounds[c] ? S.shapes[0].id < C.shapes[0].id ? -1 : 1 : S.pageBounds[c] - C.pageBounds[c]), y = f.pageBounds[l], m = p.pageBounds[c] - y, v = g.reduce((S, C) => S + C.pageBounds[d], 0), b = (m - v) / (g.length + 1);
    for (let S = y + b, C = 0; C < g.length; C++) {
      const { shapes: _, pageBounds: E } = g[C], M = new I();
      M[a] = S - E[a], S + E[d] > p.pageBounds[l] - 1 && (M[a] = p.pageBounds[l] - E[l] - 1);
      for (const N of _) {
        const O = M.clone(), D = this.getShapeParent(N);
        if (D) {
          const k = this.getShapePageTransform(D);
          k && O.rot(-k.rotation());
        }
        O.add(N), u.push(this.getChangesToTranslateShape(N, O));
      }
      S += E[d] + b;
    }
    return this.updateShapes(u), this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * editor.stretchShapes([box1, box2], 'horizontal')
   * editor.stretchShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stretch.
   * @param operation - Whether to stretch shapes horizontally or vertically.
   *
   * @public
   */
  stretchShapes(e, n) {
    var f, p;
    const r = typeof e[0] == "string" ? e : e.map((g) => g.id);
    if (this.getIsReadonly()) return this;
    const s = mt(r.map((g) => this.getShape(g))).filter(
      (g) => {
        var y;
        return ((y = this.getShapePageTransform(g)) == null ? void 0 : y.rotation()) % (mn / 2) === 0;
      }
    ), o = [], i = [], a = /* @__PURE__ */ new Set();
    for (const g of s) {
      if (a.has(g.id)) continue;
      a.add(g.id);
      const y = this.getShapePageBounds(g);
      if (!y) continue;
      const m = [g], v = [y];
      if (!((p = (f = this.getShapeUtil(g)).canBeLaidOut) != null && p.call(f, g, {
        type: "stretch",
        shapes: s
      })))
        continue;
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(g.id, "arrow"),
        initialShapes: s,
        resultShapes: m,
        resultBounds: v,
        visited: a
      });
      const b = _e.Common(v);
      b && (o.push({
        shapes: m,
        pageBounds: b
      }), i.push(b));
    }
    if (o.length < 2) return this;
    const c = _e.Common(i);
    let l, d, u;
    return n === "horizontal" ? (l = "x", d = "minX", u = "width") : (l = "y", d = "minY", u = "height"), this.run(() => {
      o.forEach(({ shapes: g, pageBounds: y }) => {
        const m = new I();
        m[l] = c[d] - y[d];
        const v = y.center.clone();
        v[l] = c[d];
        const b = new I(1, 1);
        b[l] = c[u] / y[u];
        for (const x of g) {
          const w = m.clone(), S = this.getShapeParentTransform(x);
          S && m.rot(-S.rotation()), w.add(x);
          const C = this.getChangesToTranslateShape(x, w);
          this.updateShape(C), this.resizeShape(x.id, b, {
            initialBounds: this.getShapeGeometry(x).bounds,
            scaleOrigin: v,
            isAspectRatioLocked: this.getShapeUtil(x).isAspectRatioLocked(x),
            scaleAxisRotation: 0
          });
        }
      });
    }), this;
  }
  /**
   * Resize a shape.
   *
   * @param shape - The shape (or the shape id of the shape) to resize.
   * @param scale - The scale factor to apply to the shape.
   * @param opts - Additional options.
   *
   * @public
   */
  resizeShape(e, n, r = {}) {
    var g, y, m;
    const s = typeof e == "string" ? e : e.id;
    if (this.getIsReadonly()) return this;
    Number.isFinite(n.x) || (n = new I(1, n.y)), Number.isFinite(n.y) || (n = new I(n.x, 1));
    const o = r.initialShape ?? this.getShape(s);
    if (!o) return this;
    const i = r.scaleOrigin ?? ((g = this.getShapePageBounds(s)) == null ? void 0 : g.center);
    if (!i) return this;
    const a = r.initialPageTransform ? we.Cast(r.initialPageTransform) : this.getShapePageTransform(s);
    if (!a) return this;
    const c = a.rotation();
    if (c == null) return this;
    const l = r.scaleAxisRotation ?? c, d = r.initialBounds ?? this.getShapeGeometry(s).bounds;
    if (!d) return this;
    const u = r.isAspectRatioLocked ?? this.getShapeUtil(o).isAspectRatioLocked(o);
    if (!tne(c, l))
      return this._resizeUnalignedShape(s, n, {
        ...r,
        initialBounds: d,
        scaleOrigin: i,
        scaleAxisRotation: l,
        initialPageTransform: a,
        isAspectRatioLocked: u,
        initialShape: o
      });
    const f = this.getShapeUtil(o);
    u && (Math.abs(n.x) > Math.abs(n.y) ? n = new I(n.x, Math.sign(n.y) * Math.abs(n.x)) : n = new I(Math.sign(n.x) * Math.abs(n.y), n.y));
    let p = !1;
    if (f.onResize && f.canResize(o)) {
      const v = this._scalePagePoint(
        we.applyToPoint(a, new I(0, 0)),
        i,
        n,
        l
      ), b = this.getPointInParentSpace(o.id, v), x = new I(n.x, n.y), w = Hr(
        (c - l) % Math.PI,
        0
      );
      x.x = w ? n.x : n.y, x.y = w ? n.y : n.x;
      const S = we.applyToPoint(a, new I()), { x: C, y: _ } = this.getPointInParentSpace(o.id, S);
      let E = o;
      r.skipStartAndEndCallbacks || (E = vl(
        o,
        ((y = f.onResizeStart) == null ? void 0 : y.call(f, o)) ?? void 0
      ));
      const M = f.onResize(
        { ...o, x: C, y: _ },
        {
          newPoint: b,
          handle: r.dragHandle ?? "bottom_right",
          // don't set isSingle to true for children
          mode: r.mode ?? "scale_shape",
          scaleX: x.x,
          scaleY: x.y,
          initialBounds: d,
          initialShape: o
        }
      );
      M && (p = !0), E = vl(E, {
        id: s,
        type: o.type,
        x: b.x,
        y: b.y,
        ...M
      }), r.skipStartAndEndCallbacks || (E = vl(
        E,
        ((m = f.onResizeEnd) == null ? void 0 : m.call(f, o, E)) ?? void 0
      )), this.updateShapes([E]);
    }
    if (!p) {
      const v = we.applyToPoint(a, d.center), b = this._scalePagePoint(
        v,
        i,
        n,
        l
      ), x = this.getPointInParentSpace(
        o.id,
        v
      ), w = this.getPointInParentSpace(o.id, b), S = I.Sub(w, x);
      this.updateShapes([
        {
          id: s,
          type: o.type,
          x: o.x + S.x,
          y: o.y + S.y
        }
      ]);
    }
    return this;
  }
  /** @internal */
  _scalePagePoint(e, n, r, s) {
    const o = I.RotWith(e, n, -s).sub(n), i = I.MulV(o, r);
    return I.Add(i, n).rotWith(
      n,
      s
    );
  }
  /** @internal */
  _resizeUnalignedShape(e, n, r) {
    const { type: s } = r.initialShape, o = new I(n.x, n.y);
    if (Math.abs(n.x) > Math.abs(n.y) ? o.x = Math.sign(n.x) * Math.abs(n.y) : o.y = Math.sign(n.y) * Math.abs(n.x), this.resizeShape(e, o, {
      initialShape: r.initialShape,
      initialBounds: r.initialBounds,
      isAspectRatioLocked: r.isAspectRatioLocked
    }), Math.sign(n.x) * Math.sign(n.y) < 0) {
      let { rotation: m } = we.Decompose(r.initialPageTransform);
      m -= 2 * m, this.updateShapes([{ id: e, type: s, rotation: m }]);
    }
    const i = we.applyToPoint(
      r.initialPageTransform,
      r.initialBounds.center
    ), a = this._scalePagePoint(
      i,
      r.scaleOrigin,
      n,
      r.scaleAxisRotation
    ), c = this.getShapePageBounds(e), l = this.getShapePageTransform(e), d = c.center, u = l.point();
    if (!d || !u) return this;
    const f = I.Sub(a, d), p = I.Add(u, f), { x: g, y } = this.getPointInParentSpace(e, p);
    return this.updateShapes([{ id: e, type: s, x: g, y }]), this;
  }
  /**
   * Get the initial meta value for a shape.
   *
   * @example
   * ```ts
   * editor.getInitialMetaForShape = (shape) => {
   *   if (shape.type === 'note') {
   *     return { createdBy: myCurrentUser.id }
   *   }
   * }
   * ```
   *
   * @param shape - The shape to get the initial meta for.
   *
   * @public
   */
  getInitialMetaForShape(e) {
    return {};
  }
  /**
   * Get whether the provided shape can be created.
   *
   * @param shape - The shape or shape IDs to check.
   *
   * @public
   */
  canCreateShape(e) {
    return this.canCreateShapes([e]);
  }
  /**
   * Get whether the provided shapes can be created.
   *
   * @param shapes - The shapes or shape IDs to create.
   *
   * @public
   */
  canCreateShapes(e) {
    return e.length + this.getCurrentPageShapeIds().size <= this.options.maxShapesPerPage;
  }
  /**
   * Create a single shape.
   *
   * @example
   * ```ts
   * editor.createShape(myShape)
   * editor.createShape({ id: 'box1', type: 'text', props: { richText: toRichText("ok") } })
   * ```
   *
   * @param shape - The shape (or shape partial) to create.
   *
   * @public
   */
  createShape(e) {
    return this.createShapes([e]), this;
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * editor.createShapes([myShape])
   * editor.createShapes([{ id: 'box1', type: 'text', props: { richText: toRichText("ok") } }])
   * ```
   *
   * @param shapes - The shapes (or shape partials) to create.
   *
   * @public
   */
  createShapes(e) {
    if (!Array.isArray(e))
      throw Error("Editor.createShapes: must provide an array of shapes or shape partials");
    if (this.getIsReadonly()) return this;
    if (e.length <= 0) return this;
    const n = this.getCurrentPageShapeIds();
    if (e.length + n.size > this.options.maxShapesPerPage)
      return D1(this), this;
    const s = this.getFocusedGroupId();
    return this.run(() => {
      var d, u;
      const o = this.getCurrentPageShapesSorted(), i = e.map((f) => {
        if (f.id || (f = { id: $n(), ...f }), !f.parentId || !(this.store.has(f.parentId) || e.some((p) => p.id === f.parentId))) {
          let p = this.getFocusedGroupId();
          for (let y = o.length - 1; y >= 0; y--) {
            const m = o[y];
            if (this.getShapeUtil(m).canReceiveNewChildrenOfType(m, f.type) && !this.isShapeHidden(m) && this.isPointInShape(
              m,
              // If no parent is provided, then we can treat the
              // shape's provided x/y as being in the page's space.
              { x: f.x ?? 0, y: f.y ?? 0 },
              {
                margin: 0,
                hitInside: !0
              }
            )) {
              p = m.id;
              break;
            }
          }
          const g = f.parentId;
          if (p === f.id && (p = s), p !== g && (f = { ...f }, f.parentId = p, ei(p))) {
            const y = this.getPointInShapeSpace(this.getShape(p), {
              x: f.x ?? 0,
              y: f.y ?? 0
            });
            f.x = y.x, f.y = y.y, f.rotation = -this.getShapePageTransform(p).rotation() + (f.rotation ?? 0);
          }
        }
        return f;
      }), a = /* @__PURE__ */ new Map(), c = [], { opacityForNextShape: l } = this.getInstanceState();
      for (const f of i) {
        const p = this.getShapeUtil(f);
        let g = f.index;
        if (!g) {
          const b = f.parentId ?? s;
          a.has(b) || a.set(b, this.getHighestIndexForParent(b)), g = a.get(b), a.set(b, Bc(g));
        }
        const y = p.getDefaultProps();
        for (const [b, x] of this.styleProps[f.type])
          y[x] = this.getStyleForNextShape(b);
        let m = this.store.schema.types.shape.create({
          ...f,
          index: g,
          opacity: f.opacity ?? l,
          parentId: f.parentId ?? s,
          props: "props" in f ? { ...y, ...f.props } : y
        });
        if (m.index === void 0)
          throw Error("no index!");
        const v = (u = (d = this.getShapeUtil(m)).onBeforeCreate) == null ? void 0 : u.call(d, m);
        v && (m = v), c.push(m);
      }
      c.forEach((f) => {
        f.meta = {
          ...this.getInitialMetaForShape(f),
          ...f.meta
        };
      }), this.emit("created-shapes", c), this.emit("edit"), this.store.put(c);
    }), this;
  }
  /**
   * Animate a shape.
   *
   * @example
   * ```ts
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 })
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 }, { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partial - The shape partial to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShape(e, n = { animation: eO }) {
    return this.animateShapes([e], n);
  }
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }], { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partials - The shape partials to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShapes(e, n = { animation: eO }) {
    if (!n.animation) return this;
    const { duration: r = 500, easing: s = Mo.linear } = n.animation, o = bn();
    let i = r, a;
    const c = [];
    let l, d;
    for (let f = 0, p = e.length; f < p; f++) {
      if (l = e[f], !l) continue;
      const g = this.getShape(l.id);
      g && (d = {
        start: mr(g),
        end: vl(mr(g), l)
      }, c.push(d), this.animatingShapes.set(g.id, o));
    }
    const u = (f) => {
      var m, v;
      if (i -= f, i < 0) {
        const { animatingShapes: b } = this, x = e.filter(
          (w) => w && b.get(w.id) === o
        );
        x.length && this.updateShapes(x), this.off("tick", u);
        return;
      }
      a = s(1 - i / r);
      const { animatingShapes: p } = this, g = [];
      let y;
      for (let b = 0, x = c.length; b < x; b++) {
        const { start: w, end: S } = c[b];
        y = p.get(w.id), y === o && g.push({
          ...S,
          x: w.x + (S.x - w.x) * a,
          y: w.y + (S.y - w.y) * a,
          opacity: w.opacity + (S.opacity - w.opacity) * a,
          rotation: w.rotation + (S.rotation - w.rotation) * a,
          props: ((v = (m = this.getShapeUtil(S)).getInterpolatedProps) == null ? void 0 : v.call(m, w, S, a)) ?? S.props
        });
      }
      this._updateShapes(g);
    };
    return this.on("tick", u), this;
  }
  groupShapes(e, n = {}) {
    var g;
    const { groupId: r = $n(), select: s = !0 } = n;
    if (!Array.isArray(e))
      throw Error("Editor.groupShapes: must provide an array of shapes or shape ids");
    if (this.getIsReadonly()) return this;
    const o = typeof e[0] == "string" ? e : e.map((y) => y.id);
    if (o.length <= 1) return this;
    const i = mt(
      (this._shouldIgnoreShapeLock ? o : this._getUnlockedShapeIds(o)).map(
        (y) => this.getShape(y)
      )
    ), a = i.sort(Js).map((y) => y.id), c = _e.Common(mt(i.map((y) => this.getShapePageBounds(y)))), { x: l, y: d } = c.point, u = this.findCommonAncestor(i) ?? this.getCurrentPageId();
    if (this.getCurrentToolId() !== "select") return this;
    this.isIn("select.idle") || this.cancel();
    const f = i.filter((y) => y.parentId === u).sort(Js), p = (g = f[f.length - 1]) == null ? void 0 : g.index;
    return this.run(() => {
      this.createShapes([
        {
          id: r,
          type: "group",
          parentId: u,
          index: p,
          x: l,
          y: d,
          opacity: 1,
          props: {}
        }
      ]), this.reparentShapes(a, r), s && this.select(r);
    }), this;
  }
  ungroupShapes(e, n = {}) {
    if (this.getIsReadonly()) return this;
    const { select: r = !0 } = n, s = typeof e[0] == "string" ? e : e.map((c) => c.id), o = mt(
      (this._shouldIgnoreShapeLock ? s : this._getUnlockedShapeIds(s)).map(
        (c) => this.getShape(c)
      )
    );
    if (o.length === 0) return this;
    if (this.getCurrentToolId() !== "select") return this;
    this.isIn("select.idle") || this.cancel();
    const i = /* @__PURE__ */ new Set(), a = [];
    return o.forEach((c) => {
      this.isShapeOfType(c, "group") ? a.push(c) : i.add(c.id);
    }), a.length === 0 ? this : (this.run(() => {
      let c;
      for (let l = 0, d = a.length; l < d; l++) {
        c = a[l];
        const u = this.getSortedChildIdsForParent(c.id);
        for (let f = 0, p = u.length; f < p; f++)
          i.add(u[f]);
        this.reparentShapes(u, c.parentId, c.index);
      }
      this.deleteShapes(a.map((l) => l.id)), r && this.select(...i);
    }), this);
  }
  /**
   * Update a shape using a partial of the shape.
   *
   * @example
   * ```ts
   * editor.updateShape({ id: 'box1', type: 'geo', props: { w: 100, h: 100 } })
   * ```
   *
   * @param partial - The shape partial to update.
   *
   * @public
   */
  updateShape(e) {
    return this.updateShapes([e]), this;
  }
  /**
   * Update shapes using partials of each shape.
   *
   * @example
   * ```ts
   * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])
   * ```
   *
   * @param partials - The shape partials to update.
   *
   * @public
   */
  updateShapes(e) {
    const n = Array(e.length);
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      if (!o) continue;
      const i = this.getShape(o.id);
      if (i) {
        if (!this._shouldIgnoreShapeLock) {
          if (i.isLocked) {
            if (!(Object.hasOwn(o, "isLocked") && !o.isLocked))
              continue;
          } else if (this.isShapeOrAncestorLocked(i))
            continue;
        }
        this.animatingShapes.delete(o.id), n.push(o);
      }
    }
    return this._updateShapes(n), this;
  }
  /** @internal */
  _updateShapes(e) {
    this.getIsReadonly() || this.run(() => {
      var o, i;
      const n = [];
      let r, s;
      for (let a = 0, c = e.length; a < c; a++) {
        const l = e[a];
        l && (r = this.getShape(l.id), r && (s = vl(r, l), s !== r && (s = ((i = (o = this.getShapeUtil(r)).onBeforeUpdate) == null ? void 0 : i.call(o, r, s)) ?? s, n.push(s))));
      }
      this.emit("edited-shapes", n), this.emit("edit"), this.store.put(n);
    });
  }
  /** @internal */
  _getUnlockedShapeIds(e) {
    return e.filter((n) => {
      var r;
      return !((r = this.getShape(n)) != null && r.isLocked);
    });
  }
  deleteShapes(e) {
    if (this.getIsReadonly()) return this;
    if (!Array.isArray(e))
      throw Error("Editor.deleteShapes: must provide an array of shapes or shapeIds");
    const n = typeof e[0] == "string" ? e : e.map((o) => o.id), r = this._shouldIgnoreShapeLock ? n : this._getUnlockedShapeIds(n);
    if (r.length === 0) return this;
    const s = new Set(r);
    for (const o of r)
      this.visitDescendants(o, (i) => {
        s.add(i);
      });
    return this.emit("deleted-shapes", [...s]), this.emit("edit"), this.run(() => this.store.remove([...s]));
  }
  deleteShape(e) {
    return this.deleteShapes([typeof e == "string" ? e : e.id]), this;
  }
  /* --------------------- Styles --------------------- */
  /**
   * Get all the current styles among the users selected shapes
   *
   * @internal
   */
  _extractSharedStyles(e, n) {
    if (this.isShapeOfType(e, "group")) {
      const r = this._parentIdsToChildIds.get()[e.id];
      if (!r) return;
      for (let s = 0, o = r.length; s < o; s++)
        this._extractSharedStyles(this.getShape(r[s]), n);
    } else
      for (const [r, s] of this.styleProps[e.type])
        n.applyValue(r, Fr(e.props, s));
  }
  _getSelectionSharedStyles() {
    const e = this.getSelectedShapes(), n = new hj();
    for (const r of e)
      this._extractSharedStyles(r, n);
    return n;
  }
  /**
   * Get the style for the next shape.
   *
   * @example
   * ```ts
   * const color = editor.getStyleForNextShape(DefaultColorStyle)
   * ```
   *
   * @param style - The style to get.
   *
   * @public */
  getStyleForNextShape(e) {
    const n = this.getInstanceState().stylesForNextShape[e.id];
    return n === void 0 ? e.defaultValue : n;
  }
  getShapeStyleIfExists(e, n) {
    const r = this.styleProps[e.type].get(n);
    if (r !== void 0)
      return Fr(e.props, r);
  }
  getSharedStyles() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0)
      return this._getSelectionSharedStyles();
    const e = this.root.getCurrent(), n = new hj();
    if (!e) return n;
    if (e.shapeType)
      if (e.shapeType === "frame" && !this.getShapeUtil("frame").options.showColors)
        for (const r of this.styleProps[e.shapeType].keys())
          r.id !== "tldraw:color" && n.applyValue(r, this.getStyleForNextShape(r));
      else
        for (const r of this.styleProps[e.shapeType].keys())
          n.applyValue(r, this.getStyleForNextShape(r));
    return n;
  }
  getSharedOpacity() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      const e = [], n = (s) => {
        const o = this.getShape(s);
        if (o)
          if (this.isShapeOfType(o, "group"))
            for (const i of this.getSortedChildIdsForParent(o.id))
              n(i);
          else
            e.push(o);
      };
      for (const s of this.getSelectedShapeIds())
        n(s);
      let r = null;
      for (const s of e)
        if (r === null)
          r = s.opacity;
        else if (r !== s.opacity)
          return { type: "mixed" };
      if (r !== null) return { type: "shared", value: r };
    }
    return { type: "shared", value: this.getInstanceState().opacityForNextShape };
  }
  /**
   * Set the opacity for the next shapes. This will effect subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForNextShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   * @param historyOptions - The history options for the change.
   */
  setOpacityForNextShapes(e, n) {
    return this.updateInstanceState({ opacityForNextShape: e }, n), this;
  }
  /**
   * Set the current opacity. This will effect any selected shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForSelectedShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   */
  setOpacityForSelectedShapes(e) {
    const n = this.getSelectedShapes();
    if (n.length > 0) {
      const r = [], s = (o) => {
        if (this.isShapeOfType(o, "group")) {
          const i = this.getSortedChildIdsForParent(o);
          for (const a of i)
            s(this.getShape(a));
        } else
          r.push(o);
      };
      for (const o of n)
        s(o);
      this.updateShapes(
        r.map((o) => ({
          id: o.id,
          type: o.type,
          opacity: e
        }))
      );
    }
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp} for the next shapes. This change will be applied to subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red')
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red', { ephemeral: true })
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   * @param historyOptions - The history options for the change.
   *
   * @public
   */
  setStyleForNextShapes(e, n, r) {
    const s = this.getInstanceState().stylesForNextShape;
    return this.updateInstanceState(
      { stylesForNextShape: { ...s, [e.id]: n } },
      r
    ), this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp}. This change will be applied to the currently selected shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   *
   * @public
   */
  setStyleForSelectedShapes(e, n) {
    const r = this.getSelectedShapes();
    if (r.length > 0) {
      const s = [], o = (i) => {
        if (this.isShapeOfType(i, "group")) {
          const a = this.getSortedChildIdsForParent(i.id);
          for (const c of a)
            o(this.getShape(c));
        } else {
          const a = this.getShapeUtil(i), c = this.styleProps[i.type].get(e);
          if (c) {
            const l = {
              id: i.id,
              type: i.type,
              props: { [c]: n }
            };
            s.push({
              util: a,
              originalShape: i,
              updatePartial: l
            });
          }
        }
      };
      for (const i of r)
        o(i);
      this.updateShapes(s.map(({ updatePartial: i }) => i));
    }
    return this;
  }
  /**
   * Register an external asset handler. This handler will be called when the editor needs to
   * create an asset for some external content, like an image/video file or a bookmark URL. For
   * example, the 'file' type handler will be called when a user drops an image onto the canvas.
   *
   * The handler should extract any relevant metadata for the asset, upload it to blob storage
   * using {@link Editor.uploadAsset} if needed, and return the asset with the metadata & uploaded
   * URL.
   *
   * @example
   * ```ts
   * editor.registerExternalAssetHandler('file', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalAssetHandler(e, n) {
    return this.externalAssetContentHandlers[e] = n, this;
  }
  /**
   * Register a temporary preview of an asset. This is useful for showing a ghost image of
   * something that is being uploaded. Retrieve the placeholder with
   * {@link Editor.getTemporaryAssetPreview}. Placeholders last for 3 minutes by default, but this
   * can be configured using
   *
   * @example
   * ```ts
   * editor.createTemporaryAssetPreview(assetId, file)
   * ```
   *
   * @param assetId - The asset's id.
   * @param file - The raw file.
   *
   * @public
   */
  createTemporaryAssetPreview(e, n) {
    if (this.temporaryAssetPreview.has(e))
      return this.temporaryAssetPreview.get(e);
    const r = URL.createObjectURL(n);
    return this.temporaryAssetPreview.set(e, r), setTimeout(() => {
      this.temporaryAssetPreview.delete(e), URL.revokeObjectURL(r);
    }, this.options.temporaryAssetPreviewLifetimeMs), r;
  }
  /**
   * Get temporary preview of an asset. This is useful for showing a ghost
   * image of something that is being uploaded.
   *
   * @example
   * ```ts
   * editor.getTemporaryAssetPreview('someId')
   * ```
   *
   * @param assetId - The asset's id.
   *
   * @public
   */
  getTemporaryAssetPreview(e) {
    return this.temporaryAssetPreview.get(e);
  }
  /**
   * Get an asset for an external asset content type.
   *
   * @example
   * ```ts
   * const asset = await editor.getAssetForExternalContent({ type: 'file', file: myFile })
   * const asset = await editor.getAssetForExternalContent({ type: 'url', url: myUrl })
   * ```
   *
   * @param info - Info about the external content.
   * @returns The asset.
   */
  async getAssetForExternalContent(e) {
    var n, r;
    return await ((r = (n = this.externalAssetContentHandlers)[e.type]) == null ? void 0 : r.call(n, e));
  }
  hasExternalAssetHandler(e) {
    return !!this.externalAssetContentHandlers[e];
  }
  /**
   * Register an external content handler. This handler will be called when the editor receives
   * external content of the provided type. For example, the 'image' type handler will be called
   * when a user drops an image onto the canvas.
   *
   * @example
   * ```ts
   * editor.registerExternalContentHandler('text', myHandler)
   * ```
   * @example
   * ```ts
   * editor.registerExternalContentHandler<'embed', MyEmbedType>('embed', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalContentHandler(e, n) {
    return this.externalContentHandlers[e] = n, this;
  }
  /**
   * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.
   *
   * @param info - Info about the external content.
   */
  async putExternalContent(e) {
    var n, r;
    return (r = (n = this.externalContentHandlers)[e.type]) == null ? void 0 : r.call(n, e);
  }
  /**
   * Handle replacing external content.
   *
   * @param info - Info about the external content.
   */
  async replaceExternalContent(e) {
    var n, r;
    return (r = (n = this.externalContentHandlers)[e.type]) == null ? void 0 : r.call(n, e);
  }
  /**
   * Get content that can be exported for the given shape ids.
   *
   * @param shapes - The shapes (or shape ids) to get content for.
   *
   * @returns The exported content.
   *
   * @public
   */
  getContentFromCurrentPage(e) {
    const n = typeof e[0] == "string" ? e : e.map((s) => s.id);
    if (!n || n.length === 0) return;
    const r = this.getShapeAndDescendantIds(n);
    return SH(this, r, (s) => {
      const o = [];
      for (const d of s) {
        const u = this.getBinding(d);
        u && o.push(u);
      }
      const i = [], a = [];
      for (const d of r) {
        const u = this.getShape(d);
        if (!u) continue;
        if (!r.has(u.parentId)) {
          const p = this.getShapePageTransform(u.id), g = p.point();
          a.push({
            ...u,
            x: g.x,
            y: g.y,
            rotation: p.rotation(),
            parentId: this.getCurrentPageId()
          }), i.push(u.id);
        } else
          a.push(u);
      }
      const c = [], l = /* @__PURE__ */ new Set();
      for (const d of a) {
        if (!("assetId" in d.props)) continue;
        const u = d.props.assetId;
        if (!u || l.has(u)) continue;
        l.add(u);
        const f = this.getAsset(u);
        f && c.push(f);
      }
      return {
        schema: this.store.schema.serialize(),
        shapes: a,
        rootShapeIds: i,
        bindings: o,
        assets: c
      };
    });
  }
  async resolveAssetsInContent(e) {
    if (!e) return;
    const n = [];
    return await Promise.allSettled(
      e.assets.map(async (r) => {
        var s, o, i;
        if ((r.type === "image" || r.type === "video") && !((s = r.props.src) != null && s.startsWith("data:image")) && !((o = r.props.src) != null && o.startsWith("data:video")) && !((i = r.props.src) != null && i.startsWith("http"))) {
          const a = mr(r), c = await this.store.props.assets.resolve(r, {
            screenScale: 1,
            steppedScreenScale: 1,
            dpr: 1,
            networkEffectiveType: null,
            shouldResolveToOriginal: !0
          });
          a.props.src = await oi.blobToDataUrl(
            await qc(c).then((l) => l.blob())
          ), n.push(a);
        } else
          n.push(r);
      })
    ), e.assets = n, e;
  }
  /**
   * Place content into the editor.
   *
   * @param content - The content.
   * @param opts - Options for placing the content.
   *
   * @public
   */
  putContentOntoCurrentPage(e, n = {}) {
    var N, O, D;
    if (this.getIsReadonly()) return this;
    if (!e.schema)
      throw Error(`Could not put content:
content is missing a schema.`);
    const { select: r = !1, preserveIds: s = !1, preservePosition: o = !1 } = n;
    let { point: i = void 0 } = n;
    const a = this.getCurrentPageId(), { rootShapeIds: c } = e, l = [], d = [], u = [], f = {
      store: {
        ...Object.fromEntries(e.assets.map((k) => [k.id, k])),
        ...Object.fromEntries(e.shapes.map((k) => [k.id, k])),
        ...Object.fromEntries(
          ((N = e.bindings) == null ? void 0 : N.map((k) => [k.id, k])) ?? []
        )
      },
      schema: e.schema
    }, p = this.store.schema.migrateStoreSnapshot(f);
    if (p.type === "error")
      throw Error("Could not put content: could not migrate content");
    for (const k of Object.values(p.value))
      switch (k.typeName) {
        case "asset": {
          l.push(k);
          break;
        }
        case "shape": {
          d.push(k);
          break;
        }
        case "binding": {
          u.push(k);
          break;
        }
      }
    const g = new Map(
      s ? d.map((k) => [k.id, k.id]) : d.map((k) => [k.id, $n()])
    ), y = new Map(
      s ? u.map((k) => [k.id, k.id]) : u.map((k) => [k.id, ip()])
    );
    let m = this.getCurrentPageId(), v = 1 / 0, b = [];
    for (const k of this.getSelectedShapes()) {
      if (v === 0) break;
      const A = this.isShapeOfType(k, "frame"), R = this.getShapeAncestors(k);
      A && R.push(k);
      const j = A ? R.length + 1 : R.length;
      if (j < v)
        v = j, b = R, m = A ? k.id : k.parentId;
      else if (j === v) {
        if (b.length !== R.length)
          throw Error(`Ancestors: ${b.length} !== ${R.length}`);
        if (b.length === 0) {
          m = a;
          break;
        } else {
          m = a;
          for (let $ = 0; $ < b.length && R[$] === b[$]; $++)
            m = R[$].id;
        }
      }
    }
    let x = !1;
    if (!Ys(m)) {
      const k = this.getShape(m);
      if (k) {
        if (!this.getViewportPageBounds().includes(this.getShapePageBounds(k)))
          m = a;
        else if (c.length === 1) {
          const A = d.find((R) => R.id === c[0]);
          this.isShapeOfType(k, "frame") && this.isShapeOfType(A, "frame") && A.props.w === (k == null ? void 0 : k.props.w) && A.props.h === (k == null ? void 0 : k.props.h) && (x = !0);
        }
      } else
        m = a;
    }
    x || (x = g.has(m)), x && (m = this.getShape(m).parentId);
    let w = this.getHighestIndexForParent(m);
    const S = [], C = d.map((k) => {
      const A = g.get(k.id), R = { ...k, id: A };
      return c.includes(k.id) && (R.parentId = a, S.push(R)), g.has(R.parentId) ? R.parentId = g.get(k.parentId) : (c.push(R.id), R.index = w, w = Bc(w)), R;
    });
    if (C.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage)
      return D1(this), this;
    const _ = u.map(
      (k) => ({
        ...k,
        id: Io(y.get(k.id)),
        fromId: Io(g.get(k.fromId)),
        toId: Io(g.get(k.toId))
      })
    ), E = [], M = [];
    for (const k of l)
      this.store.has(k.id) || ((k.type === "image" && ((O = k.props.src) != null && O.startsWith("data:image")) || k.type === "video" && ((D = k.props.src) != null && D.startsWith("data:video"))) && (M.push(mr(k)), k.props.src = null), E.push(k));
    return Promise.allSettled(
      M.map(async (k) => {
        const A = await Cze(
          k.props.src,
          k.props.name,
          k.props.mimeType ?? "image/png"
        ), R = await this.getAssetForExternalContent({
          type: "file",
          file: A,
          assetId: k.id
        });
        if (!R) {
          this.deleteAssets([k.id]);
          return;
        }
        this.updateAssets([{ ...R, id: k.id }]);
      })
    ), this.run(() => {
      E.length > 0 && this.createAssets(E), this.createShapes(C), this.createBindings(_), r && this.select(...S.map(($) => $.id)), m !== a && this.reparentShapes(
        S.map(($) => $.id),
        m
      );
      const k = C.map(($) => this.getShape($.id)), A = _e.Common(k.map(($) => this.getShapePageBounds($)));
      if (i === void 0)
        if (Ys(m)) {
          const $ = this.getViewportPageBounds();
          o || $.includes(_e.From(A)) ? i = A.center : i = $.center;
        } else {
          const $ = this.getShape(m);
          i = we.applyToPoint(
            this.getShapePageTransform($),
            this.getShapeGeometry($).bounds.center
          );
        }
      if (S.length === 1) {
        const $ = S[0];
        if (this.isShapeOfType($, "frame"))
          for (; this.getShapesAtPoint(i).some(
            (F) => this.isShapeOfType(F, "frame") && F.props.w === $.props.w && F.props.h === $.props.h
          ); )
            i.x += A.w + 16;
      }
      const R = _e.Common(
        mt(S.map(({ id: $ }) => this.getShapePageBounds($)))
      ).center, j = I.Sub(i, R);
      this.updateShapes(
        S.map(({ id: $ }) => {
          const F = this.getShape($), L = this.getShapeParentTransform($).decompose().rotation, z = I.Rot(j, -L);
          return { id: F.id, type: F.type, x: F.x + z.x, y: F.y + z.y };
        })
      );
    }), this;
  }
  /**
   * Get an exported SVG element of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgElement(e, n = {}) {
    const r = e.length === 0 ? this.getCurrentPageShapeIdsSorted() : typeof e[0] == "string" ? e : e.map((s) => s.id);
    if (r.length !== 0)
      return pze(this, r, n);
  }
  /**
   * Get an exported SVG string of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgString(e, n = {}) {
    const r = await this.getSvgElement(e, n);
    return r ? {
      svg: new XMLSerializer().serializeToString(r.svg),
      width: r.width,
      height: r.height
    } : void 0;
  }
  /** @deprecated Use {@link Editor.getSvgString} or {@link Editor.getSvgElement} instead. */
  async getSvg(e, n = {}) {
    const r = await this.getSvgElement(e, n);
    if (r)
      return r.svg;
  }
  /**
   * Get an exported image of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns A blob of the image.
   * @public
   */
  async toImage(e, n = {}) {
    const r = {
      format: "png",
      scale: 1,
      pixelRatio: n.format === "svg" ? void 0 : 2,
      ...n
    }, s = await this.getSvgString(e, r);
    if (!s) throw new Error("Could not create SVG");
    switch (r.format) {
      case "svg":
        return {
          blob: new Blob([s.svg], { type: "image/svg+xml" }),
          width: s.width,
          height: s.height
        };
      case "jpeg":
      case "png":
      case "webp": {
        const o = await xze(s.svg, {
          type: r.format,
          quality: r.quality,
          pixelRatio: r.pixelRatio,
          width: s.width,
          height: s.height
        });
        if (!o)
          throw new Error("Could not construct image.");
        return {
          blob: o,
          width: s.width,
          height: s.height
        };
      }
      default:
        Jt(r.format);
    }
  }
  /**
   * Update the input points from a pointer, pinch, or wheel event.
   *
   * @param info - The event info.
   */
  _updateInputsFromEvent(e) {
    const {
      pointerVelocity: n,
      previousScreenPoint: r,
      previousPagePoint: s,
      currentScreenPoint: o,
      currentPagePoint: i,
      originScreenPoint: a,
      originPagePoint: c
    } = this.inputs, { screenBounds: l } = this.store.unsafeGetWithoutCapture(ti), { x: d, y: u, z: f } = Nb(() => this.getCamera()), p = e.point.x - l.x, g = e.point.y - l.y, y = e.point.z ?? 0.5;
    r.setTo(o), s.setTo(i), o.set(p, g);
    const m = p / f - d, v = g / f - u;
    isFinite(m) && isFinite(v) && i.set(m, v, y), this.inputs.isPen = e.type === "pointer" && e.isPen, (e.name === "pointer_down" || this.inputs.isPinching) && (n.set(0, 0), a.setTo(o), c.setTo(i)), this.run(
      () => {
        var b;
        this.store.put([
          {
            id: OE,
            typeName: "pointer",
            x: i.x,
            y: i.y,
            lastActivityTimestamp: (
              // If our pointer moved only because we're following some other user, then don't
              // update our last activity timestamp; otherwise, update it to the current timestamp.
              e.type === "pointer" && e.pointerId === Z8.CAMERA_MOVE ? ((b = this.store.unsafeGetWithoutCapture(OE)) == null ? void 0 : b.lastActivityTimestamp) ?? this._tickManager.now : this._tickManager.now
            ),
            meta: {}
          }
        ]);
      },
      { history: "ignore" }
    );
  }
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * editor.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    return this.dispatch({ type: "misc", name: "cancel" }), this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * editor.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    return this.dispatch({ type: "misc", name: "interrupt" }), this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * editor.complete()
   * ```
   *
   * @public
   */
  complete() {
    return this.dispatch({ type: "misc", name: "complete" }), this;
  }
  /**
   * Puts the editor into focused mode.
   *
   * This makes the editor eligible to receive keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.focus()
   * ```
   *
   * By default this also dispatches a 'focus' event to the container element. To prevent this, pass `focusContainer: false`.
   *
   * @example
   * ```ts
   * editor.focus({ focusContainer: false })
   * ```
   *
   * @public
   */
  focus({ focusContainer: e = !0 } = {}) {
    return this.getIsFocused() ? this : (e && this.focusManager.focus(), this.updateInstanceState({ isFocused: !0 }), this);
  }
  /**
   * Switches off the editor's focused mode.
   *
   * This makes the editor ignore keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.blur()
   * ```
   * By default this also dispatches a 'blur' event to the container element. To prevent this, pass `blurContainer: false`.
   *
   * @example
   * ```ts
   * editor.blur({ blurContainer: false })
   * ```
   *
   * @public
   */
  blur({ blurContainer: e = !0 } = {}) {
    return this.getIsFocused() ? (e ? this.focusManager.blur() : this.complete(), this.updateInstanceState({ isFocused: !1 }), this) : this;
  }
  getIsFocused() {
    return this.getInstanceState().isFocused;
  }
  getIsReadonly() {
    return this.getInstanceState().isReadonly;
  }
  /**
   * @public
   * @returns a snapshot of the store's UI and document state
   */
  getSnapshot() {
    return gBe(this.store);
  }
  /**
   * Loads a snapshot into the editor.
   * @param snapshot - The snapshot to load.
   * @param opts - The options for loading the snapshot.
   * @returns
   */
  loadSnapshot(e, n) {
    return Ene(this.store, e, n), this;
  }
  _zoomToFitPageContentAt100Percent() {
    const e = this.getCurrentPageBounds();
    e && this.zoomToBounds(e, { immediate: !0, targetZoom: this.getBaseZoom() });
  }
  _navigateToDeepLink(e) {
    this.run(() => {
      switch (e.type) {
        case "page": {
          const n = this.getPage(e.pageId);
          n && this.setCurrentPage(n), this._zoomToFitPageContentAt100Percent();
          return;
        }
        case "shapes": {
          const n = mt(e.shapeIds.map((i) => this.getShape(i))), r = {};
          for (const i of n) {
            const a = this.getAncestorPageId(i);
            a && (r[a] ?? (r[a] = []), r[a].push(i));
          }
          const [s, o] = Object.entries(r).sort(
            ([i, a], [c, l]) => l.length - a.length
          )[0] ?? ["", []];
          if (!s || !o.length)
            this._zoomToFitPageContentAt100Percent();
          else {
            this.setCurrentPage(s);
            const i = _e.Common(o.map((a) => this.getShapePageBounds(a)));
            this.zoomToBounds(i, { immediate: !0, targetZoom: this.getBaseZoom() });
          }
          return;
        }
        case "viewport": {
          if (e.pageId) {
            if (!this.getPage(e.pageId)) {
              this._zoomToFitPageContentAt100Percent();
              return;
            }
            this.setCurrentPage(e.pageId);
          }
          this.zoomToBounds(e.bounds, { immediate: !0, inset: 0 });
          return;
        }
        default:
          Jt(e);
      }
    });
  }
  /**
   * Handles navigating to the content specified by the query param in the given URL.
   *
   * Use {@link Editor#createDeepLink} to create a URL with a deep link query param.
   *
   * If no URL is provided, it will look for the param in the current `window.location.href`.
   *
   * @example
   * ```ts
   * editor.navigateToDeepLink()
   * ```
   *
   * The default parameter name is 'd'. You can override this by providing the `param` option.
   *
   * @example
   * ```ts
   * // disable page parameter and change viewport parameter to 'c'
   * editor.navigateToDeepLink({
   *   param: 'x',
   *   url: 'https://my-app.com/my-document?x=200.12.454.23.xyz123',
   * })
   * ```
   *
   * @param opts - Options for loading the state from the URL.
   */
  navigateToDeepLink(e) {
    if (e && "type" in e)
      return this._navigateToDeepLink(e), this;
    const r = new URL((e == null ? void 0 : e.url) ?? window.location.href).searchParams.get((e == null ? void 0 : e.param) ?? "d");
    if (!r)
      return this._zoomToFitPageContentAt100Percent(), this;
    try {
      this._navigateToDeepLink(Tze(r));
    } catch (s) {
      console.warn(s), this._zoomToFitPageContentAt100Percent();
    }
    return this;
  }
  /**
   * Turns the given URL into a deep link by adding a query parameter.
   *
   * e.g. `https://my-app.com/my-document?d=100.100.200.200.xyz123`
   *
   * If no URL is provided, it will use the current `window.location.href`.
   *
   * @example
   * ```ts
   * // create a deep link to the current page + viewport
   * navigator.clipboard.writeText(editor.createDeepLink())
   * ```
   *
   * You can link to a particular set of shapes by providing a `to` parameter.
   *
   * @example
   * ```ts
   * // create a deep link to the set of currently selected shapes
   * navigator.clipboard.writeText(editor.createDeepLink({
   *   to: { type: 'selection', shapeIds: editor.getSelectedShapeIds() }
   * }))
   * ```
   *
   * The default query param is 'd'. You can override this by providing a `param` parameter.
   *
   * @example
   * ```ts
   * // Use `x` as the param name instead
   * editor.createDeepLink({ param: 'x' })
   * ```
   *
   * @param opts - Options for adding the state to the URL.
   * @returns the updated URL
   */
  createDeepLink(e) {
    const n = new URL((e == null ? void 0 : e.url) ?? window.location.href);
    return n.searchParams.set(
      (e == null ? void 0 : e.param) ?? "d",
      Eze(
        (e == null ? void 0 : e.to) ?? {
          type: "viewport",
          pageId: this.options.maxPages === 1 ? void 0 : this.getCurrentPageId(),
          bounds: this.getViewportPageBounds()
        }
      )
    ), n;
  }
  /**
   * Register a listener for changes to a deep link for the current document.
   *
   * You'll typically want to use this indirectly via the {@link TldrawEditorBaseProps.deepLinks} prop on the `<Tldraw />` component.
   *
   * By default this will update `window.location` in place, but you can provide a custom callback
   * to handle state changes on your own.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   onChange(url) {
   *     window.history.replaceState({}, document.title, url.toString())
   *   }
   * })
   * ```
   *
   * You can also provide a custom URL to update, in which case you must also provide `onChange`.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   getUrl: () => `https://my-app.com/my-document`,
   *   onChange(url) {
   *     setShareUrl(url.toString())
   *   }
   * })
   * ```
   *
   * By default this will update with a debounce interval of 500ms, but you can provide a custom interval.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ debounceMs: 1000 })
   * ```
   * The default parameter name is `d`. You can override this by providing a `param` option.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ param: 'x' })
   * ```
   * @param opts - Options for setting up the listener.
   * @returns a function that will stop the listener.
   */
  registerDeepLinkListener(e) {
    if (e != null && e.getUrl && !(e != null && e.onChange))
      throw Error(
        "[tldraw:urlStateSync] If you specify getUrl, you must also specify the onChange callback."
      );
    const n = ve("url with state", () => {
      var c, l;
      const i = ((c = e == null ? void 0 : e.getUrl) == null ? void 0 : c.call(e, this)) ?? window.location.href;
      return this.createDeepLink({
        param: e == null ? void 0 : e.param,
        url: i,
        to: (l = e == null ? void 0 : e.getTarget) == null ? void 0 : l.call(e, this)
      }).toString();
    }), r = (e == null ? void 0 : e.onChange) ?? (() => {
      var a;
      const i = this.createDeepLink({
        param: e == null ? void 0 : e.param,
        to: (a = e == null ? void 0 : e.getTarget) == null ? void 0 : a.call(e, this)
      });
      window.history.replaceState({}, document.title, i.toString());
    }), s = vI((i) => i(), (e == null ? void 0 : e.debounceMs) ?? 500), o = ya(
      "update url on state change",
      () => r(new URL(n.get()), this),
      { scheduleEffect: s }
    );
    return () => {
      o(), s.cancel();
    };
  }
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  _setShiftKeyTimeout() {
    this.inputs.shiftKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Shift",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: ms(this.inputs),
      code: "ShiftLeft"
    });
  }
  _setAltKeyTimeout() {
    this.inputs.altKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Alt",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: ms(this.inputs),
      code: "AltLeft"
    });
  }
  _setCtrlKeyTimeout() {
    this.inputs.ctrlKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Ctrl",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: ms(this.inputs),
      code: "ControlLeft"
    });
  }
  _setMetaKeyTimeout() {
    this.inputs.metaKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Meta",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: ms(this.inputs),
      code: "MetaLeft"
    });
  }
  /**
   * Dispatch an event to the editor.
   *
   * @example
   * ```ts
   * editor.dispatch(myPointerEvent)
   * ```
   *
   * @param info - The event info.
   *
   * @public
   */
  dispatch(e) {
    return this._pendingEventsForNextTick.push(e), e.type === "pointer" && e.name === "pointer_move" || e.type === "wheel" || e.type === "pinch" || this._flushEventsForTick(0), this;
  }
  _flushEventsForTick(e) {
    this.run(() => {
      if (this._pendingEventsForNextTick.length > 0) {
        const n = [...this._pendingEventsForNextTick];
        this._pendingEventsForNextTick.length = 0;
        for (const r of n)
          this._flushEventForTick(r);
      }
      e > 0 && this.root.handleEvent({ type: "misc", name: "tick", elapsed: e }), this.scribbles.tick(e);
    });
  }
  _flushEventForTick(e) {
    if (this.getCrashingError()) return this;
    this.emit("before-event", e);
    const { inputs: n } = this, { type: r } = e;
    if (e.type === "misc") {
      (e.name === "cancel" || e.name === "complete") && (this.inputs.isDragging = !1, this.inputs.isPanning && (this.inputs.isPanning = !1, this.inputs.isSpacebarPanning = !1, this.setCursor({ type: this._prevCursor, rotation: 0 }))), this.root.handleEvent(e);
      return;
    }
    e.shiftKey ? (clearTimeout(this._shiftKeyTimeout), this._shiftKeyTimeout = -1, n.shiftKey = !0) : !e.shiftKey && n.shiftKey && this._shiftKeyTimeout === -1 && (this._shiftKeyTimeout = this.timers.setTimeout(this._setShiftKeyTimeout, 150)), e.altKey ? (clearTimeout(this._altKeyTimeout), this._altKeyTimeout = -1, n.altKey = !0) : !e.altKey && n.altKey && this._altKeyTimeout === -1 && (this._altKeyTimeout = this.timers.setTimeout(this._setAltKeyTimeout, 150)), e.ctrlKey ? (clearTimeout(this._ctrlKeyTimeout), this._ctrlKeyTimeout = -1, n.ctrlKey = !0) : !e.ctrlKey && n.ctrlKey && this._ctrlKeyTimeout === -1 && (this._ctrlKeyTimeout = this.timers.setTimeout(this._setCtrlKeyTimeout, 150)), e.metaKey ? (clearTimeout(this._metaKeyTimeout), this._metaKeyTimeout = -1, n.metaKey = !0) : !e.metaKey && n.metaKey && this._metaKeyTimeout === -1 && (this._metaKeyTimeout = this.timers.setTimeout(this._setMetaKeyTimeout, 150));
    const { originPagePoint: s, currentPagePoint: o } = n;
    n.isPointing || (n.isDragging = !1);
    const i = this.store.unsafeGetWithoutCapture(ti), a = this.store.get(this._getCurrentPageStateId()), c = this._cameraOptions.__unsafe__getWithoutCapture();
    switch (r) {
      case "pinch": {
        if (c.isLocked) return;
        switch (clearTimeout(this._longPressTimeout), this._updateInputsFromEvent(e), e.name) {
          case "pinch_start": {
            if (n.isPinching) return;
            n.isEditing || (this._pinchStart = this.getCamera().z, this._selectedShapeIdsAtPointerDown.length || (this._selectedShapeIdsAtPointerDown = [...a.selectedShapeIds]), this._didPinch = !0, n.isPinching = !0, this.interrupt());
            return;
          }
          case "pinch": {
            if (!n.isPinching) return;
            const {
              point: { z: l = 1 },
              delta: { x: d, y: u }
            } = e, { x: f, y: p } = I.SubXY(
              e.point,
              i.screenBounds.x,
              i.screenBounds.y
            );
            this.stopCameraAnimation(), i.followingUserId && this.stopFollowingUser();
            const { x: g, y, z: m } = Nb(() => this.getCamera()), { panSpeed: v } = c;
            this._setCamera(
              new I(
                g + d * v / m - f / m + f / l,
                y + u * v / m - p / m + p / l,
                l
              ),
              { immediate: !0 }
            );
            return;
          }
          case "pinch_end": {
            if (!n.isPinching) return this;
            n.isPinching = !1;
            const { _selectedShapeIdsAtPointerDown: l } = this;
            this.setSelectedShapes(this._selectedShapeIdsAtPointerDown), this._selectedShapeIdsAtPointerDown = [], this._didPinch && (this._didPinch = !1, l.length > 0 && this.once("tick", () => {
              this._didPinch || this.setSelectedShapes(l);
            }));
            return;
          }
        }
      }
      case "wheel": {
        if (c.isLocked) return;
        this._updateInputsFromEvent(e);
        const { panSpeed: l, zoomSpeed: d, wheelBehavior: u } = c;
        if (u !== "none") {
          this.stopCameraAnimation(), i.followingUserId && this.stopFollowingUser();
          const { x: f, y: p, z: g } = Nb(() => this.getCamera()), { x: y, y: m, z: v = 0 } = e.delta;
          let b = u;
          switch (e.ctrlKey && (b = u === "pan" ? "zoom" : "pan"), b) {
            case "zoom": {
              const { x, y: w } = this.inputs.currentScreenPoint;
              let S = v;
              u === "zoom" && (Math.abs(m) > 10 ? S = 10 * Math.sign(m) / 100 : S = m / 100);
              const C = g + (S ?? 0) * d * g;
              this._setCamera(new I(f + x / C - x / g, p + w / C - w / g, C), {
                immediate: !0
              }), this.maybeTrackPerformance("Zooming");
              return;
            }
            case "pan": {
              this._setCamera(new I(f + y * l / g, p + m * l / g, g), {
                immediate: !0
              }), this.maybeTrackPerformance("Panning");
              return;
            }
          }
        }
        break;
      }
      case "pointer": {
        if (n.isPinching) return;
        this._updateInputsFromEvent(e);
        const { isPen: l } = e, { isPenMode: d } = i;
        switch (e.name) {
          case "pointer_down": {
            if (d && !l) return;
            if (this.inputs.isPanning || (this._longPressTimeout = this.timers.setTimeout(() => {
              const u = this.getViewportScreenBounds();
              this.dispatch({
                ...e,
                // important! non-obvious!! the screenpoint was adjusted using the
                // viewport bounds, and will be again when this event is handled...
                // so we need to counter-adjust from the stored value so that the
                // new value is set correctly.
                point: this.inputs.originScreenPoint.clone().addXY(u.x, u.y),
                name: "long_press"
              });
            }, this.options.longPressDurationMs)), this._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds(), e.button === Q8 && (this.capturedPointerId = e.pointerId), n.buttons.add(e.button), n.isPointing = !0, n.isDragging = !1, !d && l && this.updateInstanceState({ isPenMode: !0 }), e.button === J8 ? (this._restoreToolId = this.getCurrentToolId(), this.complete(), this.setCurrentTool("eraser")) : e.button === T1 && (this.inputs.isPanning || (this._prevCursor = this.getInstanceState().cursor.type), this.inputs.isPanning = !0, clearTimeout(this._longPressTimeout)), this.inputs.isPanning)
              return this.stopCameraAnimation(), this.setCursor({ type: "grabbing", rotation: 0 }), this;
            break;
          }
          case "pointer_move": {
            if (!l && d) return;
            const { x: u, y: f, z: p } = Nb(() => this.getCamera());
            if (this.inputs.isPanning && this.inputs.isPointing) {
              const { currentScreenPoint: g, previousScreenPoint: y } = this.inputs, m = I.Sub(g, y);
              this.setCamera(new I(u + m.x / p, f + m.y / p, p), {
                immediate: !0
              }), this.maybeTrackPerformance("Panning");
              return;
            }
            n.isPointing && !n.isDragging && I.Dist2(s, o) * this.getZoomLevel() > (i.isCoarsePointer ? this.options.coarseDragDistanceSquared : this.options.dragDistanceSquared) / p && (n.isDragging = !0, clearTimeout(this._longPressTimeout));
            break;
          }
          case "pointer_up": {
            if (n.isDragging = !1, n.isPointing = !1, clearTimeout(this._longPressTimeout), n.buttons.delete(e.button), i.isPenMode && !l) return;
            if (this.capturedPointerId === e.pointerId && (this.capturedPointerId = null, e.button = 0), n.isPanning) {
              n.keys.has("Space") || (n.isPanning = !1, n.isSpacebarPanning = !1);
              const u = this.inputs.pointerVelocity, f = Math.min(2, u.len());
              switch (e.button) {
                case Q8: {
                  this.setCursor({ type: "grab", rotation: 0 });
                  break;
                }
                case T1:
                  this.inputs.keys.has(" ") ? this.setCursor({ type: "grab", rotation: 0 }) : this.setCursor({ type: this._prevCursor, rotation: 0 });
              }
              f > 0 && this.slideCamera({ speed: f, direction: u });
            } else
              e.button === J8 && (this.complete(), this.setCurrentTool(this._restoreToolId));
            break;
          }
        }
        break;
      }
      case "keyboard": {
        switch (e.key === "ShiftRight" && (e.key = "ShiftLeft"), e.key === "AltRight" && (e.key = "AltLeft"), e.code === "ControlRight" && (e.code = "ControlLeft"), e.code === "MetaRight" && (e.code = "MetaLeft"), e.name) {
          case "key_down": {
            if (n.keys.add(e.code), e.code === "Space" && !e.ctrlKey && (this.inputs.isPanning || (this._prevCursor = i.cursor.type), this.inputs.isPanning = !0, this.inputs.isSpacebarPanning = !0, clearTimeout(this._longPressTimeout), this.setCursor({ type: this.inputs.isPointing ? "grabbing" : "grab", rotation: 0 })), this.inputs.isSpacebarPanning) {
              let l;
              switch (e.code) {
                case "ArrowUp": {
                  l = new I(0, -1);
                  break;
                }
                case "ArrowRight": {
                  l = new I(1, 0);
                  break;
                }
                case "ArrowDown": {
                  l = new I(0, 1);
                  break;
                }
                case "ArrowLeft": {
                  l = new I(-1, 0);
                  break;
                }
              }
              if (l) {
                const d = this.getViewportPageBounds(), u = d.clone().translate(l.mulV({ x: d.w, y: d.h }));
                this._animateToViewport(u, { animation: { duration: 320 } });
              }
            }
            break;
          }
          case "key_up": {
            n.keys.delete(e.code), e.code === "Space" && (this.inputs.buttons.has(T1) || (this.inputs.isPanning = !1, this.inputs.isSpacebarPanning = !1, this.setCursor({ type: this._prevCursor, rotation: 0 })));
            break;
          }
        }
        break;
      }
    }
    if (e.type === "pointer") {
      e.button === T1 ? e.name = "middle_click" : e.button === u3 && (e.name = "right_click");
      const { isPenMode: l } = this.store.unsafeGetWithoutCapture(ti);
      if (e.isPen === l) {
        const d = this._clickManager.handlePointerEvent(e);
        if (e.name !== d.name) {
          this.root.handleEvent(e), this.emit("event", e), this.root.handleEvent(d), this.emit("event", d);
          return;
        }
      }
    }
    return this.root.handleEvent(e), this.emit("event", e), e.type === "pointer" && e.name === "pointer_down" && this.menus.clearOpenMenus(), this;
  }
  /** @internal */
  maybeTrackPerformance(e) {
    ir.measurePerformance.get() && (this.performanceTracker.isStarted() ? clearTimeout(this.performanceTrackerTimeout) : this.performanceTracker.start(e), this.performanceTrackerTimeout = this.timers.setTimeout(() => {
      this.performanceTracker.stop();
    }, 50));
  }
};
Be = q6e(gj);
Ue(Be, 1, "getIsShapeHiddenCache", Ooe, Le);
Ue(Be, 1, "getCanUndo", Moe, Le);
Ue(Be, 1, "getCanRedo", Aoe, Le);
Ue(Be, 1, "getPath", koe, Le);
Ue(Be, 1, "getCurrentTool", Ioe, Le);
Ue(Be, 1, "getCurrentToolId", Poe, Le);
Ue(Be, 1, "getDocumentSettings", Toe, Le);
Ue(Be, 1, "getInstanceState", Eoe, Le);
Ue(Be, 1, "getOpenMenus", _oe, Le);
Ue(Be, 1, "getIsMenuOpen", Coe, Le);
Ue(Be, 1, "getPageStates", Soe, Le);
Ue(Be, 1, "_getPageStatesQuery", woe, Le);
Ue(Be, 1, "getCurrentPageState", xoe, Le);
Ue(Be, 1, "_getCurrentPageStateId", boe, Le);
Ue(Be, 1, "getSelectedShapeIds", voe, Le);
Ue(Be, 1, "getSelectedShapes", yoe, Le);
Ue(Be, 1, "getCurrentPageShapesInReadingOrder", moe, Le);
Ue(Be, 1, "getOnlySelectedShapeId", goe, Le);
Ue(Be, 1, "getOnlySelectedShape", poe, Le);
Ue(Be, 1, "getSelectionPageBounds", hoe, Le);
Ue(Be, 1, "getSelectionRotation", foe, Le);
Ue(Be, 1, "getSelectionRotatedPageBounds", uoe, Le);
Ue(Be, 1, "getSelectionRotatedScreenBounds", doe, Le);
Ue(Be, 1, "getFocusedGroupId", loe, Le);
Ue(Be, 1, "getFocusedGroup", coe, Le);
Ue(Be, 1, "getEditingShapeId", aoe, Le);
Ue(Be, 1, "getEditingShape", ioe, Le);
Ue(Be, 1, "getRichTextEditor", ooe, Le);
Ue(Be, 1, "getHoveredShapeId", soe, Le);
Ue(Be, 1, "getHoveredShape", roe, Le);
Ue(Be, 1, "getHintingShapeIds", noe, Le);
Ue(Be, 1, "getHintingShape", toe, Le);
Ue(Be, 1, "getErasingShapeIds", eoe, Le);
Ue(Be, 1, "getErasingShapes", Jse, Le);
Ue(Be, 1, "_unsafe_getCameraId", Qse, Le);
Ue(Be, 1, "getCamera", Zse, Le);
Ue(Be, 1, "getViewportPageBoundsForFollowing", Xse, Le);
Ue(Be, 1, "getCameraForFollowing", qse, Le);
Ue(Be, 1, "getZoomLevel", Yse, Le);
Ue(Be, 1, "getViewportScreenBounds", Gse, Le);
Ue(Be, 1, "getViewportScreenCenter", Kse, Le);
Ue(Be, 1, "getViewportPageBounds", Wse, Le);
Ue(Be, 1, "_getCollaboratorsQuery", Vse, Le);
Ue(Be, 1, "getCollaborators", Hse, Le);
Ue(Be, 1, "getCollaboratorsOnCurrentPage", Use, Le);
Ue(Be, 1, "getRenderingShapes", zse, Le);
Ue(Be, 1, "_getAllPagesQuery", Bse, Le);
Ue(Be, 1, "getPages", Fse, Le);
Ue(Be, 1, "getCurrentPageId", Lse, Le);
Ue(Be, 1, "getCurrentPageShapeIdsSorted", $se, Le);
Ue(Be, 1, "_getAllAssetsQuery", Rse, Le);
Ue(Be, 1, "_getShapeHandlesCache", jse, Le);
Ue(Be, 1, "_getShapePageTransformCache", Nse, Le);
Ue(Be, 1, "_getShapePageBoundsCache", Dse, Le);
Ue(Be, 1, "_getShapeClipPathCache", Ose, Le);
Ue(Be, 1, "_getShapeMaskCache", Mse, Le);
Ue(Be, 1, "_getShapeMaskedPageBoundsCache", Ase, Le);
Ue(Be, 1, "getNotVisibleShapes", kse, Le);
Ue(Be, 1, "getCulledShapes", Ise, Le);
Ue(Be, 1, "getCurrentPageBounds", Pse, Le);
Ue(Be, 1, "getCurrentPageShapes", Tse, Le);
Ue(Be, 1, "getCurrentPageShapesSorted", Ese, Le);
Ue(Be, 1, "getCurrentPageRenderingShapesSorted", _se, Le);
Ue(Be, 1, "_getBindingsIndexCache", Cse, Le);
Ue(Be, 1, "_getSelectionSharedStyles", Sse, Le);
Ue(Be, 1, "getSharedStyles", wse, Le);
Ue(Be, 1, "getSharedOpacity", xse, Le);
Ue(Be, 1, "getIsFocused", bse, Le);
Ue(Be, 1, "getIsReadonly", vse, Le);
Ue(Be, 1, "_setShiftKeyTimeout", yse, Le);
Ue(Be, 1, "_setAltKeyTimeout", mse, Le);
Ue(Be, 1, "_setCtrlKeyTimeout", gse, Le);
Ue(Be, 1, "_setMetaKeyTimeout", pse, Le);
Z6e(Be, Le);
function D1(t, e = t.getCurrentPageId()) {
  const n = t.getPage(e).name;
  t.emit("max-shapes", { name: n, pageId: e, count: t.options.maxShapesPerPage });
}
function vl(t, e) {
  if (!e) return t;
  let n = null;
  const r = Object.entries(e);
  for (let s = 0, o = r.length; s < o; s++) {
    const [i, a] = r[s];
    if (a !== void 0 && !(i === "id" || i === "type" || i === "typeName") && a !== t[i]) {
      if (n || (n = { ...t }), i === "props" || i === "meta") {
        n[i] = { ...t[i] };
        for (const [c, l] of Object.entries(a))
          n[i][c] = l;
        continue;
      }
      n[i] = a;
    }
  }
  return n || t;
}
function Doe(t, e, n) {
  const r = t.getShape(e);
  if (!r) return;
  n.push(r);
  const s = t.getSortedChildIdsForParent(e);
  for (let o = 0, i = s.length; o < i; o++)
    Doe(t, s[o], n);
}
function SH(t, e, n) {
  let r;
  if (t.run(
    () => {
      const s = t.store.extractingChanges(() => {
        const o = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
        for (const a of e)
          if (t.getShape(a))
            for (const l of t.getBindingsInvolvingShape(a)) {
              const d = e.has(l.fromId), u = e.has(l.toId);
              if (d && u) {
                o.add(l.id);
                continue;
              }
              (!d || !u) && i.add(l.id);
            }
        t.deleteBindings([...i], { isolateShapes: !0 });
        try {
          r = xf.ok(n(o));
        } catch (a) {
          r = xf.err(a);
        }
      });
      t.store.applyDiff(ej(s), { runCallbacks: !1 });
    },
    { history: "ignore" }
  ), r.ok)
    return r.value;
  throw r.error;
}
function CH(t, e) {
  if (!e.constraints) throw Error("Should have constraints here");
  const {
    padding: { x: n, y: r }
  } = e.constraints, s = t.getViewportScreenBounds(), o = _e.From(e.constraints.bounds), i = (s.w - n * 2) / o.w, a = (s.h - r * 2) / o.h;
  return { zx: i, zy: a };
}
function rS() {
  const t = ie(), e = J0();
  return le("isDarkMode", () => (e == null ? void 0 : e.isDarkMode) ?? t.user.getIsDarkMode(), [
    e,
    t
  ]);
}
const _H = "<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>", EH = "<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>", N1 = '<path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/>';
function Au(t, e, n, r, s, o = 16, i = 16) {
  const a = (-n - e) * (mn / 180), c = Math.sin(a), l = Math.cos(a), d = 1 * l - 1 * c, u = 1 * c + 1 * l;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${s};'><defs><filter id='shadow' y='-40%' x='-40%' width='180px' height='180%' color-interpolation-filters='sRGB'><feDropShadow dx='${d}' dy='${u}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${e + n} 16 16)${r ? " scale(-1,-1) translate(0, -32)" : ""}' filter='url(%23shadow)'>` + t.replaceAll('"', "'") + `</g></svg>") ${o} ${i}, pointer`;
}
const J6e = [
  "default",
  "pointer",
  "cross",
  "move",
  "grab",
  "grabbing",
  "text",
  "zoom-in",
  "zoom-out"
], eUe = {
  none: () => "none",
  "ew-resize": (t, e, n) => Au(EH, t, 0, e, n),
  "ns-resize": (t, e, n) => Au(EH, t, 90, e, n),
  "nesw-resize": (t, e, n) => Au(_H, t, 0, e, n),
  "nwse-resize": (t, e, n) => Au(_H, t, 90, e, n),
  "nwse-rotate": (t, e, n) => Au(N1, t, 0, e, n),
  "nesw-rotate": (t, e, n) => Au(N1, t, 90, e, n),
  "senw-rotate": (t, e, n) => Au(N1, t, 180, e, n),
  "swne-rotate": (t, e, n) => Au(N1, t, 270, e, n)
};
function ra(t, e = 0, n = "black") {
  return eUe[t](j4e(e), !1, n);
}
function tUe() {
  const t = ie(), e = Gr(), n = rS();
  Ep(
    "useCursor",
    () => {
      const { type: r, rotation: s } = t.getInstanceState().cursor;
      if (J6e.includes(r)) {
        e.style.setProperty("--tl-cursor", `var(--tl-cursor-${r})`);
        return;
      }
      e.style.setProperty(
        "--tl-cursor",
        ra(r, s, n ? "white" : "black")
      );
    },
    [t, e, n]
  );
}
function nUe() {
  const t = ie(), e = Gr(), n = rS(), r = le(ir.forceSrgb);
  B.useEffect(() => {
    n ? (e.setAttribute("data-color-mode", "dark"), e.classList.remove("tl-theme__light"), e.classList.add("tl-theme__dark")) : (e.setAttribute("data-color-mode", "light"), e.classList.remove("tl-theme__dark"), e.classList.add("tl-theme__light")), r ? e.classList.add("tl-theme__force-sRGB") : e.classList.remove("tl-theme__force-sRGB");
  }, [t, e, r, n]);
}
function rUe() {
  const [t, e] = he(0);
  me(() => e((n) => n + 1), []);
}
const sUe = (t) => t.props.src, oUe = {
  upload: async (t, e) => ({ src: await oi.blobToDataUrl(e) })
};
function iUe(t) {
  return "schema" in t && t.schema ? t.schema : E4e({
    shapes: "shapeUtils" in t && t.shapeUtils ? TH(One(t.shapeUtils)) : void 0,
    bindings: "bindingUtils" in t && t.bindingUtils ? TH(Pne(t.bindingUtils)) : void 0,
    migrations: "migrations" in t ? t.migrations : void 0
  });
}
function zE({
  initialData: t,
  defaultName: e = "",
  id: n,
  assets: r = oUe,
  onMount: s,
  collaboration: o,
  ...i
} = {}) {
  const a = iUe(i), c = new QF({
    id: n,
    schema: a,
    initialData: t,
    props: {
      defaultName: e,
      assets: {
        upload: r.upload,
        resolve: r.resolve ?? sUe,
        remove: r.remove ?? (() => Promise.resolve())
      },
      onMount: (l) => {
        tt(l instanceof Le), s == null || s(l);
      },
      collaboration: o
    }
  });
  if (i.snapshot) {
    if (t) throw new Error("Cannot provide both initialData and snapshot");
    Ene(c, i.snapshot, { forceOverwriteSessionState: !0 });
  }
  return c;
}
function TH(t) {
  return Object.fromEntries(
    t.map((e) => [
      e.type,
      {
        props: e.props,
        migrations: e.migrations
      }
    ])
  );
}
const aUe = (t, e) => e.some((n) => t instanceof n);
let PH, IH;
function cUe() {
  return PH || (PH = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function lUe() {
  return IH || (IH = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const Noe = /* @__PURE__ */ new WeakMap(), mj = /* @__PURE__ */ new WeakMap(), joe = /* @__PURE__ */ new WeakMap(), lO = /* @__PURE__ */ new WeakMap(), k3 = /* @__PURE__ */ new WeakMap();
function dUe(t) {
  const e = new Promise((n, r) => {
    const s = () => {
      t.removeEventListener("success", o), t.removeEventListener("error", i);
    }, o = () => {
      n(Xd(t.result)), s();
    }, i = () => {
      r(t.error), s();
    };
    t.addEventListener("success", o), t.addEventListener("error", i);
  });
  return e.then((n) => {
    n instanceof IDBCursor && Noe.set(n, t);
  }).catch(() => {
  }), k3.set(e, t), e;
}
function uUe(t) {
  if (mj.has(t))
    return;
  const e = new Promise((n, r) => {
    const s = () => {
      t.removeEventListener("complete", o), t.removeEventListener("error", i), t.removeEventListener("abort", i);
    }, o = () => {
      n(), s();
    }, i = () => {
      r(t.error || new DOMException("AbortError", "AbortError")), s();
    };
    t.addEventListener("complete", o), t.addEventListener("error", i), t.addEventListener("abort", i);
  });
  mj.set(t, e);
}
let yj = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return mj.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || joe.get(t);
      if (e === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return Xd(t[e]);
  },
  set(t, e, n) {
    return t[e] = n, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function fUe(t) {
  yj = t(yj);
}
function hUe(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(dO(this), e, ...n);
    return joe.set(r, e.sort ? e.sort() : [e]), Xd(r);
  } : lUe().includes(t) ? function(...e) {
    return t.apply(dO(this), e), Xd(Noe.get(this));
  } : function(...e) {
    return Xd(t.apply(dO(this), e));
  };
}
function pUe(t) {
  return typeof t == "function" ? hUe(t) : (t instanceof IDBTransaction && uUe(t), aUe(t, cUe()) ? new Proxy(t, yj) : t);
}
function Xd(t) {
  if (t instanceof IDBRequest)
    return dUe(t);
  if (lO.has(t))
    return lO.get(t);
  const e = pUe(t);
  return e !== t && (lO.set(t, e), k3.set(e, t)), e;
}
const dO = (t) => k3.get(t);
function Roe(t, e, { blocked: n, upgrade: r, blocking: s, terminated: o } = {}) {
  const i = indexedDB.open(t, e), a = Xd(i);
  return r && i.addEventListener("upgradeneeded", (c) => {
    r(Xd(i.result), c.oldVersion, c.newVersion, Xd(i.transaction), c);
  }), n && i.addEventListener("blocked", (c) => n(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    c.oldVersion,
    c.newVersion,
    c
  )), a.then((c) => {
    o && c.addEventListener("close", () => o()), s && c.addEventListener("versionchange", (l) => s(l.oldVersion, l.newVersion, l));
  }).catch(() => {
  }), a;
}
function $oe(t, { blocked: e } = {}) {
  const n = indexedDB.deleteDatabase(t);
  return e && n.addEventListener("blocked", (r) => e(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    r.oldVersion,
    r
  )), Xd(n).then(() => {
  });
}
const gUe = ["get", "getKey", "getAll", "getAllKeys", "count"], mUe = ["put", "add", "delete", "clear"], uO = /* @__PURE__ */ new Map();
function kH(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (uO.get(e))
    return uO.get(e);
  const n = e.replace(/FromIndex$/, ""), r = e !== n, s = mUe.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(s || gUe.includes(n))
  )
    return;
  const o = async function(i, ...a) {
    const c = this.transaction(i, s ? "readwrite" : "readonly");
    let l = c.store;
    return r && (l = l.index(a.shift())), (await Promise.all([
      l[n](...a),
      s && c.done
    ]))[0];
  };
  return uO.set(e, o), o;
}
fUe((t) => ({
  ...t,
  get: (e, n, r) => kH(e, n) || t.get(e, n, r),
  has: (e, n) => !!kH(e, n) || t.has(e, n)
}));
const yUe = "TLDRAW_DOCUMENT_v2", vUe = "TLDRAW_ASSET_STORE_v1", Loe = "TLDRAW_DB_NAME_INDEX_v2", Wt = {
  Records: "records",
  Schema: "schema",
  SessionState: "session_state",
  Assets: "assets"
};
async function Foe(t) {
  const e = yUe + t;
  return xUe(e), await Roe(e, 4, {
    upgrade(n) {
      n.objectStoreNames.contains(Wt.Records) || n.createObjectStore(Wt.Records), n.objectStoreNames.contains(Wt.Schema) || n.createObjectStore(Wt.Schema), n.objectStoreNames.contains(Wt.SessionState) || n.createObjectStore(Wt.SessionState), n.objectStoreNames.contains(Wt.Assets) || n.createObjectStore(Wt.Assets);
    }
  });
}
async function bUe(t) {
  const e = window.indexedDB.databases ? (await window.indexedDB.databases()).map((f) => f.name) : A3(), n = vUe + t;
  if (!e.find((f) => f === n)) return;
  const s = await Roe(n, 1, {
    upgrade(f) {
      f.objectStoreNames.contains("assets") || f.createObjectStore("assets");
    }
  });
  if (!s.objectStoreNames.contains("assets")) return;
  const o = s.transaction(["assets"], "readonly"), i = o.objectStore("assets"), a = await i.getAllKeys(), c = await Promise.all(
    a.map(async (f) => [f, await i.get(f)])
  );
  await o.done;
  const l = await Foe(t), d = l.transaction([Wt.Assets], "readwrite"), u = d.objectStore(Wt.Assets);
  for (const [f, p] of c)
    u.put(p, f);
  await d.done, s.close(), l.close(), await $oe(n);
}
const Wx = class Wx {
  constructor(e) {
    P(this, "getDbPromise");
    P(this, "isClosed", !1);
    P(this, "pendingTransactionSet", /* @__PURE__ */ new Set());
    Wx.connectedInstances.add(this), this.getDbPromise = (async () => (await bUe(e), await Foe(e)))();
  }
  getDb() {
    return this.getDbPromise;
  }
  /**
   * Wait for any pending transactions to be completed. Useful for tests.
   *
   * @internal
   */
  pending() {
    return Promise.allSettled([this.getDbPromise, ...this.pendingTransactionSet]).then(nw);
  }
  async close() {
    this.isClosed || (this.isClosed = !0, await this.pending(), (await this.getDb()).close(), Wx.connectedInstances.delete(this));
  }
  tx(e, n, r) {
    const s = (async () => {
      tt(!this.isClosed, "db is closed");
      const i = (await this.getDb()).transaction(n, e), a = i.done.catch((c) => {
        if (!this.isClosed)
          throw c;
      });
      try {
        return await r(i);
      } finally {
        this.isClosed ? i.abort() : await a;
      }
    })();
    return this.pendingTransactionSet.add(s), s.finally(() => this.pendingTransactionSet.delete(s)), s;
  }
  async load({ sessionId: e } = {}) {
    return await this.tx(
      "readonly",
      [Wt.Records, Wt.Schema, Wt.SessionState],
      async (n) => {
        var c, l;
        const r = n.objectStore(Wt.Records), s = n.objectStore(Wt.Schema), o = n.objectStore(Wt.SessionState);
        let i = e ? (c = await o.get(e)) == null ? void 0 : c.snapshot : null;
        return i || (i = (l = (await o.getAll()).sort((u, f) => u.updatedAt - f.updatedAt).pop()) == null ? void 0 : l.snapshot), {
          records: await r.getAll(),
          schema: await s.get(Wt.Schema),
          sessionStateSnapshot: i
        };
      }
    );
  }
  async storeChanges({
    schema: e,
    changes: n,
    sessionId: r,
    sessionStateSnapshot: s
  }) {
    await this.tx("readwrite", [Wt.Records, Wt.Schema, Wt.SessionState], async (o) => {
      const i = o.objectStore(Wt.Records), a = o.objectStore(Wt.Schema), c = o.objectStore(Wt.SessionState);
      for (const [l, d] of Object.entries(n.added))
        await i.put(d, l);
      for (const [l, d] of Object.values(n.updated))
        await i.put(d, d.id);
      for (const l of Object.keys(n.removed))
        await i.delete(l);
      a.put(e.serialize(), Wt.Schema), s && r ? c.put(
        {
          snapshot: s,
          updatedAt: Date.now(),
          id: r
        },
        r
      ) : (s || r) && console.error("sessionStateSnapshot and instanceId must be provided together");
    });
  }
  async storeSnapshot({
    schema: e,
    snapshot: n,
    sessionId: r,
    sessionStateSnapshot: s
  }) {
    await this.tx("readwrite", [Wt.Records, Wt.Schema, Wt.SessionState], async (o) => {
      const i = o.objectStore(Wt.Records), a = o.objectStore(Wt.Schema), c = o.objectStore(Wt.SessionState);
      await i.clear();
      for (const [l, d] of Object.entries(n))
        await i.put(d, l);
      a.put(e.serialize(), Wt.Schema), s && r ? c.put(
        {
          snapshot: s,
          updatedAt: Date.now(),
          id: r
        },
        r
      ) : (s || r) && console.error("sessionStateSnapshot and instanceId must be provided together");
    });
  }
  async pruneSessions() {
    await this.tx("readwrite", [Wt.SessionState], async (e) => {
      const n = e.objectStore(Wt.SessionState), r = (await n.getAll()).sort((o, i) => o.updatedAt - i.updatedAt);
      if (r.length < 10) {
        await e.done;
        return;
      }
      const s = r.slice(0, r.length - 10);
      for (const { id: o } of s)
        await n.delete(o);
    });
  }
  async getAsset(e) {
    return await this.tx("readonly", [Wt.Assets], async (n) => await n.objectStore(Wt.Assets).get(e));
  }
  async storeAsset(e, n) {
    await this.tx("readwrite", [Wt.Assets], async (r) => {
      await r.objectStore(Wt.Assets).put(n, e);
    });
  }
  async removeAssets(e) {
    await this.tx("readwrite", [Wt.Assets], async (n) => {
      const r = n.objectStore(Wt.Assets);
      for (const s of e)
        await r.delete(s);
    });
  }
};
/** @internal */
P(Wx, "connectedInstances", /* @__PURE__ */ new Set());
let UE = Wx;
function A3() {
  const t = JSON.parse(pF(Loe) || "[]") ?? [];
  return Array.isArray(t) ? t : [];
}
function xUe(t) {
  const e = new Set(A3());
  e.add(t), gF(Loe, JSON.stringify([...e]));
}
function wUe() {
  window.alert(
    `Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
 If your hard disk is full, try clearing up some space and then reload the page.`
  );
}
function SUe() {
  window.alert(
    `Oops! We could not access your browser's storageand the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`
  );
}
const CUe = 350, _Ue = 1e4, AH = Symbol("UPDATE_INSTANCE_STATE"), EUe = (t) => t;
class TUe {
  constructor(e) {
    P(this, "onmessage");
  }
  postMessage(e) {
  }
  close() {
  }
}
const PUe = typeof BroadcastChannel > "u" ? TUe : BroadcastChannel;
class IUe {
  constructor(e, {
    persistenceKey: n,
    sessionId: r = FE,
    onLoad: s,
    onLoadError: o
  }, i = new PUe(`tldraw-tab-sync-${n}`)) {
    P(this, "disposables", /* @__PURE__ */ new Set());
    P(this, "diffQueue", []);
    P(this, "didDispose", !1);
    P(this, "shouldDoFullDBWrite", !0);
    P(this, "isReloading", !1);
    P(this, "persistenceKey");
    P(this, "sessionId");
    P(this, "serializedSchema");
    P(this, "isDebugging", !1);
    P(this, "documentTypes");
    P(this, "$sessionStateSnapshot");
    /** @internal */
    P(this, "db");
    P(this, "initTime", Date.now());
    P(this, "isPersisting", !1);
    P(this, "didLastWriteError", !1);
    P(this, "scheduledPersistTimeout", null);
    this.store = e, this.channel = i, typeof window < "u" && (window.tlsync = this), this.persistenceKey = n, this.sessionId = r, this.db = new UE(n), this.disposables.add(() => this.db.close()), this.serializedSchema = this.store.schema.serialize(), this.$sessionStateSnapshot = v3(this.store), this.disposables.add(
      // Set up a subscription to changes from the store: When
      // the store changes (and if the change was made by the user)
      // then immediately send the diff to other tabs via postMessage
      // and schedule a persist.
      e.listen(
        ({ changes: a }) => {
          this.diffQueue.push(a), this.channel.postMessage(
            EUe({
              type: "diff",
              storeId: this.store.id,
              changes: a,
              schema: this.serializedSchema
            })
          ), this.schedulePersist();
        },
        { source: "user", scope: "document" }
      )
    ), this.disposables.add(
      e.listen(
        () => {
          this.diffQueue.push(AH), this.schedulePersist();
        },
        { scope: "session" }
      )
    ), this.connect(s, o), this.documentTypes = new Set(
      Object.values(this.store.schema.types).filter((a) => a.scope === "document").map((a) => a.typeName)
    );
  }
  debug(...e) {
    this.isDebugging && console.debug(...e);
  }
  async connect(e, n) {
    this.debug("connecting");
    let r;
    try {
      r = await this.db.load({ sessionId: this.sessionId });
    } catch (s) {
      n(s), SUe();
      return;
    }
    if (this.debug("loaded data from store", r, "didDispose", this.didDispose), !this.didDispose)
      try {
        if (r) {
          const s = Object.fromEntries(r.records.map((c) => [c.id, c])), o = r.sessionStateSnapshot ?? pBe(s), i = this.store.schema.migrateStoreSnapshot({
            store: s,
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            schema: r.schema ?? this.store.schema.serializeEarliestVersion()
          });
          if (i.type === "error") {
            console.error("failed to migrate store", i), n(new Error(`Failed to migrate store: ${i.reason}`));
            return;
          }
          const a = Object.values(i.value).filter(
            (c) => this.documentTypes.has(c.typeName)
          );
          a.length > 0 && this.store.mergeRemoteChanges(() => {
            this.store.put(a, "initialize");
          }), o && aj(this.store, o, {
            forceOverwrite: !0
          });
        }
        this.channel.onmessage = ({ data: s }) => {
          var a, c;
          this.debug("got message", s);
          const o = s, i = this.store.schema.getMigrationsSince(o.schema);
          if (i.ok) {
            if (i.value.length > 0) {
              this.debug("telling them to reload"), this.channel.postMessage({ type: "announce", schema: this.serializedSchema }), this.shouldDoFullDBWrite = !0, this.persistIfNeeded();
              return;
            }
          } else {
            if (Date.now() - this.initTime < 5e3) {
              n(new Error("Schema mismatch, please close other tabs and reload the page"));
              return;
            }
            this.debug("reloading"), this.isReloading = !0, (c = (a = window == null ? void 0 : window.location) == null ? void 0 : a.reload) == null || c.call(a);
            return;
          }
          o.type === "diff" && (this.debug("applying diff"), va(() => {
            this.store.mergeRemoteChanges(() => {
              this.store.applyDiff(o.changes);
            });
          }));
        }, this.channel.postMessage({ type: "announce", schema: this.serializedSchema }), this.disposables.add(() => {
          this.channel.close();
        }), e(this);
      } catch (s) {
        if (this.debug("error loading data from store", s), this.didDispose) return;
        n(s);
        return;
      }
  }
  close() {
    this.debug("closing"), this.didDispose = !0, this.disposables.forEach((e) => e());
  }
  /**
   * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too
   * often, and will retry if failed.
   *
   * @internal
   */
  schedulePersist() {
    this.debug("schedulePersist", this.scheduledPersistTimeout), !this.scheduledPersistTimeout && (this.scheduledPersistTimeout = setTimeout(
      () => {
        this.scheduledPersistTimeout = null, this.persistIfNeeded();
      },
      this.didLastWriteError ? _Ue : CUe
    ));
  }
  /**
   * Persist to IndexedDB only under certain circumstances:
   *
   * - If we're not already persisting
   * - If we're not reloading the page
   * - And we have something to persist (a full db write scheduled or changes in the diff queue)
   *
   * @internal
   */
  persistIfNeeded() {
    this.debug("persistIfNeeded", {
      isPersisting: this.isPersisting,
      isReloading: this.isReloading,
      shouldDoFullDBWrite: this.shouldDoFullDBWrite,
      diffQueueLength: this.diffQueue.length,
      storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()
    }), this.scheduledPersistTimeout && (clearTimeout(this.scheduledPersistTimeout), this.scheduledPersistTimeout = null), !this.isPersisting && (this.isReloading || this.store.isPossiblyCorrupted() || (this.shouldDoFullDBWrite || this.diffQueue.length > 0) && this.doPersist());
  }
  /**
   * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after
   * a short delay.
   */
  async doPersist() {
    if (tt(!this.isPersisting, "persist already in progress"), this.didDispose) return;
    this.isPersisting = !0, this.debug("doPersist start");
    const e = this.diffQueue;
    this.diffQueue = [];
    try {
      if (this.shouldDoFullDBWrite)
        this.shouldDoFullDBWrite = !1, await this.db.storeSnapshot({
          schema: this.store.schema,
          snapshot: this.store.serialize(),
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      else {
        const n = ZF(
          e.filter((r) => r !== AH)
        );
        await this.db.storeChanges({
          changes: n,
          schema: this.store.schema,
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      }
      this.didLastWriteError = !1;
    } catch (n) {
      this.shouldDoFullDBWrite = !0, this.didLastWriteError = !0, console.error("failed to store changes in indexed db", n), wUe(), typeof window < "u" && window.location.reload();
    }
    this.isPersisting = !1, this.debug("doPersist end"), this.schedulePersist();
  }
}
function Boe(t) {
  const e = fe(t), [n, r] = he(t);
  n !== e.current && r(e.current);
  const s = re((o) => {
    typeof o == "function" ? e.current = o(e.current) : e.current = o, r(e.current);
  }, []);
  return [n, s];
}
function kUe(t) {
  const [e, n] = Boe({ status: "loading" });
  return t = cv(t), me(() => {
    const { persistenceKey: r, sessionId: s, ...o } = t;
    if (!r) {
      n({
        status: "not-synced",
        store: zE(o)
      });
      return;
    }
    n({ status: "loading" });
    const i = new No(), a = {
      upload: async (u, f) => (await d.db.storeAsset(u.id, f), { src: u.id }),
      resolve: async (u) => u.props.src ? u.props.src.startsWith("asset:") ? await i.get(u, async () => {
        const f = await d.db.getAsset(u.id);
        return f ? URL.createObjectURL(f) : null;
      }) : u.props.src : null,
      remove: async (u) => {
        await d.db.removeAssets(u);
      },
      ...o.assets
    }, c = zE({ ...o, assets: a });
    let l = !1;
    const d = new IUe(c, {
      sessionId: s,
      persistenceKey: r,
      onLoad() {
        l || n({ store: c, status: "synced-local" });
      },
      onLoadError(u) {
        l || n({ status: "error", error: u });
      }
    });
    return () => {
      l = !0, d.close();
    };
  }, [t, n]), e;
}
function AUe() {
  const t = ie(), e = Gr();
  T.useEffect(() => {
    const n = (o) => e.style.setProperty("--tl-zoom", o.toString()), r = vI(n, 100), s = new hg("useZoomCss", () => {
      t.getCurrentPageShapeIds().size < 300 ? n(t.getZoomLevel()) : r(t.getZoomLevel());
    });
    return s.attach(), s.execute(), () => {
      s.detach(), r.cancel();
    };
  }, [t, e]);
}
function vj(t) {
  const e = new ArrayBuffer(t.length), n = new Uint8Array(e);
  for (let r = 0, s = t.length; r < s; r++)
    n[r] = t.charCodeAt(r);
  return e;
}
function MUe(t) {
  const e = atob(t), n = vj(e);
  return crypto.subtle.importKey(
    "spki",
    new Uint8Array(n),
    {
      name: "ECDSA",
      namedCurve: "P-256"
    },
    !0,
    ["verify"]
  );
}
const OUe = 5, jb = {
  ANNUAL_LICENSE: 1,
  PERPETUAL_LICENSE: 2,
  INTERNAL_LICENSE: 4,
  WITH_WATERMARK: 8
}, DUe = Math.max(...Object.values(jb)), Rb = {
  ID: 0,
  HOSTS: 1,
  FLAGS: 2,
  EXPIRY_DATE: 3
}, NUe = Object.keys(Rb).length, fO = "sales@tldraw.com", jUe = `${ts()}/watermarks/watermark-track.svg`;
class YI {
  constructor(e, n, r) {
    P(this, "publicKey", "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEHJh0uUfxHtCGyerXmmatE368Hd9rI6LH9oPDQihnaCryRFWEVeOvf9U/SPbyxX74LFyJs5tYeAHq5Nc0Ax25LQ");
    P(this, "isDevelopment");
    P(this, "isTest");
    P(this, "isCryptoAvailable");
    P(this, "state", yr("license state", "pending"));
    P(this, "verbose", !0);
    this.isTest = process.env.NODE_ENV === "test", this.isDevelopment = this.getIsDevelopment(r), this.publicKey = n || this.publicKey, this.isCryptoAvailable = !!crypto.subtle, this.getLicenseFromKey(e).then((s) => {
      const o = RUe(s);
      !this.isDevelopment && o === "unlicensed" && qc(jUe), this.state.set(o);
    }).catch((s) => {
      console.error("License validation failed:", s), this.state.set("unlicensed");
    });
  }
  getIsDevelopment(e) {
    return e === "development" ? !0 : e === "production" ? !1 : !["https:", "vscode-webview:"].includes(window.location.protocol) || window.location.hostname === "localhost";
  }
  async extractLicenseKey(e) {
    const [n, r] = e.split("."), [s, o] = n.split("/");
    if (!s.startsWith("tldraw-"))
      throw new Error(`Unsupported prefix '${s}'`);
    const i = await MUe(this.publicKey);
    let a;
    try {
      a = await crypto.subtle.verify(
        {
          name: "ECDSA",
          hash: { name: "SHA-256" }
        },
        i,
        new Uint8Array(vj(atob(r))),
        new Uint8Array(vj(atob(o)))
      );
    } catch (l) {
      throw console.error(l), new Error("Could not perform signature validation");
    }
    if (!a)
      throw new Error("Invalid signature");
    let c;
    try {
      c = JSON.parse(atob(o));
    } catch {
      throw new Error("Could not parse object");
    }
    return c.length > NUe && this.outputMessages([
      "License key contains some unknown properties.",
      "You may want to update tldraw packages to a newer version to get access to new functionality."
    ]), {
      id: c[Rb.ID],
      hosts: c[Rb.HOSTS],
      flags: c[Rb.FLAGS],
      expiryDate: c[Rb.EXPIRY_DATE]
    };
  }
  async getLicenseFromKey(e) {
    if (!e)
      return this.isDevelopment || this.outputNoLicenseKeyProvided(), { isLicenseParseable: !1, reason: "no-key-provided" };
    if (this.isDevelopment && !this.isCryptoAvailable)
      return this.verbose && (console.log(
        "tldraw: you seem to be in a development environment that does not support crypto. License not verified."
      ), console.log("You should check that this works in production separately.")), { isLicenseParseable: !1, reason: "has-key-development-mode" };
    let n = e.replace(/[\u200B-\u200D\uFEFF]/g, "");
    n = n.replace(/\r?\n|\r/g, "");
    try {
      const r = await this.extractLicenseKey(n), s = new Date(r.expiryDate), o = this.isFlagEnabled(r.flags, jb.ANNUAL_LICENSE), i = this.isFlagEnabled(r.flags, jb.PERPETUAL_LICENSE), a = {
        license: r,
        isLicenseParseable: !0,
        isDevelopment: this.isDevelopment,
        isDomainValid: this.isDomainValid(r),
        expiryDate: s,
        isAnnualLicense: o,
        isAnnualLicenseExpired: o && this.isAnnualLicenseExpired(s),
        isPerpetualLicense: i,
        isPerpetualLicenseExpired: i && this.isPerpetualLicenseExpired(s),
        isInternalLicense: this.isFlagEnabled(r.flags, jb.INTERNAL_LICENSE),
        isLicensedWithWatermark: this.isFlagEnabled(r.flags, jb.WITH_WATERMARK)
      };
      return this.outputLicenseInfoIfNeeded(a), a;
    } catch (r) {
      return this.outputInvalidLicenseKey(r.message), { isLicenseParseable: !1, reason: "invalid-license-key" };
    }
  }
  isDomainValid(e) {
    const n = window.location.hostname.toLowerCase();
    return e.hosts.some((r) => {
      const s = r.toLowerCase().trim();
      if (s === n || `www.${s}` === n || s === `www.${n}` || r === "*")
        return !0;
      if (r.includes("*")) {
        const o = new RegExp(r.replace(/\*/g, ".*?"));
        return o.test(n) || o.test(`www.${n}`);
      }
      if (window.location.protocol === "vscode-webview:") {
        const i = new URL(window.location.href).searchParams.get("extensionId");
        if (s === i)
          return !0;
      }
      return !1;
    });
  }
  getExpirationDateWithoutGracePeriod(e) {
    return new Date(e.getFullYear(), e.getMonth(), e.getDate());
  }
  getExpirationDateWithGracePeriod(e) {
    return new Date(
      e.getFullYear(),
      e.getMonth(),
      e.getDate() + OUe + 1
      // Add 1 day to include the expiration day
    );
  }
  isAnnualLicenseExpired(e) {
    const n = this.getExpirationDateWithGracePeriod(e), r = /* @__PURE__ */ new Date() >= n;
    return !r && /* @__PURE__ */ new Date() >= this.getExpirationDateWithoutGracePeriod(e) && this.outputMessages([
      "tldraw license is about to expire, you are in a grace period.",
      `Please reach out to ${fO} if you would like to renew your license.`
    ]), r;
  }
  isPerpetualLicenseExpired(e) {
    const n = this.getExpirationDateWithGracePeriod(e), r = {
      major: new Date(tH.major),
      minor: new Date(tH.minor)
    };
    return r.major >= n || r.minor >= n;
  }
  isFlagEnabled(e, n) {
    return (e & n) === n;
  }
  outputNoLicenseKeyProvided() {
  }
  outputInvalidLicenseKey(e) {
    this.outputMessages(["Invalid tldraw license key", `Reason: ${e}`]);
  }
  outputLicenseInfoIfNeeded(e) {
    e.isAnnualLicenseExpired && this.outputMessages([
      "Your tldraw license has expired!",
      `Please reach out to ${fO} to renew.`
    ]), !e.isDomainValid && !e.isDevelopment && this.outputMessages([
      "This tldraw license key is not valid for this domain!",
      `Please reach out to ${fO} if you would like to use tldraw on other domains.`
    ]), e.license.flags >= DUe * 2 && this.outputMessages(
      [
        "Warning: This tldraw license contains some unknown flags.",
        "This will still work, however, you may want to update tldraw packages to a newer version to get access to new functionality."
      ],
      "warning"
    );
  }
  outputMessages(e, n = "error") {
    if (!this.isTest && this.verbose) {
      this.outputDelimiter();
      for (const r of e) {
        const s = n === "warning" ? "orange" : "crimson", o = n === "warning" ? "orange" : "crimson";
        console.log(
          `%c${r}`,
          `color: ${s}; background: ${o}; padding: 2px; border-radius: 3px;`
        );
      }
      this.outputDelimiter();
    }
  }
  outputDelimiter() {
    console.log(
      "%c-------------------------------------------------------------------",
      "color: white; background: crimson; padding: 2px; border-radius: 3px;"
    );
  }
}
P(YI, "className", "tl-watermark_SEE-LICENSE");
function RUe(t) {
  return !t.isLicenseParseable || !t.isDomainValid && !t.isDevelopment ? "unlicensed" : t.isPerpetualLicenseExpired || t.isAnnualLicenseExpired ? t.isInternalLicense && t.isDomainValid ? "internal-expired" : "unlicensed" : t.isLicensedWithWatermark ? "licensed-with-watermark" : "licensed";
}
const zoe = zn({}), $Ue = () => tn(zoe);
function LUe({
  licenseKey: t,
  children: e
}) {
  const [n] = he(() => new YI(t));
  return le(n.state) === "internal-expired" ? /* @__PURE__ */ h.jsx("div", { "data-testid": "tl-license-expired", style: { display: "none" } }) : /* @__PURE__ */ h.jsx(zoe.Provider, { value: n, children: e });
}
function yu(t) {
  if (!t) throw Error("usePassThroughWheelEvents must be passed a ref");
  const e = Gr();
  me(() => {
    function n(s) {
      if (s.isSpecialRedispatchedEvent) return;
      const o = t.current;
      if (o && o.scrollHeight > o.clientHeight)
        return;
      xt(s);
      const i = e.querySelector(".tl-canvas");
      if (!i) return;
      const a = new WheelEvent("wheel", s);
      a.isSpecialRedispatchedEvent = !0, i.dispatchEvent(a);
    }
    const r = t.current;
    if (r)
      return r.addEventListener("wheel", n, { passive: !1 }), () => {
        r.removeEventListener("wheel", n);
      };
  }, [e, t]);
}
const FUe = '<svg xmlns="http://www.w3.org/2000/svg" width="3001" height="1000" fill="none"><path fill="#000" d="M590.656 300.449c0 49.706-40.294 90-90 90-49.705 0-90-40.294-90-90 0-49.705 40.295-90 90-90 49.706 0 90 40.295 90 90M569.431 719.011c-15.247 32.821-56.006 91.589-98.338 91.438-32.004-.115-38.642-30.904-17.414-50.856 17.381-16.337 28.246-48.075 31.995-72.719.415-2.728-1.556-5.197-4.272-5.679-39.666-7.04-70.746-40.877-70.746-83.417 0-48.23 38.983-87.329 87.07-87.329 39.936 0 70.172 22.237 83.369 52.397 18.839 43.055 7.117 115.733-11.664 156.165M2613.29 385.681V239.319c0-11.363 9.22-20.569 20.59-20.569h8.26c11.37 0 20.59 9.206 20.59 20.569v36.911c0 8.629 7 15.625 15.63 15.625h35.25c8.63 0 15.63-6.996 15.63-15.625v-36.911c0-11.363 9.22-20.569 20.59-20.569h8.17c11.37 0 20.59 9.206 20.59 20.569v146.362c0 11.363-9.22 20.569-20.59 20.569h-8.17c-11.37 0-20.59-9.206-20.59-20.569v-36.999c0-8.63-7-15.625-15.63-15.625h-35.25c-8.63 0-15.63 6.995-15.63 15.625v36.999c0 11.363-9.22 20.569-20.59 20.569h-8.26c-11.37 0-20.59-9.206-20.59-20.569M2391.97 239.319v146.362c0 11.348-9.16 20.569-20.49 20.569h-8.2c-11.33 0-20.49-9.221-20.49-20.569V239.319c0-11.348 9.16-20.569 20.49-20.569h8.2c11.33 0 20.49 9.221 20.49 20.569M2098.23 391.43l-42.69-146.361c-3.85-13.171 6.06-26.319 19.79-26.319h10.6c9.59 0 17.93 6.611 20.08 15.952l17.01 73.045c1.48 6.348 10.47 6.478 12.14.176l19.47-73.838c2.38-9.04 10.57-15.335 19.93-15.335h12.1c9.37 0 17.56 6.3 19.94 15.346l19.49 74.067c1.66 6.305 10.65 6.178 12.13-.171l17.09-73.294c2.15-9.339 10.49-15.948 20.08-15.948h10.53c13.72 0 23.63 13.141 19.79 26.31l-42.63 146.361c-2.56 8.789-10.63 14.829-19.79 14.829h-15.68c-9.12 0-17.16-5.98-19.76-14.709l-21.17-71.059c-1.77-5.948-10.19-5.957-11.97-.012l-21.33 71.071c-2.6 8.729-10.64 14.709-19.76 14.709h-15.59c-9.17 0-17.23-6.035-19.8-14.82M2443.23 218.75h118.59c11.38 0 20.62 9.195 20.62 20.557s-9.24 20.556-20.62 20.556h-24.79c-5.53 0-10 4.477-10 10v115.818c0 11.368-9.25 20.569-20.63 20.569h-7.65c-11.39 0-20.63-9.201-20.63-20.569V269.863c0-5.523-4.48-10-10-10h-24.89c-11.37 0-20.61-9.195-20.61-20.556s9.24-20.557 20.61-20.557M1174.15 218.75h24.64c8.35 0 15.88 5.042 19.04 12.764l34.61 83.942c2.13 5.161 9.44 5.155 11.56-.01l34.43-83.932a20.58 20.58 0 0 1 19.04-12.764h24.64c11.37 0 20.58 9.208 20.58 20.569v146.362c0 11.361-9.21 20.569-20.58 20.569h-7.09c-11.36 0-20.58-9.208-20.58-20.569l-.12-50.645c-.01-6.888-9.53-8.688-12.06-2.283l-23.46 59.332a20.57 20.57 0 0 1-19.14 13.009h-3.03a20.57 20.57 0 0 1-19.15-13.046l-23.47-59.68c-2.52-6.416-12.05-4.623-12.06 2.271l-.13 51.042c0 11.361-9.21 20.569-20.57 20.569h-7.1c-11.36 0-20.57-9.208-20.57-20.569V239.319c0-11.361 9.21-20.569 20.57-20.569"/><path fill="#000" fill-rule="evenodd" d="m1449.94 391.836 6.12-19.392a6.255 6.255 0 0 1 5.96-4.369l50.22-.061a6.24 6.24 0 0 1 5.96 4.348l6.23 19.486c2.71 8.581 10.71 14.402 19.74 14.402h9.34c14.13 0 24.15-13.791 19.61-27.151l-49.74-146.361c-2.85-8.37-10.74-13.988-19.61-13.988h-33.16c-8.87 0-16.77 5.618-19.61 13.988l-49.74 146.361c-4.54 13.36 5.48 27.151 19.61 27.151h9.32c9.04 0 17.04-5.827 19.75-14.414m31.1-98.858c1.85-5.807 10.08-5.796 11.91.016l8.83 27.916c1.28 4.028-1.73 8.134-5.96 8.134h-17.74c-4.23 0-7.24-4.119-5.95-8.151zM1681.81 406.25c18.91 0 35.39-3.686 49.36-11.168 13.97-7.544 24.73-18.394 32.24-32.489 7.56-14.105 11.29-30.866 11.29-50.182 0-19.256-3.73-35.957-11.29-50.004-7.57-14.094-18.35-24.912-32.32-32.397-13.91-7.545-30.4-11.26-49.37-11.26h-49.5c-11.38 0-20.63 9.201-20.63 20.569v146.362c0 11.368 9.25 20.569 20.63 20.569zm23.13-47.701c-6.62 3.215-14.85 4.886-24.79 4.886-10.49 0-19-8.507-19-19v-64.34c0-10.149 8.23-18.376 18.38-18.376 10.18 0 18.56 1.703 25.23 4.974 6.59 3.149 11.63 8.315 15.08 15.633 3.45 7.269 5.28 17.268 5.28 30.162 0 12.891-1.82 22.951-5.28 30.347-3.39 7.319-8.36 12.509-14.9 15.714" clip-rule="evenodd"/><path fill="#000" d="M1804.21 385.681V239.319c0-11.361 9.21-20.569 20.58-20.569h91.28c11.36 0 20.57 9.202 20.57 20.557s-9.21 20.556-20.57 20.556h-54.64a7.807 7.807 0 0 0-7.81 7.813v16.366a7.806 7.806 0 0 0 7.81 7.812h48.13c11.37 0 20.58 9.246 20.58 20.602s-9.21 20.601-20.58 20.601h-48.13a7.806 7.806 0 0 0-7.81 7.812v16.455a7.807 7.807 0 0 0 7.81 7.813h54.64c11.36 0 20.57 9.202 20.57 20.556s-9.21 20.557-20.57 20.557h-91.28c-11.37 0-20.58-9.208-20.58-20.569"/><path fill="#000" fill-rule="evenodd" d="M2875.5 68.75h-2750c-31.066 0-56.25 25.184-56.25 56.25v750c0 31.066 25.184 56.25 56.25 56.25h2750c31.07 0 56.25-25.184 56.25-56.25V125c0-31.066-25.18-56.25-56.25-56.25M125.5 0C56.464 0 .5 55.964.5 125v750c0 69.036 55.965 125 125 125h2750c69.04 0 125-55.964 125-125V125c0-69.036-55.96-125-125-125z" clip-rule="evenodd"/><path fill="#000" d="M2476.06 804.813c-10.54 0-19.82-6.947-22.81-17.068L2390.79 575.7c-4.49-15.248 6.92-30.534 22.8-30.534h27.75c11.1 0 20.72 7.686 23.18 18.52L2489 671.402c2.07 9.093 14.93 9.321 17.32.308l28.83-108.844c2.76-10.435 12.19-17.7 22.98-17.7h25.17c10.8 0 20.25 7.293 22.99 17.755l28.27 107.739c2.36 9.001 15.18 8.829 17.3-.232l25.01-106.888c2.51-10.763 12.1-18.374 23.14-18.374h27.87c15.88 0 27.29 15.286 22.8 30.534l-62.46 212.045a23.78 23.78 0 0 1-22.81 17.068h-32.12c-10.39 0-19.58-6.763-22.69-16.696l-32.08-102.694c-2.62-8.397-14.51-8.331-17.04.095l-30.74 102.346c-3.02 10.061-12.27 16.949-22.76 16.949zM1742.44 804.813h-75.81c-13.09 0-23.71-10.656-23.71-23.801V568.967c0-13.145 10.62-23.801 23.71-23.801h74.8c26.6 0 49.59 5.198 68.95 15.594 19.45 10.312 34.44 25.187 44.96 44.627 10.61 19.355 15.91 42.556 15.91 69.602q0 40.57-15.78 69.73c-10.53 19.355-25.43 34.231-44.71 44.627-19.28 10.311-42.05 15.467-68.32 15.467m-29.3-83.642c0 13.145 10.61 23.801 23.71 23.801h3.06c12.8 0 23.7-2.07 32.71-6.212 9.09-4.141 16-11.283 20.71-21.426q7.2-15.213 7.2-42.345 0-27.13-7.32-42.344c-4.8-10.143-11.87-17.285-21.22-21.426-9.26-4.142-20.63-6.212-34.1-6.212h-1.04c-13.1 0-23.71 10.656-23.71 23.801zM1460.86 804.813c-13.12 0-23.76-10.656-23.76-23.801V568.967c0-13.145 10.64-23.801 23.76-23.801h22.84c13.13 0 23.76 10.656 23.76 23.801v155.247c0 13.145 10.64 23.801 23.76 23.801h57.27c13.12 0 23.76 10.656 23.76 23.801v9.196c0 13.145-10.64 23.801-23.76 23.801zM1204.45 601.964c-13.13 0-23.77-10.656-23.77-23.801v-9.196c0-13.145 10.64-23.801 23.77-23.801h177.89c13.13 0 23.78 10.656 23.78 23.801v9.196c0 13.145-10.65 23.801-23.78 23.801h-39.38c-8.21 0-14.86 6.66-14.86 14.875v164.173c0 13.145-10.64 23.801-23.78 23.801h-21.85c-13.13 0-23.78-10.656-23.78-23.801V616.839c0-8.215-6.65-14.875-14.86-14.875z"/><path fill="#000" fill-rule="evenodd" d="M2223.05 787.891c-3.02 10.047-12.27 16.922-22.74 16.922h-25.43c-16.19 0-27.64-15.862-22.57-31.261l69.88-212.045c3.21-9.753 12.31-16.341 22.56-16.341h61.84c10.25 0 19.35 6.588 22.56 16.341l69.87 212.045c5.08 15.399-6.37 31.261-22.56 31.261h-25.43c-10.48 0-19.72-6.875-22.74-16.922l-6.7-22.2a14.84 14.84 0 0 0-14.21-10.576h-63.42c-6.55 0-12.32 4.296-14.22 10.576zm76.13-96.945-14.13-48.436c-2.46-8.451-14.36-8.602-17.04-.217l-15.46 48.436c-1.84 5.759 2.45 11.645 8.48 11.645h29.6c5.94 0 10.22-5.715 8.55-11.428" clip-rule="evenodd"/><path fill="#000" d="M1939.6 804.813c-13.13 0-23.77-10.656-23.77-23.801V568.967c0-13.145 10.64-23.801 23.77-23.801h88.13c19.24 0 36.08 3.508 50.51 10.523s25.65 17.115 33.67 30.3q12.03 19.779 12.03 47.416c0 18.595-4.14 34.273-12.41 47.036-7.64 11.913-18.18 21.101-31.63 27.564-16.98 8.159-36 11.104-54.7 11.104h-43.07c-76.56 0 4.08-135.84 4.08-84.706v7.996c0 12.117 9.81 21.941 21.91 21.941 8.12 0 16.3-.345 24.04-3.043 5.91-2.113 10.43-5.451 13.55-10.015 3.2-4.565 4.81-10.523 4.81-17.877 0-7.437-1.61-13.481-4.81-18.129-3.12-4.733-7.64-8.199-13.55-10.396-7.05-2.766-14.67-3.423-22.18-3.423-13.13 0-23.77 10.656-23.77 23.801v47.71c0 11.825 11.14 16.003 19.91 20.752 12.31 6.671 7.58 25.389-6.42 25.389-7.45 0-13.49 6.048-13.49 13.508v48.395c0 13.145-10.63 23.801-23.76 23.801zm134.89-106.758 5.41 9.95 33.51 61.622c8.62 15.86-2.84 35.186-20.87 35.186h-22.27c-8.74 0-16.77-4.798-20.92-12.496l-35.05-65.04a15.52 15.52 0 0 0-13.66-8.168c-42.24 0 40.62-82.154 73.85-21.054M931.652 0h68.748v1000h-68.748z"/></svg>', BUe = '<svg xmlns="http://www.w3.org/2000/svg" width="400" height="1601" fill="none"><path fill="#000" d="M72 1319.8c0-10.73 7.071-20.18 17.372-23.22l215.823-63.62c15.519-4.57 31.078 7.05 31.078 23.22v28.26c0 11.31-7.824 21.1-18.85 23.61l-109.636 24.94c-9.254 2.1-9.487 15.2-.313 17.63l110.784 29.37a24.21 24.21 0 0 1 18.015 23.4v25.64c0 11-7.423 20.62-18.071 23.41l-109.659 28.79c-9.162 2.41-8.986 15.47.236 17.63l108.792 25.46c10.955 2.56 18.702 12.33 18.702 23.57v28.39c0 16.17-15.559 27.79-31.078 23.22l-215.823-63.62c-10.3-3.04-17.372-12.49-17.372-23.22v-32.72c0-10.59 6.883-19.95 16.994-23.11l104.523-32.67c8.547-2.67 8.479-14.79-.096-17.36l-104.17-31.3C79.01 1372.42 72 1363 72 1352.31zM72 572.638V495.43c0-13.336 10.846-24.147 24.225-24.147h215.823c13.379 0 24.225 10.811 24.225 24.147v76.179q0 40.645-15.872 70.228-15.743 29.712-45.422 45.79-29.55 16.206-70.843 16.206-41.292 0-70.971-16.078-29.55-16.077-45.422-45.532Q72 612.767 72 572.638m85.132-29.84c-13.379 0-24.225 10.81-24.225 24.146v3.122q0 19.55 6.323 33.313 6.323 13.89 21.807 21.094 15.485 7.332 43.099 7.331t43.1-7.46q15.484-7.33 21.807-21.608 6.323-14.15 6.323-34.728v-1.064c0-13.336-10.846-24.146-24.225-24.146zM72 285.858c0-13.363 10.846-24.197 24.225-24.197h215.823c13.379 0 24.225 10.834 24.225 24.197v23.27c0 13.364-10.846 24.197-24.225 24.197H154.035c-13.379 0-24.225 10.834-24.225 24.197v58.328c0 13.364-10.846 24.197-24.225 24.197h-9.36C82.845 440.047 72 429.214 72 415.85zM278.463 24.72c0-13.374 10.846-24.216 24.225-24.216h9.36c13.379 0 24.225 10.842 24.225 24.216v181.174c0 13.374-10.846 24.216-24.225 24.216h-9.36c-13.379 0-24.225-10.842-24.225-24.216v-40.108c0-8.359-6.779-15.135-15.141-15.135H96.225c-13.38 0-24.225-10.842-24.225-24.216v-22.256c0-13.374 10.846-24.216 24.225-24.216h167.097c8.362 0 15.141-6.776 15.141-15.135z"/><path fill="#000" fill-rule="evenodd" d="M89.224 1062.13C78.997 1059.04 72 1049.63 72 1038.96v-25.9c0-16.486 16.145-28.147 31.818-22.979l215.823 71.169a24.19 24.19 0 0 1 16.632 22.98v62.97c0 10.45-6.706 19.71-16.632 22.98l-215.823 71.17C88.145 1246.51 72 1234.86 72 1218.37v-25.9c0-10.67 6.997-20.08 17.224-23.17l22.595-6.81a15.13 15.13 0 0 0 10.765-14.48v-64.59a15.13 15.13 0 0 0-10.765-14.48zm98.672 77.53 49.299-14.39c8.601-2.51 8.755-14.62.22-17.35l-49.299-15.75c-5.861-1.88-11.852 2.49-11.852 8.64v30.14c0 6.05 5.817 10.41 11.632 8.71" clip-rule="evenodd"/><path fill="#000" d="M72 773.439c0-13.367 10.846-24.203 24.225-24.203h215.823c13.379 0 24.225 10.836 24.225 24.203v89.762q0 29.395-10.711 51.439-10.71 22.046-30.84 34.293t-48.261 12.248q-28.388 0-47.873-12.635-18.187-11.672-28.056-32.218c-8.303-17.289-11.301-36.661-11.301-55.705v-43.867c0-77.976 138.26 4.16 86.215 4.16h-8.138c-12.334 0-22.332 9.989-22.332 22.311 0 8.269.351 16.6 3.097 24.487q3.225 9.024 10.194 13.794 6.968 4.899 18.194 4.899 11.356 0 18.453-4.899 7.226-4.77 10.581-13.794c2.815-7.188 3.484-14.944 3.484-22.596 0-13.366-10.846-24.202-24.225-24.202h-48.56c-12.036 0-16.288 11.345-21.122 20.272-6.79 12.539-25.841 7.72-25.841-6.536 0-7.586-6.156-13.736-13.749-13.736H96.225C82.845 820.916 72 810.08 72 796.714zm108.66 137.378-10.128 5.511-62.72 34.131C91.67 959.243 72 947.569 72 929.205V906.52a24.2 24.2 0 0 1 12.719-21.299l66.199-35.696a15.82 15.82 0 0 0 8.313-13.921c0-43.012 83.618 41.371 21.429 75.213"/></svg>';
function zUe(t) {
  return le("watermarkState", () => t.state.get(), [t]);
}
const UUe = `data:image/svg+xml;utf8,${encodeURIComponent(FUe)}`, HUe = `data:image/svg+xml;utf8,${encodeURIComponent(BUe)}`, VUe = it(function() {
  const e = $Ue(), n = ie(), r = le("is mobile", () => n.getViewportScreenBounds().width < 700, [
    n
  ]), s = zUe(e);
  return ["licensed-with-watermark", "unlicensed"].includes(s) ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(KUe, {}),
    /* @__PURE__ */ h.jsx(WUe, { src: r ? HUe : UUe })
  ] }) : null;
}), WUe = it(function({ src: e }) {
  const n = ie(), r = le("debug mode", () => n.getInstanceState().isDebugMode, [n]), s = le("is mobile", () => n.getViewportScreenBounds().width < 700, [
    n
  ]), o = g3(), i = fe(null);
  yu(i);
  const a = `url('${e}') center 100% / 100% no-repeat`, c = "https://tldraw.dev/?utm_source=dotcom&utm_medium=organic&utm_campaign=watermark";
  return /* @__PURE__ */ h.jsx(
    "div",
    {
      ref: i,
      className: YI.className,
      "data-debug": r,
      "data-mobile": s,
      draggable: !1,
      ...o,
      children: /* @__PURE__ */ h.jsx(
        "button",
        {
          draggable: !1,
          role: "button",
          onPointerDown: (l) => {
            cr(l), xt(l);
          },
          title: "made with tldraw",
          onClick: () => RI.openWindow(c, "_blank"),
          style: { mask: a, WebkitMask: a }
        }
      )
    }
  );
}), KUe = it(function() {
  const e = ie(), n = YI.className, r = `/* ------------------- SEE LICENSE -------------------
The tldraw watermark is part of tldraw's license. It is shown for unlicensed
or "licensed-with-watermark" users. By using this library, you agree to
preserve the watermark's behavior, keeping it visible, unobscured, and
available to user-interaction.

To remove the watermark, please purchase a license at tldraw.dev.
*/

	.${n} {
		position: absolute;
		bottom: max(var(--space-2), env(safe-area-inset-bottom));
		right: max(var(--space-2), env(safe-area-inset-right));
		width: 96px;
		height: 32px;
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: var(--layer-watermark) !important;
		background-color: color-mix(in srgb, var(--color-background) 62%, transparent);
		opacity: 1;
		border-radius: 5px;
		pointer-events: all;
		padding: 2px;
		box-sizing: content-box;
	}

	.${n} > button {
		position: absolute;
		width: 96px;
		height: 32px;
		pointer-events: all;
		cursor: inherit;
		color: var(--color-text);
		opacity: .38;
		border: 0;
		padding: 0;
		background-color: currentColor;
	}

	.${n}[data-debug='true'] {
		bottom: max(46px, env(safe-area-inset-bottom));
	}

	.${n}[data-mobile='true'] {
		border-radius: 4px 0px 0px 4px;
		right: max(-2px, calc(env(safe-area-inset-right) - 2px));
		width: 8px;
		height: 48px;
	}

	.${n}[data-mobile='true'] > button {
		width: 8px;
		height: 32px;
	}

	@media (hover: hover) {
		.${n} > button {
			pointer-events: none;
		}

		.${n}:hover {
			background-color: var(--color-background);
			transition: background-color 0.2s ease-in-out;
			transition-delay: 0.32s;
		}

		.${n}:hover > button {
			animation: ${n}_delayed_link 0.2s forwards ease-in-out;
			animation-delay: 0.32s;
		}

		.${n} > button:focus-visible {
			opacity: 1;
		}
	}


	@keyframes ${n}_delayed_link {
		0% {
			cursor: inherit;
			opacity: .38;
			pointer-events: none;
		}
		100% {
			cursor: pointer;
			opacity: 1;
			pointer-events: all;
		}
	}`;
  return /* @__PURE__ */ h.jsx("style", { nonce: e.options.nonce, children: r });
}), GUe = [], YUe = [], qUe = [], XUe = "tl-container", ZUe = it(function({
  store: e,
  components: n,
  className: r,
  user: s,
  options: o,
  ...i
}) {
  const [a, c] = he(null), l = Ke(() => s ?? wne(), [s]), d = (n == null ? void 0 : n.ErrorFallback) === void 0 ? dne : n == null ? void 0 : n.ErrorFallback, u = {
    ...i,
    shapeUtils: i.shapeUtils ?? GUe,
    bindingUtils: i.bindingUtils ?? YUe,
    tools: i.tools ?? qUe,
    components: n,
    options: cv(o)
  };
  return /* @__PURE__ */ h.jsx(
    "div",
    {
      ref: c,
      "data-tldraw": une,
      draggable: !1,
      className: Je(`${XUe} tl-theme__light`, r),
      onPointerDown: cr,
      tabIndex: -1,
      role: "application",
      "aria-label": (o == null ? void 0 : o.branding) ?? "tldraw",
      children: /* @__PURE__ */ h.jsx(
        dw,
        {
          fallback: d,
          onError: (f) => dF(f, { tags: { origin: "react.tldraw-before-app" } }),
          children: a && /* @__PURE__ */ h.jsx(LUe, { licenseKey: i.licenseKey, children: /* @__PURE__ */ h.jsx(cne, { container: a, children: /* @__PURE__ */ h.jsx(u8e, { overrides: n, children: e ? e instanceof QF ? (
            // Store is ready to go, whether externally synced or not
            /* @__PURE__ */ h.jsx(Hoe, { ...u, store: e, user: l })
          ) : (
            // Store is a synced store, so handle syncing stages internally
            /* @__PURE__ */ h.jsx(Uoe, { ...u, store: e, user: l })
          ) : (
            // We have no store (it's undefined) so create one and possibly sync it
            /* @__PURE__ */ h.jsx(QUe, { ...u, store: e, user: l })
          ) }) }) })
        }
      )
    }
  );
});
function QUe(t) {
  const {
    defaultName: e,
    snapshot: n,
    initialData: r,
    shapeUtils: s,
    bindingUtils: o,
    persistenceKey: i,
    sessionId: a,
    user: c,
    assets: l,
    migrations: d
  } = t, u = kUe({
    shapeUtils: s,
    bindingUtils: o,
    initialData: r,
    persistenceKey: i,
    sessionId: a,
    defaultName: e,
    snapshot: n,
    assets: l,
    migrations: d
  });
  return /* @__PURE__ */ h.jsx(Uoe, { ...t, store: u, user: c });
}
const Uoe = it(function({
  store: e,
  user: n,
  ...r
}) {
  const s = Gr();
  un(() => {
    n.userPreferences.get().colorScheme === "dark" && (s.classList.remove("tl-theme__light"), s.classList.add("tl-theme__dark"));
  }, [s, n]);
  const { LoadingScreen: o } = Ln();
  switch (e.status) {
    case "error":
      throw e.error;
    case "loading":
      return o ? /* @__PURE__ */ h.jsx(o, {}) : null;
  }
  return /* @__PURE__ */ h.jsx(Hoe, { ...r, store: e.store, user: n });
}), hO = () => document.location.search.includes("tldraw_preserve_focus");
function Hoe({
  onMount: t,
  children: e,
  store: n,
  tools: r,
  shapeUtils: s,
  bindingUtils: o,
  user: i,
  initialState: a,
  autoFocus: c = !0,
  inferDarkMode: l,
  cameraOptions: d,
  textOptions: u,
  options: f,
  licenseKey: p,
  deepLinks: g,
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  isShapeHidden: y,
  getShapeVisibility: m,
  assetUrls: v
}) {
  const { ErrorFallback: b } = Ln(), x = Gr(), [w, S] = Boe(null), C = fe(null), _ = cv(g === !0 ? {} : g), E = fe({
    // for these, it's because they're only used when the editor first mounts:
    autoFocus: c && !hO(),
    inferDarkMode: l,
    initialState: a,
    // for these, it's because we keep them up to date in a separate effect:
    cameraOptions: d,
    deepLinks: _
  });
  un(() => {
    E.current = {
      autoFocus: c && !hO(),
      inferDarkMode: l,
      initialState: a,
      cameraOptions: d,
      deepLinks: _
    };
  }, [c, l, a, d, _]), un(
    () => {
      const { autoFocus: R, inferDarkMode: j, initialState: $, cameraOptions: F, deepLinks: L } = E.current, z = new Le({
        store: n,
        shapeUtils: s,
        bindingUtils: o,
        tools: r,
        getContainer: () => x,
        user: i,
        initialState: $,
        // we should check for some kind of query parameter that turns off autofocus
        autoFocus: R,
        inferDarkMode: j,
        cameraOptions: F,
        textOptions: u,
        options: f,
        licenseKey: p,
        isShapeHidden: y,
        getShapeVisibility: m,
        fontAssetUrls: v == null ? void 0 : v.fonts
      });
      return z.updateViewportScreenBounds(C.current ?? x), L && (L != null && L.getUrl ? z.navigateToDeepLink({ ...L, url: L.getUrl(z) }) : z.navigateToDeepLink(L)), S(z), () => {
        z.dispose();
      };
    },
    // if any of these change, we need to recreate the editor.
    [
      o,
      x,
      f,
      s,
      n,
      r,
      i,
      S,
      p,
      y,
      m,
      u,
      v
    ]
  ), un(() => {
    if (w && _)
      return w.registerDeepLinkListener(_);
  }, [w, _]), un(() => {
    w && d && w.setCameraOptions(d);
  }, [w, d]);
  const M = Gx(
    re(
      (R) => w ? (w.on("crash", R), () => w.off("crash", R)) : () => {
      },
      [w]
    ),
    () => (w == null ? void 0 : w.getCrashingError()) ?? null
  );
  me(
    function() {
      if (!w) return;
      function j() {
        w && w.focus();
      }
      function $() {
        w && w.blur();
      }
      if (c && hO())
        return w.getContainer().addEventListener("pointerdown", j), document.body.addEventListener("pointerdown", $), () => {
          var F;
          (F = w.getContainer()) == null || F.removeEventListener("pointerdown", j), document.body.removeEventListener("pointerdown", $);
        };
    },
    [w, c]
  );
  const [N, O] = he(null);
  let D = N;
  w !== (D == null ? void 0 : D.editor) && (D = null), me(() => {
    if (!w) return;
    let R = !1;
    return O({ editor: w, isLoaded: !1 }), w.fonts.loadRequiredFontsForCurrentPage(w.options.maxFontsToLoadBeforeRender).finally(() => {
      R || O({ editor: w, isLoaded: !0 });
    }), () => {
      R = !0;
    };
  }, [w]);
  const { Canvas: k, LoadingScreen: A } = Ln();
  return !w || !(D != null && D.isLoaded) ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    A && /* @__PURE__ */ h.jsx(A, {}),
    /* @__PURE__ */ h.jsx("div", { className: "tl-canvas", ref: C })
  ] }) : (
    // the top-level tldraw component also renders an error boundary almost
    // identical to this one. the reason we have two is because this one has
    // access to `App`, which means that here we can enrich errors with data
    // from app for reporting, and also still attempt to render the user's
    // document in the event of an error to reassure them that their work is
    // not lost.
    /* @__PURE__ */ h.jsx(dw, {
      fallback: b,
      onError: (R) => w.annotateError(R, { origin: "react.tldraw", willCrashApp: !0 }),
      children: M ? /* @__PURE__ */ h.jsx(e8e, { crashingError: M }) : /* @__PURE__ */ h.jsx(p3, { editor: w, children: /* @__PURE__ */ h.jsxs(JUe, { onMount: t, children: [
        e ?? (k ? /* @__PURE__ */ h.jsx(k, {}, w.contextId) : null),
        /* @__PURE__ */ h.jsx(VUe, {})
      ] }) })
    })
  );
}
function JUe({ children: t, onMount: e }) {
  return AUe(), tUe(), nUe(), rUe(), Woe((n) => {
    const r = n.store.props.onMount(n), s = e == null ? void 0 : e(n);
    return () => {
      r == null || r(), s == null || s();
    };
  }), t;
}
function e8e({ crashingError: t }) {
  throw t;
}
function Voe({ children: t }) {
  return /* @__PURE__ */ h.jsx("div", { className: "tl-loading", "aria-busy": "true", tabIndex: 0, children: t });
}
function Woe(t) {
  const e = ie(), n = kl((r) => {
    let s;
    return r.run(
      () => {
        s = t == null ? void 0 : t(r), r.emit("mount");
      },
      { history: "ignore" }
    ), window.tldrawReady = !0, s;
  });
  B.useLayoutEffect(() => {
    if (e) return n == null ? void 0 : n(e);
  }, [e, n]);
}
const t8e = () => {
  const { Spinner: t } = Ln();
  return /* @__PURE__ */ h.jsx(Voe, { children: t ? /* @__PURE__ */ h.jsx(t, {}) : null });
};
function Koe(t, e = !0) {
  const n = t.length;
  if (n < 2)
    return "";
  let r = t[0], s = t[1];
  if (n === 2)
    return `M${eo(r)}L${eo(s)}`;
  let o = "";
  for (let i = 2, a = n - 1; i < a; i++)
    r = t[i], s = t[i + 1], o += Oi(r, s);
  return e ? `M${Oi(t[0], t[1])}Q${eo(t[1])}${Oi(
    t[1],
    t[2]
  )}T${o}${Oi(t[n - 1], t[0])}${Oi(t[0], t[1])}Z` : `M${eo(t[0])}Q${eo(t[1])}${Oi(t[1], t[2])}${t.length > 3 ? "T" : ""}${o}L${eo(t[n - 1])}`;
}
function MH({ scribble: t, zoom: e, color: n, opacity: r, className: s }) {
  return t.points.length ? /* @__PURE__ */ h.jsx("svg", { className: s && Je("tl-overlays__item", s), children: /* @__PURE__ */ h.jsx(
    "path",
    {
      className: "tl-scribble",
      d: Koe(t.points, !1),
      stroke: n ?? `var(--color-${t.color})`,
      fill: "none",
      strokeWidth: 8 / e,
      opacity: r ?? t.opacity
    }
  ) }) : null;
}
function n8e({ bounds: t, rotation: e }) {
  const n = ie(), r = fe(null), s = le("only selected shape", () => n.getOnlySelectedShape(), [n]), o = s ? n.getShapeUtil(s).expandSelectionOutlinePx(s) : 0;
  return Y0(r, t == null ? void 0 : t.x, t == null ? void 0 : t.y, 1, e, {
    x: -o,
    y: -o
  }), t = o instanceof _e ? t.clone().expand(o).zeroFix() : t.clone().expandBy(o).zeroFix(), /* @__PURE__ */ h.jsx(
    "svg",
    {
      ref: r,
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      children: /* @__PURE__ */ h.jsx(
        "rect",
        {
          className: Je("tl-selection__fg__outline"),
          width: ne(t.width),
          height: ne(t.height)
        }
      )
    }
  );
}
const r8e = () => /* @__PURE__ */ h.jsx("div", { className: "tl-shape-error-boundary" }), s8e = it(
  ({ shape: t, util: e }) => PI(
    "Indicator: " + t.type,
    () => (
      // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
      // calling the render method with stale data.
      e.indicator(e.editor.store.unsafeGetWithoutCapture(t.id))
    )
  ),
  (t, e) => t.shape.props === e.shape.props && t.shape.meta === e.shape.meta
), o8e = it(({ editor: t, id: e }) => {
  const n = le("shape for indicator", () => t.store.get(e), [t, e]), { ShapeIndicatorErrorFallback: r } = Ln();
  return !n || n.isLocked ? null : /* @__PURE__ */ h.jsx(
    dw,
    {
      fallback: r,
      onError: (s) => t.annotateError(s, { origin: "react.shapeIndicator", willCrashApp: !1 }),
      children: /* @__PURE__ */ h.jsx(s8e, { shape: n, util: t.getShapeUtil(n) }, n.id)
    }
  );
}), OH = it(function({
  shapeId: e,
  className: n,
  color: r,
  hidden: s,
  opacity: o
}) {
  const i = ie(), a = fe(null);
  return Ep(
    "indicator transform",
    () => {
      if (s) return;
      const c = a.current;
      if (!c) return;
      const l = i.getShapePageTransform(e);
      l && c.style.setProperty("transform", l.toCssString());
    },
    [i, e, s]
  ), un(() => {
    const c = a.current;
    c && c.style.setProperty("display", s ? "none" : "block");
  }, [s]), /* @__PURE__ */ h.jsx("svg", { ref: a, className: Je("tl-overlays__item", n), "aria-hidden": "true", children: /* @__PURE__ */ h.jsx("g", { className: "tl-shape-indicator", stroke: r ?? "var(--color-selected)", opacity: o, children: /* @__PURE__ */ h.jsx(o8e, { editor: i, id: e }) }) });
}), i8e = () => /* @__PURE__ */ h.jsx("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" }), Goe = it(function({
  hideAll: e,
  showAll: n
}) {
  const r = ie();
  if (e && n)
    throw Error("You cannot set both hideAll and showAll props to true, cmon now");
  const s = fe(/* @__PURE__ */ new Set()), o = le(
    "should display selected ids",
    () => {
      const c = s.current, l = /* @__PURE__ */ new Set(), d = r.getInstanceState(), u = d.isChangingStyle, f = r.isInAny("select.idle", "select.editing_shape"), p = r.isInAny(
        "select.brushing",
        "select.scribble_brushing",
        "select.pointing_shape",
        "select.pointing_selection",
        "select.pointing_handle"
      );
      if (u || !(f || p))
        return s.current = l, l;
      for (const g of r.getSelectedShapeIds())
        l.add(g);
      if (f && d.isHoveringCanvas && !d.isCoarsePointer) {
        const g = r.getHoveredShapeId();
        g && l.add(g);
      }
      if (c.size !== l.size)
        return s.current = l, l;
      for (const g of l)
        if (!c.has(g))
          return s.current = l, l;
      return c;
    },
    [r]
  ), i = le("rendering shapes", () => r.getRenderingShapes(), [r]), { ShapeIndicator: a } = Ln();
  return a ? i.map(({ id: c }) => /* @__PURE__ */ h.jsx(
    a,
    {
      shapeId: c,
      hidden: !n && (e || !o.has(c))
    },
    c + "_indicator"
  )) : null;
});
function a8e({ points: t, zoom: e }) {
  const n = 2.5 / e, r = t.reduce((f, p) => Math.min(f, p.x), 1 / 0), s = t.reduce((f, p) => Math.max(f, p.x), -1 / 0), o = t.reduce((f, p) => Math.min(f, p.y), 1 / 0), i = t.reduce((f, p) => Math.max(f, p.y), -1 / 0), a = t.some((f) => f.x === r && f.y === o);
  let c, l, d, u;
  return a ? (c = r, l = o, d = s, u = i) : (c = r, l = i, d = s, u = o), /* @__PURE__ */ h.jsxs("g", { className: "tl-snap-indicator", stroke: "lime", children: [
    /* @__PURE__ */ h.jsx("line", { x1: c, y1: l, x2: d, y2: u }),
    t.map((f, p) => /* @__PURE__ */ h.jsx("g", { transform: `translate(${f.x},${f.y})`, children: /* @__PURE__ */ h.jsx(
      "path",
      {
        className: "tl-snap-point",
        d: `M ${-n},${-n} L ${n},${n} M ${-n},${n} L ${n},${-n}`
      }
    ) }, p))
  ] });
}
function c8e({ gaps: t, direction: e, zoom: n }) {
  const r = 3.5 / n;
  let s = [-1 / 0, 1 / 0], o = null;
  const i = e === "horizontal";
  for (const c of t) {
    if (o = Mc(
      s[0],
      s[1],
      i ? c.startEdge[0].y : c.startEdge[0].x,
      i ? c.startEdge[1].y : c.startEdge[1].x
    ), o)
      s = o;
    else
      continue;
    if (o = Mc(
      s[0],
      s[1],
      i ? c.endEdge[0].y : c.endEdge[0].x,
      i ? c.endEdge[1].y : c.endEdge[1].x
    ), o)
      s = o;
    else
      continue;
  }
  if (s === null)
    return null;
  const a = (s[0] + s[1]) / 2;
  return /* @__PURE__ */ h.jsx("g", { className: "tl-snap-indicator", stroke: "cyan", children: t.map(({ startEdge: c, endEdge: l }, d) => /* @__PURE__ */ h.jsx(T.Fragment, { children: i ? (
    // horizontal gap
    /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(
        "line",
        {
          x1: c[0].x,
          y1: a - 2 * r,
          x2: c[1].x,
          y2: a + 2 * r
        }
      ),
      /* @__PURE__ */ h.jsx(
        "line",
        {
          x1: l[0].x,
          y1: a - 2 * r,
          x2: l[1].x,
          y2: a + 2 * r
        }
      ),
      /* @__PURE__ */ h.jsx("line", { x1: c[0].x, y1: a, x2: l[0].x, y2: a }),
      /* @__PURE__ */ h.jsx(
        "line",
        {
          x1: (c[0].x + l[0].x) / 2,
          y1: a - r,
          x2: (c[0].x + l[0].x) / 2,
          y2: a + r
        }
      )
    ] })
  ) : (
    // vertical gap
    /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(
        "line",
        {
          x1: a - 2 * r,
          y1: c[0].y,
          x2: a + 2 * r,
          y2: c[1].y
        }
      ),
      /* @__PURE__ */ h.jsx(
        "line",
        {
          x1: a - 2 * r,
          y1: l[0].y,
          x2: a + 2 * r,
          y2: l[1].y
        }
      ),
      /* @__PURE__ */ h.jsx("line", { x1: a, y1: c[0].y, x2: a, y2: l[0].y }),
      /* @__PURE__ */ h.jsx(
        "line",
        {
          x1: a - r,
          y1: (c[0].y + l[0].y) / 2,
          x2: a + r,
          y2: (c[0].y + l[0].y) / 2
        }
      )
    ] })
  ) }, d)) });
}
function l8e({ className: t, line: e, zoom: n }) {
  return /* @__PURE__ */ h.jsx("svg", { className: Je("tl-overlays__item", t), "aria-hidden": "true", children: e.type === "points" ? /* @__PURE__ */ h.jsx(a8e, { ...e, zoom: n }) : e.type === "gaps" ? /* @__PURE__ */ h.jsx(c8e, { ...e, zoom: n }) : null });
}
function Yoe(t) {
  return /* @__PURE__ */ h.jsx(
    "svg",
    {
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      "aria-hidden": "false",
      ...t,
      className: Je("tl-spinner", t.className),
      children: /* @__PURE__ */ h.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
        /* @__PURE__ */ h.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
        /* @__PURE__ */ h.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor" })
      ] })
    }
  );
}
const d8e = () => null, qoe = zn(null);
function u8e({
  overrides: t = {},
  children: e
}) {
  const n = cv(t), r = Ke(
    () => ({
      Background: k4e,
      Brush: JM,
      Canvas: PHe,
      CollaboratorBrush: JM,
      CollaboratorCursor: eH,
      CollaboratorHint: G4e,
      CollaboratorScribble: MH,
      CollaboratorShapeIndicator: OH,
      Cursor: eH,
      Grid: Z4e,
      Handle: Q4e,
      Handles: J4e,
      InFrontOfTheCanvas: null,
      LoadingScreen: t8e,
      OnTheCanvas: null,
      Overlays: null,
      Scribble: MH,
      SelectionBackground: null,
      SelectionForeground: n8e,
      ShapeIndicator: OH,
      ShapeIndicators: Goe,
      SnapIndicator: l8e,
      Spinner: Yoe,
      SvgDefs: d8e,
      ZoomBrush: JM,
      ErrorFallback: dne,
      ShapeErrorFallback: r8e,
      ShapeIndicatorErrorFallback: i8e,
      ...n
    }),
    [n]
  );
  return /* @__PURE__ */ h.jsx(qoe.Provider, { value: r, children: e });
}
function Ln() {
  const t = tn(qoe);
  if (!t)
    throw new Error("useEditorComponents must be used inside of <EditorComponentsProvider />");
  return t;
}
const f8e = ["textarea", "input"];
function h8e(t) {
  const e = ie();
  me(() => {
    const n = t.current;
    if (!n) return;
    const r = (s) => {
      var o;
      if (s instanceof PointerEvent && s.pointerType === "pen") {
        s.isKilled = !0;
        const { target: i } = s;
        if (f8e.includes((o = i.tagName) == null ? void 0 : o.toLocaleLowerCase()) || i.isContentEditable || e.isIn("select.editing_shape"))
          return;
        xt(s);
      }
    };
    return n.addEventListener("touchstart", r), n.addEventListener("touchend", r), () => {
      n.removeEventListener("touchstart", r), n.removeEventListener("touchend", r);
    };
  }, [e, t]);
}
function p8e(t, e, n) {
  return Math.max(e, Math.min(t, n));
}
const so = {
  toVector(t, e) {
    return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t];
  },
  add(t, e) {
    return [t[0] + e[0], t[1] + e[1]];
  },
  sub(t, e) {
    return [t[0] - e[0], t[1] - e[1]];
  },
  addTo(t, e) {
    t[0] += e[0], t[1] += e[1];
  },
  subTo(t, e) {
    t[0] -= e[0], t[1] -= e[1];
  }
};
function DH(t, e, n) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, n * 5) : t * e * n / (e + n * t);
}
function NH(t, e, n, r = 0.15) {
  return r === 0 ? p8e(t, e, n) : t < e ? -DH(e - t, n - e, r) + e : t > n ? +DH(t - n, n - e, r) + n : t;
}
function g8e(t, [e, n], [r, s]) {
  const [[o, i], [a, c]] = t;
  return [NH(e, o, i, r), NH(n, a, c, s)];
}
function m8e(t, e) {
  if (typeof t != "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function y8e(t) {
  var e = m8e(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
function To(t, e, n) {
  return e = y8e(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function jH(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vr(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? jH(Object(n), !0).forEach(function(r) {
      To(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : jH(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
const Xoe = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function RH(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
const v8e = ["enter", "leave"];
function b8e(t = !1, e) {
  return t && !v8e.includes(e);
}
function x8e(t, e = "", n = !1) {
  const r = Xoe[t], s = r && r[e] || e;
  return "on" + RH(t) + RH(s) + (b8e(n, s) ? "Capture" : "");
}
const w8e = ["gotpointercapture", "lostpointercapture"];
function S8e(t) {
  let e = t.substring(2).toLowerCase();
  const n = !!~e.indexOf("passive");
  n && (e = e.replace("passive", ""));
  const r = w8e.includes(e) ? "capturecapture" : "capture", s = !!~e.indexOf(r);
  return s && (e = e.replace("capture", "")), {
    device: e,
    capture: s,
    passive: n
  };
}
function C8e(t, e = "") {
  const n = Xoe[t], r = n && n[e] || e;
  return t + r;
}
function Zoe(t) {
  return "touches" in t;
}
function _8e(t) {
  return Zoe(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse";
}
function E8e(t) {
  return Array.from(t.touches).filter((e) => {
    var n, r;
    return e.target === t.currentTarget || ((n = t.currentTarget) === null || n === void 0 || (r = n.contains) === null || r === void 0 ? void 0 : r.call(n, e.target));
  });
}
function bj(t, e) {
  try {
    const n = e.clientX - t.clientX, r = e.clientY - t.clientY, s = (e.clientX + t.clientX) / 2, o = (e.clientY + t.clientY) / 2, i = Math.hypot(n, r);
    return {
      angle: -(Math.atan2(n, r) * 180) / Math.PI,
      distance: i,
      origin: [s, o]
    };
  } catch {
  }
  return null;
}
function T8e(t) {
  return E8e(t).map((e) => e.identifier);
}
function $H(t, e) {
  const [n, r] = Array.from(t.touches).filter((s) => e.includes(s.identifier));
  return bj(n, r);
}
const LH = 40, FH = 800;
function Qoe(t) {
  let {
    deltaX: e,
    deltaY: n,
    deltaMode: r
  } = t;
  return r === 1 ? (e *= LH, n *= LH) : r === 2 && (e *= FH, n *= FH), [e, n];
}
function P8e(t) {
  const e = {};
  if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
    const {
      shiftKey: n,
      altKey: r,
      metaKey: s,
      ctrlKey: o
    } = t;
    Object.assign(e, {
      shiftKey: n,
      altKey: r,
      metaKey: s,
      ctrlKey: o
    });
  }
  return e;
}
function HE(t, ...e) {
  return typeof t == "function" ? t(...e) : t;
}
function I8e() {
}
function k8e(...t) {
  return t.length === 0 ? I8e : t.length === 1 ? t[0] : function() {
    let e;
    for (const n of t)
      e = n.apply(this, arguments) || e;
    return e;
  };
}
function BH(t, e) {
  return Object.assign({}, e, t || {});
}
const A8e = 32;
class Joe {
  constructor(e, n, r) {
    this.ctrl = e, this.args = n, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: n,
      ingKey: r,
      args: s
    } = this;
    n[r] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = s, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const n = this.state, r = this.config;
    n._active || (this.reset(), this.computeInitial(), n._active = !0, n.target = e.target, n.currentTarget = e.currentTarget, n.lastOffset = r.from ? HE(r.from, n) : n.offset, n.offset = n.lastOffset, n.startTime = n.timeStamp = e.timeStamp);
  }
  computeValues(e) {
    const n = this.state;
    n._values = e, n.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: n,
      config: r,
      shared: s
    } = this;
    n.args = this.args;
    let o = 0;
    if (e && (n.event = e, r.preventDefault && e.cancelable && n.event.preventDefault(), n.type = e.type, s.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, s.locked = !!document.pointerLockElement, Object.assign(s, P8e(e)), s.down = s.pressed = s.buttons % 2 === 1 || s.touches > 0, o = e.timeStamp - n.timeStamp, n.timeStamp = e.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
      const C = n._delta.map(Math.abs);
      so.addTo(n._distance, C);
    }
    this.axisIntent && this.axisIntent(e);
    const [i, a] = n._movement, [c, l] = r.threshold, {
      _step: d,
      values: u
    } = n;
    if (r.hasCustomTransform ? (d[0] === !1 && (d[0] = Math.abs(i) >= c && u[0]), d[1] === !1 && (d[1] = Math.abs(a) >= l && u[1])) : (d[0] === !1 && (d[0] = Math.abs(i) >= c && Math.sign(i) * c), d[1] === !1 && (d[1] = Math.abs(a) >= l && Math.sign(a) * l)), n.intentional = d[0] !== !1 || d[1] !== !1, !n.intentional) return;
    const f = [0, 0];
    if (r.hasCustomTransform) {
      const [C, _] = u;
      f[0] = d[0] !== !1 ? C - d[0] : 0, f[1] = d[1] !== !1 ? _ - d[1] : 0;
    } else
      f[0] = d[0] !== !1 ? i - d[0] : 0, f[1] = d[1] !== !1 ? a - d[1] : 0;
    this.restrictToAxis && !n._blocked && this.restrictToAxis(f);
    const p = n.offset, g = n._active && !n._blocked || n.active;
    g && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = s[this.ingKey] = n._active, e && (n.first && ("bounds" in r && (n._bounds = HE(r.bounds, n)), this.setup && this.setup()), n.movement = f, this.computeOffset()));
    const [y, m] = n.offset, [[v, b], [x, w]] = n._bounds;
    n.overflow = [y < v ? -1 : y > b ? 1 : 0, m < x ? -1 : m > w ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === !1 ? n._movement[0] : n._movementBound[0] : !1, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === !1 ? n._movement[1] : n._movementBound[1] : !1;
    const S = n._active ? r.rubberband || [0, 0] : [0, 0];
    if (n.offset = g8e(n._bounds, n.offset, S), n.delta = so.sub(n.offset, p), this.computeMovement(), g && (!n.last || o > A8e)) {
      n.delta = so.sub(n.offset, p);
      const C = n.delta.map(Math.abs);
      so.addTo(n.distance, C), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && o > 0 && (n.velocity = [C[0] / o, C[1] / o], n.timeDelta = o);
    }
  }
  emit() {
    const e = this.state, n = this.shared, r = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !r.triggerAllEvents) return;
    const s = this.handler(vr(vr(vr({}, n), e), {}, {
      [this.aliasKey]: e.values
    }));
    s !== void 0 && (e.memo = s);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function M8e([t, e], n) {
  const r = Math.abs(t), s = Math.abs(e);
  if (r > s && r > n)
    return "x";
  if (s > r && s > n)
    return "y";
}
class O8e extends Joe {
  constructor(...e) {
    super(...e), To(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = so.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = so.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const n = this.state, r = this.config;
    if (!n.axis && e) {
      const s = typeof r.axisThreshold == "object" ? r.axisThreshold[_8e(e)] : r.axisThreshold;
      n.axis = M8e(n._movement, s);
    }
    n._blocked = (r.lockDirection || !!r.axis) && !n.axis || !!r.axis && r.axis !== n.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
}
const zH = (t) => t, UH = 0.15, M3 = {
  enabled(t = !0) {
    return t;
  },
  eventOptions(t, e, n) {
    return vr(vr({}, n.shared.eventOptions), t);
  },
  preventDefault(t = !1) {
    return t;
  },
  triggerAllEvents(t = !1) {
    return t;
  },
  rubberband(t = 0) {
    switch (t) {
      case !0:
        return [UH, UH];
      case !1:
        return [0, 0];
      default:
        return so.toVector(t);
    }
  },
  from(t) {
    if (typeof t == "function") return t;
    if (t != null) return so.toVector(t);
  },
  transform(t, e, n) {
    const r = t || n.shared.transform;
    if (this.hasCustomTransform = !!r, process.env.NODE_ENV === "development") {
      const s = r || zH;
      return (o) => {
        const i = s(o);
        return (!isFinite(i[0]) || !isFinite(i[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${i[0]},${[1]}]`), i;
      };
    }
    return r || zH;
  },
  threshold(t) {
    return so.toVector(t, 0);
  }
};
process.env.NODE_ENV === "development" && Object.assign(M3, {
  domTarget(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const D8e = 0, sS = vr(vr({}, M3), {}, {
  axis(t, e, {
    axis: n
  }) {
    if (this.lockDirection = n === "lock", !this.lockDirection) return n;
  },
  axisThreshold(t = D8e) {
    return t;
  },
  bounds(t = {}) {
    if (typeof t == "function")
      return (o) => sS.bounds(t(o));
    if ("current" in t)
      return () => t.current;
    if (typeof HTMLElement == "function" && t instanceof HTMLElement)
      return t;
    const {
      left: e = -1 / 0,
      right: n = 1 / 0,
      top: r = -1 / 0,
      bottom: s = 1 / 0
    } = t;
    return [[e, n], [r, s]];
  }
}), oS = typeof window < "u" && window.document && window.document.createElement;
function eie() {
  return oS && "ontouchstart" in window;
}
function N8e() {
  return eie() || oS && window.navigator.maxTouchPoints > 1;
}
function j8e() {
  return oS && "onpointerdown" in window;
}
function R8e() {
  return oS && "exitPointerLock" in window.document;
}
function $8e() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const qa = {
  isBrowser: oS,
  gesture: $8e(),
  touch: eie(),
  touchscreen: N8e(),
  pointer: j8e(),
  pointerLock: R8e()
}, L8e = 250, F8e = 180, B8e = 0.5, z8e = 50, U8e = 250, H8e = 10, HH = {
  mouse: 0,
  touch: 0,
  pen: 8
}, V8e = vr(vr({}, sS), {}, {
  device(t, e, {
    pointer: {
      touch: n = !1,
      lock: r = !1,
      mouse: s = !1
    } = {}
  }) {
    return this.pointerLock = r && qa.pointerLock, qa.touch && n ? "touch" : this.pointerLock ? "mouse" : qa.pointer && !s ? "pointer" : qa.touch ? "touch" : "mouse";
  },
  preventScrollAxis(t, e, {
    preventScroll: n
  }) {
    if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && t ? L8e : void 0, !(!qa.touchscreen || n === !1))
      return t || (n !== void 0 ? "y" : void 0);
  },
  pointerCapture(t, e, {
    pointer: {
      capture: n = !0,
      buttons: r = 1,
      keys: s = !0
    } = {}
  }) {
    return this.pointerButtons = r, this.keys = s, !this.pointerLock && this.device === "pointer" && n;
  },
  threshold(t, e, {
    filterTaps: n = !1,
    tapsThreshold: r = 3,
    axis: s = void 0
  }) {
    const o = so.toVector(t, n ? r : s ? 1 : 0);
    return this.filterTaps = n, this.tapsThreshold = r, o;
  },
  swipe({
    velocity: t = B8e,
    distance: e = z8e,
    duration: n = U8e
  } = {}) {
    return {
      velocity: this.transform(so.toVector(t)),
      distance: this.transform(so.toVector(e)),
      duration: n
    };
  },
  delay(t = 0) {
    switch (t) {
      case !0:
        return F8e;
      case !1:
        return 0;
      default:
        return t;
    }
  },
  axisThreshold(t) {
    return t ? vr(vr({}, HH), t) : HH;
  },
  keyboardDisplacement(t = H8e) {
    return t;
  }
});
process.env.NODE_ENV === "development" && Object.assign(V8e, {
  useTouch(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
function tie(t) {
  const [e, n] = t.overflow, [r, s] = t._delta, [o, i] = t._direction;
  (e < 0 && r > 0 && o < 0 || e > 0 && r < 0 && o > 0) && (t._movement[0] = t._movementBound[0]), (n < 0 && s > 0 && i < 0 || n > 0 && s < 0 && i > 0) && (t._movement[1] = t._movementBound[1]);
}
const W8e = 30, K8e = 100;
class G8e extends Joe {
  constructor(...e) {
    super(...e), To(this, "ingKey", "pinching"), To(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const e = this.state;
    e._touchIds = [], e.canceled = !1, e.cancel = this.cancel.bind(this), e.turns = 0;
  }
  computeOffset() {
    const {
      type: e,
      movement: n,
      lastOffset: r
    } = this.state;
    e === "wheel" ? this.state.offset = so.add(n, r) : this.state.offset = [(1 + n[0]) * r[0], n[1] + r[1]];
  }
  computeMovement() {
    const {
      offset: e,
      lastOffset: n
    } = this.state;
    this.state.movement = [e[0] / n[0], e[1] - n[1]];
  }
  axisIntent() {
    const e = this.state, [n, r] = e._movement;
    if (!e.axis) {
      const s = Math.abs(n) * W8e - Math.abs(r);
      s < 0 ? e.axis = "angle" : s > 0 && (e.axis = "scale");
    }
  }
  restrictToAxis(e) {
    this.config.lockDirection && (this.state.axis === "scale" ? e[1] = 0 : this.state.axis === "angle" && (e[0] = 0));
  }
  cancel() {
    const e = this.state;
    e.canceled || setTimeout(() => {
      e.canceled = !0, e._active = !1, this.compute(), this.emit();
    }, 0);
  }
  touchStart(e) {
    this.ctrl.setEventIds(e);
    const n = this.state, r = this.ctrl.touchIds;
    if (n._active && n._touchIds.every((o) => r.has(o)) || r.size < 2) return;
    this.start(e), n._touchIds = Array.from(r).slice(0, 2);
    const s = $H(e, n._touchIds);
    s && this.pinchStart(e, s);
  }
  pointerStart(e) {
    if (e.buttons != null && e.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(e), e.target.setPointerCapture(e.pointerId);
    const n = this.state, r = n._pointerEvents, s = this.ctrl.pointerIds;
    if (n._active && Array.from(r.keys()).every((i) => s.has(i)) || (r.size < 2 && r.set(e.pointerId, e), n._pointerEvents.size < 2)) return;
    this.start(e);
    const o = bj(...Array.from(r.values()));
    o && this.pinchStart(e, o);
  }
  pinchStart(e, n) {
    const r = this.state;
    r.origin = n.origin, this.computeValues([n.distance, n.angle]), this.computeInitial(), this.compute(e), this.emit();
  }
  touchMove(e) {
    if (!this.state._active) return;
    const n = $H(e, this.state._touchIds);
    n && this.pinchMove(e, n);
  }
  pointerMove(e) {
    const n = this.state._pointerEvents;
    if (n.has(e.pointerId) && n.set(e.pointerId, e), !this.state._active) return;
    const r = bj(...Array.from(n.values()));
    r && this.pinchMove(e, r);
  }
  pinchMove(e, n) {
    const r = this.state, s = r._values[1], o = n.angle - s;
    let i = 0;
    Math.abs(o) > 270 && (i += Math.sign(o)), this.computeValues([n.distance, n.angle - 360 * i]), r.origin = n.origin, r.turns = i, r._movement = [r._values[0] / r._initial[0] - 1, r._values[1] - r._initial[1]], this.compute(e), this.emit();
  }
  touchEnd(e) {
    this.ctrl.setEventIds(e), this.state._active && this.state._touchIds.some((n) => !this.ctrl.touchIds.has(n)) && (this.state._active = !1, this.compute(e), this.emit());
  }
  pointerEnd(e) {
    const n = this.state;
    this.ctrl.setEventIds(e);
    try {
      e.target.releasePointerCapture(e.pointerId);
    } catch {
    }
    n._pointerEvents.has(e.pointerId) && n._pointerEvents.delete(e.pointerId), n._active && n._pointerEvents.size < 2 && (n._active = !1, this.compute(e), this.emit());
  }
  gestureStart(e) {
    e.cancelable && e.preventDefault();
    const n = this.state;
    n._active || (this.start(e), this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY], this.compute(e), this.emit());
  }
  gestureMove(e) {
    if (e.cancelable && e.preventDefault(), !this.state._active) return;
    const n = this.state;
    this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY];
    const r = n._movement;
    n._movement = [e.scale - 1, e.rotation], n._delta = so.sub(n._movement, r), this.compute(e), this.emit();
  }
  gestureEnd(e) {
    this.state._active && (this.state._active = !1, this.compute(e), this.emit());
  }
  wheel(e) {
    const n = this.config.modifierKey;
    n && (Array.isArray(n) ? !n.find((r) => e[r]) : !e[n]) || (this.state._active ? this.wheelChange(e) : this.wheelStart(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)));
  }
  wheelStart(e) {
    this.start(e), this.wheelChange(e);
  }
  wheelChange(e) {
    "uv" in e || (e.cancelable && e.preventDefault(), process.env.NODE_ENV === "development" && !e.defaultPrevented && console.warn("[@use-gesture]: To properly support zoom on trackpads, try using the `target` option.\n\nThis message will only appear in development mode."));
    const r = this.state;
    r._delta = [-Qoe(e)[1] / K8e * r.offset[0], 0], so.addTo(r._movement, r._delta), tie(r), this.state.origin = [e.clientX, e.clientY], this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    const n = this.config.device;
    n && (e(n, "start", this[n + "Start"].bind(this)), e(n, "change", this[n + "Move"].bind(this)), e(n, "end", this[n + "End"].bind(this)), e(n, "cancel", this[n + "End"].bind(this)), e("lostPointerCapture", "", this[n + "End"].bind(this))), this.config.pinchOnWheel && e("wheel", "", this.wheel.bind(this), {
      passive: !1
    });
  }
}
const Y8e = vr(vr({}, M3), {}, {
  device(t, e, {
    shared: n,
    pointer: {
      touch: r = !1
    } = {}
  }) {
    if (n.target && !qa.touch && qa.gesture) return "gesture";
    if (qa.touch && r) return "touch";
    if (qa.touchscreen) {
      if (qa.pointer) return "pointer";
      if (qa.touch) return "touch";
    }
  },
  bounds(t, e, {
    scaleBounds: n = {},
    angleBounds: r = {}
  }) {
    const s = (i) => {
      const a = BH(HE(n, i), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [a.min, a.max];
    }, o = (i) => {
      const a = BH(HE(r, i), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [a.min, a.max];
    };
    return typeof n != "function" && typeof r != "function" ? [s(), o()] : (i) => [s(i), o(i)];
  },
  threshold(t, e, n) {
    return this.lockDirection = n.axis === "lock", so.toVector(t, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(t) {
    return t === void 0 ? "ctrlKey" : t;
  },
  pinchOnWheel(t = !0) {
    return t;
  }
});
vr(vr({}, sS), {}, {
  mouseOnly: (t = !0) => t
});
class q8e extends O8e {
  constructor(...e) {
    super(...e), To(this, "ingKey", "wheeling");
  }
  wheel(e) {
    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(e) {
    const n = this.state;
    n._delta = Qoe(e), so.addTo(n._movement, n._delta), tie(n), this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    e("wheel", "", this.wheel.bind(this));
  }
}
const X8e = sS;
vr(vr({}, sS), {}, {
  mouseOnly: (t = !0) => t
});
const O3 = /* @__PURE__ */ new Map(), xj = /* @__PURE__ */ new Map();
function Z8e(t) {
  O3.set(t.key, t.engine), xj.set(t.key, t.resolver);
}
const Q8e = {
  key: "pinch",
  engine: G8e,
  resolver: Y8e
}, J8e = {
  key: "wheel",
  engine: q8e,
  resolver: X8e
};
function eHe(t, e) {
  if (t == null) return {};
  var n = {}, r = Object.keys(t), s, o;
  for (o = 0; o < r.length; o++)
    s = r[o], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
function tHe(t, e) {
  if (t == null) return {};
  var n = eHe(t, e), r, s;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    for (s = 0; s < o.length; s++)
      r = o[s], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
const nHe = {
  target(t) {
    if (t)
      return () => "current" in t ? t.current : t;
  },
  enabled(t = !0) {
    return t;
  },
  window(t = qa.isBrowser ? window : void 0) {
    return t;
  },
  eventOptions({
    passive: t = !0,
    capture: e = !1
  } = {}) {
    return {
      passive: t,
      capture: e
    };
  },
  transform(t) {
    return t;
  }
}, rHe = ["target", "eventOptions", "window", "enabled", "transform"];
function s_(t = {}, e) {
  const n = {};
  for (const [r, s] of Object.entries(e))
    switch (typeof s) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const o = s.call(n, t[r], r, t);
          Number.isNaN(o) || (n[r] = o);
        } else
          n[r] = s.call(n, t[r], r, t);
        break;
      case "object":
        n[r] = s_(t[r], s);
        break;
      case "boolean":
        s && (n[r] = t[r]);
        break;
    }
  return n;
}
function sHe(t, e, n = {}) {
  const r = t, {
    target: s,
    eventOptions: o,
    window: i,
    enabled: a,
    transform: c
  } = r, l = tHe(r, rHe);
  if (n.shared = s_({
    target: s,
    eventOptions: o,
    window: i,
    enabled: a,
    transform: c
  }, nHe), e) {
    const d = xj.get(e);
    n[e] = s_(vr({
      shared: n.shared
    }, l), d);
  } else
    for (const d in l) {
      const u = xj.get(d);
      if (u)
        n[d] = s_(vr({
          shared: n.shared
        }, l[d]), u);
      else if (process.env.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(d)) {
        if (d === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${d}\` was used. Please read the documentation for further information.`);
      }
    }
  return n;
}
class nie {
  constructor(e, n) {
    To(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = n;
  }
  add(e, n, r, s, o) {
    const i = this._listeners, a = C8e(n, r), c = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, l = vr(vr({}, c), o);
    e.addEventListener(a, s, l);
    const d = () => {
      e.removeEventListener(a, s, l), i.delete(d);
    };
    return i.add(d), d;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
}
class oHe {
  constructor() {
    To(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, n, r = 140, ...s) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(n, r, ...s));
  }
  remove(e) {
    const n = this._timeouts.get(e);
    n && window.clearTimeout(n);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
}
let iHe = class {
  constructor(e) {
    To(this, "gestures", /* @__PURE__ */ new Set()), To(this, "_targetEventStore", new nie(this)), To(this, "gestureEventStores", {}), To(this, "gestureTimeoutStores", {}), To(this, "handlers", {}), To(this, "config", {}), To(this, "pointerIds", /* @__PURE__ */ new Set()), To(this, "touchIds", /* @__PURE__ */ new Set()), To(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), aHe(this, e);
  }
  setEventIds(e) {
    if (Zoe(e))
      return this.touchIds = new Set(T8e(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, n) {
    this.handlers = e, this.nativeHandlers = n;
  }
  applyConfig(e, n) {
    this.config = sHe(e, n, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const n = this.config.shared, r = {};
    let s;
    if (!(n.target && (s = n.target(), !s))) {
      if (n.enabled) {
        for (const i of this.gestures) {
          const a = this.config[i], c = VH(r, a.eventOptions, !!s);
          if (a.enabled) {
            const l = O3.get(i);
            new l(this, e, i).bind(c);
          }
        }
        const o = VH(r, n.eventOptions, !!s);
        for (const i in this.nativeHandlers)
          o(i, "", (a) => this.nativeHandlers[i](vr(vr({}, this.state.shared), {}, {
            event: a,
            args: e
          })), void 0, !0);
      }
      for (const o in r)
        r[o] = k8e(...r[o]);
      if (!s) return r;
      for (const o in r) {
        const {
          device: i,
          capture: a,
          passive: c
        } = S8e(o);
        this._targetEventStore.add(s, i, "", r[o], {
          capture: a,
          passive: c
        });
      }
    }
  }
};
function Rg(t, e) {
  t.gestures.add(e), t.gestureEventStores[e] = new nie(t, e), t.gestureTimeoutStores[e] = new oHe();
}
function aHe(t, e) {
  e.drag && Rg(t, "drag"), e.wheel && Rg(t, "wheel"), e.scroll && Rg(t, "scroll"), e.move && Rg(t, "move"), e.pinch && Rg(t, "pinch"), e.hover && Rg(t, "hover");
}
const VH = (t, e, n) => (r, s, o, i = {}, a = !1) => {
  var c, l;
  const d = (c = i.capture) !== null && c !== void 0 ? c : e.capture, u = (l = i.passive) !== null && l !== void 0 ? l : e.passive;
  let f = a ? r : x8e(r, s, d);
  n && u && (f += "Passive"), t[f] = t[f] || [], t[f].push(o);
}, cHe = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function lHe(t) {
  const e = {}, n = {}, r = /* @__PURE__ */ new Set();
  for (let s in t)
    cHe.test(s) ? (r.add(RegExp.lastMatch), n[s] = t[s]) : e[s] = t[s];
  return [n, e, r];
}
function $g(t, e, n, r, s, o) {
  if (!t.has(n)) return;
  if (!O3.has(r)) {
    process.env.NODE_ENV === "development" && console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${r}\` gesture but isn't properly configured.

Please add \`${r}Action\` when creating your handler.`);
    return;
  }
  const i = n + "Start", a = n + "End", c = (l) => {
    let d;
    return l.first && i in e && e[i](l), n in e && (d = e[n](l)), l.last && a in e && e[a](l), d;
  };
  s[r] = c, o[r] = o[r] || {};
}
function dHe(t, e) {
  const [n, r, s] = lHe(t), o = {};
  return $g(s, n, "onDrag", "drag", o, e), $g(s, n, "onWheel", "wheel", o, e), $g(s, n, "onScroll", "scroll", o, e), $g(s, n, "onPinch", "pinch", o, e), $g(s, n, "onMove", "move", o, e), $g(s, n, "onHover", "hover", o, e), {
    handlers: o,
    config: e,
    nativeHandlers: r
  };
}
function uHe(t, e = {}, n, r) {
  const s = B.useMemo(() => new iHe(t), []);
  if (s.applyHandlers(t, r), s.applyConfig(e, n), B.useEffect(s.effect.bind(s)), B.useEffect(() => s.clean.bind(s), []), e.target === void 0)
    return s.bind.bind(s);
}
function fHe(t) {
  return t.forEach(Z8e), function(n, r) {
    const {
      handlers: s,
      nativeHandlers: o,
      config: i
    } = dHe(n, r || {});
    return uHe(s, i, void 0, o);
  };
}
const WH = 10, hHe = /Mac|iPod|iPhone|iPad/.test(
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  typeof window > "u" ? "node" : window.navigator.platform
);
function rie(t) {
  let { deltaY: e, deltaX: n } = t, r = 0;
  return t.ctrlKey || t.altKey || t.metaKey ? r = (Math.abs(e) > WH ? WH * Math.sign(e) : e) / 100 : t.shiftKey && !hHe && (n = e, e = 0), { x: -n, y: -e, z: -r };
}
const pHe = fHe([J8e, Q8e]);
let Lg;
const gHe = (t) => Lg === void 0 ? (Lg = t, !1) : t - Lg > 120 && t - Lg < 160 ? (Lg = t, !0) : (Lg = t, !1);
function mHe(t) {
  const e = ie(), n = T.useMemo(() => {
    let r = "not sure";
    const s = ({ event: g }) => {
      if (!e.getInstanceState().isFocused || (r = "not sure", gHe(Date.now())))
        return;
      const y = e.getEditingShapeId();
      if (y) {
        const b = e.getShape(y);
        if (b && e.getShapeUtil(b).canScroll(b)) {
          const w = e.getShapePageBounds(y);
          if (w != null && w.containsPoint(e.inputs.currentPagePoint))
            return;
        }
      }
      xt(g), cr(g);
      const m = rie(g);
      if (m.x === 0 && m.y === 0) return;
      const v = {
        type: "wheel",
        name: "wheel",
        delta: m,
        point: new I(g.clientX, g.clientY),
        shiftKey: g.shiftKey,
        altKey: g.altKey,
        ctrlKey: g.metaKey || g.ctrlKey,
        metaKey: g.metaKey,
        accelKey: ms(g)
      };
      e.dispatch(v);
    };
    let o = 1, i = 1, a = 0;
    const c = new I(), l = new I(), d = (g) => {
      const y = t.current;
      r = "not sure";
      const { event: m, origin: v, da: b } = g;
      m instanceof WheelEvent || (m.target === y || y != null && y.contains(m.target)) && (l.x = v[0], l.y = v[1], c.x = v[0], c.y = v[1], o = b[0], i = e.getZoomLevel(), e.dispatch({
        type: "pinch",
        name: "pinch_start",
        point: { x: v[0], y: v[1], z: e.getZoomLevel() },
        delta: { x: 0, y: 0 },
        shiftKey: m.shiftKey,
        altKey: m.altKey,
        ctrlKey: m.metaKey || m.ctrlKey,
        metaKey: m.metaKey,
        accelKey: ms(m)
      }));
    }, u = (g) => {
      if (g && (r = "zooming"), r === "zooming")
        return;
      const y = Math.abs(a - o), m = I.Dist(c, l);
      switch (r) {
        case "not sure": {
          y > 24 ? r = "zooming" : m > 16 && (r = "panning");
          break;
        }
        case "panning": {
          y > 64 && (r = "zooming");
          break;
        }
      }
    };
    return {
      onWheel: s,
      onPinchStart: d,
      onPinchEnd: (g) => {
        const y = t.current, { event: m, origin: v, offset: b } = g;
        if (m instanceof WheelEvent || !(m.target === y || y != null && y.contains(m.target))) return;
        const x = b[0] ** e.getCameraOptions().zoomSpeed;
        r = "not sure", e.timers.requestAnimationFrame(() => {
          e.dispatch({
            type: "pinch",
            name: "pinch_end",
            point: { x: v[0], y: v[1], z: x },
            delta: { x: v[0], y: v[1] },
            shiftKey: m.shiftKey,
            altKey: m.altKey,
            ctrlKey: m.metaKey || m.ctrlKey,
            metaKey: m.metaKey,
            accelKey: ms(m)
          });
        });
      },
      onPinch: (g) => {
        const y = t.current, { event: m, origin: v, offset: b, da: x } = g;
        if (m instanceof WheelEvent || !(m.target === y || y != null && y.contains(m.target))) return;
        const w = g.type === "gesturechange" || g.type === "gestureend";
        a = x[0];
        const S = v[0] - l.x, C = v[1] - l.y;
        switch (l.x = v[0], l.y = v[1], u(w), r) {
          case "zooming": {
            const _ = b[0] ** e.getCameraOptions().zoomSpeed;
            e.dispatch({
              type: "pinch",
              name: "pinch",
              point: { x: v[0], y: v[1], z: _ },
              delta: { x: S, y: C },
              shiftKey: m.shiftKey,
              altKey: m.altKey,
              ctrlKey: m.metaKey || m.ctrlKey,
              metaKey: m.metaKey,
              accelKey: ms(m)
            });
            break;
          }
          case "panning": {
            e.dispatch({
              type: "pinch",
              name: "pinch",
              point: { x: v[0], y: v[1], z: i },
              delta: { x: S, y: C },
              shiftKey: m.shiftKey,
              altKey: m.altKey,
              ctrlKey: m.metaKey || m.ctrlKey,
              metaKey: m.metaKey,
              accelKey: ms(m)
            });
            break;
          }
        }
      }
    };
  }, [e, t]);
  pHe(n, {
    target: t,
    eventOptions: { passive: !1 },
    pinch: {
      from: () => {
        const { zoomSpeed: r } = e.getCameraOptions();
        return [e.getZoomLevel() ** (1 / r), 0];
      },
      // Return the camera z to use when pinch starts
      scaleBounds: () => {
        const r = e.getBaseZoom(), { zoomSteps: s, zoomSpeed: o } = e.getCameraOptions(), i = s[0] * r;
        return {
          max: (s[s.length - 1] * r) ** (1 / o),
          min: i ** (1 / o)
        };
      }
    }
  });
}
function pO(t, e, n) {
  const r = t.getShape(e), s = t.getShapeHandles(r);
  return { shape: r, handle: s.find((o) => o.id === n) };
}
function yHe(t, e) {
  const n = ie();
  return T.useMemo(() => {
    const r = (c) => {
      if (c.isKilled) return;
      const l = LE(c.currentTarget);
      q0(l, c);
      const { shape: d, handle: u } = pO(n, t, e);
      u && n.dispatch({
        type: "pointer",
        target: "handle",
        handle: u,
        shape: d,
        name: "pointer_down",
        ...la(c)
      });
    };
    let s, o;
    return {
      onPointerDown: r,
      onPointerMove: (c) => {
        if (c.isKilled || c.clientX === s && c.clientY === o) return;
        s = c.clientX, o = c.clientY;
        const { shape: l, handle: d } = pO(n, t, e);
        d && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: d,
          shape: l,
          name: "pointer_move",
          ...la(c)
        });
      },
      onPointerUp: (c) => {
        if (c.isKilled) return;
        const l = LE(c.currentTarget);
        X0(l, c);
        const { shape: d, handle: u } = pO(n, t, e);
        u && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: u,
          shape: d,
          name: "pointer_up",
          ...la(c)
        });
      }
    };
  }, [n, t, e]);
}
function vHe(t) {
  const e = ie();
  un(() => {
    const n = bJ(
      () => {
        t.current && e.updateViewportScreenBounds(t.current);
      },
      200,
      {
        trailing: !0
      }
    ), r = e.timers.setInterval(n, 1e3);
    window.addEventListener("resize", n);
    const s = new ResizeObserver((a) => {
      a[0].contentRect && n();
    }), o = t.current;
    let i = null;
    return o && (s.observe(o), i = bHe(o), i.addEventListener("scroll", n)), () => {
      clearInterval(r), window.removeEventListener("resize", n), s.disconnect(), i == null || i.removeEventListener("scroll", n), n.cancel();
    };
  }, [e, t]);
}
/*!
 * Author: excalidraw
 * MIT License: https://github.com/excalidraw/excalidraw/blob/master/LICENSE
 * https://github.com/excalidraw/excalidraw/blob/48c3465b19f10ec755b3eb84e21a01a468e96e43/packages/excalidraw/utils.ts#L600
 */
const bHe = (t) => {
  let e = t.parentElement;
  for (; e; ) {
    if (e === document.body)
      return document;
    const { overflowY: n } = window.getComputedStyle(e);
    if (e.scrollHeight > e.clientHeight && (n === "auto" || n === "scroll" || n === "overlay"))
      return e;
    e = e.parentElement;
  }
  return document;
};
function sie(t, e) {
  return e === 0 ? t : sie(e, t % e);
}
function oie(t) {
  const e = t.toString().split(".")[1];
  if (!e) return 1;
  const n = Math.pow(10, e.length), r = parseInt(e, 10);
  return n / sie(r, n);
}
function xHe(t = !0) {
  const [e, n] = he(0), r = ie();
  me(() => {
    if (!t) return;
    const s = () => n((o) => o + 1);
    return r.on("tick", s), () => {
      r.off("tick", s);
    };
  }, [r, t]);
}
const wHe = Kr(function({
  showStroke: e = !0,
  showVertices: n = !0,
  showClosestPointOnOutline: r = !0
}) {
  const s = ie();
  xHe(r);
  const o = s.getZoomLevel(), i = s.getRenderingShapes(), {
    inputs: { currentPagePoint: a }
  } = s;
  return /* @__PURE__ */ h.jsx(
    "svg",
    {
      style: {
        position: "absolute",
        pointerEvents: "none",
        zIndex: 999999999,
        top: 0,
        left: 0,
        overflow: "visible"
      },
      children: i.map((c) => {
        const l = s.getShape(c.id);
        if (l.type === "group") return null;
        const d = s.getShapeGeometry(l), u = s.getShapePageTransform(l), f = s.getPointInShapeSpace(l, a), p = d.nearestPoint(f), g = d.distanceToPoint(f, !0), y = Math.abs(g) * o, m = g < 0, { vertices: v } = d;
        return /* @__PURE__ */ h.jsxs(
          "g",
          {
            transform: u.toCssString(),
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              e && /* @__PURE__ */ h.jsx(
                "g",
                {
                  stroke: d.debugColor ?? "red",
                  opacity: "1",
                  strokeWidth: 2 / o,
                  fill: "none",
                  children: /* @__PURE__ */ h.jsx(iie, { geometry: d })
                }
              ),
              n && v.map((b, x) => /* @__PURE__ */ h.jsx(
                "circle",
                {
                  cx: b.x,
                  cy: b.y,
                  r: 2 / o,
                  fill: `hsl(${ql(x, [0, v.length - 1], [120, 200])}, 100%, 50%)`,
                  stroke: "black",
                  strokeWidth: 1 / o
                },
                `v${x}`
              )),
              r && y < 150 && /* @__PURE__ */ h.jsx(
                "line",
                {
                  x1: p.x,
                  y1: p.y,
                  x2: f.x,
                  y2: f.y,
                  opacity: 1 - y / 150,
                  stroke: m ? "goldenrod" : "dodgerblue",
                  strokeWidth: 2 / o
                }
              )
            ]
          },
          c.id + "_outline"
        );
      })
    }
  );
});
function iie({ geometry: t }) {
  return t instanceof ui ? /* @__PURE__ */ h.jsx("g", { stroke: t.debugColor, children: [...t.children, ...t.ignoredChildren].map((e, n) => /* @__PURE__ */ h.jsx(iie, { geometry: e }, n)) }) : /* @__PURE__ */ h.jsx("path", { d: t.toSimpleSvgPath(), stroke: t.debugColor });
}
function aie(t) {
  return I2e(t);
}
function cie() {
  const t = ie(), e = R3e(
    "userIds",
    () => aie(t.getCollaborators().map((n) => n.userId)).sort(),
    { isEqual: (n, r) => {
      var s;
      return n.join(",") === ((s = r.join) == null ? void 0 : s.call(r, ","));
    } },
    [t]
  );
  return le(e);
}
function qI(t) {
  const e = ie();
  return le(
    `latestPresence:${t}`,
    () => e.getCollaborators().find((r) => r.userId === t),
    [e, t]
  ) ?? null;
}
const SHe = Kr(function() {
  return cie().map((n) => /* @__PURE__ */ h.jsx(CHe, { collaboratorId: n }, n));
}), CHe = Kr(function({
  collaboratorId: e
}) {
  const n = ie(), r = qI(e), s = EHe(n, r);
  if (!(r && r.currentPageId === n.getCurrentPageId()))
    return null;
  switch (s) {
    case "inactive": {
      const { followingUserId: o, highlightedUserIds: i } = n.getInstanceState();
      if (!(o === r.userId || i.includes(r.userId)))
        return null;
      break;
    }
    case "idle": {
      const { highlightedUserIds: o } = n.getInstanceState();
      if (r.followingUserId === n.user.getId() && !(r.chatMessage || o.includes(r.userId)))
        return null;
      break;
    }
  }
  return /* @__PURE__ */ h.jsx(_He, { latestPresence: r });
}), _He = Kr(function({
  latestPresence: e
}) {
  const n = ie(), {
    CollaboratorBrush: r,
    CollaboratorScribble: s,
    CollaboratorCursor: o,
    CollaboratorHint: i,
    CollaboratorShapeIndicator: a
  } = Ln(), c = n.getZoomLevel(), l = n.getViewportPageBounds(), { userId: d, chatMessage: u, brush: f, scribbles: p, selectedShapeIds: g, userName: y, cursor: m, color: v } = e;
  if (!m) return null;
  const b = !(m.x < l.minX - 12 / c || m.y < l.minY - 16 / c || m.x > l.maxX - 12 / c || m.y > l.maxY - 16 / c);
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    f && r ? /* @__PURE__ */ h.jsx(
      r,
      {
        className: "tl-collaborator__brush",
        userId: d,
        brush: f,
        color: v,
        opacity: 0.1
      },
      d + "_brush"
    ) : null,
    b && o ? /* @__PURE__ */ h.jsx(
      o,
      {
        className: "tl-collaborator__cursor",
        userId: d,
        point: m,
        color: v,
        zoom: c,
        name: y !== "New User" ? y : null,
        chatMessage: u ?? ""
      },
      d + "_cursor"
    ) : i ? /* @__PURE__ */ h.jsx(
      i,
      {
        className: "tl-collaborator__cursor-hint",
        userId: d,
        point: m,
        color: v,
        zoom: c,
        viewport: l
      },
      d + "_cursor_hint"
    ) : null,
    s && p.length ? /* @__PURE__ */ h.jsx(h.Fragment, { children: p.map((x) => /* @__PURE__ */ h.jsx(
      s,
      {
        className: "tl-collaborator__scribble",
        userId: d,
        scribble: x,
        color: v,
        zoom: c,
        opacity: x.color === "laser" ? 0.5 : 0.1
      },
      d + "_scribble_" + x.id
    )) }) : null,
    a && g.filter((x) => !n.isShapeHidden(x)).map((x) => /* @__PURE__ */ h.jsx(
      a,
      {
        className: "tl-collaborator__shape-indicator",
        userId: d,
        shapeId: x,
        color: v,
        opacity: 0.5
      },
      d + "_" + x
    ))
  ] });
});
function KH(t, e) {
  return e > t.options.collaboratorInactiveTimeoutMs ? "inactive" : e > t.options.collaboratorIdleTimeoutMs ? "idle" : "active";
}
function EHe(t, e) {
  const n = fe((e == null ? void 0 : e.lastActivityTimestamp) ?? -1), [r, s] = he(
    () => KH(t, Date.now() - n.current)
  );
  return me(() => {
    const o = t.timers.setInterval(() => {
      s(KH(t, Date.now() - n.current));
    }, t.options.collaboratorCheckIntervalMs);
    return () => clearInterval(o);
  }, [t]), e && (n.current = e.lastActivityTimestamp ?? 1 / 0), r;
}
function THe() {
  const t = ie(), e = le("is menu open", () => t.menus.hasAnyOpenMenus(), [t]), [n, r] = he(!1), s = e || n, o = g3(), i = fe({
    isDown: !1,
    isDragging: !1,
    start: new I()
  }), a = re(
    (d) => {
      d.button === 0 && (r(!0), i.current = {
        isDown: !0,
        isDragging: !1,
        start: new I(d.clientX, d.clientY)
      }), t.menus.clearOpenMenus();
    },
    [t]
  ), c = re(
    (d) => {
      var u, f, p;
      if (i.current.isDown) {
        if (i.current.isDragging) {
          (u = o.onPointerMove) == null || u.call(o, d);
          return;
        }
        if (
          // We're pointing, but are we dragging?
          I.Dist2(i.current.start, new I(d.clientX, d.clientY)) > t.options.dragDistanceSquared
        ) {
          i.current = {
            ...i.current,
            isDown: !0,
            isDragging: !0
          };
          const { x: g, y } = i.current.start;
          (f = o.onPointerDown) == null || f.call(o, {
            ...d,
            clientX: g,
            clientY: y,
            button: 0
          }), (p = o.onPointerMove) == null || p.call(o, d);
        }
      }
    },
    [o, t]
  ), l = re(
    (d) => {
      var u;
      (u = o.onPointerUp) == null || u.call(o, d), r(!1), i.current = {
        isDown: !1,
        isDragging: !1,
        start: new I(d.clientX, d.clientY)
      };
    },
    [o]
  );
  return s && /* @__PURE__ */ h.jsx(
    "div",
    {
      className: "tlui-menu-click-capture",
      "data-testid": "menu-click-capture.content",
      ...o,
      onPointerDown: a,
      onPointerMove: c,
      onPointerUp: l
    }
  );
}
function PHe({ className: t }) {
  const e = ie(), { SelectionBackground: n, Background: r, SvgDefs: s, ShapeIndicators: o } = Ln(), i = fe(null), a = fe(null), c = fe(null), l = Gr();
  vHe(i), K4e(), W4e(), mHe(i), h8e(i);
  const d = fe({ lodDisableTextOutline: !1, allowTextOutline: !0 });
  Ep(
    "position layers",
    function() {
      const { x, y: w, z: S } = e.getCamera();
      if (d.current.allowTextOutline && dn.isSafari && (l.style.setProperty("--tl-text-outline", "none"), d.current.allowTextOutline = !1), d.current.allowTextOutline && S < e.options.textShadowLod !== d.current.lodDisableTextOutline) {
        const E = S < e.options.textShadowLod;
        l.style.setProperty(
          "--tl-text-outline",
          E ? "none" : "var(--tl-text-outline-reference)"
        ), d.current.lodDisableTextOutline = E;
      }
      const C = S >= 1 ? ql(S, [1, 8], [0.125, 0.5], !0) : ql(S, [0.1, 1], [-2, 0.125], !0), _ = `scale(${ne(S)}) translate(${ne(
        x + C
      )}px,${ne(w + C)}px)`;
      So(a.current, "transform", _), So(c.current, "transform", _);
    },
    [e, l]
  );
  const u = g3(), f = le(
    "shapeSvgDefs",
    () => {
      const b = /* @__PURE__ */ new Map();
      for (const x of Er(e.shapeUtils)) {
        if (!x) return;
        const w = x.getCanvasSvgDefs();
        for (const { key: S, component: C } of w)
          b.has(S) || b.set(S, /* @__PURE__ */ h.jsx(C, {}, S));
      }
      return [...b.values()];
    },
    [e]
  ), p = le("debug_shapes", () => ir.hideShapes.get(), [ir]), g = le("debug_svg", () => ir.debugSvg.get(), [ir]), y = le("debug_geometry", () => ir.debugGeometry.get(), [
    ir
  ]), m = le(
    "isEditingAnything",
    () => e.getEditingShapeId() !== null,
    [e]
  ), v = le(
    "isSelectingAnything",
    () => !!e.getSelectedShapeIds().length,
    [e]
  );
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs(
      "div",
      {
        ref: i,
        draggable: !1,
        "data-iseditinganything": m,
        "data-isselectinganything": v,
        className: Je("tl-canvas", t),
        "data-testid": "canvas",
        ...u,
        children: [
          /* @__PURE__ */ h.jsx("svg", { className: "tl-svg-context", "aria-hidden": "true", children: /* @__PURE__ */ h.jsxs("defs", { children: [
            f,
            /* @__PURE__ */ h.jsx(UHe, {}),
            /* @__PURE__ */ h.jsx(HHe, {}),
            s && /* @__PURE__ */ h.jsx(s, {})
          ] }) }),
          r && /* @__PURE__ */ h.jsx("div", { className: "tl-background__wrapper", children: /* @__PURE__ */ h.jsx(r, {}) }),
          /* @__PURE__ */ h.jsx(kHe, {}),
          /* @__PURE__ */ h.jsxs("div", { ref: a, className: "tl-html-layer tl-shapes", draggable: !1, children: [
            /* @__PURE__ */ h.jsx(GHe, {}),
            n && /* @__PURE__ */ h.jsx(KHe, {}),
            p ? null : g ? /* @__PURE__ */ h.jsx(LHe, {}) : /* @__PURE__ */ h.jsx(BHe, {})
          ] }),
          /* @__PURE__ */ h.jsx("div", { className: "tl-overlays", children: /* @__PURE__ */ h.jsxs("div", { ref: c, className: "tl-html-layer", children: [
            y ? /* @__PURE__ */ h.jsx(wHe, {}) : null,
            /* @__PURE__ */ h.jsx(MHe, {}),
            /* @__PURE__ */ h.jsx(AHe, {}),
            /* @__PURE__ */ h.jsx(OHe, {}),
            o && /* @__PURE__ */ h.jsx(o, {}),
            /* @__PURE__ */ h.jsx(zHe, {}),
            /* @__PURE__ */ h.jsx(DHe, {}),
            /* @__PURE__ */ h.jsx(WHe, {}),
            /* @__PURE__ */ h.jsx(NHe, {}),
            /* @__PURE__ */ h.jsx($He, {}),
            /* @__PURE__ */ h.jsx(SHe, {})
          ] }) }),
          /* @__PURE__ */ h.jsx(YHe, {})
        ]
      }
    ),
    /* @__PURE__ */ h.jsx(THe, {}),
    /* @__PURE__ */ h.jsx(IHe, {})
  ] });
}
function IHe() {
  const { InFrontOfTheCanvas: t } = Ln();
  return t ? /* @__PURE__ */ h.jsx(t, {}) : null;
}
function kHe() {
  const t = ie(), e = le("gridSize", () => t.getDocumentSettings().gridSize, [t]), { x: n, y: r, z: s } = le("camera", () => t.getCamera(), [t]), o = le("isGridMode", () => t.getInstanceState().isGridMode, [t]), { Grid: i } = Ln();
  return i && o ? /* @__PURE__ */ h.jsx(i, { x: n, y: r, z: s, size: e }) : null;
}
function AHe() {
  const t = ie(), e = le("scribbles", () => t.getInstanceState().scribbles, [t]), n = le("zoomLevel", () => t.getZoomLevel(), [t]), { Scribble: r } = Ln();
  return r && e.length ? e.map((s) => /* @__PURE__ */ h.jsx(r, { className: "tl-user-scribble", scribble: s, zoom: n }, s.id)) : null;
}
function MHe() {
  const t = ie(), e = le("brush", () => t.getInstanceState().brush, [t]), { Brush: n } = Ln();
  return n && e ? /* @__PURE__ */ h.jsx(n, { className: "tl-user-brush", brush: e }) : null;
}
function OHe() {
  const t = ie(), e = le("zoomBrush", () => t.getInstanceState().zoomBrush, [t]), { ZoomBrush: n } = Ln();
  return n && e ? /* @__PURE__ */ h.jsx(n, { className: "tl-user-brush tl-zoom-brush", brush: e }) : null;
}
function DHe() {
  const t = ie(), e = le("snapLines", () => t.snaps.getIndicators(), [t]), n = le("zoomLevel", () => t.getZoomLevel(), [t]), { SnapIndicator: r } = Ln();
  return r && e.length > 0 ? e.map((s) => /* @__PURE__ */ h.jsx(r, { className: "tl-user-snapline", line: s, zoom: n }, s.id)) : null;
}
function NHe() {
  const t = ie(), e = le(
    "handles shapeIdWithHandles",
    () => {
      const { isReadonly: n, isChangingStyle: r } = t.getInstanceState();
      if (n || r) return !1;
      const s = t.getOnlySelectedShape();
      return !s || !t.getShapeHandles(s) ? !1 : s.id;
    },
    [t]
  );
  return e ? /* @__PURE__ */ h.jsx(jHe, { shapeId: e }) : null;
}
function jHe({ shapeId: t }) {
  const e = ie(), { Handles: n } = Ln(), r = le("zoomLevel", () => e.getZoomLevel(), [e]), s = le("coarse pointer", () => e.getInstanceState().isCoarsePointer, [
    e
  ]), o = le("handles transform", () => e.getShapePageTransform(t), [
    e,
    t
  ]), i = le(
    "handles",
    () => {
      const c = e.getShapeHandles(t);
      if (!c) return null;
      const l = (s ? e.options.coarseHandleRadius : e.options.handleRadius) / r * 2;
      return c.filter(
        (d) => (
          // if the handle isn't a virtual handle, we'll display it
          // but for virtual handles, we'll only display them if they're far enough away from vertex handles
          d.type !== "virtual" || !c.some(
            (u) => (
              // skip the handle we're checking against
              // and check that their distance isn't below the minimum distance
              u !== d && // only check against vertex handles
              u.type === "vertex" && I.Dist(d, u) < l
            )
          )
        )
      ).sort((d) => d.type === "vertex" ? 1 : -1);
    },
    [e, r, s, t]
  ), a = le("isHidden", () => e.isShapeHidden(t), [e, t]);
  return !n || !i || !o || a ? null : /* @__PURE__ */ h.jsx(n, { children: /* @__PURE__ */ h.jsx("g", { transform: we.toCssString(o), children: i.map((c) => /* @__PURE__ */ h.jsx(
    RHe,
    {
      shapeId: t,
      handle: c,
      zoom: r,
      isCoarse: s
    },
    c.id
  )) }) });
}
function RHe({
  shapeId: t,
  handle: e,
  zoom: n,
  isCoarse: r
}) {
  const s = yHe(t, e.id), { Handle: o } = Ln();
  return o ? /* @__PURE__ */ h.jsx(
    "g",
    {
      role: "button",
      "aria-label": e.label || "handle",
      transform: `translate(${e.x}, ${e.y})`,
      ...s,
      children: /* @__PURE__ */ h.jsx(o, { shapeId: t, handle: e, zoom: n, isCoarse: r })
    }
  ) : null;
}
function $He() {
  const { Overlays: t } = Ln();
  return t ? /* @__PURE__ */ h.jsx("div", { className: "tl-custom-overlays tl-overlays__item", children: /* @__PURE__ */ h.jsx(t, {}) }) : null;
}
function LHe() {
  const t = ie(), e = le("rendering shapes", () => t.getRenderingShapes(), [t]), n = le(
    "dpr multiple",
    () => (
      // dprMultiple is the smallest number we can multiply dpr by to get an integer
      // it's usually 1, 2, or 4 (for e.g. dpr of 2, 2.5 and 2.25 respectively)
      oie(Math.floor(t.getInstanceState().devicePixelRatio * 100) / 100)
    ),
    [t]
  );
  return e.map((r) => /* @__PURE__ */ h.jsxs(D$, { children: [
    /* @__PURE__ */ h.jsx(Yne, { ...r, dprMultiple: n }),
    /* @__PURE__ */ h.jsx(VHe, { id: r.id, mode: "iframe" })
  ] }, r.id + "_fragment"));
}
function FHe() {
  const t = ie(), e = fe(/* @__PURE__ */ new Set());
  return Ep(
    "reflow for culled shapes",
    () => {
      const n = t.getCulledShapes();
      if (e.current.size === n.size && [...n].every((s) => e.current.has(s)))
        return;
      e.current = n;
      const r = document.getElementsByClassName("tl-canvas");
      r.length !== 0 && r[0].offsetHeight;
    },
    [t]
  ), null;
}
function BHe() {
  const t = ie(), e = le("rendering shapes", () => t.getRenderingShapes(), [t]), n = le(
    "dpr multiple",
    () => (
      // dprMultiple is the smallest number we can multiply dpr by to get an integer
      // it's usually 1, 2, or 4 (for e.g. dpr of 2, 2.5 and 2.25 respectively)
      oie(Math.floor(t.getInstanceState().devicePixelRatio * 100) / 100)
    ),
    [t]
  );
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    e.map((r) => /* @__PURE__ */ h.jsx(Yne, { ...r, dprMultiple: n }, r.id + "_shape")),
    dn.isSafari && /* @__PURE__ */ h.jsx(FHe, {})
  ] });
}
function zHe() {
  const t = ie(), { ShapeIndicator: e } = Ln(), n = le("hinting shape ids", () => cF(t.getHintingShapeIds()), [t]);
  return !n.length || !e ? null : n.map((r) => /* @__PURE__ */ h.jsx(e, { className: "tl-user-indicator__hint", shapeId: r }, r + "_hinting"));
}
function UHe() {
  return /* @__PURE__ */ h.jsxs("g", { id: Xc("cursor"), children: [
    /* @__PURE__ */ h.jsxs("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
      /* @__PURE__ */ h.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ h.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ h.jsxs("g", { fill: "white", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ h.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ h.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ h.jsxs("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ h.jsx("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
      /* @__PURE__ */ h.jsx("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
    ] })
  ] });
}
function HHe() {
  const t = Xc("cursor_hint");
  return /* @__PURE__ */ h.jsx("path", { id: t, fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z" });
}
function VHe({ id: t, mode: e }) {
  const n = ie(), [r, s] = he(null), o = le(
    "is in root",
    () => {
      const i = n.getShape(t);
      return (i == null ? void 0 : i.parentId) === n.getCurrentPageId();
    },
    [n, t]
  );
  return me(() => {
    if (!o) return;
    let i = null;
    const a = ya("shape to svg", async () => {
      const c = Math.random();
      i = c;
      const d = n.isShapeOfType(t, "frame") ? 0 : 10;
      let u = n.getShapePageBounds(t);
      if (!u) return;
      u = u.clone().expandBy(d);
      const f = await n.getSvgString([t], { padding: d });
      if (i !== c || !f) return;
      const p = `data:image/svg+xml;utf8,${encodeURIComponent(f.svg)}`;
      s({ src: p, bounds: u });
    });
    return () => {
      i = null, a();
    };
  }, [n, t, o]), !o || !r ? null : e === "iframe" ? /* @__PURE__ */ h.jsx(
    "iframe",
    {
      src: r.src,
      width: r.bounds.width,
      height: r.bounds.height,
      referrerPolicy: "no-referrer",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        border: "none",
        transform: `translate(${r.bounds.x}px, ${r.bounds.maxY + 12}px)`,
        outline: "1px solid black",
        maxWidth: "none"
      }
    }
  ) : /* @__PURE__ */ h.jsx(
    "img",
    {
      src: r.src,
      width: r.bounds.width,
      height: r.bounds.height,
      referrerPolicy: "no-referrer",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        transform: `translate(${r.bounds.x}px, ${r.bounds.maxY + 12}px)`,
        outline: "1px solid black",
        maxWidth: "none"
      }
    }
  );
}
function WHe() {
  const t = ie(), e = le(
    "selection rotation",
    function() {
      return t.getSelectionRotation();
    },
    [t]
  ), n = le(
    "selection bounds",
    () => t.getSelectionRotatedPageBounds(),
    [t]
  ), { SelectionForeground: r } = Ln();
  return !n || !r ? null : /* @__PURE__ */ h.jsx(r, { bounds: n, rotation: e });
}
function KHe() {
  const t = ie(), e = le("selection rotation", () => t.getSelectionRotation(), [
    t
  ]), n = le(
    "selection bounds",
    () => t.getSelectionRotatedPageBounds(),
    [t]
  ), { SelectionBackground: r } = Ln();
  return !n || !r ? null : /* @__PURE__ */ h.jsx(r, { bounds: n, rotation: e });
}
function GHe() {
  const { OnTheCanvas: t } = Ln();
  return t ? /* @__PURE__ */ h.jsx(t, {}) : null;
}
function YHe() {
  const t = ie(), e = le("camera state", () => t.getCameraState(), [t]);
  return /* @__PURE__ */ h.jsx(
    "div",
    {
      className: Je("tl-hit-test-blocker", {
        "tl-hit-test-blocker__hidden": e === "idle"
      })
    }
  );
}
function Zd({ children: t, className: e = "", ...n }) {
  return /* @__PURE__ */ h.jsx("div", { ...n, className: Je("tl-html-container", e), children: t });
}
class o_ {
  constructor(e) {
    this.editor = e;
  }
}
P(o_, "props"), P(o_, "migrations"), /**
 * The type of the binding util, which should match the binding's type.
 *
 * @public
 */
P(o_, "type");
function iS(t, e, n = {}) {
  const { newPoint: r, handle: s, scaleX: o, scaleY: i } = e, { minWidth: a = 1, maxWidth: c = 1 / 0, minHeight: l = 1, maxHeight: d = 1 / 0 } = n;
  let u = t.props.w * o, f = t.props.h * i;
  const p = new I(0, 0);
  if (u > 0) {
    if (u < a) {
      switch (s) {
        case "top_left":
        case "left":
        case "bottom_left": {
          p.x = u - a;
          break;
        }
        case "top":
        case "bottom": {
          p.x = (u - a) / 2;
          break;
        }
        default:
          p.x = 0;
      }
      u = a;
    }
  } else if (p.x = u, u = -u, u < a) {
    switch (s) {
      case "top_left":
      case "left":
      case "bottom_left": {
        p.x = -u;
        break;
      }
      default:
        p.x = -a;
    }
    u = a;
  }
  if (f > 0) {
    if (f < l) {
      switch (s) {
        case "top_left":
        case "top":
        case "top_right": {
          p.y = f - l;
          break;
        }
        case "right":
        case "left": {
          p.y = (f - l) / 2;
          break;
        }
        default:
          p.y = 0;
      }
      f = l;
    }
  } else if (p.y = f, f = -f, f < l) {
    switch (s) {
      case "top_left":
      case "top":
      case "top_right": {
        p.y = -f;
        break;
      }
      default:
        p.y = -l;
    }
    f = l;
  }
  const { x: g, y } = p.rot(t.rotation).add(r);
  return {
    ...t,
    x: g,
    y,
    props: {
      w: Math.min(c, u),
      h: Math.min(d, f)
    }
  };
}
class uv extends sc {
  getGeometry(e) {
    return new ol({
      width: e.props.w,
      height: e.props.h,
      isFilled: !0
    });
  }
  onResize(e, n) {
    return iS(e, n);
  }
  getHandleSnapGeometry(e) {
    return {
      points: this.getGeometry(e).bounds.cornersAndCenter
    };
  }
  getInterpolatedProps(e, n, r) {
    return {
      ...n.props,
      w: kt(e.props.w, n.props.w, r),
      h: kt(e.props.h, n.props.h, r)
    };
  }
}
function lie(t, { initialBounds: e, scaleX: n, scaleY: r, newPoint: s, handle: o }) {
  let i;
  switch (o) {
    case "bottom_left":
    case "bottom_right":
    case "top_left":
    case "top_right": {
      i = Math.max(0.01, Math.max(Math.abs(n), Math.abs(r)));
      break;
    }
    case "left":
    case "right": {
      i = Math.max(0.01, Math.abs(n));
      break;
    }
    case "bottom":
    case "top": {
      i = Math.max(0.01, Math.abs(r));
      break;
    }
    default:
      throw Jt(o);
  }
  const a = new I(0, 0);
  n < 0 && (a.x = -(e.width * i)), r < 0 && (a.y = -(e.height * i));
  const { x: c, y: l } = I.Add(s, a.rot(t.rotation));
  return {
    x: c,
    y: l,
    props: {
      scale: i * t.props.scale
    }
  };
}
var sD;
let qHe = (sD = class extends Xe {
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, P(sD, "id", "idle"), sD);
var oD;
let XHe = (oD = class extends Xe {
  onPointerMove(e) {
    const { editor: n } = this;
    if (n.inputs.isDragging) {
      const { originPagePoint: r } = n.inputs, s = this.parent.shapeType, o = $n(), i = n.markHistoryStoppingPoint(`creating_box:${o}`), a = Ea(r, n);
      if (this.editor.createShapes([
        {
          id: o,
          type: s,
          x: a.x,
          y: a.y,
          props: {
            w: 1,
            h: 1
          }
        }
      ]), !n.getShape(o)) {
        this.cancel();
        return;
      }
      n.select(o);
      const l = this.parent;
      this.editor.setCurrentTool(
        "select.resizing",
        {
          ...e,
          target: "selection",
          handle: "bottom_right",
          isCreating: !0,
          creatingMarkId: i,
          creationCursorOffset: { x: 1, y: 1 },
          onInteractionEnd: this.parent.id,
          onCreate: l.onCreate ? (d) => {
            var u;
            return (u = l.onCreate) == null ? void 0 : u.call(l, d);
          } : void 0
        }
        /** satisfies ResizingInfo, defined in main tldraw package  */
      );
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { originPagePoint: e } = this.editor.inputs, n = this.parent.shapeType, r = $n();
    this.editor.markHistoryStoppingPoint(`creating_box:${r}`), this.editor.createShapes([
      {
        id: r,
        type: n,
        x: e.x,
        y: e.y
      }
    ]);
    const s = this.editor.getShape(r);
    if (!s) {
      this.cancel();
      return;
    }
    let { w: o, h: i } = s.props;
    const a = new I(o / 2, i / 2), c = this.editor.getShapeParentTransform(s);
    c && a.rot(-c.rotation());
    let l = 1;
    this.editor.user.getIsDynamicResizeMode() && (l = 1 / this.editor.getZoomLevel(), o *= l, i *= l, a.mul(l));
    const d = mr(s), u = Ea(new I(s.x - a.x, s.y - a.y), this.editor);
    d.x = u.x, d.y = u.y, d.props.w = o, d.props.h = i, "scale" in s.props && (d.props.scale = l), this.editor.updateShape(d), this.editor.setSelectedShapes([r]), this.editor.getInstanceState().isToolLocked ? this.parent.transition("idle") : this.editor.setCurrentTool("select.idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
}, P(oD, "id", "pointing"), oD);
function Ea(t, e) {
  const n = e.getInstanceState().isGridMode, r = e.getDocumentSettings().gridSize;
  return n ? t.clone().snapToGrid(r) : t.clone();
}
class wj extends Xe {
  static children() {
    return [qHe, XHe];
  }
}
P(wj, "id", "box"), P(wj, "initial", "idle");
function ZHe(t, e, n) {
  const r = fe(!1), s = re(
    (i) => {
      r.current = i, i ? ni.addOpenMenu(t) : ni.deleteOpenMenu(t), e == null || e(i);
    },
    [t, e]
  ), o = le("is menu open", () => ni.getOpenMenus().includes(t), [t]);
  return me(() => (r.current && (n == null || n("open-menu"), ni.addOpenMenu(t)), () => {
    r.current && (ni.deleteOpenMenu(t), ni.getOpenMenus().forEach((i) => {
      i.startsWith(t) && (n == null || n("close-menu"), ni.deleteOpenMenu(i));
    }), r.current = !1);
  }), [t, n]), [o, s];
}
function aS(t) {
  const e = ie();
  return le("isEditing", () => e.getEditingShapeId() === t, [e, t]);
}
function QHe(t) {
  if (!t) throw Error("usePassThroughWheelEvents must be passed a ref");
  const e = Gr();
  me(() => {
    function n(s) {
      if (s.isSpecialRedispatchedEvent) return;
      xt(s);
      const o = e.querySelector(".tl-canvas");
      if (!o) return;
      const i = new PointerEvent(s.type, s);
      i.isSpecialRedispatchedEvent = !0, o.dispatchEvent(i);
    }
    const r = t.current;
    if (r)
      return r.addEventListener("mouseover", n, { passive: !1 }), () => {
        r.removeEventListener("mouseover", n);
      };
  }, [e, t]);
}
function wl(t) {
  const e = ie();
  return Ke(
    function() {
      const s = (l) => {
        if (l.isKilled) return;
        if (l.button === u3) {
          e.dispatch({
            type: "pointer",
            target: "selection",
            handle: t,
            name: "right_click",
            ...la(l)
          });
          return;
        }
        if (l.button !== 0) return;
        const d = LE(l.currentTarget);
        function u() {
          d.removeEventListener("pointerup", u), X0(d, l);
        }
        q0(d, l), d.addEventListener("pointerup", u), e.dispatch({
          name: "pointer_down",
          type: "pointer",
          target: "selection",
          handle: t,
          ...la(l)
        }), cr(l);
      };
      let o, i;
      function a(l) {
        l.isKilled || l.button === 0 && (l.clientX === o && l.clientY === i || (o = l.clientX, i = l.clientY, e.dispatch({
          name: "pointer_move",
          type: "pointer",
          target: "selection",
          handle: t,
          ...la(l)
        })));
      }
      return {
        onPointerDown: s,
        onPointerMove: a,
        onPointerUp: (l) => {
          l.isKilled || l.button === 0 && e.dispatch({
            name: "pointer_up",
            type: "pointer",
            target: "selection",
            handle: t,
            ...la(l)
          });
        }
      };
    },
    [e, t]
  );
}
function JHe(t) {
  const [e, n] = he(() => ({ store: zE(t), opts: t }));
  if (!MJ(e.opts, t)) {
    const r = { store: zE(t), opts: t };
    return n(r), r.store;
  }
  return e.store;
}
const e9e = 20, t9e = 8;
function XI(t, e = e9e) {
  return Math.max(t9e, Math.ceil(t / e));
}
class die extends nh {
  constructor(n) {
    super({ ...n, isFilled: !1, isClosed: !1 });
    P(this, "_center");
    P(this, "_radius");
    P(this, "_start");
    P(this, "_end");
    P(this, "_largeArcFlag");
    P(this, "_sweepFlag");
    P(this, "_measure");
    P(this, "_angleStart");
    P(this, "_angleEnd");
    const { center: r, sweepFlag: s, largeArcFlag: o, start: i, end: a } = n;
    if (i.equals(a)) throw Error("Arc must have different start and end points.");
    this._angleStart = I.Angle(r, i), this._angleEnd = I.Angle(r, a), this._radius = I.Dist(r, i), this._measure = R4e(this._angleStart, this._angleEnd, s, o), this._start = i, this._end = a, this._sweepFlag = s, this._largeArcFlag = o, this._center = r;
  }
  nearestPoint(n) {
    const {
      _center: r,
      _measure: s,
      _radius: o,
      _angleEnd: i,
      _angleStart: a,
      _start: c,
      _end: l
    } = this, d = q8(s, a, i, r.angle(n));
    if (d <= 0) return c;
    if (d >= 1) return l;
    const u = I.Sub(n, r).uni().mul(o).add(r);
    let f, p = 1 / 0, g;
    for (const y of [c, l, u])
      g = I.Dist2(n, y), g < p && (f = y, p = g);
    if (!f) throw Error("nearest point not found");
    return f;
  }
  hitTestLineSegment(n, r) {
    const {
      _center: s,
      _radius: o,
      _measure: i,
      _angleStart: a,
      _angleEnd: c
    } = this, l = Z0(n, r, s, o);
    return l === null ? !1 : l.some((d) => {
      const u = q8(i, a, c, s.angle(d));
      return u >= 0 && u <= 1;
    });
  }
  getVertices() {
    const { _center: n, _measure: r, length: s, _radius: o, _angleStart: i } = this, a = [];
    for (let c = 0, l = XI(Math.abs(s)); c < l + 1; c++) {
      const d = c / l * r, u = i + d;
      a.push(d3(n, o, u));
    }
    return a;
  }
  getSvgPathData(n = !0) {
    const {
      _start: r,
      _end: s,
      _radius: o,
      _largeArcFlag: i,
      _sweepFlag: a
    } = this;
    return `${n ? `M${r.toFixed()}` : ""} A${o} ${o} 0 ${i} ${a} ${s.toFixed()}`;
  }
  getLength() {
    return Math.abs(this._measure * this._radius);
  }
}
class VE extends nh {
  constructor(n) {
    super({ isClosed: !0, ...n });
    P(this, "_center");
    P(this, "_radius");
    P(this, "_x");
    P(this, "_y");
    this.config = n;
    const { x: r = 0, y: s = 0, radius: o } = n;
    this._x = r, this._y = s, this._center = new I(o + r, o + s), this._radius = o;
  }
  getBounds() {
    return new _e(this._x, this._y, this._radius * 2, this._radius * 2);
  }
  getVertices() {
    const { _center: n, _radius: r } = this, s = Bn * r, o = [];
    for (let i = 0, a = XI(s); i < a; i++) {
      const c = i / a * Bn;
      o.push(d3(n, r, c));
    }
    return o;
  }
  nearestPoint(n) {
    const { _center: r, _radius: s } = this;
    return r.equals(n) ? I.AddXY(r, s, 0) : I.Sub(n, r).uni().mul(s).add(r);
  }
  hitTestLineSegment(n, r, s = 0) {
    const { _center: o, _radius: i } = this;
    return Z0(n, r, o, i + s) !== null;
  }
  getSvgPathData() {
    const { _center: n, _radius: r } = this;
    return `M${n.x + r},${n.y} a${r},${r} 0 1,0 ${r * 2},0a${r},${r} 0 1,0 -${r * 2},0`;
  }
}
class D3 extends Q0 {
  constructor(n) {
    const { start: r, cp1: s, cp2: o, end: i } = n;
    super({ ...n, points: [r, i] });
    P(this, "_a");
    P(this, "_b");
    P(this, "_c");
    P(this, "_d");
    P(this, "_resolution");
    this._a = r, this._b = s, this._c = o, this._d = i, this._resolution = n.resolution ?? 10;
  }
  getVertices() {
    const n = [], { _a: r, _b: s, _c: o, _d: i } = this;
    for (let a = 0, c = this._resolution; a <= c; a++) {
      const l = a / c;
      n.push(
        new I(
          (1 - l) * (1 - l) * (1 - l) * r.x + 3 * ((1 - l) * (1 - l)) * l * s.x + 3 * (1 - l) * (l * l) * o.x + l * l * l * i.x,
          (1 - l) * (1 - l) * (1 - l) * r.y + 3 * ((1 - l) * (1 - l)) * l * s.y + 3 * (1 - l) * (l * l) * o.y + l * l * l * i.y
        )
      );
    }
    return n;
  }
  nearestPoint(n) {
    let r, s = 1 / 0, o, i;
    for (const a of this.segments)
      i = a.nearestPoint(n), o = I.Dist2(i, n), o < s && (r = i, s = o);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  getSvgPathData(n = !0) {
    const { _a: r, _b: s, _c: o, _d: i } = this;
    return `${n ? `M ${r.toFixed()} ` : ""} C${s.toFixed()} ${o.toFixed()} ${i.toFixed()}`;
  }
  static GetAtT(n, r) {
    const { _a: s, _b: o, _c: i, _d: a } = n;
    return new I(
      (1 - r) * (1 - r) * (1 - r) * s.x + 3 * ((1 - r) * (1 - r)) * r * o.x + 3 * (1 - r) * (r * r) * i.x + r * r * r * a.x,
      (1 - r) * (1 - r) * (1 - r) * s.y + 3 * ((1 - r) * (1 - r)) * r * o.y + 3 * (1 - r) * (r * r) * i.y + r * r * r * a.y
    );
  }
  getLength(n, r = 32) {
    let s, o = this._a, i = 0;
    for (let a = 1; a <= r; a++)
      s = D3.GetAtT(this, a / r), i += I.Dist(o, s), o = s;
    return i;
  }
}
class n9e extends nh {
  constructor(n) {
    super({ ...n, isClosed: !0 });
    P(this, "_w");
    P(this, "_h");
    P(this, "_edges");
    this.config = n;
    const { width: r, height: s } = n;
    this._w = r, this._h = s;
  }
  // eslint-disable-next-line no-restricted-syntax
  get edges() {
    if (!this._edges) {
      const { vertices: n } = this;
      this._edges = [];
      for (let r = 0, s = n.length; r < s; r++) {
        const o = n[r], i = n[(r + 1) % s];
        this._edges.push(new ly({ start: o, end: i }));
      }
    }
    return this._edges;
  }
  getVertices() {
    const n = Math.max(1, this._w), r = Math.max(1, this._h), s = n / 2, o = r / 2, i = Math.pow(s - o, 2) / Math.pow(s + o, 2), a = mn * (s + o) * (1 + 3 * i / (10 + Math.sqrt(4 - 3 * i))), c = XI(a), l = Bn / c, d = Math.cos(l), u = Math.sin(l);
    let f = 0, p = 1, g = 0, y = 1;
    const m = Array(c);
    for (let v = 0; v < c; v++)
      m[v] = new I(wt(s + s * p, 0, n), wt(o + o * f, 0, r)), g = u * p + d * f, y = d * p - u * f, f = g, p = y;
    return m;
  }
  nearestPoint(n) {
    let r, s = 1 / 0, o, i;
    for (const a of this.edges)
      i = a.nearestPoint(n), o = I.Dist2(i, n), o < s && (r = i, s = o);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  hitTestLineSegment(n, r) {
    return this.edges.some((s) => s.hitTestLineSegment(n, r));
  }
  getBounds() {
    return new _e(0, 0, this._w, this._h);
  }
  getLength() {
    const { _w: n, _h: r } = this, s = n / 2, o = r / 2, i = Math.max(0, s), a = Math.max(0, o);
    return O4e(i, a);
  }
  getSvgPathData(n = !1) {
    const { _w: r, _h: s } = this, o = r / 2, i = s / 2, a = Math.max(0, o), c = Math.max(0, i);
    return `${n ? `M${o - a},${i}` : ""} a${a},${c},0,1,1,${a * 2},0a${a},${c},0,1,1,-${a * 2},0`;
  }
}
function An(t, e, n) {
  var a;
  const r = /* @__PURE__ */ new Set();
  for (const c of e) {
    const l = t.getShape(c);
    if (!l) continue;
    r.add(l);
    const d = t.getShape(l.parentId);
    d && r.add(d);
  }
  const s = /* @__PURE__ */ new Map();
  for (const c of r) {
    const l = t.getSortedChildIdsForParent(c);
    if (n != null && n.filter && !n.filter(c))
      s.set(c, l);
    else {
      const d = r9e(t, c.id, l);
      d.length < l.length && s.set(
        c,
        l.filter((u) => !d.includes(u))
      );
    }
  }
  const o = t.getCurrentPageShapesSorted().map((c) => c.id), i = {};
  for (const [c, l] of s) {
    const d = mt(l.map((p) => t.getShape(p))), { reparenting: u, remainingShapesToReparent: f } = s9e(
      t,
      d,
      (p, g) => n != null && n.filter && !n.filter(g) ? !1 : g.id !== c.id && o.indexOf(g.id) < o.indexOf(p.id)
    );
    if (u.forEach((p, g) => {
      p.length !== 0 && (i[g] || (i[g] = {
        parentId: g,
        shapeIds: []
      }), i[g].shapeIds.push(...p.map((y) => y.id)));
    }), f.size > 0) {
      const p = ((a = t.findShapeAncestor(c, (g) => t.isShapeOfType(g, "group"))) == null ? void 0 : a.id) ?? t.getCurrentPageId();
      f.forEach((g) => {
        if (!i[p]) {
          let y;
          const m = t.getSortedChildIdsForParent(p), v = m.indexOf(c.id);
          if (v > -1) {
            const b = m[v + 1], x = b ? t.getShape(b).index : Bc(c.index);
            y = oy(c.index, x);
          }
          i[p] = {
            parentId: p,
            shapeIds: [],
            index: y
          };
        }
        i[p].shapeIds.push(g.id);
      });
    }
  }
  t.run(() => {
    Object.values(i).forEach(({ parentId: c, shapeIds: l, index: d }) => {
      l.length !== 0 && (l.sort((u, f) => o.indexOf(u) < o.indexOf(f) ? -1 : 1), t.reparentShapes(l, c, d));
    });
  });
}
function r9e(t, e, n) {
  if (n.length === 0)
    return Br;
  const r = t.getShapePageBounds(e);
  if (!r) return Br;
  const s = t.getShapeGeometry(e), i = t.getShapePageTransform(e).applyToPoints(s.vertices), a = t.getShapeMask(e), c = a ? BE(a, i) : i;
  return c ? n.filter((l) => {
    const d = t.getShapePageBounds(l);
    if (!d || !r.includes(d)) return !1;
    const u = t.getShapePageTransform(l).clone().invert().applyToPoints(c), f = t.getShapeGeometry(l);
    return N3(f, u);
  }) : Br;
}
function N3(t, e) {
  if (t instanceof ui)
    return t.children.some(
      (a) => N3(a, e)
    );
  const { vertices: n, center: r, isFilled: s, isEmptyLabel: o, isClosed: i } = t;
  if (o) return !1;
  if (n.some((a) => li(a, e)))
    return !0;
  if (i) {
    if (s && (li(r, e) || e.every((a) => li(a, n))) || kne(e, n))
      return !0;
  } else if (_Be(e, n))
    return !0;
  return !1;
}
function s9e(t, e, n) {
  var l, d, u, f;
  const r = new Set(e), s = /* @__PURE__ */ new Set();
  for (const p of e) {
    const g = t.getShapeParent(p);
    g && t.isShapeOfType(g, "group") && (s.has(g) || s.add(g));
  }
  for (const p of s) {
    const g = mt(
      t.getSortedChildIdsForParent(p).map((y) => t.getShape(y))
    );
    for (const y of g)
      r.delete(y);
    r.add(p);
  }
  const o = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = new Set(r), c = t.getCurrentPageShapesSorted().filter(
    (p) => {
      var g, y;
      return ((y = (g = t.getShapeUtil(p)).canReceiveNewChildrenOfType) == null ? void 0 : y.call(g, p, p.type)) && !a.has(p);
    }
  );
  e: for (let p = c.length - 1; p >= 0; p--) {
    const g = c[p], y = (l = t.findShapeAncestor(
      g,
      (C) => t.isShapeOfType(C, "group")
    )) == null ? void 0 : l.id, m = t.getShapeGeometry(g), v = t.getShapePageTransform(g), b = t.getShapeMask(g), x = v.applyToPoints(m.vertices), w = b ? BE(b, x) : x;
    if (!w) continue e;
    const S = [];
    t: for (const C of a) {
      if (g.id === C.id || n && !n(C, g) || (o.has(C.id) || o.set(
        C.id,
        (d = t.findShapeAncestor(C, (M) => t.isShapeOfType(M, "group"))) == null ? void 0 : d.id
      ), o.get(C.id) !== y) || t.findShapeAncestor(g, (M) => C.id === M.id)) continue t;
      const E = t.getShapePageTransform(C).clone().invert().applyToPoints(w);
      if (N3(t.getShapeGeometry(C), E)) {
        if (!((f = (u = t.getShapeUtil(g)).canReceiveNewChildrenOfType) != null && f.call(u, g, C.type)))
          continue t;
        C.parentId !== g.id && S.push(C), a.delete(C);
        continue t;
      }
    }
    S.length && i.set(g.id, S);
  }
  return {
    // these are the shapes that will be reparented to new parents
    reparenting: i,
    // these are the shapes that will be reparented to the page or their ancestral group
    remainingShapesToReparent: a
  };
}
function qs(t) {
  this.content = t;
}
qs.prototype = {
  constructor: qs,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var r = n && n != t ? this.remove(n) : this, s = r.find(t), o = r.content.slice();
    return s == -1 ? o.push(n || t, e) : (o[s + 1] = e, n && (o[s] = n)), new qs(o);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new qs(n);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new qs([t, e].concat(this.remove(t).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new qs(n);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var r = this.remove(e), s = r.content.slice(), o = r.find(t);
    return s.splice(o == -1 ? s.length : o, 0, e, n), new qs(s);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = qs.from(t), t.size ? new qs(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = qs.from(t), t.size ? new qs(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = qs.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
qs.from = function(t) {
  if (t instanceof qs) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new qs(e);
};
function uie(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let s = t.child(r), o = e.child(r);
    if (s == o) {
      n += s.nodeSize;
      continue;
    }
    if (!s.sameMarkup(o))
      return n;
    if (s.isText && s.text != o.text) {
      for (let i = 0; s.text[i] == o.text[i]; i++)
        n++;
      return n;
    }
    if (s.content.size || o.content.size) {
      let i = uie(s.content, o.content, n + 1);
      if (i != null)
        return i;
    }
    n += s.nodeSize;
  }
}
function fie(t, e, n, r) {
  for (let s = t.childCount, o = e.childCount; ; ) {
    if (s == 0 || o == 0)
      return s == o ? null : { a: n, b: r };
    let i = t.child(--s), a = e.child(--o), c = i.nodeSize;
    if (i == a) {
      n -= c, r -= c;
      continue;
    }
    if (!i.sameMarkup(a))
      return { a: n, b: r };
    if (i.isText && i.text != a.text) {
      let l = 0, d = Math.min(i.text.length, a.text.length);
      for (; l < d && i.text[i.text.length - l - 1] == a.text[a.text.length - l - 1]; )
        l++, n--, r--;
      return { a: n, b: r };
    }
    if (i.content.size || a.content.size) {
      let l = fie(i.content, a.content, n - 1, r - 1);
      if (l)
        return l;
    }
    n -= c, r -= c;
  }
}
class Pe {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, s = 0, o) {
    for (let i = 0, a = 0; a < n; i++) {
      let c = this.content[i], l = a + c.nodeSize;
      if (l > e && r(c, s + a, o || null, i) !== !1 && c.content.size) {
        let d = a + 1;
        c.nodesBetween(Math.max(0, e - d), Math.min(c.content.size, n - d), r, s + d);
      }
      a = l;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, s) {
    let o = "", i = !0;
    return this.nodesBetween(e, n, (a, c) => {
      let l = a.isText ? a.text.slice(Math.max(e, c) - c, n - c) : a.isLeaf ? s ? typeof s == "function" ? s(a) : s : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && l || a.isTextblock) && r && (i ? i = !1 : o += r), o += l;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, s = this.content.slice(), o = 0;
    for (n.isText && n.sameMarkup(r) && (s[s.length - 1] = n.withText(n.text + r.text), o = 1); o < e.content.length; o++)
      s.push(e.content[o]);
    return new Pe(s, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], s = 0;
    if (n > e)
      for (let o = 0, i = 0; i < n; o++) {
        let a = this.content[o], c = i + a.nodeSize;
        c > e && ((i < e || c > n) && (a.isText ? a = a.cut(Math.max(0, e - i), Math.min(a.text.length, n - i)) : a = a.cut(Math.max(0, e - i - 1), Math.min(a.content.size, n - i - 1))), r.push(a), s += a.nodeSize), i = c;
      }
    return new Pe(r, s);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? Pe.empty : e == 0 && n == this.content.length ? this : new Pe(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let s = this.content.slice(), o = this.size + n.nodeSize - r.nodeSize;
    return s[e] = n, new Pe(s, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new Pe([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new Pe(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let s = this.content[n];
      e(s, r, n), r += s.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return uie(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return fie(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return j1(0, e);
    if (e == this.size)
      return j1(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let n = 0, r = 0; ; n++) {
      let s = this.child(n), o = r + s.nodeSize;
      if (o >= e)
        return o == e ? j1(n + 1, o) : j1(n, r);
      r = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Pe.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Pe(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return Pe.empty;
    let n, r = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s];
      r += o.nodeSize, s && o.isText && e[s - 1].sameMarkup(o) ? (n || (n = e.slice(0, s)), n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o);
    }
    return new Pe(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return Pe.empty;
    if (e instanceof Pe)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new Pe([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Pe.empty = new Pe([], 0);
const gO = { index: 0, offset: 0 };
function j1(t, e) {
  return gO.index = t, gO.offset = e, gO;
}
function WE(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!WE(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !WE(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
let Fn = class Sj {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let s = 0; s < e.length; s++) {
      let o = e[s];
      if (this.eq(o))
        return e;
      if (this.type.excludes(o.type))
        n || (n = e.slice(0, s));
      else {
        if (o.type.excludes(this.type))
          return e;
        !r && o.type.rank > this.type.rank && (n || (n = e.slice(0, s)), n.push(this), r = !0), n && n.push(o);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && WE(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let s = r.create(n.attrs);
    return r.checkAttrs(s.attrs), s;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return Sj.none;
    if (e instanceof Sj)
      return [e];
    let n = e.slice();
    return n.sort((r, s) => r.type.rank - s.type.rank), n;
  }
};
Fn.none = [];
class KE extends Error {
}
class We {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = pie(this.content, e + this.openStart, n);
    return r && new We(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new We(hie(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return We.empty;
    let r = n.openStart || 0, s = n.openEnd || 0;
    if (typeof r != "number" || typeof s != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new We(Pe.fromJSON(e, n.content), r, s);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, s = 0;
    for (let o = e.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
      r++;
    for (let o = e.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
      s++;
    return new We(e, r, s);
  }
}
We.empty = new We(Pe.empty, 0, 0);
function hie(t, e, n) {
  let { index: r, offset: s } = t.findIndex(e), o = t.maybeChild(r), { index: i, offset: a } = t.findIndex(n);
  if (s == e || o.isText) {
    if (a != n && !t.child(i).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != i)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, o.copy(hie(o.content, e - s - 1, n - s - 1)));
}
function pie(t, e, n, r) {
  let { index: s, offset: o } = t.findIndex(e), i = t.maybeChild(s);
  if (o == e || i.isText)
    return r && !r.canReplace(s, s, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
  let a = pie(i.content, e - o - 1, n, i);
  return a && t.replaceChild(s, i.copy(a));
}
function o9e(t, e, n) {
  if (n.openStart > t.depth)
    throw new KE("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new KE("Inconsistent open depths");
  return gie(t, e, n, 0);
}
function gie(t, e, n, r) {
  let s = t.index(r), o = t.node(r);
  if (s == e.index(r) && r < t.depth - n.openStart) {
    let i = gie(t, e, n, r + 1);
    return o.copy(o.content.replaceChild(s, i));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let i = t.parent, a = i.content;
      return cp(i, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: i, end: a } = i9e(n, t);
      return cp(o, yie(t, i, a, e, r));
    }
  else return cp(o, GE(t, e, r));
}
function mie(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new KE("Cannot join " + e.type.name + " onto " + t.type.name);
}
function Cj(t, e, n) {
  let r = t.node(n);
  return mie(r, e.node(n)), r;
}
function ap(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function xx(t, e, n, r) {
  let s = (e || t).node(n), o = 0, i = e ? e.index(n) : s.childCount;
  t && (o = t.index(n), t.depth > n ? o++ : t.textOffset && (ap(t.nodeAfter, r), o++));
  for (let a = o; a < i; a++)
    ap(s.child(a), r);
  e && e.depth == n && e.textOffset && ap(e.nodeBefore, r);
}
function cp(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function yie(t, e, n, r, s) {
  let o = t.depth > s && Cj(t, e, s + 1), i = r.depth > s && Cj(n, r, s + 1), a = [];
  return xx(null, t, s, a), o && i && e.index(s) == n.index(s) ? (mie(o, i), ap(cp(o, yie(t, e, n, r, s + 1)), a)) : (o && ap(cp(o, GE(t, e, s + 1)), a), xx(e, n, s, a), i && ap(cp(i, GE(n, r, s + 1)), a)), xx(r, null, s, a), new Pe(a);
}
function GE(t, e, n) {
  let r = [];
  if (xx(null, t, n, r), t.depth > n) {
    let s = Cj(t, e, n + 1);
    ap(cp(s, GE(t, e, n + 1)), r);
  }
  return xx(e, null, n, r), new Pe(r);
}
function i9e(t, e) {
  let n = e.depth - t.openStart, s = e.node(n).copy(t.content);
  for (let o = n - 1; o >= 0; o--)
    s = e.node(o).copy(Pe.from(s));
  return {
    start: s.resolveNoCache(t.openStart + n),
    end: s.resolveNoCache(s.content.size - t.openEnd - n)
  };
}
class fw {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], s = e.child(n);
    return r ? e.child(n).cut(r) : s;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], s = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let o = 0; o < e; o++)
      s += r.child(o).nodeSize;
    return s;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return Fn.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), s = e.maybeChild(n);
    if (!r) {
      let a = r;
      r = s, s = a;
    }
    let o = r.marks;
    for (var i = 0; i < o.length; i++)
      o[i].type.spec.inclusive === !1 && (!s || !o[i].isInSet(s.marks)) && (o = o[i--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, s = e.parent.maybeChild(e.index());
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === !1 && (!s || !r[o].isInSet(s.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new YE(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], s = 0, o = n;
    for (let i = e; ; ) {
      let { index: a, offset: c } = i.content.findIndex(o), l = o - c;
      if (r.push(i, a, s + c), !l || (i = i.child(a), i.isText))
        break;
      o = l - 1, s += c + 1;
    }
    return new fw(n, r, o);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let r = GH.get(e);
    if (r)
      for (let o = 0; o < r.elts.length; o++) {
        let i = r.elts[o];
        if (i.pos == n)
          return i;
      }
    else
      GH.set(e, r = new a9e());
    let s = r.elts[r.i] = fw.resolve(e, n);
    return r.i = (r.i + 1) % c9e, s;
  }
}
class a9e {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const c9e = 12, GH = /* @__PURE__ */ new WeakMap();
class YE {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const l9e = /* @__PURE__ */ Object.create(null);
let Zc = class _j {
  /**
  @internal
  */
  constructor(e, n, r, s = Fn.none) {
    this.type = e, this.attrs = n, this.marks = s, this.content = r || Pe.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, r, s = 0) {
    this.content.nodesBetween(e, n, r, s, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, n, r, s) {
    return this.content.textBetween(e, n, r, s);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && WE(this.attrs, n || e.defaultAttrs || l9e) && Fn.sameSet(this.marks, r || Fn.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new _j(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new _j(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return We.empty;
    let s = this.resolve(e), o = this.resolve(n), i = r ? 0 : s.sharedDepth(n), a = s.start(i), l = s.node(i).content.cut(s.pos - a, o.pos - a);
    return new We(l, s.depth - i, o.depth - i);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return o9e(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: s } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (s == e || n.isText)
        return n;
      e -= s + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let s = this.content.child(n - 1);
    return { node: s, index: n - 1, offset: r - s.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return fw.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return fw.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let s = !1;
    return n > e && this.nodesBetween(e, n, (o) => (r.isInSet(o.marks) && (s = !0), !s)), s;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), vie(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = Pe.empty, s = 0, o = r.childCount) {
    let i = this.contentMatchAt(e).matchFragment(r, s, o), a = i && i.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let c = s; c < o; c++)
      if (!this.type.allowsMarks(r.child(c).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, s) {
    if (s && !this.type.allowsMarks(s))
      return !1;
    let o = this.contentMatchAt(e).matchType(r), i = o && o.matchFragment(this.content, n);
    return i ? i.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Fn.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!Fn.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let s = Pe.fromJSON(e, n.content), o = e.nodeType(n.type).create(n.attrs, s, r);
    return o.type.checkAttrs(o.attrs), o;
  }
};
Zc.prototype.text = void 0;
class qE extends Zc {
  /**
  @internal
  */
  constructor(e, n, r, s) {
    if (super(e, n, null, s), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : vie(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new qE(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new qE(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function vie(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class Mp {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new d9e(e, n);
    if (r.next == null)
      return Mp.empty;
    let s = bie(r);
    r.next && r.err("Unexpected trailing text");
    let o = y9e(m9e(s));
    return v9e(o, r), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let s = this;
    for (let o = n; s && o < r; o++)
      s = s.matchType(e.child(o).type);
    return s;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let s = [this];
    function o(i, a) {
      let c = i.matchFragment(e, r);
      if (c && (!n || c.validEnd))
        return Pe.from(a.map((l) => l.createAndFill()));
      for (let l = 0; l < i.next.length; l++) {
        let { type: d, next: u } = i.next[l];
        if (!(d.isText || d.hasRequiredAttrs()) && s.indexOf(u) == -1) {
          s.push(u);
          let f = o(u, a.concat(d));
          if (f)
            return f;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let s = r.shift(), o = s.match;
      if (o.matchType(e)) {
        let i = [];
        for (let a = s; a.type; a = a.via)
          i.push(a.type);
        return i.reverse();
      }
      for (let i = 0; i < o.next.length; i++) {
        let { type: a, next: c } = o.next[i];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!s.type || c.validEnd) && (r.push({ match: a.contentMatch, type: a, via: s }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let s = 0; s < r.next.length; s++)
        e.indexOf(r.next[s].next) == -1 && n(r.next[s].next);
    }
    return n(this), e.map((r, s) => {
      let o = s + (r.validEnd ? "*" : " ") + " ";
      for (let i = 0; i < r.next.length; i++)
        o += (i ? ", " : "") + r.next[i].type.name + "->" + e.indexOf(r.next[i].next);
      return o;
    }).join(`
`);
  }
}
Mp.empty = new Mp(!0);
class d9e {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function bie(t) {
  let e = [];
  do
    e.push(u9e(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function u9e(t) {
  let e = [];
  do
    e.push(f9e(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function f9e(t) {
  let e = g9e(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = h9e(t, e);
    else
      break;
  return e;
}
function YH(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function h9e(t, e) {
  let n = YH(t), r = n;
  return t.eat(",") && (t.next != "}" ? r = YH(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
}
function p9e(t, e) {
  let n = t.nodeTypes, r = n[e];
  if (r)
    return [r];
  let s = [];
  for (let o in n) {
    let i = n[o];
    i.isInGroup(e) && s.push(i);
  }
  return s.length == 0 && t.err("No node type or group '" + e + "' found"), s;
}
function g9e(t) {
  if (t.eat("(")) {
    let e = bie(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = p9e(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function m9e(t) {
  let e = [[]];
  return s(o(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(i, a, c) {
    let l = { term: c, to: a };
    return e[i].push(l), l;
  }
  function s(i, a) {
    i.forEach((c) => c.to = a);
  }
  function o(i, a) {
    if (i.type == "choice")
      return i.exprs.reduce((c, l) => c.concat(o(l, a)), []);
    if (i.type == "seq")
      for (let c = 0; ; c++) {
        let l = o(i.exprs[c], a);
        if (c == i.exprs.length - 1)
          return l;
        s(l, a = n());
      }
    else if (i.type == "star") {
      let c = n();
      return r(a, c), s(o(i.expr, c), c), [r(c)];
    } else if (i.type == "plus") {
      let c = n();
      return s(o(i.expr, a), c), s(o(i.expr, c), c), [r(c)];
    } else {
      if (i.type == "opt")
        return [r(a)].concat(o(i.expr, a));
      if (i.type == "range") {
        let c = a;
        for (let l = 0; l < i.min; l++) {
          let d = n();
          s(o(i.expr, c), d), c = d;
        }
        if (i.max == -1)
          s(o(i.expr, c), c);
        else
          for (let l = i.min; l < i.max; l++) {
            let d = n();
            r(c, d), s(o(i.expr, c), d), c = d;
          }
        return [r(c)];
      } else {
        if (i.type == "name")
          return [r(a, void 0, i.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function xie(t, e) {
  return e - t;
}
function qH(t, e) {
  let n = [];
  return r(e), n.sort(xie);
  function r(s) {
    let o = t[s];
    if (o.length == 1 && !o[0].term)
      return r(o[0].to);
    n.push(s);
    for (let i = 0; i < o.length; i++) {
      let { term: a, to: c } = o[i];
      !a && n.indexOf(c) == -1 && r(c);
    }
  }
}
function y9e(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(qH(t, 0));
  function n(r) {
    let s = [];
    r.forEach((i) => {
      t[i].forEach(({ term: a, to: c }) => {
        if (!a)
          return;
        let l;
        for (let d = 0; d < s.length; d++)
          s[d][0] == a && (l = s[d][1]);
        qH(t, c).forEach((d) => {
          l || s.push([a, l = []]), l.indexOf(d) == -1 && l.push(d);
        });
      });
    });
    let o = e[r.join(",")] = new Mp(r.indexOf(t.length - 1) > -1);
    for (let i = 0; i < s.length; i++) {
      let a = s[i][1].sort(xie);
      o.next.push({ type: s[i][0], next: e[a.join(",")] || n(a) });
    }
    return o;
  }
}
function v9e(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let s = r[n], o = !s.validEnd, i = [];
    for (let a = 0; a < s.next.length; a++) {
      let { type: c, next: l } = s.next[a];
      i.push(c.name), o && !(c.isText || c.hasRequiredAttrs()) && (o = !1), r.indexOf(l) == -1 && r.push(l);
    }
    o && e.err("Only non-generatable nodes (" + i.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function wie(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function Sie(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let s = e && e[r];
    if (s === void 0) {
      let o = t[r];
      if (o.hasDefault)
        s = o.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = s;
  }
  return n;
}
function Cie(t, e, n, r) {
  for (let s in e)
    if (!(s in t))
      throw new RangeError(`Unsupported attribute ${s} for ${n} of type ${s}`);
  for (let s in t) {
    let o = t[s];
    o.validate && o.validate(e[s]);
  }
}
function _ie(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      n[r] = new x9e(t, r, e[r]);
  return n;
}
let XH = class Eie {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = _ie(e, r.attrs), this.defaultAttrs = wie(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Mp.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : Sie(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Zc(this, this.computeAttrs(e), Pe.from(n), Fn.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return n = Pe.from(n), this.checkContent(n), new Zc(this, this.computeAttrs(e), n, Fn.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (e = this.computeAttrs(e), n = Pe.from(n), n.size) {
      let i = this.contentMatch.fillBefore(n);
      if (!i)
        return null;
      n = i.append(n);
    }
    let s = this.contentMatch.matchFragment(n), o = s && s.fillBefore(Pe.empty, !0);
    return o ? new Zc(this, e, n.append(o), Fn.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    Cie(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
    return n ? n.length ? n : Fn.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((o, i) => r[o] = new Eie(o, n, i));
    let s = n.spec.topNode || "doc";
    if (!r[s])
      throw new RangeError("Schema is missing its top node type ('" + s + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function b9e(t, e, n) {
  let r = n.split("|");
  return (s) => {
    let o = s === null ? "null" : typeof s;
    if (r.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${o}`);
  };
}
class x9e {
  constructor(e, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? b9e(e, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class ZI {
  /**
  @internal
  */
  constructor(e, n, r, s) {
    this.name = e, this.rank = n, this.schema = r, this.spec = s, this.attrs = _ie(e, s.attrs), this.excluded = null;
    let o = wie(this.attrs);
    this.instance = o ? new Fn(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Fn(this, Sie(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), s = 0;
    return e.forEach((o, i) => r[o] = new ZI(o, s++, n, i)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    Cie(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class Tie {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let s in e)
      n[s] = e[s];
    n.nodes = qs.from(e.nodes), n.marks = qs.from(e.marks || {}), this.nodes = XH.compile(this.spec.nodes, this), this.marks = ZI.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in this.nodes) {
      if (s in this.marks)
        throw new RangeError(s + " can not be both a node and a mark");
      let o = this.nodes[s], i = o.spec.content || "", a = o.spec.marks;
      if (o.contentMatch = r[i] || (r[i] = Mp.parse(i, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = a == "_" ? null : a ? ZH(this, a.split(" ")) : a == "" || !o.inlineContent ? [] : null;
    }
    for (let s in this.marks) {
      let o = this.marks[s], i = o.spec.excludes;
      o.excluded = i == null ? [o] : i == "" ? [] : ZH(this, i.split(" "));
    }
    this.nodeFromJSON = (s) => Zc.fromJSON(this, s), this.markFromJSON = (s) => Fn.fromJSON(this, s), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, s) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof XH) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, s);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new qE(r, r.defaultAttrs, e, Fn.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function ZH(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let s = e[r], o = t.marks[s], i = o;
    if (o)
      n.push(o);
    else
      for (let a in t.marks) {
        let c = t.marks[a];
        (s == "_" || c.spec.group && c.spec.group.split(" ").indexOf(s) > -1) && n.push(i = c);
      }
    if (!i)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
function w9e(t) {
  return t.tag != null;
}
function S9e(t) {
  return t.style != null;
}
let km = class Ej {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((s) => {
      if (w9e(s))
        this.tags.push(s);
      else if (S9e(s)) {
        let o = /[^=]*/.exec(s.style)[0];
        r.indexOf(o) < 0 && r.push(o), this.styles.push(s);
      }
    }), this.normalizeLists = !this.tags.some((s) => {
      if (!/^(ul|ol)\b/.test(s.tag) || !s.node)
        return !1;
      let o = e.nodes[s.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new JH(this, n, !1);
    return r.addAll(e, Fn.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new JH(this, n, !0);
    return r.addAll(e, Fn.none, n.from, n.to), We.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let s = r ? this.tags.indexOf(r) + 1 : 0; s < this.tags.length; s++) {
      let o = this.tags[s];
      if (E9e(e, o.tag) && (o.namespace === void 0 || e.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
        if (o.getAttrs) {
          let i = o.getAttrs(e);
          if (i === !1)
            continue;
          o.attrs = i || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, s) {
    for (let o = s ? this.styles.indexOf(s) + 1 : 0; o < this.styles.length; o++) {
      let i = this.styles[o], a = i.style;
      if (!(a.indexOf(e) != 0 || i.context && !r.matchesContext(i.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (i.getAttrs) {
          let c = i.getAttrs(n);
          if (c === !1)
            continue;
          i.attrs = c || void 0;
        }
        return i;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(s) {
      let o = s.priority == null ? 50 : s.priority, i = 0;
      for (; i < n.length; i++) {
        let a = n[i];
        if ((a.priority == null ? 50 : a.priority) < o)
          break;
      }
      n.splice(i, 0, s);
    }
    for (let s in e.marks) {
      let o = e.marks[s].spec.parseDOM;
      o && o.forEach((i) => {
        r(i = e9(i)), i.mark || i.ignore || i.clearMark || (i.mark = s);
      });
    }
    for (let s in e.nodes) {
      let o = e.nodes[s].spec.parseDOM;
      o && o.forEach((i) => {
        r(i = e9(i)), i.node || i.ignore || i.mark || (i.node = s);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Ej(e, Ej.schemaRules(e)));
  }
};
const Pie = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, C9e = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, Iie = { ol: !0, ul: !0 }, hw = 1, Tj = 2, wx = 4;
function QH(t, e, n) {
  return e != null ? (e ? hw : 0) | (e === "full" ? Tj : 0) : t && t.whitespace == "pre" ? hw | Tj : n & ~wx;
}
class R1 {
  constructor(e, n, r, s, o, i) {
    this.type = e, this.attrs = n, this.marks = r, this.solid = s, this.options = i, this.content = [], this.activeMarks = Fn.none, this.match = o || (i & wx ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(Pe.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, s;
        return (s = r.findWrapping(e.type)) ? (this.match = r, s) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & hw)) {
      let r = this.content[this.content.length - 1], s;
      if (r && r.isText && (s = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let o = r;
        r.text.length == s[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - s[0].length));
      }
    }
    let n = Pe.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(Pe.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Pie.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class JH {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let s = n.topNode, o, i = QH(null, n.preserveWhitespace, 0) | (r ? wx : 0);
    s ? o = new R1(s.type, s.attrs, Fn.none, !0, n.topMatch || s.type.contentMatch, i) : r ? o = new R1(null, null, Fn.none, !0, null, i) : o = new R1(e.schema.topNodeType, null, Fn.none, !0, null, i), this.nodes = [o], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let r = e.nodeValue, s = this.top, o = s.options & Tj ? "full" : this.localPreserveWS || (s.options & hw) > 0, { schema: i } = this.parser;
    if (o === "full" || s.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (o)
        if (o === "full")
          r = r.replace(/\r\n?/g, `
`);
        else if (i.linebreakReplacement && /[\r\n]/.test(r) && this.top.findWrapping(i.linebreakReplacement.create())) {
          let a = r.split(/\r?\n|\r/);
          for (let c = 0; c < a.length; c++)
            c && this.insertNode(i.linebreakReplacement.create(), n, !0), a[c] && this.insertNode(i.text(a[c]), n, !/\S/.test(a[c]));
          r = "";
        } else
          r = r.replace(/\r?\n|\r/g, " ");
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let a = s.content[s.content.length - 1], c = e.previousSibling;
        (!a || c && c.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (r = r.slice(1));
      }
      r && this.insertNode(i.text(r), n, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, r) {
    let s = this.localPreserveWS, o = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let i = e.nodeName.toLowerCase(), a;
    Iie.hasOwnProperty(i) && this.parser.normalizeLists && _9e(e);
    let c = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, r));
    e: if (c ? c.ignore : C9e.hasOwnProperty(i))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!c || c.skip || c.closeParent) {
      c && c.closeParent ? this.open = Math.max(0, this.open - 1) : c && c.skip.nodeType && (e = c.skip);
      let l, d = this.needsBlock;
      if (Pie.hasOwnProperty(i))
        o.content.length && o.content[0].isInline && this.open && (this.open--, o = this.top), l = !0, o.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        break e;
      }
      let u = c && c.skip ? n : this.readStyles(e, n);
      u && this.addAll(e, u), l && this.sync(o), this.needsBlock = d;
    } else {
      let l = this.readStyles(e, n);
      l && this.addElementByRule(e, c, l, c.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = s;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let r = e.style;
    if (r && r.length)
      for (let s = 0; s < this.parser.matchedStyles.length; s++) {
        let o = this.parser.matchedStyles[s], i = r.getPropertyValue(o);
        if (i)
          for (let a = void 0; ; ) {
            let c = this.parser.matchStyle(o, i, this, a);
            if (!c)
              break;
            if (c.ignore)
              return null;
            if (c.clearMark ? n = n.filter((l) => !c.clearMark(l)) : n = n.concat(this.parser.schema.marks[c.mark].create(c.attrs)), c.consuming === !1)
              a = c;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r, s) {
    let o, i;
    if (n.node)
      if (i = this.parser.schema.nodes[n.node], i.isLeaf)
        this.insertNode(i.create(n.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let c = this.enter(i, n.attrs || null, r, n.preserveWhitespace);
        c && (o = !0, r = c);
      }
    else {
      let c = this.parser.schema.marks[n.mark];
      r = r.concat(c.create(n.attrs));
    }
    let a = this.top;
    if (i && i.isLeaf)
      this.findInside(e);
    else if (s)
      this.addElement(e, r, s);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((c) => this.insertNode(c, r, !1));
    else {
      let c = e;
      typeof n.contentElement == "string" ? c = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? c = n.contentElement(e) : n.contentElement && (c = n.contentElement), this.findAround(e, c, !0), this.addAll(c, r), this.findAround(e, c, !1);
    }
    o && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r, s) {
    let o = r || 0;
    for (let i = r ? e.childNodes[r] : e.firstChild, a = s == null ? null : e.childNodes[s]; i != a; i = i.nextSibling, ++o)
      this.findAtPoint(e, o), this.addDOM(i, n);
    this.findAtPoint(e, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n, r) {
    let s, o;
    for (let i = this.open, a = 0; i >= 0; i--) {
      let c = this.nodes[i], l = c.findWrapping(e);
      if (l && (!s || s.length > l.length + a) && (s = l, o = c, !l.length))
        break;
      if (c.solid) {
        if (r)
          break;
        a += 2;
      }
    }
    if (!s)
      return null;
    this.sync(o);
    for (let i = 0; i < s.length; i++)
      n = this.enterInner(s[i], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let o = this.textblockFromContext();
      o && (n = this.enterInner(o, null, n));
    }
    let s = this.findPlace(e, n, r);
    if (s) {
      this.closeExtra();
      let o = this.top;
      o.match && (o.match = o.match.matchType(e.type));
      let i = Fn.none;
      for (let a of s.concat(e.marks))
        (o.type ? o.type.allowsMarkType(a.type) : t9(a.type, e.type)) && (i = a.addToSet(i));
      return o.content.push(e.mark(i)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r, s) {
    let o = this.findPlace(e.create(n), r, !1);
    return o && (o = this.enterInner(e, n, r, !0, s)), o;
  }
  // Open a node of the given type
  enterInner(e, n, r, s = !1, o) {
    this.closeExtra();
    let i = this.top;
    i.match = i.match && i.match.matchType(e);
    let a = QH(e, o, i.options);
    i.options & wx && i.content.length == 0 && (a |= wx);
    let c = Fn.none;
    return r = r.filter((l) => (i.type ? i.type.allowsMarkType(l.type) : t9(l.type, e)) ? (c = l.addToSet(c), !1) : !0), this.nodes.push(new R1(e, n, c, s, null, a)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= hw);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let s = r.length - 1; s >= 0; s--)
        e += r[s].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let s = 0; s < this.find.length; s++)
        this.find[s].pos == null && e.nodeType == 1 && e.contains(this.find[s].node) && n.compareDocumentPosition(this.find[s].node) & (r ? 2 : 4) && (this.find[s].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, s = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), o = -(r ? r.depth + 1 : 0) + (s ? 0 : 1), i = (a, c) => {
      for (; a >= 0; a--) {
        let l = n[a];
        if (l == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; c >= o; c--)
            if (i(a - 1, c))
              return !0;
          return !1;
        } else {
          let d = c > 0 || c == 0 && s ? this.nodes[c].type : r && c >= o ? r.node(c - o).type : null;
          if (!d || d.name != l && !d.isInGroup(l))
            return !1;
          c--;
        }
      }
      return !0;
    };
    return i(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function _9e(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && Iie.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function E9e(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function e9(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function t9(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let s = n[r];
    if (!s.allowsMarkType(t))
      continue;
    let o = [], i = (a) => {
      o.push(a);
      for (let c = 0; c < a.edgeCount; c++) {
        let { type: l, next: d } = a.edge(c);
        if (l == e || o.indexOf(d) < 0 && i(d))
          return !0;
      }
    };
    if (i(s.contentMatch))
      return !0;
  }
}
class yg {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = mO(n).createDocumentFragment());
    let s = r, o = [];
    return e.forEach((i) => {
      if (o.length || i.marks.length) {
        let a = 0, c = 0;
        for (; a < o.length && c < i.marks.length; ) {
          let l = i.marks[c];
          if (!this.marks[l.type.name]) {
            c++;
            continue;
          }
          if (!l.eq(o[a][0]) || l.type.spec.spanning === !1)
            break;
          a++, c++;
        }
        for (; a < o.length; )
          s = o.pop()[1];
        for (; c < i.marks.length; ) {
          let l = i.marks[c++], d = this.serializeMark(l, i.isInline, n);
          d && (o.push([l, s]), s.appendChild(d.dom), s = d.contentDOM || d.dom);
        }
      }
      s.appendChild(this.serializeNodeInner(i, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: s } = i_(mO(n), this.nodes[e.type.name](e), null, e.attrs);
    if (s) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, s);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let s = e.marks.length - 1; s >= 0; s--) {
      let o = this.serializeMark(e.marks[s], e.isInline, n);
      o && ((o.contentDOM || o.dom).appendChild(r), r = o.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let s = this.marks[e.type.name];
    return s && i_(mO(r), s(e, n), null, e.attrs);
  }
  static renderSpec(e, n, r = null, s) {
    return i_(e, n, r, s);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new yg(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = n9(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return n9(e.marks);
  }
}
function n9(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function mO(t) {
  return t.document || window.document;
}
const r9 = /* @__PURE__ */ new WeakMap();
function T9e(t) {
  let e = r9.get(t);
  return e === void 0 && r9.set(t, e = P9e(t)), e;
}
function P9e(t) {
  let e = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let s = 0; s < r.length; s++)
            n(r[s]);
      else
        for (let s in r)
          n(r[s]);
  }
  return n(t), e;
}
function i_(t, e, n, r) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let s = e[0], o;
  if (typeof s != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (o = T9e(r)) && o.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let i = s.indexOf(" ");
  i > 0 && (n = s.slice(0, i), s = s.slice(i + 1));
  let a, c = n ? t.createElementNS(n, s) : t.createElement(s), l = e[1], d = 1;
  if (l && typeof l == "object" && l.nodeType == null && !Array.isArray(l)) {
    d = 2;
    for (let u in l)
      if (l[u] != null) {
        let f = u.indexOf(" ");
        f > 0 ? c.setAttributeNS(u.slice(0, f), u.slice(f + 1), l[u]) : u == "style" && c.style ? c.style.cssText = l[u] : c.setAttribute(u, l[u]);
      }
  }
  for (let u = d; u < e.length; u++) {
    let f = e[u];
    if (f === 0) {
      if (u < e.length - 1 || u > d)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: c, contentDOM: c };
    } else {
      let { dom: p, contentDOM: g } = i_(t, f, n, r);
      if (c.appendChild(p), g) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = g;
      }
    }
  }
  return { dom: c, contentDOM: a };
}
const kie = 65535, Aie = Math.pow(2, 16);
function I9e(t, e) {
  return t + e * Aie;
}
function s9(t) {
  return t & kie;
}
function k9e(t) {
  return (t - (t & kie)) / Aie;
}
const Mie = 1, Oie = 2, a_ = 4, Die = 8;
class Pj {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & Die) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (Mie | a_)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (Oie | a_)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & a_) > 0;
  }
}
class ia {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && ia.empty)
      return ia.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = s9(e);
    if (!this.inverted)
      for (let s = 0; s < r; s++)
        n += this.ranges[s * 3 + 2] - this.ranges[s * 3 + 1];
    return this.ranges[r * 3] + n + k9e(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let s = 0, o = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let c = this.ranges[a] - (this.inverted ? s : 0);
      if (c > e)
        break;
      let l = this.ranges[a + o], d = this.ranges[a + i], u = c + l;
      if (e <= u) {
        let f = l ? e == c ? -1 : e == u ? 1 : n : n, p = c + s + (f < 0 ? 0 : d);
        if (r)
          return p;
        let g = e == (n < 0 ? c : u) ? null : I9e(a / 3, e - c), y = e == c ? Oie : e == u ? Mie : a_;
        return (n < 0 ? e != c : e != u) && (y |= Die), new Pj(p, y, g);
      }
      s += d - l;
    }
    return r ? e + s : new Pj(e + s, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, s = s9(n), o = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let c = this.ranges[a] - (this.inverted ? r : 0);
      if (c > e)
        break;
      let l = this.ranges[a + o], d = c + l;
      if (e <= d && a == s * 3)
        return !0;
      r += this.ranges[a + i] - l;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let s = 0, o = 0; s < this.ranges.length; s += 3) {
      let i = this.ranges[s], a = i - (this.inverted ? o : 0), c = i + (this.inverted ? 0 : o), l = this.ranges[s + n], d = this.ranges[s + r];
      e(a, a + l, c, c + d), o += d - l;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new ia(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? ia.empty : new ia(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
ia.empty = new ia([]);
class pw {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, n, r = 0, s = e ? e.length : 0) {
    this.mirror = n, this.from = r, this.to = s, this._maps = e || [], this.ownData = !(e || n);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new pw(this._maps, this.mirror, e, n);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), n != null && this.setMirror(this._maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this._maps.length; n < e._maps.length; n++) {
      let s = e.getMirror(n);
      this.appendMap(e._maps[n], s != null && s < n ? r + s : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this._maps.length + e._maps.length; n >= 0; n--) {
      let s = e.getMirror(n);
      this.appendMap(e._maps[n].invert(), s != null && s > n ? r - s - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new pw();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let s = 0;
    for (let o = this.from; o < this.to; o++) {
      let i = this._maps[o], a = i.mapResult(e, n);
      if (a.recover != null) {
        let c = this.getMirror(o);
        if (c != null && c > o && c < this.to) {
          o = c, e = this._maps[c].recover(a.recover);
          continue;
        }
      }
      s |= a.delInfo, e = a.pos;
    }
    return r ? e : new Pj(e, s, null);
  }
}
const yO = /* @__PURE__ */ Object.create(null);
class Fo {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return ia.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = yO[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in yO)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return yO[e] = n, n.prototype.jsonID = e, n;
  }
}
class is {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new is(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new is(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, s) {
    try {
      return is.ok(e.replace(n, r, s));
    } catch (o) {
      if (o instanceof KE)
        return is.fail(o.message);
      throw o;
    }
  }
}
function j3(t, e, n) {
  let r = [];
  for (let s = 0; s < t.childCount; s++) {
    let o = t.child(s);
    o.content.size && (o = o.copy(j3(o.content, e, o))), o.isInline && (o = e(o, n, s)), r.push(o);
  }
  return Pe.fromArray(r);
}
class uf extends Fo {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), s = r.node(r.sharedDepth(this.to)), o = new We(j3(n.content, (i, a) => !i.isAtom || !a.type.allowsMarkType(this.mark.type) ? i : i.mark(this.mark.addToSet(i.marks)), s), n.openStart, n.openEnd);
    return is.fromReplace(e, this.from, this.to, o);
  }
  invert() {
    return new $l(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new uf(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof uf && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new uf(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new uf(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Fo.jsonID("addMark", uf);
class $l extends Fo {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new We(j3(n.content, (s) => s.mark(this.mark.removeFromSet(s.marks)), e), n.openStart, n.openEnd);
    return is.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new uf(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new $l(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof $l && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new $l(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new $l(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Fo.jsonID("removeMark", $l);
class ff extends Fo {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return is.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return is.fromReplace(e, this.pos, this.pos + 1, new We(Pe.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let s = 0; s < n.marks.length; s++)
          if (!n.marks[s].isInSet(r))
            return new ff(this.pos, n.marks[s]);
        return new ff(this.pos, this.mark);
      }
    }
    return new Op(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ff(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new ff(n.pos, e.markFromJSON(n.mark));
  }
}
Fo.jsonID("addNodeMark", ff);
class Op extends Fo {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return is.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return is.fromReplace(e, this.pos, this.pos + 1, new We(Pe.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new ff(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Op(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Op(n.pos, e.markFromJSON(n.mark));
  }
}
Fo.jsonID("removeNodeMark", Op);
class ks extends Fo {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, s = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = s;
  }
  apply(e) {
    return this.structure && Ij(e, this.from, this.to) ? is.fail("Structure replace would overwrite content") : is.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new ia([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new ks(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new ks(n.pos, Math.max(n.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof ks) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? We.empty : new We(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new ks(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? We.empty : new We(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new ks(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ks(n.from, n.to, We.fromJSON(e, n.slice), !!n.structure);
  }
}
Fo.jsonID("replace", ks);
class Ns extends Fo {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, s, o, i, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = s, this.slice = o, this.insert = i, this.structure = a;
  }
  apply(e) {
    if (this.structure && (Ij(e, this.from, this.gapFrom) || Ij(e, this.gapTo, this.to)))
      return is.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return is.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? is.fromReplace(e, this.from, this.to, r) : is.fail("Content does not fit in gap");
  }
  getMap() {
    return new ia([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new Ns(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), s = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), o = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || s < n.pos || o > r.pos ? null : new Ns(n.pos, r.pos, s, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Ns(n.from, n.to, n.gapFrom, n.gapTo, We.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
Fo.jsonID("replaceAround", Ns);
function Ij(t, e, n) {
  let r = t.resolve(e), s = n - e, o = r.depth;
  for (; s > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
    o--, s--;
  if (s > 0) {
    let i = r.node(o).maybeChild(r.indexAfter(o));
    for (; s > 0; ) {
      if (!i || i.isLeaf)
        return !0;
      i = i.firstChild, s--;
    }
  }
  return !1;
}
function A9e(t, e, n, r) {
  let s = [], o = [], i, a;
  t.doc.nodesBetween(e, n, (c, l, d) => {
    if (!c.isInline)
      return;
    let u = c.marks;
    if (!r.isInSet(u) && d.type.allowsMarkType(r.type)) {
      let f = Math.max(l, e), p = Math.min(l + c.nodeSize, n), g = r.addToSet(u);
      for (let y = 0; y < u.length; y++)
        u[y].isInSet(g) || (i && i.to == f && i.mark.eq(u[y]) ? i.to = p : s.push(i = new $l(f, p, u[y])));
      a && a.to == f ? a.to = p : o.push(a = new uf(f, p, r));
    }
  }), s.forEach((c) => t.step(c)), o.forEach((c) => t.step(c));
}
function M9e(t, e, n, r) {
  let s = [], o = 0;
  t.doc.nodesBetween(e, n, (i, a) => {
    if (!i.isInline)
      return;
    o++;
    let c = null;
    if (r instanceof ZI) {
      let l = i.marks, d;
      for (; d = r.isInSet(l); )
        (c || (c = [])).push(d), l = d.removeFromSet(l);
    } else r ? r.isInSet(i.marks) && (c = [r]) : c = i.marks;
    if (c && c.length) {
      let l = Math.min(a + i.nodeSize, n);
      for (let d = 0; d < c.length; d++) {
        let u = c[d], f;
        for (let p = 0; p < s.length; p++) {
          let g = s[p];
          g.step == o - 1 && u.eq(s[p].style) && (f = g);
        }
        f ? (f.to = l, f.step = o) : s.push({ style: u, from: Math.max(a, e), to: l, step: o });
      }
    }
  }), s.forEach((i) => t.step(new $l(i.from, i.to, i.style)));
}
function R3(t, e, n, r = n.contentMatch, s = !0) {
  let o = t.doc.nodeAt(e), i = [], a = e + 1;
  for (let c = 0; c < o.childCount; c++) {
    let l = o.child(c), d = a + l.nodeSize, u = r.matchType(l.type);
    if (!u)
      i.push(new ks(a, d, We.empty));
    else {
      r = u;
      for (let f = 0; f < l.marks.length; f++)
        n.allowsMarkType(l.marks[f].type) || t.step(new $l(a, d, l.marks[f]));
      if (s && l.isText && n.whitespace != "pre") {
        let f, p = /\r?\n|\r/g, g;
        for (; f = p.exec(l.text); )
          g || (g = new We(Pe.from(n.schema.text(" ", n.allowedMarks(l.marks))), 0, 0)), i.push(new ks(a + f.index, a + f.index + f[0].length, g));
      }
    }
    a = d;
  }
  if (!r.validEnd) {
    let c = r.fillBefore(Pe.empty, !0);
    t.replace(a, a, new We(c, 0, 0));
  }
  for (let c = i.length - 1; c >= 0; c--)
    t.step(i[c]);
}
function O9e(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function fv(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth, s = 0, o = 0; ; --r) {
    let i = t.$from.node(r), a = t.$from.index(r) + s, c = t.$to.indexAfter(r) - o;
    if (r < t.depth && i.canReplace(a, c, n))
      return r;
    if (r == 0 || i.type.spec.isolating || !O9e(i, a, c))
      break;
    a && (s = 1), c < i.childCount && (o = 1);
  }
  return null;
}
function D9e(t, e, n) {
  let { $from: r, $to: s, depth: o } = e, i = r.before(o + 1), a = s.after(o + 1), c = i, l = a, d = Pe.empty, u = 0;
  for (let g = o, y = !1; g > n; g--)
    y || r.index(g) > 0 ? (y = !0, d = Pe.from(r.node(g).copy(d)), u++) : c--;
  let f = Pe.empty, p = 0;
  for (let g = o, y = !1; g > n; g--)
    y || s.after(g + 1) < s.end(g) ? (y = !0, f = Pe.from(s.node(g).copy(f)), p++) : l++;
  t.step(new Ns(c, l, i, a, new We(d.append(f), u, p), d.size - u, !0));
}
function $3(t, e, n = null, r = t) {
  let s = N9e(t, e), o = s && j9e(r, e);
  return o ? s.map(o9).concat({ type: e, attrs: n }).concat(o.map(o9)) : null;
}
function o9(t) {
  return { type: t, attrs: null };
}
function N9e(t, e) {
  let { parent: n, startIndex: r, endIndex: s } = t, o = n.contentMatchAt(r).findWrapping(e);
  if (!o)
    return null;
  let i = o.length ? o[0] : e;
  return n.canReplaceWith(r, s, i) ? o : null;
}
function j9e(t, e) {
  let { parent: n, startIndex: r, endIndex: s } = t, o = n.child(r), i = e.contentMatch.findWrapping(o.type);
  if (!i)
    return null;
  let c = (i.length ? i[i.length - 1] : e).contentMatch;
  for (let l = r; c && l < s; l++)
    c = c.matchType(n.child(l).type);
  return !c || !c.validEnd ? null : i;
}
function R9e(t, e, n) {
  let r = Pe.empty;
  for (let i = n.length - 1; i >= 0; i--) {
    if (r.size) {
      let a = n[i].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = Pe.from(n[i].type.create(n[i].attrs, r));
  }
  let s = e.start, o = e.end;
  t.step(new Ns(s, o, s, o, new We(r, 0, 0), n.length, !0));
}
function $9e(t, e, n, r, s) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = t.steps.length;
  t.doc.nodesBetween(e, n, (i, a) => {
    let c = typeof s == "function" ? s(i) : s;
    if (i.isTextblock && !i.hasMarkup(r, c) && L9e(t.doc, t.mapping.slice(o).map(a), r)) {
      let l = null;
      if (r.schema.linebreakReplacement) {
        let p = r.whitespace == "pre", g = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        p && !g ? l = !1 : !p && g && (l = !0);
      }
      l === !1 && jie(t, i, a, o), R3(t, t.mapping.slice(o).map(a, 1), r, void 0, l === null);
      let d = t.mapping.slice(o), u = d.map(a, 1), f = d.map(a + i.nodeSize, 1);
      return t.step(new Ns(u, f, u + 1, f - 1, new We(Pe.from(r.create(c, null, i.marks)), 0, 0), 1, !0)), l === !0 && Nie(t, i, a, o), !1;
    }
  });
}
function Nie(t, e, n, r) {
  e.forEach((s, o) => {
    if (s.isText) {
      let i, a = /\r?\n|\r/g;
      for (; i = a.exec(s.text); ) {
        let c = t.mapping.slice(r).map(n + 1 + o + i.index);
        t.replaceWith(c, c + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function jie(t, e, n, r) {
  e.forEach((s, o) => {
    if (s.type == s.type.schema.linebreakReplacement) {
      let i = t.mapping.slice(r).map(n + 1 + o);
      t.replaceWith(i, i + 1, e.type.schema.text(`
`));
    }
  });
}
function L9e(t, e, n) {
  let r = t.resolve(e), s = r.index();
  return r.parent.canReplaceWith(s, s + 1, n);
}
function F9e(t, e, n, r, s) {
  let o = t.doc.nodeAt(e);
  if (!o)
    throw new RangeError("No node at given position");
  n || (n = o.type);
  let i = n.create(r, null, s || o.marks);
  if (o.isLeaf)
    return t.replaceWith(e, e + o.nodeSize, i);
  if (!n.validContent(o.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new Ns(e, e + o.nodeSize, e + 1, e + o.nodeSize - 1, new We(Pe.from(i), 0, 0), 1, !0));
}
function Am(t, e, n = 1, r) {
  let s = t.resolve(e), o = s.depth - n, i = r && r[r.length - 1] || s.parent;
  if (o < 0 || s.parent.type.spec.isolating || !s.parent.canReplace(s.index(), s.parent.childCount) || !i.type.validContent(s.parent.content.cutByIndex(s.index(), s.parent.childCount)))
    return !1;
  for (let l = s.depth - 1, d = n - 2; l > o; l--, d--) {
    let u = s.node(l), f = s.index(l);
    if (u.type.spec.isolating)
      return !1;
    let p = u.content.cutByIndex(f, u.childCount), g = r && r[d + 1];
    g && (p = p.replaceChild(0, g.type.create(g.attrs)));
    let y = r && r[d] || u;
    if (!u.canReplace(f + 1, u.childCount) || !y.type.validContent(p))
      return !1;
  }
  let a = s.indexAfter(o), c = r && r[0];
  return s.node(o).canReplaceWith(a, a, c ? c.type : s.node(o + 1).type);
}
function B9e(t, e, n = 1, r) {
  let s = t.doc.resolve(e), o = Pe.empty, i = Pe.empty;
  for (let a = s.depth, c = s.depth - n, l = n - 1; a > c; a--, l--) {
    o = Pe.from(s.node(a).copy(o));
    let d = r && r[l];
    i = Pe.from(d ? d.type.create(d.attrs, i) : s.node(a).copy(i));
  }
  t.step(new ks(e, e, new We(o.append(i), n, n), !0));
}
function rh(t, e) {
  let n = t.resolve(e), r = n.index();
  return Rie(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function z9e(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: r } = t.type.schema;
  for (let s = 0; s < e.childCount; s++) {
    let o = e.child(s), i = o.type == r ? t.type.schema.nodes.text : o.type;
    if (n = n.matchType(i), !n || !t.type.allowsMarks(o.marks))
      return !1;
  }
  return n.validEnd;
}
function Rie(t, e) {
  return !!(t && e && !t.isLeaf && z9e(t, e));
}
function QI(t, e, n = -1) {
  let r = t.resolve(e);
  for (let s = r.depth; ; s--) {
    let o, i, a = r.index(s);
    if (s == r.depth ? (o = r.nodeBefore, i = r.nodeAfter) : n > 0 ? (o = r.node(s + 1), a++, i = r.node(s).maybeChild(a)) : (o = r.node(s).maybeChild(a - 1), i = r.node(s + 1)), o && !o.isTextblock && Rie(o, i) && r.node(s).canReplace(a, a + 1))
      return e;
    if (s == 0)
      break;
    e = n < 0 ? r.before(s) : r.after(s);
  }
}
function U9e(t, e, n) {
  let r = null, { linebreakReplacement: s } = t.doc.type.schema, o = t.doc.resolve(e - n), i = o.node().type;
  if (s && i.inlineContent) {
    let d = i.whitespace == "pre", u = !!i.contentMatch.matchType(s);
    d && !u ? r = !1 : !d && u && (r = !0);
  }
  let a = t.steps.length;
  if (r === !1) {
    let d = t.doc.resolve(e + n);
    jie(t, d.node(), d.before(), a);
  }
  i.inlineContent && R3(t, e + n - 1, i, o.node().contentMatchAt(o.index()), r == null);
  let c = t.mapping.slice(a), l = c.map(e - n);
  if (t.step(new ks(l, c.map(e + n, -1), We.empty, !0)), r === !0) {
    let d = t.doc.resolve(l);
    Nie(t, d.node(), d.before(), t.steps.length);
  }
  return t;
}
function H9e(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let s = r.depth - 1; s >= 0; s--) {
      let o = r.index(s);
      if (r.node(s).canReplaceWith(o, o, n))
        return r.before(s + 1);
      if (o > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let s = r.depth - 1; s >= 0; s--) {
      let o = r.indexAfter(s);
      if (r.node(s).canReplaceWith(o, o, n))
        return r.after(s + 1);
      if (o < r.node(s).childCount)
        return null;
    }
  return null;
}
function $ie(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let s = n.content;
  for (let o = 0; o < n.openStart; o++)
    s = s.firstChild.content;
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
    for (let i = r.depth; i >= 0; i--) {
      let a = i == r.depth ? 0 : r.pos <= (r.start(i + 1) + r.end(i + 1)) / 2 ? -1 : 1, c = r.index(i) + (a > 0 ? 1 : 0), l = r.node(i), d = !1;
      if (o == 1)
        d = l.canReplace(c, c, s);
      else {
        let u = l.contentMatchAt(c).findWrapping(s.firstChild.type);
        d = u && l.canReplaceWith(c, c, u[0]);
      }
      if (d)
        return a == 0 ? r.pos : a < 0 ? r.before(i + 1) : r.after(i + 1);
    }
  return null;
}
function JI(t, e, n = e, r = We.empty) {
  if (e == n && !r.size)
    return null;
  let s = t.resolve(e), o = t.resolve(n);
  return Lie(s, o, r) ? new ks(e, n, r) : new V9e(s, o, r).fit();
}
function Lie(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class V9e {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = Pe.empty;
    for (let s = 0; s <= e.depth; s++) {
      let o = e.node(s);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(e.indexAfter(s))
      });
    }
    for (let s = e.depth; s > 0; s--)
      this.placed = Pe.from(e.node(s).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let l = this.findFittable();
      l ? this.placeNodes(l) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, s = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!s)
      return null;
    let o = this.placed, i = r.depth, a = s.depth;
    for (; i && a && o.childCount == 1; )
      o = o.firstChild.content, i--, a--;
    let c = new We(o, i, a);
    return e > -1 ? new Ns(r.pos, e, this.$to.pos, this.$to.end(), c, n) : c.size || r.pos != this.$to.pos ? new ks(r.pos, s.pos, c) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, s = this.unplaced.openEnd; r < e; r++) {
      let o = n.firstChild;
      if (n.childCount > 1 && (s = 0), o.type.spec.isolating && s <= r) {
        e = r;
        break;
      }
      n = o.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let s, o = null;
        r ? (o = vO(this.unplaced.content, r - 1).firstChild, s = o.content) : s = this.unplaced.content;
        let i = s.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: c, match: l } = this.frontier[a], d, u = null;
          if (n == 1 && (i ? l.matchType(i.type) || (u = l.fillBefore(Pe.from(i), !1)) : o && c.compatibleContent(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, inject: u };
          if (n == 2 && i && (d = l.findWrapping(i.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, wrap: d };
          if (o && l.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, s = vO(e, n);
    return !s.childCount || s.firstChild.isLeaf ? !1 : (this.unplaced = new We(e, n + 1, Math.max(r, s.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, s = vO(e, n);
    if (s.childCount <= 1 && n > 0) {
      let o = e.size - n <= n + s.size;
      this.unplaced = new We($b(e, n - 1, 1), n - 1, o ? n - 1 : r);
    } else
      this.unplaced = new We($b(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: s, wrap: o }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (o)
      for (let y = 0; y < o.length; y++)
        this.openFrontierNode(o[y]);
    let i = this.unplaced, a = r ? r.content : i.content, c = i.openStart - e, l = 0, d = [], { match: u, type: f } = this.frontier[n];
    if (s) {
      for (let y = 0; y < s.childCount; y++)
        d.push(s.child(y));
      u = u.matchFragment(s);
    }
    let p = a.size + e - (i.content.size - i.openEnd);
    for (; l < a.childCount; ) {
      let y = a.child(l), m = u.matchType(y.type);
      if (!m)
        break;
      l++, (l > 1 || c == 0 || y.content.size) && (u = m, d.push(Fie(y.mark(f.allowedMarks(y.marks)), l == 1 ? c : 0, l == a.childCount ? p : -1)));
    }
    let g = l == a.childCount;
    g || (p = -1), this.placed = Lb(this.placed, n, Pe.from(d)), this.frontier[n].match = u, g && p < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let y = 0, m = a; y < p; y++) {
      let v = m.lastChild;
      this.frontier.push({ type: v.type, match: v.contentMatchAt(v.childCount) }), m = v.content;
    }
    this.unplaced = g ? e == 0 ? We.empty : new We($b(i.content, e - 1, 1), e - 1, p < 0 ? i.openEnd : e - 1) : new We($b(i.content, e, l), i.openStart, i.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !bO(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, s = this.$to.after(r);
    for (; r > 1 && s == this.$to.end(--r); )
      ++s;
    return s;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: r, type: s } = this.frontier[n], o = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), i = bO(e, n, s, r, o);
      if (i) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: c, type: l } = this.frontier[a], d = bO(e, a, l, c, !0);
          if (!d || d.childCount)
            continue e;
        }
        return { depth: n, fit: i, move: o ? e.doc.resolve(e.after(n + 1)) : e };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = Lb(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let s = e.node(r), o = s.type.contentMatch.fillBefore(s.content, !0, e.index(r));
      this.openFrontierNode(s.type, s.attrs, o);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let s = this.frontier[this.depth];
    s.match = s.match.matchType(e), this.placed = Lb(this.placed, this.depth, Pe.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(Pe.empty, !0);
    n.childCount && (this.placed = Lb(this.placed, this.frontier.length, n));
  }
}
function $b(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy($b(t.firstChild.content, e - 1, n)));
}
function Lb(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Lb(t.lastChild.content, e - 1, n)));
}
function vO(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function Fie(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, Fie(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(Pe.empty, !0)))), t.copy(r);
}
function bO(t, e, n, r, s) {
  let o = t.node(e), i = s ? t.indexAfter(e) : t.index(e);
  if (i == o.childCount && !n.compatibleContent(o.type))
    return null;
  let a = r.fillBefore(o.content, !0, i);
  return a && !W9e(n, o.content, i) ? a : null;
}
function W9e(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function K9e(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function G9e(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let s = t.doc.resolve(e), o = t.doc.resolve(n);
  if (Lie(s, o, r))
    return t.step(new ks(e, n, r));
  let i = zie(s, o);
  i[i.length - 1] == 0 && i.pop();
  let a = -(s.depth + 1);
  i.unshift(a);
  for (let f = s.depth, p = s.pos - 1; f > 0; f--, p--) {
    let g = s.node(f).type.spec;
    if (g.defining || g.definingAsContext || g.isolating)
      break;
    i.indexOf(f) > -1 ? a = f : s.before(f) == p && i.splice(1, 0, -f);
  }
  let c = i.indexOf(a), l = [], d = r.openStart;
  for (let f = r.content, p = 0; ; p++) {
    let g = f.firstChild;
    if (l.push(g), p == r.openStart)
      break;
    f = g.content;
  }
  for (let f = d - 1; f >= 0; f--) {
    let p = l[f], g = K9e(p.type);
    if (g && !p.sameMarkup(s.node(Math.abs(a) - 1)))
      d = f;
    else if (g || !p.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let p = (f + d + 1) % (r.openStart + 1), g = l[p];
    if (g)
      for (let y = 0; y < i.length; y++) {
        let m = i[(y + c) % i.length], v = !0;
        m < 0 && (v = !1, m = -m);
        let b = s.node(m - 1), x = s.index(m - 1);
        if (b.canReplaceWith(x, x, g.type, g.marks))
          return t.replace(s.before(m), v ? o.after(m) : n, new We(Bie(r.content, 0, r.openStart, p), p, r.openEnd));
      }
  }
  let u = t.steps.length;
  for (let f = i.length - 1; f >= 0 && (t.replace(e, n, r), !(t.steps.length > u)); f--) {
    let p = i[f];
    p < 0 || (e = s.before(p), n = o.after(p));
  }
}
function Bie(t, e, n, r, s) {
  if (e < n) {
    let o = t.firstChild;
    t = t.replaceChild(0, o.copy(Bie(o.content, e + 1, n, r, o)));
  }
  if (e > r) {
    let o = s.contentMatchAt(0), i = o.fillBefore(t).append(t);
    t = i.append(o.matchFragment(i).fillBefore(Pe.empty, !0));
  }
  return t;
}
function Y9e(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let s = H9e(t.doc, e, r.type);
    s != null && (e = n = s);
  }
  t.replaceRange(e, n, new We(Pe.from(r), 0, 0));
}
function q9e(t, e, n) {
  let r = t.doc.resolve(e), s = t.doc.resolve(n), o = zie(r, s);
  for (let i = 0; i < o.length; i++) {
    let a = o[i], c = i == o.length - 1;
    if (c && a == 0 || r.node(a).type.contentMatch.validEnd)
      return t.delete(r.start(a), s.end(a));
    if (a > 0 && (c || r.node(a - 1).canReplace(r.index(a - 1), s.indexAfter(a - 1))))
      return t.delete(r.before(a), s.after(a));
  }
  for (let i = 1; i <= r.depth && i <= s.depth; i++)
    if (e - r.start(i) == r.depth - i && n > r.end(i) && s.end(i) - n != s.depth - i && r.start(i - 1) == s.start(i - 1) && r.node(i - 1).canReplace(r.index(i - 1), s.index(i - 1)))
      return t.delete(r.before(i), n);
  t.delete(e, n);
}
function zie(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let s = r; s >= 0; s--) {
    let o = t.start(s);
    if (o < t.pos - (t.depth - s) || e.end(s) > e.pos + (e.depth - s) || t.node(s).type.spec.isolating || e.node(s).type.spec.isolating)
      break;
    (o == e.start(s) || s == t.depth && s == e.depth && t.parent.inlineContent && e.parent.inlineContent && s && e.start(s - 1) == o - 1) && n.push(s);
  }
  return n;
}
class Mm extends Fo {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return is.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in n.attrs)
      r[o] = n.attrs[o];
    r[this.attr] = this.value;
    let s = n.type.create(r, null, n.marks);
    return is.fromReplace(e, this.pos, this.pos + 1, new We(Pe.from(s), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return ia.empty;
  }
  invert(e) {
    return new Mm(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Mm(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Mm(n.pos, n.attr, n.value);
  }
}
Fo.jsonID("attr", Mm);
class gw extends Fo {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let s in e.attrs)
      n[s] = e.attrs[s];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return is.ok(r);
  }
  getMap() {
    return ia.empty;
  }
  invert(e) {
    return new gw(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new gw(n.attr, n.value);
  }
}
Fo.jsonID("docAttr", gw);
let uy = class extends Error {
};
uy = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
uy.prototype = Object.create(Error.prototype);
uy.prototype.constructor = uy;
uy.prototype.name = "TransformError";
let Uie = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new pw();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new uy(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  Return a single range, in post-transform document positions,
  that covers all content changed by this transform. Returns null
  if no replacements are made. Note that this will ignore changes
  that add/remove marks without replacing the underlying content.
  */
  changedRange() {
    let e = 1e9, n = -1e9;
    for (let r = 0; r < this.mapping.maps.length; r++) {
      let s = this.mapping.maps[r];
      r && (e = s.map(e, 1), n = s.map(n, -1)), s.forEach((o, i, a, c) => {
        e = Math.min(e, a), n = Math.max(n, c);
      });
    }
    return e == 1e9 ? null : { from: e, to: n };
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = We.empty) {
    let s = JI(this.doc, e, n, r);
    return s && this.step(s), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new We(Pe.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, We.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return G9e(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return Y9e(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return q9e(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return D9e(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return U9e(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return R9e(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, s = null) {
    return $9e(this, e, n, r, s), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, s) {
    return F9e(this, e, n, r, s), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new Mm(e, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new gw(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new ff(e, n)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (n instanceof Fn)
      n.isInSet(r.marks) && this.step(new Op(e, n));
    else {
      let s = r.marks, o, i = [];
      for (; o = n.isInSet(s); )
        i.push(new Op(e, o)), s = o.removeFromSet(s);
      for (let a = i.length - 1; a >= 0; a--)
        this.step(i[a]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, n = 1, r) {
    return B9e(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return A9e(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return M9e(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return R3(this, e, n, r), this;
  }
};
const xO = /* @__PURE__ */ Object.create(null);
let Ht = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    this.$anchor = e, this.$head = n, this.ranges = r || [new X9e(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = We.empty) {
    let r = n.content.lastChild, s = null;
    for (let a = 0; a < n.openEnd; a++)
      s = r, r = r.lastChild;
    let o = e.steps.length, i = this.ranges;
    for (let a = 0; a < i.length; a++) {
      let { $from: c, $to: l } = i[a], d = e.mapping.slice(o);
      e.replaceRange(d.map(c.pos), d.map(l.pos), a ? We.empty : n), a == 0 && c9(e, o, (r ? r.isInline : s && s.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length, s = this.ranges;
    for (let o = 0; o < s.length; o++) {
      let { $from: i, $to: a } = s[o], c = e.mapping.slice(r), l = c.map(i.pos), d = c.map(a.pos);
      o ? e.deleteRange(l, d) : (e.replaceRangeWith(l, d, n), c9(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let s = e.parent.inlineContent ? new Dt(e) : em(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (s)
      return s;
    for (let o = e.depth - 1; o >= 0; o--) {
      let i = n < 0 ? em(e.node(0), e.node(o), e.before(o + 1), e.index(o), n, r) : em(e.node(0), e.node(o), e.after(o + 1), e.index(o) + 1, n, r);
      if (i)
        return i;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new oc(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return em(e, e, 0, 0, 1) || new oc(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return em(e, e, e.content.size, e.childCount, -1) || new oc(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = xO[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in xO)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return xO[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Dt.between(this.$anchor, this.$head).getBookmark();
  }
};
Ht.prototype.visible = !0;
class X9e {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let i9 = !1;
function a9(t) {
  !i9 && !t.parent.inlineContent && (i9 = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class Dt extends Ht {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    a9(e), a9(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return Ht.near(r);
    let s = e.resolve(n.map(this.anchor));
    return new Dt(s.parent.inlineContent ? s : r, r);
  }
  replace(e, n = We.empty) {
    if (super.replace(e, n), n == We.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof Dt && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new ek(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Dt(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let s = e.resolve(n);
    return new this(s, r == n ? s : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let s = e.pos - n.pos;
    if ((!r || s) && (r = s >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let o = Ht.findFrom(n, r, !0) || Ht.findFrom(n, -r, !0);
      if (o)
        n = o.$head;
      else
        return Ht.near(n, r);
    }
    return e.parent.inlineContent || (s == 0 ? e = n : (e = (Ht.findFrom(e, -r, !0) || Ht.findFrom(e, r, !0)).$anchor, e.pos < n.pos != s < 0 && (e = n))), new Dt(e, n);
  }
}
Ht.jsonID("text", Dt);
class ek {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new ek(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Dt.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ht extends Ht {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), this.node = n;
  }
  map(e, n) {
    let { deleted: r, pos: s } = n.mapResult(this.anchor), o = e.resolve(s);
    return r ? Ht.near(o) : new ht(o);
  }
  content() {
    return new We(Pe.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ht && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new L3(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ht(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new ht(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ht.prototype.visible = !1;
Ht.jsonID("node", ht);
class L3 {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new ek(r, r) : new L3(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), r = n.nodeAfter;
    return r && ht.isSelectable(r) ? new ht(n) : Ht.near(n);
  }
}
class oc extends Ht {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = We.empty) {
    if (n == We.empty) {
      e.delete(0, e.doc.content.size);
      let r = Ht.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new oc(e);
  }
  map(e) {
    return new oc(e);
  }
  eq(e) {
    return e instanceof oc;
  }
  getBookmark() {
    return Z9e;
  }
}
Ht.jsonID("all", oc);
const Z9e = {
  map() {
    return this;
  },
  resolve(t) {
    return new oc(t);
  }
};
function em(t, e, n, r, s, o = !1) {
  if (e.inlineContent)
    return Dt.create(t, n);
  for (let i = r - (s > 0 ? 0 : 1); s > 0 ? i < e.childCount : i >= 0; i += s) {
    let a = e.child(i);
    if (a.isAtom) {
      if (!o && ht.isSelectable(a))
        return ht.create(t, n - (s < 0 ? a.nodeSize : 0));
    } else {
      let c = em(t, a, n + s, s < 0 ? a.childCount : 0, s, o);
      if (c)
        return c;
    }
    n += a.nodeSize * s;
  }
  return null;
}
function c9(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e)
    return;
  let s = t.steps[r];
  if (!(s instanceof ks || s instanceof Ns))
    return;
  let o = t.mapping.maps[r], i;
  o.forEach((a, c, l, d) => {
    i == null && (i = d);
  }), t.setSelection(Ht.near(t.doc.resolve(i), n));
}
const l9 = 1, $1 = 2, d9 = 4;
class Q9e extends Uie {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | l9) & ~$1, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & l9) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= $1, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Fn.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & $1) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~$1, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Fn.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let s = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(s.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), !e)
        return this.deleteRange(n, r);
      let o = this.storedMarks;
      if (!o) {
        let i = this.doc.resolve(n);
        o = r == n ? i.marks() : i.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, s.text(e, o)), !this.selection.empty && this.selection.to == n + e.length && this.setSelection(Ht.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= d9, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & d9) > 0;
  }
}
function u9(t, e) {
  return !e || !t ? t : t.bind(e);
}
class Fb {
  constructor(e, n, r) {
    this.name = e, this.init = u9(n.init, r), this.apply = u9(n.apply, r);
  }
}
const J9e = [
  new Fb("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new Fb("selection", {
    init(t, e) {
      return t.selection || Ht.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new Fb("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new Fb("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class wO {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = J9e.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Fb(r.key, r.spec.state, r));
    });
  }
}
class hm {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let s = this.config.plugins[r];
        if (s.spec.filterTransaction && !s.spec.filterTransaction.call(s, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], r = this.applyInner(e), s = null;
    for (; ; ) {
      let o = !1;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let a = this.config.plugins[i];
        if (a.spec.appendTransaction) {
          let c = s ? s[i].n : 0, l = s ? s[i].state : this, d = c < n.length && a.spec.appendTransaction.call(a, c ? n.slice(c) : n, l, r);
          if (d && r.filterTransaction(d, i)) {
            if (d.setMeta("appendedTransaction", e), !s) {
              s = [];
              for (let u = 0; u < this.config.plugins.length; u++)
                s.push(u < i ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(d), r = r.applyInner(d), o = !0;
          }
          s && (s[i] = { state: r, n: n.length });
        }
      }
      if (!o)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new hm(this.config), r = this.config.fields;
    for (let s = 0; s < r.length; s++) {
      let o = r[s];
      n[o.name] = o.apply(e, this[o.name], this, n);
    }
    return n;
  }
  /**
  Accessor that constructs and returns a new [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Q9e(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new wO(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new hm(n);
    for (let s = 0; s < n.fields.length; s++)
      r[n.fields[s].name] = n.fields[s].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new wO(this.schema, e.plugins), r = n.fields, s = new hm(n);
    for (let o = 0; o < r.length; o++) {
      let i = r[o].name;
      s[i] = this.hasOwnProperty(i) ? this[i] : r[o].init(e, s);
    }
    return s;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let s = e[r], o = s.spec.state;
        o && o.toJSON && (n[r] = o.toJSON.call(s, this[s.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let s = new wO(e.schema, e.plugins), o = new hm(s);
    return s.fields.forEach((i) => {
      if (i.name == "doc")
        o.doc = Zc.fromJSON(e.schema, n.doc);
      else if (i.name == "selection")
        o.selection = Ht.fromJSON(o.doc, n.selection);
      else if (i.name == "storedMarks")
        n.storedMarks && (o.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let c = r[a], l = c.spec.state;
            if (c.key == i.name && l && l.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              o[i.name] = l.fromJSON.call(c, e, n[a], o);
              return;
            }
          }
        o[i.name] = i.init(e, o);
      }
    }), o;
  }
}
function Hie(t, e, n) {
  for (let r in t) {
    let s = t[r];
    s instanceof Function ? s = s.bind(e) : r == "handleDOMEvents" && (s = Hie(s, e, {})), n[r] = s;
  }
  return n;
}
class fo {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && Hie(e.props, this, this.props), this.key = e.key ? e.key.key : Vie("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const SO = /* @__PURE__ */ Object.create(null);
function Vie(t) {
  return t in SO ? t + "$" + ++SO[t] : (SO[t] = 0, t + "$");
}
class Oa {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = Vie(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const to = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, fy = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let kj = null;
const Rd = function(t, e, n) {
  let r = kj || (kj = document.createRange());
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
}, eVe = function() {
  kj = null;
}, Dp = function(t, e, n, r) {
  return n && (f9(t, e, n, r, -1) || f9(t, e, n, r, 1));
}, tVe = /^(img|br|input|textarea|hr)$/i;
function f9(t, e, n, r, s) {
  for (var o; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (s < 0 ? 0 : Qa(t))) {
      let i = t.parentNode;
      if (!i || i.nodeType != 1 || cS(t) || tVe.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = to(t) + (s < 0 ? 0 : 1), t = i;
    } else if (t.nodeType == 1) {
      let i = t.childNodes[e + (s < 0 ? -1 : 0)];
      if (i.nodeType == 1 && i.contentEditable == "false")
        if (!((o = i.pmViewDesc) === null || o === void 0) && o.ignoreForSelection)
          e += s;
        else
          return !1;
      else
        t = i, e = s < 0 ? Qa(t) : 0;
    } else
      return !1;
  }
}
function Qa(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function nVe(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = Qa(t);
    } else if (t.parentNode && !cS(t))
      e = to(t), t = t.parentNode;
    else
      return null;
  }
}
function rVe(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !cS(t))
      e = to(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function sVe(t, e, n) {
  for (let r = e == 0, s = e == Qa(t); r || s; ) {
    if (t == n)
      return !0;
    let o = to(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && o == 0, s = s && o == Qa(t);
  }
}
function cS(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const tk = function(t) {
  return t.focusNode && Dp(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function jh(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function oVe(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function iVe(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(Qa(r.offsetNode), r.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(Qa(r.startContainer), r.startOffset) };
  }
}
const Zl = typeof navigator < "u" ? navigator : null, h9 = typeof document < "u" ? document : null, sh = Zl && Zl.userAgent || "", Aj = /Edge\/(\d+)/.exec(sh), Wie = /MSIE \d/.exec(sh), Mj = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(sh), zi = !!(Wie || Mj || Aj), wf = Wie ? document.documentMode : Mj ? +Mj[1] : Aj ? +Aj[1] : 0, ic = !zi && /gecko\/(\d+)/i.test(sh);
ic && +(/Firefox\/(\d+)/.exec(sh) || [0, 0])[1];
const Oj = !zi && /Chrome\/(\d+)/.exec(sh), Os = !!Oj, Kie = Oj ? +Oj[1] : 0, ao = !zi && !!Zl && /Apple Computer/.test(Zl.vendor), hy = ao && (/Mobile\/\w+/.test(sh) || !!Zl && Zl.maxTouchPoints > 2), Ga = hy || (Zl ? /Mac/.test(Zl.platform) : !1), Gie = Zl ? /Win/.test(Zl.platform) : !1, Wd = /Android \d/.test(sh), lS = !!h9 && "webkitFontSmoothing" in h9.documentElement.style, aVe = lS ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function cVe(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function xd(t, e) {
  return typeof t == "number" ? t : t[e];
}
function lVe(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  };
}
function p9(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0, s = t.someProp("scrollMargin") || 5, o = t.dom.ownerDocument;
  for (let i = n || t.dom; i; ) {
    if (i.nodeType != 1) {
      i = fy(i);
      continue;
    }
    let a = i, c = a == o.body, l = c ? cVe(o) : lVe(a), d = 0, u = 0;
    if (e.top < l.top + xd(r, "top") ? u = -(l.top - e.top + xd(s, "top")) : e.bottom > l.bottom - xd(r, "bottom") && (u = e.bottom - e.top > l.bottom - l.top ? e.top + xd(s, "top") - l.top : e.bottom - l.bottom + xd(s, "bottom")), e.left < l.left + xd(r, "left") ? d = -(l.left - e.left + xd(s, "left")) : e.right > l.right - xd(r, "right") && (d = e.right - l.right + xd(s, "right")), d || u)
      if (c)
        o.defaultView.scrollBy(d, u);
      else {
        let p = a.scrollLeft, g = a.scrollTop;
        u && (a.scrollTop += u), d && (a.scrollLeft += d);
        let y = a.scrollLeft - p, m = a.scrollTop - g;
        e = { left: e.left - y, top: e.top - m, right: e.right - y, bottom: e.bottom - m };
      }
    let f = c ? "fixed" : getComputedStyle(i).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    i = f == "absolute" ? i.offsetParent : fy(i);
  }
}
function dVe(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, s;
  for (let o = (e.left + e.right) / 2, i = n + 1; i < Math.min(innerHeight, e.bottom); i += 5) {
    let a = t.root.elementFromPoint(o, i);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let c = a.getBoundingClientRect();
    if (c.top >= n - 20) {
      r = a, s = c.top;
      break;
    }
  }
  return { refDOM: r, refTop: s, stack: Yie(t.dom) };
}
function Yie(t) {
  let e = [], n = t.ownerDocument;
  for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = fy(r))
    ;
  return e;
}
function uVe({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  qie(n, r == 0 ? 0 : r - e);
}
function qie(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: s, left: o } = t[n];
    r.scrollTop != s + e && (r.scrollTop = s + e), r.scrollLeft != o && (r.scrollLeft = o);
  }
}
let Fg = null;
function fVe(t) {
  if (t.setActive)
    return t.setActive();
  if (Fg)
    return t.focus(Fg);
  let e = Yie(t);
  t.focus(Fg == null ? {
    get preventScroll() {
      return Fg = { preventScroll: !0 }, !0;
    }
  } : void 0), Fg || (Fg = !1, qie(e, 0));
}
function Xie(t, e) {
  let n, r = 2e8, s, o = 0, i = e.top, a = e.top, c, l;
  for (let d = t.firstChild, u = 0; d; d = d.nextSibling, u++) {
    let f;
    if (d.nodeType == 1)
      f = d.getClientRects();
    else if (d.nodeType == 3)
      f = Rd(d).getClientRects();
    else
      continue;
    for (let p = 0; p < f.length; p++) {
      let g = f[p];
      if (g.top <= i && g.bottom >= a) {
        i = Math.max(g.bottom, i), a = Math.min(g.top, a);
        let y = g.left > e.left ? g.left - e.left : g.right < e.left ? e.left - g.right : 0;
        if (y < r) {
          n = d, r = y, s = y && n.nodeType == 3 ? {
            left: g.right < e.left ? g.right : g.left,
            top: e.top
          } : e, d.nodeType == 1 && y && (o = u + (e.left >= (g.left + g.right) / 2 ? 1 : 0));
          continue;
        }
      } else g.top > e.top && !c && g.left <= e.left && g.right >= e.left && (c = d, l = { left: Math.max(g.left, Math.min(g.right, e.left)), top: g.top });
      !n && (e.left >= g.right && e.top >= g.top || e.left >= g.left && e.top >= g.bottom) && (o = u + 1);
    }
  }
  return !n && c && (n = c, s = l, r = 0), n && n.nodeType == 3 ? hVe(n, s) : !n || r && n.nodeType == 1 ? { node: t, offset: o } : Xie(n, s);
}
function hVe(t, e) {
  let n = t.nodeValue.length, r = document.createRange(), s;
  for (let o = 0; o < n; o++) {
    r.setEnd(t, o + 1), r.setStart(t, o);
    let i = zu(r, 1);
    if (i.top != i.bottom && F3(e, i)) {
      s = { node: t, offset: o + (e.left >= (i.left + i.right) / 2 ? 1 : 0) };
      break;
    }
  }
  return r.detach(), s || { node: t, offset: 0 };
}
function F3(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function pVe(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function gVe(t, e, n) {
  let { node: r, offset: s } = Xie(e, n), o = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let i = r.getBoundingClientRect();
    o = i.left != i.right && n.left > (i.left + i.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, s, o);
}
function mVe(t, e, n, r) {
  let s = -1;
  for (let o = e, i = !1; o != t.dom; ) {
    let a = t.docView.nearestDesc(o, !0), c;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((c = a.dom.getBoundingClientRect()).width || c.height) && (a.node.isBlock && a.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(a.dom.nodeName) && (!i && c.left > r.left || c.top > r.top ? s = a.posBefore : (!i && c.right < r.left || c.bottom < r.top) && (s = a.posAfter), i = !0), !a.contentDOM && s < 0 && !a.node.isText))
      return (a.node.isBlock ? r.top < (c.top + c.bottom) / 2 : r.left < (c.left + c.right) / 2) ? a.posBefore : a.posAfter;
    o = a.dom.parentNode;
  }
  return s > -1 ? s : t.docView.posFromDOM(e, n, -1);
}
function Zie(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (let s = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), o = s; ; ) {
      let i = t.childNodes[o];
      if (i.nodeType == 1) {
        let a = i.getClientRects();
        for (let c = 0; c < a.length; c++) {
          let l = a[c];
          if (F3(e, l))
            return Zie(i, e, l);
        }
      }
      if ((o = (o + 1) % r) == s)
        break;
    }
  return t;
}
function yVe(t, e) {
  let n = t.dom.ownerDocument, r, s = 0, o = iVe(n, e.left, e.top);
  o && ({ node: r, offset: s } = o);
  let i = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
  if (!i || !t.dom.contains(i.nodeType != 1 ? i.parentNode : i)) {
    let l = t.dom.getBoundingClientRect();
    if (!F3(e, l) || (i = Zie(t.dom, e, l), !i))
      return null;
  }
  if (ao)
    for (let l = i; r && l; l = fy(l))
      l.draggable && (r = void 0);
  if (i = pVe(i, e), r) {
    if (ic && r.nodeType == 1 && (s = Math.min(s, r.childNodes.length), s < r.childNodes.length)) {
      let d = r.childNodes[s], u;
      d.nodeName == "IMG" && (u = d.getBoundingClientRect()).right <= e.left && u.bottom > e.top && s++;
    }
    let l;
    lS && s && r.nodeType == 1 && (l = r.childNodes[s - 1]).nodeType == 1 && l.contentEditable == "false" && l.getBoundingClientRect().top >= e.top && s--, r == t.dom && s == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (s == 0 || r.nodeType != 1 || r.childNodes[s - 1].nodeName != "BR") && (a = mVe(t, r, s, e));
  }
  a == null && (a = gVe(t, i, e));
  let c = t.docView.nearestDesc(i, !0);
  return { pos: a, inside: c ? c.posAtStart - c.border : -1 };
}
function g9(t) {
  return t.top < t.bottom || t.left < t.right;
}
function zu(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1];
    if (g9(r))
      return r;
  }
  return Array.prototype.find.call(n, g9) || t.getBoundingClientRect();
}
const vVe = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Qie(t, e, n) {
  let { node: r, offset: s, atom: o } = t.docView.domFromPos(e, n < 0 ? -1 : 1), i = lS || ic;
  if (r.nodeType == 3)
    if (i && (vVe.test(r.nodeValue) || (n < 0 ? !s : s == r.nodeValue.length))) {
      let c = zu(Rd(r, s, s), n);
      if (ic && s && /\s/.test(r.nodeValue[s - 1]) && s < r.nodeValue.length) {
        let l = zu(Rd(r, s - 1, s - 1), -1);
        if (l.top == c.top) {
          let d = zu(Rd(r, s, s + 1), -1);
          if (d.top != c.top)
            return ob(d, d.left < l.left);
        }
      }
      return c;
    } else {
      let c = s, l = s, d = n < 0 ? 1 : -1;
      return n < 0 && !s ? (l++, d = -1) : n >= 0 && s == r.nodeValue.length ? (c--, d = 1) : n < 0 ? c-- : l++, ob(zu(Rd(r, c, l), d), d < 0);
    }
  if (!t.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
    if (o == null && s && (n < 0 || s == Qa(r))) {
      let c = r.childNodes[s - 1];
      if (c.nodeType == 1)
        return CO(c.getBoundingClientRect(), !1);
    }
    if (o == null && s < Qa(r)) {
      let c = r.childNodes[s];
      if (c.nodeType == 1)
        return CO(c.getBoundingClientRect(), !0);
    }
    return CO(r.getBoundingClientRect(), n >= 0);
  }
  if (o == null && s && (n < 0 || s == Qa(r))) {
    let c = r.childNodes[s - 1], l = c.nodeType == 3 ? Rd(c, Qa(c) - (i ? 0 : 1)) : c.nodeType == 1 && (c.nodeName != "BR" || !c.nextSibling) ? c : null;
    if (l)
      return ob(zu(l, 1), !1);
  }
  if (o == null && s < Qa(r)) {
    let c = r.childNodes[s];
    for (; c.pmViewDesc && c.pmViewDesc.ignoreForCoords; )
      c = c.nextSibling;
    let l = c ? c.nodeType == 3 ? Rd(c, 0, i ? 0 : 1) : c.nodeType == 1 ? c : null : null;
    if (l)
      return ob(zu(l, -1), !0);
  }
  return ob(zu(r.nodeType == 3 ? Rd(r) : r, -n), n >= 0);
}
function ob(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function CO(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function Jie(t, e, n) {
  let r = t.state, s = t.root.activeElement;
  r != e && t.updateState(e), s != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), s != t.dom && s && s.focus();
  }
}
function bVe(t, e, n) {
  let r = e.selection, s = n == "up" ? r.$from : r.$to;
  return Jie(t, e, () => {
    let { node: o } = t.docView.domFromPos(s.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(o, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        o = a.contentDOM || a.dom;
        break;
      }
      o = a.dom.parentNode;
    }
    let i = Qie(t, s.pos, 1);
    for (let a = o.firstChild; a; a = a.nextSibling) {
      let c;
      if (a.nodeType == 1)
        c = a.getClientRects();
      else if (a.nodeType == 3)
        c = Rd(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let l = 0; l < c.length; l++) {
        let d = c[l];
        if (d.bottom > d.top + 1 && (n == "up" ? i.top - d.top > (d.bottom - i.top) * 2 : d.bottom - i.bottom > (i.bottom - d.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const xVe = /[\u0590-\u08ac]/;
function wVe(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let s = r.parentOffset, o = !s, i = s == r.parent.content.size, a = t.domSelection();
  return a ? !xVe.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? o : i : Jie(t, e, () => {
    let { focusNode: c, focusOffset: l, anchorNode: d, anchorOffset: u } = t.domSelectionRange(), f = a.caretBidiLevel;
    a.modify("move", n, "character");
    let p = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: g, focusOffset: y } = t.domSelectionRange(), m = g && !p.contains(g.nodeType == 1 ? g : g.parentNode) || c == g && l == y;
    try {
      a.collapse(d, u), c && (c != d || l != u) && a.extend && a.extend(c, l);
    } catch {
    }
    return f != null && (a.caretBidiLevel = f), m;
  }) : r.pos == r.start() || r.pos == r.end();
}
let m9 = null, y9 = null, v9 = !1;
function SVe(t, e, n) {
  return m9 == e && y9 == n ? v9 : (m9 = e, y9 = n, v9 = n == "up" || n == "down" ? bVe(t, e, n) : wVe(t, e, n));
}
const ac = 0, b9 = 1, Fh = 2, Ql = 3;
class dS {
  constructor(e, n, r, s) {
    this.parent = e, this.children = n, this.dom = r, this.contentDOM = s, this.dirty = ac, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let s = this.children[n];
      if (s == e)
        return r;
      r += s.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let o, i;
        if (e == this.contentDOM)
          o = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.previousSibling;
        }
        for (; o && !((i = o.pmViewDesc) && i.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(i) + i.size : this.posAtStart;
      } else {
        let o, i;
        if (e == this.contentDOM)
          o = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.nextSibling;
        }
        for (; o && !((i = o.pmViewDesc) && i.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(i) : this.posAtEnd;
      }
    let s;
    if (e == this.dom && this.contentDOM)
      s = n > to(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      s = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            s = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (s == null && n == e.childNodes.length)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            s = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return s ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, s = e; s; s = s.parentNode) {
      let o = this.getDesc(s), i;
      if (o && (!n || o.node))
        if (r && (i = o.nodeDOM) && !(i.nodeType == 1 ? i.contains(e.nodeType == 1 ? e : e.parentNode) : i == e))
          r = !1;
        else
          return o;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(e, n, r) {
    for (let s = e; s; s = s.parentNode) {
      let o = this.getDesc(s);
      if (o)
        return o.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let s = this.children[n], o = r + s.size;
      if (r == e && o != r) {
        for (; !s.border && s.children.length; )
          for (let i = 0; i < s.children.length; i++) {
            let a = s.children[i];
            if (a.size) {
              s = a;
              break;
            }
          }
        return s;
      }
      if (e < o)
        return s.descAt(e - r - s.border);
      r = o;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, s = 0;
    for (let o = 0; r < this.children.length; r++) {
      let i = this.children[r], a = o + i.size;
      if (a > e || i instanceof tae) {
        s = e - o;
        break;
      }
      o = a;
    }
    if (s)
      return this.children[r].domFromPos(s - this.children[r].border, n);
    for (let o; r && !(o = this.children[r - 1]).size && o instanceof eae && o.side >= 0; r--)
      ;
    if (n <= 0) {
      let o, i = !0;
      for (; o = r ? this.children[r - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); r--, i = !1)
        ;
      return o && n && i && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : { node: this.contentDOM, offset: o ? to(o.dom) + 1 : 0 };
    } else {
      let o, i = !0;
      for (; o = r < this.children.length ? this.children[r] : null, !(!o || o.dom.parentNode == this.contentDOM); r++, i = !1)
        ;
      return o && i && !o.border && !o.domAtom ? o.domFromPos(0, n) : { node: this.contentDOM, offset: o ? to(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let s = -1, o = -1;
    for (let i = r, a = 0; ; a++) {
      let c = this.children[a], l = i + c.size;
      if (s == -1 && e <= l) {
        let d = i + c.border;
        if (e >= d && n <= l - c.border && c.node && c.contentDOM && this.contentDOM.contains(c.contentDOM))
          return c.parseRange(e, n, d);
        e = i;
        for (let u = a; u > 0; u--) {
          let f = this.children[u - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            s = to(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        s == -1 && (s = 0);
      }
      if (s > -1 && (l > n || a == this.children.length - 1)) {
        n = l;
        for (let d = a + 1; d < this.children.length; d++) {
          let u = this.children[d];
          if (u.size && u.dom.parentNode == this.contentDOM && !u.emptyChildAt(-1)) {
            o = to(u.dom);
            break;
          }
          n += u.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      i = l;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: s, toOffset: o };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, s = !1) {
    let o = Math.min(e, n), i = Math.max(e, n);
    for (let p = 0, g = 0; p < this.children.length; p++) {
      let y = this.children[p], m = g + y.size;
      if (o > g && i < m)
        return y.setSelection(e - g - y.border, n - g - y.border, r, s);
      g = m;
    }
    let a = this.domFromPos(e, e ? -1 : 1), c = n == e ? a : this.domFromPos(n, n ? -1 : 1), l = r.root.getSelection(), d = r.domSelectionRange(), u = !1;
    if ((ic || ao) && e == n) {
      let { node: p, offset: g } = a;
      if (p.nodeType == 3) {
        if (u = !!(g && p.nodeValue[g - 1] == `
`), u && g == p.nodeValue.length)
          for (let y = p, m; y; y = y.parentNode) {
            if (m = y.nextSibling) {
              m.nodeName == "BR" && (a = c = { node: m.parentNode, offset: to(m) + 1 });
              break;
            }
            let v = y.pmViewDesc;
            if (v && v.node && v.node.isBlock)
              break;
          }
      } else {
        let y = p.childNodes[g - 1];
        u = y && (y.nodeName == "BR" || y.contentEditable == "false");
      }
    }
    if (ic && d.focusNode && d.focusNode != c.node && d.focusNode.nodeType == 1) {
      let p = d.focusNode.childNodes[d.focusOffset];
      p && p.contentEditable == "false" && (s = !0);
    }
    if (!(s || u && ao) && Dp(a.node, a.offset, d.anchorNode, d.anchorOffset) && Dp(c.node, c.offset, d.focusNode, d.focusOffset))
      return;
    let f = !1;
    if ((l.extend || e == n) && !(u && ic)) {
      l.collapse(a.node, a.offset);
      try {
        e != n && l.extend(c.node, c.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let g = a;
        a = c, c = g;
      }
      let p = document.createRange();
      p.setEnd(c.node, c.offset), p.setStart(a.node, a.offset), l.removeAllRanges(), l.addRange(p);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, s = 0; s < this.children.length; s++) {
      let o = this.children[s], i = r + o.size;
      if (r == i ? e <= i && n >= r : e < i && n > r) {
        let a = r + o.border, c = i - o.border;
        if (e >= a && n <= c) {
          this.dirty = e == r || n == i ? Fh : b9, e == a && n == c && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = Ql : o.markDirty(e - a, n - a);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? Fh : Ql;
      }
      r = i;
    }
    this.dirty = Fh;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? Fh : b9;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class eae extends dS {
  constructor(e, n, r, s) {
    let o, i = n.type.toDOM;
    if (typeof i == "function" && (i = i(r, () => {
      if (!o)
        return s;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !n.type.spec.raw) {
      if (i.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(i), i = a;
      }
      i.contentEditable = "false", i.classList.add("ProseMirror-widget");
    }
    super(e, [], i, null), this.widget = n, this.widget = n, o = this;
  }
  matchesWidget(e) {
    return this.dirty == ac && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CVe extends dS {
  constructor(e, n, r, s) {
    super(e, [], n, null), this.textDOM = r, this.text = s;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Np extends dS {
  constructor(e, n, r, s, o) {
    super(e, [], r, s), this.mark = n, this.spec = o;
  }
  static create(e, n, r, s) {
    let o = s.nodeViews[n.type.name], i = o && o(n, s, r);
    return (!i || !i.dom) && (i = yg.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new Np(e, n, i.dom, i.contentDOM || i.dom, i);
  }
  parseRule() {
    return this.dirty & Ql || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Ql && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != ac) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = ac;
    }
  }
  slice(e, n, r) {
    let s = Np.create(this.parent, this.mark, !0, r), o = this.children, i = this.size;
    n < i && (o = Nj(o, n, i, r)), e > 0 && (o = Nj(o, 0, e, r));
    for (let a = 0; a < o.length; a++)
      o[a].parent = s;
    return s.children = o, s;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Sf extends dS {
  constructor(e, n, r, s, o, i, a, c, l) {
    super(e, [], o, i), this.node = n, this.outerDeco = r, this.innerDeco = s, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, s, o, i) {
    let a = o.nodeViews[n.type.name], c, l = a && a(n, o, () => {
      if (!c)
        return i;
      if (c.parent)
        return c.parent.posBeforeChild(c);
    }, r, s), d = l && l.dom, u = l && l.contentDOM;
    if (n.isText) {
      if (!d)
        d = document.createTextNode(n.text);
      else if (d.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else d || ({ dom: d, contentDOM: u } = yg.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !u && !n.isText && d.nodeName != "BR" && (d.hasAttribute("contenteditable") || (d.contentEditable = "false"), n.type.spec.draggable && (d.draggable = !0));
    let f = d;
    return d = sae(d, r, n), l ? c = new _Ve(e, n, r, s, d, u || null, f, l, o, i + 1) : n.isText ? new nk(e, n, r, s, d, f, o) : new Sf(e, n, r, s, d, u || null, f, o, i + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => Pe.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return this.dirty == ac && e.eq(this.node) && XE(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent, s = n, o = e.composing ? this.localCompositionInfo(e, n) : null, i = o && o.pos > -1 ? o : null, a = o && o.pos < 0, c = new TVe(this, i && i.node, e);
    kVe(this.node, this.innerDeco, (l, d, u) => {
      l.spec.marks ? c.syncToMarks(l.spec.marks, r, e, d) : l.type.side >= 0 && !u && c.syncToMarks(d == this.node.childCount ? Fn.none : this.node.child(d).marks, r, e, d), c.placeWidget(l, e, s);
    }, (l, d, u, f) => {
      c.syncToMarks(l.marks, r, e, f);
      let p;
      c.findNodeMatch(l, d, u, f) || a && e.state.selection.from > s && e.state.selection.to < s + l.nodeSize && (p = c.findIndexWithChild(o.node)) > -1 && c.updateNodeAt(l, d, u, p, e) || c.updateNextNode(l, d, u, e, f, s) || c.addNode(l, d, u, e, s), s += l.nodeSize;
    }), c.syncToMarks([], r, e, 0), this.node.isTextblock && c.addTextblockHacks(), c.destroyRest(), (c.changed || this.dirty == Fh) && (i && this.protectLocalComposition(e, i), nae(this.contentDOM, this.children, e), hy && AVe(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: s } = e.state.selection;
    if (!(e.state.selection instanceof Dt) || r < n || s > n + this.node.content.size)
      return null;
    let o = e.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let i = o.nodeValue, a = MVe(this.node.content, i, r - n, s - n);
      return a < 0 ? null : { node: o, pos: a, text: i };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: s }) {
    if (this.getDesc(n))
      return;
    let o = n;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let i = new CVe(this, o, n, s);
    e.input.compositionNodes.push(i), this.children = Nj(this.children, r, r + s.length, e, i);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, s) {
    return this.dirty == Ql || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, s), !0);
  }
  updateInner(e, n, r, s) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(s, this.posAtStart), this.dirty = ac;
  }
  updateOuterDeco(e) {
    if (XE(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = rae(this.dom, this.nodeDOM, Dj(this.outerDeco, this.node, n), Dj(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0));
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.nodeDOM.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function x9(t, e, n, r, s) {
  sae(r, e, t);
  let o = new Sf(void 0, t, e, n, r, r, r, s, 0);
  return o.contentDOM && o.updateChildren(s, 0), o;
}
class nk extends Sf {
  constructor(e, n, r, s, o, i, a) {
    super(e, n, r, s, o, null, i, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, s) {
    return this.dirty == Ql || this.dirty != ac && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != ac || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, s.trackWrites == this.nodeDOM && (s.trackWrites = null)), this.node = e, this.dirty = ac, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let s = this.node.cut(e, n), o = document.createTextNode(s.text);
    return new nk(this.parent, s, this.outerDeco, this.innerDeco, o, o, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Ql);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class tae extends dS {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == ac && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class _Ve extends Sf {
  constructor(e, n, r, s, o, i, a, c, l, d) {
    super(e, n, r, s, o, i, a, l, d), this.spec = c;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, s) {
    if (this.dirty == Ql)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let o = this.spec.update(e, n, r);
      return o && this.updateInner(e, n, r, s), o;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, s);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, s) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, s);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function nae(t, e, n) {
  let r = t.firstChild, s = !1;
  for (let o = 0; o < e.length; o++) {
    let i = e[o], a = i.dom;
    if (a.parentNode == t) {
      for (; a != r; )
        r = w9(r), s = !0;
      r = r.nextSibling;
    } else
      s = !0, t.insertBefore(a, r);
    if (i instanceof Np) {
      let c = r ? r.previousSibling : t.lastChild;
      nae(i.contentDOM, i.children, n), r = c ? c.nextSibling : t.firstChild;
    }
  }
  for (; r; )
    r = w9(r), s = !0;
  s && n.trackWrites == t && (n.trackWrites = null);
}
const Sx = function(t) {
  t && (this.nodeName = t);
};
Sx.prototype = /* @__PURE__ */ Object.create(null);
const Bh = [new Sx()];
function Dj(t, e, n) {
  if (t.length == 0)
    return Bh;
  let r = n ? Bh[0] : new Sx(), s = [r];
  for (let o = 0; o < t.length; o++) {
    let i = t[o].type.attrs;
    if (i) {
      i.nodeName && s.push(r = new Sx(i.nodeName));
      for (let a in i) {
        let c = i[a];
        c != null && (n && s.length == 1 && s.push(r = new Sx(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + c : a == "style" ? r.style = (r.style ? r.style + ";" : "") + c : a != "nodeName" && (r[a] = c));
      }
    }
  }
  return s;
}
function rae(t, e, n, r) {
  if (n == Bh && r == Bh)
    return e;
  let s = e;
  for (let o = 0; o < r.length; o++) {
    let i = r[o], a = n[o];
    if (o) {
      let c;
      a && a.nodeName == i.nodeName && s != t && (c = s.parentNode) && c.nodeName.toLowerCase() == i.nodeName || (c = document.createElement(i.nodeName), c.pmIsDeco = !0, c.appendChild(s), a = Bh[0]), s = c;
    }
    EVe(s, a || Bh[0], i);
  }
  return s;
}
function EVe(t, e, n) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], s = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < r.length; o++)
      s.indexOf(r[o]) == -1 && t.classList.remove(r[o]);
    for (let o = 0; o < s.length; o++)
      r.indexOf(s[o]) == -1 && t.classList.add(s[o]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, s;
      for (; s = r.exec(e.style); )
        t.style.removeProperty(s[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function sae(t, e, n) {
  return rae(t, t, Bh, Dj(e, n, t.nodeType != 1));
}
function XE(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function w9(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class TVe {
  constructor(e, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = PVe(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r, s) {
    let o = 0, i = this.stack.length >> 1, a = Math.min(i, e.length);
    for (; o < a && (o == i - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(e[o]) && e[o].type.spec.spanning !== !1; )
      o++;
    for (; o < i; )
      this.destroyRest(), this.top.dirty = ac, this.index = this.stack.pop(), this.top = this.stack.pop(), i--;
    for (; i < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let c = -1, l = this.top.children.length;
      s < this.preMatch.index && (l = Math.min(this.index + 3, l));
      for (let d = this.index; d < l; d++) {
        let u = this.top.children[d];
        if (u.matchesMark(e[i]) && !this.isLocked(u.dom)) {
          c = d;
          break;
        }
      }
      if (c > -1)
        c > this.index && (this.changed = !0, this.destroyBetween(this.index, c)), this.top = this.top.children[this.index];
      else {
        let d = Np.create(this.top, e[i], n, r);
        this.top.children.splice(this.index, 0, d), this.top = d, this.changed = !0;
      }
      this.index = 0, i++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, s) {
    let o = -1, i;
    if (s >= this.preMatch.index && (i = this.preMatch.matches[s - this.preMatch.index]).parent == this.top && i.matchesNode(e, n, r))
      o = this.top.children.indexOf(i, this.index);
    else
      for (let a = this.index, c = Math.min(this.top.children.length, a + 5); a < c; a++) {
        let l = this.top.children[a];
        if (l.matchesNode(e, n, r) && !this.preMatch.matched.has(l)) {
          o = a;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(e, n, r, s, o) {
    let i = this.top.children[s];
    return i.dirty == Ql && i.dom == i.contentDOM && (i.dirty = Fh), i.update(e, n, r, o) ? (this.destroyBetween(this.index, s), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let s = this.index; s < this.top.children.length; s++)
            if (this.top.children[s] == r)
              return s;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, s, o, i) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let c = this.top.children[a];
      if (c instanceof Sf) {
        let l = this.preMatch.matched.get(c);
        if (l != null && l != o)
          return !1;
        let d = c.dom, u, f = this.isLocked(d) && !(e.isText && c.node && c.node.isText && c.nodeDOM.nodeValue == e.text && c.dirty != Ql && XE(n, c.outerDeco));
        if (!f && c.update(e, n, r, s))
          return this.destroyBetween(this.index, a), c.dom != d && (this.changed = !0), this.index++, !0;
        if (!f && (u = this.recreateWrapper(c, e, n, r, s, i)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = u, u.contentDOM && (u.dirty = Fh, u.updateChildren(s, i + 1), u.dirty = ac), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, r, s, o, i) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !XE(r, e.outerDeco) || !s.eq(e.innerDeco))
      return null;
    let a = Sf.create(this.top, n, r, s, o, i);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let c of a.children)
        c.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, s, o) {
    let i = Sf.create(this.top, e, n, r, s, o);
    i.contentDOM && i.updateChildren(s, o + 1), this.top.children.splice(this.index++, 0, i), this.changed = !0;
  }
  placeWidget(e, n, r) {
    let s = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (s && s.matchesWidget(e) && (e == s.widget || !s.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new eae(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof Np; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof nk) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((ao || Os) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let s = new tae(this.top, [], r, null);
      n != this.top ? n.children.push(s) : n.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function PVe(t, e) {
  let n = e, r = n.children.length, s = t.childCount, o = /* @__PURE__ */ new Map(), i = [];
  e: for (; s > 0; ) {
    let a;
    for (; ; )
      if (r) {
        let l = n.children[r - 1];
        if (l instanceof Np)
          n = l, r = l.children.length;
        else {
          a = l, r--;
          break;
        }
      } else {
        if (n == e)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let c = a.node;
    if (c) {
      if (c != t.child(s - 1))
        break;
      --s, o.set(a, s), i.push(a);
    }
  }
  return { index: s, matched: o, matches: i.reverse() };
}
function IVe(t, e) {
  return t.type.side - e.type.side;
}
function kVe(t, e, n, r) {
  let s = e.locals(t), o = 0;
  if (s.length == 0) {
    for (let l = 0; l < t.childCount; l++) {
      let d = t.child(l);
      r(d, s, e.forChild(o, d), l), o += d.nodeSize;
    }
    return;
  }
  let i = 0, a = [], c = null;
  for (let l = 0; ; ) {
    let d, u;
    for (; i < s.length && s[i].to == o; ) {
      let m = s[i++];
      m.widget && (d ? (u || (u = [d])).push(m) : d = m);
    }
    if (d)
      if (u) {
        u.sort(IVe);
        for (let m = 0; m < u.length; m++)
          n(u[m], l, !!c);
      } else
        n(d, l, !!c);
    let f, p;
    if (c)
      p = -1, f = c, c = null;
    else if (l < t.childCount)
      p = l, f = t.child(l++);
    else
      break;
    for (let m = 0; m < a.length; m++)
      a[m].to <= o && a.splice(m--, 1);
    for (; i < s.length && s[i].from <= o && s[i].to > o; )
      a.push(s[i++]);
    let g = o + f.nodeSize;
    if (f.isText) {
      let m = g;
      i < s.length && s[i].from < m && (m = s[i].from);
      for (let v = 0; v < a.length; v++)
        a[v].to < m && (m = a[v].to);
      m < g && (c = f.cut(m - o), f = f.cut(0, m - o), g = m, p = -1);
    } else
      for (; i < s.length && s[i].to < g; )
        i++;
    let y = f.isInline && !f.isLeaf ? a.filter((m) => !m.inline) : a.slice();
    r(f, y, e.forChild(o, f), p), o = g;
  }
}
function AVe(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function MVe(t, e, n, r) {
  for (let s = 0, o = 0; s < t.childCount && o <= r; ) {
    let i = t.child(s++), a = o;
    if (o += i.nodeSize, !i.isText)
      continue;
    let c = i.text;
    for (; s < t.childCount; ) {
      let l = t.child(s++);
      if (o += l.nodeSize, !l.isText)
        break;
      c += l.text;
    }
    if (o >= n) {
      if (o >= r && c.slice(r - e.length - a, r - a) == e)
        return r - e.length;
      let l = a < r ? c.lastIndexOf(e, r - a - 1) : -1;
      if (l >= 0 && l + e.length + a >= n)
        return a + l;
      if (n == r && c.length >= r + e.length - a && c.slice(r - a, r - a + e.length) == e)
        return r;
    }
  }
  return -1;
}
function Nj(t, e, n, r, s) {
  let o = [];
  for (let i = 0, a = 0; i < t.length; i++) {
    let c = t[i], l = a, d = a += c.size;
    l >= n || d <= e ? o.push(c) : (l < e && o.push(c.slice(0, e - l, r)), s && (o.push(s), s = void 0), d > n && o.push(c.slice(n - l, c.size, r)));
  }
  return o;
}
function B3(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let s = t.docView.nearestDesc(n.focusNode), o = s && s.size == 0, i = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (i < 0)
    return null;
  let a = r.resolve(i), c, l;
  if (tk(n)) {
    for (c = i; s && !s.node; )
      s = s.parent;
    let u = s.node;
    if (s && u.isAtom && ht.isSelectable(u) && s.parent && !(u.isInline && sVe(n.focusNode, n.focusOffset, s.dom))) {
      let f = s.posBefore;
      l = new ht(i == f ? a : r.resolve(f));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let u = i, f = i;
      for (let p = 0; p < n.rangeCount; p++) {
        let g = n.getRangeAt(p);
        u = Math.min(u, t.docView.posFromDOM(g.startContainer, g.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(g.endContainer, g.endOffset, -1));
      }
      if (u < 0)
        return null;
      [c, i] = f == t.state.selection.anchor ? [f, u] : [u, f], a = r.resolve(i);
    } else
      c = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (c < 0)
      return null;
  }
  let d = r.resolve(c);
  if (!l) {
    let u = e == "pointer" || t.state.selection.head < a.pos && !o ? 1 : -1;
    l = z3(t, d, a, u);
  }
  return l;
}
function oae(t) {
  return t.editable ? t.hasFocus() : aae(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Qd(t, e = !1) {
  let n = t.state.selection;
  if (iae(t, n), !!oae(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Os) {
      let r = t.domSelectionRange(), s = t.domObserver.currentSelection;
      if (r.anchorNode && s.anchorNode && Dp(r.anchorNode, r.anchorOffset, s.anchorNode, s.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      DVe(t);
    else {
      let { anchor: r, head: s } = n, o, i;
      S9 && !(n instanceof Dt) && (n.$from.parent.inlineContent || (o = C9(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (i = C9(t, n.to))), t.docView.setSelection(r, s, t, e), S9 && (o && _9(o), i && _9(i)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && OVe(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const S9 = ao || Os && Kie < 63;
function C9(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), s = r < n.childNodes.length ? n.childNodes[r] : null, o = r ? n.childNodes[r - 1] : null;
  if (ao && s && s.contentEditable == "false")
    return _O(s);
  if ((!s || s.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (s)
      return _O(s);
    if (o)
      return _O(o);
  }
}
function _O(t) {
  return t.contentEditable = "true", ao && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function _9(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function OVe(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, s = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != s) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!oae(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function DVe(t) {
  let e = t.domSelection();
  if (!e)
    return;
  let n = t.cursorWrapper.dom, r = n.nodeName == "IMG";
  r ? e.collapse(n.parentNode, to(n) + 1) : e.collapse(n, 0), !r && !t.state.selection.visible && zi && wf <= 11 && (n.disabled = !0, n.disabled = !1);
}
function iae(t, e) {
  if (e instanceof ht) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (E9(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    E9(t);
}
function E9(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function z3(t, e, n, r) {
  return t.someProp("createSelectionBetween", (s) => s(t, e, n)) || Dt.between(e, n, r);
}
function T9(t) {
  return t.editable && !t.hasFocus() ? !1 : aae(t);
}
function aae(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function NVe(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return Dp(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function jj(t, e) {
  let { $anchor: n, $head: r } = t.selection, s = e > 0 ? n.max(r) : n.min(r), o = s.parent.inlineContent ? s.depth ? t.doc.resolve(e > 0 ? s.after() : s.before()) : null : s;
  return o && Ht.findFrom(o, e);
}
function Hu(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function P9(t, e, n) {
  let r = t.state.selection;
  if (r instanceof Dt)
    if (n.indexOf("s") > -1) {
      let { $head: s } = r, o = s.textOffset ? null : e < 0 ? s.nodeBefore : s.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let i = t.state.doc.resolve(s.pos + o.nodeSize * (e < 0 ? -1 : 1));
      return Hu(t, new Dt(r.$anchor, i));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let s = jj(t.state, e);
        return s && s instanceof ht ? Hu(t, s) : !1;
      } else if (!(Ga && n.indexOf("m") > -1)) {
        let s = r.$head, o = s.textOffset ? null : e < 0 ? s.nodeBefore : s.nodeAfter, i;
        if (!o || o.isText)
          return !1;
        let a = e < 0 ? s.pos - o.nodeSize : s.pos;
        return o.isAtom || (i = t.docView.descAt(a)) && !i.contentDOM ? ht.isSelectable(o) ? Hu(t, new ht(e < 0 ? t.state.doc.resolve(s.pos - o.nodeSize) : s)) : lS ? Hu(t, new Dt(t.state.doc.resolve(e < 0 ? a : a + o.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof ht && r.node.isInline)
      return Hu(t, new Dt(e > 0 ? r.$to : r.$from));
    {
      let s = jj(t.state, e);
      return s ? Hu(t, s) : !1;
    }
  }
}
function ZE(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Cx(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function Bg(t, e) {
  return e < 0 ? jVe(t) : RVe(t);
}
function jVe(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let s, o, i = !1;
  for (ic && n.nodeType == 1 && r < ZE(n) && Cx(n.childNodes[r], -1) && (i = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if (Cx(a, -1))
          s = n, o = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (cae(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && Cx(a, -1); )
          s = n.parentNode, o = to(a), a = a.previousSibling;
        if (a)
          n = a, r = ZE(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  i ? Rj(t, n, r) : s && Rj(t, s, o);
}
function RVe(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let s = ZE(n), o, i;
  for (; ; )
    if (r < s) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if (Cx(a, 1))
        o = n, i = ++r;
      else
        break;
    } else {
      if (cae(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && Cx(a, 1); )
          o = a.parentNode, i = to(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, s = ZE(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = s = 0;
        }
      }
    }
  o && Rj(t, o, i);
}
function cae(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function $Ve(t, e) {
  for (; t && e == t.childNodes.length && !cS(t); )
    e = to(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function LVe(t, e) {
  for (; t && !e && !cS(t); )
    e = to(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function Rj(t, e, n) {
  if (e.nodeType != 3) {
    let o, i;
    (i = $Ve(e, n)) ? (e = i, n = 0) : (o = LVe(e, n)) && (e = o, n = o.nodeValue.length);
  }
  let r = t.domSelection();
  if (!r)
    return;
  if (tk(r)) {
    let o = document.createRange();
    o.setEnd(e, n), o.setStart(e, n), r.removeAllRanges(), r.addRange(o);
  } else r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: s } = t;
  setTimeout(() => {
    t.state == s && Qd(t);
  }, 50);
}
function I9(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(Os || Gie) && n.parent.inlineContent) {
    let s = t.coordsAtPos(e);
    if (e > n.start()) {
      let o = t.coordsAtPos(e - 1), i = (o.top + o.bottom) / 2;
      if (i > s.top && i < s.bottom && Math.abs(o.left - s.left) > 1)
        return o.left < s.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let o = t.coordsAtPos(e + 1), i = (o.top + o.bottom) / 2;
      if (i > s.top && i < s.bottom && Math.abs(o.left - s.left) > 1)
        return o.left > s.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function k9(t, e, n) {
  let r = t.state.selection;
  if (r instanceof Dt && !r.empty || n.indexOf("s") > -1 || Ga && n.indexOf("m") > -1)
    return !1;
  let { $from: s, $to: o } = r;
  if (!s.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let i = jj(t.state, e);
    if (i && i instanceof ht)
      return Hu(t, i);
  }
  if (!s.parent.inlineContent) {
    let i = e < 0 ? s : o, a = r instanceof oc ? Ht.near(i, e) : Ht.findFrom(i, e);
    return a ? Hu(t, a) : !1;
  }
  return !1;
}
function A9(t, e) {
  if (!(t.state.selection instanceof Dt))
    return !0;
  let { $head: n, $anchor: r, empty: s } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!s)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let o = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (o && !o.isText) {
    let i = t.state.tr;
    return e < 0 ? i.delete(n.pos - o.nodeSize, n.pos) : i.delete(n.pos, n.pos + o.nodeSize), t.dispatch(i), !0;
  }
  return !1;
}
function M9(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function FVe(t) {
  if (!ao || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    M9(t, r, "true"), setTimeout(() => M9(t, r, "false"), 20);
  }
  return !1;
}
function BVe(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function zVe(t, e) {
  let n = e.keyCode, r = BVe(e);
  if (n == 8 || Ga && n == 72 && r == "c")
    return A9(t, -1) || Bg(t, -1);
  if (n == 46 && !e.shiftKey || Ga && n == 68 && r == "c")
    return A9(t, 1) || Bg(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || Ga && n == 66 && r == "c") {
    let s = n == 37 ? I9(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return P9(t, s, r) || Bg(t, s);
  } else if (n == 39 || Ga && n == 70 && r == "c") {
    let s = n == 39 ? I9(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return P9(t, s, r) || Bg(t, s);
  } else {
    if (n == 38 || Ga && n == 80 && r == "c")
      return k9(t, -1, r) || Bg(t, -1);
    if (n == 40 || Ga && n == 78 && r == "c")
      return FVe(t) || k9(t, 1, r) || Bg(t, 1);
    if (r == (Ga ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function U3(t, e) {
  t.someProp("transformCopied", (p) => {
    e = p(e, t);
  });
  let n = [], { content: r, openStart: s, openEnd: o } = e;
  for (; s > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    s--, o--;
    let p = r.firstChild;
    n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null), r = p.content;
  }
  let i = t.someProp("clipboardSerializer") || yg.fromSchema(t.state.schema), a = pae(), c = a.createElement("div");
  c.appendChild(i.serializeFragment(r, { document: a }));
  let l = c.firstChild, d, u = 0;
  for (; l && l.nodeType == 1 && (d = hae[l.nodeName.toLowerCase()]); ) {
    for (let p = d.length - 1; p >= 0; p--) {
      let g = a.createElement(d[p]);
      for (; c.firstChild; )
        g.appendChild(c.firstChild);
      c.appendChild(g), u++;
    }
    l = c.firstChild;
  }
  l && l.nodeType == 1 && l.setAttribute("data-pm-slice", `${s} ${o}${u ? ` -${u}` : ""} ${JSON.stringify(n)}`);
  let f = t.someProp("clipboardTextSerializer", (p) => p(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: c, text: f, slice: e };
}
function lae(t, e, n, r, s) {
  let o = s.parent.type.spec.code, i, a;
  if (!n && !e)
    return null;
  let c = !!e && (r || o || !n);
  if (c) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, o || r, t);
    }), o)
      return a = new We(Pe.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), t.someProp("transformPasted", (f) => {
        a = f(a, t, !0);
      }), a;
    let u = t.someProp("clipboardTextParser", (f) => f(e, s, r, t));
    if (u)
      a = u;
    else {
      let f = s.marks(), { schema: p } = t.state, g = yg.fromSchema(p);
      i = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((y) => {
        let m = i.appendChild(document.createElement("p"));
        y && m.appendChild(g.serializeNode(p.text(y, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (u) => {
      n = u(n, t);
    }), i = WVe(n), lS && KVe(i);
  let l = i && i.querySelector("[data-pm-slice]"), d = l && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(l.getAttribute("data-pm-slice") || "");
  if (d && d[3])
    for (let u = +d[3]; u > 0; u--) {
      let f = i.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      i = f;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || km.fromSchema(t.state.schema)).parseSlice(i, {
    preserveWhitespace: !!(c || d),
    context: s,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !UVe.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), d)
    a = GVe(O9(a, +d[1], +d[2]), d[4]);
  else if (a = We.maxOpen(HVe(a.content, s), !0), a.openStart || a.openEnd) {
    let u = 0, f = 0;
    for (let p = a.content.firstChild; u < a.openStart && !p.type.spec.isolating; u++, p = p.firstChild)
      ;
    for (let p = a.content.lastChild; f < a.openEnd && !p.type.spec.isolating; f++, p = p.lastChild)
      ;
    a = O9(a, u, f);
  }
  return t.someProp("transformPasted", (u) => {
    a = u(a, t, c);
  }), a;
}
const UVe = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function HVe(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let s = e.node(n).contentMatchAt(e.index(n)), o, i = [];
    if (t.forEach((a) => {
      if (!i)
        return;
      let c = s.findWrapping(a.type), l;
      if (!c)
        return i = null;
      if (l = i.length && o.length && uae(c, o, a, i[i.length - 1], 0))
        i[i.length - 1] = l;
      else {
        i.length && (i[i.length - 1] = fae(i[i.length - 1], o.length));
        let d = dae(a, c);
        i.push(d), s = s.matchType(d.type), o = c;
      }
    }), i)
      return Pe.from(i);
  }
  return t;
}
function dae(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, Pe.from(t));
  return t;
}
function uae(t, e, n, r, s) {
  if (s < t.length && s < e.length && t[s] == e[s]) {
    let o = uae(t, e, n, r.lastChild, s + 1);
    if (o)
      return r.copy(r.content.replaceChild(r.childCount - 1, o));
    if (r.contentMatchAt(r.childCount).matchType(s == t.length - 1 ? n.type : t[s + 1]))
      return r.copy(r.content.append(Pe.from(dae(n, t, s + 1))));
  }
}
function fae(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, fae(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(Pe.empty, !0);
  return t.copy(n.append(r));
}
function $j(t, e, n, r, s, o) {
  let i = e < 0 ? t.firstChild : t.lastChild, a = i.content;
  return t.childCount > 1 && (o = 0), s < r - 1 && (a = $j(a, e, n, r, s + 1, o)), s >= n && (a = e < 0 ? i.contentMatchAt(0).fillBefore(a, o <= s).append(a) : a.append(i.contentMatchAt(i.childCount).fillBefore(Pe.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, i.copy(a));
}
function O9(t, e, n) {
  return e < t.openStart && (t = new We($j(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new We($j(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const hae = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let D9 = null;
function pae() {
  return D9 || (D9 = document.implementation.createHTMLDocument("title"));
}
let EO = null;
function VVe(t) {
  let e = window.trustedTypes;
  return e ? (EO || (EO = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), EO.createHTML(t)) : t;
}
function WVe(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = pae().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), s;
  if ((s = r && hae[r[1].toLowerCase()]) && (t = s.map((o) => "<" + o + ">").join("") + t + s.map((o) => "</" + o + ">").reverse().join("")), n.innerHTML = VVe(t), s)
    for (let o = 0; o < s.length; o++)
      n = n.querySelector(s[o]) || n;
  return n;
}
function KVe(t) {
  let e = t.querySelectorAll(Os ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function GVe(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: s, openStart: o, openEnd: i } = t;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let c = n.nodes[r[a]];
    if (!c || c.hasRequiredAttrs())
      break;
    s = Pe.from(c.create(r[a + 1], s)), o++, i++;
  }
  return new We(s, o, i);
}
const fi = {}, hi = {}, YVe = { touchstart: !0, touchmove: !0 };
class qVe {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.badSafariComposition = !1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function XVe(t) {
  for (let e in fi) {
    let n = fi[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
      QVe(t, r) && !H3(t, r) && (t.editable || !(r.type in hi)) && n(t, r);
    }, YVe[e] ? { passive: !0 } : void 0);
  }
  ao && t.dom.addEventListener("input", () => null), Lj(t);
}
function hf(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function ZVe(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Lj(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => H3(t, r));
  });
}
function H3(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function QVe(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function JVe(t, e) {
  !H3(t, e) && fi[e.type] && (t.editable || !(e.type in hi)) && fi[e.type](t, e);
}
hi.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !mae(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(Wd && Os && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), hy && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (s) => s(t, jh(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else t.someProp("handleKeyDown", (r) => r(t, n)) || zVe(t, n) ? n.preventDefault() : hf(t, "key");
};
hi.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
hi.keypress = (t, e) => {
  let n = e;
  if (mae(t, n) || !n.charCode || n.ctrlKey && !n.altKey || Ga && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (s) => s(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof Dt) || !r.$from.sameParent(r.$to)) {
    let s = String.fromCharCode(n.charCode), o = () => t.state.tr.insertText(s).scrollIntoView();
    !/[\r\n]/.test(s) && !t.someProp("handleTextInput", (i) => i(t, r.$from.pos, r.$to.pos, s, o)) && t.dispatch(o()), n.preventDefault();
  }
};
function rk(t) {
  return { left: t.clientX, top: t.clientY };
}
function e7e(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function V3(t, e, n, r, s) {
  if (r == -1)
    return !1;
  let o = t.state.doc.resolve(r);
  for (let i = o.depth + 1; i > 0; i--)
    if (t.someProp(e, (a) => i > o.depth ? a(t, n, o.nodeAfter, o.before(i), s, !0) : a(t, n, o.node(i), o.before(i), s, !1)))
      return !0;
  return !1;
}
function Om(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let r = t.state.tr.setSelection(e);
  r.setMeta("pointer", !0), t.dispatch(r);
}
function t7e(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && ht.isSelectable(r) ? (Om(t, new ht(n)), !0) : !1;
}
function n7e(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, s;
  n instanceof ht && (r = n.node);
  let o = t.state.doc.resolve(e);
  for (let i = o.depth + 1; i > 0; i--) {
    let a = i > o.depth ? o.nodeAfter : o.node(i);
    if (ht.isSelectable(a)) {
      r && n.$from.depth > 0 && i >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? s = o.before(n.$from.depth) : s = o.before(i);
      break;
    }
  }
  return s != null ? (Om(t, ht.create(t.state.doc, s)), !0) : !1;
}
function r7e(t, e, n, r, s) {
  return V3(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (o) => o(t, e, r)) || (s ? n7e(t, n) : t7e(t, n));
}
function s7e(t, e, n, r) {
  return V3(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (s) => s(t, e, r));
}
function o7e(t, e, n, r) {
  return V3(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (s) => s(t, e, r)) || i7e(t, n, r);
}
function i7e(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (Om(t, Dt.create(r, 0, r.content.size)), !0) : !1;
  let s = r.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let i = o > s.depth ? s.nodeAfter : s.node(o), a = s.before(o);
    if (i.inlineContent)
      Om(t, Dt.create(r, a + 1, a + 1 + i.content.size));
    else if (ht.isSelectable(i))
      Om(t, ht.create(r, a));
    else
      continue;
    return !0;
  }
}
function W3(t) {
  return QE(t);
}
const gae = Ga ? "metaKey" : "ctrlKey";
fi.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = W3(t), s = Date.now(), o = "singleClick";
  s - t.input.lastClick.time < 500 && e7e(n, t.input.lastClick) && !n[gae] && t.input.lastClick.button == n.button && (t.input.lastClick.type == "singleClick" ? o = "doubleClick" : t.input.lastClick.type == "doubleClick" && (o = "tripleClick")), t.input.lastClick = { time: s, x: n.clientX, y: n.clientY, type: o, button: n.button };
  let i = t.posAtCoords(rk(n));
  i && (o == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new a7e(t, i, n, !!r)) : (o == "doubleClick" ? s7e : o7e)(t, i.pos, i.inside, n) ? n.preventDefault() : hf(t, "pointer"));
};
class a7e {
  constructor(e, n, r, s) {
    this.view = e, this.pos = n, this.event = r, this.flushed = s, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[gae], this.allowDefault = r.shiftKey;
    let o, i;
    if (n.inside > -1)
      o = e.state.doc.nodeAt(n.inside), i = n.inside;
    else {
      let d = e.state.doc.resolve(n.pos);
      o = d.parent, i = d.depth ? d.before() : 0;
    }
    const a = s ? null : r.target, c = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = c && c.nodeDOM.nodeType == 1 ? c.nodeDOM : null;
    let { selection: l } = e.state;
    (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || l instanceof ht && l.from <= i && l.to > i) && (this.mightDrag = {
      node: o,
      pos: i,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && ic && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), hf(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Qd(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(rk(e))), this.updateAllowDefault(e), this.allowDefault || !n ? hf(this.view, "pointer") : r7e(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    ao && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Os && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Om(this.view, Ht.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : hf(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), hf(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
fi.touchstart = (t) => {
  t.input.lastTouch = Date.now(), W3(t), hf(t, "pointer");
};
fi.touchmove = (t) => {
  t.input.lastTouch = Date.now(), hf(t, "pointer");
};
fi.contextmenu = (t) => W3(t);
function mae(t, e) {
  return t.composing ? !0 : ao && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const c7e = Wd ? 5e3 : -1;
hi.compositionstart = hi.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof Dt && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1) || Os && Gie && l7e(t)))
      t.markCursor = t.state.storedMarks || n.marks(), QE(t, !0), t.markCursor = null;
    else if (QE(t, !e.selection.empty), ic && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let s = r.focusNode, o = r.focusOffset; s && s.nodeType == 1 && o != 0; ) {
        let i = o < 0 ? s.lastChild : s.childNodes[o - 1];
        if (!i)
          break;
        if (i.nodeType == 3) {
          let a = t.domSelection();
          a && a.collapse(i, i.nodeValue.length);
          break;
        } else
          s = i, o = -1;
      }
    }
    t.input.composing = !0;
  }
  yae(t, c7e);
};
function l7e(t) {
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (!e || e.nodeType != 1 || n >= e.childNodes.length)
    return !1;
  let r = e.childNodes[n];
  return r.nodeType == 1 && r.contentEditable == "false";
}
hi.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.badSafariComposition ? t.domObserver.forceFlush() : t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, yae(t, 20));
};
function yae(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => QE(t), e));
}
function vae(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = u7e()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function d7e(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = nVe(e.focusNode, e.focusOffset), r = rVe(e.focusNode, e.focusOffset);
  if (n && r && n != r) {
    let s = r.pmViewDesc, o = t.domObserver.lastChangedTextNode;
    if (n == o || r == o)
      return o;
    if (!s || !s.isText(r.nodeValue))
      return r;
    if (t.input.compositionNode == r) {
      let i = n.pmViewDesc;
      if (!(!i || !i.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function u7e() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function QE(t, e = !1) {
  if (!(Wd && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), vae(t), e || t.docView && t.docView.dirty) {
      let n = B3(t), r = t.state.selection;
      return n && !n.eq(r) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function f7e(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), s = document.createRange();
  s.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(s), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const mw = zi && wf < 15 || hy && aVe < 604;
fi.copy = hi.cut = (t, e) => {
  let n = e, r = t.state.selection, s = n.type == "cut";
  if (r.empty)
    return;
  let o = mw ? null : n.clipboardData, i = r.content(), { dom: a, text: c } = U3(t, i);
  o ? (n.preventDefault(), o.clearData(), o.setData("text/html", a.innerHTML), o.setData("text/plain", c)) : f7e(t, a), s && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function h7e(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function p7e(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let s = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? yw(t, r.value, null, s, e) : yw(t, r.textContent, r.innerHTML, s, e);
  }, 50);
}
function yw(t, e, n, r, s) {
  let o = lae(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (c) => c(t, s, o || We.empty)))
    return !0;
  if (!o)
    return !1;
  let i = h7e(o), a = i ? t.state.tr.replaceSelectionWith(i, r) : t.state.tr.replaceSelection(o);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function bae(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
hi.paste = (t, e) => {
  let n = e;
  if (t.composing && !Wd)
    return;
  let r = mw ? null : n.clipboardData, s = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && yw(t, bae(r), r.getData("text/html"), s, n) ? n.preventDefault() : p7e(t, n);
};
let xae = class {
  constructor(e, n, r) {
    this.slice = e, this.move = n, this.node = r;
  }
};
const g7e = Ga ? "altKey" : "ctrlKey";
function wae(t, e) {
  let n = t.someProp("dragCopies", (r) => !r(e));
  return n ?? !e[g7e];
}
fi.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let s = t.state.selection, o = s.empty ? null : t.posAtCoords(rk(n)), i;
  if (!(o && o.pos >= s.from && o.pos <= (s instanceof ht ? s.to - 1 : s.to))) {
    if (r && r.mightDrag)
      i = ht.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let u = t.docView.nearestDesc(n.target, !0);
      u && u.node.type.spec.draggable && u != t.docView && (i = ht.create(t.state.doc, u.posBefore));
    }
  }
  let a = (i || t.state.selection).content(), { dom: c, text: l, slice: d } = U3(t, a);
  (!n.dataTransfer.files.length || !Os || Kie > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(mw ? "Text" : "text/html", c.innerHTML), n.dataTransfer.effectAllowed = "copyMove", mw || n.dataTransfer.setData("text/plain", l), t.dragging = new xae(d, wae(t, n), i);
};
fi.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
hi.dragover = hi.dragenter = (t, e) => e.preventDefault();
hi.drop = (t, e) => {
  try {
    m7e(t, e, t.dragging);
  } finally {
    t.dragging = null;
  }
};
function m7e(t, e, n) {
  if (!e.dataTransfer)
    return;
  let r = t.posAtCoords(rk(e));
  if (!r)
    return;
  let s = t.state.doc.resolve(r.pos), o = n && n.slice;
  o ? t.someProp("transformPasted", (p) => {
    o = p(o, t, !1);
  }) : o = lae(t, bae(e.dataTransfer), mw ? null : e.dataTransfer.getData("text/html"), !1, s);
  let i = !!(n && wae(t, e));
  if (t.someProp("handleDrop", (p) => p(t, e, o || We.empty, i))) {
    e.preventDefault();
    return;
  }
  if (!o)
    return;
  e.preventDefault();
  let a = o ? $ie(t.state.doc, s.pos, o) : s.pos;
  a == null && (a = s.pos);
  let c = t.state.tr;
  if (i) {
    let { node: p } = n;
    p ? p.replace(c) : c.deleteSelection();
  }
  let l = c.mapping.map(a), d = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, u = c.doc;
  if (d ? c.replaceRangeWith(l, l, o.content.firstChild) : c.replaceRange(l, l, o), c.doc.eq(u))
    return;
  let f = c.doc.resolve(l);
  if (d && ht.isSelectable(o.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new ht(f));
  else {
    let p = c.mapping.map(a);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((g, y, m, v) => p = v), c.setSelection(z3(t, f, c.doc.resolve(p)));
  }
  t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
}
fi.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Qd(t);
  }, 20));
};
fi.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
fi.beforeinput = (t, e) => {
  if (Os && Wd && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (o) => o(t, jh(8, "Backspace")))))
        return;
      let { $cursor: s } = t.state.selection;
      s && s.pos > 0 && t.dispatch(t.state.tr.delete(s.pos - 1, s.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in hi)
  fi[t] = hi[t];
function vw(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class JE {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || lp, this.side = this.spec.side || 0;
  }
  map(e, n, r, s) {
    let { pos: o, deleted: i } = e.mapResult(n.from + s, this.side < 0 ? -1 : 1);
    return i ? null : new ec(o - r, o - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof JE && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && vw(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Cf {
  constructor(e, n) {
    this.attrs = e, this.spec = n || lp;
  }
  map(e, n, r, s) {
    let o = e.map(n.from + s, this.spec.inclusiveStart ? -1 : 1) - r, i = e.map(n.to + s, this.spec.inclusiveEnd ? 1 : -1) - r;
    return o >= i ? null : new ec(o, i, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Cf && vw(this.attrs, e.attrs) && vw(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Cf;
  }
  destroy() {
  }
}
class K3 {
  constructor(e, n) {
    this.attrs = e, this.spec = n || lp;
  }
  map(e, n, r, s) {
    let o = e.mapResult(n.from + s, 1);
    if (o.deleted)
      return null;
    let i = e.mapResult(n.to + s, -1);
    return i.deleted || i.pos <= o.pos ? null : new ec(o.pos - r, i.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: s } = e.content.findIndex(n.from), o;
    return s == n.from && !(o = e.child(r)).isText && s + o.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof K3 && vw(this.attrs, e.attrs) && vw(this.spec, e.spec);
  }
  destroy() {
  }
}
class ec {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new ec(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new ec(e, e, new JE(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, s) {
    return new ec(e, n, new Cf(r, s));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, s) {
    return new ec(e, n, new K3(r, s));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Cf;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof JE;
  }
}
const tm = [], lp = {};
class hs {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : tm, this.children = n.length ? n : tm;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? eT(n, e, 0, lp) : Eo;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let s = [];
    return this.findInner(e ?? 0, n ?? 1e9, s, 0, r), s;
  }
  findInner(e, n, r, s, o) {
    for (let i = 0; i < this.local.length; i++) {
      let a = this.local[i];
      a.from <= n && a.to >= e && (!o || o(a.spec)) && r.push(a.copy(a.from + s, a.to + s));
    }
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] < n && this.children[i + 1] > e) {
        let a = this.children[i] + 1;
        this.children[i + 2].findInner(e - a, n - a, r, s + a, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == Eo || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || lp);
  }
  /**
  @internal
  */
  mapInner(e, n, r, s, o) {
    let i;
    for (let a = 0; a < this.local.length; a++) {
      let c = this.local[a].map(e, r, s);
      c && c.type.valid(n, c) ? (i || (i = [])).push(c) : o.onRemove && o.onRemove(this.local[a].spec);
    }
    return this.children.length ? y7e(this.children, i || [], e, n, r, s, o) : i ? new hs(i.sort(dp), tm) : Eo;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == Eo ? hs.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let s, o = 0;
    e.forEach((a, c) => {
      let l = c + r, d;
      if (d = Cae(n, a, l)) {
        for (s || (s = this.children.slice()); o < s.length && s[o] < c; )
          o += 3;
        s[o] == c ? s[o + 2] = s[o + 2].addInner(a, d, l + 1) : s.splice(o, 0, c, c + a.nodeSize, eT(d, a, l + 1, lp)), o += 3;
      }
    });
    let i = Sae(o ? _ae(n) : n, -r);
    for (let a = 0; a < i.length; a++)
      i[a].type.valid(e, i[a]) || i.splice(a--, 1);
    return new hs(i.length ? this.local.concat(i).sort(dp) : this.local, s || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Eo ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, s = this.local;
    for (let o = 0; o < r.length; o += 3) {
      let i, a = r[o] + n, c = r[o + 1] + n;
      for (let d = 0, u; d < e.length; d++)
        (u = e[d]) && u.from > a && u.to < c && (e[d] = null, (i || (i = [])).push(u));
      if (!i)
        continue;
      r == this.children && (r = this.children.slice());
      let l = r[o + 2].removeInner(i, a + 1);
      l != Eo ? r[o + 2] = l : (r.splice(o, 3), o -= 3);
    }
    if (s.length) {
      for (let o = 0, i; o < e.length; o++)
        if (i = e[o])
          for (let a = 0; a < s.length; a++)
            s[a].eq(i, n) && (s == this.local && (s = this.local.slice()), s.splice(a--, 1));
    }
    return r == this.children && s == this.local ? this : s.length || r.length ? new hs(s, r) : Eo;
  }
  forChild(e, n) {
    if (this == Eo)
      return this;
    if (n.isLeaf)
      return hs.empty;
    let r, s;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
    let o = e + 1, i = o + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let c = this.local[a];
      if (c.from < i && c.to > o && c.type instanceof Cf) {
        let l = Math.max(o, c.from) - o, d = Math.min(i, c.to) - o;
        l < d && (s || (s = [])).push(c.copy(l, d));
      }
    }
    if (s) {
      let a = new hs(s.sort(dp), tm);
      return r ? new qu([a, r]) : a;
    }
    return r || Eo;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof hs) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return G3(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Eo)
      return tm;
    if (e.inlineContent || !this.local.some(Cf.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Cf || n.push(this.local[r]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
hs.empty = new hs([], []);
hs.removeOverlap = G3;
const Eo = hs.empty;
class qu {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((s) => s.map(e, n, lp));
    return qu.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return hs.empty;
    let r = [];
    for (let s = 0; s < this.members.length; s++) {
      let o = this.members[s].forChild(e, n);
      o != Eo && (o instanceof qu ? r = r.concat(o.members) : r.push(o));
    }
    return qu.from(r);
  }
  eq(e) {
    if (!(e instanceof qu) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let s = 0; s < this.members.length; s++) {
      let o = this.members[s].localsInner(e);
      if (o.length)
        if (!n)
          n = o;
        else {
          r && (n = n.slice(), r = !1);
          for (let i = 0; i < o.length; i++)
            n.push(o[i]);
        }
    }
    return n ? G3(r ? n : n.sort(dp)) : tm;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Eo;
      case 1:
        return e[0];
      default:
        return new qu(e.every((n) => n instanceof hs) ? e : e.reduce((n, r) => n.concat(r instanceof hs ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
}
function y7e(t, e, n, r, s, o, i) {
  let a = t.slice();
  for (let l = 0, d = o; l < n.maps.length; l++) {
    let u = 0;
    n.maps[l].forEach((f, p, g, y) => {
      let m = y - g - (p - f);
      for (let v = 0; v < a.length; v += 3) {
        let b = a[v + 1];
        if (b < 0 || f > b + d - u)
          continue;
        let x = a[v] + d - u;
        p >= x ? a[v + 1] = f <= x ? -2 : -1 : f >= d && m && (a[v] += m, a[v + 1] += m);
      }
      u += m;
    }), d = n.maps[l].map(d, -1);
  }
  let c = !1;
  for (let l = 0; l < a.length; l += 3)
    if (a[l + 1] < 0) {
      if (a[l + 1] == -2) {
        c = !0, a[l + 1] = -1;
        continue;
      }
      let d = n.map(t[l] + o), u = d - s;
      if (u < 0 || u >= r.content.size) {
        c = !0;
        continue;
      }
      let f = n.map(t[l + 1] + o, -1), p = f - s, { index: g, offset: y } = r.content.findIndex(u), m = r.maybeChild(g);
      if (m && y == u && y + m.nodeSize == p) {
        let v = a[l + 2].mapInner(n, m, d + 1, t[l] + o + 1, i);
        v != Eo ? (a[l] = u, a[l + 1] = p, a[l + 2] = v) : (a[l + 1] = -2, c = !0);
      } else
        c = !0;
    }
  if (c) {
    let l = v7e(a, t, e, n, s, o, i), d = eT(l, r, 0, i);
    e = d.local;
    for (let u = 0; u < a.length; u += 3)
      a[u + 1] < 0 && (a.splice(u, 3), u -= 3);
    for (let u = 0, f = 0; u < d.children.length; u += 3) {
      let p = d.children[u];
      for (; f < a.length && a[f] < p; )
        f += 3;
      a.splice(f, 0, d.children[u], d.children[u + 1], d.children[u + 2]);
    }
  }
  return new hs(e.sort(dp), a);
}
function Sae(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let s = t[r];
    n.push(new ec(s.from + e, s.to + e, s.type));
  }
  return n;
}
function v7e(t, e, n, r, s, o, i) {
  function a(c, l) {
    for (let d = 0; d < c.local.length; d++) {
      let u = c.local[d].map(r, s, l);
      u ? n.push(u) : i.onRemove && i.onRemove(c.local[d].spec);
    }
    for (let d = 0; d < c.children.length; d += 3)
      a(c.children[d + 2], c.children[d] + l + 1);
  }
  for (let c = 0; c < t.length; c += 3)
    t[c + 1] == -1 && a(t[c + 2], e[c] + o + 1);
  return n;
}
function Cae(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, s = null;
  for (let o = 0, i; o < t.length; o++)
    (i = t[o]) && i.from > n && i.to < r && ((s || (s = [])).push(i), t[o] = null);
  return s;
}
function _ae(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function eT(t, e, n, r) {
  let s = [], o = !1;
  e.forEach((a, c) => {
    let l = Cae(t, a, c + n);
    if (l) {
      o = !0;
      let d = eT(l, a, n + c + 1, r);
      d != Eo && s.push(c, c + a.nodeSize, d);
    }
  });
  let i = Sae(o ? _ae(t) : t, -n).sort(dp);
  for (let a = 0; a < i.length; a++)
    i[a].type.valid(e, i[a]) || (r.onRemove && r.onRemove(i[a].spec), i.splice(a--, 1));
  return i.length || s.length ? new hs(i, s) : Eo;
}
function dp(t, e) {
  return t.from - e.from || t.to - e.to;
}
function G3(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let s = n + 1; s < e.length; s++) {
        let o = e[s];
        if (o.from == r.from) {
          o.to != r.to && (e == t && (e = t.slice()), e[s] = o.copy(o.from, r.to), N9(e, s + 1, o.copy(r.to, o.to)));
          continue;
        } else {
          o.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, o.from), N9(e, s, r.copy(o.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function N9(t, e, n) {
  for (; e < t.length && dp(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function TO(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let r = n(t.state);
    r && r != Eo && e.push(r);
  }), t.cursorWrapper && e.push(hs.create(t.state.doc, [t.cursorWrapper.deco])), qu.from(e);
}
const b7e = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, x7e = zi && wf <= 11;
class w7e {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class S7e {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new w7e(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let s = 0; s < r.length; s++)
        this.queue.push(r[s]);
      zi && wf <= 11 && r.some((s) => s.type == "childList" && s.removedNodes.length || s.type == "characterData" && s.oldValue.length > s.target.nodeValue.length) ? this.flushSoon() : ao && e.composing && r.some((s) => s.type == "childList" && s.target.nodeName == "TR") ? (e.input.badSafariComposition = !0, this.flushSoon()) : this.flush();
    }), x7e && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, b7e)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (T9(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Qd(this.view);
      if (zi && wf <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Dp(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let o = e.focusNode; o; o = fy(o))
      n.add(o);
    for (let o = e.anchorNode; o; o = fy(o))
      if (n.has(o)) {
        r = o;
        break;
      }
    let s = r && this.view.docView.nearestDesc(r);
    if (s && s.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = e.domSelectionRange(), s = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && T9(e) && !this.ignoreSelectionChange(r), o = -1, i = -1, a = !1, c = [];
    if (e.editable)
      for (let d = 0; d < n.length; d++) {
        let u = this.registerMutation(n[d], c);
        u && (o = o < 0 ? u.from : Math.min(u.from, o), i = i < 0 ? u.to : Math.max(u.to, i), u.typeOver && (a = !0));
      }
    if (ic && c.length) {
      let d = c.filter((u) => u.nodeName == "BR");
      if (d.length == 2) {
        let [u, f] = d;
        u.parentNode && u.parentNode.parentNode == f.parentNode ? f.remove() : u.remove();
      } else {
        let { focusNode: u } = this.currentSelection;
        for (let f of d) {
          let p = f.parentNode;
          p && p.nodeName == "LI" && (!u || E7e(e, u) != p) && f.remove();
        }
      }
    } else if ((Os || ao) && c.some((d) => d.nodeName == "BR") && (e.input.lastKeyCode == 8 || e.input.lastKeyCode == 46)) {
      for (let d of c)
        if (d.nodeName == "BR" && d.parentNode) {
          let u = d.nextSibling;
          u && u.nodeType == 1 && u.contentEditable == "false" && d.parentNode.removeChild(d);
        }
    }
    let l = null;
    o < 0 && s && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && tk(r) && (l = B3(e)) && l.eq(Ht.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Qd(e), this.currentSelection.set(r), e.scrollToSelection()) : (o > -1 || s) && (o > -1 && (e.docView.markDirty(o, i), C7e(e)), e.input.badSafariComposition && (e.input.badSafariComposition = !1, T7e(e, c)), this.handleDOMChange(o, i, a, c), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Qd(e), this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let d = 0; d < e.addedNodes.length; d++) {
        let u = e.addedNodes[d];
        n.push(u), u.nodeType == 3 && (this.lastChangedTextNode = u);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let s = e.previousSibling, o = e.nextSibling;
      if (zi && wf <= 11 && e.addedNodes.length)
        for (let d = 0; d < e.addedNodes.length; d++) {
          let { previousSibling: u, nextSibling: f } = e.addedNodes[d];
          (!u || Array.prototype.indexOf.call(e.addedNodes, u) < 0) && (s = u), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (o = f);
        }
      let i = s && s.parentNode == e.target ? to(s) + 1 : 0, a = r.localPosFromDOM(e.target, i, -1), c = o && o.parentNode == e.target ? to(o) : e.target.childNodes.length, l = r.localPosFromDOM(e.target, c, 1);
      return { from: a, to: l };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let j9 = /* @__PURE__ */ new WeakMap(), R9 = !1;
function C7e(t) {
  if (!j9.has(t) && (j9.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = ic, R9)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), R9 = !0;
  }
}
function $9(t, e) {
  let n = e.startContainer, r = e.startOffset, s = e.endContainer, o = e.endOffset, i = t.domAtPos(t.state.selection.anchor);
  return Dp(i.node, i.offset, s, o) && ([n, r, s, o] = [s, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: s, focusOffset: o };
}
function _7e(t, e) {
  if (e.getComposedRanges) {
    let s = e.getComposedRanges(t.root)[0];
    if (s)
      return $9(t, s);
  }
  let n;
  function r(s) {
    s.preventDefault(), s.stopImmediatePropagation(), n = s.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", r, !0), n ? $9(t, n) : null;
}
function E7e(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let r = t.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function T7e(t, e) {
  var n;
  let { focusNode: r, focusOffset: s } = t.domSelectionRange();
  for (let o of e)
    if (((n = o.parentNode) === null || n === void 0 ? void 0 : n.nodeName) == "TR") {
      let i = o.nextSibling;
      for (; i && i.nodeName != "TD" && i.nodeName != "TH"; )
        i = i.nextSibling;
      if (i) {
        let a = i;
        for (; ; ) {
          let c = a.firstChild;
          if (!c || c.nodeType != 1 || c.contentEditable == "false" || /^(BR|IMG)$/.test(c.nodeName))
            break;
          a = c;
        }
        a.insertBefore(o, a.firstChild), r == o && t.domSelection().collapse(o, s);
      } else
        o.parentNode.removeChild(o);
    }
}
function P7e(t, e, n) {
  let { node: r, fromOffset: s, toOffset: o, from: i, to: a } = t.docView.parseRange(e, n), c = t.domSelectionRange(), l, d = c.anchorNode;
  if (d && t.dom.contains(d.nodeType == 1 ? d : d.parentNode) && (l = [{ node: d, offset: c.anchorOffset }], tk(c) || l.push({ node: c.focusNode, offset: c.focusOffset })), Os && t.input.lastKeyCode === 8)
    for (let m = o; m > s; m--) {
      let v = r.childNodes[m - 1], b = v.pmViewDesc;
      if (v.nodeName == "BR" && !b) {
        o = m;
        break;
      }
      if (!b || b.size)
        break;
    }
  let u = t.state.doc, f = t.someProp("domParser") || km.fromSchema(t.state.schema), p = u.resolve(i), g = null, y = f.parse(r, {
    topNode: p.parent,
    topMatch: p.parent.contentMatchAt(p.index()),
    topOpen: !0,
    from: s,
    to: o,
    preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: l,
    ruleFromNode: I7e,
    context: p
  });
  if (l && l[0].pos != null) {
    let m = l[0].pos, v = l[1] && l[1].pos;
    v == null && (v = m), g = { anchor: m + i, head: v + i };
  }
  return { doc: y, sel: g, from: i, to: a };
}
function I7e(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (ao && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || ao && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const k7e = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function A7e(t, e, n, r, s) {
  let o = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let _ = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, E = B3(t, _);
    if (E && !t.state.selection.eq(E)) {
      if (Os && Wd && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (N) => N(t, jh(13, "Enter"))))
        return;
      let M = t.state.tr.setSelection(E);
      _ == "pointer" ? M.setMeta("pointer", !0) : _ == "key" && M.scrollIntoView(), o && M.setMeta("composition", o), t.dispatch(M);
    }
    return;
  }
  let i = t.state.doc.resolve(e), a = i.sharedDepth(n);
  e = i.before(a + 1), n = t.state.doc.resolve(n).after(a + 1);
  let c = t.state.selection, l = P7e(t, e, n), d = t.state.doc, u = d.slice(l.from, l.to), f, p;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, p = "end") : (f = t.state.selection.from, p = "start"), t.input.lastKeyCode = null;
  let g = D7e(u.content, l.doc.content, l.from, f, p);
  if (g && t.input.domChangeCount++, (hy && t.input.lastIOSEnter > Date.now() - 225 || Wd) && s.some((_) => _.nodeType == 1 && !k7e.test(_.nodeName)) && (!g || g.endA >= g.endB) && t.someProp("handleKeyDown", (_) => _(t, jh(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!g)
    if (r && c instanceof Dt && !c.empty && c.$head.sameParent(c.$anchor) && !t.composing && !(l.sel && l.sel.anchor != l.sel.head))
      g = { start: c.from, endA: c.to, endB: c.to };
    else {
      if (l.sel) {
        let _ = L9(t, t.state.doc, l.sel);
        if (_ && !_.eq(t.state.selection)) {
          let E = t.state.tr.setSelection(_);
          o && E.setMeta("composition", o), t.dispatch(E);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && g.start == g.endB && t.state.selection instanceof Dt && (g.start > t.state.selection.from && g.start <= t.state.selection.from + 2 && t.state.selection.from >= l.from ? g.start = t.state.selection.from : g.endA < t.state.selection.to && g.endA >= t.state.selection.to - 2 && t.state.selection.to <= l.to && (g.endB += t.state.selection.to - g.endA, g.endA = t.state.selection.to)), zi && wf <= 11 && g.endB == g.start + 1 && g.endA == g.start && g.start > l.from && l.doc.textBetween(g.start - l.from - 1, g.start - l.from + 1) == " " && (g.start--, g.endA--, g.endB--);
  let y = l.doc.resolveNoCache(g.start - l.from), m = l.doc.resolveNoCache(g.endB - l.from), v = d.resolve(g.start), b = y.sameParent(m) && y.parent.inlineContent && v.end() >= g.endA;
  if ((hy && t.input.lastIOSEnter > Date.now() - 225 && (!b || s.some((_) => _.nodeName == "DIV" || _.nodeName == "P")) || !b && y.pos < l.doc.content.size && (!y.sameParent(m) || !y.parent.inlineContent) && y.pos < m.pos && !/\S/.test(l.doc.textBetween(y.pos, m.pos, "", ""))) && t.someProp("handleKeyDown", (_) => _(t, jh(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > g.start && O7e(d, g.start, g.endA, y, m) && t.someProp("handleKeyDown", (_) => _(t, jh(8, "Backspace")))) {
    Wd && Os && t.domObserver.suppressSelectionUpdates();
    return;
  }
  Os && g.endB == g.start && (t.input.lastChromeDelete = Date.now()), Wd && !b && y.start() != m.start() && m.parentOffset == 0 && y.depth == m.depth && l.sel && l.sel.anchor == l.sel.head && l.sel.head == g.endA && (g.endB -= 2, m = l.doc.resolveNoCache(g.endB - l.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(_) {
      return _(t, jh(13, "Enter"));
    });
  }, 20));
  let x = g.start, w = g.endA, S = (_) => {
    let E = _ || t.state.tr.replace(x, w, l.doc.slice(g.start - l.from, g.endB - l.from));
    if (l.sel) {
      let M = L9(t, E.doc, l.sel);
      M && !(Os && t.composing && M.empty && (g.start != g.endB || t.input.lastChromeDelete < Date.now() - 100) && (M.head == x || M.head == E.mapping.map(w) - 1) || zi && M.empty && M.head == x) && E.setSelection(M);
    }
    return o && E.setMeta("composition", o), E.scrollIntoView();
  }, C;
  if (b)
    if (y.pos == m.pos) {
      zi && wf <= 11 && y.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Qd(t), 20));
      let _ = S(t.state.tr.delete(x, w)), E = d.resolve(g.start).marksAcross(d.resolve(g.endA));
      E && _.ensureMarks(E), t.dispatch(_);
    } else if (
      // Adding or removing a mark
      g.endA == g.endB && (C = M7e(y.parent.content.cut(y.parentOffset, m.parentOffset), v.parent.content.cut(v.parentOffset, g.endA - v.start())))
    ) {
      let _ = S(t.state.tr);
      C.type == "add" ? _.addMark(x, w, C.mark) : _.removeMark(x, w, C.mark), t.dispatch(_);
    } else if (y.parent.child(y.index()).isText && y.index() == m.index() - (m.textOffset ? 0 : 1)) {
      let _ = y.parent.textBetween(y.parentOffset, m.parentOffset), E = () => S(t.state.tr.insertText(_, x, w));
      t.someProp("handleTextInput", (M) => M(t, x, w, _, E)) || t.dispatch(E());
    } else
      t.dispatch(S());
  else
    t.dispatch(S());
}
function L9(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : z3(t, e.resolve(n.anchor), e.resolve(n.head));
}
function M7e(t, e) {
  let n = t.firstChild.marks, r = e.firstChild.marks, s = n, o = r, i, a, c;
  for (let d = 0; d < r.length; d++)
    s = r[d].removeFromSet(s);
  for (let d = 0; d < n.length; d++)
    o = n[d].removeFromSet(o);
  if (s.length == 1 && o.length == 0)
    a = s[0], i = "add", c = (d) => d.mark(a.addToSet(d.marks));
  else if (s.length == 0 && o.length == 1)
    a = o[0], i = "remove", c = (d) => d.mark(a.removeFromSet(d.marks));
  else
    return null;
  let l = [];
  for (let d = 0; d < e.childCount; d++)
    l.push(c(e.child(d)));
  if (Pe.from(l).eq(t))
    return { mark: a, type: i };
}
function O7e(t, e, n, r, s) {
  if (
    // The content must have shrunk
    n - e <= s.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    PO(r, !0, !1) < s.pos
  )
    return !1;
  let o = t.resolve(e);
  if (!r.parent.isTextblock) {
    let a = o.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let i = t.resolve(PO(o, !0, !0));
  return !i.parent.isTextblock || i.pos > n || PO(i, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(i.parent.content);
}
function PO(t, e, n) {
  let r = t.depth, s = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, s++, e = !1;
  if (n) {
    let o = t.node(r).maybeChild(t.indexAfter(r));
    for (; o && !o.isLeaf; )
      o = o.firstChild, s++;
  }
  return s;
}
function D7e(t, e, n, r, s) {
  let o = t.findDiffStart(e, n);
  if (o == null)
    return null;
  let { a: i, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (s == "end") {
    let c = Math.max(0, o - Math.min(i, a));
    r -= i + c - o;
  }
  if (i < o && t.size < e.size) {
    let c = r <= o && r >= i ? o - r : 0;
    o -= c, o && o < e.size && F9(e.textBetween(o - 1, o + 1)) && (o += c ? 1 : -1), a = o + (a - i), i = o;
  } else if (a < o) {
    let c = r <= o && r >= a ? o - r : 0;
    o -= c, o && o < t.size && F9(t.textBetween(o - 1, o + 1)) && (o += c ? 1 : -1), i = o + (i - a), a = o;
  }
  return { start: o, endA: i, endB: a };
}
function F9(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class Eae {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new qVe(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(V9), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = U9(this), z9(this), this.nodeViews = H9(this), this.docView = x9(this.state.doc, B9(this), TO(this), this.dom, this), this.domObserver = new S7e(this, (r, s, o, i) => A7e(this, r, s, o, i)), this.domObserver.start(), XVe(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Lj(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(V9), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in e)
      n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var r;
    let s = this.state, o = !1, i = !1;
    e.storedMarks && this.composing && (vae(this), i = !0), this.state = e;
    let a = s.plugins != e.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let p = H9(this);
      j7e(p, this.nodeViews) && (this.nodeViews = p, o = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && Lj(this), this.editable = U9(this), z9(this);
    let c = TO(this), l = B9(this), d = s.plugins != e.plugins && !s.doc.eq(e.doc) ? "reset" : e.scrollToSelection > s.scrollToSelection ? "to selection" : "preserve", u = o || !this.docView.matchesNode(e.doc, l, c);
    (u || !e.selection.eq(s.selection)) && (i = !0);
    let f = d == "preserve" && i && this.dom.style.overflowAnchor == null && dVe(this);
    if (i) {
      this.domObserver.stop();
      let p = u && (zi || Os) && !this.composing && !s.selection.empty && !e.selection.empty && N7e(s.selection, e.selection);
      if (u) {
        let g = Os ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = d7e(this)), (o || !this.docView.update(e.doc, l, c, this)) && (this.docView.updateOuterDeco(l), this.docView.destroy(), this.docView = x9(e.doc, l, c, this.dom, this)), g && (!this.trackWrites || !this.dom.contains(this.trackWrites)) && (p = !0);
      }
      p || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && NVe(this)) ? Qd(this, p) : (iae(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(s), !((r = this.dragging) === null || r === void 0) && r.node && !s.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, s), d == "reset" ? this.dom.scrollTop = 0 : d == "to selection" ? this.scrollToSelection() : f && uVe(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof ht) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && p9(this, n.getBoundingClientRect(), e);
      } else
        p9(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node, s = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      s = r.from;
    else {
      let o = r.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == r.node && (s = o);
    }
    this.dragging = new xae(e.slice, e.move, s < 0 ? void 0 : ht.create(this.state.doc, s));
  }
  someProp(e, n) {
    let r = this._props && this._props[e], s;
    if (r != null && (s = n ? n(r) : r))
      return s;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let a = this.directPlugins[i].props[e];
      if (a != null && (s = n ? n(a) : a))
        return s;
    }
    let o = this.state.plugins;
    if (o)
      for (let i = 0; i < o.length; i++) {
        let a = o[i].props[e];
        if (a != null && (s = n ? n(a) : a))
          return s;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (zi) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && fVe(this.dom), Qd(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return yVe(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return Qie(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let s = this.docView.posFromDOM(e, n, r);
    if (s == null)
      throw new RangeError("DOM position not inside the editor");
    return s;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return SVe(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return yw(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return yw(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return U3(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (ZVe(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], TO(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, eVe());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return JVe(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? ao && this.root.nodeType === 11 && oVe(this.dom.ownerDocument) == this.dom && _7e(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
Eae.prototype.dispatch = function(t) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, t) : this.updateState(this.state.apply(t));
};
function B9(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let r in n)
        r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
  }), e.translate || (e.translate = "no"), [ec.node(0, t.state.doc.content.size, e)];
}
function z9(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: ec.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function U9(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function N7e(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function H9(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let s in r)
      Object.prototype.hasOwnProperty.call(e, s) || (e[s] = r[s]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function j7e(t, e) {
  let n = 0, r = 0;
  for (let s in t) {
    if (t[s] != e[s])
      return !0;
    n++;
  }
  for (let s in e)
    r++;
  return n != r;
}
function V9(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Rf = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, tT = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, R7e = typeof navigator < "u" && /Mac/.test(navigator.platform), $7e = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var no = 0; no < 10; no++) Rf[48 + no] = Rf[96 + no] = String(no);
for (var no = 1; no <= 24; no++) Rf[no + 111] = "F" + no;
for (var no = 65; no <= 90; no++)
  Rf[no] = String.fromCharCode(no + 32), tT[no] = String.fromCharCode(no);
for (var IO in Rf) tT.hasOwnProperty(IO) || (tT[IO] = Rf[IO]);
function L7e(t) {
  var e = R7e && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || $7e && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? tT : Rf)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const F7e = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), B7e = typeof navigator < "u" && /Win/.test(navigator.platform);
function z7e(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, s, o, i;
  for (let a = 0; a < e.length - 1; a++) {
    let c = e[a];
    if (/^(cmd|meta|m)$/i.test(c))
      i = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      F7e ? i = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return r && (n = "Alt-" + n), s && (n = "Ctrl-" + n), i && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function U7e(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[z7e(n)] = t[n];
  return e;
}
function kO(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function H7e(t) {
  return new fo({ props: { handleKeyDown: Tae(t) } });
}
function Tae(t) {
  let e = U7e(t);
  return function(n, r) {
    let s = L7e(r), o, i = e[kO(s, r)];
    if (i && i(n.state, n.dispatch, n))
      return !0;
    if (s.length == 1 && s != " ") {
      if (r.shiftKey) {
        let a = e[kO(s, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(B7e && r.ctrlKey && r.altKey) && (o = Rf[r.keyCode]) && o != s) {
        let a = e[kO(o, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const V7e = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function Pae(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const W7e = (t, e, n) => {
  let r = Pae(t, n);
  if (!r)
    return !1;
  let s = Y3(r);
  if (!s) {
    let i = r.blockRange(), a = i && fv(i);
    return a == null ? !1 : (e && e(t.tr.lift(i, a).scrollIntoView()), !0);
  }
  let o = s.nodeBefore;
  if (Mae(t, s, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (py(o, "end") || ht.isSelectable(o)))
    for (let i = r.depth; ; i--) {
      let a = JI(t.doc, r.before(i), r.after(i), We.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let c = t.tr.step(a);
          c.setSelection(py(o, "end") ? Ht.findFrom(c.doc.resolve(c.mapping.map(s.pos, -1)), -1) : ht.create(c.doc, s.pos - o.nodeSize)), e(c.scrollIntoView());
        }
        return !0;
      }
      if (i == 1 || r.node(i - 1).childCount > 1)
        break;
    }
  return o.isAtom && s.depth == r.depth - 1 ? (e && e(t.tr.delete(s.pos - o.nodeSize, s.pos).scrollIntoView()), !0) : !1;
}, K7e = (t, e, n) => {
  let r = Pae(t, n);
  if (!r)
    return !1;
  let s = Y3(r);
  return s ? Iae(t, s, e) : !1;
}, G7e = (t, e, n) => {
  let r = kae(t, n);
  if (!r)
    return !1;
  let s = q3(r);
  return s ? Iae(t, s, e) : !1;
};
function Iae(t, e, n) {
  let r = e.nodeBefore, s = r, o = e.pos - 1;
  for (; !s.isTextblock; o--) {
    if (s.type.spec.isolating)
      return !1;
    let d = s.lastChild;
    if (!d)
      return !1;
    s = d;
  }
  let i = e.nodeAfter, a = i, c = e.pos + 1;
  for (; !a.isTextblock; c++) {
    if (a.type.spec.isolating)
      return !1;
    let d = a.firstChild;
    if (!d)
      return !1;
    a = d;
  }
  let l = JI(t.doc, o, c, We.empty);
  if (!l || l.from != o || l instanceof ks && l.slice.size >= c - o)
    return !1;
  if (n) {
    let d = t.tr.step(l);
    d.setSelection(Dt.create(d.doc, o)), n(d.scrollIntoView());
  }
  return !0;
}
function py(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const Y7e = (t, e, n) => {
  let { $head: r, empty: s } = t.selection, o = r;
  if (!s)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
      return !1;
    o = Y3(r);
  }
  let i = o && o.nodeBefore;
  return !i || !ht.isSelectable(i) ? !1 : (e && e(t.tr.setSelection(ht.create(t.doc, o.pos - i.nodeSize)).scrollIntoView()), !0);
};
function Y3(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function kae(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const q7e = (t, e, n) => {
  let r = kae(t, n);
  if (!r)
    return !1;
  let s = q3(r);
  if (!s)
    return !1;
  let o = s.nodeAfter;
  if (Mae(t, s, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (py(o, "start") || ht.isSelectable(o))) {
    let i = JI(t.doc, r.before(), r.after(), We.empty);
    if (i && i.slice.size < i.to - i.from) {
      if (e) {
        let a = t.tr.step(i);
        a.setSelection(py(o, "start") ? Ht.findFrom(a.doc.resolve(a.mapping.map(s.pos)), 1) : ht.create(a.doc, a.mapping.map(s.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && s.depth == r.depth - 1 ? (e && e(t.tr.delete(s.pos, s.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, X7e = (t, e, n) => {
  let { $head: r, empty: s } = t.selection, o = r;
  if (!s)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
      return !1;
    o = q3(r);
  }
  let i = o && o.nodeAfter;
  return !i || !ht.isSelectable(i) ? !1 : (e && e(t.tr.setSelection(ht.create(t.doc, o.pos)).scrollIntoView()), !0);
};
function q3(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const Z7e = (t, e) => {
  let n = t.selection, r = n instanceof ht, s;
  if (r) {
    if (n.node.isTextblock || !rh(t.doc, n.from))
      return !1;
    s = n.from;
  } else if (s = QI(t.doc, n.from, -1), s == null)
    return !1;
  if (e) {
    let o = t.tr.join(s);
    r && o.setSelection(ht.create(o.doc, s - t.doc.resolve(s).nodeBefore.nodeSize)), e(o.scrollIntoView());
  }
  return !0;
}, Q7e = (t, e) => {
  let n = t.selection, r;
  if (n instanceof ht) {
    if (n.node.isTextblock || !rh(t.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = QI(t.doc, n.to, 1), r == null)
    return !1;
  return e && e(t.tr.join(r).scrollIntoView()), !0;
}, J7e = (t, e) => {
  let { $from: n, $to: r } = t.selection, s = n.blockRange(r), o = s && fv(s);
  return o == null ? !1 : (e && e(t.tr.lift(s, o).scrollIntoView()), !0);
}, eWe = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function Aae(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const tWe = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let s = n.node(-1), o = n.indexAfter(-1), i = Aae(s.contentMatchAt(o));
  if (!i || !s.canReplaceWith(o, o, i))
    return !1;
  if (e) {
    let a = n.after(), c = t.tr.replaceWith(a, a, i.createAndFill());
    c.setSelection(Ht.near(c.doc.resolve(a), 1)), e(c.scrollIntoView());
  }
  return !0;
}, nWe = (t, e) => {
  let n = t.selection, { $from: r, $to: s } = n;
  if (n instanceof oc || r.parent.inlineContent || s.parent.inlineContent)
    return !1;
  let o = Aae(s.parent.contentMatchAt(s.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (e) {
    let i = (!r.parentOffset && s.index() < s.parent.childCount ? r : s).pos, a = t.tr.insert(i, o.createAndFill());
    a.setSelection(Dt.create(a.doc, i + 1)), e(a.scrollIntoView());
  }
  return !0;
}, rWe = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let o = n.before();
    if (Am(t.doc, o))
      return e && e(t.tr.split(o).scrollIntoView()), !0;
  }
  let r = n.blockRange(), s = r && fv(r);
  return s == null ? !1 : (e && e(t.tr.lift(r, s).scrollIntoView()), !0);
}, sWe = (t, e) => {
  let { $from: n, to: r } = t.selection, s, o = n.sharedDepth(r);
  return o == 0 ? !1 : (s = n.before(o), e && e(t.tr.setSelection(ht.create(t.doc, s))), !0);
};
function oWe(t, e, n) {
  let r = e.nodeBefore, s = e.nodeAfter, o = e.index();
  return !r || !s || !r.type.compatibleContent(s.type) ? !1 : !r.content.size && e.parent.canReplace(o - 1, o) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(o, o + 1) || !(s.isTextblock || rh(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function Mae(t, e, n, r) {
  let s = e.nodeBefore, o = e.nodeAfter, i, a, c = s.type.spec.isolating || o.type.spec.isolating;
  if (!c && oWe(t, e, n))
    return !0;
  let l = !c && e.parent.canReplace(e.index(), e.index() + 1);
  if (l && (i = (a = s.contentMatchAt(s.childCount)).findWrapping(o.type)) && a.matchType(i[0] || o.type).validEnd) {
    if (n) {
      let p = e.pos + o.nodeSize, g = Pe.empty;
      for (let v = i.length - 1; v >= 0; v--)
        g = Pe.from(i[v].create(null, g));
      g = Pe.from(s.copy(g));
      let y = t.tr.step(new Ns(e.pos - 1, p, e.pos, p, new We(g, 1, 0), i.length, !0)), m = y.doc.resolve(p + 2 * i.length);
      m.nodeAfter && m.nodeAfter.type == s.type && rh(y.doc, m.pos) && y.join(m.pos), n(y.scrollIntoView());
    }
    return !0;
  }
  let d = o.type.spec.isolating || r > 0 && c ? null : Ht.findFrom(e, 1), u = d && d.$from.blockRange(d.$to), f = u && fv(u);
  if (f != null && f >= e.depth)
    return n && n(t.tr.lift(u, f).scrollIntoView()), !0;
  if (l && py(o, "start", !0) && py(s, "end")) {
    let p = s, g = [];
    for (; g.push(p), !p.isTextblock; )
      p = p.lastChild;
    let y = o, m = 1;
    for (; !y.isTextblock; y = y.firstChild)
      m++;
    if (p.canReplace(p.childCount, p.childCount, y.content)) {
      if (n) {
        let v = Pe.empty;
        for (let x = g.length - 1; x >= 0; x--)
          v = Pe.from(g[x].copy(v));
        let b = t.tr.step(new Ns(e.pos - g.length, e.pos + o.nodeSize, e.pos + m, e.pos + o.nodeSize - m, new We(v, g.length, 0), 0, !0));
        n(b.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function Oae(t) {
  return function(e, n) {
    let r = e.selection, s = t < 0 ? r.$from : r.$to, o = s.depth;
    for (; s.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return s.node(o).isTextblock ? (n && n(e.tr.setSelection(Dt.create(e.doc, t < 0 ? s.start(o) : s.end(o)))), !0) : !1;
  };
}
const iWe = Oae(-1), aWe = Oae(1);
function cWe(t, e = null) {
  return function(n, r) {
    let { $from: s, $to: o } = n.selection, i = s.blockRange(o), a = i && $3(i, t, e);
    return a ? (r && r(n.tr.wrap(i, a).scrollIntoView()), !0) : !1;
  };
}
function W9(t, e = null) {
  return function(n, r) {
    let s = !1;
    for (let o = 0; o < n.selection.ranges.length && !s; o++) {
      let { $from: { pos: i }, $to: { pos: a } } = n.selection.ranges[o];
      n.doc.nodesBetween(i, a, (c, l) => {
        if (s)
          return !1;
        if (!(!c.isTextblock || c.hasMarkup(t, e)))
          if (c.type == t)
            s = !0;
          else {
            let d = n.doc.resolve(l), u = d.index();
            s = d.parent.canReplaceWith(u, u + 1, t);
          }
      });
    }
    if (!s)
      return !1;
    if (r) {
      let o = n.tr;
      for (let i = 0; i < n.selection.ranges.length; i++) {
        let { $from: { pos: a }, $to: { pos: c } } = n.selection.ranges[i];
        o.setBlockType(a, c, t, e);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function lWe(t, e = null) {
  return function(n, r) {
    let { $from: s, $to: o } = n.selection, i = s.blockRange(o);
    if (!i)
      return !1;
    let a = r ? n.tr : null;
    return dWe(a, i, t, e) ? (r && r(a.scrollIntoView()), !0) : !1;
  };
}
function dWe(t, e, n, r = null) {
  let s = !1, o = e, i = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let c = i.resolve(e.start - 2);
    o = new YE(c, c, e.depth), e.endIndex < e.parent.childCount && (e = new YE(e.$from, i.resolve(e.$to.end(e.depth)), e.depth)), s = !0;
  }
  let a = $3(o, n, r, e);
  return a ? (t && uWe(t, e, a, s, n), !0) : !1;
}
function uWe(t, e, n, r, s) {
  let o = Pe.empty;
  for (let d = n.length - 1; d >= 0; d--)
    o = Pe.from(n[d].type.create(n[d].attrs, o));
  t.step(new Ns(e.start - (r ? 2 : 0), e.end, e.start, e.end, new We(o, 0, 0), n.length, !0));
  let i = 0;
  for (let d = 0; d < n.length; d++)
    n[d].type == s && (i = d + 1);
  let a = n.length - i, c = e.start + n.length - (r ? 2 : 0), l = e.parent;
  for (let d = e.startIndex, u = e.endIndex, f = !0; d < u; d++, f = !1)
    !f && Am(t.doc, c, a) && (t.split(c, a), c += 2 * a), c += l.child(d).nodeSize;
  return t;
}
function fWe(t) {
  return function(e, n) {
    let { $from: r, $to: s } = e.selection, o = r.blockRange(s, (i) => i.childCount > 0 && i.firstChild.type == t);
    return o ? n ? r.node(o.depth - 1).type == t ? hWe(e, n, t, o) : pWe(e, n, o) : !0 : !1;
  };
}
function hWe(t, e, n, r) {
  let s = t.tr, o = r.end, i = r.$to.end(r.depth);
  o < i && (s.step(new Ns(o - 1, i, o, i, new We(Pe.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new YE(s.doc.resolve(r.$from.pos), s.doc.resolve(i), r.depth));
  const a = fv(r);
  if (a == null)
    return !1;
  s.lift(r, a);
  let c = s.doc.resolve(s.mapping.map(o, -1) - 1);
  return rh(s.doc, c.pos) && c.nodeBefore.type == c.nodeAfter.type && s.join(c.pos), e(s.scrollIntoView()), !0;
}
function pWe(t, e, n) {
  let r = t.tr, s = n.parent;
  for (let p = n.end, g = n.endIndex - 1, y = n.startIndex; g > y; g--)
    p -= s.child(g).nodeSize, r.delete(p - 1, p + 1);
  let o = r.doc.resolve(n.start), i = o.nodeAfter;
  if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, c = n.endIndex == s.childCount, l = o.node(-1), d = o.index(-1);
  if (!l.canReplace(d + (a ? 0 : 1), d + 1, i.content.append(c ? Pe.empty : Pe.from(s))))
    return !1;
  let u = o.pos, f = u + i.nodeSize;
  return r.step(new Ns(u - (a ? 1 : 0), f + (c ? 1 : 0), u + 1, f - 1, new We((a ? Pe.empty : Pe.from(s.copy(Pe.empty))).append(c ? Pe.empty : Pe.from(s.copy(Pe.empty))), a ? 0 : 1, c ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function gWe(t) {
  return function(e, n) {
    let { $from: r, $to: s } = e.selection, o = r.blockRange(s, (l) => l.childCount > 0 && l.firstChild.type == t);
    if (!o)
      return !1;
    let i = o.startIndex;
    if (i == 0)
      return !1;
    let a = o.parent, c = a.child(i - 1);
    if (c.type != t)
      return !1;
    if (n) {
      let l = c.lastChild && c.lastChild.type == a.type, d = Pe.from(l ? t.create() : null), u = new We(Pe.from(t.create(null, Pe.from(a.type.create(null, d)))), l ? 3 : 1, 0), f = o.start, p = o.end;
      n(e.tr.step(new Ns(f - (l ? 3 : 1), p, f, p, u, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function sk(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n, { doc: s } = n, { storedMarks: o } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return o;
    },
    get selection() {
      return r;
    },
    get doc() {
      return s;
    },
    get tr() {
      return r = n.selection, s = n.doc, o = n.storedMarks, n;
    }
  };
}
class ok {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: r } = this, { view: s } = n, { tr: o } = r, i = this.buildProps(o);
    return Object.fromEntries(Object.entries(e).map(([a, c]) => [a, (...d) => {
      const u = c(...d)(i);
      return !o.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(o), u;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: r, editor: s, state: o } = this, { view: i } = s, a = [], c = !!e, l = e || o.tr, d = () => (!c && n && !l.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(l), a.every((f) => f === !0)), u = {
      ...Object.fromEntries(Object.entries(r).map(([f, p]) => [f, (...y) => {
        const m = this.buildProps(l, n), v = p(...y)(m);
        return a.push(v), u;
      }])),
      run: d
    };
    return u;
  }
  createCan(e) {
    const { rawCommands: n, state: r } = this, s = !1, o = e || r.tr, i = this.buildProps(o, s);
    return {
      ...Object.fromEntries(Object.entries(n).map(([c, l]) => [c, (...d) => l(...d)({ ...i, dispatch: void 0 })])),
      chain: () => this.createChain(o, s)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: r, editor: s, state: o } = this, { view: i } = s, a = {
      tr: e,
      editor: s,
      view: i,
      state: sk({
        state: o,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(r).map(([c, l]) => [c, (...d) => l(...d)(a)]));
      }
    };
    return a;
  }
}
class mWe {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const r = this.callbacks[e];
    return r && r.forEach((s) => s.apply(this, n)), this;
  }
  off(e, n) {
    const r = this.callbacks[e];
    return r && (n ? this.callbacks[e] = r.filter((s) => s !== n) : delete this.callbacks[e]), this;
  }
  once(e, n) {
    const r = (...s) => {
      this.off(e, r), n.apply(this, s);
    };
    return this.on(e, r);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function et(t, e, n) {
  return t.config[e] === void 0 && t.parent ? et(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? et(t.parent, e, n) : null
  }) : t.config[e];
}
function ik(t) {
  const e = t.filter((s) => s.type === "extension"), n = t.filter((s) => s.type === "node"), r = t.filter((s) => s.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: r
  };
}
function Dae(t) {
  const e = [], { nodeExtensions: n, markExtensions: r } = ik(t), s = [...n, ...r], o = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((i) => {
    const a = {
      name: i.name,
      options: i.options,
      storage: i.storage,
      extensions: s
    }, c = et(i, "addGlobalAttributes", a);
    if (!c)
      return;
    c().forEach((d) => {
      d.types.forEach((u) => {
        Object.entries(d.attributes).forEach(([f, p]) => {
          e.push({
            type: u,
            name: f,
            attribute: {
              ...o,
              ...p
            }
          });
        });
      });
    });
  }), s.forEach((i) => {
    const a = {
      name: i.name,
      options: i.options,
      storage: i.storage
    }, c = et(i, "addAttributes", a);
    if (!c)
      return;
    const l = c();
    Object.entries(l).forEach(([d, u]) => {
      const f = {
        ...o,
        ...u
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({
        type: i.name,
        name: d,
        attribute: f
      });
    });
  }), e;
}
function Rs(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function $s(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const r = { ...e };
    return Object.entries(n).forEach(([s, o]) => {
      if (!r[s]) {
        r[s] = o;
        return;
      }
      if (s === "class") {
        const a = o ? String(o).split(" ") : [], c = r[s] ? r[s].split(" ") : [], l = a.filter((d) => !c.includes(d));
        r[s] = [...c, ...l].join(" ");
      } else if (s === "style") {
        const a = o ? o.split(";").map((d) => d.trim()).filter(Boolean) : [], c = r[s] ? r[s].split(";").map((d) => d.trim()).filter(Boolean) : [], l = /* @__PURE__ */ new Map();
        c.forEach((d) => {
          const [u, f] = d.split(":").map((p) => p.trim());
          l.set(u, f);
        }), a.forEach((d) => {
          const [u, f] = d.split(":").map((p) => p.trim());
          l.set(u, f);
        }), r[s] = Array.from(l.entries()).map(([d, u]) => `${d}: ${u}`).join("; ");
      } else
        r[s] = o;
    }), r;
  }, {});
}
function Fj(t, e) {
  return e.filter((n) => n.type === t.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, r) => $s(n, r), {});
}
function Nae(t) {
  return typeof t == "function";
}
function Kt(t, e = void 0, ...n) {
  return Nae(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function yWe(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function vWe(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function K9(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (r === !1)
        return !1;
      const s = e.reduce((o, i) => {
        const a = i.attribute.parseHTML ? i.attribute.parseHTML(n) : vWe(n.getAttribute(i.name));
        return a == null ? o : {
          ...o,
          [i.name]: a
        };
      }, {});
      return { ...r, ...s };
    }
  };
}
function G9(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && yWe(n) ? !1 : n != null)
  );
}
function jae(t, e) {
  var n;
  const r = Dae(t), { nodeExtensions: s, markExtensions: o } = ik(t), i = (n = s.find((l) => et(l, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(s.map((l) => {
    const d = r.filter((v) => v.type === l.name), u = {
      name: l.name,
      options: l.options,
      storage: l.storage,
      editor: e
    }, f = t.reduce((v, b) => {
      const x = et(b, "extendNodeSchema", u);
      return {
        ...v,
        ...x ? x(l) : {}
      };
    }, {}), p = G9({
      ...f,
      content: Kt(et(l, "content", u)),
      marks: Kt(et(l, "marks", u)),
      group: Kt(et(l, "group", u)),
      inline: Kt(et(l, "inline", u)),
      atom: Kt(et(l, "atom", u)),
      selectable: Kt(et(l, "selectable", u)),
      draggable: Kt(et(l, "draggable", u)),
      code: Kt(et(l, "code", u)),
      whitespace: Kt(et(l, "whitespace", u)),
      linebreakReplacement: Kt(et(l, "linebreakReplacement", u)),
      defining: Kt(et(l, "defining", u)),
      isolating: Kt(et(l, "isolating", u)),
      attrs: Object.fromEntries(d.map((v) => {
        var b;
        return [v.name, { default: (b = v == null ? void 0 : v.attribute) === null || b === void 0 ? void 0 : b.default }];
      }))
    }), g = Kt(et(l, "parseHTML", u));
    g && (p.parseDOM = g.map((v) => K9(v, d)));
    const y = et(l, "renderHTML", u);
    y && (p.toDOM = (v) => y({
      node: v,
      HTMLAttributes: Fj(v, d)
    }));
    const m = et(l, "renderText", u);
    return m && (p.toText = m), [l.name, p];
  })), c = Object.fromEntries(o.map((l) => {
    const d = r.filter((m) => m.type === l.name), u = {
      name: l.name,
      options: l.options,
      storage: l.storage,
      editor: e
    }, f = t.reduce((m, v) => {
      const b = et(v, "extendMarkSchema", u);
      return {
        ...m,
        ...b ? b(l) : {}
      };
    }, {}), p = G9({
      ...f,
      inclusive: Kt(et(l, "inclusive", u)),
      excludes: Kt(et(l, "excludes", u)),
      group: Kt(et(l, "group", u)),
      spanning: Kt(et(l, "spanning", u)),
      code: Kt(et(l, "code", u)),
      attrs: Object.fromEntries(d.map((m) => {
        var v;
        return [m.name, { default: (v = m == null ? void 0 : m.attribute) === null || v === void 0 ? void 0 : v.default }];
      }))
    }), g = Kt(et(l, "parseHTML", u));
    g && (p.parseDOM = g.map((m) => K9(m, d)));
    const y = et(l, "renderHTML", u);
    return y && (p.toDOM = (m) => y({
      mark: m,
      HTMLAttributes: Fj(m, d)
    })), [l.name, p];
  }));
  return new Tie({
    topNode: i,
    nodes: a,
    marks: c
  });
}
function AO(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function Y9(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
function ak(t, e) {
  const n = yg.fromSchema(e).serializeFragment(t), s = document.implementation.createHTMLDocument().createElement("div");
  return s.appendChild(n), s.innerHTML;
}
const bWe = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, r - e), r, (s, o, i, a) => {
    var c, l;
    const d = ((l = (c = s.type.spec).toText) === null || l === void 0 ? void 0 : l.call(c, {
      node: s,
      pos: o,
      parent: i,
      index: a
    })) || s.textContent || "%leaf%";
    n += s.isAtom && !s.isText ? d : d.slice(0, Math.max(0, r - o));
  }), n;
};
function X3(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class ck {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const xWe = (t, e) => {
  if (X3(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function L1(t) {
  var e;
  const { editor: n, from: r, to: s, text: o, rules: i, plugin: a } = t, { view: c } = n;
  if (c.composing)
    return !1;
  const l = c.state.doc.resolve(r);
  if (
    // check for code node
    l.parent.type.spec.code || !((e = l.nodeBefore || l.nodeAfter) === null || e === void 0) && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let d = !1;
  const u = bWe(l) + o;
  return i.forEach((f) => {
    if (d)
      return;
    const p = xWe(u, f.find);
    if (!p)
      return;
    const g = c.state.tr, y = sk({
      state: c.state,
      transaction: g
    }), m = {
      from: r - (p[0].length - o.length),
      to: s
    }, { commands: v, chain: b, can: x } = new ok({
      editor: n,
      state: y
    });
    f.handler({
      state: y,
      range: m,
      match: p,
      commands: v,
      chain: b,
      can: x
    }) === null || !g.steps.length || (g.setMeta(a, {
      transform: g,
      from: r,
      to: s,
      text: o
    }), c.dispatch(g), d = !0);
  }), d;
}
function wWe(t) {
  const { editor: e, rules: n } = t, r = new fo({
    state: {
      init() {
        return null;
      },
      apply(s, o, i) {
        const a = s.getMeta(r);
        if (a)
          return a;
        const c = s.getMeta("applyInputRules");
        return !!c && setTimeout(() => {
          let { text: d } = c;
          typeof d == "string" ? d = d : d = ak(Pe.from(d), i.schema);
          const { from: u } = c, f = u + d.length;
          L1({
            editor: e,
            from: u,
            to: f,
            text: d,
            rules: n,
            plugin: r
          });
        }), s.selectionSet || s.docChanged ? null : o;
      }
    },
    props: {
      handleTextInput(s, o, i, a) {
        return L1({
          editor: e,
          from: o,
          to: i,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (s) => (setTimeout(() => {
          const { $cursor: o } = s.state.selection;
          o && L1({
            editor: e,
            from: o.pos,
            to: o.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(s, o) {
        if (o.key !== "Enter")
          return !1;
        const { $cursor: i } = s.state.selection;
        return i ? L1({
          editor: e,
          from: i.pos,
          to: i.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function SWe(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function F1(t) {
  return SWe(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function lk(t, e) {
  const n = { ...t };
  return F1(t) && F1(e) && Object.keys(e).forEach((r) => {
    F1(e[r]) && F1(t[r]) ? n[r] = lk(t[r], e[r]) : n[r] = e[r];
  }), n;
}
class Jl {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Kt(et(this, "addOptions", {
      name: this.name
    }))), this.storage = Kt(et(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Jl(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => lk(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Jl(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Kt(et(n, "addOptions", {
      name: n.name
    })), n.storage = Kt(et(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state, s = e.state.selection.$from;
    if (s.pos === s.end()) {
      const i = s.marks();
      if (!!!i.find((l) => (l == null ? void 0 : l.type.name) === n.name))
        return !1;
      const c = i.find((l) => (l == null ? void 0 : l.type.name) === n.name);
      return c && r.removeStoredMark(c), r.insertText(" ", s.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
}
function CWe(t) {
  return typeof t == "number";
}
class _We {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const EWe = (t, e, n) => {
  if (X3(e))
    return [...t.matchAll(e)];
  const r = e(t, n);
  return r ? r.map((s) => {
    const o = [s.text];
    return o.index = s.index, o.input = t, o.data = s.data, s.replaceWith && (s.text.includes(s.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(s.replaceWith)), o;
  }) : [];
};
function TWe(t) {
  const { editor: e, state: n, from: r, to: s, rule: o, pasteEvent: i, dropEvent: a } = t, { commands: c, chain: l, can: d } = new ok({
    editor: e,
    state: n
  }), u = [];
  return n.doc.nodesBetween(r, s, (p, g) => {
    if (!p.isTextblock || p.type.spec.code)
      return;
    const y = Math.max(r, g), m = Math.min(s, g + p.content.size), v = p.textBetween(y - g, m - g, void 0, "");
    EWe(v, o.find, i).forEach((x) => {
      if (x.index === void 0)
        return;
      const w = y + x.index + 1, S = w + x[0].length, C = {
        from: n.tr.mapping.map(w),
        to: n.tr.mapping.map(S)
      }, _ = o.handler({
        state: n,
        range: C,
        match: x,
        commands: c,
        chain: l,
        can: d,
        pasteEvent: i,
        dropEvent: a
      });
      u.push(_);
    });
  }), u.every((p) => p !== null);
}
let B1 = null;
const PWe = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t), n;
};
function IWe(t) {
  const { editor: e, rules: n } = t;
  let r = null, s = !1, o = !1, i = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const c = ({ state: d, from: u, to: f, rule: p, pasteEvt: g }) => {
    const y = d.tr, m = sk({
      state: d,
      transaction: y
    });
    if (!(!TWe({
      editor: e,
      state: m,
      from: Math.max(u - 1, 0),
      to: f.b - 1,
      rule: p,
      pasteEvent: g,
      dropEvent: a
    }) || !y.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return i = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, y;
    }
  };
  return n.map((d) => new fo({
    // we register a global drag handler to track the current drag source element
    view(u) {
      const f = (g) => {
        var y;
        r = !((y = u.dom.parentElement) === null || y === void 0) && y.contains(g.target) ? u.dom.parentElement : null, r && (B1 = e);
      }, p = () => {
        B1 && (B1 = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", p), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", p);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (u, f) => {
          if (o = r === u.dom.parentElement, a = f, !o) {
            const p = B1;
            p != null && p.isEditable && setTimeout(() => {
              const g = p.state.selection;
              g && p.commands.deleteRange({ from: g.from, to: g.to });
            }, 10);
          }
          return !1;
        },
        paste: (u, f) => {
          var p;
          const g = (p = f.clipboardData) === null || p === void 0 ? void 0 : p.getData("text/html");
          return i = f, s = !!(g != null && g.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (u, f, p) => {
      const g = u[0], y = g.getMeta("uiEvent") === "paste" && !s, m = g.getMeta("uiEvent") === "drop" && !o, v = g.getMeta("applyPasteRules"), b = !!v;
      if (!y && !m && !b)
        return;
      if (b) {
        let { text: S } = v;
        typeof S == "string" ? S = S : S = ak(Pe.from(S), p.schema);
        const { from: C } = v, _ = C + S.length, E = PWe(S);
        return c({
          rule: d,
          state: p,
          from: C,
          to: { b: _ },
          pasteEvt: E
        });
      }
      const x = f.doc.content.findDiffStart(p.doc.content), w = f.doc.content.findDiffEnd(p.doc.content);
      if (!(!CWe(x) || !w || x === w.b))
        return c({
          rule: d,
          state: p,
          from: x,
          to: w,
          pasteEvt: i
        });
    }
  }));
}
function kWe(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return Array.from(new Set(e));
}
class zh {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = zh.resolve(e), this.schema = jae(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = zh.sort(zh.flatten(e)), r = kWe(n.map((s) => s.name));
    return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((s) => `'${s}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, s = et(n, "addExtensions", r);
      return s ? [n, ...this.flatten(s())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((r, s) => {
      const o = et(r, "priority") || 100, i = et(s, "priority") || 100;
      return o > i ? -1 : o < i ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: AO(n.name, this.schema)
      }, s = et(n, "addCommands", r);
      return s ? {
        ...e,
        ...s()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, n = zh.sort([...this.extensions].reverse()), r = [], s = [], o = n.map((i) => {
      const a = {
        name: i.name,
        options: i.options,
        storage: i.storage,
        editor: e,
        type: AO(i.name, this.schema)
      }, c = [], l = et(i, "addKeyboardShortcuts", a);
      let d = {};
      if (i.type === "mark" && et(i, "exitable", a) && (d.ArrowRight = () => Jl.handleExit({ editor: e, mark: i })), l) {
        const y = Object.fromEntries(Object.entries(l()).map(([m, v]) => [m, () => v({ editor: e })]));
        d = { ...d, ...y };
      }
      const u = H7e(d);
      c.push(u);
      const f = et(i, "addInputRules", a);
      Y9(i, e.options.enableInputRules) && f && r.push(...f());
      const p = et(i, "addPasteRules", a);
      Y9(i, e.options.enablePasteRules) && p && s.push(...p());
      const g = et(i, "addProseMirrorPlugins", a);
      if (g) {
        const y = g();
        c.push(...y);
      }
      return c;
    }).flat();
    return [
      wWe({
        editor: e,
        rules: r
      }),
      ...IWe({
        editor: e,
        rules: s
      }),
      ...o
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return Dae(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = ik(this.extensions);
    return Object.fromEntries(n.filter((r) => !!et(r, "addNodeView")).map((r) => {
      const s = this.attributes.filter((c) => c.type === r.name), o = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: e,
        type: Rs(r.name, this.schema)
      }, i = et(r, "addNodeView", o);
      if (!i)
        return [];
      const a = (c, l, d, u, f) => {
        const p = Fj(c, s);
        return i()({
          // pass-through
          node: c,
          view: l,
          getPos: d,
          decorations: u,
          innerDecorations: f,
          // tiptap-specific
          editor: e,
          extension: r,
          HTMLAttributes: p
        });
      };
      return [r.name, a];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const r = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: AO(e.name, this.schema)
      };
      e.type === "mark" && (!((n = Kt(et(e, "keepOnSplit", r))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
      const s = et(e, "onBeforeCreate", r), o = et(e, "onCreate", r), i = et(e, "onUpdate", r), a = et(e, "onSelectionUpdate", r), c = et(e, "onTransaction", r), l = et(e, "onFocus", r), d = et(e, "onBlur", r), u = et(e, "onDestroy", r);
      s && this.editor.on("beforeCreate", s), o && this.editor.on("create", o), i && this.editor.on("update", i), a && this.editor.on("selectionUpdate", a), c && this.editor.on("transaction", c), l && this.editor.on("focus", l), d && this.editor.on("blur", d), u && this.editor.on("destroy", u);
    });
  }
}
class co {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Kt(et(this, "addOptions", {
      name: this.name
    }))), this.storage = Kt(et(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new co(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => lk(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new co({ ...this.config, ...e });
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Kt(et(n, "addOptions", {
      name: n.name
    })), n.storage = Kt(et(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function Rae(t, e, n) {
  const { from: r, to: s } = e, { blockSeparator: o = `

`, textSerializers: i = {} } = n || {};
  let a = "";
  return t.nodesBetween(r, s, (c, l, d, u) => {
    var f;
    c.isBlock && l > r && (a += o);
    const p = i == null ? void 0 : i[c.type.name];
    if (p)
      return d && (a += p({
        node: c,
        pos: l,
        parent: d,
        index: u,
        range: e
      })), !1;
    c.isText && (a += (f = c == null ? void 0 : c.text) === null || f === void 0 ? void 0 : f.slice(Math.max(r, l) - l, s - l));
  }), a;
}
function Z3(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const AWe = co.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new fo({
        key: new Oa("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: r, selection: s } = e, { ranges: o } = s, i = Math.min(...o.map((d) => d.$from.pos)), a = Math.max(...o.map((d) => d.$to.pos)), c = Z3(n);
            return Rae(r, { from: i, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: c
            });
          }
        }
      })
    ];
  }
}), MWe = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), OWe = (t = !1) => ({ commands: e }) => e.setContent("", t), DWe = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: r } = e, { ranges: s } = r;
  return n && s.forEach(({ $from: o, $to: i }) => {
    t.doc.nodesBetween(o.pos, i.pos, (a, c) => {
      if (a.type.isText)
        return;
      const { doc: l, mapping: d } = e, u = l.resolve(d.map(c)), f = l.resolve(d.map(c + a.nodeSize)), p = u.blockRange(f);
      if (!p)
        return;
      const g = fv(p);
      if (a.type.isTextblock) {
        const { defaultType: y } = u.parent.contentMatchAt(u.index());
        e.setNodeMarkup(p.start, y);
      }
      (g || g === 0) && e.lift(p, g);
    });
  }), !0;
}, NWe = (t) => (e) => t(e), jWe = () => ({ state: t, dispatch: e }) => nWe(t, e), RWe = (t, e) => ({ editor: n, tr: r }) => {
  const { state: s } = n, o = s.doc.slice(t.from, t.to);
  r.deleteRange(t.from, t.to);
  const i = r.mapping.map(e);
  return r.insert(i, o.content), r.setSelection(new Dt(r.doc.resolve(Math.max(i - 1, 0)))), !0;
}, $We = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const s = t.selection.$anchor;
  for (let o = s.depth; o > 0; o -= 1)
    if (s.node(o).type === r.type) {
      if (e) {
        const a = s.before(o), c = s.after(o);
        t.delete(a, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, LWe = (t) => ({ tr: e, state: n, dispatch: r }) => {
  const s = Rs(t, n.schema), o = e.selection.$anchor;
  for (let i = o.depth; i > 0; i -= 1)
    if (o.node(i).type === s) {
      if (r) {
        const c = o.before(i), l = o.after(i);
        e.delete(c, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, FWe = (t) => ({ tr: e, dispatch: n }) => {
  const { from: r, to: s } = t;
  return n && e.delete(r, s), !0;
}, BWe = () => ({ state: t, dispatch: e }) => V7e(t, e), zWe = () => ({ commands: t }) => t.keyboardShortcut("Enter"), UWe = () => ({ state: t, dispatch: e }) => tWe(t, e);
function nT(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((s) => n.strict ? e[s] === t[s] : X3(e[s]) ? e[s].test(t[s]) : e[s] === t[s]) : !0;
}
function $ae(t, e, n = {}) {
  return t.find((r) => r.type === e && nT(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((s) => [s, r.attrs[s]])),
    n
  ));
}
function q9(t, e, n = {}) {
  return !!$ae(t, e, n);
}
function dk(t, e, n) {
  var r;
  if (!t || !e)
    return;
  let s = t.parent.childAfter(t.parentOffset);
  if ((!s.node || !s.node.marks.some((d) => d.type === e)) && (s = t.parent.childBefore(t.parentOffset)), !s.node || !s.node.marks.some((d) => d.type === e) || (n = n || ((r = s.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !$ae([...s.node.marks], e, n)))
    return;
  let i = s.index, a = t.start() + s.offset, c = i + 1, l = a + s.node.nodeSize;
  for (; i > 0 && q9([...t.parent.child(i - 1).marks], e, n); )
    i -= 1, a -= t.parent.child(i).nodeSize;
  for (; c < t.parent.childCount && q9([...t.parent.child(c).marks], e, n); )
    l += t.parent.child(c).nodeSize, c += 1;
  return {
    from: a,
    to: l
  };
}
function oh(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const HWe = (t, e = {}) => ({ tr: n, state: r, dispatch: s }) => {
  const o = oh(t, r.schema), { doc: i, selection: a } = n, { $from: c, from: l, to: d } = a;
  if (s) {
    const u = dk(c, o, e);
    if (u && u.from <= l && u.to >= d) {
      const f = Dt.create(i, u.from, u.to);
      n.setSelection(f);
    }
  }
  return !0;
}, VWe = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](e))
      return !0;
  return !1;
};
function Lae(t) {
  return t instanceof Dt;
}
function Uh(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function Fae(t, e = null) {
  if (!e)
    return null;
  const n = Ht.atStart(t), r = Ht.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return r;
  const s = n.from, o = r.to;
  return e === "all" ? Dt.create(t, Uh(0, s, o), Uh(t.content.size, s, o)) : Dt.create(t, Uh(e, s, o), Uh(e, s, o));
}
function X9() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function rT() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function WWe() {
  return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
}
const KWe = (t = null, e = {}) => ({ editor: n, view: r, tr: s, dispatch: o }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const i = () => {
    (rT() || X9()) && r.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), WWe() && !rT() && !X9() && r.dom.focus({ preventScroll: !0 }));
    });
  };
  if (r.hasFocus() && t === null || t === !1)
    return !0;
  if (o && t === null && !Lae(n.state.selection))
    return i(), !0;
  const a = Fae(s.doc, t) || n.state.selection, c = n.state.selection.eq(a);
  return o && (c || s.setSelection(a), c && s.storedMarks && s.setStoredMarks(s.storedMarks), i()), !0;
}, GWe = (t, e) => (n) => t.every((r, s) => e(r, { ...n, index: s })), YWe = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), Bae = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const r = e[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && Bae(r);
  }
  return t;
};
function Bb(t) {
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return Bae(n);
}
function bw(t, e, n) {
  if (t instanceof Zc || t instanceof Pe)
    return t;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof t == "object" && t !== null, s = typeof t == "string";
  if (r)
    try {
      if (Array.isArray(t) && t.length > 0)
        return Pe.fromArray(t.map((a) => e.nodeFromJSON(a)));
      const i = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && i.check(), i;
    } catch (o) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: o });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", o), bw("", e, n);
    }
  if (s) {
    if (n.errorOnInvalidContent) {
      let i = !1, a = "";
      const c = new Tie({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (l) => (i = !0, a = typeof l == "string" ? l : l.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? km.fromSchema(c).parseSlice(Bb(t), n.parseOptions) : km.fromSchema(c).parse(Bb(t), n.parseOptions), n.errorOnInvalidContent && i)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
    }
    const o = km.fromSchema(e);
    return n.slice ? o.parseSlice(Bb(t), n.parseOptions).content : o.parse(Bb(t), n.parseOptions);
  }
  return bw("", e, n);
}
function qWe(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e)
    return;
  const s = t.steps[r];
  if (!(s instanceof ks || s instanceof Ns))
    return;
  const o = t.mapping.maps[r];
  let i = 0;
  o.forEach((a, c, l, d) => {
    i === 0 && (i = d);
  }), t.setSelection(Ht.near(t.doc.resolve(i), n));
}
const XWe = (t) => !("type" in t), ZWe = (t, e, n) => ({ tr: r, dispatch: s, editor: o }) => {
  var i;
  if (s) {
    n = {
      parseOptions: o.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    const c = (m) => {
      o.emit("contentError", {
        editor: o,
        error: m,
        disableCollaboration: () => {
          o.storage.collaboration && (o.storage.collaboration.isDisabled = !0);
        }
      });
    }, l = {
      preserveWhitespace: "full",
      ...n.parseOptions
    };
    if (!n.errorOnInvalidContent && !o.options.enableContentCheck && o.options.emitContentError)
      try {
        bw(e, o.schema, {
          parseOptions: l,
          errorOnInvalidContent: !0
        });
      } catch (m) {
        c(m);
      }
    try {
      a = bw(e, o.schema, {
        parseOptions: l,
        errorOnInvalidContent: (i = n.errorOnInvalidContent) !== null && i !== void 0 ? i : o.options.enableContentCheck
      });
    } catch (m) {
      return c(m), !1;
    }
    let { from: d, to: u } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, f = !0, p = !0;
    if ((XWe(a) ? a : [a]).forEach((m) => {
      m.check(), f = f ? m.isText && m.marks.length === 0 : !1, p = p ? m.isBlock : !1;
    }), d === u && p) {
      const { parent: m } = r.doc.resolve(d);
      m.isTextblock && !m.type.spec.code && !m.childCount && (d -= 1, u += 1);
    }
    let y;
    if (f) {
      if (Array.isArray(e))
        y = e.map((m) => m.text || "").join("");
      else if (e instanceof Pe) {
        let m = "";
        e.forEach((v) => {
          v.text && (m += v.text);
        }), y = m;
      } else typeof e == "object" && e && e.text ? y = e.text : y = e;
      r.insertText(y, d, u);
    } else
      y = a, r.replaceWith(d, u, y);
    n.updateSelection && qWe(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: d, text: y }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: d, text: y });
  }
  return !0;
}, QWe = () => ({ state: t, dispatch: e }) => Z7e(t, e), JWe = () => ({ state: t, dispatch: e }) => Q7e(t, e), eKe = () => ({ state: t, dispatch: e }) => W7e(t, e), tKe = () => ({ state: t, dispatch: e }) => q7e(t, e), nKe = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = QI(t.doc, t.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, rKe = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = QI(t.doc, t.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, sKe = () => ({ state: t, dispatch: e }) => K7e(t, e), oKe = () => ({ state: t, dispatch: e }) => G7e(t, e);
function zae() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function iKe(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, s, o, i;
  for (let a = 0; a < e.length - 1; a += 1) {
    const c = e[a];
    if (/^(cmd|meta|m)$/i.test(c))
      i = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      rT() || zae() ? i = !0 : s = !0;
    else
      throw new Error(`Unrecognized modifier name: ${c}`);
  }
  return r && (n = `Alt-${n}`), s && (n = `Ctrl-${n}`), i && (n = `Meta-${n}`), o && (n = `Shift-${n}`), n;
}
const aKe = (t) => ({ editor: e, view: n, tr: r, dispatch: s }) => {
  const o = iKe(t).split(/-(?!$)/), i = o.find((l) => !["Alt", "Ctrl", "Meta", "Shift"].includes(l)), a = new KeyboardEvent("keydown", {
    key: i === "Space" ? " " : i,
    altKey: o.includes("Alt"),
    ctrlKey: o.includes("Ctrl"),
    metaKey: o.includes("Meta"),
    shiftKey: o.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), c = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (l) => l(n, a));
  });
  return c == null || c.steps.forEach((l) => {
    const d = l.map(r.mapping);
    d && s && r.maybeStep(d);
  }), !0;
};
function xw(t, e, n = {}) {
  const { from: r, to: s, empty: o } = t.selection, i = e ? Rs(e, t.schema) : null, a = [];
  t.doc.nodesBetween(r, s, (u, f) => {
    if (u.isText)
      return;
    const p = Math.max(r, f), g = Math.min(s, f + u.nodeSize);
    a.push({
      node: u,
      from: p,
      to: g
    });
  });
  const c = s - r, l = a.filter((u) => i ? i.name === u.node.type.name : !0).filter((u) => nT(u.node.attrs, n, { strict: !1 }));
  return o ? !!l.length : l.reduce((u, f) => u + f.to - f.from, 0) >= c;
}
const cKe = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const s = Rs(t, n.schema);
  return xw(n, s, e) ? J7e(n, r) : !1;
}, lKe = () => ({ state: t, dispatch: e }) => rWe(t, e), dKe = (t) => ({ state: e, dispatch: n }) => {
  const r = Rs(t, e.schema);
  return fWe(r)(e, n);
}, uKe = () => ({ state: t, dispatch: e }) => eWe(t, e);
function uk(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function Z9(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((r, s) => (n.includes(s) || (r[s] = t[s]), r), {});
}
const fKe = (t, e) => ({ tr: n, state: r, dispatch: s }) => {
  let o = null, i = null;
  const a = uk(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (o = Rs(t, r.schema)), a === "mark" && (i = oh(t, r.schema)), s && n.selection.ranges.forEach((c) => {
    r.doc.nodesBetween(c.$from.pos, c.$to.pos, (l, d) => {
      o && o === l.type && n.setNodeMarkup(d, void 0, Z9(l.attrs, e)), i && l.marks.length && l.marks.forEach((u) => {
        i === u.type && n.addMark(d, d + l.nodeSize, i.create(Z9(u.attrs, e)));
      });
    });
  }), !0) : !1;
}, hKe = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), pKe = () => ({ tr: t, dispatch: e }) => {
  if (e) {
    const n = new oc(t.doc);
    t.setSelection(n);
  }
  return !0;
}, gKe = () => ({ state: t, dispatch: e }) => Y7e(t, e), mKe = () => ({ state: t, dispatch: e }) => X7e(t, e), yKe = () => ({ state: t, dispatch: e }) => sWe(t, e), vKe = () => ({ state: t, dispatch: e }) => aWe(t, e), bKe = () => ({ state: t, dispatch: e }) => iWe(t, e);
function Bj(t, e, n = {}, r = {}) {
  return bw(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
const xKe = (t, e = !1, n = {}, r = {}) => ({ editor: s, tr: o, dispatch: i, commands: a }) => {
  var c, l;
  const { doc: d } = o;
  if (n.preserveWhitespace !== "full") {
    const u = Bj(t, s.schema, n, {
      errorOnInvalidContent: (c = r.errorOnInvalidContent) !== null && c !== void 0 ? c : s.options.enableContentCheck
    });
    return i && o.replaceWith(0, d.content.size, u).setMeta("preventUpdate", !e), !0;
  }
  return i && o.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: d.content.size }, t, {
    parseOptions: n,
    errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : s.options.enableContentCheck
  });
};
function Uae(t, e) {
  const n = oh(e, t.schema), { from: r, to: s, empty: o } = t.selection, i = [];
  o ? (t.storedMarks && i.push(...t.storedMarks), i.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, s, (c) => {
    i.push(...c.marks);
  });
  const a = i.find((c) => c.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function wKe(t, e) {
  const n = new Uie(t);
  return e.forEach((r) => {
    r.steps.forEach((s) => {
      n.step(s);
    });
  }), n;
}
function SKe(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function CKe(t, e, n) {
  const r = [];
  return t.nodesBetween(e.from, e.to, (s, o) => {
    n(s) && r.push({
      node: s,
      pos: o
    });
  }), r;
}
function _Ke(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r
      };
  }
}
function Q3(t) {
  return (e) => _Ke(e.$from, t);
}
function fk(t, e) {
  const n = zh.resolve(t);
  return jae(n, e);
}
function EKe(t, e) {
  const n = fk(e), r = Zc.fromJSON(n, t);
  return ak(r.content, n);
}
function TKe(t, e) {
  const n = fk(e), r = Bb(t);
  return km.fromSchema(n).parse(r).toJSON();
}
function Hae(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return Rae(t, n, e);
}
function PKe(t, e, n) {
  const { blockSeparator: r = `

`, textSerializers: s = {} } = n || {}, o = fk(e), i = Zc.fromJSON(o, t);
  return Hae(i, {
    blockSeparator: r,
    textSerializers: {
      ...Z3(o),
      ...s
    }
  });
}
function IKe(t, e) {
  const n = Rs(e, t.schema), { from: r, to: s } = t.selection, o = [];
  t.doc.nodesBetween(r, s, (a) => {
    o.push(a);
  });
  const i = o.reverse().find((a) => a.type.name === n.name);
  return i ? { ...i.attrs } : {};
}
function Vae(t, e) {
  const n = uk(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? IKe(t, e) : n === "mark" ? Uae(t, e) : {};
}
function kKe(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const s = e(r);
    return Object.prototype.hasOwnProperty.call(n, s) ? !1 : n[s] = !0;
  });
}
function AKe(t) {
  const e = kKe(t);
  return e.length === 1 ? e : e.filter((n, r) => !e.filter((o, i) => i !== r).some((o) => n.oldRange.from >= o.oldRange.from && n.oldRange.to <= o.oldRange.to && n.newRange.from >= o.newRange.from && n.newRange.to <= o.newRange.to));
}
function MKe(t) {
  const { mapping: e, steps: n } = t, r = [];
  return e.maps.forEach((s, o) => {
    const i = [];
    if (s.ranges.length)
      s.forEach((a, c) => {
        i.push({ from: a, to: c });
      });
    else {
      const { from: a, to: c } = n[o];
      if (a === void 0 || c === void 0)
        return;
      i.push({ from: a, to: c });
    }
    i.forEach(({ from: a, to: c }) => {
      const l = e.slice(o).map(a, -1), d = e.slice(o).map(c), u = e.invert().map(l, -1), f = e.invert().map(d);
      r.push({
        oldRange: {
          from: u,
          to: f
        },
        newRange: {
          from: l,
          to: d
        }
      });
    });
  }), AKe(r);
}
function J3(t, e, n) {
  const r = [];
  return t === e ? n.resolve(t).marks().forEach((s) => {
    const o = n.resolve(t), i = dk(o, s.type);
    i && r.push({
      mark: s,
      ...i
    });
  }) : n.nodesBetween(t, e, (s, o) => {
    !s || (s == null ? void 0 : s.nodeSize) === void 0 || r.push(...s.marks.map((i) => ({
      from: o,
      to: o + s.nodeSize,
      mark: i
    })));
  }), r;
}
function c_(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([r]) => {
    const s = t.find((o) => o.type === e && o.name === r);
    return s ? s.attribute.keepOnSplit : !1;
  }));
}
function zj(t, e, n = {}) {
  const { empty: r, ranges: s } = t.selection, o = e ? oh(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((u) => o ? o.name === u.type.name : !0).find((u) => nT(u.attrs, n, { strict: !1 }));
  let i = 0;
  const a = [];
  if (s.forEach(({ $from: u, $to: f }) => {
    const p = u.pos, g = f.pos;
    t.doc.nodesBetween(p, g, (y, m) => {
      if (!y.isText && !y.marks.length)
        return;
      const v = Math.max(p, m), b = Math.min(g, m + y.nodeSize), x = b - v;
      i += x, a.push(...y.marks.map((w) => ({
        mark: w,
        from: v,
        to: b
      })));
    });
  }), i === 0)
    return !1;
  const c = a.filter((u) => o ? o.name === u.mark.type.name : !0).filter((u) => nT(u.mark.attrs, n, { strict: !1 })).reduce((u, f) => u + f.to - f.from, 0), l = a.filter((u) => o ? u.mark.type !== o && u.mark.type.excludes(o) : !0).reduce((u, f) => u + f.to - f.from, 0);
  return (c > 0 ? c + l : c) >= i;
}
function OKe(t, e, n = {}) {
  if (!e)
    return xw(t, null, n) || zj(t, null, n);
  const r = uk(e, t.schema);
  return r === "node" ? xw(t, e, n) : r === "mark" ? zj(t, e, n) : !1;
}
function Q9(t, e) {
  const { nodeExtensions: n } = ik(e), r = n.find((i) => i.name === t);
  if (!r)
    return !1;
  const s = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, o = Kt(et(r, "group", s));
  return typeof o != "string" ? !1 : o.split(" ").includes("list");
}
function e5(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  var r;
  if (n) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let s = !0;
    return t.content.forEach((o) => {
      s !== !1 && (e5(o, { ignoreWhitespace: n, checkChildren: e }) || (s = !1));
    }), s;
  }
  return !1;
}
function DKe(t) {
  return t instanceof ht;
}
function NKe(t, e, n) {
  var r;
  const { selection: s } = e;
  let o = null;
  if (Lae(s) && (o = s.$cursor), o) {
    const a = (r = t.storedMarks) !== null && r !== void 0 ? r : o.marks();
    return !!n.isInSet(a) || !a.some((c) => c.type.excludes(n));
  }
  const { ranges: i } = s;
  return i.some(({ $from: a, $to: c }) => {
    let l = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, c.pos, (d, u, f) => {
      if (l)
        return !1;
      if (d.isInline) {
        const p = !f || f.type.allowsMarkType(n), g = !!n.isInSet(d.marks) || !d.marks.some((y) => y.type.excludes(n));
        l = p && g;
      }
      return !l;
    }), l;
  });
}
const jKe = (t, e = {}) => ({ tr: n, state: r, dispatch: s }) => {
  const { selection: o } = n, { empty: i, ranges: a } = o, c = oh(t, r.schema);
  if (s)
    if (i) {
      const l = Uae(r, c);
      n.addStoredMark(c.create({
        ...l,
        ...e
      }));
    } else
      a.forEach((l) => {
        const d = l.$from.pos, u = l.$to.pos;
        r.doc.nodesBetween(d, u, (f, p) => {
          const g = Math.max(p, d), y = Math.min(p + f.nodeSize, u);
          f.marks.find((v) => v.type === c) ? f.marks.forEach((v) => {
            c === v.type && n.addMark(g, y, c.create({
              ...v.attrs,
              ...e
            }));
          }) : n.addMark(g, y, c.create(e));
        });
      });
  return NKe(r, n, c);
}, RKe = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), $Ke = (t, e = {}) => ({ state: n, dispatch: r, chain: s }) => {
  const o = Rs(t, n.schema);
  let i;
  return n.selection.$anchor.sameParent(n.selection.$head) && (i = n.selection.$anchor.parent.attrs), o.isTextblock ? s().command(({ commands: a }) => W9(o, { ...i, ...e })(n) ? !0 : a.clearNodes()).command(({ state: a }) => W9(o, { ...i, ...e })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, LKe = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, s = Uh(t, 0, r.content.size), o = ht.create(r, s);
    e.setSelection(o);
  }
  return !0;
}, FKe = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, { from: s, to: o } = typeof t == "number" ? { from: t, to: t } : t, i = Dt.atStart(r).from, a = Dt.atEnd(r).to, c = Uh(s, i, a), l = Uh(o, i, a), d = Dt.create(r, c, l);
    e.setSelection(d);
  }
  return !0;
}, BKe = (t) => ({ state: e, dispatch: n }) => {
  const r = Rs(t, e.schema);
  return gWe(r)(e, n);
};
function J9(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const r = n.filter((s) => e == null ? void 0 : e.includes(s.type.name));
    t.tr.ensureMarks(r);
  }
}
const zKe = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: s }) => {
  const { selection: o, doc: i } = e, { $from: a, $to: c } = o, l = s.extensionManager.attributes, d = c_(l, a.node().type.name, a.node().attrs);
  if (o instanceof ht && o.node.isBlock)
    return !a.parentOffset || !Am(i, a.pos) ? !1 : (r && (t && J9(n, s.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const u = c.parentOffset === c.parent.content.size, f = a.depth === 0 ? void 0 : SKe(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let p = u && f ? [
    {
      type: f,
      attrs: d
    }
  ] : void 0, g = Am(e.doc, e.mapping.map(a.pos), 1, p);
  if (!p && !g && Am(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (g = !0, p = f ? [
    {
      type: f,
      attrs: d
    }
  ] : void 0), r) {
    if (g && (o instanceof Dt && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, p), f && !u && !a.parentOffset && a.parent.type !== f)) {
      const y = e.mapping.map(a.before()), m = e.doc.resolve(y);
      a.node(-1).canReplaceWith(m.index(), m.index() + 1, f) && e.setNodeMarkup(e.mapping.map(a.before()), f);
    }
    t && J9(n, s.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return g;
}, UKe = (t, e = {}) => ({ tr: n, state: r, dispatch: s, editor: o }) => {
  var i;
  const a = Rs(t, r.schema), { $from: c, $to: l } = r.selection, d = r.selection.node;
  if (d && d.isBlock || c.depth < 2 || !c.sameParent(l))
    return !1;
  const u = c.node(-1);
  if (u.type !== a)
    return !1;
  const f = o.extensionManager.attributes;
  if (c.parent.content.size === 0 && c.node(-1).childCount === c.indexAfter(-1)) {
    if (c.depth === 2 || c.node(-3).type !== a || c.index(-2) !== c.node(-2).childCount - 1)
      return !1;
    if (s) {
      let v = Pe.empty;
      const b = c.index(-1) ? 1 : c.index(-2) ? 2 : 3;
      for (let E = c.depth - b; E >= c.depth - 3; E -= 1)
        v = Pe.from(c.node(E).copy(v));
      const x = c.indexAfter(-1) < c.node(-2).childCount ? 1 : c.indexAfter(-2) < c.node(-3).childCount ? 2 : 3, w = {
        ...c_(f, c.node().type.name, c.node().attrs),
        ...e
      }, S = ((i = a.contentMatch.defaultType) === null || i === void 0 ? void 0 : i.createAndFill(w)) || void 0;
      v = v.append(Pe.from(a.createAndFill(null, S) || void 0));
      const C = c.before(c.depth - (b - 1));
      n.replace(C, c.after(-x), new We(v, 4 - b, 0));
      let _ = -1;
      n.doc.nodesBetween(C, n.doc.content.size, (E, M) => {
        if (_ > -1)
          return !1;
        E.isTextblock && E.content.size === 0 && (_ = M + 1);
      }), _ > -1 && n.setSelection(Dt.near(n.doc.resolve(_))), n.scrollIntoView();
    }
    return !0;
  }
  const p = l.pos === c.end() ? u.contentMatchAt(0).defaultType : null, g = {
    ...c_(f, u.type.name, u.attrs),
    ...e
  }, y = {
    ...c_(f, c.node().type.name, c.node().attrs),
    ...e
  };
  n.delete(c.pos, l.pos);
  const m = p ? [
    { type: a, attrs: g },
    { type: p, attrs: y }
  ] : [{ type: a, attrs: g }];
  if (!Am(n.doc, c.pos, 2))
    return !1;
  if (s) {
    const { selection: v, storedMarks: b } = r, { splittableMarks: x } = o.extensionManager, w = b || v.$to.parentOffset && v.$from.marks();
    if (n.split(c.pos, 2, m).scrollIntoView(), !w || !s)
      return !0;
    const S = w.filter((C) => x.includes(C.type.name));
    n.ensureMarks(S);
  }
  return !0;
}, MO = (t, e) => {
  const n = Q3((i) => i.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const s = t.doc.nodeAt(r);
  return n.node.type === (s == null ? void 0 : s.type) && rh(t.doc, n.pos) && t.join(n.pos), !0;
}, OO = (t, e) => {
  const n = Q3((i) => i.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const s = t.doc.nodeAt(r);
  return n.node.type === (s == null ? void 0 : s.type) && rh(t.doc, r) && t.join(r), !0;
}, HKe = (t, e, n, r = {}) => ({ editor: s, tr: o, state: i, dispatch: a, chain: c, commands: l, can: d }) => {
  const { extensions: u, splittableMarks: f } = s.extensionManager, p = Rs(t, i.schema), g = Rs(e, i.schema), { selection: y, storedMarks: m } = i, { $from: v, $to: b } = y, x = v.blockRange(b), w = m || y.$to.parentOffset && y.$from.marks();
  if (!x)
    return !1;
  const S = Q3((C) => Q9(C.type.name, u))(y);
  if (x.depth >= 1 && S && x.depth - S.depth <= 1) {
    if (S.node.type === p)
      return l.liftListItem(g);
    if (Q9(S.node.type.name, u) && p.validContent(S.node.content) && a)
      return c().command(() => (o.setNodeMarkup(S.pos, p), !0)).command(() => MO(o, p)).command(() => OO(o, p)).run();
  }
  return !n || !w || !a ? c().command(() => d().wrapInList(p, r) ? !0 : l.clearNodes()).wrapInList(p, r).command(() => MO(o, p)).command(() => OO(o, p)).run() : c().command(() => {
    const C = d().wrapInList(p, r), _ = w.filter((E) => f.includes(E.type.name));
    return o.ensureMarks(_), C ? !0 : l.clearNodes();
  }).wrapInList(p, r).command(() => MO(o, p)).command(() => OO(o, p)).run();
}, VKe = (t, e = {}, n = {}) => ({ state: r, commands: s }) => {
  const { extendEmptyMarkRange: o = !1 } = n, i = oh(t, r.schema);
  return zj(r, i, e) ? s.unsetMark(i, { extendEmptyMarkRange: o }) : s.setMark(i, e);
}, WKe = (t, e, n = {}) => ({ state: r, commands: s }) => {
  const o = Rs(t, r.schema), i = Rs(e, r.schema), a = xw(r, o, n);
  let c;
  return r.selection.$anchor.sameParent(r.selection.$head) && (c = r.selection.$anchor.parent.attrs), a ? s.setNode(i, c) : s.setNode(o, { ...c, ...n });
}, KKe = (t, e = {}) => ({ state: n, commands: r }) => {
  const s = Rs(t, n.schema);
  return xw(n, s, e) ? r.lift(s) : r.wrapIn(s, e);
}, GKe = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const s = n[r];
    let o;
    if (s.spec.isInputRules && (o = s.getState(t))) {
      if (e) {
        const i = t.tr, a = o.transform;
        for (let c = a.steps.length - 1; c >= 0; c -= 1)
          i.step(a.steps[c].invert(a.docs[c]));
        if (o.text) {
          const c = i.doc.resolve(o.from).marks();
          i.replaceWith(o.from, o.to, t.schema.text(o.text, c));
        } else
          i.delete(o.from, o.to);
      }
      return !0;
    }
  }
  return !1;
}, YKe = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: r, ranges: s } = n;
  return r || e && s.forEach((o) => {
    t.removeMark(o.$from.pos, o.$to.pos);
  }), !0;
}, qKe = (t, e = {}) => ({ tr: n, state: r, dispatch: s }) => {
  var o;
  const { extendEmptyMarkRange: i = !1 } = e, { selection: a } = n, c = oh(t, r.schema), { $from: l, empty: d, ranges: u } = a;
  if (!s)
    return !0;
  if (d && i) {
    let { from: f, to: p } = a;
    const g = (o = l.marks().find((m) => m.type === c)) === null || o === void 0 ? void 0 : o.attrs, y = dk(l, c, g);
    y && (f = y.from, p = y.to), n.removeMark(f, p, c);
  } else
    u.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, c);
    });
  return n.removeStoredMark(c), !0;
}, XKe = (t, e = {}) => ({ tr: n, state: r, dispatch: s }) => {
  let o = null, i = null;
  const a = uk(typeof t == "string" ? t : t.name, r.schema);
  return a ? (a === "node" && (o = Rs(t, r.schema)), a === "mark" && (i = oh(t, r.schema)), s && n.selection.ranges.forEach((c) => {
    const l = c.$from.pos, d = c.$to.pos;
    let u, f, p, g;
    n.selection.empty ? r.doc.nodesBetween(l, d, (y, m) => {
      o && o === y.type && (p = Math.max(m, l), g = Math.min(m + y.nodeSize, d), u = m, f = y);
    }) : r.doc.nodesBetween(l, d, (y, m) => {
      m < l && o && o === y.type && (p = Math.max(m, l), g = Math.min(m + y.nodeSize, d), u = m, f = y), m >= l && m <= d && (o && o === y.type && n.setNodeMarkup(m, void 0, {
        ...y.attrs,
        ...e
      }), i && y.marks.length && y.marks.forEach((v) => {
        if (i === v.type) {
          const b = Math.max(m, l), x = Math.min(m + y.nodeSize, d);
          n.addMark(b, x, i.create({
            ...v.attrs,
            ...e
          }));
        }
      }));
    }), f && (u !== void 0 && n.setNodeMarkup(u, void 0, {
      ...f.attrs,
      ...e
    }), i && f.marks.length && f.marks.forEach((y) => {
      i === y.type && n.addMark(p, g, i.create({
        ...y.attrs,
        ...e
      }));
    }));
  }), !0) : !1;
}, ZKe = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const s = Rs(t, n.schema);
  return cWe(s, e)(n, r);
}, QKe = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const s = Rs(t, n.schema);
  return lWe(s, e)(n, r);
};
var JKe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: MWe,
  clearContent: OWe,
  clearNodes: DWe,
  command: NWe,
  createParagraphNear: jWe,
  cut: RWe,
  deleteCurrentNode: $We,
  deleteNode: LWe,
  deleteRange: FWe,
  deleteSelection: BWe,
  enter: zWe,
  exitCode: UWe,
  extendMarkRange: HWe,
  first: VWe,
  focus: KWe,
  forEach: GWe,
  insertContent: YWe,
  insertContentAt: ZWe,
  joinBackward: eKe,
  joinDown: JWe,
  joinForward: tKe,
  joinItemBackward: nKe,
  joinItemForward: rKe,
  joinTextblockBackward: sKe,
  joinTextblockForward: oKe,
  joinUp: QWe,
  keyboardShortcut: aKe,
  lift: cKe,
  liftEmptyBlock: lKe,
  liftListItem: dKe,
  newlineInCode: uKe,
  resetAttributes: fKe,
  scrollIntoView: hKe,
  selectAll: pKe,
  selectNodeBackward: gKe,
  selectNodeForward: mKe,
  selectParentNode: yKe,
  selectTextblockEnd: vKe,
  selectTextblockStart: bKe,
  setContent: xKe,
  setMark: jKe,
  setMeta: RKe,
  setNode: $Ke,
  setNodeSelection: LKe,
  setTextSelection: FKe,
  sinkListItem: BKe,
  splitBlock: zKe,
  splitListItem: UKe,
  toggleList: HKe,
  toggleMark: VKe,
  toggleNode: WKe,
  toggleWrap: KKe,
  undoInputRule: GKe,
  unsetAllMarks: YKe,
  unsetMark: qKe,
  updateAttributes: XKe,
  wrapIn: ZKe,
  wrapInList: QKe
});
const eGe = co.create({
  name: "commands",
  addCommands() {
    return {
      ...JKe
    };
  }
}), tGe = co.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new fo({
        key: new Oa("tiptapDrop"),
        props: {
          handleDrop: (t, e, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), nGe = co.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new fo({
        key: new Oa("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), rGe = new Oa("focusEvents"), sGe = co.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new fo({
        key: rGe,
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const r = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const r = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), oGe = co.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: i }) => [
      () => i.undoInputRule(),
      // maybe convert first text block node to default node
      () => i.command(({ tr: a }) => {
        const { selection: c, doc: l } = a, { empty: d, $anchor: u } = c, { pos: f, parent: p } = u, g = u.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : u, y = g.parent.type.spec.isolating, m = u.pos - u.parentOffset, v = y && g.parent.childCount === 1 ? m === u.pos : Ht.atStart(l).from === f;
        return !d || !p.type.isTextblock || p.textContent.length || !v || v && u.parent.type.name === "paragraph" ? !1 : i.clearNodes();
      }),
      () => i.deleteSelection(),
      () => i.joinBackward(),
      () => i.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: i }) => [
      () => i.deleteSelection(),
      () => i.deleteCurrentNode(),
      () => i.joinForward(),
      () => i.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: i }) => [
        () => i.newlineInCode(),
        () => i.createParagraphNear(),
        () => i.liftEmptyBlock(),
        () => i.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, s = {
      ...r
    }, o = {
      ...r,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return rT() || zae() ? o : s;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new fo({
        key: new Oa("clearDocument"),
        appendTransaction: (t, e, n) => {
          if (t.some((y) => y.getMeta("composition")))
            return;
          const r = t.some((y) => y.docChanged) && !e.doc.eq(n.doc), s = t.some((y) => y.getMeta("preventClearDocument"));
          if (!r || s)
            return;
          const { empty: o, from: i, to: a } = e.selection, c = Ht.atStart(e.doc).from, l = Ht.atEnd(e.doc).to;
          if (o || !(i === c && a === l) || !e5(n.doc))
            return;
          const f = n.tr, p = sk({
            state: n,
            transaction: f
          }), { commands: g } = new ok({
            editor: this.editor,
            state: p
          });
          if (g.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), iGe = co.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new fo({
        key: new Oa("tiptapPaste"),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
}), aGe = co.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new fo({
        key: new Oa("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class Rh {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, r = !1, s = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = n, this.currentNode = s;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new Rh(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Rh(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Rh(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, r) => {
      const s = n.isBlock && !n.isTextblock, o = n.isAtom && !n.isText, i = this.pos + r + (o ? 0 : 1);
      if (i < 0 || i > this.resolvedPos.doc.nodeSize - 2)
        return;
      const a = this.resolvedPos.doc.resolve(i);
      if (!s && a.depth <= this.depth)
        return;
      const c = new Rh(a, this.editor, s, s ? n : null);
      s && (c.actualDepth = this.depth + 1), e.push(new Rh(a, this.editor, s, s ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let r = null, s = this.parent;
    for (; s && !r; ) {
      if (s.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const o = s.node.attrs, i = Object.keys(n);
          for (let a = 0; a < i.length; a += 1) {
            const c = i[a];
            if (o[c] !== n[c])
              break;
          }
        } else
          r = s;
      s = s.parent;
    }
    return r;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, r = !1) {
    let s = [];
    if (!this.children || this.children.length === 0)
      return s;
    const o = Object.keys(n);
    return this.children.forEach((i) => {
      r && s.length > 0 || (i.node.type.name === e && o.every((c) => n[c] === i.node.attrs[c]) && s.push(i), !(r && s.length > 0) && (s = s.concat(i.querySelectorAll(e, n, r))));
    }), s;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
}
const cGe = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function lGe(t, e, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const s = document.createElement("style");
  return e && s.setAttribute("nonce", e), s.setAttribute("data-tiptap-style", ""), s.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(s), s;
}
class dGe extends mWe {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: r, moved: s }) => this.options.onDrop(n, r, s)), this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = lGe(cGe, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, n) {
    const r = Nae(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], s = this.state.reconfigure({ plugins: r });
    return this.view.updateState(s), s;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = this.state.plugins;
    let r = n;
    if ([].concat(e).forEach((o) => {
      const i = typeof o == "string" ? `${o}$` : o.key;
      r = r.filter((a) => !a.key.startsWith(i));
    }), n.length === r.length)
      return;
    const s = this.state.reconfigure({
      plugins: r
    });
    return this.view.updateState(s), s;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const s = [...this.options.enableCoreExtensions ? [
      nGe,
      AWe.configure({
        blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      eGe,
      sGe,
      oGe,
      aGe,
      tGe,
      iGe
    ].filter((o) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[o.name] !== !1 : !0) : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o == null ? void 0 : o.type));
    this.extensionManager = new zh(s, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new ok({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let n;
    try {
      n = Bj(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (i) {
      if (!(i instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(i.message))
        throw i;
      this.emit("contentError", {
        editor: this,
        error: i,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
        }
      }), n = Bj(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const r = Fae(n, this.options.autofocus);
    this.view = new Eae(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: hm.create({
        doc: n,
        selection: r || void 0
      })
    });
    const s = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(s), this.createNodeViews(), this.prependClass();
    const o = this.view.dom;
    o.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((i) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(i);
      });
      return;
    }
    const n = this.state.apply(e), r = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const s = e.getMeta("focus"), o = e.getMeta("blur");
    s && this.emit("focus", {
      editor: this,
      event: s.event,
      transaction: e
    }), o && this.emit("blur", {
      editor: this,
      event: o.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return Vae(this.state, e);
  }
  isActive(e, n) {
    const r = typeof e == "string" ? e : null, s = typeof e == "string" ? n : e;
    return OKe(this.state, r, s);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return ak(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: r = {} } = e || {};
    return Hae(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...Z3(this.schema),
        ...r
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return e5(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null;
  }
  $nodes(e, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null;
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new Rh(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
}
function jp(t) {
  return new ck({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const s = Kt(t.getAttributes, void 0, r);
      if (s === !1 || s === null)
        return null;
      const { tr: o } = e, i = r[r.length - 1], a = r[0];
      if (i) {
        const c = a.search(/\S/), l = n.from + a.indexOf(i), d = l + i.length;
        if (J3(n.from, n.to, e.doc).filter((p) => p.mark.type.excluded.find((y) => y === t.type && y !== p.mark.type)).filter((p) => p.to > l).length)
          return null;
        d < n.to && o.delete(d, n.to), l > n.from && o.delete(n.from + c, l);
        const f = n.from + c + i.length;
        o.addMark(n.from + c, f, t.type.create(s || {})), o.removeStoredMark(t.type);
      }
    }
  });
}
function uGe(t) {
  return new ck({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const s = Kt(t.getAttributes, void 0, r) || {}, { tr: o } = e, i = n.from;
      let a = n.to;
      const c = t.type.create(s);
      if (r[1]) {
        const l = r[0].lastIndexOf(r[1]);
        let d = i + l;
        d > a ? d = a : a = d + r[1].length;
        const u = r[0][r[0].length - 1];
        o.insertText(u, i + r[0].length - 1), o.replaceWith(d, a, c);
      } else if (r[0]) {
        const l = t.type.isInline ? i : i - 1;
        o.insert(l, t.type.create(s)).delete(o.mapping.map(i), o.mapping.map(a));
      }
      o.scrollIntoView();
    }
  });
}
function Uj(t) {
  return new ck({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const s = e.doc.resolve(n.from), o = Kt(t.getAttributes, void 0, r) || {};
      if (!s.node(-1).canReplaceWith(s.index(-1), s.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, o);
    }
  });
}
function ww(t) {
  return new ck({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: s }) => {
      const o = Kt(t.getAttributes, void 0, r) || {}, i = e.tr.delete(n.from, n.to), c = i.doc.resolve(n.from).blockRange(), l = c && $3(c, t.type, o);
      if (!l)
        return null;
      if (i.wrap(c, l), t.keepMarks && t.editor) {
        const { selection: u, storedMarks: f } = e, { splittableMarks: p } = t.editor.extensionManager, g = f || u.$to.parentOffset && u.$from.marks();
        if (g) {
          const y = g.filter((m) => p.includes(m.type.name));
          i.ensureMarks(y);
        }
      }
      if (t.keepAttributes) {
        const u = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        s().updateAttributes(u, o).run();
      }
      const d = i.doc.resolve(n.from - 1).nodeBefore;
      d && d.type === t.type && rh(i.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, d)) && i.join(n.from - 1);
    }
  });
}
let ul = class Hj {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Kt(et(this, "addOptions", {
      name: this.name
    }))), this.storage = Kt(et(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Hj(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => lk(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Hj(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Kt(et(n, "addOptions", {
      name: n.name
    })), n.storage = Kt(et(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
function $f(t) {
  return new _We({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: s }) => {
      const o = Kt(t.getAttributes, void 0, r, s);
      if (o === !1 || o === null)
        return null;
      const { tr: i } = e, a = r[r.length - 1], c = r[0];
      let l = n.to;
      if (a) {
        const d = c.search(/\S/), u = n.from + c.indexOf(a), f = u + a.length;
        if (J3(n.from, n.to, e.doc).filter((g) => g.mark.type.excluded.find((m) => m === t.type && m !== g.mark.type)).filter((g) => g.to > u).length)
          return null;
        f < n.to && i.delete(f, n.to), u > n.from && i.delete(n.from + d, u), l = n.from + d + a.length, i.addMark(n.from + d, l, t.type.create(o || {})), i.removeStoredMark(t.type);
      }
    }
  });
}
function fGe(t, e) {
  const { selection: n } = t, { $from: r } = n;
  if (n instanceof ht) {
    const o = r.index();
    return r.parent.canReplaceWith(o, o + 1, e);
  }
  let s = r.depth;
  for (; s >= 0; ) {
    const o = r.index(s);
    if (r.node(s).contentMatchAt(o).matchType(e))
      return !0;
    s -= 1;
  }
  return !1;
}
const hGe = new No();
function pGe(t) {
  return hGe.get(t, () => fk(t.extensions ?? []));
}
function t5(t, e, n) {
  const { tipTapConfig: r, addFontsFromNode: s } = t.getTextOptions();
  tt(r, "textOptions.tipTapConfig must be set to use rich text"), tt(s, "textOptions.addFontsFromNode must be set to use rich text");
  const o = pGe(r), i = Zc.fromJSON(o, e), a = /* @__PURE__ */ new Set();
  function c(d) {
    a.add(d);
  }
  function l(d, u) {
    u = s(d, u, c);
    for (const f of d.children)
      l(f, u);
  }
  return l(i, n), Array.from(a);
}
async function eV({ shouldReload: t = !0 } = {}) {
  lDe();
  for (const e of UE.connectedInstances)
    await e.close();
  await Promise.all(A3().map((e) => $oe(e))), cDe(), t && window.location.reload();
}
typeof window < "u" && (process.env.NODE_ENV === "development" && (window.hardReset = eV), window.__tldraw__hardReset = eV);
function gGe(t, e = "_blank") {
  RI.openWindow(t, e);
}
Xf(
  "@tldraw/editor",
  "3.15.5",
  "esm"
);
class ln {
  constructor() {
    /** @internal */
    P(this, "commands", []);
    P(this, "lastMoveTo", null);
  }
  static lineThroughPoints(e, n) {
    const r = new ln();
    r.moveTo(e[0].x, e[0].y, { ...n, offset: (n == null ? void 0 : n.endOffsets) ?? (n == null ? void 0 : n.offset) });
    for (let s = 1; s < e.length; s++) {
      const o = s === e.length - 1;
      r.lineTo(e[s].x, e[s].y, o ? { offset: n == null ? void 0 : n.endOffsets } : void 0);
    }
    return r;
  }
  static cubicSplineThroughPoints(e, n) {
    const r = new ln(), s = e.length, o = s - 2, i = 1.25;
    r.moveTo(e[0].x, e[0].y, { ...n, offset: (n == null ? void 0 : n.endOffsets) ?? (n == null ? void 0 : n.offset) });
    for (let a = 0; a < s - 1; a++) {
      const c = a === 0 ? e[0] : e[a - 1], l = e[a], d = e[a + 1], u = a === o ? d : e[a + 2];
      let f, p, g, y;
      a === 0 ? (f = c.x, p = c.y) : (f = l.x + (d.x - c.x) / 6 * i, p = l.y + (d.y - c.y) / 6 * i);
      let m;
      a === o ? (g = d.x, y = d.y, m = { offset: n == null ? void 0 : n.endOffsets }) : (g = d.x - (u.x - l.x) / 6 * i, y = d.y - (u.y - l.y) / 6 * i), r.cubicBezierTo(d.x, d.y, f, p, g, y, m);
    }
    return r;
  }
  assertHasMoveTo() {
    return tt(this.lastMoveTo, "Start an SVGPathBuilder with `.moveTo()`"), this.lastMoveTo;
  }
  moveTo(e, n, r) {
    return this.lastMoveTo = { type: "move", x: e, y: n, closeIdx: null, isClose: !1, opts: r }, this.commands.push(this.lastMoveTo), this;
  }
  lineTo(e, n, r) {
    return this.assertHasMoveTo(), this.commands.push({ type: "line", x: e, y: n, isClose: !1, opts: r }), this;
  }
  circularArcTo(e, n, r, s, o, i) {
    return this.arcTo(e, e, n, r, 0, s, o, i);
  }
  arcTo(e, n, r, s, o, i, a, c) {
    this.assertHasMoveTo();
    const l = this.commands[this.commands.length - 1].x, d = this.commands[this.commands.length - 1].y;
    if (l === i && d === a)
      return this;
    if (e === 0 || n === 0)
      return this.lineTo(i, a, c);
    const u = o, f = Math.sin(u), p = Math.cos(u);
    let g = Math.abs(e), y = Math.abs(n);
    const m = (l - i) / 2, v = (d - a) / 2, b = p * m + f * v, x = -f * m + p * v, w = b * b / (g * g) + x * x / (y * y);
    if (w > 1) {
      const Y = Math.sqrt(w);
      g *= Y, y *= Y;
    }
    const S = r !== s ? 1 : -1, C = g * g * y * y - g * g * x * x - y * y * b * b, _ = g * g * x * x + y * y * b * b;
    let E = C / _;
    E = E < 0 ? 0 : E;
    const M = S * Math.sqrt(E), N = M * (g * x / y), O = M * (-(y * b) / g), D = p * N - f * O + (l + i) / 2, k = f * N + p * O + (d + a) / 2, A = (b - N) / g, R = (x - O) / y, j = (-b - N) / g, $ = (-x - O) / y, F = Math.atan2(R, A);
    let L = Math.atan2($, j);
    !s && L > F ? L -= 2 * Math.PI : s && L < F && (L += 2 * Math.PI);
    const z = L - F, H = Math.max(g, y) * Math.abs(z), U = Math.min(4, Math.ceil(Math.abs(z) / (Math.PI / 2))), W = Math.ceil(
      XI(H) / U
    ), Z = z / U, K = (Y) => ({
      x: D + g * Math.cos(Y) * p - y * Math.sin(Y) * f,
      y: k + g * Math.cos(Y) * f + y * Math.sin(Y) * p
    }), oe = (Y) => ({
      x: -g * Math.sin(Y) * p - y * Math.cos(Y) * f,
      y: -g * Math.sin(Y) * f + y * Math.cos(Y) * p
    });
    for (let Y = 0; Y < U; Y++) {
      const ee = F + Y * Z, ae = F + (Y + 1) * Z, de = ae - ee, ye = K(ee), G = K(ae), xe = oe(ee), ge = oe(ae), ze = 4 / 3 * Math.tan(de / 4), Ge = ye.x + ze * xe.x, Ct = ye.y + ze * xe.y, vn = G.x - ze * ge.x, Yt = G.y - ze * ge.y, X = Y === 0 ? c : { ...c, mergeWithPrevious: !0 };
      this.cubicBezierToWithResolution(
        G.x,
        G.y,
        Ge,
        Ct,
        vn,
        Yt,
        X,
        W
      );
    }
    return this;
  }
  cubicBezierTo(e, n, r, s, o, i, a) {
    return this.cubicBezierToWithResolution(e, n, r, s, o, i, a);
  }
  cubicBezierToWithResolution(e, n, r, s, o, i, a, c) {
    return this.assertHasMoveTo(), this.commands.push({
      type: "cubic",
      x: e,
      y: n,
      cp1: { x: r, y: s },
      cp2: { x: o, y: i },
      isClose: !1,
      opts: a,
      resolution: c
    }), this;
  }
  close() {
    const e = this.assertHasMoveTo(), n = this.commands[this.commands.length - 1];
    return Hr(e.x, n.x) && Hr(e.y, n.y) ? n.isClose = !0 : this.commands.push({
      type: "line",
      x: e.x,
      y: e.y,
      isClose: !0
    }), e.closeIdx = this.commands.length - 1, this.lastMoveTo = null, this;
  }
  toD(e = {}) {
    var d, u, f;
    const { startIdx: n = 0, endIdx: r = this.commands.length, onlyFilled: s = !1 } = e, o = [];
    let i = !1, a = !1, c = !1;
    const l = (p) => {
      if (a || p === 0) return;
      a = !0;
      const g = this.commands[p - 1];
      o.push("M", ne(g.x), ne(g.y));
    };
    for (let p = n; p < r; p++) {
      const g = this.commands[p];
      switch (g.type) {
        case "move": {
          const y = ((d = g.opts) == null ? void 0 : d.geometry) === !1 ? !1 : ((f = (u = g.opts) == null ? void 0 : u.geometry) == null ? void 0 : f.isFilled) ?? !1;
          s && !y ? i = !0 : (i = !1, a = !0, c = !0, o.push("M", ne(g.x), ne(g.y)));
          break;
        }
        case "line":
          if (i) break;
          l(p), g.isClose && c ? o.push("Z") : o.push("L", ne(g.x), ne(g.y));
          break;
        case "cubic":
          if (i) break;
          l(p), o.push(
            "C",
            ne(g.cp1.x),
            ne(g.cp1.y),
            ne(g.cp2.x),
            ne(g.cp2.y),
            ne(g.x),
            ne(g.y)
          );
          break;
        default:
          Jt(g, "type");
      }
    }
    return o.join(" ");
  }
  toSvg(e) {
    if (e.forceSolid)
      return this.toSolidSvg(e);
    switch (e.style) {
      case "solid":
        return this.toSolidSvg(e);
      case "dashed":
      case "dotted":
        return this.toDashedSvg(e);
      case "draw":
        return this.toDrawSvg(e);
      default:
        Jt(e, "style");
    }
  }
  toGeometry() {
    var r, s, o, i, a, c, l, d;
    const e = [];
    let n = null;
    for (let u = 0; u < this.commands.length; u++) {
      const f = this.commands[u];
      f.type === "move" && (n && ((r = n.opts) == null ? void 0 : r.geometry) !== !1 && e.push(
        new Vj(this, n.startIdx, u, {
          ...(s = n.opts) == null ? void 0 : s.geometry,
          isFilled: ((i = (o = n.opts) == null ? void 0 : o.geometry) == null ? void 0 : i.isFilled) ?? !1,
          isClosed: n.moveCommand.closeIdx !== null
        })
      ), n = { startIdx: u, moveCommand: f, opts: f.opts, isClosed: !1 }), f.isClose && (tt(n, "No current move command"), n.isClosed = !0);
    }
    return n && ((a = n.opts) == null ? void 0 : a.geometry) !== !1 && e.push(
      new Vj(this, n.startIdx, this.commands.length, {
        ...(c = n.opts) == null ? void 0 : c.geometry,
        isFilled: ((d = (l = n.opts) == null ? void 0 : l.geometry) == null ? void 0 : d.isFilled) ?? !1,
        isClosed: n.moveCommand.closeIdx !== null
      })
    ), tt(e.length > 0), e.length === 1 ? e[0] : new ui({ children: e });
  }
  toSolidSvg(e) {
    const { strokeWidth: n, props: r } = e;
    return /* @__PURE__ */ h.jsx("path", { strokeWidth: n, d: this.toD({ onlyFilled: e.onlyFilled }), ...r });
  }
  toDashedSvg(e) {
    var y, m, v, b, x;
    const {
      style: n,
      strokeWidth: r,
      snap: s,
      lengthRatio: o,
      props: { markerStart: i, markerEnd: a, ...c } = {}
    } = e, l = [];
    let d = !1, u = !1, f, p = null;
    const g = () => {
      if (!p) return;
      const { startIdx: w, endIdx: S, isFirst: C, isLast: _, length: E, lineOpts: M, pathIsClosed: N } = p;
      if (p = null, w === S && this.commands[w].type === "move") return;
      const O = (M == null ? void 0 : M.dashStart) ?? e.start, D = (M == null ? void 0 : M.dashEnd) ?? e.end, { strokeDasharray: k, strokeDashoffset: A } = Ane(E, r, {
        style: n,
        snap: s,
        lengthRatio: o,
        start: C ? O ?? (N ? "outset" : "none") : "outset",
        end: _ ? D ?? (N ? "outset" : "none") : "outset"
      }), R = this.toD({ startIdx: w, endIdx: S + 1 });
      l.push(
        /* @__PURE__ */ h.jsx(
          "path",
          {
            d: R,
            strokeDasharray: k,
            strokeDashoffset: A,
            markerStart: C ? i : void 0,
            markerEnd: _ ? a : void 0
          },
          l.length
        )
      );
    };
    for (let w = 0; w < this.commands.length; w++) {
      const S = this.commands[w], C = this.commands[w - 1];
      if (S.type === "move") {
        d = S.closeIdx !== null;
        const N = ((y = S.opts) == null ? void 0 : y.geometry) === !1 ? !1 : ((v = (m = S.opts) == null ? void 0 : m.geometry) == null ? void 0 : v.isFilled) ?? !1;
        e.onlyFilled && !N ? u = !0 : (u = !1, f = S.opts);
        continue;
      }
      if (u) continue;
      const _ = this.calculateSegmentLength(C, S), E = C.type === "move", M = S.isClose || w === this.commands.length - 1 || ((b = this.commands[w + 1]) == null ? void 0 : b.type) === "move";
      p && ((x = S.opts) != null && x.mergeWithPrevious) ? (p.length += _, p.endIdx = w, p.isLast = M) : (g(), p = {
        startIdx: w,
        endIdx: w,
        isFirst: E,
        isLast: M,
        length: _,
        lineOpts: f,
        pathIsClosed: d
      });
    }
    return g(), /* @__PURE__ */ h.jsx("g", { strokeWidth: r, ...c, children: l });
  }
  toDrawSvg(e) {
    return /* @__PURE__ */ h.jsx("path", { strokeWidth: e.strokeWidth, d: this.toDrawD(e), ...e.props });
  }
  toDrawD(e) {
    var f, p, g, y, m, v, b;
    const {
      strokeWidth: n,
      randomSeed: r,
      offset: s = n / 3,
      roundness: o = n * 2,
      passes: i = 2,
      onlyFilled: a = !1
    } = e, c = [], l = this.getCommandInfo(), d = [];
    let u = null;
    for (let x = 0; x < this.commands.length; x++) {
      const w = this.commands[x], S = ((f = w.opts) == null ? void 0 : f.offset) ?? s, C = ((p = w.opts) == null ? void 0 : p.roundness) ?? o;
      w.type === "move" && (u = x);
      const _ = w.isClose ? Io(u) + 1 : !this.commands[x + 1] || this.commands[x + 1].type === "move" ? void 0 : x + 1, E = _ !== void 0 && this.commands[_] && ((g = this.commands[_]) == null ? void 0 : g.type) !== "move" ? l[_] : void 0, M = tV[w.type], N = _ !== void 0 ? tV[this.commands[_].type] : !1, O = l[x], D = O == null ? void 0 : O.tangentEnd, k = E == null ? void 0 : E.tangentStart, A = M && N && D && k && I.Len2(D) > 0.01 && I.Len2(k) > 0.01 ? ql(
        Math.abs(I.AngleBetween(D, k)),
        [Math.PI / 2, Math.PI],
        [C, 0],
        !0
      ) : 0, j = Math.min(
        (O == null ? void 0 : O.length) ?? 1 / 0,
        (E == null ? void 0 : E.length) ?? 1 / 0
      ) - A * 2, $ = wt(S, 0, j / 4), F = Math.min(
        A,
        ((O == null ? void 0 : O.length) ?? 1 / 0) / 4
      ), L = Math.min(
        A,
        ((E == null ? void 0 : E.length) ?? 1 / 0) / 4
      ), z = {
        command: w,
        offsetAmount: $,
        roundnessBefore: F,
        roundnessAfter: L,
        tangentToPrev: (y = l[x]) == null ? void 0 : y.tangentEnd,
        tangentToNext: E == null ? void 0 : E.tangentStart,
        moveDidClose: !1
      };
      if (d.push(z), w.isClose && u !== null) {
        const H = d[u];
        H.moveDidClose = !0, H.roundnessAfter = L;
      } else w.type === "move" && (u = x);
    }
    for (let x = 0; x < i; x++) {
      const w = lg(r + x);
      let S = { x: 0, y: 0 }, C = !1;
      for (const {
        command: _,
        offsetAmount: E,
        roundnessBefore: M,
        roundnessAfter: N,
        tangentToNext: O,
        tangentToPrev: D
      } of d) {
        const k = _.isClose ? S : { x: w() * E, y: w() * E };
        if (_.type === "move") {
          S = k;
          const $ = ((m = _.opts) == null ? void 0 : m.geometry) === !1 ? !1 : ((b = (v = _.opts) == null ? void 0 : v.geometry) == null ? void 0 : b.isFilled) ?? !1;
          a && !$ ? C = !0 : C = !1;
        }
        if (C) continue;
        const A = I.Add(_, k), R = O && N > 0 ? I.Mul(O, -N).add(A) : A, j = D && M > 0 ? I.Mul(D, M).add(A) : A;
        if (R === A || j === A)
          switch (_.type) {
            case "move":
              c.push("M", ne(R.x), ne(R.y));
              break;
            case "line":
              c.push("L", ne(R.x), ne(R.y));
              break;
            case "cubic": {
              const $ = I.Add(_.cp1, k), F = I.Add(_.cp2, k);
              c.push(
                "C",
                ne($.x),
                ne($.y),
                ne(F.x),
                ne(F.y),
                ne(R.x),
                ne(R.y)
              );
              break;
            }
            default:
              Jt(_, "type");
          }
        else
          switch (_.type) {
            case "move":
              c.push("M", ne(R.x), ne(R.y));
              break;
            case "line":
              c.push(
                "L",
                ne(j.x),
                ne(j.y),
                "Q",
                ne(A.x),
                ne(A.y),
                ne(R.x),
                ne(R.y)
              );
              break;
            case "cubic": {
              const $ = I.Add(_.cp1, k), F = I.Add(_.cp2, k);
              c.push(
                "C",
                ne($.x),
                ne($.y),
                ne(F.x),
                ne(F.y),
                ne(A.x),
                ne(A.y)
              );
              break;
            }
            default:
              Jt(_, "type");
          }
      }
    }
    return c.join(" ");
  }
  calculateSegmentLength(e, n) {
    switch (n.type) {
      case "move":
        return 0;
      case "line":
        return I.Dist(e, n);
      case "cubic":
        return zb.length(
          e.x,
          e.y,
          n.cp1.x,
          n.cp1.y,
          n.cp2.x,
          n.cp2.y,
          n.x,
          n.y
        );
      default:
        Jt(n, "type");
    }
  }
  /** @internal */
  getCommands() {
    return this.commands;
  }
  /** @internal */
  getCommandInfo() {
    const e = [];
    for (let n = 1; n < this.commands.length; n++) {
      const r = this.commands[n - 1], s = this.commands[n];
      if (s._info) {
        e[n] = s._info;
        continue;
      }
      if (s.type === "move")
        continue;
      let o, i;
      switch (s.type) {
        case "line":
          o = i = I.Sub(r, s).uni();
          break;
        case "cubic": {
          o = I.Sub(s.cp1, r).uni(), i = I.Sub(s.cp2, s).uni();
          break;
        }
        default:
          Jt(s, "type");
      }
      s._info = {
        tangentStart: o,
        tangentEnd: i,
        length: this.calculateSegmentLength(r, s)
      }, e[n] = s._info;
    }
    return e;
  }
}
const tV = {
  line: !0,
  move: !0,
  cubic: !1
};
class Vj extends nh {
  constructor(n, r, s, o) {
    super(o);
    P(this, "_segments", null);
    this.path = n, this.startIdx = r, this.endIdx = s;
  }
  getSegments() {
    if (this._segments) return this._segments;
    this._segments = [];
    let n = this.path.commands[this.startIdx];
    tt(n.type === "move");
    for (let r = this.startIdx + 1; r < this.endIdx; r++) {
      const s = this.path.commands[r];
      switch (tt(s.type !== "move"), s.type) {
        case "line":
          this._segments.push(new ly({ start: I.From(n), end: I.From(s) }));
          break;
        case "cubic": {
          this._segments.push(
            new D3({
              start: I.From(n),
              cp1: I.From(s.cp1),
              cp2: I.From(s.cp2),
              end: I.From(s),
              resolution: s.resolution
            })
          );
          break;
        }
        default:
          Jt(s, "type");
      }
      n = s;
    }
    return this._segments;
  }
  getVertices(n) {
    const r = this.getSegments().flatMap((s) => s.getVertices(n)).filter((s, o, i) => {
      const a = i[o - 1];
      return a ? !I.Equals(a, s) : !0;
    });
    if (this.isClosed) {
      const s = r[r.length - 1], o = r[0];
      I.Equals(s, o) || r.push(o);
    }
    return r;
  }
  nearestPoint(n, r) {
    let s = null, o = 1 / 0;
    for (const i of this.getSegments()) {
      const a = i.nearestPoint(n), c = I.Dist2(n, a);
      c < o && (o = c, s = a);
    }
    return tt(s, "No nearest point found"), s;
  }
  hitTestLineSegment(n, r, s = 0, o) {
    return super.hitTestLineSegment(n, r, s, o);
  }
  getSvgPathData() {
    return this.path.toD({ startIdx: this.startIdx, endIdx: this.endIdx });
  }
}
/*!
 * Adapted from https://github.com/adobe-webplatform/Snap.svg/tree/master
 * Apache License: https://github.com/adobe-webplatform/Snap.svg/blob/master/LICENSE
 * https://github.com/adobe-webplatform/Snap.svg/blob/c8e483c9694517e24b282f8f59f985629f4994ce/dist/snap.svg.js#L5786
 */
const zb = {
  base3(t, e, n, r, s) {
    const o = -3 * e + 9 * n - 9 * r + 3 * s, i = t * o + 6 * e - 12 * n + 6 * r;
    return t * i - 3 * e + 3 * n;
  },
  /**
   * Calculate the approximate length of a cubic bezier curve from (x1, y1) to (x4, y4) with
   * control points (x2, y2) and (x3, y3).
   */
  length(t, e, n, r, s, o, i, a, c = 1) {
    c = c > 1 ? 1 : c < 0 ? 0 : c;
    const l = c / 2, d = 12;
    let u = 0;
    u = 0;
    for (let f = 0; f < d; f++) {
      const p = l * zb.Tvalues[f] + l, g = zb.base3(p, t, n, s, i), y = zb.base3(p, e, r, o, a), m = g * g + y * y;
      u += zb.Cvalues[f] * Math.sqrt(m);
    }
    return l * u;
  },
  Tvalues: [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ],
  Cvalues: [
    0.2491,
    0.2491,
    0.2335,
    0.2335,
    0.2032,
    0.2032,
    0.1601,
    0.1601,
    0.1069,
    0.1069,
    0.0472,
    0.0472
  ]
};
function Wae() {
  const [t, e] = he(!1);
  return me(() => {
    if (typeof window > "u" || !("matchMedia" in window)) return;
    const n = window.matchMedia("(prefers-reduced-motion: reduce)"), r = () => {
      e(n.matches);
    };
    return r(), n.addEventListener("change", r), () => n.removeEventListener("change", r);
  }, []), t;
}
const Wj = zn(null);
function mGe({ children: t }) {
  const e = K0("a11y", { msg: "", priority: "assertive" }), n = tn(Wj), r = Ke(
    () => ({
      currentMsg: e,
      announce(s) {
        s && e.set(s);
      }
    }),
    [e]
  );
  return n ? /* @__PURE__ */ h.jsx(h.Fragment, { children: t }) : /* @__PURE__ */ h.jsx(Wj.Provider, { value: r, children: t });
}
function hk() {
  const t = tn(Wj);
  if (!t)
    throw new Error("useA11y must be used within a A11yContext.Provider");
  return t;
}
const Kae = zn(null);
function Gae({
  assetUrls: t,
  children: e
}) {
  return me(() => {
    for (const n of Object.values(t.icons)) {
      if (!n) continue;
      const r = rw();
      r.crossOrigin = "anonymous", r.src = n, r.decode();
    }
    for (const n of Object.values(t.embedIcons)) {
      if (!n) continue;
      const r = rw();
      r.crossOrigin = "anonymous", r.src = n, r.decode();
    }
  }, [t]), /* @__PURE__ */ h.jsx(Kae.Provider, { value: t, children: e });
}
function n5() {
  const t = tn(Kae);
  if (!t)
    throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  return t;
}
const Kj = {
  "action.convert-to-bookmark": "Convert to Bookmark",
  "action.convert-to-embed": "Convert to Embed",
  "action.open-embed-link": "Open link",
  "action.align-bottom": "Align bottom",
  "action.align-center-horizontal": "Align horizontally",
  "action.align-center-vertical": "Align vertically",
  "action.align-center-horizontal.short": "Align H",
  "action.align-center-vertical.short": "Align V",
  "action.align-left": "Align left",
  "action.align-right": "Align right",
  "action.align-top": "Align top",
  "action.back-to-content": "Back to content",
  "action.bring-forward": "Bring forward",
  "action.bring-to-front": "Bring to front",
  "action.copy-as-png.short": "PNG",
  "action.copy-as-png": "Copy as PNG",
  "action.copy-as-svg.short": "SVG",
  "action.copy-as-svg": "Copy as SVG",
  "action.copy": "Copy",
  "action.cut": "Cut",
  "action.delete": "Delete",
  "action.unlock-all": "Unlock all",
  "action.distribute-horizontal": "Distribute horizontally",
  "action.distribute-vertical": "Distribute vertically",
  "action.distribute-horizontal.short": "Distribute H",
  "action.distribute-vertical.short": "Distribute V",
  "action.download-original": "Download original",
  "action.duplicate": "Duplicate",
  "action.edit-link": "Edit link",
  "action.exit-pen-mode": "Exit pen mode",
  "action.export-as-png.short": "PNG",
  "action.export-as-png": "Export as PNG",
  "action.export-as-svg.short": "SVG",
  "action.export-as-svg": "Export as SVG",
  "action.export-all-as-png.short": "PNG",
  "action.export-all-as-png": "Export as PNG",
  "action.export-all-as-svg.short": "SVG",
  "action.export-all-as-svg": "Export as SVG",
  "action.fit-frame-to-content": "Fit to content",
  "action.flip-horizontal": "Flip horizontally",
  "action.flip-vertical": "Flip vertically",
  "action.flip-horizontal.short": "Flip H",
  "action.flip-vertical.short": "Flip V",
  "action.fork-project": "Fork this project",
  "action.fork-project-on-tldraw": "Fork project on tldraw",
  "action.group": "Group",
  "action.insert-embed": "Insert embed",
  "action.insert-media": "Upload media",
  "action.leave-shared-project": "Leave shared project",
  "action.new-project": "New project",
  "action.new-shared-project": "New shared project",
  "action.open-cursor-chat": "Cursor chat",
  "action.open-kbd-shortcuts": "Open keyboard shortcuts",
  "action.open-file": "Open file",
  "action.pack": "Pack",
  "action.paste": "Paste",
  "action.paste-error-title": "Pasting failed",
  "action.paste-error-description": "Could not paste due to missing clipboard permissions. Please enable the permissions and try again.",
  "action.print": "Print",
  "action.redo": "Redo",
  "action.remove-frame": "Remove frame",
  "action.rename": "Rename",
  "action.rotate-ccw": "Rotate counterclockwise",
  "action.rotate-cw": "Rotate clockwise",
  "action.save-copy": "Save a copy",
  "action.select-all": "Select all",
  "action.select-none": "Select none",
  "action.send-backward": "Send backward",
  "action.send-to-back": "Send to back",
  "action.share-project": "Share this project",
  "action.stack-horizontal": "Stack horizontally",
  "action.stack-vertical": "Stack vertically",
  "action.stack-horizontal.short": "Stack H",
  "action.stack-vertical.short": "Stack V",
  "action.stop-following": "Stop following",
  "action.stretch-horizontal": "Stretch horizontally",
  "action.stretch-vertical": "Stretch vertically",
  "action.stretch-horizontal.short": "Stretch H",
  "action.stretch-vertical.short": "Stretch V",
  "action.toggle-auto-size": "Toggle auto size",
  "action.toggle-dark-mode.menu": "Dark mode",
  "action.toggle-dark-mode": "Toggle dark mode",
  "action.toggle-paste-at-cursor.menu": "Paste at cursor",
  "action.toggle-paste-at-cursor": "Toggle paste at cursor",
  "action.toggle-wrap-mode.menu": "Select on wrap",
  "action.toggle-wrap-mode": "Toggle Select on wrap",
  "action.toggle-reduce-motion.menu": "Reduce motion",
  "action.toggle-reduce-motion": "Toggle reduce motion",
  "action.toggle-keyboard-shortcuts.menu": "Keyboard shortcuts",
  "action.toggle-keyboard-shortcuts": "Toggle keyboard shortcuts",
  "action.toggle-edge-scrolling.menu": "Edge scrolling",
  "action.toggle-edge-scrolling": "Toggle edge scrolling",
  "action.toggle-debug-mode.menu": "Debug mode",
  "action.toggle-debug-mode": "Toggle debug mode",
  "action.toggle-focus-mode.menu": "Focus mode",
  "action.toggle-focus-mode": "Toggle focus mode",
  "action.toggle-dynamic-size-mode.menu": "Dynamic size",
  "action.toggle-dynamic-size-mode": "Toggle dynamic size",
  "action.toggle-grid.menu": "Show grid",
  "action.toggle-grid": "Toggle grid",
  "action.toggle-lock": "Toggle locked",
  "action.flatten-to-image": "Flatten",
  "action.toggle-snap-mode.menu": "Always snap",
  "action.toggle-snap-mode": "Toggle always snap",
  "action.toggle-tool-lock.menu": "Tool lock",
  "action.toggle-tool-lock": "Toggle tool lock",
  "action.toggle-transparent.context-menu": "Transparent",
  "action.toggle-transparent.menu": "Transparent",
  "action.toggle-transparent": "Toggle transparent background",
  "action.undo": "Undo",
  "action.ungroup": "Ungroup",
  "action.zoom-in": "Zoom in",
  "action.zoom-out": "Zoom out",
  "action.zoom-to-100": "Zoom to 100%",
  "action.zoom-to-fit": "Zoom to fit",
  "action.zoom-to-selection": "Zoom to selection",
  "assets.files.size-too-big": "File size is too big",
  "assets.files.type-not-allowed": "File type is not allowed",
  "assets.files.upload-failed": "Upload failed",
  "assets.files.amount-too-many": "Too many files",
  "assets.url.failed": "Couldnt load URL preview",
  "theme.dark": "Dark",
  "theme.light": "Light",
  "theme.system": "System",
  "color-style.white": "White",
  "color-style.black": "Black",
  "color-style.blue": "Blue",
  "color-style.green": "Green",
  "color-style.grey": "Grey",
  "color-style.light-blue": "Light blue",
  "color-style.light-green": "Light green",
  "color-style.light-red": "Light red",
  "color-style.light-violet": "Light violet",
  "color-style.orange": "Orange",
  "color-style.red": "Red",
  "color-style.violet": "Violet",
  "color-style.yellow": "Yellow",
  "fill-style.none": "None",
  "document.default-name": "Untitled",
  "fill-style.semi": "Semi",
  "fill-style.solid": "Solid",
  "fill-style.pattern": "Pattern",
  "fill-style.fill": "Fill",
  "dash-style.dashed": "Dashed",
  "dash-style.dotted": "Dotted",
  "dash-style.draw": "Draw",
  "dash-style.solid": "Solid",
  "size-style.s": "Small",
  "size-style.m": "Medium",
  "size-style.l": "Large",
  "size-style.xl": "Extra large",
  "opacity-style.0.1": "10%",
  "opacity-style.0.25": "25%",
  "opacity-style.0.5": "50%",
  "opacity-style.0.75": "75%",
  "opacity-style.1": "100%",
  "font-style.draw": "Draw",
  "font-style.sans": "Sans",
  "font-style.serif": "Serif",
  "font-style.mono": "Mono",
  "align-style.start": "Start",
  "align-style.middle": "Middle",
  "align-style.end": "End",
  "align-style.justify": "Justify",
  "verticalAlign-style.start": "Top",
  "verticalAlign-style.middle": "Middle",
  "verticalAlign-style.end": "Bottom",
  "geo-style.arrow-down": "Arrow down",
  "geo-style.arrow-left": "Arrow left",
  "geo-style.arrow-right": "Arrow right",
  "geo-style.arrow-up": "Arrow up",
  "geo-style.cloud": "Cloud",
  "geo-style.diamond": "Diamond",
  "geo-style.ellipse": "Ellipse",
  "geo-style.heart": "Heart",
  "geo-style.hexagon": "Hexagon",
  "geo-style.octagon": "Octagon",
  "geo-style.oval": "Oval",
  "geo-style.pentagon": "Pentagon",
  "geo-style.rectangle": "Rectangle",
  "geo-style.rhombus": "Rhombus",
  "geo-style.star": "Star",
  "geo-style.trapezoid": "Trapezoid",
  "geo-style.triangle": "Triangle",
  "geo-style.x-box": "X box",
  "geo-style.check-box": "Check box",
  "arrowheadStart-style.none": "None",
  "arrowheadStart-style.arrow": "Arrow",
  "arrowheadStart-style.bar": "Bar",
  "arrowheadStart-style.diamond": "Diamond",
  "arrowheadStart-style.dot": "Dot",
  "arrowheadStart-style.inverted": "Inverted",
  "arrowheadStart-style.pipe": "Pipe",
  "arrowheadStart-style.square": "Square",
  "arrowheadStart-style.triangle": "Triangle",
  "arrowheadEnd-style.none": "None",
  "arrowheadEnd-style.arrow": "Arrow",
  "arrowheadEnd-style.bar": "Bar",
  "arrowheadEnd-style.diamond": "Diamond",
  "arrowheadEnd-style.dot": "Dot",
  "arrowheadEnd-style.inverted": "Inverted",
  "arrowheadEnd-style.pipe": "Pipe",
  "arrowheadEnd-style.square": "Square",
  "arrowheadEnd-style.triangle": "Triangle",
  "spline-style.line": "Line",
  "spline-style.cubic": "Cubic",
  "arrow-kind-style.arc": "Arc",
  "arrow-kind-style.elbow": "Elbow",
  "tool.select": "Select",
  "tool.hand": "Hand",
  "tool.draw": "Draw",
  "tool.eraser": "Eraser",
  "tool.arrow-down": "Arrow down",
  "tool.arrow-left": "Arrow left",
  "tool.arrow-right": "Arrow right",
  "tool.arrow-up": "Arrow up",
  "tool.arrow": "Arrow",
  "tool.cloud": "Cloud",
  "tool.diamond": "Diamond",
  "tool.ellipse": "Ellipse",
  "tool.heart": "Heart",
  "tool.hexagon": "Hexagon",
  "tool.highlight": "Highlight",
  "tool.line": "Line",
  "tool.octagon": "Octagon",
  "tool.oval": "Oval",
  "tool.pentagon": "Pentagon",
  "tool.rectangle": "Rectangle",
  "tool.rhombus": "Rhombus",
  "tool.star": "Star",
  "tool.trapezoid": "Trapezoid",
  "tool.triangle": "Triangle",
  "tool.x-box": "X box",
  "tool.check-box": "Check box",
  "tool.media": "Media",
  "tool.frame": "Frame",
  "tool.note": "Note",
  "tool.laser": "Laser",
  "tool.embed": "Embed",
  "tool.text": "Text",
  "tool.pointer-down": "Pointer down",
  "tool.image-zoom": "Zoom",
  "tool.replace-media": "Replace media",
  "tool.flip-horz": "Flip horizontally",
  "tool.flip-vert": "Flip vertically",
  "tool.rotate-cw": "Rotate",
  "tool.aspect-ratio": "Aspect ratio",
  "tool.aspect-ratio.original": "Original",
  "tool.aspect-ratio.square": "Square (1:1)",
  "tool.aspect-ratio.circle": "Circle (1:1)",
  "tool.aspect-ratio.landscape": "Landscape (4:3)",
  "tool.aspect-ratio.portrait": "Portrait (3:4)",
  "tool.aspect-ratio.wide": "Wide (16:9)",
  "tool.image-toolbar-title": "Image tools",
  "tool.image-crop": "Crop image",
  "tool.media-alt-text": "Alternative text",
  "tool.media-alt-text-desc": "Give a description",
  "tool.media-alt-text-confirm": "Confirm",
  "tool.rich-text-bold": "Bold",
  "tool.rich-text-italic": "Italic",
  "tool.rich-text-code": "Code",
  "tool.rich-text-highlight": "Highlight",
  "tool.rich-text-strikethrough": "Strikethrough",
  "tool.rich-text-link": "Link",
  "tool.rich-text-link-visit": "Visit link",
  "tool.rich-text-link-remove": "Remove link",
  "tool.rich-text-header": "Header",
  "tool.rich-text-bulletList": "Bulleted list",
  "tool.rich-text-toolbar-title": "Text formatting",
  "tool.rich-text-orderedList": "Ordered list",
  "tool.bookmark": "Bookmark",
  "a11y.status": "Status",
  "a11y.skip-to-main-content": "Move focus to canvas",
  "a11y.shape-index": "{num} of {total}",
  "a11y.shape-image": "Image",
  "a11y.shape-video": "Video",
  "a11y.multiple-shapes": "{num} shapes selected",
  "a11y.select-shape": "Select next shape",
  "a11y.select-shape-direction": "Select shape in direction",
  "a11y.enter-leave-container": "Enter/leave container",
  "a11y.repeat-shape": "Repeat shape",
  "a11y.move-shape": "Move shape",
  "a11y.move-shape-faster": "Move shape faster",
  "a11y.enlarge-shape": "Enlarge shape",
  "a11y.shrink-shape": "Shrink shape",
  "a11y.pan-camera": "Pan camera",
  "a11y.adjust-shape-styles": "Adjust shape styles",
  "a11y.open-context-menu": "Open context menu",
  "a11y.open-keyboard-shortcuts": "Open keyboard shortcuts",
  "menu.title": "Menu",
  "menu.theme": "Theme",
  "menu.copy-as": "Copy as",
  "menu.edit": "Edit",
  "menu.export-as": "Export as",
  "menu.file": "File",
  "menu.language": "Language",
  "menu.preferences": "Preferences",
  "menu.view": "View",
  "context-menu.title": "Context menu",
  "context-menu.edit": "Edit",
  "context-menu.arrange": "Arrange",
  "context-menu.copy-as": "Copy as",
  "context-menu.export-as": "Export as",
  "context-menu.export-all-as": "Export",
  "context-menu.move-to-page": "Move to page",
  "context-menu.reorder": "Reorder",
  "page-menu.title": "Pages",
  "page-menu.create-new-page": "Create new page",
  "page-menu.max-page-count-reached": "Max pages reached",
  "page-menu.new-page-initial-name": "Page 1",
  "page-menu.edit-start": "Edit",
  "page-menu.edit-done": "Done",
  "page-menu.go-to-page": "Go to page",
  "page-menu.submenu.rename": "Rename",
  "page-menu.submenu.duplicate-page": "Duplicate",
  "page-menu.submenu.title": "Menu",
  "page-menu.submenu.move-down": "Move down",
  "page-menu.submenu.move-up": "Move up",
  "page-menu.submenu.delete": "Delete",
  "share-menu.title": "Share",
  "share-menu.save-note": "Download this project to your computer as a .tldr file.",
  "share-menu.fork-note": "Create a new shared project based on this snapshot.",
  "share-menu.share-project": "Share this project",
  "share-menu.copy-link": "Copy editor link",
  "share-menu.create-snapshot-link": "Copy snapshot link",
  "share-menu.snapshot-link-note": "Capture and share this project as a read-only snapshot link.",
  "share-menu.copy-readonly-link": "Copy viewer link",
  "share-menu.offline-note": "Create a new shared project based on your current project.",
  "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
  "share-menu.copy-readonly-link-note": "Anyone with the link will be able to access this project.",
  "share-menu.project-too-large": "Sorry, this project cant be shared because its too large. Were working on it!",
  "share-menu.upload-failed": "Sorry, we couldnt upload your project at the moment. Please try again or let us know if the problem persists.",
  "share-menu.creating-project": "Creating the new project",
  "share-menu.copied": "Copied link",
  "document-name-menu.copy-link": "Copy link",
  "status.offline": "Offline",
  "people-menu.title": "People",
  "people-menu.change-name": "Change name",
  "people-menu.avatar-color": "Avatar color",
  "people-menu.change-color": "Change color",
  "people-menu.follow": "Following",
  "people-menu.following": "Following",
  "people-menu.leading": "Following You",
  "people-menu.user": "(You)",
  "people-menu.invite": "Invite others",
  "people-menu.anonymous-user": "New user",
  "help-menu.import-tldr-file": "Import file",
  "help-menu.title": "Help and resources",
  "help-menu.about": "About tldraw",
  "help-menu.discord": "Discord",
  "help-menu.github": "GitHub",
  "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
  "help-menu.twitter": "Twitter",
  "help-menu.terms": "Terms of service",
  "help-menu.privacy": "Privacy policy",
  "actions-menu.title": "Actions",
  "edit-link-dialog.title": "Edit link",
  "edit-link-dialog.invalid-url": "A link must be a valid URL.",
  "edit-link-dialog.detail": "Links will open in a new tab.",
  "edit-link-dialog.url": "URL",
  "edit-link-dialog.clear": "Clear",
  "edit-link-dialog.save": "Continue",
  "edit-link-dialog.cancel": "Cancel",
  "edit-link-dialog.external-link": "External link",
  "embed-dialog.title": "Insert embed",
  "embed-dialog.back": "Back",
  "embed-dialog.create": "Create",
  "embed-dialog.cancel": "Cancel",
  "embed-dialog.url": "URL",
  "embed-dialog.instruction": "Paste in the sites URL to create the embed.",
  "embed-dialog.invalid-url": "We could not create an embed from that URL.",
  "shortcuts-dialog.title": "Keyboard shortcuts",
  "shortcuts-dialog.edit": "Edit",
  "shortcuts-dialog.file": "File",
  "shortcuts-dialog.preferences": "Preferences",
  "shortcuts-dialog.tools": "Tools",
  "shortcuts-dialog.transform": "Transform",
  "shortcuts-dialog.view": "View",
  "shortcuts-dialog.collaboration": "Collaboration",
  "shortcuts-dialog.a11y": "Accessibility",
  "shortcuts-dialog.text-formatting": "Text formatting",
  "style-panel.title": "Styles",
  "style-panel.align": "Align",
  "style-panel.label-align": "Label align",
  "style-panel.vertical-align": "Vertical align",
  "style-panel.position": "Position",
  "style-panel.arrowheads": "Arrows",
  "style-panel.arrowhead-start": "Start",
  "style-panel.arrowhead-end": "End",
  "style-panel.arrow-kind": "Line",
  "style-panel.color": "Color",
  "style-panel.dash": "Dash",
  "style-panel.fill": "Fill",
  "style-panel.font": "Font",
  "style-panel.geo": "Shape",
  "style-panel.mixed": "Mixed",
  "style-panel.opacity": "Opacity",
  "style-panel.size": "Size",
  "style-panel.spline": "Spline",
  "tool-panel.title": "Tools",
  "tool-panel.more": "More",
  "navigation-zone.title": "Navigation",
  "navigation-zone.minimap": "Minimap",
  "navigation-zone.toggle-minimap": "Toggle minimap",
  "navigation-zone.zoom": "Zoom",
  "focus-mode.toggle-focus-mode": "Toggle focus mode",
  "toast.close": "Close",
  "toast.success": "Success",
  "toast.error": "Error",
  "toast.info": "Info",
  "toast.warning": "Warning",
  "file-system.file-open-error.title": "Could not open file",
  "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesnt look like a tldraw file.",
  "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
  "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
  "file-system.confirm-open.title": "Overwrite current project?",
  "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-open.cancel": "Cancel",
  "file-system.confirm-open.open": "Open file",
  "file-system.confirm-open.dont-show-again": "Dont ask again",
  "file-system.confirm-clear.title": "Clear current project?",
  "file-system.confirm-clear.description": "Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-clear.cancel": "Cancel",
  "file-system.confirm-clear.continue": "Continue",
  "file-system.confirm-clear.dont-show-again": "Dont ask again",
  "file-system.shared-document-file-open-error.title": "Could not open file",
  "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
  "sharing.confirm-leave.title": "Leave current project?",
  "sharing.confirm-leave.description": "Are you sure you want to leave this shared project? You can return to it by navigating to its URL.",
  "sharing.confirm-leave.cancel": "Cancel",
  "sharing.confirm-leave.leave": "Leave",
  "sharing.confirm-leave.dont-show-again": "Dont ask again",
  "toast.error.export-fail.title": "Failed export",
  "toast.error.export-fail.desc": "Failed to export image",
  "toast.error.copy-fail.title": "Failed copy",
  "toast.error.copy-fail.desc": "Failed to copy image",
  "context.pages.new-page": "New page",
  "vscode.file-open.desc": "Weve updated this document to work with the current version of tldraw. If youd like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
  "vscode.file-open.open": "Continue",
  "vscode.file-open.backup": "Backup",
  "vscode.file-open.backup-saved": "Backup saved",
  "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
  "vscode.file-open.dont-show-again": "Dont ask again",
  "cursor-chat.type-to-chat": "Type to chat",
  "app.loading": "Loading tldraw",
  "handle.resize-top": "Resize top",
  "handle.resize-bottom": "Resize bottom",
  "handle.resize-left": "Resize left",
  "handle.resize-right": "Resize right",
  "handle.resize-top-left": "Resize top left",
  "handle.resize-top-right": "Resize top right",
  "handle.resize-bottom-left": "Resize bottom left",
  "handle.resize-bottom-right": "Resize bottom right",
  "handle.rotate.top_left_rotate": "Rotate top left",
  "handle.rotate.top_right_rotate": "Rotate top right",
  "handle.rotate.bottom_left_rotate": "Rotate bottom left",
  "handle.rotate.bottom_right_rotate": "Rotate bottom right",
  "handle.rotate.mobile_rotate": "Rotate",
  "handle.crop.top": "Crop top",
  "handle.crop.bottom": "Crop bottom",
  "handle.crop.left": "Crop left",
  "handle.crop.right": "Crop right",
  "handle.crop.top-left": "Crop top left",
  "handle.crop.top-right": "Crop top right",
  "handle.crop.bottom-left": "Crop bottom left",
  "handle.crop.bottom-right": "Crop bottom right",
  "ui.close": "Close",
  "ui.checked": "Checked",
  "ui.unchecked": "Unchecked"
}, yGe = /* @__PURE__ */ new Set(["ar", "fa", "he", "ur", "ku"]), zg = {
  locale: "en",
  label: "English",
  messages: Kj,
  dir: "ltr"
};
async function vGe(t, e) {
  if (!(await qc(e.translations.en)).ok)
    return console.warn("No main translations found."), zg;
  if (t === "en")
    return zg;
  const r = lw.find((a) => a.locale === t);
  if (!r)
    return console.warn(`No translation found for locale ${t}`), zg;
  const o = await (await qc(e.translations[r.locale])).json();
  if (!o)
    return console.warn(`No messages found for locale ${t}`), zg;
  const i = [];
  for (const a in zg.messages)
    o[a] || i.push(a);
  return i.length > 0 && process.env.NODE_ENV === "development" && console.warn(`Language ${t}: missing messages for keys:
${i.join(`
`)}`), {
    locale: t,
    label: r.label,
    dir: yGe.has(r.locale) ? "rtl" : "ltr",
    messages: { ...zg.messages, ...o }
  };
}
const Yae = T.createContext(null);
function qae() {
  const t = T.useContext(Yae);
  if (!t)
    throw new Error("useCurrentTranslation must be used inside of <TldrawUiContextProvider />");
  return t;
}
function Xae({
  overrides: t,
  locale: e,
  children: n
}) {
  const r = n5(), [s, o] = T.useState(() => t && t.en ? {
    locale: "en",
    label: "English",
    dir: "ltr",
    messages: { ...Kj, ...t.en }
  } : {
    locale: "en",
    label: "English",
    dir: "ltr",
    messages: Kj
  });
  return T.useEffect(() => {
    let i = !1;
    async function a() {
      const c = await vGe(e, r);
      c && !i && (t && t[e] ? o({
        ...c,
        messages: { ...c.messages, ...t[e] }
      }) : o(c));
    }
    return a(), () => {
      i = !0;
    };
  }, [r, e, t]), /* @__PURE__ */ h.jsx(Yae.Provider, { value: s, children: n });
}
function Ze() {
  const t = qae();
  return T.useCallback(
    function(n) {
      return t.messages[n] ?? n;
    },
    [t]
  );
}
const bGe = {
  normal: "tlui-button__normal",
  primary: "tlui-button__primary",
  danger: "tlui-button__danger",
  low: "tlui-button__low",
  icon: "tlui-button__icon",
  tool: "tlui-button__tool",
  menu: "tlui-button__menu",
  help: "tlui-button__help"
}, yt = T.forwardRef(
  function({ children: e, type: n, isActive: r, ...s }, o) {
    return /* @__PURE__ */ h.jsx(
      "button",
      {
        ref: o,
        type: "button",
        draggable: !1,
        "data-isactive": r,
        ...s,
        className: Je(
          "tlui-button",
          bGe[n],
          s.className
        ),
        children: e
      }
    );
  }
);
function xGe() {
  const t = ie(), e = Ze(), n = fe(null), r = re(
    (s) => {
      var i;
      cr(s), (i = n.current) == null || i.blur();
      const o = t.getCurrentPageShapesInReadingOrder();
      o.length && (t.setSelectedShapes([o[0].id]), t.zoomToSelectionIfOffscreen(256, {
        animation: {
          duration: t.options.animationMediumMs
        },
        inset: 0
      }), t.timers.setTimeout(() => t.getContainer().focus(), 100));
    },
    [t]
  );
  return /* @__PURE__ */ h.jsx(
    yt,
    {
      ref: n,
      type: "low",
      tabIndex: 0,
      className: "tl-skip-to-main-content",
      onClick: r,
      children: e("a11y.skip-to-main-content")
    }
  );
}
const wGe = it(function() {
  const e = hk(), n = Ze(), r = le("a11y-msg", () => e.currentMsg.get(), []);
  return CGe(r.msg), SGe(), r.msg && /* @__PURE__ */ h.jsx(
    "div",
    {
      "aria-label": n("a11y.status"),
      "aria-live": r.priority || "assertive",
      role: "status",
      "aria-hidden": "false",
      style: {
        position: "absolute",
        top: "-10000px",
        left: "-10000px"
      },
      children: r.msg
    }
  );
});
function Zae(t) {
  const { editor: e, selectedShapeIds: n, msg: r } = t;
  let s = "";
  const o = n.length;
  if (o > 1)
    s = r("a11y.multiple-shapes").replace("{num}", o.toString());
  else if (o === 1) {
    const i = n[0], a = e.getShape(i);
    if (!a) return "";
    const c = e.getShapeUtil(a.type), l = ["image", "video"].includes(a.type);
    let d = "";
    a.type === "geo" ? d = r(`geo-style.${a.props.geo}`) : l ? d = r(`a11y.shape-${a.type}`) : d = r(`tool.${a.type}`);
    const u = e.getCurrentPageShapesInReadingOrder(), f = (u.findIndex((m) => m.id === i) + 1).toString(), p = u.length.toString(), g = r("a11y.shape-index").replace("{num}", f).replace("{total}", p), y = c.getAriaDescriptor(a) || c.getText(a) || "";
    s = (y ? `${y}, ` : "") + `${d}. ${g}`;
  }
  return s;
}
const SGe = () => {
  const t = uo(), e = hk(), n = Ze(), r = fe([]);
  UF(
    "announce selection",
    () => {
      if (!t) return;
      if (t.isIn("select.idle")) {
        const o = t.getSelectedShapeIds();
        o !== r.current && (r.current = o, Nb(() => {
          const i = Zae({
            editor: t,
            selectedShapeIds: o,
            msg: n
          });
          i && e.announce({ msg: i });
        }));
      }
    },
    [t, e, n]
  );
}, CGe = (t) => {
  const e = Gr();
  me(() => {
    if (ir.a11y.get()) {
      const n = (s) => {
        console.debug(
          `%ca11y%c: ${s}`,
          "color: white; background: #40C057; padding: 2px;border-radius: 3px;",
          "font-weight: normal"
        );
      }, r = (s) => {
        const o = document.activeElement;
        if (s.key === "Tab" && o && o !== document.body && !o.classList.contains("tl-container")) {
          const i = o.getAttribute("aria-label") || o.getAttribute("title") || o.textContent;
          i && n(i);
        }
      };
      return t && n(t), document.addEventListener("keyup", r), () => document.removeEventListener("keyup", r);
    }
  }, [e, t]);
}, Qae = () => {
}, Jae = T.createContext(null);
function _Ge({ onEvent: t, children: e }) {
  return /* @__PURE__ */ h.jsx(Jae.Provider, { value: t ?? Qae, children: e });
}
function xr() {
  return T.useContext(Jae) ?? Qae;
}
var EGe = T.createContext(void 0);
function vg(t) {
  const e = T.useContext(EGe);
  return t || e || "ltr";
}
var z1 = { exports: {} }, DO = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nV;
function TGe() {
  if (nV) return DO;
  nV = 1;
  var t = B;
  function e(u, f) {
    return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, s = t.useEffect, o = t.useLayoutEffect, i = t.useDebugValue;
  function a(u, f) {
    var p = f(), g = r({ inst: { value: p, getSnapshot: f } }), y = g[0].inst, m = g[1];
    return o(
      function() {
        y.value = p, y.getSnapshot = f, c(y) && m({ inst: y });
      },
      [u, p, f]
    ), s(
      function() {
        return c(y) && m({ inst: y }), u(function() {
          c(y) && m({ inst: y });
        });
      },
      [u]
    ), i(p), p;
  }
  function c(u) {
    var f = u.getSnapshot;
    u = u.value;
    try {
      var p = f();
      return !n(u, p);
    } catch {
      return !0;
    }
  }
  function l(u, f) {
    return f();
  }
  var d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : a;
  return DO.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : d, DO;
}
var NO = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rV;
function PGe() {
  return rV || (rV = 1, process.env.NODE_ENV !== "production" && function() {
    function t(p, g) {
      return p === g && (p !== 0 || 1 / p === 1 / g) || p !== p && g !== g;
    }
    function e(p, g) {
      d || s.startTransition === void 0 || (d = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var y = g();
      if (!u) {
        var m = g();
        o(y, m) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), u = !0);
      }
      m = i({
        inst: { value: y, getSnapshot: g }
      });
      var v = m[0].inst, b = m[1];
      return c(
        function() {
          v.value = y, v.getSnapshot = g, n(v) && b({ inst: v });
        },
        [p, y, g]
      ), a(
        function() {
          return n(v) && b({ inst: v }), p(function() {
            n(v) && b({ inst: v });
          });
        },
        [p]
      ), l(y), y;
    }
    function n(p) {
      var g = p.getSnapshot;
      p = p.value;
      try {
        var y = g();
        return !o(p, y);
      } catch {
        return !0;
      }
    }
    function r(p, g) {
      return g();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var s = B, o = typeof Object.is == "function" ? Object.is : t, i = s.useState, a = s.useEffect, c = s.useLayoutEffect, l = s.useDebugValue, d = !1, u = !1, f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : e;
    NO.useSyncExternalStore = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), NO;
}
var sV;
function r5() {
  return sV || (sV = 1, process.env.NODE_ENV === "production" ? z1.exports = TGe() : z1.exports = PGe()), z1.exports;
}
var IGe = r5();
function pk(t) {
  const e = T.useRef({ value: t, previous: t });
  return T.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [t]);
}
var gk = "Checkbox", [kGe, Y3t] = bs(gk), [AGe, s5] = kGe(gk);
function MGe(t) {
  const {
    __scopeCheckbox: e,
    checked: n,
    children: r,
    defaultChecked: s,
    disabled: o,
    form: i,
    name: a,
    onCheckedChange: c,
    required: l,
    value: d = "on",
    // @ts-expect-error
    internal_do_not_use_render: u
  } = t, [f, p] = io({
    prop: n,
    defaultProp: s ?? !1,
    onChange: c,
    caller: gk
  }), [g, y] = T.useState(null), [m, v] = T.useState(null), b = T.useRef(!1), x = g ? !!i || !!g.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    !0
  ), w = {
    checked: f,
    disabled: o,
    setChecked: p,
    control: g,
    setControl: y,
    name: a,
    form: i,
    value: d,
    hasConsumerStoppedPropagationRef: b,
    required: l,
    defaultChecked: _f(s) ? !1 : s,
    isFormControl: x,
    bubbleInput: m,
    setBubbleInput: v
  };
  return /* @__PURE__ */ h.jsx(
    AGe,
    {
      scope: e,
      ...w,
      children: OGe(u) ? u(w) : r
    }
  );
}
var ece = "CheckboxTrigger", tce = T.forwardRef(
  ({ __scopeCheckbox: t, onKeyDown: e, onClick: n, ...r }, s) => {
    const {
      control: o,
      value: i,
      disabled: a,
      checked: c,
      required: l,
      setControl: d,
      setChecked: u,
      hasConsumerStoppedPropagationRef: f,
      isFormControl: p,
      bubbleInput: g
    } = s5(ece, t), y = vt(s, d), m = T.useRef(c);
    return T.useEffect(() => {
      const v = o == null ? void 0 : o.form;
      if (v) {
        const b = () => u(m.current);
        return v.addEventListener("reset", b), () => v.removeEventListener("reset", b);
      }
    }, [o, u]), /* @__PURE__ */ h.jsx(
      Re.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": _f(c) ? "mixed" : c,
        "aria-required": l,
        "data-state": ice(c),
        "data-disabled": a ? "" : void 0,
        disabled: a,
        value: i,
        ...r,
        ref: y,
        onKeyDown: Te(e, (v) => {
          v.key === "Enter" && v.preventDefault();
        }),
        onClick: Te(n, (v) => {
          u((b) => _f(b) ? !0 : !b), g && p && (f.current = v.isPropagationStopped(), f.current || v.stopPropagation());
        })
      }
    );
  }
);
tce.displayName = ece;
var o5 = T.forwardRef(
  (t, e) => {
    const {
      __scopeCheckbox: n,
      name: r,
      checked: s,
      defaultChecked: o,
      required: i,
      disabled: a,
      value: c,
      onCheckedChange: l,
      form: d,
      ...u
    } = t;
    return /* @__PURE__ */ h.jsx(
      MGe,
      {
        __scopeCheckbox: n,
        checked: s,
        defaultChecked: o,
        disabled: a,
        required: i,
        onCheckedChange: l,
        name: r,
        form: d,
        value: c,
        internal_do_not_use_render: ({ isFormControl: f }) => /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
          /* @__PURE__ */ h.jsx(
            tce,
            {
              ...u,
              ref: e,
              __scopeCheckbox: n
            }
          ),
          f && /* @__PURE__ */ h.jsx(
            oce,
            {
              __scopeCheckbox: n
            }
          )
        ] })
      }
    );
  }
);
o5.displayName = gk;
var nce = "CheckboxIndicator", rce = T.forwardRef(
  (t, e) => {
    const { __scopeCheckbox: n, forceMount: r, ...s } = t, o = s5(nce, n);
    return /* @__PURE__ */ h.jsx(
      Fs,
      {
        present: r || _f(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ h.jsx(
          Re.span,
          {
            "data-state": ice(o.checked),
            "data-disabled": o.disabled ? "" : void 0,
            ...s,
            ref: e,
            style: { pointerEvents: "none", ...t.style }
          }
        )
      }
    );
  }
);
rce.displayName = nce;
var sce = "CheckboxBubbleInput", oce = T.forwardRef(
  ({ __scopeCheckbox: t, ...e }, n) => {
    const {
      control: r,
      hasConsumerStoppedPropagationRef: s,
      checked: o,
      defaultChecked: i,
      required: a,
      disabled: c,
      name: l,
      value: d,
      form: u,
      bubbleInput: f,
      setBubbleInput: p
    } = s5(sce, t), g = vt(n, p), y = pk(o), m = WP(r);
    T.useEffect(() => {
      const b = f;
      if (!b) return;
      const x = window.HTMLInputElement.prototype, S = Object.getOwnPropertyDescriptor(
        x,
        "checked"
      ).set, C = !s.current;
      if (y !== o && S) {
        const _ = new Event("click", { bubbles: C });
        b.indeterminate = _f(o), S.call(b, _f(o) ? !1 : o), b.dispatchEvent(_);
      }
    }, [f, y, o, s]);
    const v = T.useRef(_f(o) ? !1 : o);
    return /* @__PURE__ */ h.jsx(
      Re.input,
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: i ?? v.current,
        required: a,
        disabled: c,
        name: l,
        value: d,
        form: u,
        ...e,
        tabIndex: -1,
        ref: g,
        style: {
          ...e.style,
          ...m,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
oce.displayName = sce;
function OGe(t) {
  return typeof t == "function";
}
function _f(t) {
  return t === "indeterminate";
}
function ice(t) {
  return _f(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
var jO = "rovingFocusGroup.onEntryFocus", DGe = { bubbles: !1, cancelable: !0 }, uS = "RovingFocusGroup", [Gj, ace, NGe] = w0(uS), [jGe, hv] = bs(
  uS,
  [NGe]
), [RGe, $Ge] = jGe(uS), cce = T.forwardRef(
  (t, e) => /* @__PURE__ */ h.jsx(Gj.Provider, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ h.jsx(Gj.Slot, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ h.jsx(LGe, { ...t, ref: e }) }) })
);
cce.displayName = uS;
var LGe = T.forwardRef((t, e) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: s = !1,
    dir: o,
    currentTabStopId: i,
    defaultCurrentTabStopId: a,
    onCurrentTabStopIdChange: c,
    onEntryFocus: l,
    preventScrollOnEntryFocus: d = !1,
    ...u
  } = t, f = T.useRef(null), p = vt(e, f), g = vg(o), [y, m] = io({
    prop: i,
    defaultProp: a ?? null,
    onChange: c,
    caller: uS
  }), [v, b] = T.useState(!1), x = pr(l), w = ace(n), S = T.useRef(!1), [C, _] = T.useState(0);
  return T.useEffect(() => {
    const E = f.current;
    if (E)
      return E.addEventListener(jO, x), () => E.removeEventListener(jO, x);
  }, [x]), /* @__PURE__ */ h.jsx(
    RGe,
    {
      scope: n,
      orientation: r,
      dir: g,
      loop: s,
      currentTabStopId: y,
      onItemFocus: T.useCallback(
        (E) => m(E),
        [m]
      ),
      onItemShiftTab: T.useCallback(() => b(!0), []),
      onFocusableItemAdd: T.useCallback(
        () => _((E) => E + 1),
        []
      ),
      onFocusableItemRemove: T.useCallback(
        () => _((E) => E - 1),
        []
      ),
      children: /* @__PURE__ */ h.jsx(
        Re.div,
        {
          tabIndex: v || C === 0 ? -1 : 0,
          "data-orientation": r,
          ...u,
          ref: p,
          style: { outline: "none", ...t.style },
          onMouseDown: Te(t.onMouseDown, () => {
            S.current = !0;
          }),
          onFocus: Te(t.onFocus, (E) => {
            const M = !S.current;
            if (E.target === E.currentTarget && M && !v) {
              const N = new CustomEvent(jO, DGe);
              if (E.currentTarget.dispatchEvent(N), !N.defaultPrevented) {
                const O = w().filter((j) => j.focusable), D = O.find((j) => j.active), k = O.find((j) => j.id === y), R = [D, k, ...O].filter(
                  Boolean
                ).map((j) => j.ref.current);
                uce(R, d);
              }
            }
            S.current = !1;
          }),
          onBlur: Te(t.onBlur, () => b(!1))
        }
      )
    }
  );
}), lce = "RovingFocusGroupItem", dce = T.forwardRef(
  (t, e) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: s = !1,
      tabStopId: o,
      children: i,
      ...a
    } = t, c = as(), l = o || c, d = $Ge(lce, n), u = d.currentTabStopId === l, f = ace(n), { onFocusableItemAdd: p, onFocusableItemRemove: g, currentTabStopId: y } = d;
    return T.useEffect(() => {
      if (r)
        return p(), () => g();
    }, [r, p, g]), /* @__PURE__ */ h.jsx(
      Gj.ItemSlot,
      {
        scope: n,
        id: l,
        focusable: r,
        active: s,
        children: /* @__PURE__ */ h.jsx(
          Re.span,
          {
            tabIndex: u ? 0 : -1,
            "data-orientation": d.orientation,
            ...a,
            ref: e,
            onMouseDown: Te(t.onMouseDown, (m) => {
              r ? d.onItemFocus(l) : m.preventDefault();
            }),
            onFocus: Te(t.onFocus, () => d.onItemFocus(l)),
            onKeyDown: Te(t.onKeyDown, (m) => {
              if (m.key === "Tab" && m.shiftKey) {
                d.onItemShiftTab();
                return;
              }
              if (m.target !== m.currentTarget) return;
              const v = zGe(m, d.orientation, d.dir);
              if (v !== void 0) {
                if (m.metaKey || m.ctrlKey || m.altKey || m.shiftKey) return;
                m.preventDefault();
                let x = f().filter((w) => w.focusable).map((w) => w.ref.current);
                if (v === "last") x.reverse();
                else if (v === "prev" || v === "next") {
                  v === "prev" && x.reverse();
                  const w = x.indexOf(m.currentTarget);
                  x = d.loop ? UGe(x, w + 1) : x.slice(w + 1);
                }
                setTimeout(() => uce(x));
              }
            }),
            children: typeof i == "function" ? i({ isCurrentTabStop: u, hasTabStop: y != null }) : i
          }
        )
      }
    );
  }
);
dce.displayName = lce;
var FGe = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function BGe(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function zGe(t, e, n) {
  const r = BGe(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return FGe[r];
}
function uce(t, e = !1) {
  const n = document.activeElement;
  for (const r of t)
    if (r === n || (r.focus({ preventScroll: e }), document.activeElement !== n)) return;
}
function UGe(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var i5 = cce, mk = dce, Yj = ["Enter", " "], HGe = ["ArrowDown", "PageUp", "Home"], fce = ["ArrowUp", "PageDown", "End"], VGe = [...HGe, ...fce], WGe = {
  ltr: [...Yj, "ArrowRight"],
  rtl: [...Yj, "ArrowLeft"]
}, KGe = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, fS = "Menu", [Sw, GGe, YGe] = w0(fS), [bg, yk] = bs(fS, [
  YGe,
  Kf,
  hv
]), hS = Kf(), hce = hv(), [pce, ih] = bg(fS), [qGe, pS] = bg(fS), gce = (t) => {
  const { __scopeMenu: e, open: n = !1, children: r, dir: s, onOpenChange: o, modal: i = !0 } = t, a = hS(e), [c, l] = T.useState(null), d = T.useRef(!1), u = pr(o), f = vg(s);
  return T.useEffect(() => {
    const p = () => {
      d.current = !0, document.addEventListener("pointerdown", g, { capture: !0, once: !0 }), document.addEventListener("pointermove", g, { capture: !0, once: !0 });
    }, g = () => d.current = !1;
    return document.addEventListener("keydown", p, { capture: !0 }), () => {
      document.removeEventListener("keydown", p, { capture: !0 }), document.removeEventListener("pointerdown", g, { capture: !0 }), document.removeEventListener("pointermove", g, { capture: !0 });
    };
  }, []), /* @__PURE__ */ h.jsx(P0, { ...a, children: /* @__PURE__ */ h.jsx(
    pce,
    {
      scope: e,
      open: n,
      onOpenChange: u,
      content: c,
      onContentChange: l,
      children: /* @__PURE__ */ h.jsx(
        qGe,
        {
          scope: e,
          onClose: T.useCallback(() => u(!1), [u]),
          isUsingKeyboardRef: d,
          dir: f,
          modal: i,
          children: r
        }
      )
    }
  ) });
};
gce.displayName = fS;
var XGe = "MenuAnchor", a5 = T.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, s = hS(n);
    return /* @__PURE__ */ h.jsx(I0, { ...s, ...r, ref: e });
  }
);
a5.displayName = XGe;
var c5 = "MenuPortal", [ZGe, mce] = bg(c5, {
  forceMount: void 0
}), yce = (t) => {
  const { __scopeMenu: e, forceMount: n, children: r, container: s } = t, o = ih(c5, e);
  return /* @__PURE__ */ h.jsx(ZGe, { scope: e, forceMount: n, children: /* @__PURE__ */ h.jsx(Fs, { present: n || o.open, children: /* @__PURE__ */ h.jsx(Uy, { asChild: !0, container: s, children: r }) }) });
};
yce.displayName = c5;
var cc = "MenuContent", [QGe, l5] = bg(cc), vce = T.forwardRef(
  (t, e) => {
    const n = mce(cc, t.__scopeMenu), { forceMount: r = n.forceMount, ...s } = t, o = ih(cc, t.__scopeMenu), i = pS(cc, t.__scopeMenu);
    return /* @__PURE__ */ h.jsx(Sw.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ h.jsx(Fs, { present: r || o.open, children: /* @__PURE__ */ h.jsx(Sw.Slot, { scope: t.__scopeMenu, children: i.modal ? /* @__PURE__ */ h.jsx(JGe, { ...s, ref: e }) : /* @__PURE__ */ h.jsx(eYe, { ...s, ref: e }) }) }) });
  }
), JGe = T.forwardRef(
  (t, e) => {
    const n = ih(cc, t.__scopeMenu), r = T.useRef(null), s = vt(e, r);
    return T.useEffect(() => {
      const o = r.current;
      if (o) return JP(o);
    }, []), /* @__PURE__ */ h.jsx(
      d5,
      {
        ...t,
        ref: s,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Te(
          t.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), eYe = T.forwardRef((t, e) => {
  const n = ih(cc, t.__scopeMenu);
  return /* @__PURE__ */ h.jsx(
    d5,
    {
      ...t,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), tYe = /* @__PURE__ */ kf("MenuContent.ScrollLock"), d5 = T.forwardRef(
  (t, e) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: s,
      onOpenAutoFocus: o,
      onCloseAutoFocus: i,
      disableOutsidePointerEvents: a,
      onEntryFocus: c,
      onEscapeKeyDown: l,
      onPointerDownOutside: d,
      onFocusOutside: u,
      onInteractOutside: f,
      onDismiss: p,
      disableOutsideScroll: g,
      ...y
    } = t, m = ih(cc, n), v = pS(cc, n), b = hS(n), x = hce(n), w = GGe(n), [S, C] = T.useState(null), _ = T.useRef(null), E = vt(e, _, m.onContentChange), M = T.useRef(0), N = T.useRef(""), O = T.useRef(0), D = T.useRef(null), k = T.useRef("right"), A = T.useRef(0), R = g ? A0 : T.Fragment, j = g ? { as: tYe, allowPinchZoom: !0 } : void 0, $ = (L) => {
      var Y, ee;
      const z = N.current + L, H = w().filter((ae) => !ae.disabled), U = document.activeElement, W = (Y = H.find((ae) => ae.ref.current === U)) == null ? void 0 : Y.textValue, Z = H.map((ae) => ae.textValue), K = hYe(Z, z, W), oe = (ee = H.find((ae) => ae.textValue === K)) == null ? void 0 : ee.ref.current;
      (function ae(de) {
        N.current = de, window.clearTimeout(M.current), de !== "" && (M.current = window.setTimeout(() => ae(""), 1e3));
      })(z), oe && setTimeout(() => oe.focus());
    };
    T.useEffect(() => () => window.clearTimeout(M.current), []), ZP();
    const F = T.useCallback((L) => {
      var H, U;
      return k.current === ((H = D.current) == null ? void 0 : H.side) && gYe(L, (U = D.current) == null ? void 0 : U.area);
    }, []);
    return /* @__PURE__ */ h.jsx(
      QGe,
      {
        scope: n,
        searchRef: N,
        onItemEnter: T.useCallback(
          (L) => {
            F(L) && L.preventDefault();
          },
          [F]
        ),
        onItemLeave: T.useCallback(
          (L) => {
            var z;
            F(L) || ((z = _.current) == null || z.focus(), C(null));
          },
          [F]
        ),
        onTriggerLeave: T.useCallback(
          (L) => {
            F(L) && L.preventDefault();
          },
          [F]
        ),
        pointerGraceTimerRef: O,
        onPointerGraceIntentChange: T.useCallback((L) => {
          D.current = L;
        }, []),
        children: /* @__PURE__ */ h.jsx(R, { ...j, children: /* @__PURE__ */ h.jsx(
          k0,
          {
            asChild: !0,
            trapped: s,
            onMountAutoFocus: Te(o, (L) => {
              var z;
              L.preventDefault(), (z = _.current) == null || z.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: i,
            children: /* @__PURE__ */ h.jsx(
              ng,
              {
                asChild: !0,
                disableOutsidePointerEvents: a,
                onEscapeKeyDown: l,
                onPointerDownOutside: d,
                onFocusOutside: u,
                onInteractOutside: f,
                onDismiss: p,
                children: /* @__PURE__ */ h.jsx(
                  i5,
                  {
                    asChild: !0,
                    ...x,
                    dir: v.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: S,
                    onCurrentTabStopIdChange: C,
                    onEntryFocus: Te(c, (L) => {
                      v.isUsingKeyboardRef.current || L.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ h.jsx(
                      KP,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": jce(m.open),
                        "data-radix-menu-content": "",
                        dir: v.dir,
                        ...b,
                        ...y,
                        ref: E,
                        style: { outline: "none", ...y.style },
                        onKeyDown: Te(y.onKeyDown, (L) => {
                          const H = L.target.closest("[data-radix-menu-content]") === L.currentTarget, U = L.ctrlKey || L.altKey || L.metaKey, W = L.key.length === 1;
                          H && (L.key === "Tab" && L.preventDefault(), !U && W && $(L.key));
                          const Z = _.current;
                          if (L.target !== Z || !VGe.includes(L.key)) return;
                          L.preventDefault();
                          const oe = w().filter((Y) => !Y.disabled).map((Y) => Y.ref.current);
                          fce.includes(L.key) && oe.reverse(), uYe(oe);
                        }),
                        onBlur: Te(t.onBlur, (L) => {
                          L.currentTarget.contains(L.target) || (window.clearTimeout(M.current), N.current = "");
                        }),
                        onPointerMove: Te(
                          t.onPointerMove,
                          Cw((L) => {
                            const z = L.target, H = A.current !== L.clientX;
                            if (L.currentTarget.contains(z) && H) {
                              const U = L.clientX > A.current ? "right" : "left";
                              k.current = U, A.current = L.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
vce.displayName = cc;
var nYe = "MenuGroup", u5 = T.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ h.jsx(Re.div, { role: "group", ...r, ref: e });
  }
);
u5.displayName = nYe;
var rYe = "MenuLabel", bce = T.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ h.jsx(Re.div, { ...r, ref: e });
  }
);
bce.displayName = rYe;
var sT = "MenuItem", oV = "menu.itemSelect", vk = T.forwardRef(
  (t, e) => {
    const { disabled: n = !1, onSelect: r, ...s } = t, o = T.useRef(null), i = pS(sT, t.__scopeMenu), a = l5(sT, t.__scopeMenu), c = vt(e, o), l = T.useRef(!1), d = () => {
      const u = o.current;
      if (!n && u) {
        const f = new CustomEvent(oV, { bubbles: !0, cancelable: !0 });
        u.addEventListener(oV, (p) => r == null ? void 0 : r(p), { once: !0 }), R$(u, f), f.defaultPrevented ? l.current = !1 : i.onClose();
      }
    };
    return /* @__PURE__ */ h.jsx(
      xce,
      {
        ...s,
        ref: c,
        disabled: n,
        onClick: Te(t.onClick, d),
        onPointerDown: (u) => {
          var f;
          (f = t.onPointerDown) == null || f.call(t, u), l.current = !0;
        },
        onPointerUp: Te(t.onPointerUp, (u) => {
          var f;
          l.current || (f = u.currentTarget) == null || f.click();
        }),
        onKeyDown: Te(t.onKeyDown, (u) => {
          const f = a.searchRef.current !== "";
          n || f && u.key === " " || Yj.includes(u.key) && (u.currentTarget.click(), u.preventDefault());
        })
      }
    );
  }
);
vk.displayName = sT;
var xce = T.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: s, ...o } = t, i = l5(sT, n), a = hce(n), c = T.useRef(null), l = vt(e, c), [d, u] = T.useState(!1), [f, p] = T.useState("");
    return T.useEffect(() => {
      const g = c.current;
      g && p((g.textContent ?? "").trim());
    }, [o.children]), /* @__PURE__ */ h.jsx(
      Sw.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: s ?? f,
        children: /* @__PURE__ */ h.jsx(mk, { asChild: !0, ...a, focusable: !r, children: /* @__PURE__ */ h.jsx(
          Re.div,
          {
            role: "menuitem",
            "data-highlighted": d ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...o,
            ref: l,
            onPointerMove: Te(
              t.onPointerMove,
              Cw((g) => {
                r ? i.onItemLeave(g) : (i.onItemEnter(g), g.defaultPrevented || g.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Te(
              t.onPointerLeave,
              Cw((g) => i.onItemLeave(g))
            ),
            onFocus: Te(t.onFocus, () => u(!0)),
            onBlur: Te(t.onBlur, () => u(!1))
          }
        ) })
      }
    );
  }
), sYe = "MenuCheckboxItem", wce = T.forwardRef(
  (t, e) => {
    const { checked: n = !1, onCheckedChange: r, ...s } = t;
    return /* @__PURE__ */ h.jsx(Tce, { scope: t.__scopeMenu, checked: n, children: /* @__PURE__ */ h.jsx(
      vk,
      {
        role: "menuitemcheckbox",
        "aria-checked": oT(n) ? "mixed" : n,
        ...s,
        ref: e,
        "data-state": p5(n),
        onSelect: Te(
          s.onSelect,
          () => r == null ? void 0 : r(oT(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
wce.displayName = sYe;
var Sce = "MenuRadioGroup", [oYe, iYe] = bg(
  Sce,
  { value: void 0, onValueChange: () => {
  } }
), Cce = T.forwardRef(
  (t, e) => {
    const { value: n, onValueChange: r, ...s } = t, o = pr(r);
    return /* @__PURE__ */ h.jsx(oYe, { scope: t.__scopeMenu, value: n, onValueChange: o, children: /* @__PURE__ */ h.jsx(u5, { ...s, ref: e }) });
  }
);
Cce.displayName = Sce;
var _ce = "MenuRadioItem", Ece = T.forwardRef(
  (t, e) => {
    const { value: n, ...r } = t, s = iYe(_ce, t.__scopeMenu), o = n === s.value;
    return /* @__PURE__ */ h.jsx(Tce, { scope: t.__scopeMenu, checked: o, children: /* @__PURE__ */ h.jsx(
      vk,
      {
        role: "menuitemradio",
        "aria-checked": o,
        ...r,
        ref: e,
        "data-state": p5(o),
        onSelect: Te(
          r.onSelect,
          () => {
            var i;
            return (i = s.onValueChange) == null ? void 0 : i.call(s, n);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
Ece.displayName = _ce;
var f5 = "MenuItemIndicator", [Tce, aYe] = bg(
  f5,
  { checked: !1 }
), Pce = T.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, forceMount: r, ...s } = t, o = aYe(f5, n);
    return /* @__PURE__ */ h.jsx(
      Fs,
      {
        present: r || oT(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ h.jsx(
          Re.span,
          {
            ...s,
            ref: e,
            "data-state": p5(o.checked)
          }
        )
      }
    );
  }
);
Pce.displayName = f5;
var cYe = "MenuSeparator", Ice = T.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ h.jsx(
      Re.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: e
      }
    );
  }
);
Ice.displayName = cYe;
var lYe = "MenuArrow", kce = T.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, s = hS(n);
    return /* @__PURE__ */ h.jsx(GP, { ...s, ...r, ref: e });
  }
);
kce.displayName = lYe;
var h5 = "MenuSub", [dYe, Ace] = bg(h5), Mce = (t) => {
  const { __scopeMenu: e, children: n, open: r = !1, onOpenChange: s } = t, o = ih(h5, e), i = hS(e), [a, c] = T.useState(null), [l, d] = T.useState(null), u = pr(s);
  return T.useEffect(() => (o.open === !1 && u(!1), () => u(!1)), [o.open, u]), /* @__PURE__ */ h.jsx(P0, { ...i, children: /* @__PURE__ */ h.jsx(
    pce,
    {
      scope: e,
      open: r,
      onOpenChange: u,
      content: l,
      onContentChange: d,
      children: /* @__PURE__ */ h.jsx(
        dYe,
        {
          scope: e,
          contentId: as(),
          triggerId: as(),
          trigger: a,
          onTriggerChange: c,
          children: n
        }
      )
    }
  ) });
};
Mce.displayName = h5;
var Ub = "MenuSubTrigger", Oce = T.forwardRef(
  (t, e) => {
    const n = ih(Ub, t.__scopeMenu), r = pS(Ub, t.__scopeMenu), s = Ace(Ub, t.__scopeMenu), o = l5(Ub, t.__scopeMenu), i = T.useRef(null), { pointerGraceTimerRef: a, onPointerGraceIntentChange: c } = o, l = { __scopeMenu: t.__scopeMenu }, d = T.useCallback(() => {
      i.current && window.clearTimeout(i.current), i.current = null;
    }, []);
    return T.useEffect(() => d, [d]), T.useEffect(() => {
      const u = a.current;
      return () => {
        window.clearTimeout(u), c(null);
      };
    }, [a, c]), /* @__PURE__ */ h.jsx(a5, { asChild: !0, ...l, children: /* @__PURE__ */ h.jsx(
      xce,
      {
        id: s.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": s.contentId,
        "data-state": jce(n.open),
        ...t,
        ref: eu(e, s.onTriggerChange),
        onClick: (u) => {
          var f;
          (f = t.onClick) == null || f.call(t, u), !(t.disabled || u.defaultPrevented) && (u.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Te(
          t.onPointerMove,
          Cw((u) => {
            o.onItemEnter(u), !u.defaultPrevented && !t.disabled && !n.open && !i.current && (o.onPointerGraceIntentChange(null), i.current = window.setTimeout(() => {
              n.onOpenChange(!0), d();
            }, 100));
          })
        ),
        onPointerLeave: Te(
          t.onPointerLeave,
          Cw((u) => {
            var p, g;
            d();
            const f = (p = n.content) == null ? void 0 : p.getBoundingClientRect();
            if (f) {
              const y = (g = n.content) == null ? void 0 : g.dataset.side, m = y === "right", v = m ? -5 : 5, b = f[m ? "left" : "right"], x = f[m ? "right" : "left"];
              o.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: u.clientX + v, y: u.clientY },
                  { x: b, y: f.top },
                  { x, y: f.top },
                  { x, y: f.bottom },
                  { x: b, y: f.bottom }
                ],
                side: y
              }), window.clearTimeout(a.current), a.current = window.setTimeout(
                () => o.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (o.onTriggerLeave(u), u.defaultPrevented) return;
              o.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Te(t.onKeyDown, (u) => {
          var p;
          const f = o.searchRef.current !== "";
          t.disabled || f && u.key === " " || WGe[r.dir].includes(u.key) && (n.onOpenChange(!0), (p = n.content) == null || p.focus(), u.preventDefault());
        })
      }
    ) });
  }
);
Oce.displayName = Ub;
var Dce = "MenuSubContent", Nce = T.forwardRef(
  (t, e) => {
    const n = mce(cc, t.__scopeMenu), { forceMount: r = n.forceMount, ...s } = t, o = ih(cc, t.__scopeMenu), i = pS(cc, t.__scopeMenu), a = Ace(Dce, t.__scopeMenu), c = T.useRef(null), l = vt(e, c);
    return /* @__PURE__ */ h.jsx(Sw.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ h.jsx(Fs, { present: r || o.open, children: /* @__PURE__ */ h.jsx(Sw.Slot, { scope: t.__scopeMenu, children: /* @__PURE__ */ h.jsx(
      d5,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...s,
        ref: l,
        align: "start",
        side: i.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (d) => {
          var u;
          i.isUsingKeyboardRef.current && ((u = c.current) == null || u.focus()), d.preventDefault();
        },
        onCloseAutoFocus: (d) => d.preventDefault(),
        onFocusOutside: Te(t.onFocusOutside, (d) => {
          d.target !== a.trigger && o.onOpenChange(!1);
        }),
        onEscapeKeyDown: Te(t.onEscapeKeyDown, (d) => {
          i.onClose(), d.preventDefault();
        }),
        onKeyDown: Te(t.onKeyDown, (d) => {
          var p;
          const u = d.currentTarget.contains(d.target), f = KGe[i.dir].includes(d.key);
          u && f && (o.onOpenChange(!1), (p = a.trigger) == null || p.focus(), d.preventDefault());
        })
      }
    ) }) }) });
  }
);
Nce.displayName = Dce;
function jce(t) {
  return t ? "open" : "closed";
}
function oT(t) {
  return t === "indeterminate";
}
function p5(t) {
  return oT(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function uYe(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return;
}
function fYe(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
function hYe(t, e, n) {
  const s = e.length > 1 && Array.from(e).every((l) => l === e[0]) ? e[0] : e, o = n ? t.indexOf(n) : -1;
  let i = fYe(t, Math.max(o, 0));
  s.length === 1 && (i = i.filter((l) => l !== n));
  const c = i.find(
    (l) => l.toLowerCase().startsWith(s.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function pYe(t, e) {
  const { x: n, y: r } = t;
  let s = !1;
  for (let o = 0, i = e.length - 1; o < e.length; i = o++) {
    const a = e[o], c = e[i], l = a.x, d = a.y, u = c.x, f = c.y;
    d > r != f > r && n < (u - l) * (r - d) / (f - d) + l && (s = !s);
  }
  return s;
}
function gYe(t, e) {
  if (!e) return !1;
  const n = { x: t.clientX, y: t.clientY };
  return pYe(n, e);
}
function Cw(t) {
  return (e) => e.pointerType === "mouse" ? t(e) : void 0;
}
var Rce = gce, $ce = a5, Lce = yce, Fce = vce, Bce = u5, zce = bce, Uce = vk, Hce = wce, Vce = Cce, Wce = Ece, Kce = Pce, Gce = Ice, Yce = kce, qce = Mce, Xce = Oce, Zce = Nce, g5 = "ContextMenu", [mYe, q3t] = bs(g5, [
  yk
]), Bo = yk(), [yYe, Qce] = mYe(g5), Jce = (t) => {
  const { __scopeContextMenu: e, children: n, onOpenChange: r, dir: s, modal: o = !0 } = t, [i, a] = T.useState(!1), c = Bo(e), l = pr(r), d = T.useCallback(
    (u) => {
      a(u), l(u);
    },
    [l]
  );
  return /* @__PURE__ */ h.jsx(
    yYe,
    {
      scope: e,
      open: i,
      onOpenChange: d,
      modal: o,
      children: /* @__PURE__ */ h.jsx(
        Rce,
        {
          ...c,
          dir: s,
          open: i,
          onOpenChange: d,
          modal: o,
          children: n
        }
      )
    }
  );
};
Jce.displayName = g5;
var ele = "ContextMenuTrigger", tle = T.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, disabled: r = !1, ...s } = t, o = Qce(ele, n), i = Bo(n), a = T.useRef({ x: 0, y: 0 }), c = T.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...a.current })
    }), l = T.useRef(0), d = T.useCallback(
      () => window.clearTimeout(l.current),
      []
    ), u = (f) => {
      a.current = { x: f.clientX, y: f.clientY }, o.onOpenChange(!0);
    };
    return T.useEffect(() => d, [d]), T.useEffect(() => void (r && d()), [r, d]), /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx($ce, { ...i, virtualRef: c }),
      /* @__PURE__ */ h.jsx(
        Re.span,
        {
          "data-state": o.open ? "open" : "closed",
          "data-disabled": r ? "" : void 0,
          ...s,
          ref: e,
          style: { WebkitTouchCallout: "none", ...t.style },
          onContextMenu: r ? t.onContextMenu : Te(t.onContextMenu, (f) => {
            d(), u(f), f.preventDefault();
          }),
          onPointerDown: r ? t.onPointerDown : Te(
            t.onPointerDown,
            U1((f) => {
              d(), l.current = window.setTimeout(() => u(f), 700);
            })
          ),
          onPointerMove: r ? t.onPointerMove : Te(t.onPointerMove, U1(d)),
          onPointerCancel: r ? t.onPointerCancel : Te(t.onPointerCancel, U1(d)),
          onPointerUp: r ? t.onPointerUp : Te(t.onPointerUp, U1(d))
        }
      )
    ] });
  }
);
tle.displayName = ele;
var vYe = "ContextMenuPortal", m5 = (t) => {
  const { __scopeContextMenu: e, ...n } = t, r = Bo(e);
  return /* @__PURE__ */ h.jsx(Lce, { ...r, ...n });
};
m5.displayName = vYe;
var nle = "ContextMenuContent", rle = T.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = Qce(nle, n), o = Bo(n), i = T.useRef(!1);
    return /* @__PURE__ */ h.jsx(
      Fce,
      {
        ...o,
        ...r,
        ref: e,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (a) => {
          var c;
          (c = t.onCloseAutoFocus) == null || c.call(t, a), !a.defaultPrevented && i.current && a.preventDefault(), i.current = !1;
        },
        onInteractOutside: (a) => {
          var c;
          (c = t.onInteractOutside) == null || c.call(t, a), !a.defaultPrevented && !s.modal && (i.current = !0);
        },
        style: {
          ...t.style,
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
rle.displayName = nle;
var bYe = "ContextMenuGroup", xYe = T.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
    return /* @__PURE__ */ h.jsx(Bce, { ...s, ...r, ref: e });
  }
);
xYe.displayName = bYe;
var wYe = "ContextMenuLabel", SYe = T.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
    return /* @__PURE__ */ h.jsx(zce, { ...s, ...r, ref: e });
  }
);
SYe.displayName = wYe;
var CYe = "ContextMenuItem", sle = T.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
    return /* @__PURE__ */ h.jsx(Uce, { ...s, ...r, ref: e });
  }
);
sle.displayName = CYe;
var _Ye = "ContextMenuCheckboxItem", ole = T.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
  return /* @__PURE__ */ h.jsx(Hce, { ...s, ...r, ref: e });
});
ole.displayName = _Ye;
var EYe = "ContextMenuRadioGroup", TYe = T.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
  return /* @__PURE__ */ h.jsx(Vce, { ...s, ...r, ref: e });
});
TYe.displayName = EYe;
var PYe = "ContextMenuRadioItem", IYe = T.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
  return /* @__PURE__ */ h.jsx(Wce, { ...s, ...r, ref: e });
});
IYe.displayName = PYe;
var kYe = "ContextMenuItemIndicator", AYe = T.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
  return /* @__PURE__ */ h.jsx(Kce, { ...s, ...r, ref: e });
});
AYe.displayName = kYe;
var MYe = "ContextMenuSeparator", OYe = T.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
  return /* @__PURE__ */ h.jsx(Gce, { ...s, ...r, ref: e });
});
OYe.displayName = MYe;
var DYe = "ContextMenuArrow", NYe = T.forwardRef(
  (t, e) => {
    const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
    return /* @__PURE__ */ h.jsx(Yce, { ...s, ...r, ref: e });
  }
);
NYe.displayName = DYe;
var ile = "ContextMenuSub", ale = (t) => {
  const { __scopeContextMenu: e, children: n, onOpenChange: r, open: s, defaultOpen: o } = t, i = Bo(e), [a, c] = io({
    prop: s,
    defaultProp: o ?? !1,
    onChange: r,
    caller: ile
  });
  return /* @__PURE__ */ h.jsx(qce, { ...i, open: a, onOpenChange: c, children: n });
};
ale.displayName = ile;
var jYe = "ContextMenuSubTrigger", cle = T.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
  return /* @__PURE__ */ h.jsx(Xce, { ...s, ...r, ref: e });
});
cle.displayName = jYe;
var RYe = "ContextMenuSubContent", lle = T.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, s = Bo(n);
  return /* @__PURE__ */ h.jsx(
    Zce,
    {
      ...s,
      ...r,
      ref: e,
      style: {
        ...t.style,
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
lle.displayName = RYe;
function U1(t) {
  return (e) => e.pointerType !== "mouse" ? t(e) : void 0;
}
var $Ye = Jce, LYe = tle, FYe = m5, BYe = rle, zYe = sle, UYe = ole, bk = "DropdownMenu", [HYe, X3t] = bs(
  bk,
  [yk]
), zo = yk(), [VYe, dle] = HYe(bk), ule = (t) => {
  const {
    __scopeDropdownMenu: e,
    children: n,
    dir: r,
    open: s,
    defaultOpen: o,
    onOpenChange: i,
    modal: a = !0
  } = t, c = zo(e), l = T.useRef(null), [d, u] = io({
    prop: s,
    defaultProp: o ?? !1,
    onChange: i,
    caller: bk
  });
  return /* @__PURE__ */ h.jsx(
    VYe,
    {
      scope: e,
      triggerId: as(),
      triggerRef: l,
      contentId: as(),
      open: d,
      onOpenChange: u,
      onOpenToggle: T.useCallback(() => u((f) => !f), [u]),
      modal: a,
      children: /* @__PURE__ */ h.jsx(Rce, { ...c, open: d, onOpenChange: u, dir: r, modal: a, children: n })
    }
  );
};
ule.displayName = bk;
var fle = "DropdownMenuTrigger", hle = T.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...s } = t, o = dle(fle, n), i = zo(n);
    return /* @__PURE__ */ h.jsx($ce, { asChild: !0, ...i, children: /* @__PURE__ */ h.jsx(
      Re.button,
      {
        type: "button",
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": o.open,
        "aria-controls": o.open ? o.contentId : void 0,
        "data-state": o.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...s,
        ref: eu(e, o.triggerRef),
        onPointerDown: Te(t.onPointerDown, (a) => {
          !r && a.button === 0 && a.ctrlKey === !1 && (o.onOpenToggle(), o.open || a.preventDefault());
        }),
        onKeyDown: Te(t.onKeyDown, (a) => {
          r || (["Enter", " "].includes(a.key) && o.onOpenToggle(), a.key === "ArrowDown" && o.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
        })
      }
    ) });
  }
);
hle.displayName = fle;
var WYe = "DropdownMenuPortal", ple = (t) => {
  const { __scopeDropdownMenu: e, ...n } = t, r = zo(e);
  return /* @__PURE__ */ h.jsx(Lce, { ...r, ...n });
};
ple.displayName = WYe;
var gle = "DropdownMenuContent", mle = T.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = dle(gle, n), o = zo(n), i = T.useRef(!1);
    return /* @__PURE__ */ h.jsx(
      Fce,
      {
        id: s.contentId,
        "aria-labelledby": s.triggerId,
        ...o,
        ...r,
        ref: e,
        onCloseAutoFocus: Te(t.onCloseAutoFocus, (a) => {
          var c;
          i.current || (c = s.triggerRef.current) == null || c.focus(), i.current = !1, a.preventDefault();
        }),
        onInteractOutside: Te(t.onInteractOutside, (a) => {
          const c = a.detail.originalEvent, l = c.button === 0 && c.ctrlKey === !0, d = c.button === 2 || l;
          (!s.modal || d) && (i.current = !0);
        }),
        style: {
          ...t.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
mle.displayName = gle;
var KYe = "DropdownMenuGroup", GYe = T.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
    return /* @__PURE__ */ h.jsx(Bce, { ...s, ...r, ref: e });
  }
);
GYe.displayName = KYe;
var YYe = "DropdownMenuLabel", qYe = T.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
    return /* @__PURE__ */ h.jsx(zce, { ...s, ...r, ref: e });
  }
);
qYe.displayName = YYe;
var XYe = "DropdownMenuItem", yle = T.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
    return /* @__PURE__ */ h.jsx(Uce, { ...s, ...r, ref: e });
  }
);
yle.displayName = XYe;
var ZYe = "DropdownMenuCheckboxItem", vle = T.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
  return /* @__PURE__ */ h.jsx(Hce, { ...s, ...r, ref: e });
});
vle.displayName = ZYe;
var QYe = "DropdownMenuRadioGroup", JYe = T.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
  return /* @__PURE__ */ h.jsx(Vce, { ...s, ...r, ref: e });
});
JYe.displayName = QYe;
var eqe = "DropdownMenuRadioItem", tqe = T.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
  return /* @__PURE__ */ h.jsx(Wce, { ...s, ...r, ref: e });
});
tqe.displayName = eqe;
var nqe = "DropdownMenuItemIndicator", ble = T.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
  return /* @__PURE__ */ h.jsx(Kce, { ...s, ...r, ref: e });
});
ble.displayName = nqe;
var rqe = "DropdownMenuSeparator", sqe = T.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
  return /* @__PURE__ */ h.jsx(Gce, { ...s, ...r, ref: e });
});
sqe.displayName = rqe;
var oqe = "DropdownMenuArrow", iqe = T.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
    return /* @__PURE__ */ h.jsx(Yce, { ...s, ...r, ref: e });
  }
);
iqe.displayName = oqe;
var aqe = (t) => {
  const { __scopeDropdownMenu: e, children: n, open: r, onOpenChange: s, defaultOpen: o } = t, i = zo(e), [a, c] = io({
    prop: r,
    defaultProp: o ?? !1,
    onChange: s,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ h.jsx(qce, { ...i, open: a, onOpenChange: c, children: n });
}, cqe = "DropdownMenuSubTrigger", xle = T.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
  return /* @__PURE__ */ h.jsx(Xce, { ...s, ...r, ref: e });
});
xle.displayName = cqe;
var lqe = "DropdownMenuSubContent", wle = T.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, s = zo(n);
  return /* @__PURE__ */ h.jsx(
    Zce,
    {
      ...s,
      ...r,
      ref: e,
      style: {
        ...t.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
wle.displayName = lqe;
var y5 = ule, v5 = hle, xk = ple, b5 = mle, dqe = yle, Sle = vle, uqe = ble, fqe = aqe, hqe = xle, pqe = wle, gqe = "Label", Cle = T.forwardRef((t, e) => /* @__PURE__ */ h.jsx(
  Re.label,
  {
    ...t,
    ref: e,
    onMouseDown: (n) => {
      var s;
      n.target.closest("button, input, select, textarea") || ((s = t.onMouseDown) == null || s.call(t, n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
Cle.displayName = gqe;
var _le = Cle;
function _w(t, [e, n]) {
  return Math.min(n, Math.max(e, t));
}
var x5 = "Progress", w5 = 100, [mqe, Z3t] = bs(x5), [yqe, vqe] = mqe(x5), Ele = T.forwardRef(
  (t, e) => {
    const {
      __scopeProgress: n,
      value: r = null,
      max: s,
      getValueLabel: o = bqe,
      ...i
    } = t;
    (s || s === 0) && !iV(s) && console.error(xqe(`${s}`, "Progress"));
    const a = iV(s) ? s : w5;
    r !== null && !aV(r, a) && console.error(wqe(`${r}`, "Progress"));
    const c = aV(r, a) ? r : null, l = iT(c) ? o(c, a) : void 0;
    return /* @__PURE__ */ h.jsx(yqe, { scope: n, value: c, max: a, children: /* @__PURE__ */ h.jsx(
      Re.div,
      {
        "aria-valuemax": a,
        "aria-valuemin": 0,
        "aria-valuenow": iT(c) ? c : void 0,
        "aria-valuetext": l,
        role: "progressbar",
        "data-state": Ile(c, a),
        "data-value": c ?? void 0,
        "data-max": a,
        ...i,
        ref: e
      }
    ) });
  }
);
Ele.displayName = x5;
var Tle = "ProgressIndicator", Ple = T.forwardRef(
  (t, e) => {
    const { __scopeProgress: n, ...r } = t, s = vqe(Tle, n);
    return /* @__PURE__ */ h.jsx(
      Re.div,
      {
        "data-state": Ile(s.value, s.max),
        "data-value": s.value ?? void 0,
        "data-max": s.max,
        ...r,
        ref: e
      }
    );
  }
);
Ple.displayName = Tle;
function bqe(t, e) {
  return `${Math.round(t / e * 100)}%`;
}
function Ile(t, e) {
  return t == null ? "indeterminate" : t === e ? "complete" : "loading";
}
function iT(t) {
  return typeof t == "number";
}
function iV(t) {
  return iT(t) && !isNaN(t) && t > 0;
}
function aV(t, e) {
  return iT(t) && !isNaN(t) && t <= e && t >= 0;
}
function xqe(t, e) {
  return `Invalid prop \`max\` of value \`${t}\` supplied to \`${e}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${w5}\`.`;
}
function wqe(t, e) {
  return `Invalid prop \`value\` of value \`${t}\` supplied to \`${e}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${w5} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
var kle = Ele, Sqe = Ple;
function Cqe(t, e) {
  return T.useReducer((n, r) => e[n][r] ?? n, t);
}
var S5 = "ScrollArea", [Ale, Q3t] = bs(S5), [_qe, pc] = Ale(S5), Mle = T.forwardRef(
  (t, e) => {
    const {
      __scopeScrollArea: n,
      type: r = "hover",
      dir: s,
      scrollHideDelay: o = 600,
      ...i
    } = t, [a, c] = T.useState(null), [l, d] = T.useState(null), [u, f] = T.useState(null), [p, g] = T.useState(null), [y, m] = T.useState(null), [v, b] = T.useState(0), [x, w] = T.useState(0), [S, C] = T.useState(!1), [_, E] = T.useState(!1), M = vt(e, (O) => c(O)), N = vg(s);
    return /* @__PURE__ */ h.jsx(
      _qe,
      {
        scope: n,
        type: r,
        dir: N,
        scrollHideDelay: o,
        scrollArea: a,
        viewport: l,
        onViewportChange: d,
        content: u,
        onContentChange: f,
        scrollbarX: p,
        onScrollbarXChange: g,
        scrollbarXEnabled: S,
        onScrollbarXEnabledChange: C,
        scrollbarY: y,
        onScrollbarYChange: m,
        scrollbarYEnabled: _,
        onScrollbarYEnabledChange: E,
        onCornerWidthChange: b,
        onCornerHeightChange: w,
        children: /* @__PURE__ */ h.jsx(
          Re.div,
          {
            dir: N,
            ...i,
            ref: M,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": v + "px",
              "--radix-scroll-area-corner-height": x + "px",
              ...t.style
            }
          }
        )
      }
    );
  }
);
Mle.displayName = S5;
var Ole = "ScrollAreaViewport", Dle = T.forwardRef(
  (t, e) => {
    const { __scopeScrollArea: n, children: r, nonce: s, ...o } = t, i = pc(Ole, n), a = T.useRef(null), c = vt(e, a, i.onViewportChange);
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: s
        }
      ),
      /* @__PURE__ */ h.jsx(
        Re.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...o,
          ref: c,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: i.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: i.scrollbarYEnabled ? "scroll" : "hidden",
            ...t.style
          },
          children: /* @__PURE__ */ h.jsx("div", { ref: i.onContentChange, style: { minWidth: "100%", display: "table" }, children: r })
        }
      )
    ] });
  }
);
Dle.displayName = Ole;
var id = "ScrollAreaScrollbar", C5 = T.forwardRef(
  (t, e) => {
    const { forceMount: n, ...r } = t, s = pc(id, t.__scopeScrollArea), { onScrollbarXEnabledChange: o, onScrollbarYEnabledChange: i } = s, a = t.orientation === "horizontal";
    return T.useEffect(() => (a ? o(!0) : i(!0), () => {
      a ? o(!1) : i(!1);
    }), [a, o, i]), s.type === "hover" ? /* @__PURE__ */ h.jsx(Eqe, { ...r, ref: e, forceMount: n }) : s.type === "scroll" ? /* @__PURE__ */ h.jsx(Tqe, { ...r, ref: e, forceMount: n }) : s.type === "auto" ? /* @__PURE__ */ h.jsx(Nle, { ...r, ref: e, forceMount: n }) : s.type === "always" ? /* @__PURE__ */ h.jsx(_5, { ...r, ref: e }) : null;
  }
);
C5.displayName = id;
var Eqe = T.forwardRef((t, e) => {
  const { forceMount: n, ...r } = t, s = pc(id, t.__scopeScrollArea), [o, i] = T.useState(!1);
  return T.useEffect(() => {
    const a = s.scrollArea;
    let c = 0;
    if (a) {
      const l = () => {
        window.clearTimeout(c), i(!0);
      }, d = () => {
        c = window.setTimeout(() => i(!1), s.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", l), a.addEventListener("pointerleave", d), () => {
        window.clearTimeout(c), a.removeEventListener("pointerenter", l), a.removeEventListener("pointerleave", d);
      };
    }
  }, [s.scrollArea, s.scrollHideDelay]), /* @__PURE__ */ h.jsx(Fs, { present: n || o, children: /* @__PURE__ */ h.jsx(
    Nle,
    {
      "data-state": o ? "visible" : "hidden",
      ...r,
      ref: e
    }
  ) });
}), Tqe = T.forwardRef((t, e) => {
  const { forceMount: n, ...r } = t, s = pc(id, t.__scopeScrollArea), o = t.orientation === "horizontal", i = Sk(() => c("SCROLL_END"), 100), [a, c] = Cqe("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return T.useEffect(() => {
    if (a === "idle") {
      const l = window.setTimeout(() => c("HIDE"), s.scrollHideDelay);
      return () => window.clearTimeout(l);
    }
  }, [a, s.scrollHideDelay, c]), T.useEffect(() => {
    const l = s.viewport, d = o ? "scrollLeft" : "scrollTop";
    if (l) {
      let u = l[d];
      const f = () => {
        const p = l[d];
        u !== p && (c("SCROLL"), i()), u = p;
      };
      return l.addEventListener("scroll", f), () => l.removeEventListener("scroll", f);
    }
  }, [s.viewport, o, c, i]), /* @__PURE__ */ h.jsx(Fs, { present: n || a !== "hidden", children: /* @__PURE__ */ h.jsx(
    _5,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...r,
      ref: e,
      onPointerEnter: Te(t.onPointerEnter, () => c("POINTER_ENTER")),
      onPointerLeave: Te(t.onPointerLeave, () => c("POINTER_LEAVE"))
    }
  ) });
}), Nle = T.forwardRef((t, e) => {
  const n = pc(id, t.__scopeScrollArea), { forceMount: r, ...s } = t, [o, i] = T.useState(!1), a = t.orientation === "horizontal", c = Sk(() => {
    if (n.viewport) {
      const l = n.viewport.offsetWidth < n.viewport.scrollWidth, d = n.viewport.offsetHeight < n.viewport.scrollHeight;
      i(a ? l : d);
    }
  }, 10);
  return gy(n.viewport, c), gy(n.content, c), /* @__PURE__ */ h.jsx(Fs, { present: r || o, children: /* @__PURE__ */ h.jsx(
    _5,
    {
      "data-state": o ? "visible" : "hidden",
      ...s,
      ref: e
    }
  ) });
}), _5 = T.forwardRef((t, e) => {
  const { orientation: n = "vertical", ...r } = t, s = pc(id, t.__scopeScrollArea), o = T.useRef(null), i = T.useRef(0), [a, c] = T.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), l = Fle(a.viewport, a.content), d = {
    ...r,
    sizes: a,
    onSizesChange: c,
    hasThumb: l > 0 && l < 1,
    onThumbChange: (f) => o.current = f,
    onThumbPointerUp: () => i.current = 0,
    onThumbPointerDown: (f) => i.current = f
  };
  function u(f, p) {
    return Oqe(f, i.current, a, p);
  }
  return n === "horizontal" ? /* @__PURE__ */ h.jsx(
    Pqe,
    {
      ...d,
      ref: e,
      onThumbPositionChange: () => {
        if (s.viewport && o.current) {
          const f = s.viewport.scrollLeft, p = cV(f, a, s.dir);
          o.current.style.transform = `translate3d(${p}px, 0, 0)`;
        }
      },
      onWheelScroll: (f) => {
        s.viewport && (s.viewport.scrollLeft = f);
      },
      onDragScroll: (f) => {
        s.viewport && (s.viewport.scrollLeft = u(f, s.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ h.jsx(
    Iqe,
    {
      ...d,
      ref: e,
      onThumbPositionChange: () => {
        if (s.viewport && o.current) {
          const f = s.viewport.scrollTop, p = cV(f, a);
          o.current.style.transform = `translate3d(0, ${p}px, 0)`;
        }
      },
      onWheelScroll: (f) => {
        s.viewport && (s.viewport.scrollTop = f);
      },
      onDragScroll: (f) => {
        s.viewport && (s.viewport.scrollTop = u(f));
      }
    }
  ) : null;
}), Pqe = T.forwardRef((t, e) => {
  const { sizes: n, onSizesChange: r, ...s } = t, o = pc(id, t.__scopeScrollArea), [i, a] = T.useState(), c = T.useRef(null), l = vt(e, c, o.onScrollbarXChange);
  return T.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ h.jsx(
    Rle,
    {
      "data-orientation": "horizontal",
      ...s,
      ref: l,
      sizes: n,
      style: {
        bottom: 0,
        left: o.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: o.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": wk(n) + "px",
        ...t.style
      },
      onThumbPointerDown: (d) => t.onThumbPointerDown(d.x),
      onDragScroll: (d) => t.onDragScroll(d.x),
      onWheelScroll: (d, u) => {
        if (o.viewport) {
          const f = o.viewport.scrollLeft + d.deltaX;
          t.onWheelScroll(f), zle(f, u) && d.preventDefault();
        }
      },
      onResize: () => {
        c.current && o.viewport && i && r({
          content: o.viewport.scrollWidth,
          viewport: o.viewport.offsetWidth,
          scrollbar: {
            size: c.current.clientWidth,
            paddingStart: cT(i.paddingLeft),
            paddingEnd: cT(i.paddingRight)
          }
        });
      }
    }
  );
}), Iqe = T.forwardRef((t, e) => {
  const { sizes: n, onSizesChange: r, ...s } = t, o = pc(id, t.__scopeScrollArea), [i, a] = T.useState(), c = T.useRef(null), l = vt(e, c, o.onScrollbarYChange);
  return T.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ h.jsx(
    Rle,
    {
      "data-orientation": "vertical",
      ...s,
      ref: l,
      sizes: n,
      style: {
        top: 0,
        right: o.dir === "ltr" ? 0 : void 0,
        left: o.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": wk(n) + "px",
        ...t.style
      },
      onThumbPointerDown: (d) => t.onThumbPointerDown(d.y),
      onDragScroll: (d) => t.onDragScroll(d.y),
      onWheelScroll: (d, u) => {
        if (o.viewport) {
          const f = o.viewport.scrollTop + d.deltaY;
          t.onWheelScroll(f), zle(f, u) && d.preventDefault();
        }
      },
      onResize: () => {
        c.current && o.viewport && i && r({
          content: o.viewport.scrollHeight,
          viewport: o.viewport.offsetHeight,
          scrollbar: {
            size: c.current.clientHeight,
            paddingStart: cT(i.paddingTop),
            paddingEnd: cT(i.paddingBottom)
          }
        });
      }
    }
  );
}), [kqe, jle] = Ale(id), Rle = T.forwardRef((t, e) => {
  const {
    __scopeScrollArea: n,
    sizes: r,
    hasThumb: s,
    onThumbChange: o,
    onThumbPointerUp: i,
    onThumbPointerDown: a,
    onThumbPositionChange: c,
    onDragScroll: l,
    onWheelScroll: d,
    onResize: u,
    ...f
  } = t, p = pc(id, n), [g, y] = T.useState(null), m = vt(e, (M) => y(M)), v = T.useRef(null), b = T.useRef(""), x = p.viewport, w = r.content - r.viewport, S = pr(d), C = pr(c), _ = Sk(u, 10);
  function E(M) {
    if (v.current) {
      const N = M.clientX - v.current.left, O = M.clientY - v.current.top;
      l({ x: N, y: O });
    }
  }
  return T.useEffect(() => {
    const M = (N) => {
      const O = N.target;
      (g == null ? void 0 : g.contains(O)) && S(N, w);
    };
    return document.addEventListener("wheel", M, { passive: !1 }), () => document.removeEventListener("wheel", M, { passive: !1 });
  }, [x, g, w, S]), T.useEffect(C, [r, C]), gy(g, _), gy(p.content, _), /* @__PURE__ */ h.jsx(
    kqe,
    {
      scope: n,
      scrollbar: g,
      hasThumb: s,
      onThumbChange: pr(o),
      onThumbPointerUp: pr(i),
      onThumbPositionChange: C,
      onThumbPointerDown: pr(a),
      children: /* @__PURE__ */ h.jsx(
        Re.div,
        {
          ...f,
          ref: m,
          style: { position: "absolute", ...f.style },
          onPointerDown: Te(t.onPointerDown, (M) => {
            M.button === 0 && (M.target.setPointerCapture(M.pointerId), v.current = g.getBoundingClientRect(), b.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", p.viewport && (p.viewport.style.scrollBehavior = "auto"), E(M));
          }),
          onPointerMove: Te(t.onPointerMove, E),
          onPointerUp: Te(t.onPointerUp, (M) => {
            const N = M.target;
            N.hasPointerCapture(M.pointerId) && N.releasePointerCapture(M.pointerId), document.body.style.webkitUserSelect = b.current, p.viewport && (p.viewport.style.scrollBehavior = ""), v.current = null;
          })
        }
      )
    }
  );
}), aT = "ScrollAreaThumb", $le = T.forwardRef(
  (t, e) => {
    const { forceMount: n, ...r } = t, s = jle(aT, t.__scopeScrollArea);
    return /* @__PURE__ */ h.jsx(Fs, { present: n || s.hasThumb, children: /* @__PURE__ */ h.jsx(Aqe, { ref: e, ...r }) });
  }
), Aqe = T.forwardRef(
  (t, e) => {
    const { __scopeScrollArea: n, style: r, ...s } = t, o = pc(aT, n), i = jle(aT, n), { onThumbPositionChange: a } = i, c = vt(
      e,
      (u) => i.onThumbChange(u)
    ), l = T.useRef(void 0), d = Sk(() => {
      l.current && (l.current(), l.current = void 0);
    }, 100);
    return T.useEffect(() => {
      const u = o.viewport;
      if (u) {
        const f = () => {
          if (d(), !l.current) {
            const p = Dqe(u, a);
            l.current = p, a();
          }
        };
        return a(), u.addEventListener("scroll", f), () => u.removeEventListener("scroll", f);
      }
    }, [o.viewport, d, a]), /* @__PURE__ */ h.jsx(
      Re.div,
      {
        "data-state": i.hasThumb ? "visible" : "hidden",
        ...s,
        ref: c,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...r
        },
        onPointerDownCapture: Te(t.onPointerDownCapture, (u) => {
          const p = u.target.getBoundingClientRect(), g = u.clientX - p.left, y = u.clientY - p.top;
          i.onThumbPointerDown({ x: g, y });
        }),
        onPointerUp: Te(t.onPointerUp, i.onThumbPointerUp)
      }
    );
  }
);
$le.displayName = aT;
var E5 = "ScrollAreaCorner", Lle = T.forwardRef(
  (t, e) => {
    const n = pc(E5, t.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && r ? /* @__PURE__ */ h.jsx(Mqe, { ...t, ref: e }) : null;
  }
);
Lle.displayName = E5;
var Mqe = T.forwardRef((t, e) => {
  const { __scopeScrollArea: n, ...r } = t, s = pc(E5, n), [o, i] = T.useState(0), [a, c] = T.useState(0), l = !!(o && a);
  return gy(s.scrollbarX, () => {
    var u;
    const d = ((u = s.scrollbarX) == null ? void 0 : u.offsetHeight) || 0;
    s.onCornerHeightChange(d), c(d);
  }), gy(s.scrollbarY, () => {
    var u;
    const d = ((u = s.scrollbarY) == null ? void 0 : u.offsetWidth) || 0;
    s.onCornerWidthChange(d), i(d);
  }), l ? /* @__PURE__ */ h.jsx(
    Re.div,
    {
      ...r,
      ref: e,
      style: {
        width: o,
        height: a,
        position: "absolute",
        right: s.dir === "ltr" ? 0 : void 0,
        left: s.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...t.style
      }
    }
  ) : null;
});
function cT(t) {
  return t ? parseInt(t, 10) : 0;
}
function Fle(t, e) {
  const n = t / e;
  return isNaN(n) ? 0 : n;
}
function wk(t) {
  const e = Fle(t.viewport, t.content), n = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, r = (t.scrollbar.size - n) * e;
  return Math.max(r, 18);
}
function Oqe(t, e, n, r = "ltr") {
  const s = wk(n), o = s / 2, i = e || o, a = s - i, c = n.scrollbar.paddingStart + i, l = n.scrollbar.size - n.scrollbar.paddingEnd - a, d = n.content - n.viewport, u = r === "ltr" ? [0, d] : [d * -1, 0];
  return Ble([c, l], u)(t);
}
function cV(t, e, n = "ltr") {
  const r = wk(e), s = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, o = e.scrollbar.size - s, i = e.content - e.viewport, a = o - r, c = n === "ltr" ? [0, i] : [i * -1, 0], l = _w(t, c);
  return Ble([0, i], [0, a])(l);
}
function Ble(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1]) return e[0];
    const r = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + r * (n - t[0]);
  };
}
function zle(t, e) {
  return t > 0 && t < e;
}
var Dqe = (t, e = () => {
}) => {
  let n = { left: t.scrollLeft, top: t.scrollTop }, r = 0;
  return function s() {
    const o = { left: t.scrollLeft, top: t.scrollTop }, i = n.left !== o.left, a = n.top !== o.top;
    (i || a) && e(), n = o, r = window.requestAnimationFrame(s);
  }(), () => window.cancelAnimationFrame(r);
};
function Sk(t, e) {
  const n = pr(t), r = T.useRef(0);
  return T.useEffect(() => () => window.clearTimeout(r.current), []), T.useCallback(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, e);
  }, [n, e]);
}
function gy(t, e) {
  const n = pr(e);
  vs(() => {
    let r = 0;
    if (t) {
      const s = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return s.observe(t), () => {
        window.cancelAnimationFrame(r), s.unobserve(t);
      };
    }
  }, [t, n]);
}
var Ule = Mle, Nqe = Dle, jqe = Lle, Rqe = [" ", "Enter", "ArrowUp", "ArrowDown"], $qe = [" ", "Enter"], Rp = "Select", [Ck, _k, Lqe] = w0(Rp), [pv, J3t] = bs(Rp, [
  Lqe,
  Kf
]), Ek = Kf(), [Fqe, ah] = pv(Rp), [Bqe, zqe] = pv(Rp), Hle = (t) => {
  const {
    __scopeSelect: e,
    children: n,
    open: r,
    defaultOpen: s,
    onOpenChange: o,
    value: i,
    defaultValue: a,
    onValueChange: c,
    dir: l,
    name: d,
    autoComplete: u,
    disabled: f,
    required: p,
    form: g
  } = t, y = Ek(e), [m, v] = T.useState(null), [b, x] = T.useState(null), [w, S] = T.useState(!1), C = vg(l), [_, E] = io({
    prop: r,
    defaultProp: s ?? !1,
    onChange: o,
    caller: Rp
  }), [M, N] = io({
    prop: i,
    defaultProp: a,
    onChange: c,
    caller: Rp
  }), O = T.useRef(null), D = m ? g || !!m.closest("form") : !0, [k, A] = T.useState(/* @__PURE__ */ new Set()), R = Array.from(k).map((j) => j.props.value).join(";");
  return /* @__PURE__ */ h.jsx(P0, { ...y, children: /* @__PURE__ */ h.jsxs(
    Fqe,
    {
      required: p,
      scope: e,
      trigger: m,
      onTriggerChange: v,
      valueNode: b,
      onValueNodeChange: x,
      valueNodeHasChildren: w,
      onValueNodeHasChildrenChange: S,
      contentId: as(),
      value: M,
      onValueChange: N,
      open: _,
      onOpenChange: E,
      dir: C,
      triggerPointerDownPosRef: O,
      disabled: f,
      children: [
        /* @__PURE__ */ h.jsx(Ck.Provider, { scope: e, children: /* @__PURE__ */ h.jsx(
          Bqe,
          {
            scope: t.__scopeSelect,
            onNativeOptionAdd: T.useCallback((j) => {
              A(($) => new Set($).add(j));
            }, []),
            onNativeOptionRemove: T.useCallback((j) => {
              A(($) => {
                const F = new Set($);
                return F.delete(j), F;
              });
            }, []),
            children: n
          }
        ) }),
        D ? /* @__PURE__ */ h.jsxs(
          hde,
          {
            "aria-hidden": !0,
            required: p,
            tabIndex: -1,
            name: d,
            autoComplete: u,
            value: M,
            onChange: (j) => N(j.target.value),
            disabled: f,
            form: g,
            children: [
              M === void 0 ? /* @__PURE__ */ h.jsx("option", { value: "" }) : null,
              Array.from(k)
            ]
          },
          R
        ) : null
      ]
    }
  ) });
};
Hle.displayName = Rp;
var Vle = "SelectTrigger", Wle = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, disabled: r = !1, ...s } = t, o = Ek(n), i = ah(Vle, n), a = i.disabled || r, c = vt(e, i.onTriggerChange), l = _k(n), d = T.useRef("touch"), [u, f, p] = gde((y) => {
      const m = l().filter((x) => !x.disabled), v = m.find((x) => x.value === i.value), b = mde(m, y, v);
      b !== void 0 && i.onValueChange(b.value);
    }), g = (y) => {
      a || (i.onOpenChange(!0), p()), y && (i.triggerPointerDownPosRef.current = {
        x: Math.round(y.pageX),
        y: Math.round(y.pageY)
      });
    };
    return /* @__PURE__ */ h.jsx(I0, { asChild: !0, ...o, children: /* @__PURE__ */ h.jsx(
      Re.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": i.contentId,
        "aria-expanded": i.open,
        "aria-required": i.required,
        "aria-autocomplete": "none",
        dir: i.dir,
        "data-state": i.open ? "open" : "closed",
        disabled: a,
        "data-disabled": a ? "" : void 0,
        "data-placeholder": pde(i.value) ? "" : void 0,
        ...s,
        ref: c,
        onClick: Te(s.onClick, (y) => {
          y.currentTarget.focus(), d.current !== "mouse" && g(y);
        }),
        onPointerDown: Te(s.onPointerDown, (y) => {
          d.current = y.pointerType;
          const m = y.target;
          m.hasPointerCapture(y.pointerId) && m.releasePointerCapture(y.pointerId), y.button === 0 && y.ctrlKey === !1 && y.pointerType === "mouse" && (g(y), y.preventDefault());
        }),
        onKeyDown: Te(s.onKeyDown, (y) => {
          const m = u.current !== "";
          !(y.ctrlKey || y.altKey || y.metaKey) && y.key.length === 1 && f(y.key), !(m && y.key === " ") && Rqe.includes(y.key) && (g(), y.preventDefault());
        })
      }
    ) });
  }
);
Wle.displayName = Vle;
var Kle = "SelectValue", Gle = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, className: r, style: s, children: o, placeholder: i = "", ...a } = t, c = ah(Kle, n), { onValueNodeHasChildrenChange: l } = c, d = o !== void 0, u = vt(e, c.onValueNodeChange);
    return vs(() => {
      l(d);
    }, [l, d]), /* @__PURE__ */ h.jsx(
      Re.span,
      {
        ...a,
        ref: u,
        style: { pointerEvents: "none" },
        children: pde(c.value) ? /* @__PURE__ */ h.jsx(h.Fragment, { children: i }) : o
      }
    );
  }
);
Gle.displayName = Kle;
var Uqe = "SelectIcon", Yle = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, children: r, ...s } = t;
    return /* @__PURE__ */ h.jsx(Re.span, { "aria-hidden": !0, ...s, ref: e, children: r || "" });
  }
);
Yle.displayName = Uqe;
var Hqe = "SelectPortal", qle = (t) => /* @__PURE__ */ h.jsx(Uy, { asChild: !0, ...t });
qle.displayName = Hqe;
var $p = "SelectContent", Xle = T.forwardRef(
  (t, e) => {
    const n = ah($p, t.__scopeSelect), [r, s] = T.useState();
    if (vs(() => {
      s(new DocumentFragment());
    }, []), !n.open) {
      const o = r;
      return o ? b0.createPortal(
        /* @__PURE__ */ h.jsx(Zle, { scope: t.__scopeSelect, children: /* @__PURE__ */ h.jsx(Ck.Slot, { scope: t.__scopeSelect, children: /* @__PURE__ */ h.jsx("div", { children: t.children }) }) }),
        o
      ) : null;
    }
    return /* @__PURE__ */ h.jsx(Qle, { ...t, ref: e });
  }
);
Xle.displayName = $p;
var Pc = 10, [Zle, ch] = pv($p), Vqe = "SelectContentImpl", Wqe = /* @__PURE__ */ kf("SelectContent.RemoveScroll"), Qle = T.forwardRef(
  (t, e) => {
    const {
      __scopeSelect: n,
      position: r = "item-aligned",
      onCloseAutoFocus: s,
      onEscapeKeyDown: o,
      onPointerDownOutside: i,
      //
      // PopperContent props
      side: a,
      sideOffset: c,
      align: l,
      alignOffset: d,
      arrowPadding: u,
      collisionBoundary: f,
      collisionPadding: p,
      sticky: g,
      hideWhenDetached: y,
      avoidCollisions: m,
      //
      ...v
    } = t, b = ah($p, n), [x, w] = T.useState(null), [S, C] = T.useState(null), _ = vt(e, (Y) => w(Y)), [E, M] = T.useState(null), [N, O] = T.useState(
      null
    ), D = _k(n), [k, A] = T.useState(!1), R = T.useRef(!1);
    T.useEffect(() => {
      if (x) return JP(x);
    }, [x]), ZP();
    const j = T.useCallback(
      (Y) => {
        const [ee, ...ae] = D().map((G) => G.ref.current), [de] = ae.slice(-1), ye = document.activeElement;
        for (const G of Y)
          if (G === ye || (G == null || G.scrollIntoView({ block: "nearest" }), G === ee && S && (S.scrollTop = 0), G === de && S && (S.scrollTop = S.scrollHeight), G == null || G.focus(), document.activeElement !== ye)) return;
      },
      [D, S]
    ), $ = T.useCallback(
      () => j([E, x]),
      [j, E, x]
    );
    T.useEffect(() => {
      k && $();
    }, [k, $]);
    const { onOpenChange: F, triggerPointerDownPosRef: L } = b;
    T.useEffect(() => {
      if (x) {
        let Y = { x: 0, y: 0 };
        const ee = (de) => {
          var ye, G;
          Y = {
            x: Math.abs(Math.round(de.pageX) - (((ye = L.current) == null ? void 0 : ye.x) ?? 0)),
            y: Math.abs(Math.round(de.pageY) - (((G = L.current) == null ? void 0 : G.y) ?? 0))
          };
        }, ae = (de) => {
          Y.x <= 10 && Y.y <= 10 ? de.preventDefault() : x.contains(de.target) || F(!1), document.removeEventListener("pointermove", ee), L.current = null;
        };
        return L.current !== null && (document.addEventListener("pointermove", ee), document.addEventListener("pointerup", ae, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", ee), document.removeEventListener("pointerup", ae, { capture: !0 });
        };
      }
    }, [x, F, L]), T.useEffect(() => {
      const Y = () => F(!1);
      return window.addEventListener("blur", Y), window.addEventListener("resize", Y), () => {
        window.removeEventListener("blur", Y), window.removeEventListener("resize", Y);
      };
    }, [F]);
    const [z, H] = gde((Y) => {
      const ee = D().filter((ye) => !ye.disabled), ae = ee.find((ye) => ye.ref.current === document.activeElement), de = mde(ee, Y, ae);
      de && setTimeout(() => de.ref.current.focus());
    }), U = T.useCallback(
      (Y, ee, ae) => {
        const de = !R.current && !ae;
        (b.value !== void 0 && b.value === ee || de) && (M(Y), de && (R.current = !0));
      },
      [b.value]
    ), W = T.useCallback(() => x == null ? void 0 : x.focus(), [x]), Z = T.useCallback(
      (Y, ee, ae) => {
        const de = !R.current && !ae;
        (b.value !== void 0 && b.value === ee || de) && O(Y);
      },
      [b.value]
    ), K = r === "popper" ? qj : Jle, oe = K === qj ? {
      side: a,
      sideOffset: c,
      align: l,
      alignOffset: d,
      arrowPadding: u,
      collisionBoundary: f,
      collisionPadding: p,
      sticky: g,
      hideWhenDetached: y,
      avoidCollisions: m
    } : {};
    return /* @__PURE__ */ h.jsx(
      Zle,
      {
        scope: n,
        content: x,
        viewport: S,
        onViewportChange: C,
        itemRefCallback: U,
        selectedItem: E,
        onItemLeave: W,
        itemTextRefCallback: Z,
        focusSelectedItem: $,
        selectedItemText: N,
        position: r,
        isPositioned: k,
        searchRef: z,
        children: /* @__PURE__ */ h.jsx(A0, { as: Wqe, allowPinchZoom: !0, children: /* @__PURE__ */ h.jsx(
          k0,
          {
            asChild: !0,
            trapped: b.open,
            onMountAutoFocus: (Y) => {
              Y.preventDefault();
            },
            onUnmountAutoFocus: Te(s, (Y) => {
              var ee;
              (ee = b.trigger) == null || ee.focus({ preventScroll: !0 }), Y.preventDefault();
            }),
            children: /* @__PURE__ */ h.jsx(
              ng,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: o,
                onPointerDownOutside: i,
                onFocusOutside: (Y) => Y.preventDefault(),
                onDismiss: () => b.onOpenChange(!1),
                children: /* @__PURE__ */ h.jsx(
                  K,
                  {
                    role: "listbox",
                    id: b.contentId,
                    "data-state": b.open ? "open" : "closed",
                    dir: b.dir,
                    onContextMenu: (Y) => Y.preventDefault(),
                    ...v,
                    ...oe,
                    onPlaced: () => A(!0),
                    ref: _,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...v.style
                    },
                    onKeyDown: Te(v.onKeyDown, (Y) => {
                      const ee = Y.ctrlKey || Y.altKey || Y.metaKey;
                      if (Y.key === "Tab" && Y.preventDefault(), !ee && Y.key.length === 1 && H(Y.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(Y.key)) {
                        let de = D().filter((ye) => !ye.disabled).map((ye) => ye.ref.current);
                        if (["ArrowUp", "End"].includes(Y.key) && (de = de.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(Y.key)) {
                          const ye = Y.target, G = de.indexOf(ye);
                          de = de.slice(G + 1);
                        }
                        setTimeout(() => j(de)), Y.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
Qle.displayName = Vqe;
var Kqe = "SelectItemAlignedPosition", Jle = T.forwardRef((t, e) => {
  const { __scopeSelect: n, onPlaced: r, ...s } = t, o = ah($p, n), i = ch($p, n), [a, c] = T.useState(null), [l, d] = T.useState(null), u = vt(e, (_) => d(_)), f = _k(n), p = T.useRef(!1), g = T.useRef(!0), { viewport: y, selectedItem: m, selectedItemText: v, focusSelectedItem: b } = i, x = T.useCallback(() => {
    if (o.trigger && o.valueNode && a && l && y && m && v) {
      const _ = o.trigger.getBoundingClientRect(), E = l.getBoundingClientRect(), M = o.valueNode.getBoundingClientRect(), N = v.getBoundingClientRect();
      if (o.dir !== "rtl") {
        const ye = N.left - E.left, G = M.left - ye, xe = _.left - G, ge = _.width + xe, ze = Math.max(ge, E.width), Ge = window.innerWidth - Pc, Ct = _w(G, [
          Pc,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(Pc, Ge - ze)
        ]);
        a.style.minWidth = ge + "px", a.style.left = Ct + "px";
      } else {
        const ye = E.right - N.right, G = window.innerWidth - M.right - ye, xe = window.innerWidth - _.right - G, ge = _.width + xe, ze = Math.max(ge, E.width), Ge = window.innerWidth - Pc, Ct = _w(G, [
          Pc,
          Math.max(Pc, Ge - ze)
        ]);
        a.style.minWidth = ge + "px", a.style.right = Ct + "px";
      }
      const O = f(), D = window.innerHeight - Pc * 2, k = y.scrollHeight, A = window.getComputedStyle(l), R = parseInt(A.borderTopWidth, 10), j = parseInt(A.paddingTop, 10), $ = parseInt(A.borderBottomWidth, 10), F = parseInt(A.paddingBottom, 10), L = R + j + k + F + $, z = Math.min(m.offsetHeight * 5, L), H = window.getComputedStyle(y), U = parseInt(H.paddingTop, 10), W = parseInt(H.paddingBottom, 10), Z = _.top + _.height / 2 - Pc, K = D - Z, oe = m.offsetHeight / 2, Y = m.offsetTop + oe, ee = R + j + Y, ae = L - ee;
      if (ee <= Z) {
        const ye = O.length > 0 && m === O[O.length - 1].ref.current;
        a.style.bottom = "0px";
        const G = l.clientHeight - y.offsetTop - y.offsetHeight, xe = Math.max(
          K,
          oe + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (ye ? W : 0) + G + $
        ), ge = ee + xe;
        a.style.height = ge + "px";
      } else {
        const ye = O.length > 0 && m === O[0].ref.current;
        a.style.top = "0px";
        const xe = Math.max(
          Z,
          R + y.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (ye ? U : 0) + oe
        ) + ae;
        a.style.height = xe + "px", y.scrollTop = ee - Z + y.offsetTop;
      }
      a.style.margin = `${Pc}px 0`, a.style.minHeight = z + "px", a.style.maxHeight = D + "px", r == null || r(), requestAnimationFrame(() => p.current = !0);
    }
  }, [
    f,
    o.trigger,
    o.valueNode,
    a,
    l,
    y,
    m,
    v,
    o.dir,
    r
  ]);
  vs(() => x(), [x]);
  const [w, S] = T.useState();
  vs(() => {
    l && S(window.getComputedStyle(l).zIndex);
  }, [l]);
  const C = T.useCallback(
    (_) => {
      _ && g.current === !0 && (x(), b == null || b(), g.current = !1);
    },
    [x, b]
  );
  return /* @__PURE__ */ h.jsx(
    Yqe,
    {
      scope: n,
      contentWrapper: a,
      shouldExpandOnScrollRef: p,
      onScrollButtonChange: C,
      children: /* @__PURE__ */ h.jsx(
        "div",
        {
          ref: c,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: w
          },
          children: /* @__PURE__ */ h.jsx(
            Re.div,
            {
              ...s,
              ref: u,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...s.style
              }
            }
          )
        }
      )
    }
  );
});
Jle.displayName = Kqe;
var Gqe = "SelectPopperPosition", qj = T.forwardRef((t, e) => {
  const {
    __scopeSelect: n,
    align: r = "start",
    collisionPadding: s = Pc,
    ...o
  } = t, i = Ek(n);
  return /* @__PURE__ */ h.jsx(
    KP,
    {
      ...i,
      ...o,
      ref: e,
      align: r,
      collisionPadding: s,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...o.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
qj.displayName = Gqe;
var [Yqe, T5] = pv($p, {}), Xj = "SelectViewport", ede = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, nonce: r, ...s } = t, o = ch(Xj, n), i = T5(Xj, n), a = vt(e, o.onViewportChange), c = T.useRef(0);
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: r
        }
      ),
      /* @__PURE__ */ h.jsx(Ck.Slot, { scope: n, children: /* @__PURE__ */ h.jsx(
        Re.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...s,
          ref: a,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...s.style
          },
          onScroll: Te(s.onScroll, (l) => {
            const d = l.currentTarget, { contentWrapper: u, shouldExpandOnScrollRef: f } = i;
            if (f != null && f.current && u) {
              const p = Math.abs(c.current - d.scrollTop);
              if (p > 0) {
                const g = window.innerHeight - Pc * 2, y = parseFloat(u.style.minHeight), m = parseFloat(u.style.height), v = Math.max(y, m);
                if (v < g) {
                  const b = v + p, x = Math.min(g, b), w = b - x;
                  u.style.height = x + "px", u.style.bottom === "0px" && (d.scrollTop = w > 0 ? w : 0, u.style.justifyContent = "flex-end");
                }
              }
            }
            c.current = d.scrollTop;
          })
        }
      ) })
    ] });
  }
);
ede.displayName = Xj;
var tde = "SelectGroup", [qqe, Xqe] = pv(tde), Zqe = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, s = as();
    return /* @__PURE__ */ h.jsx(qqe, { scope: n, id: s, children: /* @__PURE__ */ h.jsx(Re.div, { role: "group", "aria-labelledby": s, ...r, ref: e }) });
  }
);
Zqe.displayName = tde;
var nde = "SelectLabel", rde = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, s = Xqe(nde, n);
    return /* @__PURE__ */ h.jsx(Re.div, { id: s.id, ...r, ref: e });
  }
);
rde.displayName = nde;
var lT = "SelectItem", [Qqe, sde] = pv(lT), ode = T.forwardRef(
  (t, e) => {
    const {
      __scopeSelect: n,
      value: r,
      disabled: s = !1,
      textValue: o,
      ...i
    } = t, a = ah(lT, n), c = ch(lT, n), l = a.value === r, [d, u] = T.useState(o ?? ""), [f, p] = T.useState(!1), g = vt(
      e,
      (b) => {
        var x;
        return (x = c.itemRefCallback) == null ? void 0 : x.call(c, b, r, s);
      }
    ), y = as(), m = T.useRef("touch"), v = () => {
      s || (a.onValueChange(r), a.onOpenChange(!1));
    };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ h.jsx(
      Qqe,
      {
        scope: n,
        value: r,
        disabled: s,
        textId: y,
        isSelected: l,
        onItemTextChange: T.useCallback((b) => {
          u((x) => x || ((b == null ? void 0 : b.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ h.jsx(
          Ck.ItemSlot,
          {
            scope: n,
            value: r,
            disabled: s,
            textValue: d,
            children: /* @__PURE__ */ h.jsx(
              Re.div,
              {
                role: "option",
                "aria-labelledby": y,
                "data-highlighted": f ? "" : void 0,
                "aria-selected": l && f,
                "data-state": l ? "checked" : "unchecked",
                "aria-disabled": s || void 0,
                "data-disabled": s ? "" : void 0,
                tabIndex: s ? void 0 : -1,
                ...i,
                ref: g,
                onFocus: Te(i.onFocus, () => p(!0)),
                onBlur: Te(i.onBlur, () => p(!1)),
                onClick: Te(i.onClick, () => {
                  m.current !== "mouse" && v();
                }),
                onPointerUp: Te(i.onPointerUp, () => {
                  m.current === "mouse" && v();
                }),
                onPointerDown: Te(i.onPointerDown, (b) => {
                  m.current = b.pointerType;
                }),
                onPointerMove: Te(i.onPointerMove, (b) => {
                  var x;
                  m.current = b.pointerType, s ? (x = c.onItemLeave) == null || x.call(c) : m.current === "mouse" && b.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: Te(i.onPointerLeave, (b) => {
                  var x;
                  b.currentTarget === document.activeElement && ((x = c.onItemLeave) == null || x.call(c));
                }),
                onKeyDown: Te(i.onKeyDown, (b) => {
                  var w;
                  ((w = c.searchRef) == null ? void 0 : w.current) !== "" && b.key === " " || ($qe.includes(b.key) && v(), b.key === " " && b.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
ode.displayName = lT;
var Hb = "SelectItemText", ide = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, className: r, style: s, ...o } = t, i = ah(Hb, n), a = ch(Hb, n), c = sde(Hb, n), l = zqe(Hb, n), [d, u] = T.useState(null), f = vt(
      e,
      (v) => u(v),
      c.onItemTextChange,
      (v) => {
        var b;
        return (b = a.itemTextRefCallback) == null ? void 0 : b.call(a, v, c.value, c.disabled);
      }
    ), p = d == null ? void 0 : d.textContent, g = T.useMemo(
      () => /* @__PURE__ */ h.jsx("option", { value: c.value, disabled: c.disabled, children: p }, c.value),
      [c.disabled, c.value, p]
    ), { onNativeOptionAdd: y, onNativeOptionRemove: m } = l;
    return vs(() => (y(g), () => m(g)), [y, m, g]), /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(Re.span, { id: c.textId, ...o, ref: f }),
      c.isSelected && i.valueNode && !i.valueNodeHasChildren ? b0.createPortal(o.children, i.valueNode) : null
    ] });
  }
);
ide.displayName = Hb;
var ade = "SelectItemIndicator", cde = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t;
    return sde(ade, n).isSelected ? /* @__PURE__ */ h.jsx(Re.span, { "aria-hidden": !0, ...r, ref: e }) : null;
  }
);
cde.displayName = ade;
var Zj = "SelectScrollUpButton", lde = T.forwardRef((t, e) => {
  const n = ch(Zj, t.__scopeSelect), r = T5(Zj, t.__scopeSelect), [s, o] = T.useState(!1), i = vt(e, r.onScrollButtonChange);
  return vs(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const l = c.scrollTop > 0;
        o(l);
      };
      const c = n.viewport;
      return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), s ? /* @__PURE__ */ h.jsx(
    ude,
    {
      ...t,
      ref: i,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: c } = n;
        a && c && (a.scrollTop = a.scrollTop - c.offsetHeight);
      }
    }
  ) : null;
});
lde.displayName = Zj;
var Qj = "SelectScrollDownButton", dde = T.forwardRef((t, e) => {
  const n = ch(Qj, t.__scopeSelect), r = T5(Qj, t.__scopeSelect), [s, o] = T.useState(!1), i = vt(e, r.onScrollButtonChange);
  return vs(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const l = c.scrollHeight - c.clientHeight, d = Math.ceil(c.scrollTop) < l;
        o(d);
      };
      const c = n.viewport;
      return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), s ? /* @__PURE__ */ h.jsx(
    ude,
    {
      ...t,
      ref: i,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: c } = n;
        a && c && (a.scrollTop = a.scrollTop + c.offsetHeight);
      }
    }
  ) : null;
});
dde.displayName = Qj;
var ude = T.forwardRef((t, e) => {
  const { __scopeSelect: n, onAutoScroll: r, ...s } = t, o = ch("SelectScrollButton", n), i = T.useRef(null), a = _k(n), c = T.useCallback(() => {
    i.current !== null && (window.clearInterval(i.current), i.current = null);
  }, []);
  return T.useEffect(() => () => c(), [c]), vs(() => {
    var d;
    const l = a().find((u) => u.ref.current === document.activeElement);
    (d = l == null ? void 0 : l.ref.current) == null || d.scrollIntoView({ block: "nearest" });
  }, [a]), /* @__PURE__ */ h.jsx(
    Re.div,
    {
      "aria-hidden": !0,
      ...s,
      ref: e,
      style: { flexShrink: 0, ...s.style },
      onPointerDown: Te(s.onPointerDown, () => {
        i.current === null && (i.current = window.setInterval(r, 50));
      }),
      onPointerMove: Te(s.onPointerMove, () => {
        var l;
        (l = o.onItemLeave) == null || l.call(o), i.current === null && (i.current = window.setInterval(r, 50));
      }),
      onPointerLeave: Te(s.onPointerLeave, () => {
        c();
      })
    }
  );
}), Jqe = "SelectSeparator", fde = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t;
    return /* @__PURE__ */ h.jsx(Re.div, { "aria-hidden": !0, ...r, ref: e });
  }
);
fde.displayName = Jqe;
var Jj = "SelectArrow", eXe = T.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, s = Ek(n), o = ah(Jj, n), i = ch(Jj, n);
    return o.open && i.position === "popper" ? /* @__PURE__ */ h.jsx(GP, { ...s, ...r, ref: e }) : null;
  }
);
eXe.displayName = Jj;
var tXe = "SelectBubbleInput", hde = T.forwardRef(
  ({ __scopeSelect: t, value: e, ...n }, r) => {
    const s = T.useRef(null), o = vt(r, s), i = pk(e);
    return T.useEffect(() => {
      const a = s.current;
      if (!a) return;
      const c = window.HTMLSelectElement.prototype, d = Object.getOwnPropertyDescriptor(
        c,
        "value"
      ).set;
      if (i !== e && d) {
        const u = new Event("change", { bubbles: !0 });
        d.call(a, e), a.dispatchEvent(u);
      }
    }, [i, e]), /* @__PURE__ */ h.jsx(
      Re.select,
      {
        ...n,
        style: { ...bq, ...n.style },
        ref: o,
        defaultValue: e
      }
    );
  }
);
hde.displayName = tXe;
function pde(t) {
  return t === "" || t === void 0;
}
function gde(t) {
  const e = pr(t), n = T.useRef(""), r = T.useRef(0), s = T.useCallback(
    (i) => {
      const a = n.current + i;
      e(a), function c(l) {
        n.current = l, window.clearTimeout(r.current), l !== "" && (r.current = window.setTimeout(() => c(""), 1e3));
      }(a);
    },
    [e]
  ), o = T.useCallback(() => {
    n.current = "", window.clearTimeout(r.current);
  }, []);
  return T.useEffect(() => () => window.clearTimeout(r.current), []), [n, s, o];
}
function mde(t, e, n) {
  const s = e.length > 1 && Array.from(e).every((l) => l === e[0]) ? e[0] : e, o = n ? t.indexOf(n) : -1;
  let i = nXe(t, Math.max(o, 0));
  s.length === 1 && (i = i.filter((l) => l !== n));
  const c = i.find(
    (l) => l.textValue.toLowerCase().startsWith(s.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function nXe(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var rXe = Hle, yde = Wle, sXe = Gle, oXe = Yle, iXe = qle, vde = Xle, aXe = ede, bde = rde, xde = ode, cXe = ide, lXe = cde, wde = lde, Sde = dde, Cde = fde, _de = ["PageUp", "PageDown"], Ede = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], Tde = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, gv = "Slider", [eR, dXe, uXe] = w0(gv), [Pde, e5t] = bs(gv, [
  uXe
]), [fXe, Tk] = Pde(gv), Ide = T.forwardRef(
  (t, e) => {
    const {
      name: n,
      min: r = 0,
      max: s = 100,
      step: o = 1,
      orientation: i = "horizontal",
      disabled: a = !1,
      minStepsBetweenThumbs: c = 0,
      defaultValue: l = [r],
      value: d,
      onValueChange: u = () => {
      },
      onValueCommit: f = () => {
      },
      inverted: p = !1,
      form: g,
      ...y
    } = t, m = T.useRef(/* @__PURE__ */ new Set()), v = T.useRef(0), x = i === "horizontal" ? hXe : pXe, [w = [], S] = io({
      prop: d,
      defaultProp: l,
      onChange: (O) => {
        var k;
        (k = [...m.current][v.current]) == null || k.focus(), u(O);
      }
    }), C = T.useRef(w);
    function _(O) {
      const D = bXe(w, O);
      N(O, D);
    }
    function E(O) {
      N(O, v.current);
    }
    function M() {
      const O = C.current[v.current];
      w[v.current] !== O && f(w);
    }
    function N(O, D, { commit: k } = { commit: !1 }) {
      const A = CXe(o), R = _Xe(Math.round((O - r) / o) * o + r, A), j = _w(R, [r, s]);
      S(($ = []) => {
        const F = yXe($, j, D);
        if (SXe(F, c * o)) {
          v.current = F.indexOf(j);
          const L = String(F) !== String($);
          return L && k && f(F), L ? F : $;
        } else
          return $;
      });
    }
    return /* @__PURE__ */ h.jsx(
      fXe,
      {
        scope: t.__scopeSlider,
        name: n,
        disabled: a,
        min: r,
        max: s,
        valueIndexToChangeRef: v,
        thumbs: m.current,
        values: w,
        orientation: i,
        form: g,
        children: /* @__PURE__ */ h.jsx(eR.Provider, { scope: t.__scopeSlider, children: /* @__PURE__ */ h.jsx(eR.Slot, { scope: t.__scopeSlider, children: /* @__PURE__ */ h.jsx(
          x,
          {
            "aria-disabled": a,
            "data-disabled": a ? "" : void 0,
            ...y,
            ref: e,
            onPointerDown: Te(y.onPointerDown, () => {
              a || (C.current = w);
            }),
            min: r,
            max: s,
            inverted: p,
            onSlideStart: a ? void 0 : _,
            onSlideMove: a ? void 0 : E,
            onSlideEnd: a ? void 0 : M,
            onHomeKeyDown: () => !a && N(r, 0, { commit: !0 }),
            onEndKeyDown: () => !a && N(s, w.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: O, direction: D }) => {
              if (!a) {
                const R = _de.includes(O.key) || O.shiftKey && Ede.includes(O.key) ? 10 : 1, j = v.current, $ = w[j], F = o * R * D;
                N($ + F, j, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Ide.displayName = gv;
var [kde, Ade] = Pde(gv, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), hXe = T.forwardRef(
  (t, e) => {
    const {
      min: n,
      max: r,
      dir: s,
      inverted: o,
      onSlideStart: i,
      onSlideMove: a,
      onSlideEnd: c,
      onStepKeyDown: l,
      ...d
    } = t, [u, f] = T.useState(null), p = vt(e, (x) => f(x)), g = T.useRef(void 0), y = vg(s), m = y === "ltr", v = m && !o || !m && o;
    function b(x) {
      const w = g.current || u.getBoundingClientRect(), S = [0, w.width], _ = P5(S, v ? [n, r] : [r, n]);
      return g.current = w, _(x - w.left);
    }
    return /* @__PURE__ */ h.jsx(
      kde,
      {
        scope: t.__scopeSlider,
        startEdge: v ? "left" : "right",
        endEdge: v ? "right" : "left",
        direction: v ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ h.jsx(
          Mde,
          {
            dir: y,
            "data-orientation": "horizontal",
            ...d,
            ref: p,
            style: {
              ...d.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (x) => {
              const w = b(x.clientX);
              i == null || i(w);
            },
            onSlideMove: (x) => {
              const w = b(x.clientX);
              a == null || a(w);
            },
            onSlideEnd: () => {
              g.current = void 0, c == null || c();
            },
            onStepKeyDown: (x) => {
              const S = Tde[v ? "from-left" : "from-right"].includes(x.key);
              l == null || l({ event: x, direction: S ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), pXe = T.forwardRef(
  (t, e) => {
    const {
      min: n,
      max: r,
      inverted: s,
      onSlideStart: o,
      onSlideMove: i,
      onSlideEnd: a,
      onStepKeyDown: c,
      ...l
    } = t, d = T.useRef(null), u = vt(e, d), f = T.useRef(void 0), p = !s;
    function g(y) {
      const m = f.current || d.current.getBoundingClientRect(), v = [0, m.height], x = P5(v, p ? [r, n] : [n, r]);
      return f.current = m, x(y - m.top);
    }
    return /* @__PURE__ */ h.jsx(
      kde,
      {
        scope: t.__scopeSlider,
        startEdge: p ? "bottom" : "top",
        endEdge: p ? "top" : "bottom",
        size: "height",
        direction: p ? 1 : -1,
        children: /* @__PURE__ */ h.jsx(
          Mde,
          {
            "data-orientation": "vertical",
            ...l,
            ref: u,
            style: {
              ...l.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (y) => {
              const m = g(y.clientY);
              o == null || o(m);
            },
            onSlideMove: (y) => {
              const m = g(y.clientY);
              i == null || i(m);
            },
            onSlideEnd: () => {
              f.current = void 0, a == null || a();
            },
            onStepKeyDown: (y) => {
              const v = Tde[p ? "from-bottom" : "from-top"].includes(y.key);
              c == null || c({ event: y, direction: v ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), Mde = T.forwardRef(
  (t, e) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: s,
      onSlideEnd: o,
      onHomeKeyDown: i,
      onEndKeyDown: a,
      onStepKeyDown: c,
      ...l
    } = t, d = Tk(gv, n);
    return /* @__PURE__ */ h.jsx(
      Re.span,
      {
        ...l,
        ref: e,
        onKeyDown: Te(t.onKeyDown, (u) => {
          u.key === "Home" ? (i(u), u.preventDefault()) : u.key === "End" ? (a(u), u.preventDefault()) : _de.concat(Ede).includes(u.key) && (c(u), u.preventDefault());
        }),
        onPointerDown: Te(t.onPointerDown, (u) => {
          const f = u.target;
          f.setPointerCapture(u.pointerId), u.preventDefault(), d.thumbs.has(f) ? f.focus() : r(u);
        }),
        onPointerMove: Te(t.onPointerMove, (u) => {
          u.target.hasPointerCapture(u.pointerId) && s(u);
        }),
        onPointerUp: Te(t.onPointerUp, (u) => {
          const f = u.target;
          f.hasPointerCapture(u.pointerId) && (f.releasePointerCapture(u.pointerId), o(u));
        })
      }
    );
  }
), Ode = "SliderTrack", Dde = T.forwardRef(
  (t, e) => {
    const { __scopeSlider: n, ...r } = t, s = Tk(Ode, n);
    return /* @__PURE__ */ h.jsx(
      Re.span,
      {
        "data-disabled": s.disabled ? "" : void 0,
        "data-orientation": s.orientation,
        ...r,
        ref: e
      }
    );
  }
);
Dde.displayName = Ode;
var tR = "SliderRange", Nde = T.forwardRef(
  (t, e) => {
    const { __scopeSlider: n, ...r } = t, s = Tk(tR, n), o = Ade(tR, n), i = T.useRef(null), a = vt(e, i), c = s.values.length, l = s.values.map(
      (f) => $de(f, s.min, s.max)
    ), d = c > 1 ? Math.min(...l) : 0, u = 100 - Math.max(...l);
    return /* @__PURE__ */ h.jsx(
      Re.span,
      {
        "data-orientation": s.orientation,
        "data-disabled": s.disabled ? "" : void 0,
        ...r,
        ref: a,
        style: {
          ...t.style,
          [o.startEdge]: d + "%",
          [o.endEdge]: u + "%"
        }
      }
    );
  }
);
Nde.displayName = tR;
var nR = "SliderThumb", jde = T.forwardRef(
  (t, e) => {
    const n = dXe(t.__scopeSlider), [r, s] = T.useState(null), o = vt(e, (a) => s(a)), i = T.useMemo(
      () => r ? n().findIndex((a) => a.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ h.jsx(gXe, { ...t, ref: o, index: i });
  }
), gXe = T.forwardRef(
  (t, e) => {
    const { __scopeSlider: n, index: r, name: s, ...o } = t, i = Tk(nR, n), a = Ade(nR, n), [c, l] = T.useState(null), d = vt(e, (b) => l(b)), u = c ? i.form || !!c.closest("form") : !0, f = WP(c), p = i.values[r], g = p === void 0 ? 0 : $de(p, i.min, i.max), y = vXe(r, i.values.length), m = f == null ? void 0 : f[a.size], v = m ? xXe(m, g, a.direction) : 0;
    return T.useEffect(() => {
      if (c)
        return i.thumbs.add(c), () => {
          i.thumbs.delete(c);
        };
    }, [c, i.thumbs]), /* @__PURE__ */ h.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [a.startEdge]: `calc(${g}% + ${v}px)`
        },
        children: [
          /* @__PURE__ */ h.jsx(eR.ItemSlot, { scope: t.__scopeSlider, children: /* @__PURE__ */ h.jsx(
            Re.span,
            {
              role: "slider",
              "aria-label": t["aria-label"] || y,
              "aria-valuemin": i.min,
              "aria-valuenow": p,
              "aria-valuemax": i.max,
              "aria-orientation": i.orientation,
              "data-orientation": i.orientation,
              "data-disabled": i.disabled ? "" : void 0,
              tabIndex: i.disabled ? void 0 : 0,
              ...o,
              ref: d,
              style: p === void 0 ? { display: "none" } : t.style,
              onFocus: Te(t.onFocus, () => {
                i.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          u && /* @__PURE__ */ h.jsx(
            Rde,
            {
              name: s ?? (i.name ? i.name + (i.values.length > 1 ? "[]" : "") : void 0),
              form: i.form,
              value: p
            },
            r
          )
        ]
      }
    );
  }
);
jde.displayName = nR;
var mXe = "RadioBubbleInput", Rde = T.forwardRef(
  ({ __scopeSlider: t, value: e, ...n }, r) => {
    const s = T.useRef(null), o = vt(s, r), i = pk(e);
    return T.useEffect(() => {
      const a = s.current;
      if (!a) return;
      const c = window.HTMLInputElement.prototype, d = Object.getOwnPropertyDescriptor(c, "value").set;
      if (i !== e && d) {
        const u = new Event("input", { bubbles: !0 });
        d.call(a, e), a.dispatchEvent(u);
      }
    }, [i, e]), /* @__PURE__ */ h.jsx(
      Re.input,
      {
        style: { display: "none" },
        ...n,
        ref: o,
        defaultValue: e
      }
    );
  }
);
Rde.displayName = mXe;
function yXe(t = [], e, n) {
  const r = [...t];
  return r[n] = e, r.sort((s, o) => s - o);
}
function $de(t, e, n) {
  const o = 100 / (n - e) * (t - e);
  return _w(o, [0, 100]);
}
function vXe(t, e) {
  return e > 2 ? `Value ${t + 1} of ${e}` : e === 2 ? ["Minimum", "Maximum"][t] : void 0;
}
function bXe(t, e) {
  if (t.length === 1) return 0;
  const n = t.map((s) => Math.abs(s - e)), r = Math.min(...n);
  return n.indexOf(r);
}
function xXe(t, e, n) {
  const r = t / 2, o = P5([0, 50], [0, r]);
  return (r - o(e) * n) * n;
}
function wXe(t) {
  return t.slice(0, -1).map((e, n) => t[n + 1] - e);
}
function SXe(t, e) {
  if (e > 0) {
    const n = wXe(t);
    return Math.min(...n) >= e;
  }
  return !0;
}
function P5(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1]) return e[0];
    const r = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + r * (n - t[0]);
  };
}
function CXe(t) {
  return (String(t).split(".")[1] || "").length;
}
function _Xe(t, e) {
  const n = Math.pow(10, e);
  return Math.round(t * n) / n;
}
var EXe = Ide, TXe = Dde, PXe = Nde, IXe = jde, Pk = "Switch", [kXe, t5t] = bs(Pk), [AXe, MXe] = kXe(Pk), Lde = T.forwardRef(
  (t, e) => {
    const {
      __scopeSwitch: n,
      name: r,
      checked: s,
      defaultChecked: o,
      required: i,
      disabled: a,
      value: c = "on",
      onCheckedChange: l,
      form: d,
      ...u
    } = t, [f, p] = T.useState(null), g = vt(e, (x) => p(x)), y = T.useRef(!1), m = f ? d || !!f.closest("form") : !0, [v, b] = io({
      prop: s,
      defaultProp: o ?? !1,
      onChange: l,
      caller: Pk
    });
    return /* @__PURE__ */ h.jsxs(AXe, { scope: n, checked: v, disabled: a, children: [
      /* @__PURE__ */ h.jsx(
        Re.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": v,
          "aria-required": i,
          "data-state": Ude(v),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: c,
          ...u,
          ref: g,
          onClick: Te(t.onClick, (x) => {
            b((w) => !w), m && (y.current = x.isPropagationStopped(), y.current || x.stopPropagation());
          })
        }
      ),
      m && /* @__PURE__ */ h.jsx(
        zde,
        {
          control: f,
          bubbles: !y.current,
          name: r,
          value: c,
          checked: v,
          required: i,
          disabled: a,
          form: d,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Lde.displayName = Pk;
var Fde = "SwitchThumb", Bde = T.forwardRef(
  (t, e) => {
    const { __scopeSwitch: n, ...r } = t, s = MXe(Fde, n);
    return /* @__PURE__ */ h.jsx(
      Re.span,
      {
        "data-state": Ude(s.checked),
        "data-disabled": s.disabled ? "" : void 0,
        ...r,
        ref: e
      }
    );
  }
);
Bde.displayName = Fde;
var OXe = "SwitchBubbleInput", zde = T.forwardRef(
  ({
    __scopeSwitch: t,
    control: e,
    checked: n,
    bubbles: r = !0,
    ...s
  }, o) => {
    const i = T.useRef(null), a = vt(i, o), c = pk(n), l = WP(e);
    return T.useEffect(() => {
      const d = i.current;
      if (!d) return;
      const u = window.HTMLInputElement.prototype, p = Object.getOwnPropertyDescriptor(
        u,
        "checked"
      ).set;
      if (c !== n && p) {
        const g = new Event("click", { bubbles: r });
        p.call(d, n), d.dispatchEvent(g);
      }
    }, [c, n, r]), /* @__PURE__ */ h.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...s,
        tabIndex: -1,
        ref: a,
        style: {
          ...s.style,
          ...l,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
zde.displayName = OXe;
function Ude(t) {
  return t ? "checked" : "unchecked";
}
var Hde = Lde, DXe = Bde, Vde = "Toggle", Wde = T.forwardRef((t, e) => {
  const { pressed: n, defaultPressed: r, onPressedChange: s, ...o } = t, [i, a] = io({
    prop: n,
    onChange: s,
    defaultProp: r ?? !1,
    caller: Vde
  });
  return /* @__PURE__ */ h.jsx(
    Re.button,
    {
      type: "button",
      "aria-pressed": i,
      "data-state": i ? "on" : "off",
      "data-disabled": t.disabled ? "" : void 0,
      ...o,
      ref: e,
      onClick: Te(t.onClick, () => {
        t.disabled || a(!i);
      })
    }
  );
});
Wde.displayName = Vde;
var lh = "ToggleGroup", [Kde, Gde] = bs(lh, [
  hv
]), Yde = hv(), I5 = B.forwardRef((t, e) => {
  const { type: n, ...r } = t;
  if (n === "single") {
    const s = r;
    return /* @__PURE__ */ h.jsx(NXe, { ...s, ref: e });
  }
  if (n === "multiple") {
    const s = r;
    return /* @__PURE__ */ h.jsx(jXe, { ...s, ref: e });
  }
  throw new Error(`Missing prop \`type\` expected on \`${lh}\``);
});
I5.displayName = lh;
var [qde, Xde] = Kde(lh), NXe = B.forwardRef((t, e) => {
  const {
    value: n,
    defaultValue: r,
    onValueChange: s = () => {
    },
    ...o
  } = t, [i, a] = io({
    prop: n,
    defaultProp: r ?? "",
    onChange: s,
    caller: lh
  });
  return /* @__PURE__ */ h.jsx(
    qde,
    {
      scope: t.__scopeToggleGroup,
      type: "single",
      value: B.useMemo(() => i ? [i] : [], [i]),
      onItemActivate: a,
      onItemDeactivate: B.useCallback(() => a(""), [a]),
      children: /* @__PURE__ */ h.jsx(Zde, { ...o, ref: e })
    }
  );
}), jXe = B.forwardRef((t, e) => {
  const {
    value: n,
    defaultValue: r,
    onValueChange: s = () => {
    },
    ...o
  } = t, [i, a] = io({
    prop: n,
    defaultProp: r ?? [],
    onChange: s,
    caller: lh
  }), c = B.useCallback(
    (d) => a((u = []) => [...u, d]),
    [a]
  ), l = B.useCallback(
    (d) => a((u = []) => u.filter((f) => f !== d)),
    [a]
  );
  return /* @__PURE__ */ h.jsx(
    qde,
    {
      scope: t.__scopeToggleGroup,
      type: "multiple",
      value: i,
      onItemActivate: c,
      onItemDeactivate: l,
      children: /* @__PURE__ */ h.jsx(Zde, { ...o, ref: e })
    }
  );
});
I5.displayName = lh;
var [RXe, $Xe] = Kde(lh), Zde = B.forwardRef(
  (t, e) => {
    const {
      __scopeToggleGroup: n,
      disabled: r = !1,
      rovingFocus: s = !0,
      orientation: o,
      dir: i,
      loop: a = !0,
      ...c
    } = t, l = Yde(n), d = vg(i), u = { role: "group", dir: d, ...c };
    return /* @__PURE__ */ h.jsx(RXe, { scope: n, rovingFocus: s, disabled: r, children: s ? /* @__PURE__ */ h.jsx(
      i5,
      {
        asChild: !0,
        ...l,
        orientation: o,
        dir: d,
        loop: a,
        children: /* @__PURE__ */ h.jsx(Re.div, { ...u, ref: e })
      }
    ) : /* @__PURE__ */ h.jsx(Re.div, { ...u, ref: e }) });
  }
), dT = "ToggleGroupItem", Qde = B.forwardRef(
  (t, e) => {
    const n = Xde(dT, t.__scopeToggleGroup), r = $Xe(dT, t.__scopeToggleGroup), s = Yde(t.__scopeToggleGroup), o = n.value.includes(t.value), i = r.disabled || t.disabled, a = { ...t, pressed: o, disabled: i }, c = B.useRef(null);
    return r.rovingFocus ? /* @__PURE__ */ h.jsx(
      mk,
      {
        asChild: !0,
        ...s,
        focusable: !i,
        active: o,
        ref: c,
        children: /* @__PURE__ */ h.jsx(lV, { ...a, ref: e })
      }
    ) : /* @__PURE__ */ h.jsx(lV, { ...a, ref: e });
  }
);
Qde.displayName = dT;
var lV = B.forwardRef(
  (t, e) => {
    const { __scopeToggleGroup: n, value: r, ...s } = t, o = Xde(dT, n), i = { role: "radio", "aria-checked": t.pressed, "aria-pressed": void 0 }, a = o.type === "single" ? i : void 0;
    return /* @__PURE__ */ h.jsx(
      Wde,
      {
        ...a,
        ...s,
        ref: e,
        onPressedChange: (c) => {
          c ? o.onItemActivate(r) : o.onItemDeactivate(r);
        }
      }
    );
  }
), LXe = I5, FXe = Qde, k5 = "Toolbar", [BXe, n5t] = bs(k5, [
  hv,
  Gde
]), A5 = hv(), Jde = Gde(), [zXe, eue] = BXe(k5), tue = T.forwardRef(
  (t, e) => {
    const { __scopeToolbar: n, orientation: r = "horizontal", dir: s, loop: o = !0, ...i } = t, a = A5(n), c = vg(s);
    return /* @__PURE__ */ h.jsx(zXe, { scope: n, orientation: r, dir: c, children: /* @__PURE__ */ h.jsx(
      i5,
      {
        asChild: !0,
        ...a,
        orientation: r,
        dir: c,
        loop: o,
        children: /* @__PURE__ */ h.jsx(
          Re.div,
          {
            role: "toolbar",
            "aria-orientation": r,
            dir: c,
            ...i,
            ref: e
          }
        )
      }
    ) });
  }
);
tue.displayName = k5;
var nue = "ToolbarSeparator", UXe = T.forwardRef(
  (t, e) => {
    const { __scopeToolbar: n, ...r } = t, s = eue(nue, n);
    return /* @__PURE__ */ h.jsx(
      uL,
      {
        orientation: s.orientation === "horizontal" ? "vertical" : "horizontal",
        ...r,
        ref: e
      }
    );
  }
);
UXe.displayName = nue;
var HXe = "ToolbarButton", M5 = T.forwardRef(
  (t, e) => {
    const { __scopeToolbar: n, ...r } = t, s = A5(n);
    return /* @__PURE__ */ h.jsx(mk, { asChild: !0, ...s, focusable: !t.disabled, children: /* @__PURE__ */ h.jsx(Re.button, { type: "button", ...r, ref: e }) });
  }
);
M5.displayName = HXe;
var VXe = "ToolbarLink", WXe = T.forwardRef(
  (t, e) => {
    const { __scopeToolbar: n, ...r } = t, s = A5(n);
    return /* @__PURE__ */ h.jsx(mk, { asChild: !0, ...s, focusable: !0, children: /* @__PURE__ */ h.jsx(
      Re.a,
      {
        ...r,
        ref: e,
        onKeyDown: Te(t.onKeyDown, (o) => {
          o.key === " " && o.currentTarget.click();
        })
      }
    ) });
  }
);
WXe.displayName = VXe;
var rue = "ToolbarToggleGroup", sue = T.forwardRef(
  (t, e) => {
    const { __scopeToolbar: n, ...r } = t, s = eue(rue, n), o = Jde(n);
    return /* @__PURE__ */ h.jsx(
      LXe,
      {
        "data-orientation": s.orientation,
        dir: s.dir,
        ...o,
        ...r,
        ref: e,
        rovingFocus: !1
      }
    );
  }
);
sue.displayName = rue;
var KXe = "ToolbarToggleItem", oue = T.forwardRef(
  (t, e) => {
    const { __scopeToolbar: n, ...r } = t, s = Jde(n), o = { __scopeToolbar: t.__scopeToolbar };
    return /* @__PURE__ */ h.jsx(M5, { asChild: !0, ...o, children: /* @__PURE__ */ h.jsx(FXe, { ...s, ...r, ref: e }) });
  }
);
oue.displayName = KXe;
var GXe = tue, YXe = M5, qXe = sue, XXe = oue;
function ZXe(t, e) {
  const n = mt(
    e.map((s) => t.getShape(s)).filter((s) => s && t.isShapeOfType(s, "frame"))
  );
  if (!n.length) return;
  const r = [];
  t.run(() => {
    n.map((s) => {
      const o = t.getSortedChildIdsForParent(s.id);
      o.length && (An(t, o, {
        filter: (i) => !n.find((a) => a.id === i.id)
      }), r.push(...o));
    }), t.setSelectedShapes(r), t.deleteShapes(e);
  });
}
const dV = 50;
function iue(t, e, n = { padding: dV }) {
  const r = _e.FromPoints(
    t.flatMap((l) => {
      if (!l) return [];
      const d = e.getShapeGeometry(l.id), u = e.getShapeLocalTransform(l);
      return (u == null ? void 0 : u.applyToPoints(d.vertices)) ?? [];
    })
  ), s = n.padding ?? dV, o = r.w + 2 * s, i = r.h + 2 * s, a = s - r.minX, c = s - r.minY;
  return { w: o, h: i, dx: a, dy: c };
}
function aue(t, e, n = {}) {
  const r = t.getShape(e);
  if (!r) return;
  const s = t.getSortedChildIdsForParent(r.id), o = mt(s.map((u) => t.getShape(u)));
  if (!o.length) return;
  const { w: i, h: a, dx: c, dy: l } = iue(o, t, n);
  if (c === 0 && l === 0 && r.props.w === i && r.props.h === a) return;
  const d = new I(c, l).rot(r.rotation);
  t.run(() => {
    const u = s.map((f) => {
      const p = t.getShape(f);
      return {
        id: p.id,
        type: p.type,
        x: p.x + c,
        y: p.y + l
      };
    });
    u.push({
      id: r.id,
      type: r.type,
      x: r.x - d.x,
      y: r.y - d.y,
      props: {
        w: i,
        h: a
      }
    }), t.updateShapes(u);
  });
}
function Pr({ children: t }) {
  return /* @__PURE__ */ h.jsx("span", { className: "tlui-button__label", children: t });
}
const ed = it(function({
  label: e,
  small: n,
  invertIcon: r,
  icon: s,
  color: o,
  className: i,
  ...a
}) {
  return typeof s == "string" ? /* @__PURE__ */ h.jsx(
    QXe,
    {
      label: e,
      small: n,
      invertIcon: r,
      icon: s,
      color: o,
      className: i,
      ...a
    }
  ) : Ube(s, {
    ...a,
    className: Je({ "tlui-icon__small": n }, i, s.props.className),
    "aria-label": e,
    style: {
      color: o,
      transform: r ? "scale(-1, 1)" : void 0,
      ...s.props.style
    }
  });
});
function QXe({
  label: t,
  small: e,
  invertIcon: n,
  icon: r,
  color: s,
  className: o,
  ...i
}) {
  const a = n5(), c = a.icons[r] ?? a.icons["question-mark-circle"], l = fe(null);
  return un(() => {
    c || console.error(`Icon not found: ${r}. Add it to the assetUrls.icons object.`), l != null && l.current && (l.current.style.webkitMask = `url(${c}) center 100% / 100% no-repeat`);
  }, [l, c, r]), r === "none" ? /* @__PURE__ */ h.jsx(
    "div",
    {
      className: Je(
        "tlui-icon tlui-icon__placeholder",
        { "tlui-icon__small": e },
        o
      ),
      ...i
    }
  ) : /* @__PURE__ */ h.jsx(
    "div",
    {
      ...i,
      ref: l,
      "aria-label": t,
      role: "img",
      className: Je("tlui-icon", { "tlui-icon__small": e }, o),
      style: {
        color: s,
        mask: `url(${c}) center 100% / 100% no-repeat`,
        transform: n ? "scale(-1, 1)" : void 0
      }
    }
  );
}
function gt({ icon: t, small: e, invertIcon: n }) {
  return /* @__PURE__ */ h.jsx(
    ed,
    {
      "aria-hidden": "true",
      label: "",
      className: "tlui-button__icon",
      icon: t,
      small: e,
      invertIcon: n
    }
  );
}
function Ik({ className: t, children: e }) {
  return /* @__PURE__ */ h.jsx("div", { className: Je("tlui-dialog__header", t), children: e });
}
function kk({ className: t, children: e, style: n }) {
  return /* @__PURE__ */ h.jsx(
    M0,
    {
      dir: "ltr",
      className: Je("tlui-dialog__header__title", t),
      style: n,
      children: e
    }
  );
}
function Ak() {
  const t = Ze();
  return /* @__PURE__ */ h.jsx("div", { className: "tlui-dialog__header__close", children: /* @__PURE__ */ h.jsx(pL, { "data-testid": "dialog.close", dir: "ltr", asChild: !0, children: /* @__PURE__ */ h.jsx(
    yt,
    {
      type: "icon",
      "aria-label": t("ui.close"),
      onTouchEnd: (e) => e.target.click(),
      children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "cross-2" })
    }
  ) }) });
}
function Ew({ className: t, children: e, style: n }) {
  return /* @__PURE__ */ h.jsx("div", { className: Je("tlui-dialog__body", t), style: n, tabIndex: 0, children: e });
}
function O5({ className: t, children: e }) {
  return /* @__PURE__ */ h.jsx("div", { className: Je("tlui-dialog__footer", t), children: e });
}
const mv = T.forwardRef(
  function({
    className: e,
    label: n,
    icon: r,
    iconLeft: s,
    iconLabel: o,
    autoSelect: i = !1,
    autoFocus: a = !1,
    defaultValue: c,
    placeholder: l,
    onComplete: d,
    onValueChange: u,
    onCancel: f,
    onFocus: p,
    onBlur: g,
    shouldManuallyMaintainScrollPositionWhenFocused: y = !1,
    children: m,
    value: v,
    "data-testid": b,
    disabled: x
  }, w) {
    const S = uo(), C = T.useRef(null);
    T.useImperativeHandle(w, () => C.current);
    const _ = Ze(), E = T.useRef(c ?? ""), M = T.useRef(c ?? ""), N = T.useRef(!1), [O, D] = T.useState(!1), k = T.useCallback(
      (L) => {
        D(!0);
        const z = L.currentTarget;
        M.current = z.value, S ? S.timers.requestAnimationFrame(() => {
          i && z.select();
        }) : fj.requestAnimationFrame("anon", () => {
          i && z.select();
        }), p == null || p();
      },
      [i, S, p]
    ), A = T.useCallback(
      (L) => {
        const z = L.currentTarget.value;
        M.current = z, u == null || u(z);
      },
      [u]
    ), R = T.useCallback(
      (L) => {
        switch (L.key) {
          case "Enter": {
            if (N.current) return;
            L.currentTarget.blur(), cr(L), d == null || d(L.currentTarget.value);
            break;
          }
          case "Escape": {
            L.currentTarget.value = E.current, f == null || f(L.currentTarget.value), L.currentTarget.blur(), cr(L);
            break;
          }
        }
      },
      [d, f]
    ), j = T.useCallback(
      (L) => {
        D(!1);
        const z = L.currentTarget.value;
        g == null || g(z);
      },
      [g]
    ), $ = T.useCallback(() => N.current = !0, []), F = T.useCallback(() => N.current = !1, []);
    return T.useEffect(() => {
      if (!dn.isIos) return;
      const L = window.visualViewport;
      if (O && y && L) {
        const z = () => {
          var H;
          (H = C.current) == null || H.scrollIntoView({ block: "center" });
        };
        return L.addEventListener("resize", z), L.addEventListener("scroll", z), S ? S.timers.requestAnimationFrame(() => {
          var H;
          (H = C.current) == null || H.scrollIntoView({ block: "center" });
        }) : fj.requestAnimationFrame("anon", () => {
          var H;
          (H = C.current) == null || H.scrollIntoView({ block: "center" });
        }), () => {
          L.removeEventListener("resize", z), L.removeEventListener("scroll", z);
        };
      }
    }, [O, S, y]), /* @__PURE__ */ h.jsxs("div", { draggable: !1, className: "tlui-input__wrapper", children: [
      m,
      n && /* @__PURE__ */ h.jsx("label", { children: _(n) }),
      s && /* @__PURE__ */ h.jsx(
        ed,
        {
          label: o ? _(o) : "",
          icon: s,
          className: "tlui-icon-left",
          small: !0
        }
      ),
      /* @__PURE__ */ h.jsx(
        "input",
        {
          ref: C,
          className: Je("tlui-input", e),
          type: "text",
          defaultValue: c,
          onKeyDownCapture: R,
          onChange: A,
          onFocus: k,
          onBlur: j,
          onCompositionStart: $,
          onCompositionEnd: F,
          autoFocus: a,
          placeholder: l,
          value: v,
          "data-testid": b,
          disabled: x
        }
      ),
      r && /* @__PURE__ */ h.jsx(ed, { label: o ? _(o) : "", icon: r, small: !!n })
    ] });
  }
);
function uV(t) {
  return _a.isValid(t) ? { isValid: !0, hasProtocol: !0 } : _a.isValid("https://" + t) ? { isValid: !0, hasProtocol: !1 } : { isValid: !1, hasProtocol: !1 };
}
const JXe = Kr(function({ onClose: e }) {
  const r = ie().getOnlySelectedShape();
  return r && "url" in r.props && typeof r.props.url == "string" ? /* @__PURE__ */ h.jsx(eZe, { onClose: e, selectedShape: r }) : null;
}), eZe = Kr(function({
  onClose: e,
  selectedShape: n
}) {
  const r = ie(), s = Ze(), o = fe(null);
  me(() => {
    r.timers.requestAnimationFrame(() => {
      var g;
      return (g = o.current) == null ? void 0 : g.focus();
    });
  }, [r]);
  const i = fe(n.props.url), [a, c] = he(() => {
    const g = uV(n.props.url), y = g.isValid === !0 ? g.hasProtocol ? n.props.url : "https://" + n.props.url : "https://";
    return {
      actual: y,
      safe: y,
      valid: !0
    };
  }), l = re((g) => {
    const y = g.replace(/https?:\/\/(https?:\/\/)/, (b, x) => x), m = uV(y), v = m.isValid === !0 ? m.hasProtocol ? y : "https://" + y : "https://";
    c({
      actual: y,
      safe: v,
      valid: m.isValid
    });
  }, []), d = re(() => {
    const g = r.getOnlySelectedShape();
    g && (r.updateShapes([
      { id: g.id, type: g.type, props: { url: "" } }
    ]), e());
  }, [r, e]), u = re(() => {
    const g = r.getOnlySelectedShape();
    g && (g && "url" in g.props && g.props.url !== a.safe && r.updateShapes([
      {
        id: g.id,
        type: g.type,
        props: { url: a.safe }
      }
    ]), e());
  }, [r, e, a]), f = re(() => {
    e();
  }, [e]);
  if (!n)
    return e(), null;
  const p = i.current && !a.valid;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs(Ik, { children: [
      /* @__PURE__ */ h.jsx(kk, { children: s("edit-link-dialog.title") }),
      /* @__PURE__ */ h.jsx(Ak, {})
    ] }),
    /* @__PURE__ */ h.jsx(Ew, { children: /* @__PURE__ */ h.jsxs("div", { className: "tlui-edit-link-dialog", children: [
      /* @__PURE__ */ h.jsx(
        mv,
        {
          ref: o,
          className: "tlui-edit-link-dialog__input",
          label: "edit-link-dialog.url",
          autoFocus: !0,
          autoSelect: !0,
          placeholder: "https://example.com",
          value: a.actual,
          onValueChange: l,
          onComplete: u,
          onCancel: f
        }
      ),
      /* @__PURE__ */ h.jsx("div", { children: a.valid ? s("edit-link-dialog.detail") : s("edit-link-dialog.invalid-url") })
    ] }) }),
    /* @__PURE__ */ h.jsxs(O5, { className: "tlui-dialog__footer__actions", children: [
      /* @__PURE__ */ h.jsx(yt, { type: "normal", onClick: f, onTouchEnd: f, children: /* @__PURE__ */ h.jsx(Pr, { children: s("edit-link-dialog.cancel") }) }),
      p ? /* @__PURE__ */ h.jsx(yt, { type: "danger", onTouchEnd: d, onClick: d, children: /* @__PURE__ */ h.jsx(Pr, { children: s("edit-link-dialog.clear") }) }) : /* @__PURE__ */ h.jsx(
        yt,
        {
          type: "primary",
          disabled: !a.valid,
          onTouchEnd: u,
          onClick: u,
          children: /* @__PURE__ */ h.jsx(Pr, { children: s("edit-link-dialog.save") })
        }
      )
    ] })
  ] });
}), fV = /(^\/[f|p|r|ro|s|v]\/[^/]+\/?$)/, D5 = [
  {
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    overridePermissions: {
      "allow-top-navigation": !0
    },
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(fV))
        return e.searchParams.append("embed", "true"), t;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(fV))
        return e.searchParams.delete("embed"), t;
    }
  },
  {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      if (t.match(
        // eslint-disable-next-line no-useless-escape
        /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto|design)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
      ) && !t.includes("figma.com/embed"))
        return `https://www.figma.com/embed?embed_host=share&url=${t}`;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/?$/)) {
        const n = e.searchParams.get("url");
        if (n)
          return n;
      }
    }
  },
  {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: !0,
    overridePermissions: {
      "allow-presentation": !0
    },
    toEmbedUrl: (t) => {
      if (t.includes("/maps/embed?"))
        return t;
      if (t.includes("/maps/")) {
        const e = t.match(/@(.*?),(.*?),(.*?)(z|m)/);
        let n;
        if (e) {
          const [, r, s, o, i] = e, a = i === "z" ? "roadmap" : "satellite", c = a === "roadmap" ? o : -Math.log2(parseInt(o) / 14772321) / 0.8;
          n = `https://${new URL(t).host.replace("www.", "")}/maps/embed/v1/view?key=${process.env.NEXT_PUBLIC_GC_API_KEY}&center=${r},${s}&zoom=${c}&maptype=${a}`;
        } else
          n = "";
        return n;
      }
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (!e) return;
      if (e.pathname.match(/^\/maps\/embed\/v1\/view\/?$/) && e.searchParams.has("center") && e.searchParams.get("zoom")) {
        const r = e.searchParams.get("zoom") ?? "12", s = e.searchParams.get("maptype") ?? "roadmap", o = s === "roadmap" ? r : 14772321 * Math.pow(2, parseInt(r) * -0.8), [i, a] = e.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${i},${a},${o}${s === "roadmap" ? "z" : "m"}`;
      }
    }
  },
  {
    type: "val_town",
    title: "Val Town",
    hostnames: ["val.town"],
    minWidth: 260,
    minHeight: 100,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = bt(t), n = e && e.pathname.match(/\/v\/(.+)\/?/);
      if (n)
        return `https://www.val.town/embed/${n[1]}`;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t), n = e && e.pathname.match(/\/embed\/(.+)\/?/);
      if (n)
        return `https://www.val.town/v/${n[1]}`;
    }
  },
  {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = bt(t), n = e && e.pathname.match(/\/s\/([^/]+)\/?/);
      if (n)
        return `https://codesandbox.io/embed/${n[1]}`;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t), n = e && e.pathname.match(/\/embed\/([^/]+)\/?/);
      if (n)
        return `https://codesandbox.io/s/${n[1]}`;
    }
  },
  {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, s, o] = n;
        return `https://codepen.io/${s}/embed/${o}`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, s, o] = n;
        return `https://codepen.io/${s}/pen/${o}`;
      }
    }
  },
  {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: !1,
    toEmbedUrl: (t) => {
      const e = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, s] = n;
        return `https://scratch.mit.edu/projects/embed/${s}`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, s] = n;
        return `https://scratch.mit.edu/projects/${s}`;
      }
    }
  },
  {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: !0,
    overridePermissions: {
      "allow-presentation": !0,
      "allow-popups-to-escape-sandbox": !0
    },
    isAspectRatioLocked: !0,
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (!e) return;
      const n = e.hostname.replace(/^www./, "");
      if (n === "youtu.be") {
        const r = e.pathname.split("/").filter(Boolean)[0], s = new URLSearchParams(e.search), o = s.get("t");
        o && (s.set("start", o), s.delete("t"));
        const i = s.toString() ? "?" + s.toString() : "";
        return `https://www.youtube.com/embed/${r}${i}`;
      } else if ((n === "youtube.com" || n === "m.youtube.com") && e.pathname.match(/^\/watch/)) {
        const r = e.searchParams.get("v"), s = new URLSearchParams(e.search);
        s.delete("v");
        const o = s.get("t");
        o && (s.set("start", o), s.delete("t"));
        const i = s.toString() ? "?" + s.toString() : "";
        return `https://www.youtube.com/embed/${r}${i}`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (!e) return;
      if (e.hostname.replace(/^www./, "") === "youtube.com") {
        const r = e.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (r) {
          const s = new URLSearchParams(e.search);
          s.set("v", (r == null ? void 0 : r[1]) ?? "");
          const o = s.get("start");
          return o && (s.set("t", o), s.delete("start")), `https://www.youtube.com/watch?${s.toString()}`;
        }
      }
    }
  },
  {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    overridePermissions: {
      "allow-popups-to-escape-sandbox": !0
    },
    toEmbedUrl: (t) => {
      const e = bt(t), n = e == null ? void 0 : e.searchParams.get("cid");
      if (e != null && e.pathname.match(/\/calendar\/u\/0/) && n) {
        e.pathname = "/calendar/embed";
        const r = Array.from(e.searchParams.keys());
        for (const s of r)
          e.searchParams.delete(s);
        return e.searchParams.set("src", n), e.href;
      }
    },
    fromEmbedUrl: (t) => {
      const e = bt(t), n = e == null ? void 0 : e.searchParams.get("src");
      if (e != null && e.pathname.match(/\/calendar\/embed/) && n) {
        e.pathname = "/calendar/u/0";
        const r = Array.from(e.searchParams.keys());
        for (const s of r)
          e.searchParams.delete(s);
        return e.searchParams.set("cid", n), e.href;
      }
    }
  },
  {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    overridePermissions: {
      "allow-popups-to-escape-sandbox": !0
    },
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e != null && e.pathname.match(/^\/presentation/) && (e != null && e.pathname.match(/\/pub\/?$/))) {
        e.pathname = e.pathname.replace(/\/pub$/, "/embed");
        const n = Array.from(e.searchParams.keys());
        for (const r of n)
          e.searchParams.delete(r);
        return e.href;
      }
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e != null && e.pathname.match(/^\/presentation/) && (e != null && e.pathname.match(/\/embed\/?$/))) {
        e.pathname = e.pathname.replace(/\/embed$/, "/pub");
        const n = Array.from(e.searchParams.keys());
        for (const r of n)
          e.searchParams.delete(r);
        return e.href;
      }
    }
  },
  {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    // Security warning:
    // Gists allow adding .json extensions to the URL which return JSONP.
    // Furthermore, the JSONP can include callbacks that execute arbitrary JavaScript.
    // It _is_ sandboxed by the iframe but we still want to disable it nonetheless.
    // We restrict the id to only allow hexdecimal characters to prevent this.
    // Read more:
    //   https://github.com/bhaveshk90/Content-Security-Policy-CSP-Bypass-Techniques
    //   https://github.com/renniepak/CSPBypass
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/))
        return t.split("/").pop() ? t : void 0;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/))
        return t.split("/").pop() ? t : void 0;
    }
  },
  {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/))
        return `${t}?embed=true`;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/) && e.searchParams.has("embed"))
        return e.searchParams.delete("embed"), e.href;
    }
  },
  {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/map\//))
        return e.origin + "/embed" + e.pathname;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/map\//))
        return e.pathname = e.pathname.replace(/^\/embed/, ""), e.href;
    }
  },
  {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/(artist|album)\//))
        return e.origin + "/embed" + e.pathname;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/(artist|album)\//))
        return e.origin + e.pathname.replace(/^\/embed/, "");
    }
  },
  {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.hostname === "vimeo.com" && e.pathname.match(/^\/[0-9]+/))
        return "https://player.vimeo.com/video/" + e.pathname.split("/")[1] + "?title=0&byline=0";
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.hostname === "player.vimeo.com") {
        const n = e.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (n)
          return "https://vimeo.com/" + n[1];
      }
    }
  },
  {
    type: "excalidraw",
    title: "Excalidraw",
    hostnames: ["excalidraw.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.hash.match(/#room=/))
        return t;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.hash.match(/#room=/))
        return t;
    }
  },
  {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !1,
    backgroundColor: "#fff",
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}/embed${e.pathname}?cell=*`;
      if (e && e.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const n = e.pathname.replace(/^\/d/, "");
        return `${e.origin}/embed${n}?cell=*`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "")}#cell-*`;
      if (e && e.pathname.match(/^\/embed\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "/d")}#cell-*`;
    }
  },
  {
    type: "desmos",
    title: "Desmos",
    hostnames: ["desmos.com"],
    width: 700,
    height: 450,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.hostname === "www.desmos.com" && e.pathname.match(/^\/calculator\/([^/]+)\/?$/) && e.search === "" && e.hash === "")
        return `${t}?embed`;
    },
    fromEmbedUrl: (t) => {
      const e = bt(t);
      if (e && e.hostname === "www.desmos.com" && e.pathname.match(/^\/calculator\/([^/]+)\/?$/) && e.search === "?embed" && e.hash === "")
        return t.replace("?embed", "");
    }
  }
], tZe = {
  // ========================================================================================
  // Disabled permissions
  // ========================================================================================
  // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads-without-user-activation": !1,
  // [MDN] Allows for downloads to occur with a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads": !1,
  // [MDN] Lets the resource open modal windows.
  // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'.
  "allow-modals": !1,
  // [MDN] Lets the resource lock the screen orientation.
  // [REASON] Would interfere with the tldraw interface.
  "allow-orientation-lock": !1,
  // [MDN] Lets the resource use the Pointer Lock API.
  // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox).
  "allow-pointer-lock": !1,
  // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
  // [REASON] We want to allow embeds to link back to their original sites (e.g. YouTube).
  "allow-popups": !0,
  // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
  // [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within our app.
  "allow-popups-to-escape-sandbox": !1,
  // [MDN] Lets the resource start a presentation session.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-presentation": !1,
  // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
  // [REASON] We don't want anyone else to access our storage.
  "allow-storage-access-by-user-activation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation-by-user-activation": !1,
  // ========================================================================================
  // Enabled permissions
  // ========================================================================================
  // [MDN] Lets the resource run scripts (but not create popup windows).
  "allow-scripts": !0,
  // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
  "allow-same-origin": !0,
  // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
  "allow-forms": !0
}, nZe = D5.map(
  (t) => t.type
);
function rZe(t) {
  return nZe.includes(t);
}
function sZe(t) {
  return "icon" in t;
}
function cue() {
  const t = uo();
  if (t && t.hasShapeUtil("embed"))
    return t.getShapeUtil("embed");
}
function N5() {
  const t = cue();
  return (e) => t ? t.getEmbedDefinition(e) : void 0;
}
function oZe() {
  const t = cue();
  return t ? t.getEmbedDefinitions() : [];
}
const lue = Kr(function({ onClose: e }) {
  const n = ie(), r = Ze(), s = n5(), [o, i] = he(null), [a, c] = he(""), [l, d] = he(null), [u, f] = he(!1), p = fe(-1), g = oZe(), y = N5();
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs(Ik, { children: [
      /* @__PURE__ */ h.jsx(kk, { children: o ? `${r("embed-dialog.title")}  ${o.title}` : r("embed-dialog.title") }),
      /* @__PURE__ */ h.jsx(Ak, {})
    ] }),
    o ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsxs(Ew, { className: "tlui-embed-dialog__enter", children: [
        /* @__PURE__ */ h.jsx(
          mv,
          {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "https://example.com",
            autoFocus: !0,
            onValueChange: (m) => {
              c(m);
              const v = y(m);
              d(
                v && v.definition.type === o.type ? v : null
              ), f(!1), clearTimeout(p.current), p.current = n.timers.setTimeout(
                () => f(!v),
                320
              );
            }
          }
        ),
        a === "" ? /* @__PURE__ */ h.jsxs("div", { className: "tlui-embed-dialog__instruction", children: [
          /* @__PURE__ */ h.jsx("span", { children: r("embed-dialog.instruction") }),
          " ",
          o.instructionLink && /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
            /* @__PURE__ */ h.jsx(
              "a",
              {
                target: "_blank",
                rel: "noopener noreferrer",
                href: o.instructionLink,
                className: "tlui-embed-dialog__instruction__link",
                children: "Learn more"
              }
            ),
            "."
          ] })
        ] }) : /* @__PURE__ */ h.jsx("div", { className: "tlui-embed-dialog__warning", children: u ? r("embed-dialog.invalid-url") : "" })
      ] }),
      /* @__PURE__ */ h.jsxs(O5, { className: "tlui-dialog__footer__actions", children: [
        /* @__PURE__ */ h.jsx(
          yt,
          {
            type: "normal",
            onClick: () => {
              i(null), d(null), c("");
            },
            children: /* @__PURE__ */ h.jsx(Pr, { children: r("embed-dialog.back") })
          }
        ),
        /* @__PURE__ */ h.jsx("div", { className: "tlui-embed__spacer" }),
        /* @__PURE__ */ h.jsx(yt, { type: "normal", onClick: e, children: /* @__PURE__ */ h.jsx(Pr, { children: r("embed-dialog.cancel") }) }),
        /* @__PURE__ */ h.jsx(
          yt,
          {
            type: "primary",
            disabled: !l,
            onClick: () => {
              l && (n.putExternalContent({
                type: "embed",
                url: a,
                point: n.getViewportPageBounds().center,
                embed: l.definition
              }), e());
            },
            children: /* @__PURE__ */ h.jsx(Pr, { children: r("embed-dialog.create") })
          }
        )
      ] })
    ] }) : /* @__PURE__ */ h.jsx(h.Fragment, { children: /* @__PURE__ */ h.jsx(Ew, { className: "tlui-embed-dialog__list", children: g.map((m) => {
      const v = rZe(m.type) ? s.embedIcons[m.type] : sZe(m) ? m.icon : void 0;
      return /* @__PURE__ */ h.jsxs(yt, { type: "menu", onClick: () => i(m), children: [
        /* @__PURE__ */ h.jsx(Pr, { children: m.title }),
        v && /* @__PURE__ */ h.jsx(
          "div",
          {
            className: "tlui-embed-dialog__item__image",
            style: { backgroundImage: `url(${v})` }
          }
        )
      ] }, m.type);
    }) }) })
  ] });
}), RO = [0, 389, 436, 476, 580, 640, 840, 1023];
var Ir = /* @__PURE__ */ ((t) => (t[t.ZERO = 0] = "ZERO", t[t.MOBILE_XXS = 1] = "MOBILE_XXS", t[t.MOBILE_XS = 2] = "MOBILE_XS", t[t.MOBILE_SM = 3] = "MOBILE_SM", t[t.MOBILE = 4] = "MOBILE", t[t.TABLET_SM = 5] = "TABLET_SM", t[t.TABLET = 6] = "TABLET", t[t.DESKTOP = 7] = "DESKTOP", t))(Ir || {});
const due = B.createContext(null);
function iZe({ forceMobile: t = !1, children: e }) {
  const n = uo(), r = le(
    "breakpoint",
    () => {
      const { width: s } = (n == null ? void 0 : n.getViewportScreenBounds()) ?? { width: window.innerWidth }, o = t ? Ir.MOBILE_SM : RO.length - 1;
      for (let i = 0; i < o; i++)
        if (s > RO[i] && s <= RO[i + 1])
          return i;
      return o;
    },
    [n]
  );
  return /* @__PURE__ */ h.jsx(due.Provider, { value: r, children: e });
}
function Uo() {
  const t = tn(due);
  if (t === null)
    throw new Error("useBreakpoint must be used inside of the <BreakpointProvider /> component");
  return t;
}
const uue = zn(null);
function Mk() {
  const t = tn(uue);
  if (!t)
    throw new Error("useTldrawUiMenuContext must be used within a TldrawUiMenuContextProvider");
  return t;
}
function pi({
  type: t,
  sourceId: e,
  children: n
}) {
  return /* @__PURE__ */ h.jsx(uue.Provider, { value: { type: t, sourceId: e }, children: n });
}
function Ok() {
  const t = uo();
  return (t == null ? void 0 : t.store.props.collaboration) !== void 0;
}
function aZe() {
  const t = uo();
  return le(
    "sync status",
    () => {
      var e;
      return (e = t == null ? void 0 : t.store.props.collaboration) != null && e.status ? t.store.props.collaboration.status.get() : null;
    },
    [t]
  );
}
function Da() {
  const t = uo();
  return le("isReadonlyMode", () => !!(t != null && t.getIsReadonly()), [t]);
}
const $O = dn.isDarwin ? "" : "__CTRL__", hV = dn.isDarwin ? "" : "__ALT__";
function fue(t) {
  return t === "," ? [","] : t.split(",")[0].split(/(\[\[[^\]]+\]\])/g).map(
    (e) => e.startsWith("[[") ? e.replace(/[[\]]/g, "") : e.replace(/cmd\+/g, $O).replace(/ctrl\+/g, $O).replace(/alt\+/g, hV).replace(/shift\+/g, "").replace(/\$/g, $O).replace(/\?/g, hV).replace(/!/g, "").match(/__CTRL__|__ALT__|./g) || []
  ).flat().map((e, n) => {
    if (e === "__CTRL__") return "Ctrl";
    if (e === "__ALT__") return "Alt";
    const r = e[0].toUpperCase() + e.slice(1);
    return dn.isDarwin || !n ? r : ["+", r];
  }).flat();
}
function rR(t) {
  return " " + fue(t).join("");
}
function sR(t) {
  const e = Ze();
  return /* @__PURE__ */ h.jsx(Yoe, { "aria-label": e("app.loading"), ...t });
}
function vu(t, e) {
  const n = uo(), r = re(
    (i) => {
      i && (n == null || n.complete()), e == null || e(i);
    },
    [n, e]
  ), s = xr(), o = re(
    (i) => {
      s(i, { source: "unknown", id: t });
    },
    [t, s]
  );
  return ZHe(n ? `${t}-${n.contextId}` : t, r, o);
}
function Dk({
  id: t,
  children: e,
  modal: n = !1,
  debugOpen: r = !1
}) {
  const [s, o] = vu(t);
  return /* @__PURE__ */ h.jsx(
    y5,
    {
      open: r || s,
      dir: "ltr",
      modal: n,
      onOpenChange: o,
      children: e
    }
  );
}
function Nk({ children: t, ...e }) {
  return /* @__PURE__ */ h.jsx(
    v5,
    {
      dir: "ltr",
      asChild: !0,
      onTouchEnd: (n) => xt(n),
      ...e,
      children: t
    }
  );
}
function jk({
  className: t,
  side: e = "bottom",
  align: n = "start",
  sideOffset: r = 8,
  alignOffset: s = 8,
  children: o
}) {
  const i = Gr();
  return /* @__PURE__ */ h.jsx(xk, { container: i, children: /* @__PURE__ */ h.jsx(
    b5,
    {
      className: Je("tlui-menu", t),
      side: e,
      sideOffset: r,
      align: n,
      alignOffset: s,
      collisionPadding: 4,
      children: o
    }
  ) });
}
function cZe({ id: t, children: e }) {
  const [n, r] = vu(t);
  return /* @__PURE__ */ h.jsx(fqe, { open: n, onOpenChange: r, children: e });
}
function lZe({
  id: t,
  label: e,
  title: n,
  disabled: r
}) {
  return /* @__PURE__ */ h.jsx(hqe, { dir: "ltr", asChild: !0, disabled: r, children: /* @__PURE__ */ h.jsxs(
    yt,
    {
      "data-testid": t,
      type: "menu",
      className: "tlui-menu__submenu__trigger",
      disabled: r,
      title: n,
      children: [
        /* @__PURE__ */ h.jsx(Pr, { children: e }),
        /* @__PURE__ */ h.jsx(gt, { icon: "chevron-right", small: !0 })
      ]
    }
  ) });
}
function dZe({
  id: t,
  alignOffset: e = -1,
  sideOffset: n = -6,
  size: r = "small",
  children: s
}) {
  const o = Gr();
  return /* @__PURE__ */ h.jsx(xk, { container: o, children: /* @__PURE__ */ h.jsx(
    pqe,
    {
      "data-testid": t,
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset: e,
      sideOffset: n,
      collisionPadding: 4,
      "data-size": r,
      children: s
    }
  ) });
}
function uZe({ className: t, children: e }) {
  return /* @__PURE__ */ h.jsx("div", { dir: "ltr", className: Je("tlui-menu__group", t), children: e });
}
function fZe({ noClose: t, children: e }) {
  return /* @__PURE__ */ h.jsx(dqe, { dir: "ltr", asChild: !0, onClick: t ? xt : void 0, children: e });
}
function hZe({
  children: t,
  onSelect: e,
  ...n
}) {
  const r = Ze();
  return /* @__PURE__ */ h.jsxs(
    Sle,
    {
      dir: "ltr",
      className: "tlui-button tlui-button__menu tlui-button__checkbox",
      onSelect: (s) => {
        e == null || e(s), xt(s);
      },
      ...n,
      children: [
        /* @__PURE__ */ h.jsx("div", { className: "tlui-button__checkbox__indicator", children: /* @__PURE__ */ h.jsx(uqe, { dir: "ltr", children: /* @__PURE__ */ h.jsx(ed, { label: r("ui.checked"), icon: "check", small: !0 }) }) }),
        t
      ]
    }
  );
}
function _x({ children: t, visibleOnMobileLayout: e = !1 }) {
  const n = Uo();
  return !e && n < Ir.MOBILE ? null : /* @__PURE__ */ h.jsx("kbd", { className: "tlui-kbd", children: fue(t).map((r, s) => /* @__PURE__ */ h.jsx("span", { children: r }, s)) });
}
const zr = B.forwardRef(
  ({ children: t, className: e, label: n, ...r }, s) => /* @__PURE__ */ h.jsx(
    GXe,
    {
      ref: s,
      ...r,
      className: Je("tlui-toolbar-container", e),
      "aria-label": n,
      children: t
    }
  )
), Ds = B.forwardRef(
  ({ asChild: t, children: e, type: n, isActive: r, ...s }, o) => /* @__PURE__ */ h.jsx(
    YXe,
    {
      ref: o,
      asChild: t,
      draggable: !1,
      "data-isactive": r,
      ...s,
      className: Je("tlui-button", `tlui-button__${n}`, s.className),
      children: e
    }
  )
), pZe = ({
  children: t,
  className: e,
  type: n,
  ...r
}) => /* @__PURE__ */ h.jsx(
  qXe,
  {
    type: n,
    ...r,
    role: "radiogroup",
    className: Je("tlui-toolbar-toggle-group", e),
    children: t
  }
), gZe = ({
  children: t,
  className: e,
  type: n,
  value: r,
  ...s
}) => /* @__PURE__ */ h.jsx(
  XXe,
  {
    ...s,
    className: Je(
      "tlui-button",
      `tlui-button__${n}`,
      "tlui-toolbar-toggle-group-item",
      e
    ),
    value: r,
    children: t
  }
);
function Zt({
  disabled: t = !1,
  spinner: e = !1,
  readonlyOk: n = !1,
  id: r,
  kbd: s,
  label: o,
  icon: i,
  iconLeft: a,
  onSelect: c,
  noClose: l,
  isSelected: d
}) {
  const { type: u, sourceId: f } = Mk(), p = Ze(), [g, y] = he(!1);
  if (Da() && !n) return null;
  const v = Tw(o, u), b = s ? rR(s) : void 0, x = v ? p(v) : void 0, w = x && b ? `${x} ${b}` : x;
  switch (u) {
    case "menu":
      return /* @__PURE__ */ h.jsx(fZe, { children: /* @__PURE__ */ h.jsxs(
        yt,
        {
          type: "menu",
          "data-testid": `${f}.${r}`,
          disabled: t,
          title: w,
          onClick: (S) => {
            l && xt(S), g ? y(!1) : c(f);
          },
          children: [
            a && /* @__PURE__ */ h.jsx(gt, { icon: a, small: !0 }),
            /* @__PURE__ */ h.jsx(Pr, { children: x }),
            s && /* @__PURE__ */ h.jsx(_x, { children: s })
          ]
        }
      ) });
    case "context-menu":
      return t ? null : /* @__PURE__ */ h.jsxs(
        zYe,
        {
          dir: "ltr",
          title: w,
          draggable: !1,
          className: "tlui-button tlui-button__menu",
          "data-testid": `${f}.${r}`,
          onSelect: (S) => {
            l && xt(S), g ? y(!1) : c(f);
          },
          children: [
            /* @__PURE__ */ h.jsx("span", { className: "tlui-button__label", draggable: !1, children: x }),
            a && /* @__PURE__ */ h.jsx(gt, { icon: a, small: !0 }),
            s && /* @__PURE__ */ h.jsx(_x, { children: s }),
            e && /* @__PURE__ */ h.jsx(sR, {})
          ]
        }
      );
    case "panel":
      return /* @__PURE__ */ h.jsxs(
        yt,
        {
          "data-testid": `${f}.${r}`,
          type: "menu",
          title: w,
          disabled: t,
          onClick: () => c(f),
          children: [
            /* @__PURE__ */ h.jsx(Pr, { children: x }),
            e ? /* @__PURE__ */ h.jsx(sR, {}) : i && /* @__PURE__ */ h.jsx(gt, { icon: i })
          ]
        }
      );
    case "small-icons":
    case "icons":
      return /* @__PURE__ */ h.jsx(
        Ds,
        {
          "data-testid": `${f}.${r}`,
          type: "icon",
          title: w,
          disabled: t,
          onClick: () => c(f),
          children: /* @__PURE__ */ h.jsx(gt, { icon: i, small: !0 })
        }
      );
    case "keyboard-shortcuts":
      return s ? /* @__PURE__ */ h.jsxs("div", { className: "tlui-shortcuts-dialog__key-pair", "data-testid": `${f}.${r}`, children: [
        /* @__PURE__ */ h.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: x }),
        /* @__PURE__ */ h.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: /* @__PURE__ */ h.jsx(_x, { visibleOnMobileLayout: !0, children: s }) })
      ] }) : (console.warn(
        `Menu item '${o}' isn't shown in the keyboard shortcuts dialog because it doesn't have a keyboard shortcut.`
      ), null);
    case "helper-buttons":
      return /* @__PURE__ */ h.jsxs(yt, { type: "low", onClick: () => c(f), children: [
        /* @__PURE__ */ h.jsx(gt, { icon: i }),
        /* @__PURE__ */ h.jsx(Pr, { children: x })
      ] });
    case "toolbar":
      return /* @__PURE__ */ h.jsx(
        Ds,
        {
          "aria-label": x,
          "aria-pressed": d ? "true" : "false",
          "data-testid": `tools.${r}`,
          "data-value": r,
          disabled: t,
          onClick: () => c("toolbar"),
          onTouchStart: (S) => {
            xt(S), c("toolbar");
          },
          title: w,
          type: "tool",
          children: /* @__PURE__ */ h.jsx(gt, { icon: i })
        }
      );
    case "toolbar-overflow":
      return /* @__PURE__ */ h.jsx(
        Ds,
        {
          "aria-label": x,
          "aria-pressed": d ? "true" : "false",
          isActive: d,
          className: "tlui-button-grid__button",
          "data-testid": `tools.more.${r}`,
          "data-value": r,
          disabled: t,
          onClick: () => c("toolbar"),
          title: w,
          type: "icon",
          children: /* @__PURE__ */ h.jsx(gt, { icon: i })
        }
      );
    default:
      throw Jt(u);
  }
}
function be({ actionId: t = "", ...e }) {
  const r = xu()[t];
  return r ? /* @__PURE__ */ h.jsx(Zt, { ...r, ...e }) : null;
}
function At({ id: t, label: e, className: n, children: r }) {
  const { type: s, sourceId: o } = Mk(), i = Ze(), a = Tw(e, s), c = a ? i(a) : void 0;
  switch (s) {
    case "panel":
      return /* @__PURE__ */ h.jsx(
        "div",
        {
          className: Je("tlui-menu__group", n),
          "data-testid": `${o}-group.${t}`,
          children: r
        }
      );
    case "menu":
      return /* @__PURE__ */ h.jsx(uZe, { className: n, "data-testid": `${o}-group.${t}`, children: r });
    case "context-menu":
      return /* @__PURE__ */ h.jsx(
        "div",
        {
          dir: "ltr",
          className: Je("tlui-menu__group", n),
          "data-testid": `${o}-group.${t}`,
          children: r
        }
      );
    case "keyboard-shortcuts":
      return /* @__PURE__ */ h.jsxs("div", { className: "tlui-shortcuts-dialog__group", "data-testid": `${o}-group.${t}`, children: [
        /* @__PURE__ */ h.jsx("h2", { className: "tlui-shortcuts-dialog__group__title", children: c }),
        /* @__PURE__ */ h.jsx("div", { className: "tlui-shortcuts-dialog__group__content", children: r })
      ] });
    default:
      return r;
  }
}
const oR = zn(null);
function mZe({ context: t, children: e }) {
  const n = tn(oR), r = xr(), s = K0("dialogs", []), o = Ke(() => ({
    dialogs: s,
    addDialog(i) {
      const a = i.id ?? bn();
      return s.update((c) => [...c.filter((l) => l.id !== i.id), { ...i, id: a }]), r("open-menu", { source: "dialog", id: a }), ni.addOpenMenu(a, t), a;
    },
    removeDialog(i) {
      var c;
      const a = s.get().find((l) => l.id === i);
      return a && ((c = a.onClose) == null || c.call(a), r("close-menu", { source: "dialog", id: i }), ni.deleteOpenMenu(i, t), s.update((l) => l.filter((d) => d !== a))), i;
    },
    clearDialogs() {
      const i = s.get();
      i.length !== 0 && (i.forEach((a) => {
        var c;
        (c = a.onClose) == null || c.call(a), r("close-menu", { source: "dialog", id: a.id }), ni.deleteOpenMenu(a.id, t);
      }), s.set([]));
    }
  }), [r, s, t]);
  return n ? /* @__PURE__ */ h.jsx(h.Fragment, { children: e }) : /* @__PURE__ */ h.jsx(oR.Provider, { value: o, children: e });
}
function gS() {
  const t = tn(oR);
  if (!t)
    throw new Error("useDialogs must be used within a DialogsProvider");
  return t;
}
const iR = zn(null);
function yZe({ children: t }) {
  const e = K0("toasts", []), n = tn(iR), r = Ke(() => ({
    toasts: e,
    addToast(s) {
      const o = s.id ?? bn();
      return e.update((i) => [...i.filter((a) => a.id !== s.id), { ...s, id: o }]), o;
    },
    removeToast(s) {
      return e.update((o) => o.filter((i) => i.id !== s)), s;
    },
    clearToasts() {
      e.set([]);
    }
  }), [e]);
  return n ? /* @__PURE__ */ h.jsx(h.Fragment, { children: t }) : /* @__PURE__ */ h.jsx(Oq, { children: /* @__PURE__ */ h.jsx(iR.Provider, { value: r, children: t }) });
}
function bu() {
  const t = tn(iR);
  if (!t)
    throw new Error("useToasts must be used within a ToastsProvider");
  return t;
}
function pV(t) {
  return new Promise((e) => {
    const { allowMultiple: n = !0, mimeTypes: r = [] } = t || {}, s = document.createElement("input");
    s.type = "file", s.accept = r == null ? void 0 : r.join(","), s.multiple = n;
    async function o(i) {
      const a = i.target.files;
      if (!a || a.length === 0) return;
      const c = Array.from(a);
      s.value = "", e(c), s.removeEventListener("change", o), s.remove();
    }
    s.addEventListener("change", o), s == null || s.click();
  });
}
var j5 = { exports: {} };
j5.exports;
(function(t) {
  var e = function() {
    var n = String.fromCharCode, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", o = {};
    function i(c, l) {
      if (!o[c]) {
        o[c] = {};
        for (var d = 0; d < c.length; d++)
          o[c][c.charAt(d)] = d;
      }
      return o[c][l];
    }
    var a = {
      compressToBase64: function(c) {
        if (c == null) return "";
        var l = a._compress(c, 6, function(d) {
          return r.charAt(d);
        });
        switch (l.length % 4) {
          default:
          case 0:
            return l;
          case 1:
            return l + "===";
          case 2:
            return l + "==";
          case 3:
            return l + "=";
        }
      },
      decompressFromBase64: function(c) {
        return c == null ? "" : c == "" ? null : a._decompress(c.length, 32, function(l) {
          return i(r, c.charAt(l));
        });
      },
      compressToUTF16: function(c) {
        return c == null ? "" : a._compress(c, 15, function(l) {
          return n(l + 32);
        }) + " ";
      },
      decompressFromUTF16: function(c) {
        return c == null ? "" : c == "" ? null : a._decompress(c.length, 16384, function(l) {
          return c.charCodeAt(l) - 32;
        });
      },
      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: function(c) {
        for (var l = a.compress(c), d = new Uint8Array(l.length * 2), u = 0, f = l.length; u < f; u++) {
          var p = l.charCodeAt(u);
          d[u * 2] = p >>> 8, d[u * 2 + 1] = p % 256;
        }
        return d;
      },
      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: function(c) {
        if (c == null)
          return a.decompress(c);
        for (var l = new Array(c.length / 2), d = 0, u = l.length; d < u; d++)
          l[d] = c[d * 2] * 256 + c[d * 2 + 1];
        var f = [];
        return l.forEach(function(p) {
          f.push(n(p));
        }), a.decompress(f.join(""));
      },
      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: function(c) {
        return c == null ? "" : a._compress(c, 6, function(l) {
          return s.charAt(l);
        });
      },
      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: function(c) {
        return c == null ? "" : c == "" ? null : (c = c.replace(/ /g, "+"), a._decompress(c.length, 32, function(l) {
          return i(s, c.charAt(l));
        }));
      },
      compress: function(c) {
        return a._compress(c, 16, function(l) {
          return n(l);
        });
      },
      _compress: function(c, l, d) {
        if (c == null) return "";
        var u, f, p = {}, g = {}, y = "", m = "", v = "", b = 2, x = 3, w = 2, S = [], C = 0, _ = 0, E;
        for (E = 0; E < c.length; E += 1)
          if (y = c.charAt(E), Object.prototype.hasOwnProperty.call(p, y) || (p[y] = x++, g[y] = !0), m = v + y, Object.prototype.hasOwnProperty.call(p, m))
            v = m;
          else {
            if (Object.prototype.hasOwnProperty.call(g, v)) {
              if (v.charCodeAt(0) < 256) {
                for (u = 0; u < w; u++)
                  C = C << 1, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++;
                for (f = v.charCodeAt(0), u = 0; u < 8; u++)
                  C = C << 1 | f & 1, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++, f = f >> 1;
              } else {
                for (f = 1, u = 0; u < w; u++)
                  C = C << 1 | f, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++, f = 0;
                for (f = v.charCodeAt(0), u = 0; u < 16; u++)
                  C = C << 1 | f & 1, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++, f = f >> 1;
              }
              b--, b == 0 && (b = Math.pow(2, w), w++), delete g[v];
            } else
              for (f = p[v], u = 0; u < w; u++)
                C = C << 1 | f & 1, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++, f = f >> 1;
            b--, b == 0 && (b = Math.pow(2, w), w++), p[m] = x++, v = String(y);
          }
        if (v !== "") {
          if (Object.prototype.hasOwnProperty.call(g, v)) {
            if (v.charCodeAt(0) < 256) {
              for (u = 0; u < w; u++)
                C = C << 1, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++;
              for (f = v.charCodeAt(0), u = 0; u < 8; u++)
                C = C << 1 | f & 1, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++, f = f >> 1;
            } else {
              for (f = 1, u = 0; u < w; u++)
                C = C << 1 | f, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++, f = 0;
              for (f = v.charCodeAt(0), u = 0; u < 16; u++)
                C = C << 1 | f & 1, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++, f = f >> 1;
            }
            b--, b == 0 && (b = Math.pow(2, w), w++), delete g[v];
          } else
            for (f = p[v], u = 0; u < w; u++)
              C = C << 1 | f & 1, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++, f = f >> 1;
          b--, b == 0 && (b = Math.pow(2, w), w++);
        }
        for (f = 2, u = 0; u < w; u++)
          C = C << 1 | f & 1, _ == l - 1 ? (_ = 0, S.push(d(C)), C = 0) : _++, f = f >> 1;
        for (; ; )
          if (C = C << 1, _ == l - 1) {
            S.push(d(C));
            break;
          } else _++;
        return S.join("");
      },
      decompress: function(c) {
        return c == null ? "" : c == "" ? null : a._decompress(c.length, 32768, function(l) {
          return c.charCodeAt(l);
        });
      },
      _decompress: function(c, l, d) {
        var u = [], f = 4, p = 4, g = 3, y = "", m = [], v, b, x, w, S, C, _, E = { val: d(0), position: l, index: 1 };
        for (v = 0; v < 3; v += 1)
          u[v] = v;
        for (x = 0, S = Math.pow(2, 2), C = 1; C != S; )
          w = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = l, E.val = d(E.index++)), x |= (w > 0 ? 1 : 0) * C, C <<= 1;
        switch (x) {
          case 0:
            for (x = 0, S = Math.pow(2, 8), C = 1; C != S; )
              w = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = l, E.val = d(E.index++)), x |= (w > 0 ? 1 : 0) * C, C <<= 1;
            _ = n(x);
            break;
          case 1:
            for (x = 0, S = Math.pow(2, 16), C = 1; C != S; )
              w = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = l, E.val = d(E.index++)), x |= (w > 0 ? 1 : 0) * C, C <<= 1;
            _ = n(x);
            break;
          case 2:
            return "";
        }
        for (u[3] = _, b = _, m.push(_); ; ) {
          if (E.index > c)
            return "";
          for (x = 0, S = Math.pow(2, g), C = 1; C != S; )
            w = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = l, E.val = d(E.index++)), x |= (w > 0 ? 1 : 0) * C, C <<= 1;
          switch (_ = x) {
            case 0:
              for (x = 0, S = Math.pow(2, 8), C = 1; C != S; )
                w = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = l, E.val = d(E.index++)), x |= (w > 0 ? 1 : 0) * C, C <<= 1;
              u[p++] = n(x), _ = p - 1, f--;
              break;
            case 1:
              for (x = 0, S = Math.pow(2, 16), C = 1; C != S; )
                w = E.val & E.position, E.position >>= 1, E.position == 0 && (E.position = l, E.val = d(E.index++)), x |= (w > 0 ? 1 : 0) * C, C <<= 1;
              u[p++] = n(x), _ = p - 1, f--;
              break;
            case 2:
              return m.join("");
          }
          if (f == 0 && (f = Math.pow(2, g), g++), u[_])
            y = u[_];
          else if (_ === p)
            y = b + b.charAt(0);
          else
            return null;
          m.push(y), u[p++] = b + y.charAt(0), f--, b = y, f == 0 && (f = Math.pow(2, g), g++);
        }
      }
    };
    return a;
  }();
  t != null ? t.exports = e : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
    return e;
  });
})(j5);
var vZe = j5.exports;
const aR = /* @__PURE__ */ Wr(vZe), R5 = "web image/vnd.tldraw+png", bZe = {
  png: R5
}, xZe = {
  [R5]: "image/png"
};
function wZe(t) {
  return Fr(bZe, t) ?? null;
}
function SZe(t) {
  return Fr(xZe, t) ?? t;
}
function CZe(t) {
  return typeof ClipboardItem < "u" && "supports" in ClipboardItem && ClipboardItem.supports(t);
}
function _Ze(t) {
  const e = Object.entries(t);
  for (const [n, r] of e) r.catch((s) => console.error(s));
  return navigator.clipboard.write([new ClipboardItem(t)]).catch((n) => (console.error(n), Promise.all(
    e.map(async ([r, s]) => [r, await s])
  ).then((r) => {
    const s = AJ(r);
    return navigator.clipboard.write([new ClipboardItem(s)]);
  })));
}
async function EZe(t, e, n, r) {
  const s = e.map(
    (o) => o instanceof File ? o : new File([o], "tldrawFile", { type: o.type })
  );
  t.markHistoryStoppingPoint("paste"), await t.putExternalContent({
    type: "files",
    files: s,
    point: n,
    sources: r
  });
}
async function cR(t, e, n, r) {
  return t.markHistoryStoppingPoint("paste"), await t.putExternalContent({
    type: "url",
    point: n,
    url: e,
    sources: r
  });
}
const TZe = [
  R5,
  "image/png",
  "image/jpeg",
  "image/webp",
  "image/svg+xml"
];
function LO(t) {
  const e = document.implementation.createHTMLDocument("");
  return e.documentElement.innerHTML = t.trim(), e.body.textContent || e.body.innerText || "";
}
const PZe = (t) => {
  try {
    const e = new URL(t);
    return e.protocol === "http:" || e.protocol === "https:";
  } catch {
    return !1;
  }
}, IZe = (t) => {
  const e = t.split(/[\n\s]/);
  for (const n of e)
    try {
      const r = new URL(n);
      if (!(r.protocol === "http:" || r.protocol === "https:"))
        return;
    } catch {
      return;
    }
  return aie(e);
}, kZe = (t) => /^<svg/.test(t), AZe = ["input", "select", "textarea"];
function FO(t) {
  const { activeElement: e } = document;
  return t.menus.hasAnyOpenMenus() || e && (e.isContentEditable || AZe.indexOf(e.tagName.toLowerCase()) > -1);
}
const H1 = (t, e, n, r) => {
  const s = IZe(e);
  if (s)
    for (const o of s)
      cR(t, o, n);
  else PZe(e) ? cR(t, e, n) : kZe(e) ? (t.markHistoryStoppingPoint("paste"), t.putExternalContent({
    type: "svg-text",
    text: e,
    point: n,
    sources: r
  })) : (t.markHistoryStoppingPoint("paste"), t.putExternalContent({
    type: "text",
    text: e,
    point: n,
    sources: r
  }));
}, MZe = async (t, e, n) => {
  if (t.getEditingShapeId() !== null) return;
  if (!e)
    throw Error("No clipboard data");
  const r = [];
  for (const s of Object.values(e.items))
    switch (s.kind) {
      case "file": {
        r.push({
          type: "file",
          source: new Promise((o) => o(s.getAsFile()))
        });
        break;
      }
      case "string": {
        s.type === "text/html" ? r.push({
          type: "html",
          source: new Promise((o) => s.getAsString(o))
        }) : s.type === "text/plain" ? r.push({
          type: "text",
          source: new Promise((o) => s.getAsString(o))
        }) : r.push({ type: s.type, source: new Promise((o) => s.getAsString(o)) });
        break;
      }
    }
  pue(t, r, n);
}, hue = async ({
  editor: t,
  clipboardItems: e,
  point: n,
  fallbackFiles: r
}) => {
  const s = [];
  for (const o of e) {
    for (const i of TZe)
      if (o.types.includes(i)) {
        const a = o.getType(i).then((c) => oi.rewriteMimeType(c, SZe(i)));
        s.push({
          type: "blob",
          source: a
        });
        break;
      }
    o.types.includes("text/html") && s.push({
      type: "html",
      source: (async () => {
        const i = await o.getType("text/html");
        return await oi.blobToText(i);
      })()
    }), o.types.includes("text/uri-list") && s.push({
      type: "url",
      source: (async () => {
        const i = await o.getType("text/uri-list");
        return await oi.blobToText(i);
      })()
    }), o.types.includes("text/plain") && s.push({
      type: "text",
      source: (async () => {
        const i = await o.getType("text/plain");
        return await oi.blobToText(i);
      })()
    });
  }
  return r != null && r.length && s.length === 1 && s[0].type === "text" ? (s.pop(), s.push(
    ...r.map((o) => ({ type: "file", source: Promise.resolve(o) }))
  )) : r != null && r.length && s.length === 0 && s.push(
    ...r.map((o) => ({ type: "file", source: Promise.resolve(o) }))
  ), await pue(t, s, n);
};
async function pue(t, e, n) {
  const r = e.filter(
    (o) => (o.type === "file" || o.type === "blob") && o.source !== null
  );
  if (r.length) {
    if (r.length > t.options.maxFilesAtOnce)
      throw Error("Too many files");
    const o = mt(await Promise.all(r.map((i) => i.source)));
    return await EZe(t, o, n);
  }
  const s = await Promise.all(
    e.filter((o) => o.type !== "file").map(
      (o) => new Promise((i) => {
        const a = o;
        if (a.type === "file") {
          i({ type: "error", data: null, reason: "unexpected file" });
          return;
        }
        a.source.then((c) => {
          var d;
          const l = (d = c.match(/<div data-tldraw[^>]*>(.*)<\/div>/)) == null ? void 0 : d[1];
          if (l)
            try {
              let u;
              try {
                u = JSON.parse(l);
              } catch {
                const f = aR.decompressFromBase64(l);
                if (f === null) {
                  i({
                    type: "error",
                    data: null,
                    reason: "found tldraw data comment but could not parse"
                  });
                  return;
                }
                u = JSON.parse(f);
              }
              if (u.type !== "application/tldraw") {
                i({
                  type: "error",
                  data: u,
                  reason: `found tldraw data comment but JSON was of a different type: ${u.type}`
                });
                return;
              }
              if (u.version === 3)
                try {
                  const f = JSON.parse(
                    aR.decompressFromBase64(u.data.otherCompressed) || "{}"
                  ), p = {
                    assets: u.data.assets || [],
                    ...f
                  };
                  i({ type: "tldraw", data: p });
                  return;
                } catch (f) {
                  i({
                    type: "error",
                    data: u,
                    reason: `failed to decompress version 2 clipboard data: ${f}`
                  });
                  return;
                }
              if (u.version === 2)
                i({ type: "tldraw", data: u.data });
              else {
                if (typeof u.data == "string") {
                  i({
                    type: "error",
                    data: u,
                    reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
                  });
                  return;
                }
                i({ type: "tldraw", data: u.data });
                return;
              }
            } catch {
              i({
                type: "error",
                data: l,
                reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
              });
              return;
            }
          else {
            if (a.type === "html") {
              i({ type: "text", data: c, subtype: "html" });
              return;
            }
            if (a.type === "url") {
              i({ type: "text", data: c, subtype: "url" });
              return;
            }
            try {
              const u = JSON.parse(c);
              if (u.type === "excalidraw/clipboard") {
                i({ type: "excalidraw", data: u });
                return;
              } else {
                i({ type: "text", data: c, subtype: "json" });
                return;
              }
            } catch {
              i({ type: "text", data: c, subtype: "text" });
              return;
            }
          }
          i({ type: "error", data: c, reason: "unhandled case" });
        });
      })
    )
  );
  for (const o of s)
    if (o.type === "tldraw") {
      t.markHistoryStoppingPoint("paste"), t.putExternalContent({ type: "tldraw", content: o.data, point: n });
      return;
    }
  for (const o of s)
    if (o.type === "excalidraw") {
      t.markHistoryStoppingPoint("paste"), t.putExternalContent({ type: "excalidraw", content: o.data, point: n });
      return;
    }
  for (const o of s) {
    if (o.type === "text" && o.subtype === "html") {
      const a = new DOMParser().parseFromString(o.data, "text/html").querySelector("body");
      if (a && Array.from(a.children).filter((l) => l.nodeType === 1).length === 1 && a.firstElementChild && a.firstElementChild.tagName === "A" && a.firstElementChild.hasAttribute("href") && a.firstElementChild.getAttribute("href") !== "") {
        const l = a.firstElementChild.getAttribute("href");
        H1(t, l, n, s);
        return;
      }
      if (!s.some((l) => l.type === "text" && l.subtype !== "html") && o.data.trim() && (LO(o.data) ?? "")) {
        H1(t, LO(o.data), n, s);
        return;
      }
      if (s.some((l) => l.type === "text" && l.subtype !== "html")) {
        const l = LO(o.data) ?? "";
        if (l) {
          t.markHistoryStoppingPoint("paste"), t.putExternalContent({
            type: "text",
            text: l,
            html: o.data,
            point: n,
            sources: s
          });
          return;
        }
      }
    }
    if (o.type === "text" && o.subtype === "text" && o.data.startsWith("<iframe ")) {
      const a = new DOMParser().parseFromString(o.data, "text/html").querySelector("body");
      if (a && Array.from(a.children).filter((l) => l.nodeType === 1).length === 1 && a.firstElementChild && a.firstElementChild.tagName === "IFRAME" && a.firstElementChild.hasAttribute("src") && a.firstElementChild.getAttribute("src") !== "") {
        const l = a.firstElementChild.getAttribute("src");
        H1(t, l, n, s);
        return;
      }
    }
  }
  for (const o of s)
    if (o.type === "text" && o.subtype === "url") {
      cR(t, o.data, n, s);
      return;
    }
  for (const o of s)
    if (o.type === "text" && o.subtype === "text" && o.data.trim()) {
      H1(t, o.data, n, s);
      return;
    }
}
const uT = async (t) => {
  var i;
  const e = await t.resolveAssetsInContent(
    t.getContentFromCurrentPage(t.getSelectedShapeIds())
  );
  if (!e) {
    navigator && navigator.clipboard && navigator.clipboard.writeText("");
    return;
  }
  const { assets: n, ...r } = e, s = {
    type: "application/tldraw",
    kind: "content",
    version: 3,
    data: {
      assets: n || [],
      // Plain JSON, no compression
      otherCompressed: aR.compressToBase64(JSON.stringify(r))
      // Only compress non-asset data
    }
  }, o = JSON.stringify(s);
  if (!(typeof navigator > "u")) {
    const a = e.shapes.map((c) => t.getShapeUtil(c).getText(c)).filter(hDe);
    if ((i = navigator.clipboard) != null && i.write) {
      const c = new Blob([`<div data-tldraw>${o}</div>`], {
        type: "text/html"
      });
      let l = a.join(" ");
      l === "" && (l = " "), navigator.clipboard.write([
        new ClipboardItem({
          "text/html": c,
          // What is this second blob used for?
          "text/plain": new Blob([l], { type: "text/plain" })
        })
      ]);
    } else navigator.clipboard.writeText && navigator.clipboard.writeText(`<div data-tldraw>${o}</div>`);
  }
};
function OZe() {
  const t = uo(), e = xr(), n = re(
    async function(i) {
      tt(t, "editor is required for copy"), t.getSelectedShapeIds().length !== 0 && (await uT(t), e("copy", { source: i }));
    },
    [t, e]
  ), r = re(
    async function(i) {
      t && t.getSelectedShapeIds().length !== 0 && (await uT(t), t.deleteShapes(t.getSelectedShapeIds()), e("cut", { source: i }));
    },
    [t, e]
  ), s = re(
    async function(i, a, c) {
      t && t.getEditingShapeId() === null && (Array.isArray(i) && i[0] instanceof ClipboardItem ? (hue({ editor: t, clipboardItems: i, point: c }), e("paste", { source: "menu" })) : navigator.clipboard.read().then((l) => {
        s(l, a, c);
      }));
    },
    [t, e]
  );
  return {
    copy: n,
    cut: r,
    paste: s
  };
}
function DZe() {
  const t = ie(), e = xr(), n = le("editor.isFocused", () => t.getInstanceState().isFocused, [
    t
  ]);
  me(() => {
    if (!n) return;
    const r = async (c) => {
      t.getSelectedShapeIds().length === 0 || t.getEditingShapeId() !== null || FO(t) || (xt(c), await uT(t), e("copy", { source: "kbd" }));
    };
    async function s(c) {
      t.getSelectedShapeIds().length === 0 || t.getEditingShapeId() !== null || FO(t) || (xt(c), await uT(t), t.deleteShapes(t.getSelectedShapeIds()), e("cut", { source: "kbd" }));
    }
    let o = !1;
    const i = (c) => {
      c.button === 1 && (o = !0, t.timers.requestAnimationFrame(() => {
        o = !1;
      }));
    }, a = (c) => {
      var f, p;
      if (o) {
        cr(c);
        return;
      }
      if (t.getEditingShapeId() !== null || FO(t)) return;
      let l, d = !1;
      t.inputs.shiftKey && (d = !0), t.user.getIsPasteAtCursorMode() && (d = !d), d && (l = t.inputs.currentPagePoint);
      const u = () => {
        c.clipboardData && MZe(t, c.clipboardData, l);
      };
      if ((f = navigator.clipboard) != null && f.read) {
        const g = Array.from(((p = c.clipboardData) == null ? void 0 : p.files) || []);
        navigator.clipboard.read().then(
          (y) => {
            Array.isArray(y) && y[0] instanceof ClipboardItem && hue({ editor: t, clipboardItems: y, point: l, fallbackFiles: g });
          },
          () => {
            u();
          }
        );
      } else
        u();
      xt(c), e("paste", { source: "kbd" });
    };
    return document.addEventListener("copy", r), document.addEventListener("cut", s), document.addEventListener("paste", a), document.addEventListener("pointerup", i), () => {
      document.removeEventListener("copy", r), document.removeEventListener("cut", s), document.removeEventListener("paste", a), document.removeEventListener("pointerup", i);
    };
  }, [t, e, n]);
}
const gV = {
  jpeg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  svg: "text/plain"
};
function NZe(t, e, n = {}) {
  const r = e != null && e.length ? e : [...t.getCurrentPageShapeIds()], s = n.format ?? "png";
  return {
    blobPromise: t.toImage(r, n).then(
      (o) => oi.rewriteMimeType(o.blob, gV[s])
    ),
    mimeType: gV[s]
  };
}
function jZe(...t) {
  const [e, n, r] = typeof t[2] == "string" ? [t[0], t[1], { ...t[3], format: t[2] }] : t;
  if (!navigator.clipboard) return Promise.reject(new Error("Copy not supported"));
  if (navigator.clipboard.write) {
    const { blobPromise: s, mimeType: o } = NZe(e, n, r), i = { [o]: s }, a = wZe(r.format);
    return a && CZe(a) && (i[a] = s.then(
      (c) => oi.rewriteMimeType(c, a)
    )), _Ze(i);
  }
  switch (r.format) {
    case "svg":
      return RZe(async () => {
        const s = await e.getSvgString(n, r);
        if (!s) throw new Error("Failed to copy");
        return s.svg;
      });
    case "png":
      throw new Error("Copy not supported");
    default:
      Jt(r.format);
  }
}
async function RZe(t) {
  var e, n;
  await ((n = (e = navigator.clipboard) == null ? void 0 : e.writeText) == null ? void 0 : n.call(e, await t()));
}
function $Ze() {
  const t = uo(), { addToast: e } = bu(), n = Ze();
  return re(
    (r, s = "svg") => {
      tt(t, "useCopyAs: editor is required"), jZe(t, r, { format: s }).catch(() => {
        e({
          id: "copy-fail",
          severity: "warning",
          title: n("toast.error.copy-fail.title"),
          description: n("toast.error.copy-fail.desc")
        });
      });
    },
    [t, e, n]
  );
}
async function LZe(...t) {
  const [e, n, r] = typeof t[2] == "object" ? t : [t[0], t[1], { ...t[4], format: t[2] ?? "png", name: t[3] }];
  let s = r.name;
  if (!s && (s = `shapes at ${mV()}`, n.length === 1)) {
    const a = e.getShape(n[0]);
    e.isShapeOfType(a, "frame") ? s = a.props.name || "frame" : s = `${jI(a.id)} at ${mV()}`;
  }
  s += `.${r.format}`;
  const { blob: o } = await e.toImage(n, r), i = new File([o], s, { type: o.type });
  FZe(i);
}
function mV() {
  const t = /* @__PURE__ */ new Date(), e = String(t.getFullYear()).slice(2), n = String(t.getMonth() + 1).padStart(2, "0"), r = String(t.getDate()).padStart(2, "0"), s = String(t.getHours()).padStart(2, "0"), o = String(t.getMinutes()).padStart(2, "0"), i = String(t.getSeconds()).padStart(2, "0");
  return `${e}-${n}-${r} ${s}.${o}.${i}`;
}
function FZe(t) {
  const e = document.createElement("a"), n = URL.createObjectURL(t);
  e.href = n, e.download = t.name, e.click(), URL.revokeObjectURL(n);
}
function BZe() {
  const t = uo(), { addToast: e } = bu(), n = Ze();
  return re(
    (r, s = "png", o) => {
      tt(t, "useExportAs: editor is required"), LZe(t, r, {
        format: s,
        name: o,
        scale: 1
      }).catch((i) => {
        console.error(i.message), e({
          id: "export-fail",
          title: n("toast.error.export-fail.title"),
          description: n("toast.error.export-fail.desc"),
          severity: "error"
        });
      });
    },
    [t, e, n]
  );
}
function zZe() {
  const t = uo(), e = fe(null), n = fe(null);
  return re(
    async function() {
      tt(t, "usePrint: editor is required");
      const s = document.createElement("div"), o = document.createElement("style"), i = (v, b) => {
        v && (v.innerHTML = ""), b && document.head.contains(b) && document.head.removeChild(b), v && document.body.contains(v) && document.body.removeChild(v);
      };
      i(e.current, n.current), e.current = s, n.current = o;
      const a = `tl-print-surface-${bn()}`;
      s.className = a, o.innerHTML = `
			.${a} {
				display: none;
			}

			.${a} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.tldraw__editor {
					display: none;
				}

				.${a} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${a}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${a}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${a}__item__header {
					display: none;
				}

				.${a}__item__footer {
					display: none;
					text-align: right;
				}

				.${a}__item__footer__hide {
					display: none;
				}

				
			}

		`;
      const c = () => {
        document.head.appendChild(o), document.body.appendChild(s);
      }, l = () => {
        t.once("tick", () => {
          i(s, o);
        });
      };
      window.addEventListener("beforeprint", c), window.addEventListener("afterprint", l);
      function d(v, b, x) {
        try {
          s.innerHTML += `<div class="${a}__item">
        <div class="${a}__item__header">
          ${v.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${a}__item__main">
          ${x}
        </div>
        <div class="${a}__item__footer ${a}__item__footer__${b ? "" : "hide"}">
          ${b ?? ""}
        </div>
      </div>`;
        } catch (w) {
          console.error(w);
        }
      }
      function u() {
        dn.isChromeForIos ? (c(), window.print()) : dn.isSafari ? (c(), document.execCommand("print", !1)) : window.print();
      }
      const f = t.getSelectedShapeIds(), p = t.getCurrentPageId(), g = t.getPages(), m = {
        scale: 1,
        background: !1,
        darkMode: !1,
        preserveAspectRatio: "xMidYMid meet"
      };
      if (t.getSelectedShapeIds().length > 0) {
        const v = await t.getSvgString(f, m);
        if (v) {
          const b = g.find((x) => x.id === p);
          d(`tldraw  ${b == null ? void 0 : b.name}`, null, v.svg), u();
        }
      } else {
        const v = t.getCurrentPage(), b = await t.getSvgString(
          t.getSortedChildIdsForParent(v.id),
          m
        );
        b && (d(`tldraw  ${v.name}`, null, b.svg), u());
      }
      window.removeEventListener("beforeprint", c), window.removeEventListener("afterprint", l);
    },
    [t]
  );
}
const gue = zn([]);
function $5() {
  const t = uo(), { addToast: e, removeToast: n, clearToasts: r } = bu(), { addDialog: s, clearDialogs: o, removeDialog: i } = gS(), a = Ze(), c = zZe(), { cut: l, copy: d, paste: u } = OZe(), f = $Ze(), p = BZe(), g = N5(), m = Uo() < Ir.TABLET_SM, v = Yu(tn(gue)), b = re(async () => {
    if (!t) return;
    const C = await pV({
      allowMultiple: !0,
      mimeTypes: v
    });
    C.length && (t.markHistoryStoppingPoint("insert media"), t.putExternalContent({
      type: "files",
      files: C,
      point: t.getViewportPageBounds().center
    }));
  }, [t, v]), x = re(
    async (C) => {
      if (!t) return;
      const _ = await pV({
        allowMultiple: !1,
        mimeTypes: v == null ? void 0 : v.filter(
          (N) => C ? N.startsWith("image/") : N.startsWith("video/")
        )
      });
      if (!_.length) return;
      const E = t.getOnlySelectedShape();
      if (!E || C && E.type !== "image" || !C && E.type !== "video")
        return;
      t.markHistoryStoppingPoint("replace media");
      const M = _[0];
      t.replaceExternalContent({
        type: "file-replace",
        file: M,
        shapeId: E.id,
        isImage: C
      });
    },
    [t, v]
  ), w = re(() => x(
    !0
    /* isImage */
  ), [x]), S = re(() => x(
    !1
    /* isImage */
  ), [x]);
  return Ke(
    () => ({
      addToast: e,
      removeToast: n,
      clearToasts: r,
      addDialog: s,
      removeDialog: i,
      clearDialogs: o,
      msg: a,
      isMobile: m,
      insertMedia: b,
      replaceImage: w,
      replaceVideo: S,
      printSelectionOrPages: c,
      cut: l,
      copy: d,
      paste: u,
      copyAs: f,
      exportAs: p,
      getEmbedDefinition: g
    }),
    [
      e,
      n,
      r,
      s,
      i,
      o,
      a,
      m,
      b,
      w,
      S,
      c,
      l,
      d,
      u,
      f,
      p,
      g
    ]
  );
}
function UZe(t, e) {
  const n = {};
  for (const r of t)
    if (r.translations)
      for (const [s, o] of ai(r.translations)) {
        let i = n[s];
        i || (i = n[s] = {}), Object.assign(i, o);
      }
  return {
    actions: (r, s, o) => {
      for (const i of t)
        i.actions && (s = i.actions(r, s, o));
      return s;
    },
    tools: (r, s, o) => {
      for (const i of t)
        i.tools && (s = i.tools(r, s, { ...e, ...o }));
      return s;
    },
    translations: n
  };
}
function mue(t) {
  return Ke(() => t, t);
}
function yue(t) {
  const e = mue(
    t == null ? [] : Array.isArray(t) ? t : [t]
  );
  return Ke(() => {
    const n = {};
    for (const r of e)
      if (r.translations)
        for (const [s, o] of ai(r.translations)) {
          let i = n[s];
          i || (i = n[s] = {}), Object.assign(i, o);
        }
    return n;
  }, [e]);
}
function HZe(t) {
  const e = $5(), n = mue(
    t == null ? [] : Array.isArray(t) ? t : [t]
  );
  return Ke(
    () => UZe(n, e),
    [n, e]
  );
}
const vue = T.createContext(null);
function VZe({ overrides: t, children: e }) {
  const n = uo(), r = xr(), s = hk(), o = Ze(), i = $5(), a = T.useCallback(
    (l, d, u) => {
      s.announce({ msg: o(d.label) }), r("select-tool", { source: l, id: u ?? d.id });
    },
    [s, o, r]
  ), c = T.useMemo(() => {
    if (!n) return {};
    const l = [
      {
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: !0,
        onSelect(u) {
          if (n.isIn("select")) {
            const f = n.root.getCurrent();
            f.exit({}, f.id), f.enter({}, f.id);
          }
          n.setCurrentTool("select"), a(u, this);
        }
      },
      {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: !0,
        onSelect(u) {
          n.setCurrentTool("hand"), a(u, this);
        }
      },
      {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        onSelect(u) {
          n.setCurrentTool("eraser"), a(u, this);
        }
      },
      {
        id: "draw",
        label: "tool.draw",
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect(u) {
          n.setCurrentTool("draw"), a(u, this);
        }
      },
      ...[...Hc.values].map((u) => ({
        id: u,
        label: `tool.${u}`,
        meta: {
          geo: u
        },
        kbd: u === "rectangle" ? "r" : u === "ellipse" ? "o" : void 0,
        icon: "geo-" + u,
        onSelect(f) {
          n.run(() => {
            n.setStyleForNextShapes(Hc, u), n.setCurrentTool("geo"), a(f, this, `geo-${u}`);
          });
        }
      })),
      {
        id: "arrow",
        label: "tool.arrow",
        icon: "tool-arrow",
        kbd: "a",
        onSelect(u) {
          n.setCurrentTool("arrow"), a(u, this);
        }
      },
      {
        id: "line",
        label: "tool.line",
        icon: "tool-line",
        kbd: "l",
        onSelect(u) {
          n.setCurrentTool("line"), a(u, this);
        }
      },
      {
        id: "frame",
        label: "tool.frame",
        icon: "tool-frame",
        kbd: "f",
        onSelect(u) {
          n.setCurrentTool("frame"), a(u, this);
        }
      },
      {
        id: "text",
        label: "tool.text",
        icon: "tool-text",
        kbd: "t",
        onSelect(u) {
          n.setCurrentTool("text"), a(u, this);
        }
      },
      {
        id: "asset",
        label: "tool.media",
        icon: "tool-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(u) {
          i.insertMedia(), a(u, this, "media");
        }
      },
      {
        id: "note",
        label: "tool.note",
        icon: "tool-note",
        kbd: "n",
        onSelect(u) {
          n.setCurrentTool("note"), a(u, this);
        }
      },
      {
        id: "laser",
        label: "tool.laser",
        readonlyOk: !0,
        icon: "tool-laser",
        kbd: "k",
        onSelect(u) {
          n.setCurrentTool("laser"), a(u, this);
        }
      },
      {
        id: "embed",
        label: "tool.embed",
        icon: "dot",
        onSelect(u) {
          i.addDialog({ component: lue }), a(u, this);
        }
      },
      {
        id: "highlight",
        label: "tool.highlight",
        icon: "tool-highlight",
        // TODO: pick a better shortcut
        kbd: "shift+d",
        onSelect(u) {
          n.setCurrentTool("highlight"), a(u, this);
        }
      }
    ];
    l.forEach((u) => u.onSelect = u.onSelect.bind(u));
    const d = Object.fromEntries(l.map((u) => [u.id, u]));
    return t ? t(n, d, i) : d;
  }, [t, n, i, a]);
  return /* @__PURE__ */ h.jsx(vue.Provider, { value: c, children: e });
}
function L5() {
  const t = T.useContext(vue);
  if (!t)
    throw new Error("useTools must be used within a ToolProvider");
  return t;
}
function wi({ toolId: t = "", ...e }) {
  const r = L5()[t];
  return r ? /* @__PURE__ */ h.jsx(Zt, { ...r, ...e }) : null;
}
function WZe() {
  const t = Ok();
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs(At, { label: "shortcuts-dialog.tools", id: "tools", children: [
      /* @__PURE__ */ h.jsx(be, { actionId: "toggle-tool-lock" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "insert-media" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "select" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "draw" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "eraser" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "hand" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "rectangle" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "ellipse" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "arrow" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "line" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "text" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "frame" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "note" }),
      /* @__PURE__ */ h.jsx(wi, { toolId: "laser" }),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "pointer-down",
          label: "tool.pointer-down",
          kbd: ",",
          onSelect: () => {
          }
        }
      )
    ] }),
    /* @__PURE__ */ h.jsxs(At, { label: "shortcuts-dialog.preferences", id: "preferences", children: [
      /* @__PURE__ */ h.jsx(be, { actionId: "toggle-dark-mode" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "toggle-focus-mode" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "toggle-grid" })
    ] }),
    /* @__PURE__ */ h.jsxs(At, { label: "shortcuts-dialog.edit", id: "edit", children: [
      /* @__PURE__ */ h.jsx(be, { actionId: "undo" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "redo" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "cut" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "copy" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "paste" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "select-all" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "delete" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "duplicate" })
    ] }),
    /* @__PURE__ */ h.jsxs(At, { label: "shortcuts-dialog.view", id: "view", children: [
      /* @__PURE__ */ h.jsx(be, { actionId: "zoom-in" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "zoom-out" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "zoom-to-100" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "zoom-to-fit" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "zoom-to-selection" })
    ] }),
    /* @__PURE__ */ h.jsxs(At, { label: "shortcuts-dialog.transform", id: "transform", children: [
      /* @__PURE__ */ h.jsx(be, { actionId: "bring-to-front" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "bring-forward" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "send-backward" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "send-to-back" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "group" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "ungroup" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "flip-horizontal" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "flip-vertical" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-top" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-center-vertical" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-bottom" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-left" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-center-horizontal" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-right" })
    ] }),
    /* @__PURE__ */ h.jsxs(At, { label: "shortcuts-dialog.text-formatting", id: "text", children: [
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "text-bold",
          label: "tool.rich-text-bold",
          kbd: "cmd+b",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "text-italic",
          label: "tool.rich-text-italic",
          kbd: "cmd+i",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "text-code",
          label: "tool.rich-text-code",
          kbd: "cmd+e",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "text-highlight",
          label: "tool.rich-text-highlight",
          kbd: "cmd+shift+h",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "text-strikethrough",
          label: "tool.rich-text-strikethrough",
          kbd: "cmd+shift+s",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "text-link",
          label: "tool.rich-text-link",
          kbd: "cmd+shift+k",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "text-header",
          label: "tool.rich-text-header",
          kbd: "cmd+shift+[[1-6]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "text-orderedList",
          label: "tool.rich-text-orderedList",
          kbd: "cmd+shift+7",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "text-bulletedlist",
          label: "tool.rich-text-bulletList",
          kbd: "cmd+shift+8",
          onSelect: () => {
          }
        }
      )
    ] }),
    /* @__PURE__ */ h.jsxs(At, { label: "shortcuts-dialog.a11y", id: "a11y", children: [
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "a11y-select-next-shape",
          label: "a11y.select-shape",
          kbd: "[[Tab]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "a11y-select-next-shape-direction",
          label: "a11y.select-shape-direction",
          kbd: "cmd+",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "a11y-select-next-shape-container",
          label: "a11y.enter-leave-container",
          kbd: "cmd+shift+",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "a11y-pan-camera",
          label: "a11y.pan-camera",
          kbd: "[[Space]]+",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "adjust-shape-styles",
          label: "a11y.adjust-shape-styles",
          kbd: "cmd+[[Enter]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "open-context-menu",
          label: "a11y.open-context-menu",
          kbd: "cmd+shift+[[Enter]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "a11y-move-shape",
          label: "a11y.move-shape",
          kbd: "",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "a11y-move-shape-faster",
          label: "a11y.move-shape-faster",
          kbd: "shift+",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ h.jsx(be, { actionId: "enlarge-shapes" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "shrink-shapes" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "a11y-repeat-shape-announce" }),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "a11y-open-keyboard-shortcuts",
          label: "a11y.open-keyboard-shortcuts",
          kbd: "cmd+alt+/",
          onSelect: () => {
          }
        }
      )
    ] }),
    t && /* @__PURE__ */ h.jsx(At, { label: "shortcuts-dialog.collaboration", id: "collaboration", children: /* @__PURE__ */ h.jsx(be, { actionId: "open-cursor-chat" }) })
  ] });
}
const bue = it(function({
  children: e
}) {
  const n = Ze(), r = Uo(), s = e ?? /* @__PURE__ */ h.jsx(WZe, {});
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs(Ik, { className: "tlui-shortcuts-dialog__header", children: [
      /* @__PURE__ */ h.jsx(kk, { children: n("shortcuts-dialog.title") }),
      /* @__PURE__ */ h.jsx(Ak, {})
    ] }),
    /* @__PURE__ */ h.jsx(
      Ew,
      {
        className: Je("tlui-shortcuts-dialog__body", {
          "tlui-shortcuts-dialog__body__mobile": r <= Ir.MOBILE_XS,
          "tlui-shortcuts-dialog__body__tablet": r <= Ir.TABLET
        }),
        children: /* @__PURE__ */ h.jsx(pi, { type: "keyboard-shortcuts", sourceId: "kbd", children: s })
      }
    ),
    /* @__PURE__ */ h.jsx("div", { className: "tlui-dialog__scrim" })
  ] });
});
async function KZe(t, e, n) {
  const r = mt(
    e.map((a) => {
      const c = t.getShape(a);
      if (!(!c || t.getShapeUtil(c.type).toSvg === void 0))
        return c;
    })
  );
  if (r.length === 0) return;
  if (r.length === 1) {
    const a = r[0];
    if (!a || t.isShapeOfType(a, "image")) return;
  }
  const s = [];
  if (n !== void 0) {
    const a = r.map((c) => ({
      shape: c,
      bounds: t.getShapeMaskedPageBounds(c).clone().expandBy(n)
    }));
    for (let c = 0; c < a.length; c++) {
      const l = a[c];
      if (c === 0) {
        s[0] = {
          shapes: [l.shape],
          bounds: l.bounds
        };
        continue;
      }
      let d = !1;
      for (const u of s)
        if (u.bounds.includes(l.bounds)) {
          u.shapes.push(l.shape), u.bounds.expand(l.bounds), d = !0;
          break;
        }
      d || s.push({
        shapes: [l.shape],
        bounds: l.bounds
      });
    }
  } else {
    const a = _e.Common(r.map((c) => t.getShapeMaskedPageBounds(c)));
    s.push({
      shapes: r,
      bounds: a
    });
  }
  const o = t.options.flattenImageBoundsPadding;
  for (const a of s) {
    n !== void 0 && a.bounds.expandBy(-n);
    const c = await t.getSvgString(a.shapes, {
      padding: o,
      background: !1
    });
    if (!(c != null && c.svg)) continue;
    const l = await t.getAssetForExternalContent({
      type: "file",
      file: new File([c.svg], "asset.svg", { type: "image/svg+xml" })
    });
    l && (a.asset = l);
  }
  const i = [];
  return va(() => {
    for (const a of s) {
      const { asset: c, bounds: l, shapes: d } = a;
      if (!c) continue;
      const u = t.findCommonAncestor(d) ?? t.getCurrentPageId();
      if (!u) continue;
      let f = "a1";
      for (const v of d)
        if (v.parentId === u) {
          v.index > f && (f = v.index);
          break;
        }
      let p, g, y;
      if (ei(u)) {
        const v = t.getShape(u);
        if (!v) continue;
        const b = t.getPointInShapeSpace(v, {
          x: l.x,
          y: l.y
        });
        y = t.getShapePageTransform(u).rotation(), b.sub(new I(o, o).rot(-y)), p = b.x, g = b.y;
      } else
        p = l.x - o, g = l.y - o, y = 0;
      t.deleteShapes(d), t.createAssets([{ ...c, id: c.id }]);
      const m = $n();
      t.createShape({
        id: m,
        type: "image",
        index: f,
        parentId: u,
        x: p,
        y: g,
        rotation: -y,
        props: {
          assetId: c.id,
          w: l.w + o * 2,
          h: l.h + o * 2
        }
      }), i.push(m);
    }
  }), i;
}
const xue = T.createContext(null);
function wue(t, e) {
  return (e.isShapeOfType(t, "image") || e.isShapeOfType(t, "video")) && !!t.props.assetId;
}
function GZe(t) {
  return Object.fromEntries(t.map((e) => [e.id, e]));
}
function V1(t, e) {
  if (t.getSelectedShapes().length === 0)
    return t.getDocumentSettings().name || e;
}
function YZe({ overrides: t, children: e }) {
  const n = uo(), r = Ok(), s = $5(), o = xr(), i = hk(), a = Ze(), c = s.msg("document.default-name"), l = T.useMemo(() => {
    const d = n;
    if (!d) return {};
    function u() {
      return d.isIn("select") || (d.complete(), d.setCurrentTool("select")), !1;
    }
    function f() {
      return d.isIn("select") && d.getSelectedShapeIds().length > 0;
    }
    function p(m) {
      if (!f() || u()) return;
      d.markHistoryStoppingPoint("resize shapes");
      const v = d.getSelectedShapeIds();
      v.length !== 0 && d.run(() => {
        v.map((x) => d.getShape(x)).filter(Boolean).forEach((x) => {
          var w;
          d.resizeShape(x.id, new I(m, m), {
            scaleOrigin: (w = d.getSelectionPageBounds()) == null ? void 0 : w.center
          });
        });
      });
    }
    const g = [
      {
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        onSelect(m) {
          f() && (u() || (o("edit-link", { source: m }), d.markHistoryStoppingPoint("edit-link"), s.addDialog({ component: JXe })));
        }
      },
      {
        id: "insert-embed",
        label: "action.insert-embed",
        kbd: "cmd+i,ctrl+i",
        onSelect(m) {
          o("insert-embed", { source: m }), s.addDialog({ component: lue });
        }
      },
      {
        id: "open-kbd-shortcuts",
        label: "action.open-kbd-shortcuts",
        kbd: "cmd+alt+/,ctrl+alt+/",
        onSelect(m) {
          o("open-kbd-shortcuts", { source: m }), s.addDialog({ component: bue });
        }
      },
      {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(m) {
          o("insert-media", { source: m }), s.insertMedia();
        }
      },
      {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "cmd+z,ctrl+z",
        onSelect(m) {
          o("undo", { source: m }), d.undo();
        }
      },
      {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "cmd+shift+z,ctrl+shift+z",
        onSelect(m) {
          o("redo", { source: m }), d.redo();
        }
      },
      {
        id: "export-as-svg",
        label: {
          default: "action.export-as-svg",
          menu: "action.export-as-svg.short",
          "context-menu": "action.export-as-svg.short"
        },
        readonlyOk: !0,
        onSelect(m) {
          let v = d.getSelectedShapeIds();
          v.length === 0 && (v = Array.from(d.getCurrentPageShapeIds().values())), v.length !== 0 && (o("export-as", { format: "svg", source: m }), s.exportAs(v, "svg", V1(d, c)));
        }
      },
      {
        id: "export-as-png",
        label: {
          default: "action.export-as-png",
          menu: "action.export-as-png.short",
          "context-menu": "action.export-as-png.short"
        },
        readonlyOk: !0,
        onSelect(m) {
          let v = d.getSelectedShapeIds();
          v.length === 0 && (v = Array.from(d.getCurrentPageShapeIds().values())), v.length !== 0 && (o("export-as", { format: "png", source: m }), s.exportAs(v, "png", V1(d, c)));
        }
      },
      {
        id: "export-all-as-svg",
        label: {
          default: "action.export-all-as-svg",
          menu: "action.export-all-as-svg.short",
          "context-menu": "action.export-all-as-svg.short"
        },
        readonlyOk: !0,
        onSelect(m) {
          let v = d.getSelectedShapeIds();
          v.length === 0 && (v = Array.from(d.getCurrentPageShapeIds().values())), v.length !== 0 && (o("export-all-as", { format: "svg", source: m }), s.exportAs(
            Array.from(d.getCurrentPageShapeIds()),
            "svg",
            V1(d, c)
          ));
        }
      },
      {
        id: "export-all-as-png",
        label: {
          default: "action.export-all-as-png",
          menu: "action.export-all-as-png.short",
          "context-menu": "action.export-all-as-png.short"
        },
        readonlyOk: !0,
        onSelect(m) {
          const v = Array.from(d.getCurrentPageShapeIds().values());
          v.length !== 0 && (o("export-all-as", { format: "png", source: m }), s.exportAs(v, "png", V1(d, c)));
        }
      },
      {
        id: "copy-as-svg",
        label: {
          default: "action.copy-as-svg",
          menu: "action.copy-as-svg.short",
          "context-menu": "action.copy-as-svg.short"
        },
        kbd: "cmd+shift+c,ctrl+shift+c",
        readonlyOk: !0,
        onSelect(m) {
          let v = d.getSelectedShapeIds();
          v.length === 0 && (v = Array.from(d.getCurrentPageShapeIds().values())), v.length !== 0 && (o("copy-as", { format: "svg", source: m }), s.copyAs(v, "svg"));
        }
      },
      {
        id: "copy-as-png",
        label: {
          default: "action.copy-as-png",
          menu: "action.copy-as-png.short",
          "context-menu": "action.copy-as-png.short"
        },
        readonlyOk: !0,
        onSelect(m) {
          let v = d.getSelectedShapeIds();
          v.length === 0 && (v = Array.from(d.getCurrentPageShapeIds().values())), v.length !== 0 && (o("copy-as", { format: "png", source: m }), s.copyAs(v, "png"));
        }
      },
      {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        onSelect(m) {
          f() && (u() || (o("toggle-auto-size", { source: m }), d.markHistoryStoppingPoint("toggling auto size"), d.run(() => {
            const v = d.getSelectedShapes().filter(
              (b) => d.isShapeOfType(b, "text") && b.props.autoSize === !1
            );
            d.updateShapes(
              v.map((b) => ({
                id: b.id,
                type: b.type,
                props: {
                  ...b.props,
                  w: 8,
                  autoSize: !0
                }
              }))
            ), An(
              d,
              v.map((b) => b.id)
            );
          })));
        }
      },
      {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: !0,
        onSelect(m) {
          o("open-embed-link", { source: m });
          const v = d.getSelectedShapeIds(), b = "No embed shapes selected";
          if (v.length !== 1) {
            console.error(b);
            return;
          }
          const x = d.getShape(v[0]);
          if (!x || !d.isShapeOfType(x, "embed")) {
            console.error(b);
            return;
          }
          gGe(x.props.url, "_blank");
        }
      },
      {
        id: "select-zoom-tool",
        readonlyOk: !0,
        kbd: "z",
        onSelect(m) {
          var v, b;
          if (((v = d.root.getCurrent()) == null ? void 0 : v.id) !== "zoom" && (o("zoom-tool", { source: m }), !(d.inputs.shiftKey || d.inputs.ctrlKey))) {
            const x = d.root.getCurrent();
            x && ((b = x.getCurrent()) == null ? void 0 : b.id) === "idle" && d.setCurrentTool("zoom", { onInteractionEnd: x.id, maskAs: "zoom" });
          }
        }
      },
      {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        onSelect(m) {
          f() && (u() || d.run(() => {
            o("convert-to-bookmark", { source: m });
            const v = d.getSelectedShapes(), b = [], x = [];
            for (const w of v) {
              if (!w || !d.isShapeOfType(w, "embed") || !w.props.url)
                continue;
              const S = new I(w.x, w.y);
              S.rot(-w.rotation), S.add(new I(w.props.w / 2 - 300 / 2, w.props.h / 2 - 320 / 2)), S.rot(w.rotation);
              const C = {
                id: $n(),
                type: "bookmark",
                rotation: w.rotation,
                x: S.x,
                y: S.y,
                opacity: 1,
                props: {
                  url: w.props.url
                }
              };
              b.push(C), x.push(w.id);
            }
            d.markHistoryStoppingPoint("convert shapes to bookmark"), d.deleteShapes(x), d.createShapes(b);
          }));
        }
      },
      {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        onSelect(m) {
          f() && (u() || (o("convert-to-embed", { source: m }), d.run(() => {
            const v = d.getSelectedShapeIds(), b = mt(v.map((S) => d.getShape(S))), x = [], w = [];
            for (const S of b) {
              if (!d.isShapeOfType(S, "bookmark")) continue;
              const { url: C } = S.props, _ = s.getEmbedDefinition(C);
              if (!_ || !_.definition) continue;
              const { width: E, height: M } = _.definition, N = new I(S.x, S.y);
              N.rot(-S.rotation), N.add(new I(S.props.w / 2 - E / 2, S.props.h / 2 - M / 2)), N.rot(S.rotation);
              const O = {
                id: $n(),
                type: "embed",
                x: N.x,
                y: N.y,
                rotation: S.rotation,
                props: {
                  url: C,
                  w: E,
                  h: M
                }
              };
              x.push(O), w.push(S.id);
            }
            d.markHistoryStoppingPoint("convert shapes to embed"), d.deleteShapes(w), d.createShapes(x);
          })));
        }
      },
      {
        id: "duplicate",
        kbd: "cmd+d,ctrl+d",
        label: "action.duplicate",
        icon: "duplicate",
        onSelect(m) {
          if (!f() || u()) return;
          o("duplicate-shapes", { source: m });
          const v = d.getInstanceState();
          let b, x;
          if (v.duplicateProps)
            b = v.duplicateProps.shapeIds, x = v.duplicateProps.offset;
          else {
            b = d.getSelectedShapeIds();
            const w = _e.Common(mt(b.map((S) => d.getShapePageBounds(S))));
            x = d.getCameraOptions().isLocked ? {
              // same as the adjacent note margin
              x: d.options.adjacentShapeMargin,
              y: d.options.adjacentShapeMargin
            } : {
              x: w.width + d.options.adjacentShapeMargin,
              y: 0
            };
          }
          d.markHistoryStoppingPoint("duplicate shapes"), d.duplicateShapes(b, x), v.duplicateProps && d.updateInstanceState({
            duplicateProps: {
              ...v.duplicateProps,
              shapeIds: d.getSelectedShapeIds()
            }
          });
        }
      },
      {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "cmd+shift+g,ctrl+shift+g",
        icon: "ungroup",
        onSelect(m) {
          f() && (u() || (o("ungroup-shapes", { source: m }), d.markHistoryStoppingPoint("ungroup"), d.ungroupShapes(d.getSelectedShapeIds())));
        }
      },
      {
        id: "group",
        label: "action.group",
        kbd: "cmd+g,ctrl+g",
        icon: "group",
        onSelect(m) {
          if (!f() || u()) return;
          o("group-shapes", { source: m });
          const v = d.getOnlySelectedShape();
          v && d.isShapeOfType(v, "group") ? (d.markHistoryStoppingPoint("ungroup"), d.ungroupShapes(d.getSelectedShapeIds())) : (d.markHistoryStoppingPoint("group"), d.groupShapes(d.getSelectedShapeIds()));
        }
      },
      {
        id: "remove-frame",
        label: "action.remove-frame",
        kbd: "cmd+shift+f,ctrl+shift+f",
        onSelect(m) {
          if (!f()) return;
          o("remove-frame", { source: m });
          const v = d.getSelectedShapes();
          v.length > 0 && v.every((b) => d.isShapeOfType(b, "frame")) && (d.markHistoryStoppingPoint("remove-frame"), ZXe(
            d,
            v.map((b) => b.id)
          ));
        }
      },
      {
        id: "fit-frame-to-content",
        label: "action.fit-frame-to-content",
        onSelect(m) {
          if (!f()) return;
          o("fit-frame-to-content", { source: m });
          const v = d.getOnlySelectedShape();
          v && d.isShapeOfType(v, "frame") && (d.markHistoryStoppingPoint("fit-frame-to-content"), aue(d, v.id));
        }
      },
      {
        id: "align-left",
        label: "action.align-left",
        kbd: "alt+A",
        icon: "align-left",
        onSelect(m) {
          f() && (u() || (o("align-shapes", { operation: "left", source: m }), d.markHistoryStoppingPoint("align left"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.alignShapes(v, "left"), An(d, v);
          })));
        }
      },
      {
        id: "align-center-horizontal",
        label: {
          default: "action.align-center-horizontal",
          "context-menu": "action.align-center-horizontal.short"
        },
        kbd: "alt+H",
        icon: "align-center-horizontal",
        onSelect(m) {
          f() && (u() || (o("align-shapes", { operation: "center-horizontal", source: m }), d.markHistoryStoppingPoint("align center horizontal"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.alignShapes(v, "center-horizontal"), An(d, v);
          })));
        }
      },
      {
        id: "align-right",
        label: "action.align-right",
        kbd: "alt+D",
        icon: "align-right",
        onSelect(m) {
          f() && (u() || (o("align-shapes", { operation: "right", source: m }), d.markHistoryStoppingPoint("align right"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.alignShapes(v, "right"), An(d, v);
          })));
        }
      },
      {
        id: "align-center-vertical",
        label: {
          default: "action.align-center-vertical",
          "context-menu": "action.align-center-vertical.short"
        },
        kbd: "alt+V",
        icon: "align-center-vertical",
        onSelect(m) {
          f() && (u() || (o("align-shapes", { operation: "center-vertical", source: m }), d.markHistoryStoppingPoint("align center vertical"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.alignShapes(v, "center-vertical"), An(d, v);
          })));
        }
      },
      {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "alt+W",
        onSelect(m) {
          f() && (u() || (o("align-shapes", { operation: "top", source: m }), d.markHistoryStoppingPoint("align top"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.alignShapes(v, "top"), An(d, v);
          })));
        }
      },
      {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "alt+S",
        onSelect(m) {
          f() && (u() || (o("align-shapes", { operation: "bottom", source: m }), d.markHistoryStoppingPoint("align bottom"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.alignShapes(v, "bottom"), An(d, v);
          })));
        }
      },
      {
        id: "distribute-horizontal",
        label: {
          default: "action.distribute-horizontal",
          "context-menu": "action.distribute-horizontal.short"
        },
        icon: "distribute-horizontal",
        kbd: "alt+shift+h",
        onSelect(m) {
          f() && (u() || (o("distribute-shapes", { operation: "horizontal", source: m }), d.markHistoryStoppingPoint("distribute horizontal"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.distributeShapes(v, "horizontal"), An(d, v);
          })));
        }
      },
      {
        id: "distribute-vertical",
        label: {
          default: "action.distribute-vertical",
          "context-menu": "action.distribute-vertical.short"
        },
        icon: "distribute-vertical",
        kbd: "alt+shift+V",
        onSelect(m) {
          f() && (u() || (o("distribute-shapes", { operation: "vertical", source: m }), d.markHistoryStoppingPoint("distribute vertical"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.distributeShapes(v, "vertical"), An(d, v);
          })));
        }
      },
      {
        id: "stretch-horizontal",
        label: {
          default: "action.stretch-horizontal",
          "context-menu": "action.stretch-horizontal.short"
        },
        icon: "stretch-horizontal",
        onSelect(m) {
          f() && (u() || (o("stretch-shapes", { operation: "horizontal", source: m }), d.markHistoryStoppingPoint("stretch horizontal"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.stretchShapes(v, "horizontal"), An(d, v);
          })));
        }
      },
      {
        id: "stretch-vertical",
        label: {
          default: "action.stretch-vertical",
          "context-menu": "action.stretch-vertical.short"
        },
        icon: "stretch-vertical",
        onSelect(m) {
          f() && (u() || (o("stretch-shapes", { operation: "vertical", source: m }), d.markHistoryStoppingPoint("stretch vertical"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.stretchShapes(v, "vertical"), An(d, v);
          })));
        }
      },
      {
        id: "flip-horizontal",
        label: {
          default: "action.flip-horizontal",
          "context-menu": "action.flip-horizontal.short"
        },
        kbd: "shift+h",
        onSelect(m) {
          f() && (u() || (o("flip-shapes", { operation: "horizontal", source: m }), d.markHistoryStoppingPoint("flip horizontal"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.flipShapes(v, "horizontal"), An(d, v);
          })));
        }
      },
      {
        id: "flip-vertical",
        label: { default: "action.flip-vertical", "context-menu": "action.flip-vertical.short" },
        kbd: "shift+v",
        onSelect(m) {
          f() && (u() || (o("flip-shapes", { operation: "vertical", source: m }), d.markHistoryStoppingPoint("flip vertical"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.flipShapes(v, "vertical"), An(d, v);
          })));
        }
      },
      {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        onSelect(m) {
          f() && (u() || (o("pack-shapes", { source: m }), d.markHistoryStoppingPoint("pack"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.packShapes(v, d.options.adjacentShapeMargin), An(d, v);
          })));
        }
      },
      {
        id: "stack-vertical",
        label: {
          default: "action.stack-vertical",
          "context-menu": "action.stack-vertical.short"
        },
        icon: "stack-vertical",
        onSelect(m) {
          f() && (u() || (o("stack-shapes", { operation: "vertical", source: m }), d.markHistoryStoppingPoint("stack-vertical"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.stackShapes(v, "vertical", d.options.adjacentShapeMargin), An(d, v);
          })));
        }
      },
      {
        id: "stack-horizontal",
        label: {
          default: "action.stack-horizontal",
          "context-menu": "action.stack-horizontal.short"
        },
        icon: "stack-horizontal",
        onSelect(m) {
          f() && (u() || (o("stack-shapes", { operation: "horizontal", source: m }), d.markHistoryStoppingPoint("stack-horizontal"), d.run(() => {
            const v = d.getSelectedShapeIds();
            d.stackShapes(v, "horizontal", d.options.adjacentShapeMargin), An(d, v);
          })));
        }
      },
      {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        onSelect(m) {
          f() && (u() || (o("reorder-shapes", { operation: "toFront", source: m }), d.markHistoryStoppingPoint("bring to front"), d.bringToFront(d.getSelectedShapeIds())));
        }
      },
      {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "alt+]",
        onSelect(m) {
          f() && (u() || (o("reorder-shapes", { operation: "forward", source: m }), d.markHistoryStoppingPoint("bring forward"), d.bringForward(d.getSelectedShapeIds())));
        }
      },
      {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "alt+[",
        onSelect(m) {
          f() && (u() || (o("reorder-shapes", { operation: "backward", source: m }), d.markHistoryStoppingPoint("send backward"), d.sendBackward(d.getSelectedShapeIds())));
        }
      },
      {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        onSelect(m) {
          f() && (u() || (o("reorder-shapes", { operation: "toBack", source: m }), d.markHistoryStoppingPoint("send to back"), d.sendToBack(d.getSelectedShapeIds())));
        }
      },
      {
        id: "cut",
        label: "action.cut",
        kbd: "cmd+x,ctrl+x",
        onSelect(m) {
          f() && (u() || (d.markHistoryStoppingPoint("cut"), s.cut(m)));
        }
      },
      {
        id: "copy",
        label: "action.copy",
        kbd: "cmd+c,ctrl+c",
        readonlyOk: !0,
        onSelect(m) {
          f() && (u() || s.copy(m));
        }
      },
      {
        id: "paste",
        label: "action.paste",
        kbd: "cmd+v,ctrl+v",
        onSelect(m) {
          var v;
          (v = navigator.clipboard) == null || v.read().then((b) => {
            s.paste(
              b,
              m,
              m === "context-menu" ? d.inputs.currentPagePoint : void 0
            );
          }).catch(() => {
            s.addToast({
              title: s.msg("action.paste-error-title"),
              description: s.msg("action.paste-error-description"),
              severity: "error"
            });
          });
        }
      },
      {
        id: "select-all",
        label: "action.select-all",
        kbd: "cmd+a,ctrl+a",
        readonlyOk: !0,
        onSelect(m) {
          d.run(() => {
            u() || (o("select-all-shapes", { source: m }), d.markHistoryStoppingPoint("select all kbd"), d.selectAll());
          });
        }
      },
      {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: !0,
        onSelect(m) {
          f() && (u() || (o("select-none-shapes", { source: m }), d.markHistoryStoppingPoint("select none"), d.selectNone()));
        }
      },
      {
        id: "delete",
        label: "action.delete",
        kbd: ",del",
        icon: "trash",
        onSelect(m) {
          f() && (u() || (o("delete-shapes", { source: m }), d.markHistoryStoppingPoint("delete"), d.deleteShapes(d.getSelectedShapeIds())));
        }
      },
      {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        onSelect(m) {
          f() && (u() || (o("rotate-cw", { source: m }), d.markHistoryStoppingPoint("rotate-cw"), d.run(() => {
            const v = d.getSelectionRotation() % (ar / 2), b = Hr(v, 0) || Hr(v, ar / 2), x = d.getSelectedShapeIds();
            d.rotateShapesBy(x, ar / 2 - (b ? 0 : v)), An(d, x);
          })));
        }
      },
      {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        onSelect(m) {
          f() && (u() || (o("rotate-ccw", { source: m }), d.markHistoryStoppingPoint("rotate-ccw"), d.run(() => {
            const v = d.getSelectionRotation() % (ar / 2), b = Hr(v, 0), x = d.getSelectedShapeIds();
            d.rotateShapesBy(x, b ? -(ar / 2) : -v), An(d, x);
          })));
        }
      },
      {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "cmd+=,ctrl+=,=",
        readonlyOk: !0,
        onSelect(m) {
          o("zoom-in", { source: m, towardsCursor: !1 }), d.zoomIn(void 0, {
            animation: { duration: d.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-in-on-cursor",
        label: "action.zoom-in",
        kbd: "shift+cmd+=,shift+ctrl+=,shift+=",
        readonlyOk: !0,
        onSelect(m) {
          o("zoom-in", { source: m, towardsCursor: !0 }), d.zoomIn(d.inputs.currentScreenPoint, {
            animation: { duration: d.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "cmd+-,ctrl+-,-",
        readonlyOk: !0,
        onSelect(m) {
          o("zoom-out", { source: m, towardsCursor: !1 }), d.zoomOut(void 0, {
            animation: { duration: d.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out-on-cursor",
        label: "action.zoom-out",
        kbd: "shift+cmd+-,shift+ctrl+-,shift+-",
        readonlyOk: !0,
        onSelect(m) {
          o("zoom-out", { source: m, towardsCursor: !0 }), d.zoomOut(d.inputs.currentScreenPoint, {
            animation: { duration: d.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "shift+0",
        readonlyOk: !0,
        onSelect(m) {
          o("reset-zoom", { source: m }), d.resetZoom(void 0, {
            animation: { duration: d.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "shift+1",
        readonlyOk: !0,
        onSelect(m) {
          o("zoom-to-fit", { source: m }), d.zoomToFit({ animation: { duration: d.options.animationMediumMs } });
        }
      },
      {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "shift+2",
        readonlyOk: !0,
        onSelect(m) {
          f() && (u() || (o("zoom-to-selection", { source: m }), d.zoomToSelection({ animation: { duration: d.options.animationMediumMs } })));
        }
      },
      {
        id: "toggle-snap-mode",
        label: {
          default: "action.toggle-snap-mode",
          menu: "action.toggle-snap-mode.menu"
        },
        onSelect(m) {
          o("toggle-snap-mode", { source: m }), d.user.updateUserPreferences({ isSnapMode: !d.user.getIsSnapMode() });
        },
        checkbox: !0
      },
      {
        id: "toggle-dark-mode",
        label: {
          default: "action.toggle-dark-mode",
          menu: "action.toggle-dark-mode.menu"
        },
        kbd: "cmd+/,ctrl+/",
        readonlyOk: !0,
        onSelect(m) {
          const v = d.user.getIsDarkMode() ? "light" : "dark";
          o("color-scheme", { source: m, value: v }), d.user.updateUserPreferences({
            colorScheme: v
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-wrap-mode",
        label: {
          default: "action.toggle-wrap-mode",
          menu: "action.toggle-wrap-mode.menu"
        },
        readonlyOk: !0,
        onSelect(m) {
          o("toggle-wrap-mode", { source: m }), d.user.updateUserPreferences({
            isWrapMode: !d.user.getIsWrapMode()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-dynamic-size-mode",
        label: {
          default: "action.toggle-dynamic-size-mode",
          menu: "action.toggle-dynamic-size-mode.menu"
        },
        readonlyOk: !1,
        onSelect(m) {
          o("toggle-dynamic-size-mode", { source: m }), d.user.updateUserPreferences({
            isDynamicSizeMode: !d.user.getIsDynamicResizeMode()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-paste-at-cursor",
        label: {
          default: "action.toggle-paste-at-cursor",
          menu: "action.toggle-paste-at-cursor.menu"
        },
        readonlyOk: !1,
        onSelect(m) {
          o("toggle-paste-at-cursor", { source: m }), d.user.updateUserPreferences({
            isPasteAtCursorMode: !d.user.getIsPasteAtCursorMode()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-reduce-motion",
        label: {
          default: "action.toggle-reduce-motion",
          menu: "action.toggle-reduce-motion.menu"
        },
        readonlyOk: !0,
        onSelect(m) {
          o("toggle-reduce-motion", { source: m }), d.user.updateUserPreferences({
            animationSpeed: d.user.getAnimationSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-keyboard-shortcuts",
        label: {
          default: "action.toggle-keyboard-shortcuts",
          menu: "action.toggle-keyboard-shortcuts.menu"
        },
        readonlyOk: !0,
        onSelect(m) {
          o("toggle-keyboard-shortcuts", { source: m }), d.user.updateUserPreferences({
            areKeyboardShortcutsEnabled: !d.user.getAreKeyboardShortcutsEnabled()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-edge-scrolling",
        label: {
          default: "action.toggle-edge-scrolling",
          menu: "action.toggle-edge-scrolling.menu"
        },
        readonlyOk: !0,
        onSelect(m) {
          o("toggle-edge-scrolling", { source: m }), d.user.updateUserPreferences({
            edgeScrollSpeed: d.user.getEdgeScrollSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-transparent",
        label: {
          default: "action.toggle-transparent",
          menu: "action.toggle-transparent.menu",
          "context-menu": "action.toggle-transparent.context-menu"
        },
        readonlyOk: !0,
        onSelect(m) {
          o("toggle-transparent", { source: m }), d.updateInstanceState({
            exportBackground: !d.getInstanceState().exportBackground
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-tool-lock",
        label: {
          default: "action.toggle-tool-lock",
          menu: "action.toggle-tool-lock.menu"
        },
        kbd: "q",
        onSelect(m) {
          o("toggle-tool-lock", { source: m }), d.updateInstanceState({ isToolLocked: !d.getInstanceState().isToolLocked });
        },
        checkbox: !0
      },
      {
        id: "unlock-all",
        label: "action.unlock-all",
        onSelect(m) {
          o("unlock-all", { source: m });
          const v = [];
          for (const b of d.getCurrentPageShapes())
            b.isLocked && v.push({ id: b.id, type: b.type, isLocked: !1 });
          v.length > 0 && d.updateShapes(v);
        }
      },
      {
        id: "toggle-focus-mode",
        label: {
          default: "action.toggle-focus-mode",
          menu: "action.toggle-focus-mode.menu"
        },
        readonlyOk: !0,
        kbd: "cmd+.,ctrl+.",
        checkbox: !0,
        onSelect(m) {
          d.timers.requestAnimationFrame(() => {
            d.run(() => {
              o("toggle-focus-mode", { source: m }), s.clearDialogs(), s.clearToasts(), d.updateInstanceState({ isFocusMode: !d.getInstanceState().isFocusMode });
            });
          });
        }
      },
      {
        id: "toggle-grid",
        label: {
          default: "action.toggle-grid",
          menu: "action.toggle-grid.menu"
        },
        readonlyOk: !0,
        kbd: "cmd+',ctrl+'",
        onSelect(m) {
          o("toggle-grid-mode", { source: m }), d.updateInstanceState({ isGridMode: !d.getInstanceState().isGridMode });
        },
        checkbox: !0
      },
      {
        id: "toggle-debug-mode",
        label: {
          default: "action.toggle-debug-mode",
          menu: "action.toggle-debug-mode.menu"
        },
        readonlyOk: !0,
        onSelect(m) {
          o("toggle-debug-mode", { source: m }), d.updateInstanceState({
            isDebugMode: !d.getInstanceState().isDebugMode
          });
        },
        checkbox: !0
      },
      {
        id: "print",
        label: "action.print",
        kbd: "cmd+p,ctrl+p",
        readonlyOk: !0,
        onSelect(m) {
          o("print", { source: m }), s.printSelectionOrPages();
        }
      },
      {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect(m) {
          o("exit-pen-mode", { source: m }), d.updateInstanceState({ isPenMode: !1 });
        }
      },
      {
        id: "stop-following",
        label: "action.stop-following",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect(m) {
          o("stop-following", { source: m }), d.stopFollowingUser();
        }
      },
      {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: !0,
        onSelect(m) {
          o("zoom-to-content", { source: m });
          const v = d.getSelectionPageBounds() ?? d.getCurrentPageBounds();
          v && d.zoomToBounds(v, {
            targetZoom: Math.min(1, d.getZoomLevel()),
            animation: { duration: 220 }
          });
        }
      },
      {
        id: "toggle-lock",
        label: "action.toggle-lock",
        kbd: "shift+l",
        onSelect(m) {
          d.markHistoryStoppingPoint("locking"), o("toggle-lock", { source: m }), d.toggleLock(d.getSelectedShapeIds());
        }
      },
      {
        id: "move-to-new-page",
        label: "context.pages.new-page",
        onSelect(m) {
          const v = ci.createId(), b = d.getSelectedShapeIds();
          d.run(() => {
            d.markHistoryStoppingPoint("move_shapes_to_page"), d.createPage({
              name: s.msg("page-menu.new-page-initial-name"),
              id: v
            }), d.moveShapesToPage(b, v);
          }), o("move-to-new-page", { source: m });
        }
      },
      {
        id: "select-white-color",
        label: "color-style.white",
        kbd: "alt+t",
        onSelect(m) {
          const v = di;
          d.run(() => {
            d.markHistoryStoppingPoint("change-color"), d.isIn("select") && d.setStyleForSelectedShapes(v, "white"), d.setStyleForNextShapes(v, "white");
          }), o("set-style", { source: m, id: v.id, value: "white" });
        }
      },
      {
        id: "select-fill-fill",
        label: "fill-style.fill",
        kbd: "alt+f",
        onSelect(m) {
          const v = Ap;
          d.run(() => {
            d.markHistoryStoppingPoint("change-fill"), d.isIn("select") && d.setStyleForSelectedShapes(v, "fill"), d.setStyleForNextShapes(v, "fill");
          }), o("set-style", { source: m, id: v.id, value: "fill" });
        }
      },
      {
        id: "flatten-to-image",
        label: "action.flatten-to-image",
        kbd: "shift+f",
        onSelect: async (m) => {
          const v = d.getSelectedShapeIds();
          if (v.length === 0) return;
          d.markHistoryStoppingPoint("flattening to image"), o("flatten-to-image", { source: m });
          const b = await KZe(
            d,
            v,
            d.options.flattenImageBoundsExpand
          );
          b != null && b.length && d.setSelectedShapes(b);
        }
      },
      {
        id: "select-geo-tool",
        kbd: "g",
        onSelect: async (m) => {
          o("select-tool", { source: m, id: "geo-previous" }), d.setCurrentTool("geo");
        }
      },
      {
        id: "change-page-prev",
        kbd: "alt+left,alt+up",
        readonlyOk: !0,
        onSelect: async (m) => {
          const v = d.getPages(), b = v.findIndex((x) => x.id === d.getCurrentPageId());
          b < 1 || (o("change-page", { source: m, direction: "prev" }), d.setCurrentPage(v[b - 1].id));
        }
      },
      {
        id: "change-page-next",
        kbd: "alt+right,alt+down",
        readonlyOk: !0,
        onSelect: async (m) => {
          const v = d.getPages(), b = v.findIndex((x) => x.id === d.getCurrentPageId());
          if (b === -1 || b >= v.length - 1) {
            if (d.getCurrentPageShapes().length <= 0 || d.getIsReadonly())
              return;
            o("new-page", { source: m }), d.run(() => {
              d.markHistoryStoppingPoint("creating page");
              const x = ci.createId();
              d.createPage({
                name: s.msg("page-menu.new-page-initial-name"),
                id: x
              }), d.setCurrentPage(x);
            });
            return;
          }
          d.setCurrentPage(v[b + 1].id), o("change-page", { source: m, direction: "next" });
        }
      },
      {
        id: "adjust-shape-styles",
        label: "a11y.adjust-shape-styles",
        kbd: "cmd+Enter,ctrl+Enter",
        isRequiredA11yAction: !0,
        onSelect: async (m) => {
          if (!f()) return;
          const v = d.getContainer().querySelector(".tlui-style-panel button");
          v == null || v.focus(), o("adjust-shape-styles", { source: m });
        }
      },
      {
        id: "a11y-open-context-menu",
        kbd: "cmd+shift+Enter,ctrl+shift+Enter",
        isRequiredA11yAction: !0,
        readonlyOk: !0,
        onSelect: async (m) => {
          var S;
          if (!f()) return;
          const v = d.getSelectionPageBounds();
          if (!v) return;
          const b = v.x + v.width / 2, x = v.y + v.height / 2, w = d.pageToScreen(new I(b, x));
          (S = d.getContainer().querySelector(".tl-canvas")) == null || S.dispatchEvent(
            new PointerEvent("contextmenu", {
              clientX: w.x,
              clientY: w.y,
              bubbles: !0
            })
          ), o("open-context-menu", { source: m });
        }
      },
      {
        id: "enlarge-shapes",
        label: "a11y.enlarge-shape",
        kbd: "cmd+alt+shift+=,ctrl+alt+shift+=",
        onSelect: async (m) => {
          p(1.1), o("enlarge-shapes", { source: m });
        }
      },
      {
        id: "shrink-shapes",
        label: "a11y.shrink-shape",
        kbd: "cmd+alt+shift+-,ctrl+alt+shift+-",
        onSelect: async (m) => {
          p(1 / 1.1), o("shrink-shapes", { source: m });
        }
      },
      {
        id: "a11y-repeat-shape-announce",
        kbd: "alt+r",
        label: "a11y.repeat-shape",
        isRequiredA11yAction: !0,
        readonlyOk: !0,
        onSelect: async (m) => {
          const v = d.getSelectedShapeIds();
          if (!v.length) return;
          const b = Zae({
            editor: d,
            selectedShapeIds: v,
            msg: a
          });
          b && (i.announce({ msg: "" }), d.timers.requestAnimationFrame(() => {
            i.announce({ msg: b });
          }), o("a11y-repeat-shape-announce", { source: m }));
        }
      },
      {
        id: "image-replace",
        label: "tool.replace-media",
        icon: "arrow-cycle",
        readonlyOk: !1,
        onSelect: async (m) => {
          o("image-replace", { source: m }), s.replaceImage();
        }
      },
      {
        id: "video-replace",
        label: "tool.replace-media",
        icon: "arrow-cycle",
        readonlyOk: !1,
        onSelect: async (m) => {
          o("video-replace", { source: m }), s.replaceVideo();
        }
      },
      {
        id: "download-original",
        label: "action.download-original",
        readonlyOk: !0,
        onSelect: async (m) => {
          const v = d.getSelectedShapes();
          if (v.length === 0) return;
          const b = v.filter(
            (x) => wue(x, d)
          );
          if (b.length !== 0) {
            for (const x of b) {
              const w = d.getAsset(x.props.assetId);
              if (!w || !w.props.src) continue;
              const S = await d.resolveAssetUrl(w.id, { shouldResolveToOriginal: !0 });
              if (!S) return;
              const C = document.createElement("a");
              C.href = S, (w.type === "video" || w.type === "image") && !w.props.src.startsWith("asset:") ? C.download = w.props.name : C.download = "download", document.body.appendChild(C), C.click(), document.body.removeChild(C);
            }
            o("download-original", { source: m });
          }
        }
      }
    ];
    r && g.push({
      id: "open-cursor-chat",
      label: "action.open-cursor-chat",
      readonlyOk: !0,
      kbd: "/",
      onSelect(m) {
        o("open-cursor-chat", { source: m }), !d.getInstanceState().isCoarsePointer && d.timers.requestAnimationFrame(() => {
          d.updateInstanceState({ isChatting: !0 });
        });
      }
    });
    const y = GZe(g);
    return t ? t(d, y, s) : y;
  }, [s, n, o, t, c, r, a, i]);
  return /* @__PURE__ */ h.jsx(xue.Provider, { value: l, children: e });
}
function xu() {
  const t = T.useContext(xue);
  if (!t)
    throw new Error("useTools must be used within a ToolProvider");
  return t;
}
function Tw(t, e) {
  return t ? typeof t == "string" ? t : e ? t[e] ?? t.default : void 0 : void 0;
}
function Rk({
  id: t,
  kbd: e,
  label: n,
  readonlyOk: r,
  onSelect: s,
  toggle: o = !1,
  disabled: i = !1,
  checked: a = !1
}) {
  const { type: c, sourceId: l } = Mk(), d = Da(), u = Ze();
  if (d && !r) return null;
  const f = Tw(n, c), p = f ? u(f) : void 0;
  switch (c) {
    case "menu":
      return /* @__PURE__ */ h.jsxs(
        Sle,
        {
          dir: "ltr",
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          title: p,
          onSelect: (g) => {
            s == null || s(l), xt(g);
          },
          disabled: i,
          checked: a,
          children: [
            /* @__PURE__ */ h.jsx(
              ed,
              {
                small: !0,
                label: u(a ? "ui.checked" : "ui.unchecked"),
                icon: o ? a ? "toggle-on" : "toggle-off" : a ? "check" : "none"
              }
            ),
            p && /* @__PURE__ */ h.jsx("span", { className: "tlui-button__label", draggable: !1, children: p }),
            e && /* @__PURE__ */ h.jsx(_x, { children: e })
          ]
        }
      );
    case "context-menu":
      return /* @__PURE__ */ h.jsxs(
        UYe,
        {
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          dir: "ltr",
          title: p,
          onSelect: (g) => {
            s(l), xt(g);
          },
          disabled: i,
          checked: a,
          children: [
            /* @__PURE__ */ h.jsx(
              ed,
              {
                small: !0,
                label: u(a ? "ui.checked" : "ui.unchecked"),
                icon: o ? a ? "toggle-on" : "toggle-off" : a ? "check" : "none"
              }
            ),
            p && /* @__PURE__ */ h.jsx("span", { className: "tlui-button__label", draggable: !1, children: p }),
            e && /* @__PURE__ */ h.jsx(_x, { children: e })
          ]
        },
        t
      );
    default:
      return null;
  }
}
function Yi({
  id: t,
  disabled: e = !1,
  label: n,
  size: r = "small",
  children: s
}) {
  const { type: o, sourceId: i } = Mk(), a = Gr(), c = Ze(), l = n ? typeof n == "string" ? n : n[o] ?? n.default : void 0, d = l ? c(l) : void 0;
  switch (o) {
    case "menu":
      return /* @__PURE__ */ h.jsxs(cZe, { id: `${i}-sub.${t}`, children: [
        /* @__PURE__ */ h.jsx(
          lZe,
          {
            id: `${i}-sub.${t}-button`,
            disabled: e,
            label: d,
            title: d
          }
        ),
        /* @__PURE__ */ h.jsx(dZe, { id: `${i}-sub.${t}-content`, size: r, children: s })
      ] });
    case "context-menu":
      return e ? null : /* @__PURE__ */ h.jsxs(qZe, { id: `${i}-sub.${t}`, children: [
        /* @__PURE__ */ h.jsx(cle, { dir: "ltr", disabled: e, asChild: !0, children: /* @__PURE__ */ h.jsxs(
          yt,
          {
            "data-testid": `${i}-sub.${t}-button`,
            type: "menu",
            className: "tlui-menu__submenu__trigger",
            children: [
              /* @__PURE__ */ h.jsx(Pr, { children: d }),
              /* @__PURE__ */ h.jsx(gt, { icon: "chevron-right", small: !0 })
            ]
          }
        ) }),
        /* @__PURE__ */ h.jsx(m5, { container: a, children: /* @__PURE__ */ h.jsx(
          lle,
          {
            "data-testid": `${i}-sub.${t}-content`,
            className: "tlui-menu tlui-menu__submenu__content",
            alignOffset: -1,
            sideOffset: -4,
            collisionPadding: 4,
            "data-size": r,
            children: s
          }
        ) })
      ] });
    default:
      return s;
  }
}
function qZe({ id: t, children: e }) {
  const [n, r] = vu(t);
  return /* @__PURE__ */ h.jsx(ale, { open: n, onOpenChange: r, children: e });
}
const XZe = [
  { colorScheme: "light", label: "theme.light" },
  { colorScheme: "dark", label: "theme.dark" },
  { colorScheme: "system", label: "theme.system" }
];
function ZZe() {
  const t = ie(), e = xr(), n = le(
    "colorScheme",
    () => t.user.getUserPreferences().colorScheme ?? (t.user.getIsDarkMode() ? "dark" : "light"),
    [t]
  );
  return /* @__PURE__ */ h.jsx(Yi, { id: "help menu color-scheme", label: "menu.theme", children: /* @__PURE__ */ h.jsx(At, { id: "theme", children: XZe.map(({ colorScheme: r, label: s }) => /* @__PURE__ */ h.jsx(
    Rk,
    {
      id: `color-scheme-${r}`,
      label: s,
      checked: r === n,
      readonlyOk: !0,
      onSelect: () => {
        t.user.updateUserPreferences({ colorScheme: r }), e("color-scheme", { source: "menu", value: r });
      }
    },
    r
  )) }) });
}
const QZe = ({
  id: t,
  component: e,
  onClose: n,
  preventBackgroundClose: r
}) => {
  const { removeDialog: s } = gS(), o = fe(!1), i = Gr(), a = re(
    (c) => {
      if (!c) {
        if (n)
          try {
            n();
          } catch (l) {
            console.warn(l);
          }
        s(t);
      }
    },
    [t, n, s]
  );
  return /* @__PURE__ */ h.jsx(tI, { onOpenChange: a, defaultOpen: !0, children: /* @__PURE__ */ h.jsx(nI, { container: i, children: /* @__PURE__ */ h.jsx(
    Zy,
    {
      dir: "ltr",
      className: "tlui-dialog__overlay",
      onClick: (c) => {
        o.current || !r && c.target === c.currentTarget && a(!1);
      },
      children: /* @__PURE__ */ h.jsx(
        Qy,
        {
          dir: "ltr",
          className: "tlui-dialog__content",
          "aria-describedby": void 0,
          onMouseDown: () => o.current = !0,
          onMouseUp: () => o.current = !1,
          onInteractOutside: (c) => {
            o.current = !1, r && c.preventDefault();
          },
          children: /* @__PURE__ */ h.jsx(
            e,
            {
              onClose: () => {
                o.current = !1, a(!1);
              }
            }
          )
        }
      )
    }
  ) }) });
}, JZe = it(function() {
  const { dialogs: e } = gS();
  return le("dialogs", () => e.get(), [e]).map((r) => /* @__PURE__ */ h.jsx(QZe, { ...r }, r.id));
});
function gc({
  actionId: t = "",
  ...e
}) {
  const r = xu()[t];
  return r ? /* @__PURE__ */ h.jsx(Rk, { ...r, ...e }) : null;
}
const eQe = 4e3, tQe = {
  success: "check-circle",
  warning: "warning-triangle",
  error: "cross-circle",
  info: "info-circle"
};
function nQe({ toast: t }) {
  const { removeToast: e } = bu(), n = Ze(), r = (a) => {
    a || e(t.id);
  }, s = t.actions && t.actions.length > 0, o = t.icon || t.severity && tQe[t.severity], i = t.iconLabel || (t.severity ? n(`toast.${t.severity}`) : "");
  return /* @__PURE__ */ h.jsxs(
    z$,
    {
      onOpenChange: r,
      className: "tlui-toast__container",
      duration: t.keepOpen ? 1 / 0 : eQe,
      "data-severity": t.severity,
      children: [
        o && /* @__PURE__ */ h.jsx("div", { className: "tlui-toast__icon", children: /* @__PURE__ */ h.jsx(ed, { label: i, icon: o }) }),
        /* @__PURE__ */ h.jsxs(
          "div",
          {
            className: "tlui-toast__main",
            "data-title": !!t.title,
            "data-description": !!t.description,
            "data-actions": !!t.actions,
            children: [
              /* @__PURE__ */ h.jsxs("div", { className: "tlui-toast__content", children: [
                t.title && /* @__PURE__ */ h.jsx(U$, { className: "tlui-toast__title", children: t.title }),
                t.description && /* @__PURE__ */ h.jsx(H$, { className: "tlui-toast__description", children: t.description })
              ] }),
              t.actions && /* @__PURE__ */ h.jsxs("div", { className: "tlui-toast__actions", children: [
                t.actions.map((a, c) => /* @__PURE__ */ h.jsx(V$, { altText: a.label, asChild: !0, onClick: a.onClick, children: /* @__PURE__ */ h.jsx(yt, { type: a.type, children: /* @__PURE__ */ h.jsx(Pr, { children: a.label }) }) }, c)),
                /* @__PURE__ */ h.jsx(V_, { asChild: !0, children: /* @__PURE__ */ h.jsx(
                  yt,
                  {
                    type: "normal",
                    className: "tlui-toast__close",
                    style: { marginLeft: "auto" },
                    children: /* @__PURE__ */ h.jsx(Pr, { children: t.closeLabel ?? n("toast.close") })
                  }
                ) })
              ] })
            ]
          }
        ),
        !s && /* @__PURE__ */ h.jsx(V_, { asChild: !0, children: /* @__PURE__ */ h.jsx(yt, { type: "normal", className: "tlui-toast__close", children: /* @__PURE__ */ h.jsx(Pr, { children: t.closeLabel ?? n("toast.close") }) }) })
      ]
    }
  );
}
const rQe = it(function() {
  const { toasts: e } = bu(), n = le("toasts", () => e.get(), []);
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    n.map((r) => /* @__PURE__ */ h.jsx(nQe, { toast: r }, r.id)),
    /* @__PURE__ */ h.jsx(F$, { className: "tlui-toast__viewport" })
  ] });
});
function fT(t, e, n) {
  const { arrowheadStart: r, arrowheadEnd: s } = e.props, o = gm(t, e, n), i = o.start.clone(), a = o.end.clone(), c = I.Med(i, a);
  if (I.Equals(i, a))
    return {
      bindings: n,
      type: "straight",
      start: {
        handle: i,
        point: i,
        arrowhead: e.props.arrowheadStart
      },
      end: {
        handle: a,
        point: a,
        arrowhead: e.props.arrowheadEnd
      },
      middle: c,
      isValid: !1,
      length: 0
    };
  const l = I.Sub(a, i).uni(), d = pT(t, e, "start"), u = pT(t, e, "end"), f = t.getShapePageTransform(e);
  yV(
    a,
    // <-- will be mutated
    o.start,
    f,
    u
  ), yV(
    i,
    // <-- will be mutated
    o.end,
    f,
    d
  );
  let p = 0, g = 0, y = 0, m = 0, v = mm * e.props.scale;
  const b = d && u && d.shape === u.shape, x = d && u ? F5(t, d.shape.id, u.shape.id) : "safe";
  x === "safe" && d && u && !b && !d.isExact && !u.isExact && (u.didIntersect && !d.didIntersect ? d.isClosed && i.setTo(a.clone().add(l.clone().mul(mm * e.props.scale))) : u.didIntersect || u.isClosed && a.setTo(i.clone().sub(l.clone().mul(mm * e.props.scale))));
  const w = I.Sub(a, i), S = I.Len(w) ? w.uni() : I.From(w), C = !I.Equals(S, l);
  b || (x !== "start-contains-end" && d && r !== "none" && !d.isExact && (y = da[e.props.size] / 2 + ("size" in d.shape.props ? da[d.shape.props.size] / 2 : 0), p = (Iw + y) * e.props.scale, v += y * e.props.scale), x !== "end-contains-start" && u && s !== "none" && !u.isExact && (m = da[e.props.size] / 2 + ("size" in u.shape.props ? da[u.shape.props.size] / 2 : 0), g = (Iw + m) * e.props.scale, v += m * e.props.scale));
  const _ = i.clone().add(S.clone().mul(p * (C ? -1 : 1))), E = a.clone().sub(S.clone().mul(g * (C ? -1 : 1)));
  I.DistMin(_, E, v) && (p !== 0 && g !== 0 ? (p *= -1.5, g *= -1.5) : p !== 0 ? p *= -1 : g !== 0 && (g *= -1)), i.add(S.clone().mul(p * (C ? -1 : 1))), a.sub(S.clone().mul(g * (C ? -1 : 1))), C ? (d && u && a.setTo(I.Add(i, S.clone().mul(-mm * e.props.scale))), c.setTo(I.Med(o.start, o.end))) : c.setTo(I.Med(i, a));
  const M = I.Dist(i, a);
  return {
    bindings: n,
    type: "straight",
    start: {
      handle: o.start,
      point: i,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      handle: o.end,
      point: a,
      arrowhead: e.props.arrowheadEnd
    },
    middle: c,
    isValid: M > 0,
    length: M
  };
}
function yV(t, e, n, r) {
  if (r === void 0 || r.isExact)
    return;
  const s = we.applyToPoint(n, e), o = we.applyToPoint(n, t), i = we.applyToPoint(we.Inverse(r.transform), s), a = we.applyToPoint(we.Inverse(r.transform), o), c = Array.from(
    r.geometry.intersectLineSegment(i, a, {
      includeLabels: !1,
      includeInternal: !1
    })
  );
  let l;
  if (c.length && (l = c.sort((f, p) => I.Dist2(f, i) - I.Dist2(p, i))[0] ?? (r.isClosed ? void 0 : a)), l === void 0 && (l = r.geometry.nearestPoint(a), !I.DistMin(l, a, 1)))
    return;
  const d = we.applyToPoint(r.transform, l), u = we.applyToPoint(we.Inverse(n), d);
  t.setTo(u), r.didIntersect = !0;
}
function sQe(t, e, n) {
  const { arrowheadEnd: r, arrowheadStart: s } = e.props, o = e.props.bend;
  if (Math.abs(o) > Math.abs(e.props.bend * (PQe * e.props.scale)))
    return fT(t, e, n);
  const i = gm(t, e, n), a = I.Med(i.start, i.end), c = I.Sub(i.end, i.start), l = I.Len(c) ? c.uni() : I.From(c), d = I.Add(a, l.per().mul(-o)), u = pT(t, e, "start"), f = pT(t, e, "end"), p = i.start.clone(), g = i.end.clone(), y = d.clone();
  if (I.Equals(p, g))
    return {
      bindings: n,
      type: "straight",
      start: {
        handle: p,
        point: p,
        arrowhead: e.props.arrowheadStart
      },
      end: {
        handle: g,
        point: g,
        arrowhead: e.props.arrowheadEnd
      },
      middle: y,
      isValid: !1,
      length: 0
    };
  const m = e.props.bend < 0, v = m ? l3 : D4e, b = vV(p, g, y), x = I.Angle(b.center, p), w = I.Angle(b.center, g), S = v(x, w);
  if (b.length === 0 || b.size === 0 || !Y8(b.length) || !Y8(b.size))
    return fT(t, e, n);
  const C = p.clone(), _ = g.clone(), E = y.clone(), M = t.getShapePageTransform(e);
  let N = 0, O = 0, D = mm * e.props.scale;
  if (u && !u.isExact) {
    const z = we.applyToPoint(M, C), H = we.applyToPoint(M, b.center), U = we.applyToPoint(M, _), W = we.Inverse(u.transform), Z = we.applyToPoint(W, z), K = we.applyToPoint(W, H), oe = we.applyToPoint(W, U), { isClosed: Y } = u;
    let ee, ae = Array.from(
      u.geometry.intersectCircle(K, b.radius, {
        includeLabels: !1,
        includeInternal: !1
      })
    );
    if (ae.length) {
      const de = K.angle(Z), ye = K.angle(oe), G = v(de, ye);
      ae = ae.filter(
        (ge) => v(de, K.angle(ge)) <= G
      );
      const xe = G * 0.25;
      ae.sort(
        Y ? (ge, ze) => Math.abs(v(de, K.angle(ge)) - xe) < Math.abs(v(de, K.angle(ze)) - xe) ? -1 : 1 : (ge, ze) => v(de, K.angle(ge)) < v(de, K.angle(ze)) ? -1 : 1
      ), ee = ae[0];
    }
    if (!ee)
      if (Y) {
        const de = u.geometry.nearestPoint(Z);
        I.DistMin(de, Z, 1) && (ee = de);
      } else
        ee = Z;
    if (ee && (C.setTo(
      t.getPointInShapeSpace(e, we.applyToPoint(u.transform, ee))
    ), u.didIntersect = !0, s !== "none")) {
      const de = da[e.props.size] / 2 + ("size" in u.shape.props ? da[u.shape.props.size] / 2 : 0);
      N = (Iw + de) * e.props.scale, D += de * e.props.scale;
    }
  }
  if (f && !f.isExact) {
    const z = we.applyToPoint(M, C), H = we.applyToPoint(M, _), U = we.applyToPoint(M, b.center), W = we.Inverse(f.transform), Z = we.applyToPoint(W, z), K = we.applyToPoint(W, U), oe = we.applyToPoint(W, H), Y = f.isClosed;
    let ee, ae = Array.from(
      f.geometry.intersectCircle(K, b.radius, {
        includeLabels: !1,
        includeInternal: !1
      })
    );
    if (ae.length) {
      const de = K.angle(Z), ye = K.angle(oe), G = v(de, ye), xe = G * 0.75;
      ae = ae.filter(
        (ge) => v(de, K.angle(ge)) <= G
      ), ae.sort(
        Y ? (ge, ze) => Math.abs(v(de, K.angle(ge)) - xe) < Math.abs(v(de, K.angle(ze)) - xe) ? -1 : 1 : (ge, ze) => v(de, K.angle(ge)) < v(de, K.angle(ze)) ? -1 : 1
      ), ee = ae[0];
    }
    if (!ee)
      if (Y) {
        const de = f.geometry.nearestPoint(oe);
        I.DistMin(de, oe, 1) && (ee = de);
      } else
        ee = oe;
    if (ee && (_.setTo(
      t.getPointInShapeSpace(e, we.applyToPoint(f.transform, ee))
    ), f.didIntersect = !0, r !== "none")) {
      const de = da[e.props.size] / 2 + ("size" in f.shape.props ? da[f.shape.props.size] / 2 : 0);
      O = (Iw + de) * e.props.scale, D += de * e.props.scale;
    }
  }
  let k = I.Angle(b.center, C), A = I.Angle(b.center, _), R = v(k, A), j = R * b.radius;
  const $ = C.clone(), F = _.clone();
  if (N !== 0 && $.setTo(b.center).add(
    I.FromAngle(k + R * (N / j * (m ? 1 : -1))).mul(b.radius)
  ), O !== 0 && F.setTo(b.center).add(
    I.FromAngle(A + R * (O / j * (m ? -1 : 1))).mul(b.radius)
  ), I.DistMin($, F, D)) {
    N !== 0 && O !== 0 ? (N *= -1.5, O *= -1.5) : N !== 0 ? N *= -2 : O !== 0 && (O *= -2);
    const z = 0.1 - v(x, k) * b.radius, H = 0.1 - v(A, w) * b.radius;
    N = Math.max(N, z), O = Math.max(O, H);
  }
  if (N !== 0 && C.setTo(b.center).add(
    I.FromAngle(k + R * (N / j * (m ? 1 : -1))).mul(b.radius)
  ), O !== 0 && _.setTo(b.center).add(
    I.FromAngle(A + R * (O / j * (m ? -1 : 1))).mul(b.radius)
  ), u && f && !u.isExact && !f.isExact) {
    k = I.Angle(b.center, C), A = I.Angle(b.center, _), R = v(k, A), j = R * b.radius;
    const z = F5(
      t,
      u.shape.id,
      f.shape.id
    );
    z === "double-bound" && j < 30 ? (C.setTo(p), _.setTo(g), E.setTo(y)) : z === "safe" && (u && !u.didIntersect && C.setTo(p), (f && !f.didIntersect || v(x, k) > v(x, A)) && _.setTo(b.center).add(
      I.FromAngle(
        k + R * (Math.min(0.9, mm * e.props.scale / j) * (m ? 1 : -1))
      ).mul(b.radius)
    ));
  }
  oQe(
    b.center,
    b.radius,
    C,
    _,
    E,
    S,
    m
  ), C.equals(_) && (C.setTo(E.clone().addXY(1, 1)), _.setTo(E.clone().subXY(1, 1))), p.setTo(C), g.setTo(_), y.setTo(E);
  const L = vV(p, g, y);
  return {
    bindings: n,
    type: "arc",
    start: {
      point: p,
      handle: i.start,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      point: g,
      handle: i.end,
      arrowhead: e.props.arrowheadEnd
    },
    middle: y,
    handleArc: b,
    bodyArc: L,
    isValid: L.length !== 0 && isFinite(L.center.x) && isFinite(L.center.y)
  };
}
function vV(t, e, n) {
  const r = nne(t, e, n) ?? I.Med(t, e), s = I.Dist(r, t), o = +I.Clockwise(t, n, e), i = ((t.y - e.y) ** 2 + (t.x - e.x) ** 2) ** 0.5, a = ((e.y - n.y) ** 2 + (e.x - n.x) ** 2) ** 0.5, c = ((n.y - t.y) ** 2 + (n.x - t.x) ** 2) ** 0.5, l = Math.acos((a * a + c * c - i * i) / (2 * a * c)) * 2, d = +(mn > l), u = (Bn - l) * (o ? 1 : -1), f = u * s;
  return {
    center: r,
    radius: s,
    size: u,
    length: f,
    largeArcFlag: d,
    sweepFlag: o
  };
}
function oQe(t, e, n, r, s, o, i) {
  const a = I.Angle(t, n), c = I.Angle(t, r);
  let l = l3(a, c);
  if (i || (l = Bn - l), s.setTo(t).add(I.FromAngle(a + l * (0.5 * (i ? 1 : -1))).mul(e)), l > o) {
    s.rotWith(t, mn);
    const d = r.clone();
    r.setTo(n), n.setTo(d);
  }
}
const bV = ["right", "bottom", "left", "top"], iQe = {
  top: { x: 0, y: -1 },
  right: { x: 1, y: 0 },
  bottom: { x: 0, y: 1 },
  left: { x: -1, y: 0 }
}, aQe = {
  left: "x",
  right: "x",
  top: "y",
  bottom: "y"
}, Ug = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, Pw = {
  x: {
    v: (t, e) => new I(t, e),
    loEdge: "left",
    hiEdge: "right",
    crossMid: "midY",
    gap: "gapX",
    midRange: "midXRange",
    self: "x",
    cross: "y",
    size: "width"
  },
  y: {
    v: (t, e) => new I(e, t),
    loEdge: "top",
    hiEdge: "bottom",
    crossMid: "midX",
    gap: "gapY",
    midRange: "midYRange",
    self: "y",
    cross: "x",
    size: "height"
  }
};
function cQe(t, e) {
  const n = {
    min: t.min - e,
    max: t.max + e
  };
  return n.min > n.max ? null : n;
}
function lQe(t, e) {
  return tt(t.min <= t.max && e.min <= e.max), t.min <= e.min && e.max <= t.max ? [
    { min: t.min, max: e.min },
    { min: e.max, max: t.max }
  ] : e.max <= t.min || e.min >= t.max ? [t] : e.min <= t.min && t.max <= e.max ? [] : hT(t.min, e) ? [{ min: e.max, max: t.max }] : hT(t.max, e) ? [{ min: t.min, max: e.min }] : [];
}
function BO(t, e) {
  return { min: Math.min(t, e), max: Math.max(t, e) };
}
function hT(t, e) {
  return t >= e.min && t <= e.max;
}
function xV(t) {
  return t.max - t.min;
}
function W1(t) {
  if (!t) return;
  const e = t.cross.min;
  t.cross.min = -t.cross.max, t.cross.max = -e, t.crossTarget = -t.crossTarget;
}
function K1(t) {
  t && (t.value = -t.value, t.expanded = t.expanded === null ? null : -t.expanded);
}
const ns = {
  Identity: { x: 1, y: 1, transpose: !1 },
  Rotate90: { x: -1, y: 1, transpose: !0 },
  Rotate180: { x: -1, y: -1, transpose: !1 },
  Rotate270: { x: 1, y: -1, transpose: !0 },
  FlipX: { x: -1, y: 1, transpose: !1 },
  FlipY: { x: 1, y: -1, transpose: !1 }
};
function dQe(t) {
  return t.transpose ? {
    x: t.y,
    y: t.x,
    transpose: !0
  } : t;
}
function uQe(t, e) {
  const n = { ...t };
  return e.transpose && (pf(n, "x", "y"), n.transpose = !n.transpose), e.x === -1 && (n.x = -n.x), e.y === -1 && (n.y = -n.y), n;
}
function pf(t, e, n) {
  const r = t[e];
  t[e] = t[n], t[n] = r;
}
function wV(t, e) {
  e.x = t.x * e.x, e.y = t.y * e.y, t.transpose && pf(e, "x", "y");
}
function Hg(t, e) {
  t.x === -1 && (e.x = -(e.x + e.width)), t.y === -1 && (e.y = -(e.y + e.height)), t.transpose && (pf(e, "x", "y"), pf(e, "width", "height"));
}
function SV(t, e) {
  t.x === -1 && (pf(e, "left", "right"), W1(e.top), W1(e.bottom), K1(e.left), K1(e.right)), t.y === -1 && (pf(e, "top", "bottom"), W1(e.left), W1(e.right), K1(e.top), K1(e.bottom)), t.transpose && (pf(e, "left", "top"), pf(e, "right", "bottom"));
}
class fQe {
  constructor(e) {
    P(this, "options");
    P(this, "A");
    P(this, "B");
    P(this, "common");
    P(this, "gapX");
    P(this, "gapY");
    P(this, "midX");
    P(this, "midY");
    P(this, "bias");
    P(this, "transform", ns.Identity);
    P(this, "inverse", ns.Identity);
    this.options = e.options, this.A = e.A, this.B = e.B, this.common = e.common, this.midX = e.midX, this.midY = e.midY, this.gapX = e.gapX, this.gapY = e.gapY, this.bias = new I(1, 1);
  }
  apply(e) {
    if (this.transform = uQe(e, this.transform), this.inverse = dQe(this.transform), Hg(e, this.A.original), Hg(e, this.B.original), Hg(e, this.common.original), Hg(e, this.A.expanded), Hg(e, this.B.expanded), Hg(e, this.common.expanded), SV(e, this.A.edges), SV(e, this.B.edges), wV(e, this.bias), e.x === -1 && (this.gapX = -this.gapX, this.midX = this.midX === null ? null : -this.midX), e.y === -1 && (this.gapY = -this.gapY, this.midY = this.midY === null ? null : -this.midY), e.transpose) {
      let n = this.midX;
      this.midX = this.midY, this.midY = n, n = this.gapX, this.gapX = this.gapY, this.gapY = n;
    }
  }
  reset() {
    this.apply(this.inverse);
  }
  vec(e, n) {
    const r = new I(e, n);
    return wV(this.inverse, r), r;
  }
}
const Vg = 0.01;
class Di {
  constructor(e, n) {
    P(this, "points", []);
    P(this, "_midpointHandle", null);
    this.info = e, this.name = n;
  }
  add(e, n) {
    return this.points.push(this.info.vec(e, n)), this;
  }
  midpointHandle(e) {
    tt(this._midpointHandle === null, "midX/midY called multiple times");
    const n = I.Lrp(
      this.points[this.points.length - 2],
      this.points[this.points.length - 1],
      0.5
    );
    return this._midpointHandle = {
      axis: this.info.transform.transpose ? e === "x" ? "y" : "x" : e,
      point: n,
      segmentStart: this.points[this.points.length - 2].clone(),
      segmentEnd: this.points[this.points.length - 1].clone()
    }, this;
  }
  build() {
    const e = [];
    for (let n = 0; n < this.points.length; n++) {
      const r = this.points[n], s = e[e.length - 1], o = e[e.length - 2];
      if (!s || !o)
        e.push(r);
      else {
        const i = Math.abs(r.x - s.x), a = Math.abs(r.y - s.y), c = Math.abs(r.x - o.x), l = Math.abs(r.y - o.y);
        i < Vg && a < Vg || (i < Vg && c < Vg ? s.y = r.y : a < Vg && l < Vg ? s.x = r.x : e.push(r));
      }
    }
    return {
      name: this.name,
      points: e,
      distance: hQe(e),
      aEdgePicking: "manual",
      bEdgePicking: "manual",
      skipPointsWhenDrawing: /* @__PURE__ */ new Set(),
      midpointHandle: this._midpointHandle
    };
  }
}
function hQe(t) {
  let e = 0;
  for (let n = 0; n < t.length - 1; n++) {
    const r = t[n], s = t[n + 1];
    e += Math.abs(s.x - r.x) + Math.abs(s.y - r.y);
  }
  return e;
}
function G1(t) {
  const e = t.A.edges.right, n = t.B.edges.left;
  if (!e || !n) return null;
  if (e.crossTarget > n.crossTarget && t.apply(ns.FlipY), t.gapX > 0 && t.midX !== null)
    return new Di(t, "to left 1").add(e.value, e.crossTarget).add(t.midX, e.crossTarget).add(t.midX, n.crossTarget).midpointHandle("x").add(n.value, n.crossTarget).build();
  if (e.expanded === null || n.expanded === null) return null;
  if (t.midY !== null)
    return new Di(t, "to left 2").add(e.value, e.crossTarget).add(e.expanded, e.crossTarget).add(e.expanded, t.midY).add(n.expanded, t.midY).midpointHandle("y").add(n.expanded, n.crossTarget).add(n.value, n.crossTarget).build();
  const r = Math.abs(e.value - t.common.expanded.right) + Math.abs(e.crossTarget - t.common.expanded.bottom) + Math.abs(t.common.expanded.right - n.expanded) + Math.abs(t.common.expanded.bottom - n.crossTarget) + t.options.expandElbowLegLength + 6, s = t.options.expandElbowLegLength + Math.abs(e.crossTarget - t.common.expanded.top) + Math.abs(e.expanded - t.common.expanded.left) + Math.abs(t.common.expanded.top - n.crossTarget) + Math.abs(t.common.expanded.left - n.value) + // 6 points in this arrow, plus bias towards down/right:
  6 + t.bias.y, o = t.gapX < 0 && t.midX !== null ? t.options.expandElbowLegLength + Math.abs(e.crossTarget - t.A.expanded.bottom) + t.common.expanded.width + Math.abs(t.A.expanded.bottom - t.B.expanded.top) + Math.abs(t.B.expanded.top - n.crossTarget) + t.options.expandElbowLegLength + // 8 points in this arrow
  8 : 1 / 0;
  return r < s && r < o ? new Di(t, "to left 3").add(e.value, e.crossTarget).add(t.common.expanded.right, e.crossTarget).add(t.common.expanded.right, t.common.expanded.bottom).add(n.expanded, t.common.expanded.bottom).add(n.expanded, n.crossTarget).add(n.value, n.crossTarget).build() : s < o ? new Di(t, "to left 4").add(e.value, e.crossTarget).add(e.expanded, e.crossTarget).add(e.expanded, t.common.expanded.top).add(t.common.expanded.left, t.common.expanded.top).add(t.common.expanded.left, n.crossTarget).add(n.value, n.crossTarget).build() : t.midX !== null ? new Di(t, "to left 5").add(e.value, e.crossTarget).add(e.expanded, e.crossTarget).add(e.expanded, t.A.expanded.bottom).add(t.midX, t.A.expanded.bottom).add(t.midX, t.B.expanded.top).midpointHandle("y").add(n.expanded, t.B.expanded.top).add(n.expanded, n.crossTarget).add(n.value, n.crossTarget).build() : null;
}
function Vb(t) {
  const e = t.A.edges.right, n = t.B.edges.top;
  if (!e || !n) return null;
  if (e.crossTarget < (n.expanded ?? n.value) && n.crossTarget > (e.expanded ?? e.value) || t.A.isPoint && t.B.expanded.containsPoint(t.A.original.center))
    return new Di(t, "to top 1").add(e.value, e.crossTarget).add(n.crossTarget, e.crossTarget).add(n.crossTarget, n.value).build();
  if (t.gapX > 0 && t.midX !== null && n.expanded !== null)
    return new Di(t, "to top 2").add(e.value, e.crossTarget).add(t.midX, e.crossTarget).add(t.midX, n.expanded).midpointHandle("x").add(n.crossTarget, n.expanded).add(n.crossTarget, n.value).build();
  if (t.gapY > 0 && e.expanded !== null && n.crossTarget < e.expanded && t.midY !== null)
    return new Di(t, "to top 3").add(e.value, e.crossTarget).add(e.expanded, e.crossTarget).add(e.expanded, t.midY).add(n.crossTarget, t.midY).midpointHandle("y").add(n.crossTarget, n.value).build();
  const r = Math.abs(e.value - t.common.expanded.right) + Math.abs(e.crossTarget - t.common.expanded.top) + Math.abs(n.crossTarget - t.common.expanded.right) + Math.abs(n.value - t.common.expanded.top), s = e.expanded !== null && t.midY !== null && n.expanded !== null ? Math.abs(e.value - e.expanded) + Math.abs(t.B.expanded.left - e.expanded) + Math.abs(t.B.expanded.left - n.crossTarget) + Math.abs(e.crossTarget - t.B.expanded.top) + Math.abs(n.value - n.expanded) : 1 / 0, o = e.expanded !== null && t.midX !== null && n.expanded !== null ? Math.abs(e.value - t.common.expanded.right) + Math.abs(e.crossTarget - t.A.expanded.bottom) + Math.abs(e.expanded - n.crossTarget) + Math.abs(t.A.expanded.bottom - n.expanded) + Math.abs(n.expanded - n.value) : 1 / 0;
  return r < s && r < o ? new Di(t, "to top 4").add(e.value, e.crossTarget).add(t.common.expanded.right, e.crossTarget).add(t.common.expanded.right, t.common.expanded.top).add(n.crossTarget, t.common.expanded.top).add(n.crossTarget, n.value).build() : n.expanded !== null && e.expanded !== null && t.midY !== null && s < o ? new Di(t, "to top 5").add(e.value, e.crossTarget).add(e.expanded, e.crossTarget).add(e.expanded, t.midY).add(t.B.expanded.left, t.midY).midpointHandle("y").add(t.B.expanded.left, n.expanded).add(n.crossTarget, n.expanded).add(n.crossTarget, n.value).build() : n.expanded !== null && e.expanded !== null && t.midX !== null ? new Di(t, "to top 6").add(e.value, e.crossTarget).add(e.expanded, e.crossTarget).add(e.expanded, t.A.expanded.bottom).add(t.midX, t.A.expanded.bottom).add(t.midX, n.expanded).midpointHandle("x").add(n.crossTarget, n.expanded).add(n.crossTarget, n.value).build() : null;
}
function Y1(t) {
  return t.apply(ns.FlipY), Vb(t);
}
function q1(t) {
  const e = t.A.edges.right, n = t.B.edges.right;
  if (!e || !n) return null;
  if ((t.gapX <= 0 || e.crossTarget > t.B.expanded.bottom || e.crossTarget < t.B.expanded.top) && (n.value > t.A.original.left || n.crossTarget > t.A.expanded.bottom || n.crossTarget < t.A.expanded.top))
    return new Di(t, "to right 1").add(e.value, e.crossTarget).add(t.common.expanded.right, e.crossTarget).add(t.common.expanded.right, n.crossTarget).add(n.value, n.crossTarget).build();
  if (t.midX === null) return null;
  if (n.expanded !== null && t.gapX >= 0) {
    const r = Math.abs(n.crossTarget - t.B.expanded.bottom) + Math.abs(e.crossTarget - t.B.expanded.bottom), s = Math.abs(n.crossTarget - t.B.expanded.top) + Math.abs(e.crossTarget - t.B.expanded.top), o = r < s ? "bottom" : "top";
    return new Di(t, `to right 2 via ${o}`).add(e.value, e.crossTarget).add(t.midX, e.crossTarget).add(t.midX, t.B.expanded[o]).midpointHandle("x").add(n.expanded, t.B.expanded[o]).add(n.expanded, n.crossTarget).add(n.value, n.crossTarget).build();
  }
  if (e.expanded !== null && t.gapX <= 0) {
    const r = Math.abs(n.crossTarget - t.A.expanded.bottom) + Math.abs(e.crossTarget - t.A.expanded.bottom), s = Math.abs(n.crossTarget - t.A.expanded.top) + Math.abs(e.crossTarget - t.A.expanded.top), o = r < s ? "bottom" : "top";
    return new Di(t, `to right 3 via ${o}`).add(e.value, e.crossTarget).add(e.expanded, e.crossTarget).add(e.expanded, t.A.expanded[o]).add(t.midX, t.A.expanded[o]).add(t.midX, n.crossTarget).midpointHandle("x").add(n.value, n.crossTarget).build();
  }
  return null;
}
const pQe = {
  top: {
    top: [ns.Rotate270, q1],
    left: [ns.Rotate270, Vb],
    bottom: [ns.Rotate270, G1],
    right: [ns.Rotate270, Y1]
  },
  right: {
    top: [ns.Identity, Vb],
    right: [ns.Identity, q1],
    bottom: [ns.Identity, Y1],
    left: [ns.Identity, G1]
  },
  bottom: {
    top: [ns.Rotate90, G1],
    left: [ns.Rotate90, Y1],
    bottom: [ns.Rotate90, q1],
    right: [ns.Rotate90, Vb]
  },
  left: {
    top: [ns.Rotate180, Y1],
    left: [ns.Rotate180, q1],
    bottom: [ns.Rotate180, Vb],
    right: [ns.Rotate180, G1]
  }
};
function rs(t, e, n) {
  const [r, s] = pQe[e][n];
  t.apply(r);
  const o = s(t);
  return t.reset(), o;
}
function gQe(t, e) {
  let n = null;
  if (
    // +1 to bias us towards the x-axis. without this, we get flicker as we move an arrow locket
    // to 45 deg (as gapx/gapy are almost equal and the result depends on floating point
    // precision)
    Math.abs(t.gapX) + 1 > Math.abs(t.gapY) && t.midX !== null
  )
    t.gapX > 0 ? n = rs(t, "right", "left") : n = rs(t, "left", "right");
  else {
    const i = t.A.edges.right, a = t.A.edges.left, c = t.B.edges.top, l = t.B.edges.bottom;
    t.A.isPoint && t.B.isPoint ? t.gapY > 0 ? n = rs(t, "bottom", "top") : n = rs(t, "top", "bottom") : i && c && (i.expanded ?? i.value) <= c.crossTarget && i.crossTarget <= (c.expanded ?? c.value) ? n = rs(t, "right", "top") : i && l && (i.expanded ?? i.value) <= l.crossTarget && i.crossTarget >= (l.expanded ?? l.value) ? n = rs(t, "right", "bottom") : a && c && (a.expanded ?? a.value) >= c.crossTarget && a.crossTarget <= (c.expanded ?? c.value) ? n = rs(t, "left", "top") : a && l && (a.expanded ?? a.value) >= l.crossTarget && a.crossTarget >= (l.expanded ?? l.value) ? n = rs(t, "left", "bottom") : t.gapY > 0 && t.midY !== null ? n = rs(t, "bottom", "top") : t.gapY < 0 && t.midY !== null && (n = rs(t, "top", "bottom"));
  }
  if (n)
    return n.aEdgePicking = e, n.bEdgePicking = e, n;
  const r = bV.filter((i) => t.A.edges[i]), s = bV.filter((i) => t.B.edges[i]), o = r.flatMap(
    (i) => s.map((a) => [i, a, e, e])
  );
  return pm(t, o);
}
function mQe(t, e) {
  let n = null;
  const r = t.A.edges.right, s = t.A.edges.left, o = t.B.edges.top, i = t.B.edges.bottom;
  switch (e) {
    case "right":
      t.gapX > 0 && t.gapX > Math.abs(t.gapY) && t.midX !== null ? n = rs(t, "right", "left") : r && o && (r.expanded ?? r.value) <= o.crossTarget && r.crossTarget <= (o.expanded ?? o.value) ? n = rs(t, "right", "top") : r && i && (r.expanded ?? r.value) <= i.crossTarget && r.crossTarget >= (i.expanded ?? i.value) && (n = rs(t, "right", "bottom"));
      break;
    case "left":
      t.gapX < 0 && Math.abs(t.gapX) > Math.abs(t.gapY) && t.midX !== null ? n = rs(t, "left", "right") : s && o && (s.expanded ?? s.value) >= o.crossTarget && s.crossTarget <= (o.expanded ?? o.value) ? n = rs(t, "left", "top") : s && i && (s.expanded ?? s.value) >= i.crossTarget && s.crossTarget >= (i.expanded ?? i.value) && (n = rs(t, "left", "bottom"));
      break;
    case "top":
    case "bottom":
      break;
    default:
      Jt(e);
  }
  if (n)
    return n.aEdgePicking = "manual", n.bEdgePicking = "auto", n;
  switch (e) {
    case "top":
      return pm(t, [
        ["top", "bottom", "manual", "auto"],
        ["top", "right", "manual", "auto"],
        ["top", "left", "manual", "auto"],
        ["top", "top", "manual", "auto"]
      ]);
    case "bottom":
      return pm(t, [
        ["bottom", "top", "manual", "auto"],
        ["bottom", "right", "manual", "auto"],
        ["bottom", "left", "manual", "auto"],
        ["bottom", "bottom", "manual", "auto"]
      ]);
    case "left":
      return pm(t, [
        ["left", "right", "manual", "auto"],
        ["left", "bottom", "manual", "auto"],
        ["left", "left", "manual", "auto"],
        ["left", "top", "manual", "auto"]
      ]);
    case "right":
      return pm(t, [
        ["right", "left", "manual", "auto"],
        ["right", "bottom", "manual", "auto"],
        ["right", "right", "manual", "auto"],
        ["right", "top", "manual", "auto"]
      ]);
  }
}
function yQe(t, e, n) {
  const r = rs(t, e, n);
  return r || (t.A.isPoint && t.B.isPoint ? pm(t, [
    [Ug[e], Ug[n], "manual", "manual"],
    [e, Ug[n], "manual", "auto"],
    [Ug[e], n, "auto", "manual"]
  ]) : t.A.isPoint ? rs(t, Ug[e], n) : t.B.isPoint ? rs(t, e, Ug[n]) : null);
}
function pm(t, e) {
  let n = null, r = 1 / 0, s = 1 / 0, o = 0;
  for (const [i, a, c, l] of e) {
    o += 1;
    const d = rs(t, i, a);
    d && (d.aEdgePicking = c, d.bEdgePicking = l, d.points.length < r ? (r = d.points.length, s = d.distance, n = d) : d.points.length === r && d.distance + o < s && (s = d.distance, n = d));
  }
  return n;
}
function Sue(t, e, n) {
  const r = t.getShapeUtil(e.type).options, s = {
    elbowMidpoint: e.props.elbowMidPoint,
    expandElbowLegLength: r.expandElbowLegLength[e.props.size] * e.props.scale,
    minElbowLegLength: r.minElbowLegLength[e.props.size] * e.props.scale
  };
  let o = CV(t, e, n.start, e.props.start), i = CV(t, e, n.end, e.props.end);
  o = PV(o, i, s), i = PV(i, o, s);
  const a = !!(!o.side && i.side);
  let { aTerminal: c, bTerminal: l } = a ? { aTerminal: i, bTerminal: o } : { aTerminal: o, bTerminal: i }, d = {
    top: bo(c, l, "top", s),
    right: bo(c, l, "right", s),
    bottom: bo(c, l, "bottom", s),
    left: bo(c, l, "left", s)
  }, u = {
    top: bo(l, c, "top", s),
    right: bo(l, c, "right", s),
    bottom: bo(l, c, "bottom", s),
    left: bo(l, c, "left", s)
  };
  const f = _V(d, c.side), p = _V(u, l.side);
  let g = !1;
  (!f || !p) && (g = !0, f || (l = Wb(l)), p || (c = Wb(c)), l.bounds.containsPoint(c.target, s.expandElbowLegLength) && (l = Wb(l)), c.bounds.containsPoint(l.target, s.expandElbowLegLength) && (c = Wb(c))), g && (d = {
    top: bo(c, l, "top", s),
    right: bo(c, l, "right", s),
    bottom: bo(c, l, "bottom", s),
    left: bo(c, l, "left", s)
  }, u = {
    top: bo(l, c, "top", s),
    right: bo(l, c, "right", s),
    bottom: bo(l, c, "bottom", s),
    left: bo(l, c, "left", s)
  });
  const y = c.isPoint ? c.bounds : c.bounds.clone().expandBy(s.expandElbowLegLength), m = l.isPoint ? l.bounds : l.bounds.clone().expandBy(s.expandElbowLegLength), v = {
    original: _e.Common([c.bounds, l.bounds]),
    expanded: _e.Common([y, m])
  };
  let b = l.bounds.minX - c.bounds.maxX;
  b < 0 && (b = c.bounds.minX - l.bounds.maxX, b < 0 && (b = 0), b = -b);
  let x = l.bounds.minY - c.bounds.maxY;
  x < 0 && (x = c.bounds.minY - l.bounds.maxY, x < 0 && (x = 0), x = -x);
  const w = c.minEndSegmentLength * 3, S = l.minEndSegmentLength * 3, C = (c.isPoint ? w : s.minElbowLegLength) + (l.isPoint ? S : s.minElbowLegLength);
  let _ = null;
  b > C ? _ = {
    a: c.isPoint ? c.bounds.maxX + w : y.maxX,
    b: l.isPoint ? l.bounds.minX - S : m.minX
  } : b < -C && (_ = {
    a: c.isPoint ? c.bounds.minX - w : y.minX,
    b: l.isPoint ? l.bounds.maxX + S : m.maxX
  });
  let E = null;
  x > C ? E = {
    a: c.isPoint ? c.bounds.maxY + w : y.maxY,
    b: l.isPoint ? l.bounds.minY - S : m.minY
  } : x < -C && (E = {
    a: c.isPoint ? c.bounds.minY - w : y.minY,
    b: l.isPoint ? l.bounds.maxY + S : m.maxY
  });
  const M = a ? 1 - s.elbowMidpoint : s.elbowMidpoint, N = _ ? kt(_.a, _.b, M) : null, O = E ? kt(E.a, E.b, M) : null, D = {
    options: s,
    swapOrder: a,
    A: {
      isPoint: c.isPoint,
      target: c.target,
      isExact: c.isExact,
      arrowheadOffset: c.arrowheadOffset,
      minEndSegmentLength: c.minEndSegmentLength,
      original: c.bounds,
      expanded: y,
      edges: d,
      geometry: c.geometry
    },
    B: {
      isPoint: l.isPoint,
      target: l.target,
      isExact: l.isExact,
      arrowheadOffset: l.arrowheadOffset,
      minEndSegmentLength: l.minEndSegmentLength,
      original: l.bounds,
      expanded: m,
      edges: u,
      geometry: l.geometry
    },
    common: v,
    gapX: b,
    gapY: x,
    midX: N,
    midY: O
  }, k = new fQe(D), A = EV(c, l, D.A.edges), R = EV(l, c, D.B.edges);
  let j;
  return A && R ? j = yQe(k, A, R) : A && !R && (j = mQe(k, A)), j || (j = gQe(k, A || R ? "fallback" : "auto")), j && (TV("first", D.A, D.B, j), TV("last", D.B, D.A, j), SQe(j, c, l), a && j.points.reverse()), {
    ...D,
    route: j,
    midXRange: _ ? a ? { lo: _.b, hi: _.a } : { lo: _.a, hi: _.b } : null,
    midYRange: E ? a ? { lo: E.b, hi: E.a } : { lo: E.a, hi: E.b } : null
  };
}
function vQe(t, e) {
  const n = t.swapOrder ? t.B.target : t.A.target, r = t.swapOrder ? t.A.target : t.B.target, s = I.ManhattanDist(e.points[0], e.points[1]), o = I.ManhattanDist(
    e.points[e.points.length - 2],
    e.points[e.points.length - 1]
  ), i = I.ManhattanDist(n, e.points[1]), a = I.ManhattanDist(e.points[e.points.length - 2], r), c = s - i, l = o - a, d = [n, ...e.points, r];
  return {
    name: e.name,
    distance: e.distance + c + l,
    points: d.filter((u) => !e.skipPointsWhenDrawing.has(u)),
    aEdgePicking: e.aEdgePicking,
    bEdgePicking: e.bEdgePicking,
    skipPointsWhenDrawing: e.skipPointsWhenDrawing,
    midpointHandle: e.midpointHandle
  };
}
function bQe(t) {
  return Hr(t.x, 0.5) && Hr(t.y, 0.5) ? null : Math.abs(t.x - 0.5) > // slightly bias towards x arrows to prevent flickering when the anchor is right on the line
  // between the two directions
  Math.abs(t.y - 0.5) - 1e-4 ? t.x < 0.5 ? "left" : "right" : t.y < 0.5 ? "top" : "bottom";
}
function CV(t, e, n, r) {
  const s = da[e.props.size] * e.props.scale / 2, o = s * e.props.scale * 3;
  if (n) {
    const i = t.getShape(n.toId), a = xQe(t, e, n.toId, n.props);
    if (a && i) {
      let c = 0;
      const l = n.props.terminal === "start" ? "arrowheadStart" : "arrowheadEnd";
      if (e.props[l] !== "none") {
        const f = "scale" in i.props ? i.props.scale : 1, p = "size" in i.props ? (da[i.props.size] ?? 0) * f / 2 : 0;
        c = s + p + Iw * e.props.scale;
      }
      let d = null;
      const u = a.target;
      return n.props.isPrecise && (d = bQe(
        I.RotWith(
          n.props.normalizedAnchor,
          { x: 0.5, y: 0.5 },
          a.shapeToArrowTransform.rotation()
        )
      )), {
        targetShapeId: n.toId,
        isPoint: !1,
        isExact: n.props.isExact,
        bounds: a.bounds,
        geometry: a.geometry,
        target: u,
        arrowheadOffset: c,
        minEndSegmentLength: o,
        side: d,
        snap: n.props.snap
      };
    }
  }
  return {
    targetShapeId: null,
    bounds: _e.FromCenter(r, { x: 0, y: 0 }),
    geometry: null,
    isExact: !1,
    isPoint: !0,
    target: I.From(r),
    arrowheadOffset: 0,
    minEndSegmentLength: o,
    side: null,
    snap: "none"
  };
}
function xQe(t, e, n, r) {
  const s = r.terminal === "start" ? e.props.arrowheadStart !== "none" : e.props.arrowheadEnd !== "none", o = t.getShapeGeometry(
    n,
    s ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  if (!o)
    return null;
  const i = t.getShapePageTransform(e.id), a = t.getShapePageTransform(n), c = i.clone().invert().multiply(a), l = o.transform(c), d = { x: 0.5, y: 0.5 }, u = r.isPrecise ? r.normalizedAnchor : d, f = {
    x: kt(
      o.bounds.minX,
      o.bounds.maxX,
      u.x
    ),
    y: kt(
      o.bounds.minY,
      o.bounds.maxY,
      u.y
    )
  }, p = {
    x: kt(
      o.bounds.minX,
      o.bounds.maxX,
      d.x
    ),
    y: kt(
      o.bounds.minY,
      o.bounds.maxY,
      d.y
    )
  }, g = we.applyToPoint(c, f), y = we.applyToPoint(c, p);
  return {
    bounds: l.bounds,
    geometry: l,
    target: g,
    center: y,
    shapeToArrowTransform: c
  };
}
const wQe = {
  top: {
    expand: -1,
    main: "minY",
    opposite: "maxY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "max",
    crossAxis: "x"
  },
  bottom: {
    expand: 1,
    main: "maxY",
    opposite: "minY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "min",
    crossAxis: "x"
  },
  left: {
    expand: -1,
    main: "minX",
    opposite: "maxX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "max",
    crossAxis: "y"
  },
  right: {
    expand: 1,
    main: "maxX",
    opposite: "minX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "min",
    crossAxis: "y"
  }
};
function bo(t, e, n, r) {
  const s = wQe[n], o = t.targetShapeId === e.targetShapeId && t.targetShapeId !== null && (t.snap === "edge" || t.snap === "edge-point") && (e.snap === "edge" || e.snap === "edge-point"), i = t.bounds[s.main], a = t.isPoint ? null : i + s.expand * r.expandElbowLegLength, c = BO(t.bounds[s.crossMin], t.bounds[s.crossMax]);
  let l = c;
  if (!l)
    return null;
  tt(c);
  const d = BO(e.bounds[s.main], e.bounds[s.opposite]);
  e.isPoint || (d[s.bRangeExpand] -= r.minElbowLegLength * 2 * s.expand);
  const u = cQe(
    BO(e.bounds[s.crossMin], e.bounds[s.crossMax]),
    r.expandElbowLegLength
  );
  tt(d && u);
  let f = !1;
  if (hT(i, d) && !t.isPoint && !e.isPoint && !o) {
    const g = lQe(l, u);
    switch (g.length) {
      case 0:
        return null;
      case 1:
        f = g[0] !== l, l = g[0];
        break;
      case 2:
        f = !0, l = xV(g[0]) > xV(g[1]) ? g[0] : g[1];
        break;
      default:
        Jt(g);
    }
  }
  if (!hT(t.target[s.crossAxis], l))
    return null;
  const p = t.target[s.crossAxis];
  return {
    value: i,
    expanded: a,
    cross: l,
    crossTarget: p,
    isPartial: f
  };
}
function _V(t, e) {
  return e === null ? !!(t.bottom || t.left || t.right || t.top) : e === "x" ? !!t.left || !!t.right : e === "y" ? !!t.top || !!t.bottom : !!t[e];
}
function EV(t, e, n) {
  switch (t.side) {
    case null:
      return null;
    case "x":
      return t.bounds.center.x > e.bounds.center.x && (n != null && n.left) ? "left" : n != null && n.right ? "right" : null;
    case "y":
      return t.bounds.center.y > e.bounds.center.y && (n != null && n.top) ? "top" : n != null && n.bottom ? "bottom" : null;
    default:
      return t.side;
  }
}
function Wb(t) {
  if (t.isPoint) return t;
  let e = null, n = 0;
  return (t.snap === "edge" || t.snap === "edge-point") && (n = t.arrowheadOffset, (t.side === "x" || t.side === "left" || t.side === "right") && (e = "x"), (t.side === "y" || t.side === "top" || t.side === "bottom") && (e = "y")), {
    targetShapeId: t.targetShapeId,
    side: e,
    bounds: new _e(t.target.x, t.target.y, 0, 0),
    geometry: t.geometry,
    target: t.target,
    arrowheadOffset: n,
    minEndSegmentLength: t.minEndSegmentLength,
    isExact: t.isExact,
    isPoint: !0,
    snap: t.snap
  };
}
function TV(t, e, n, r) {
  if (!e.geometry) return;
  const s = t === "first" ? r.points[0] : r.points[r.points.length - 1], o = t === "first" ? r.points[1] : r.points[r.points.length - 2], i = e.geometry.isClosed ? o : e.target, a = I.ManhattanDist(s, i);
  let c = null, l = 1 / 0;
  if (e.isExact)
    c = e.target;
  else if (e.geometry) {
    const d = e.geometry.intersectLineSegment(o, e.target, {
      includeLabels: !1,
      includeInternal: !1
    });
    e.geometry.hitTestPoint(
      e.target,
      Math.max(1, e.arrowheadOffset),
      !0,
      Ul.EXCLUDE_NON_STANDARD
    ) && d.push(e.target);
    for (const u of d) {
      const f = I.ManhattanDist(i, u);
      f < l && (l = f, c = u);
    }
  }
  if (c) {
    let d = e.arrowheadOffset;
    const u = I.ManhattanDist(o, c), f = e.arrowheadOffset * 2;
    if (u < f) {
      const m = f - e.arrowheadOffset;
      d = u - m;
    }
    d < e.minEndSegmentLength && (e.geometry.bounds.containsPoint(n.target) ? d = Math.max(0, d) : d = -e.arrowheadOffset);
    let p = c, g = !1;
    if (!e.isExact && d !== 0) {
      const m = I.Nudge(c, o, d);
      p = m, d < 0 && !e.geometry.hitTestPoint(m, 0, !0, Ul.EXCLUDE_NON_STANDARD) ? p = c : (d < 0 && (g = !0), p = m);
    }
    const y = I.ManhattanDist(o, p);
    if (r.distance += y - a, s.x = p.x, s.y = p.y, g) {
      const m = I.Lrp(o, s, 0.5);
      r.skipPointsWhenDrawing.add(m), r.points.splice(t === "first" ? 1 : r.points.length - 1, 0, m);
    }
  }
}
function SQe(t, e, n) {
  if (t) {
    if (t.points.length >= 3) {
      const r = t.points[0], s = t.points[1];
      if (I.ManhattanDist(r, s) < e.minEndSegmentLength && (t.points.splice(1, 1), t.points.length >= 3)) {
        const i = Hr(r.x, s.x) ? "y" : "x";
        t.points[1][i] = r[i];
      }
    }
    if (t.points.length >= 3) {
      const r = t.points[t.points.length - 1], s = t.points[t.points.length - 2];
      if (I.ManhattanDist(r, s) < n.minEndSegmentLength && (t.points.splice(t.points.length - 2, 1), t.points.length >= 3)) {
        const i = Hr(r.x, s.x) ? "y" : "x";
        t.points[t.points.length - 2][i] = r[i];
      }
    }
  }
}
function PV(t, e, n) {
  if (!t.geometry || t.geometry.isClosed) return t;
  const r = t.geometry.uninterpolateAlongEdge(
    t.target,
    Ul.EXCLUDE_NON_STANDARD
  ), s = t.geometry.interpolateAlongEdge(
    r - 0.01 / t.geometry.length
  ), i = t.geometry.interpolateAlongEdge(
    r + 0.01 / t.geometry.length
  ).sub(s).per().uni(), a = Math.abs(i.x) > Math.abs(i.y) ? Pw.x : Pw.y;
  if (t.geometry.bounds.containsPoint(e.target, n.expandElbowLegLength))
    return t.side = a.self, Wb(t);
  const c = a.v(
    t.target[a.self] - t.bounds[a.size] * 2,
    t.target[a.cross]
  ), l = a.v(
    t.target[a.self] + t.bounds[a.size] * 2,
    t.target[a.cross]
  );
  let d = null, u = 0, f = null, p = 0, g = a.self;
  for (const y of t.geometry.intersectLineSegment(
    c,
    l,
    Ul.EXCLUDE_NON_STANDARD
  ))
    Math.abs(y[a.self] - t.target[a.self]) < 1 || (y[a.self] < t.target[a.self] ? I.ManhattanDist(y, t.target) > u && (u = I.ManhattanDist(y, t.target), d = y) : I.ManhattanDist(y, t.target) > p && (p = I.ManhattanDist(y, t.target), f = y));
  return d && f ? u > p ? g = a.hiEdge : g = a.loEdge : d && !f ? g = a.hiEdge : !d && f && (g = a.loEdge), t.side = g, t;
}
const CQe = 8;
function _Qe(t) {
  return t.props.kind !== "arc" ? !1 : Math.abs(t.props.bend) < CQe * t.props.scale;
}
function pT(t, e, n) {
  const r = t.getBindingsFromShape(e, "arrow").find((c) => c.props.terminal === n);
  if (!r) return;
  const s = t.getShape(r.toId);
  if (!s) return;
  const o = t.getShapePageTransform(s), i = n === "start" ? e.props.arrowheadStart !== "none" : e.props.arrowheadEnd !== "none", a = t.getShapeGeometry(
    s,
    i ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  return {
    shape: s,
    transform: o,
    isClosed: a.isClosed,
    isExact: r.props.isExact,
    didIntersect: !1,
    geometry: a
  };
}
function IV(t, e, n, r) {
  const s = t.getShape(n.toId);
  if (s) {
    const { point: o, size: i } = t.getShapeGeometry(s).bounds, a = I.Add(
      o,
      I.MulV(
        // if the parent is the bound shape, then it's ALWAYS precise
        n.props.isPrecise || r ? n.props.normalizedAnchor : { x: 0.5, y: 0.5 },
        i
      )
    ), c = we.applyToPoint(t.getShapePageTransform(s), a);
    return we.applyToPoint(we.Inverse(e), c);
  } else
    return new I(0, 0);
}
const EQe = MI(
  "arrow bindings",
  (t, e) => {
    const n = t.getBindingsFromShape(e.id, "arrow");
    return {
      start: n.find((r) => r.props.terminal === "start"),
      end: n.find((r) => r.props.terminal === "end")
    };
  },
  {
    // we only look at the arrow IDs:
    areRecordsEqual: (t, e) => t.id === e.id,
    // the records should stay the same:
    areResultsEqual: (t, e) => t.start === e.start && t.end === e.end
  }
);
function As(t, e) {
  return EQe.get(t, e.id);
}
const TQe = MI(
  "arrow info",
  (t, e) => {
    const n = As(t, e);
    if (e.props.kind === "elbow") {
      const r = Sue(t, e, n);
      if (!(r != null && r.route)) return fT(t, e, n);
      const s = r.swapOrder ? r.B : r.A, o = r.swapOrder ? r.A : r.B;
      return {
        type: "elbow",
        bindings: n,
        start: {
          handle: s.target,
          point: r.route.points[0],
          arrowhead: e.props.arrowheadStart
        },
        end: {
          handle: o.target,
          point: r.route.points[r.route.points.length - 1],
          arrowhead: e.props.arrowheadEnd
        },
        elbow: r,
        route: r.route,
        isValid: !0
      };
    }
    return _Qe(e) ? fT(t, e, n) : sQe(t, e, n);
  },
  {
    areRecordsEqual: (t, e) => t.props === e.props,
    areResultsEqual: V2e
  }
);
function Xa(t, e) {
  const n = typeof e == "string" ? e : e.id;
  return TQe.get(t, n);
}
function gm(t, e, n) {
  var a, c;
  const r = t.getShapePageTransform(e), s = F5(
    t,
    (a = n.start) == null ? void 0 : a.toId,
    (c = n.end) == null ? void 0 : c.toId
  ), o = n.start ? IV(
    t,
    r,
    n.start,
    s === "double-bound" || s === "start-contains-end"
  ) : I.From(e.props.start), i = n.end ? IV(
    t,
    r,
    n.end,
    s === "double-bound" || s === "end-contains-start"
  ) : I.From(e.props.end);
  return { start: o, end: i };
}
function ib(t, e, n, r) {
  const s = typeof e == "string" ? e : e.id, o = typeof n == "string" ? n : n.id, i = t.getBindingsFromShape(s, "arrow").filter((c) => c.props.terminal === r.terminal);
  i.length > 1 && t.deleteBindings(i.slice(1));
  const a = i[0];
  a ? t.updateBinding({
    ...a,
    toId: o,
    props: r
  }) : t.createBinding({
    type: "arrow",
    fromId: s,
    toId: o,
    props: r
  });
}
function Kb(t, e, n) {
  const r = t.getBindingsFromShape(e, "arrow").filter((s) => s.props.terminal === n);
  t.deleteBindings(r);
}
const mm = 10, Iw = 10, PQe = 10, da = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function F5(t, e, n) {
  if (!e || !n) return "safe";
  if (e === n) return "double-bound";
  const r = t.getShapePageBounds(e), s = t.getShapePageBounds(n);
  if (r && s) {
    if (r.contains(s)) return "start-contains-end";
    if (s.contains(r)) return "end-contains-start";
  }
  return "safe";
}
class l_ extends o_ {
  getDefaultProps() {
    return {
      isPrecise: !1,
      isExact: !1,
      normalizedAnchor: { x: 0.5, y: 0.5 },
      snap: "none"
    };
  }
  // when the binding itself changes
  onAfterCreate({ binding: e }) {
    const n = this.editor.getShape(e.fromId);
    n && zO(this.editor, n);
  }
  // when the binding itself changes
  onAfterChange({ bindingAfter: e }) {
    const n = this.editor.getShape(e.fromId);
    n && zO(this.editor, n);
  }
  // when the arrow itself changes
  onAfterChangeFromShape({
    shapeAfter: e
  }) {
    zO(this.editor, e);
  }
  // when the shape an arrow is bound to changes
  onAfterChangeToShape({
    binding: e,
    shapeBefore: n,
    shapeAfter: r,
    reason: s
  }) {
    s !== "ancestry" && n.parentId === r.parentId && n.index === r.index || Cue(this.editor, e.fromId);
  }
  // when the arrow is isolated we need to update it's x,y positions
  onBeforeIsolateFromShape({
    binding: e
  }) {
    const n = this.editor.getShape(e.fromId);
    n && gT({
      editor: this.editor,
      arrow: n,
      terminal: e.props.terminal
    });
  }
}
P(l_, "type", "arrow"), P(l_, "props", Ete), P(l_, "migrations", Tte);
function Cue(t, e) {
  var m;
  const n = t.getShape(e);
  if (!n) return;
  const r = As(t, n), { start: s, end: o } = r, i = s ? t.getShape(s.toId) : void 0, a = o ? t.getShape(o.toId) : void 0, c = t.getAncestorPageId(n);
  if (!c) return;
  let l;
  if (i && a)
    l = t.findCommonAncestor([i, a]) ?? c;
  else if (i || a) {
    const v = (m = i || a) == null ? void 0 : m.parentId;
    v && v === n.parentId ? l = n.parentId : l = c;
  } else
    return;
  l && l !== n.parentId && t.reparentShapes([e], l);
  const d = t.getShape(e);
  if (!d) throw Error("no reparented arrow");
  const u = t.getShapeNearestSibling(d, i), f = t.getShapeNearestSibling(d, a);
  let p;
  if (u && f)
    p = u.index > f.index ? u : f;
  else if (u && !f)
    p = u;
  else if (f && !u)
    p = f;
  else
    return;
  let g;
  const y = t.getSortedChildIdsForParent(p.parentId).map((v) => t.getShape(v)).filter((v) => v.index > p.index);
  if (y.length) {
    const v = y.find((b) => b.type !== "arrow");
    if (
      // ...then, if we're above the last shape we want to be above...
      d.index > p.index && // ...but below the next non-arrow sibling...
      (!v || d.index < v.index)
    )
      return;
    g = oy(p.index, y[0].index);
  } else
    g = Bc(p.index);
  g !== d.index && t.updateShapes([{ id: e, type: "arrow", index: g }]);
}
function zO(t, e) {
  const n = As(t, e);
  for (const r of ["start", "end"]) {
    const s = n[r];
    if (!s) continue;
    const o = t.getShape(s.toId), i = t.getAncestorPageId(e) === t.getAncestorPageId(o);
    (!o || !i) && gT({ editor: t, arrow: e, terminal: r, unbind: !0 });
  }
  Cue(t, e.id);
}
function gT({
  editor: t,
  arrow: e,
  terminal: n,
  unbind: r = !1,
  useHandle: s = !1
}) {
  const o = Xa(t, e);
  if (!o)
    throw new Error("expected arrow info");
  const i = s ? o.start.handle : o.start.point, a = s ? o.end.handle : o.end.point, c = n === "start" ? i : a, l = {
    id: e.id,
    type: "arrow",
    props: {
      [n]: { x: c.x, y: c.y },
      bend: e.props.bend
    }
  };
  if (o.type === "arc") {
    const d = n === "start" ? i : o.start.handle, u = n === "end" ? a : o.end.handle, f = I.Med(d, u), p = I.Sub(d, u).per().uni().mul(o.handleArc.radius * 2 * Math.sign(e.props.bend)), g = Z0(
      o.handleArc.center,
      I.Add(f, p),
      o.handleArc.center,
      o.handleArc.radius
    );
    tt((g == null ? void 0 : g.length) === 1);
    const y = I.Dist(f, g[0]) * Math.sign(e.props.bend);
    Hr(y, l.props.bend) || (l.props.bend = y);
  }
  t.updateShape(l), r && Kb(t, e, n);
}
function IQe({ children: t }) {
  const e = ie();
  return le(
    "shouldDisplayHandles",
    () => {
      if (e.isInAny("select.idle", "select.pointing_handle", "select.pointing_shape"))
        return !0;
      if (e.isInAny("select.editing_shape")) {
        const r = e.getOnlySelectedShape();
        return r && e.isShapeOfType(r, "note");
      }
      return !1;
    },
    [e]
  ) ? /* @__PURE__ */ h.jsx("svg", { className: "tl-user-handles tl-overlays__item", "aria-hidden": "true", children: t }) : null;
}
const kQe = new No();
function Ex(t) {
  return kQe.get(t, () => yr("arrowTarget", null));
}
function AQe(t) {
  return Ex(t).get();
}
function B5(t) {
  Ex(t).set(null);
}
function $k({
  editor: t,
  pointInPageSpace: e,
  arrow: n,
  isPrecise: r,
  currentBinding: s,
  oppositeBinding: o
}) {
  const i = t.getShapeUtil("arrow");
  if (i.options.shouldIgnoreTargets(t))
    return Ex(t).set(null), null;
  const a = i.options.shouldBeExact(t), c = n ? n.props.kind : t.getStyleForNextShape(aw), l = t.getShapeAtPoint(e, {
    hitInside: !0,
    hitFrameInside: !0,
    margin: c === "elbow" ? 8 : 0,
    filter: (R) => !R.isLocked && t.canBindShapes({
      fromShape: n ?? MQe,
      toShape: R,
      binding: "arrow"
    })
  });
  if (!l)
    return Ex(t).set(null), null;
  const d = t.getShapeGeometry(l), u = _e.ZeroFix(d.bounds), f = d.center, p = t.getShapePageTransform(l), g = t.getPointInShapeSpace(l, e), y = Math.max(
    d.bounds.width,
    d.bounds.height
  ), m = Qf(iQe, (R, j) => {
    const $ = Pw[aQe[R]], F = I.Mul(j, y).add(f);
    let L = !1, z = $.v(
      u[R],
      u[$.crossMid]
    ), H = 0;
    const U = d.intersectLineSegment(
      f,
      F,
      Ul.EXCLUDE_NON_STANDARD
    );
    for (const Z of U) {
      const K = I.Dist2(Z, f);
      K > H && (H = K, z = Z, L = d.isClosed);
    }
    return { point: p.applyToPoint(z), isEnabled: L, far: p.applyToPoint(F) };
  }), v = t.getZoomLevel(), b = i.options.minElbowHandleDistance / v, x = p.applyToPoint(f);
  for (const R of px(m)) {
    const j = m[R];
    I.DistMin(j.point, x, b) && (j.isEnabled = !1);
  }
  let w = r || a;
  w || (!s || s && l.id !== s.toId) && (w = t.inputs.pointerVelocity.len() < 0.5), r || (d.isClosed || (w = !0), o && l.id === o.toId && o.props.isPrecise && (w = !0));
  const S = !a && w && d.isClosed, C = !a && (w && c === "elbow" || !d.isClosed), _ = !a && w && c === "elbow" && d.isClosed, E = w && (d.isClosed || a), M = !a && w && c === "elbow" && d.isClosed;
  let N = "none", O = e;
  if (E || (N = "center", O = x), C) {
    const R = E ? X1(
      t,
      u,
      i.options.elbowArrowEdgeSnapDistance
    ) : 1 / 0, j = d.nearestPoint(
      g,
      {
        includeLabels: !1,
        includeInternal: !1
      }
    ), $ = p.applyToPoint(
      j
    );
    I.Dist($, e) < R && (N = "edge", O = $);
  }
  if (M) {
    const R = X1(
      t,
      u,
      i.options.elbowArrowAxisSnapDistance
    ), j = I.DistanceToLineSegment(
      m.left.far,
      m.right.far,
      e
    ), $ = I.DistanceToLineSegment(
      m.top.far,
      m.bottom.far,
      e
    ), F = j < $ && j < R ? "x" : $ < R ? "y" : null;
    if (F) {
      const L = Pw[F], z = I.Dist2(m[L.loEdge].far, e), H = I.Dist2(m[L.hiEdge].far, e), U = z < H ? L.loEdge : L.hiEdge;
      m[U].isEnabled && (N = "edge-point", O = m[U].point);
    }
  }
  if (_) {
    const R = X1(
      t,
      u,
      i.options.elbowArrowPointSnapDistance
    );
    let j = null, $ = 1 / 0;
    for (const [F, L] of ai(m)) {
      if (!L.isEnabled) continue;
      const z = I.Dist(L.point, e);
      z < R && z < $ && ($ = z, j = F);
    }
    j && (N = "edge-point", O = m[j].point);
  }
  if (S) {
    const R = X1(
      t,
      u,
      c === "elbow" ? i.options.elbowArrowCenterSnapDistance : i.options.arcArrowCenterSnapDistance
    );
    I.Dist(g, u.center) < R && (N = "center", O = x);
  }
  const D = t.getPointInShapeSpace(l, O), k = {
    x: sw(
      u.minX,
      u.maxX,
      D.x
    ),
    y: sw(
      u.minY,
      u.maxY,
      D.y
    )
  }, A = {
    target: l,
    arrowKind: c,
    handlesInPageSpace: m,
    centerInPageSpace: x,
    anchorInPageSpace: O,
    isExact: a,
    isPrecise: w,
    snap: N,
    normalizedAnchor: k
  };
  return Ex(t).set(A), A;
}
const MQe = { type: "arrow" };
function X1(t, e, n) {
  return wt(
    Math.min(e.width, e.height) * 0.15,
    4,
    n
  ) / t.getZoomLevel();
}
function OQe() {
  const t = ie();
  return le(
    "should show arrow hints",
    () => {
      if (t.isInAny("arrow.idle", "arrow.pointing")) return !0;
      if (t.isIn("select.pointing_handle")) {
        const n = t.getStateDescendant("select.pointing_handle");
        if (n.info.shape.type === "arrow" && (n.info.handle.id === "start" || n.info.handle.id === "end"))
          return !0;
      }
      if (t.isIn("select.dragging_handle")) {
        const n = t.getStateDescendant("select.dragging_handle");
        if (n.info.shape.type === "arrow" && (n.info.handle.id === "start" || n.info.handle.id === "end"))
          return !0;
      }
      return !1;
    },
    [t]
  ) ? /* @__PURE__ */ h.jsx(DQe, {}) : null;
}
function DQe() {
  const t = ie(), { ShapeIndicator: e } = Ln(), n = le("arrow target info", () => AQe(t), [t]);
  if (!n) return null;
  const { handlesInPageSpace: r, snap: s, anchorInPageSpace: o, arrowKind: i, isExact: a, isPrecise: c } = n, l = !a && i === "elbow";
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    e && /* @__PURE__ */ h.jsx(e, { shapeId: n.target.id }),
    l && /* @__PURE__ */ h.jsxs("svg", { className: "tl-overlays__item", "aria-hidden": "true", children: [
      /* @__PURE__ */ h.jsx(
        "circle",
        {
          cx: o.x,
          cy: o.y,
          className: `tl-arrow-hint-snap tl-arrow-hint-snap__${c ? s ?? "none" : "none"}`
        }
      ),
      Object.entries(r).map(([d, u]) => u.isEnabled ? /* @__PURE__ */ h.jsx(
        "circle",
        {
          cx: u.point.x,
          cy: u.point.y,
          className: "tl-arrow-hint-handle"
        },
        d
      ) : null)
    ] })
  ] });
}
const { PI: NQe } = Math, Dm = NQe + 1e-4;
function _ue(t, e = {}) {
  const { size: n = 16, smoothing: r = 0.5 } = e;
  if (t.length === 0 || n <= 0)
    return { left: [], right: [] };
  const s = t[0], o = t[t.length - 1], i = o.runningLength, a = Math.pow(n * r, 2), c = [], l = [];
  let d = t[0].vector, u = t[0].point, f = u, p = u, g = f, y = !1, m;
  for (let v = 0; v < t.length; v++) {
    m = t[v];
    const { point: b, vector: x } = t[v], w = m.vector.dpr(d), S = (v < t.length - 1 ? t[v + 1] : t[v]).vector, C = v < t.length - 1 ? S.dpr(m.vector) : 1, _ = w < 0 && !y, E = C !== null && C < 0.2;
    if (_ || E) {
      if (C > -0.62 && i - m.runningLength > m.radius) {
        const N = d.clone().mul(m.radius);
        d.clone().cpr(S) < 0 ? (p = I.Add(b, N), g = I.Sub(b, N)) : (p = I.Sub(b, N), g = I.Add(b, N)), c.push(p), l.push(g);
      } else {
        const N = d.clone().mul(m.radius).per(), O = I.Sub(m.input, N);
        for (let D = 1 / 13, k = 0; k < 1; k += D)
          p = I.RotWith(O, m.input, Dm * k), c.push(p), g = I.RotWith(O, m.input, Dm + Dm * -k), l.push(g);
      }
      u = p, f = g, E && (y = !0);
      continue;
    }
    if (y = !1, m === s || m === o) {
      const N = I.Per(x).mul(m.radius);
      c.push(I.Sub(b, N)), l.push(I.Add(b, N));
      continue;
    }
    const M = I.Lrp(S, x, C).per().mul(m.radius);
    p = I.Sub(b, M), (v <= 1 || I.Dist2(u, p) > a) && (c.push(p), u = p), g = I.Add(b, M), (v <= 1 || I.Dist2(f, g) > a) && (l.push(g), f = g), d = x;
  }
  return {
    left: c,
    right: l
  };
}
function Eue(t, e = {}) {
  const { size: n = 16, start: r = {}, end: s = {}, last: o = !1 } = e, { cap: i = !0 } = r, { cap: a = !0 } = s;
  if (t.length === 0 || n <= 0)
    return [];
  const c = t[0], l = t[t.length - 1], d = l.runningLength, u = r.taper === !1 ? 0 : r.taper === !0 ? Math.max(n, d) : r.taper, f = s.taper === !1 ? 0 : s.taper === !0 ? Math.max(n, d) : s.taper, { left: p, right: g } = _ue(t, e), y = c.point, m = t.length > 1 ? t[t.length - 1].point : I.AddXY(c.point, 1, 1);
  if (t.length === 1 && (!(u || f) || o)) {
    const w = I.Add(
      y,
      I.Sub(y, m).uni().per().mul(-c.radius)
    ), S = [];
    for (let C = 1 / 13, _ = C; _ <= 1; _ += C)
      S.push(I.RotWith(w, y, Dm * 2 * _));
    return S;
  }
  const v = [];
  if (!(u || f && t.length === 1)) if (i)
    for (let w = 1 / 8, S = w; S <= 1; S += w) {
      const C = I.RotWith(g[0], y, Dm * S);
      v.push(C);
    }
  else {
    const w = I.Sub(p[0], g[0]), S = I.Mul(w, 0.5), C = I.Mul(w, 0.51);
    v.push(
      I.Sub(y, S),
      I.Sub(y, C),
      I.Add(y, C),
      I.Add(y, S)
    );
  }
  const b = [], x = l.vector.clone().per().neg();
  if (f || u && t.length === 1)
    b.push(m);
  else if (a) {
    const w = I.Add(m, I.Mul(x, l.radius));
    for (let S = 1 / 29, C = S; C < 1; C += S)
      b.push(I.RotWith(w, m, Dm * 3 * C));
  } else
    b.push(
      I.Add(m, I.Mul(x, l.radius)),
      I.Add(m, I.Mul(x, l.radius * 0.99)),
      I.Sub(m, I.Mul(x, l.radius * 0.99)),
      I.Sub(m, I.Mul(x, l.radius))
    );
  return p.concat(b, g.reverse(), v);
}
const jQe = 0.025, RQe = 0.01;
function Lf(t, e = {}) {
  var m;
  const { streamline: n = 0.5, size: r = 16, simulatePressure: s = !1 } = e;
  if (t.length === 0) return [];
  const o = 0.15 + (1 - n) * 0.85;
  let i = t.map(I.From), a = 0;
  if (!s) {
    let v = i[0];
    for (; v && !(v.z >= jQe); )
      i.shift(), v = i[0];
  }
  if (!s) {
    let v = i[i.length - 1];
    for (; v && !(v.z >= RQe); )
      i.pop(), v = i[i.length - 1];
  }
  if (i.length === 0)
    return [
      {
        point: I.From(t[0]),
        input: I.From(t[0]),
        pressure: s ? 0.5 : 0.15,
        vector: new I(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
  let c = i[1];
  for (; c && !(I.Dist2(c, i[0]) > (r / 3) ** 2); )
    i[0].z = Math.max(i[0].z, c.z), i.splice(1, 1), c = i[1];
  const l = i.pop();
  for (c = i[i.length - 1]; c && !(I.Dist2(c, l) > (r / 3) ** 2); )
    i.pop(), c = i[i.length - 1], a++;
  i.push(l);
  const d = e.last || !e.simulatePressure || i.length > 1 && I.Dist2(i[i.length - 1], i[i.length - 2]) < r ** 2 || a > 0;
  if (i.length === 2 && e.simulatePressure) {
    const v = i[1];
    i = i.slice(0, -1);
    for (let b = 1; b < 5; b++) {
      const x = I.Lrp(i[0], v, b / 4);
      x.z = (i[0].z + (v.z - i[0].z)) * b / 4, i.push(x);
    }
  }
  const u = [
    {
      point: i[0],
      input: i[0],
      pressure: s ? 0.5 : i[0].z,
      vector: new I(1, 1),
      distance: 0,
      runningLength: 0,
      radius: 1
    }
  ];
  let f = 0, p = u[0], g, y;
  d && n > 0 && i.push(i[i.length - 1].clone());
  for (let v = 1, b = i.length; v < b; v++)
    g = !o || e.last && v === b - 1 ? i[v].clone() : i[v].clone().lrp(p.point, 1 - o), !p.point.equals(g) && (y = I.Dist(g, p.point), f += y, !(v < 4 && f < r) && (p = {
      input: i[v],
      // The adjusted point
      point: g,
      // The input pressure (or .5 if not specified)
      pressure: s ? 0.5 : i[v].z,
      // The vector from the current point to the previous point
      vector: I.Sub(p.point, g).uni(),
      // The distance between the current point and the previous point
      distance: y,
      // The total distance so far
      runningLength: f,
      // The stroke point's radius
      radius: 1
    }, u.push(p)));
  if ((m = u[1]) != null && m.vector && (u[0].vector = u[1].vector.clone()), f < 1) {
    const v = Math.max(0.5, ...u.map((b) => b.pressure));
    u.forEach((b) => b.pressure = v);
  }
  return u;
}
const { min: Mu } = Math, UO = 0.275;
function z5(t, e) {
  const {
    size: n = 16,
    thinning: r = 0.5,
    simulatePressure: s = !0,
    easing: o = (m) => m,
    start: i = {},
    end: a = {}
  } = e, { easing: c = Mo.easeOutQuad } = i, { easing: l = Mo.easeOutCubic } = a, d = t[t.length - 1].runningLength;
  let u, f = t[0].pressure, p;
  if (!s && d < n) {
    const m = t.reduce((v, b) => Math.max(v, b.pressure), 0.5);
    return t.forEach((v) => {
      v.pressure = m, v.radius = n * o(0.5 - r * (0.5 - v.pressure));
    }), t;
  } else {
    let m;
    for (let v = 0, b = t.length; v < b && (p = t[v], !(p.runningLength > n * 5)); v++) {
      const x = Mu(1, p.distance / n);
      if (s) {
        const w = Mu(1, 1 - x);
        m = Mu(1, f + (w - f) * (x * UO));
      } else
        m = Mu(1, f + (p.pressure - f) * 0.5);
      f = f + (m - f) * 0.5;
    }
    for (let v = 0; v < t.length; v++) {
      if (p = t[v], r) {
        let { pressure: b } = p;
        const x = Mu(1, p.distance / n);
        if (s) {
          const w = Mu(1, 1 - x);
          b = Mu(1, f + (w - f) * (x * UO));
        } else
          b = Mu(
            1,
            f + (b - f) * (x * UO)
          );
        p.radius = n * o(0.5 - r * (0.5 - b)), f = b;
      } else
        p.radius = n / 2;
      u === void 0 && (u = p.radius);
    }
  }
  const g = i.taper === !1 ? 0 : i.taper === !0 ? Math.max(n, d) : i.taper, y = a.taper === !1 ? 0 : a.taper === !0 ? Math.max(n, d) : a.taper;
  if (g || y)
    for (let m = 0; m < t.length; m++) {
      p = t[m];
      const { runningLength: v } = p, b = v < g ? c(v / g) : 1, x = d - v < y ? l((d - v) / y) : 1;
      p.radius = Math.max(0.01, p.radius * Math.min(b, x));
    }
  return t;
}
function $Qe(t, e = {}) {
  return Eue(
    z5(Lf(t, e), e),
    e
  );
}
function kV({ scribble: t, zoom: e, color: n, opacity: r, className: s }) {
  if (!t.points.length) return null;
  const o = $Qe(t.points, {
    size: t.size / e,
    start: { taper: t.taper, easing: Mo.linear },
    last: t.state === "stopping",
    simulatePressure: !1,
    streamline: 0.32
  });
  let i;
  if (o.length < 4) {
    const a = t.size / e / 2, { x: c, y: l } = t.points[t.points.length - 1];
    i = `M ${c - a},${l} a ${a},${a} 0 1,0 ${a * 2},0 a ${a},${a} 0 1,0 ${-a * 2},0`;
  } else
    i = Koe(o);
  return /* @__PURE__ */ h.jsx("svg", { className: s && Je("tl-overlays__item", s), children: /* @__PURE__ */ h.jsx(
    "path",
    {
      className: "tl-scribble",
      d: i,
      fill: n ?? `var(--color-${t.color})`,
      opacity: r ?? t.opacity
    }
  ) });
}
function LQe({
  size: t,
  width: e,
  height: n,
  hideAlternateHandles: r
}) {
  const s = ne(t / 3), o = s / 2, i = Ze();
  return /* @__PURE__ */ h.jsxs("svg", { className: "tl-overlays__item", "aria-hidden": "true", children: [
    /* @__PURE__ */ h.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${ne(0 - o)},${ne(t)} 
						${ne(0 - o)},${ne(0 - o)} 
						${ne(t)},${ne(0 - o)}`,
        strokeWidth: s,
        "data-testid": "selection.crop.top_left",
        role: "button",
        "aria-label": i("handle.crop.top-left")
      }
    ),
    /* @__PURE__ */ h.jsx(
      "line",
      {
        className: Je("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: ne(e / 2 - t),
        y1: ne(0 - o),
        x2: ne(e / 2 + t),
        y2: ne(0 - o),
        strokeWidth: s,
        "data-testid": "selection.crop.top",
        role: "button",
        "aria-label": i("handle.crop.top")
      }
    ),
    /* @__PURE__ */ h.jsx(
      "polyline",
      {
        className: Je("tl-corner-crop-handle", {
          "tl-hidden": r
        }),
        points: `
						${ne(e - t)},${ne(0 - o)} 
						${ne(e + o)},${ne(0 - o)} 
						${ne(e + o)},${ne(t)}`,
        strokeWidth: s,
        "data-testid": "selection.crop.top_right",
        role: "button",
        "aria-label": i("handle.crop.top-right")
      }
    ),
    /* @__PURE__ */ h.jsx(
      "line",
      {
        className: Je("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: ne(e + o),
        y1: ne(n / 2 - t),
        x2: ne(e + o),
        y2: ne(n / 2 + t),
        strokeWidth: s,
        "data-testid": "selection.crop.right",
        role: "button",
        "aria-label": i("handle.crop.right")
      }
    ),
    /* @__PURE__ */ h.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${ne(e + o)},${ne(n - t)} 
						${ne(e + o)},${ne(n + o)}
						${ne(e - t)},${ne(n + o)}`,
        strokeWidth: s,
        "data-testid": "selection.crop.bottom_right",
        role: "button",
        "aria-label": i("handle.crop.bottom-right")
      }
    ),
    /* @__PURE__ */ h.jsx(
      "line",
      {
        className: Je("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: ne(e / 2 - t),
        y1: ne(n + o),
        x2: ne(e / 2 + t),
        y2: ne(n + o),
        strokeWidth: s,
        "data-testid": "selection.crop.bottom",
        role: "button",
        "aria-label": i("handle.crop.bottom")
      }
    ),
    /* @__PURE__ */ h.jsx(
      "polyline",
      {
        className: Je("tl-corner-crop-handle", {
          "tl-hidden": r
        }),
        points: `
						${ne(0 + t)},${ne(n + o)} 
						${ne(0 - o)},${ne(n + o)}
						${ne(0 - o)},${ne(n - t)}`,
        strokeWidth: s,
        "data-testid": "selection.crop.bottom_left",
        role: "button",
        "aria-label": i("handle.crop.bottom-left")
      }
    ),
    /* @__PURE__ */ h.jsx(
      "line",
      {
        className: Je("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: ne(0 - o),
        y1: ne(n / 2 - t),
        x2: ne(0 - o),
        y2: ne(n / 2 + t),
        strokeWidth: s,
        "data-testid": "selection.crop.left",
        role: "button",
        "aria-label": i("handle.crop.left")
      }
    )
  ] });
}
const FQe = Kr(function({
  bounds: e,
  rotation: n
}) {
  const r = ie(), s = Ze(), o = fe(null), i = Da(), a = wl("top"), c = wl("right"), l = wl("bottom"), d = wl("left"), u = wl("top_left"), f = wl("top_right"), p = wl("bottom_right"), g = wl("bottom_left"), y = r.getInstanceState().cursor.type === "default", m = r.getInstanceState().isCoarsePointer, v = r.getOnlySelectedShape(), b = v && r.isShapeOrAncestorLocked(v), x = v ? r.getShapeUtil(v).expandSelectionOutlinePx(v) : 0, w = x instanceof _e ? e.clone().expand(x).zeroFix() : e.clone().expandBy(x).zeroFix();
  if (Y0(o, e == null ? void 0 : e.x, e == null ? void 0 : e.y, 1, r.getSelectionRotation(), {
    x: w.x - e.x,
    y: w.y - e.y
  }), v && r.isShapeHidden(v)) return null;
  const S = r.getZoomLevel(), C = r.getInstanceState().isChangingStyle, _ = w.width, E = w.height, M = 8 / S, N = _ < M * 2, O = E < M * 2, D = _ < M * 4, k = E < M * 4, A = _ < M * 5, R = E < M * 5, j = m ? 1.75 : 1, $ = 6 / S * j, F = (D ? $ / 2 : $) * (j * 0.75), L = (k ? $ / 2 : $) * (j * 0.75), z = (v ? !r.getShapeUtil(v).hideSelectionBoundsFg(v) : !0) && !C;
  let H = z && r.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_canvas",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle",
    "select.pointing_resize_handle"
  ) || z && r.isIn("select.resizing") && v && r.isShapeOfType(v, "text");
  v && H && dn.isFirefox && r.isShapeOfType(v, "embed") && (H = !1);
  const U = r.isInAny(
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle"
  ) && !C && !i, W = r.isInAny(
    "select.idle",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle"
  ) && !C && !i, Z = !m && !(N || O) && (W || U) && (v ? !r.getShapeUtil(v).hideRotateHandle(v) : !0) && !b, K = m && (!D || !k) && (W || U) && (v ? !r.getShapeUtil(v).hideRotateHandle(v) : !0) && !b, oe = W && (v ? r.getShapeUtil(v).canResize(v) && !r.getShapeUtil(v).hideResizeHandles(v) : !0) && !U && !b, Y = N || O, ee = N && O, ae = A || R, de = oe || U, ye = !Z, G = !W || !K, xe = !W || !de, ge = !W || !de || Y, ze = !W || !de || Y, Ge = !W || !de || ee && !U;
  let Ct = !0, vn = !0;
  if (U)
    Ct = ae, vn = ae;
  else if (oe) {
    Ct = Y || ee || m;
    const ce = m && v && v.type === "text";
    vn = Ct && !ce;
  }
  const Yt = Math.min(24 / S, E - L * 3), X = W && m && v && r.isShapeOfType(v, "text") && Yt * S >= 4;
  return /* @__PURE__ */ h.jsx(
    "svg",
    {
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      "aria-hidden": "true",
      children: /* @__PURE__ */ h.jsxs("g", { ref: o, children: [
        H && /* @__PURE__ */ h.jsx(
          "rect",
          {
            className: "tl-selection__fg__outline",
            width: ne(_),
            height: ne(E)
          }
        ),
        /* @__PURE__ */ h.jsx(
          Z1,
          {
            "data-testid": "selection.rotate.top-left",
            cx: 0,
            cy: 0,
            targetSize: $,
            corner: "top_left_rotate",
            cursor: y ? ra("nwse-rotate", n) : void 0,
            isHidden: ye
          }
        ),
        /* @__PURE__ */ h.jsx(
          Z1,
          {
            "data-testid": "selection.rotate.top-right",
            cx: _ + $ * 3,
            cy: 0,
            targetSize: $,
            corner: "top_right_rotate",
            cursor: y ? ra("nesw-rotate", n) : void 0,
            isHidden: ye
          }
        ),
        /* @__PURE__ */ h.jsx(
          Z1,
          {
            "data-testid": "selection.rotate.bottom-left",
            cx: 0,
            cy: E + $ * 3,
            targetSize: $,
            corner: "bottom_left_rotate",
            cursor: y ? ra("swne-rotate", n) : void 0,
            isHidden: ye
          }
        ),
        /* @__PURE__ */ h.jsx(
          Z1,
          {
            "data-testid": "selection.rotate.bottom-right",
            cx: _ + $ * 3,
            cy: E + $ * 3,
            targetSize: $,
            corner: "bottom_right_rotate",
            cursor: y ? ra("senw-rotate", n) : void 0,
            isHidden: ye
          }
        ),
        /* @__PURE__ */ h.jsx(
          zQe,
          {
            "data-testid": "selection.rotate.mobile",
            cx: D ? -$ * 1.5 : _ / 2,
            cy: D ? E / 2 : -$ * 1.5,
            size: M,
            isHidden: G
          }
        ),
        /* @__PURE__ */ h.jsx(
          Ou,
          {
            hide: Ct,
            dataTestId: "selection.resize.top",
            ariaLabel: s("handle.resize-top"),
            x: 0,
            y: ne(0 - (k ? L * 2 : L)),
            width: ne(_),
            height: ne(Math.max(1, L * 2)),
            cursor: y ? ra("ns-resize", n) : void 0,
            events: a
          }
        ),
        /* @__PURE__ */ h.jsx(
          Ou,
          {
            hide: vn,
            dataTestId: "selection.resize.right",
            ariaLabel: s("handle.resize-right"),
            x: ne(_ - (D ? 0 : F)),
            y: 0,
            height: ne(E),
            width: ne(Math.max(1, F * 2)),
            cursor: y ? ra("ew-resize", n) : void 0,
            events: c
          }
        ),
        /* @__PURE__ */ h.jsx(
          Ou,
          {
            hide: Ct,
            dataTestId: "selection.resize.bottom",
            ariaLabel: s("handle.resize-bottom"),
            x: 0,
            y: ne(E - (k ? 0 : L)),
            width: ne(_),
            height: ne(Math.max(1, L * 2)),
            cursor: y ? ra("ns-resize", n) : void 0,
            events: l
          }
        ),
        /* @__PURE__ */ h.jsx(
          Ou,
          {
            hide: vn,
            dataTestId: "selection.resize.left",
            ariaLabel: s("handle.resize-left"),
            x: ne(0 - (D ? F * 2 : F)),
            y: 0,
            height: ne(E),
            width: ne(Math.max(1, F * 2)),
            cursor: y ? ra("ew-resize", n) : void 0,
            events: d
          }
        ),
        /* @__PURE__ */ h.jsx(
          Ou,
          {
            hide: xe,
            dataTestId: "selection.target.top-left",
            ariaLabel: s("handle.resize-top-left"),
            x: ne(0 - (D ? F * 2 : F * 1.5)),
            y: ne(0 - (k ? L * 2 : L * 1.5)),
            width: ne(F * 3),
            height: ne(L * 3),
            cursor: y ? ra("nwse-resize", n) : void 0,
            events: u
          }
        ),
        /* @__PURE__ */ h.jsx(
          Ou,
          {
            hide: ge,
            dataTestId: "selection.target.top-right",
            ariaLabel: s("handle.resize-top-right"),
            x: ne(_ - (D ? 0 : F * 1.5)),
            y: ne(0 - (k ? L * 2 : L * 1.5)),
            width: ne(F * 3),
            height: ne(L * 3),
            cursor: y ? ra("nesw-resize", n) : void 0,
            events: f
          }
        ),
        /* @__PURE__ */ h.jsx(
          Ou,
          {
            hide: Ge,
            dataTestId: "selection.target.bottom-right",
            ariaLabel: s("handle.resize-bottom-right"),
            x: ne(_ - (D ? F : F * 1.5)),
            y: ne(E - (k ? L : L * 1.5)),
            width: ne(F * 3),
            height: ne(L * 3),
            cursor: y ? ra("nwse-resize", n) : void 0,
            events: p
          }
        ),
        /* @__PURE__ */ h.jsx(
          Ou,
          {
            hide: ze,
            dataTestId: "selection.target.bottom-left",
            ariaLabel: s("handle.resize-bottom-left"),
            x: ne(0 - (D ? F * 3 : F * 1.5)),
            y: ne(E - (k ? 0 : L * 1.5)),
            width: ne(F * 3),
            height: ne(L * 3),
            cursor: y ? ra("nesw-resize", n) : void 0,
            events: g
          }
        ),
        oe && /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
          /* @__PURE__ */ h.jsx(
            "rect",
            {
              "data-testid": "selection.resize.top-left",
              className: Je("tl-corner-handle", {
                "tl-hidden": xe
              }),
              x: ne(0 - M / 2),
              y: ne(0 - M / 2),
              width: ne(M),
              height: ne(M)
            }
          ),
          /* @__PURE__ */ h.jsx(
            "rect",
            {
              "data-testid": "selection.resize.top-right",
              className: Je("tl-corner-handle", {
                "tl-hidden": ge
              }),
              x: ne(_ - M / 2),
              y: ne(0 - M / 2),
              width: ne(M),
              height: ne(M)
            }
          ),
          /* @__PURE__ */ h.jsx(
            "rect",
            {
              "data-testid": "selection.resize.bottom-right",
              className: Je("tl-corner-handle", {
                "tl-hidden": Ge
              }),
              x: ne(_ - M / 2),
              y: ne(E - M / 2),
              width: ne(M),
              height: ne(M)
            }
          ),
          /* @__PURE__ */ h.jsx(
            "rect",
            {
              "data-testid": "selection.resize.bottom-left",
              className: Je("tl-corner-handle", {
                "tl-hidden": ze
              }),
              x: ne(0 - M / 2),
              y: ne(E - M / 2),
              width: ne(M),
              height: ne(M)
            }
          )
        ] }),
        X && /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
          /* @__PURE__ */ h.jsx(
            "rect",
            {
              "data-testid": "selection.text-resize.left.handle",
              className: "tl-text-handle",
              x: ne(0 - M / 4),
              y: ne(E / 2 - Yt / 2),
              rx: M / 4,
              width: ne(M / 2),
              height: ne(Yt)
            }
          ),
          /* @__PURE__ */ h.jsx(
            "rect",
            {
              "data-testid": "selection.text-resize.right.handle",
              className: "tl-text-handle",
              rx: M / 4,
              x: ne(_ - M / 4),
              y: ne(E / 2 - Yt / 2),
              width: ne(M / 2),
              height: ne(Yt)
            }
          )
        ] }),
        U && /* @__PURE__ */ h.jsx(
          LQe,
          {
            size: M,
            width: _,
            height: E,
            hideAlternateHandles: ae
          }
        )
      ] })
    }
  );
}), Ou = function({
  hide: e,
  dataTestId: n,
  ariaLabel: r,
  x: s,
  y: o,
  width: i,
  height: a,
  cursor: c,
  events: l
}) {
  return /* @__PURE__ */ h.jsx(
    "rect",
    {
      className: Je("tl-resize-handle", "tl-transparent", {
        "tl-hidden": e
      }),
      "data-testid": n,
      role: "button",
      "aria-label": r,
      pointerEvents: "all",
      x: s,
      y: o,
      width: i,
      height: a,
      cursor: c,
      ...l
    }
  );
}, Z1 = function({
  cx: e,
  cy: n,
  targetSize: r,
  corner: s,
  cursor: o,
  isHidden: i,
  "data-testid": a
}) {
  const c = wl(s), d = Ze()(`handle.rotate.${s}`);
  return /* @__PURE__ */ h.jsx(
    "rect",
    {
      className: Je("tl-transparent", "tl-rotate-corner", { "tl-hidden": i }),
      "data-testid": a,
      role: "button",
      "aria-label": d,
      pointerEvents: "all",
      x: ne(e - r * 3),
      y: ne(n - r * 3),
      width: ne(Math.max(1, r * 3)),
      height: ne(Math.max(1, r * 3)),
      cursor: o,
      ...c
    }
  );
}, BQe = Math.sqrt(Math.PI), zQe = function({
  cx: e,
  cy: n,
  size: r,
  isHidden: s,
  "data-testid": o
}) {
  const i = wl("mobile_rotate"), a = ie(), c = le("zoom level", () => a.getZoomLevel(), [a]), l = Math.max(14 * (1 / c), 20 / Math.max(1, c)), d = Ze();
  return /* @__PURE__ */ h.jsxs("g", { role: "button", "aria-label": d("handle.rotate.mobile_rotate"), children: [
    /* @__PURE__ */ h.jsx(
      "circle",
      {
        "data-testid": o,
        pointerEvents: "all",
        className: Je("tl-transparent", "tl-mobile-rotate__bg", { "tl-hidden": s }),
        cx: e,
        cy: n,
        r: l,
        ...i
      }
    ),
    /* @__PURE__ */ h.jsx(
      "circle",
      {
        className: Je("tl-mobile-rotate__fg", { "tl-hidden": s }),
        cx: e,
        cy: n,
        r: r / BQe
      }
    )
  ] });
};
function UQe() {
  const t = ie(), e = le(
    "is in a valid select state",
    () => t.isInAny(
      "select.idle",
      "select.brushing",
      "select.scribble_brushing",
      "select.editing_shape",
      "select.pointing_shape",
      "select.pointing_selection",
      "select.pointing_handle"
    ),
    [t]
  );
  return /* @__PURE__ */ h.jsx(Goe, { hideAll: !e });
}
const Tue = [l_], AV = 8;
function Vc() {
  return {
    topLeft: { x: 0, y: 0 },
    bottomRight: { x: 1, y: 1 }
  };
}
const HQe = [
  "original",
  "square",
  "circle",
  "landscape",
  "portrait",
  "wide"
], lR = {
  original: 0,
  square: 1,
  circle: 1,
  landscape: 4 / 3,
  portrait: 3 / 4,
  wide: 16 / 9
};
function il(t, e) {
  if (!e) return { w: t.w, h: t.h };
  const n = t.w / (e.bottomRight.x - e.topLeft.x), r = t.h / (e.bottomRight.y - e.topLeft.y);
  return { w: n, h: r };
}
function Lk(t) {
  return {
    width: t.bottomRight.x - t.topLeft.x,
    height: t.bottomRight.y - t.topLeft.y
  };
}
function U5(t) {
  const { width: e, height: n } = Lk(t);
  return {
    x: t.topLeft.x + e / 2,
    y: t.topLeft.y + n / 2
  };
}
function H5(t, e, n, r, s) {
  const o = Math.max(0, Math.min(1 - n, t - n / 2)), i = Math.max(0, Math.min(1 - r, e - r / 2));
  return {
    topLeft: { x: o, y: i },
    bottomRight: { x: o + n, y: i + r },
    isCircle: s
  };
}
function VQe(t, e, n = {}) {
  const { handle: r, change: s, crop: o, aspectRatioLocked: i } = e, { w: a, h: c } = e.uncroppedSize, { minWidth: l = AV, minHeight: d = AV } = n;
  if (a < l || c < d || s.x === 0 && s.y === 0)
    return;
  const u = new _e(
    o.topLeft.x * a,
    o.topLeft.y * c,
    (o.bottomRight.x - o.topLeft.x) * a,
    (o.bottomRight.y - o.topLeft.y) * c
  ), f = u.aspectRatio, p = u.clone();
  if (r === "top_left" || r === "bottom_left" || r === "left")
    p.x = wt(p.x + s.x, 0, u.maxX - l), p.w = u.maxX - p.x;
  else if (r === "top_right" || r === "bottom_right" || r === "right") {
    const m = wt(p.maxX + s.x, u.x + l, a);
    p.w = m - p.x;
  }
  if (r === "top_left" || r === "top_right" || r === "top")
    p.y = wt(p.y + s.y, 0, u.maxY - d), p.h = u.maxY - p.y;
  else if (r === "bottom_left" || r === "bottom_right" || r === "bottom") {
    const m = wt(p.maxY + s.y, u.y + d, c);
    p.h = m - p.y;
  }
  if (i)
    switch (p.aspectRatio > f ? p.h = p.w / f : p.w = p.h * f, r) {
      case "top_left": {
        p.x = u.maxX - p.w, p.y = u.maxY - p.h, p.x <= 0 && (p.x = 0, p.w = u.maxX - p.x, p.h = p.w / f, p.y = u.maxY - p.h), p.y <= 0 && (p.y = 0, p.h = u.maxY - p.y, p.w = p.h * f, p.x = u.maxX - p.w);
        break;
      }
      case "top_right": {
        p.x = u.x, p.y = u.maxY - p.h, p.maxX >= a && (p.w = a - u.x, p.h = p.w / f, p.y = u.maxY - p.h), p.y <= 0 && (p.y = 0, p.h = u.maxY - p.y, p.w = p.h * f);
        break;
      }
      case "bottom_left": {
        p.x = u.maxX - p.w, p.y = u.y, p.x <= 0 && (p.x = 0, p.w = u.maxX - p.x, p.h = p.w / f), p.maxY >= c && (p.h = c - u.y, p.w = p.h * f, p.x = u.maxX - p.w);
        break;
      }
      case "bottom_right": {
        p.x = u.x, p.y = u.y, p.maxX >= a && (p.w = a - u.x, p.h = p.w / f), p.maxY >= c && (p.h = c - u.y, p.w = p.h * f);
        break;
      }
      case "top": {
        if (p.h = u.maxY - p.y, p.w = p.h * f, p.x -= (p.w - u.w) / 2, p.x <= 0) {
          const v = u.midX;
          p.w = v * 2, p.h = p.w / f, p.x = 0;
        }
        if (p.maxX >= a) {
          const v = a - u.midX;
          p.w = v * 2, p.h = p.w / f, p.x = a - p.w;
        }
        p.y = u.maxY - p.h;
        break;
      }
      case "right": {
        if (p.w = p.maxX - u.x, p.h = p.w / f, p.y -= (p.h - u.h) / 2, p.y <= 0) {
          const v = u.midY;
          p.h = v * 2, p.w = p.h * f, p.y = 0;
        }
        if (p.maxY >= c) {
          const v = c - u.midY;
          p.h = v * 2, p.w = p.h * f, p.y = c - p.h;
        }
        break;
      }
      case "bottom": {
        if (p.h = p.maxY - u.y, p.w = p.h * f, p.x -= (p.w - u.w) / 2, p.x <= 0) {
          const v = u.midX;
          p.w = v * 2, p.h = p.w / f, p.x = 0;
        }
        if (p.maxX >= a) {
          const v = a - u.midX;
          p.w = v * 2, p.h = p.w / f, p.x = a - p.w;
        }
        break;
      }
      case "left": {
        if (p.w = u.maxX - p.x, p.h = p.w / f, p.y -= (p.h - u.h) / 2, p.y <= 0) {
          const v = u.midY;
          p.h = v * 2, p.w = p.h * f, p.y = 0;
        }
        if (p.maxY >= c) {
          const v = c - u.midY;
          p.h = v * 2, p.w = p.h * f, p.y = c - p.h;
        }
        p.x = u.maxX - p.w;
        break;
      }
    }
  const g = {
    topLeft: { x: p.x / a, y: p.y / c },
    bottomRight: { x: p.maxX / a, y: p.maxY / c },
    isCircle: o.isCircle
  };
  if (g.topLeft.x === o.topLeft.x && g.topLeft.y === o.topLeft.y && g.bottomRight.x === o.bottomRight.x && g.bottomRight.y === o.bottomRight.y)
    return;
  const y = new I(p.x - o.topLeft.x * a, p.y - o.topLeft.y * c).rot(t.rotation).add(t);
  return {
    id: t.id,
    type: t.type,
    x: y.x,
    y: y.y,
    props: {
      w: p.w,
      h: p.h,
      crop: g
    }
  };
}
function WQe(t, e, n, r = !0, s = !1) {
  const { w: o, h: i } = il(t.props, t.props.crop ?? Vc()), a = t.props.crop || Vc(), c = t.x + t.props.w / 2, l = t.y + t.props.h / 2;
  let d, u;
  if (r) {
    const { x: y, y: m } = U5(a);
    d = y, u = m;
  } else
    d = 0.5, u = 0.5;
  const f = H5(
    d,
    u,
    e,
    n,
    s
  ), p = e * o, g = n * i;
  return {
    crop: f,
    w: p,
    h: g,
    x: c - p / 2,
    y: l - g / 2
  };
}
const Pi = 3;
function KQe(t, e, n) {
  const r = e.props.crop || Vc(), { width: s, height: o } = Lk(r), i = s / o, a = n ? 1 / (1 - n) : Pi, c = 1 + t * (a - 1);
  let l, d;
  i > 1 ? (l = Math.min(1, 1 / c), d = l / i) : (d = Math.min(1, 1 / c), l = d * i);
  const u = WQe(e, l, d, !0, r.isCircle), f = Math.min(Pi, s / l);
  u.w *= f, u.h *= f;
  const p = e.x + e.props.w / 2, g = e.y + e.props.h / 2;
  return u.x = p - u.w / 2, u.y = g - u.h / 2, u;
}
function GQe(t, e, n) {
  const r = Vc(), s = t.props.crop || r, o = t.props.w, i = t.props.h, a = e / n;
  let c = r, l = o, d = i;
  if (Zf(t.props.crop, r))
    l = o, d = o * n / e;
  else {
    const { w: m, h: v } = il(
      t.props,
      t.props.crop || Vc()
      // Use the ACTUAL current crop to correctly infer uncropped size
    ), { width: b, height: x } = Lk(s), w = b / x, S = m / v;
    let C, _;
    const E = U5(s);
    C = b;
    const M = a / S / w;
    _ = C * M;
    const N = Pi / (Pi - 1);
    if (M > N) {
      const O = 1 / Pi;
      if (1 / _ < 1 / C) {
        const D = _ / O;
        _ = _ / D, C = C / D;
      } else {
        const D = C / O;
        C = C / D, _ = _ / D;
      }
    }
    C = Math.max(0, Math.min(1, C)), _ = Math.max(0, Math.min(1, _)), c = H5(
      E.x,
      E.y,
      C,
      _,
      s.isCircle
    );
  }
  const f = t.x + o / 2, p = t.y + i / 2, g = f - l / 2, y = p - d / 2;
  return {
    crop: c,
    w: l,
    h: d,
    x: g,
    y
  };
}
function YQe(t, e) {
  if (t === "original") {
    const { w: O, h: D } = il(e.props, e.props.crop ?? Vc()), k = e.x + e.props.w / 2, A = e.y + e.props.h / 2;
    return {
      crop: Vc(),
      w: O,
      h: D,
      x: k - O / 2,
      y: A - D / 2
    };
  }
  const n = lR[t], r = t === "circle", { w: s, h: o } = il(
    e.props,
    e.props.crop || Vc()
    // Use the ACTUAL current crop to correctly infer uncropped size
  ), i = s / o, a = e.props.crop || Vc(), { width: c, height: l } = Lk(a), d = U5(a), u = Math.min(1 / c, 1 / l);
  let f, p;
  if (i === 0 || !Number.isFinite(i) || n === 0)
    f = 1, p = 1;
  else {
    const O = c * s, D = l * o, k = Math.max(O, D), A = O >= D;
    let R, j;
    A ? (R = k, j = R / n) : (j = k, R = j * n), f = R / s, p = j / o, f > 1 && (f = 1, p = i / n), p > 1 && (p = 1, f = n / i), f = Math.max(0, Math.min(1, f)), p = Math.max(0, Math.min(1, p));
  }
  const g = Math.min(1 / f, 1 / p);
  f *= g / u, p *= g / u, f = Math.max(0, Math.min(1, f)), p = Math.max(0, Math.min(1, p));
  const y = H5(
    d.x,
    d.y,
    f,
    p,
    r
  ), m = y.bottomRight.x - y.topLeft.x, v = y.bottomRight.y - y.topLeft.y, b = m * s, x = v * o;
  let w = 1;
  c > 0 ? w = e.props.w / (c * s) : l > 0 && (w = e.props.h / (l * o));
  const S = b * w, C = x * w, _ = e.x + e.props.w / 2, E = e.y + e.props.h / 2, M = _ - S / 2, N = E - C / 2;
  return {
    crop: y,
    w: S,
    h: C,
    x: M,
    y: N
  };
}
const Oo = {
  lineHeight: 1.35,
  fontWeight: "normal",
  fontVariant: "normal",
  fontStyle: "normal",
  padding: "0px"
}, ys = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
}, my = {
  s: 18,
  m: 24,
  l: 36,
  xl: 44
}, Ef = {
  s: 18,
  m: 22,
  l: 26,
  xl: 32
}, qQe = {
  s: 18,
  m: 20,
  l: 24,
  xl: 28
}, Ff = {
  draw: "var(--tl-font-draw)",
  sans: "var(--tl-font-sans)",
  serif: "var(--tl-font-serif)",
  mono: "var(--tl-font-mono)"
}, XQe = 20, dR = 4.25, ri = 16;
function ZQe(t, e) {
  const n = t.w / e.w, r = t.h / e.h;
  return n <= 1 && r <= 1 ? t : n > r ? {
    w: t.w / n,
    h: t.h / n
  } : {
    w: t.w / r,
    h: t.h / r
  };
}
async function QQe(t, e, n) {
  var v, b, x;
  const { elements: r, files: s } = e, o = {
    shapes: [],
    bindings: [],
    rootShapeIds: [],
    assets: [],
    schema: t.store.schema.serialize()
  }, i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), c = t.getCurrentPageId(), l = /* @__PURE__ */ new Map(), d = [], u = /* @__PURE__ */ new Set();
  r.forEach((w) => {
    if (l.set(w.id, $n()), w.boundElements !== null)
      for (const S of w.boundElements)
        S.type === "text" && u.add(S.id);
  });
  let f = GJ;
  for (const w of r) {
    if (u.has(w.id))
      continue;
    const S = l.get(w.id), C = {
      id: S,
      typeName: "shape",
      parentId: c,
      index: f,
      x: w.x,
      y: w.y,
      rotation: 0,
      isLocked: w.locked,
      opacity: JQe(w.opacity),
      meta: {}
    };
    switch (w.angle !== 0 && a.set(S, w.angle), w.groupIds && w.groupIds.length > 0 ? i.has(w.groupIds[0]) ? (v = i.get(w.groupIds[0])) == null || v.push(S) : i.set(w.groupIds[0], [S]) : d.push(S), w.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let _ = "", E = "middle";
        if (w.boundElements !== null) {
          for (const N of w.boundElements)
            if (N.type === "text") {
              const O = r.find((D) => D.id === N.id);
              O && (_ = O.text, E = iJe[O.textAlign]);
            }
        }
        const M = w.backgroundColor === "transparent" ? w.strokeColor : w.backgroundColor;
        o.shapes.push({
          ...C,
          type: "geo",
          props: {
            geo: w.type,
            url: w.link ?? "",
            w: w.width,
            h: w.height,
            size: Q1[w.strokeWidth] ?? "draw",
            color: ab[M] ?? "black",
            richText: dc(_),
            align: E,
            dash: J1(w),
            fill: lJe(w)
          }
        });
        break;
      }
      case "freedraw": {
        o.shapes.push({
          ...C,
          type: "draw",
          props: {
            dash: J1(w),
            size: Q1[w.strokeWidth],
            color: ab[w.strokeColor] ?? "black",
            segments: [
              {
                type: "free",
                points: w.points.map(([_, E, M = 0.5]) => ({
                  x: _,
                  y: E,
                  z: M
                }))
              }
            ]
          }
        });
        break;
      }
      case "line": {
        if (w.points.slice().length < 2)
          break;
        const E = ow(w.points.length);
        o.shapes.push({
          ...C,
          type: "line",
          props: {
            dash: J1(w),
            size: Q1[w.strokeWidth],
            color: ab[w.strokeColor] ?? "black",
            spline: w.roundness ? "cubic" : "line",
            points: {
              ...Object.fromEntries(
                w.points.map(([M, N], O) => {
                  const D = E[O];
                  return [D, { id: D, index: D, x: M, y: N }];
                })
              )
            }
          }
        });
        break;
      }
      case "arrow": {
        let _ = "";
        if (w.boundElements !== null) {
          for (const D of w.boundElements)
            if (D.type === "text") {
              const k = r.find((A) => A.id === D.id);
              k && (_ = k.text);
            }
        }
        const E = w.points[0], M = w.points[w.points.length - 1], N = l.get((b = w.startBinding) == null ? void 0 : b.elementId), O = l.get((x = w.endBinding) == null ? void 0 : x.elementId);
        o.shapes.push({
          ...C,
          type: "arrow",
          props: {
            text: _,
            kind: w.elbowed ? "elbow" : "arc",
            bend: cJe(w, E, M),
            dash: J1(w),
            size: Q1[w.strokeWidth] ?? "m",
            color: ab[w.strokeColor] ?? "black",
            start: { x: E[0], y: E[1] },
            end: { x: M[0], y: M[1] },
            arrowheadEnd: MV[w.endArrowhead] ?? "none",
            arrowheadStart: MV[w.startArrowhead] ?? "none"
          }
        }), N && o.bindings.push({
          id: ip(),
          typeName: "binding",
          type: "arrow",
          fromId: S,
          toId: N,
          props: {
            terminal: "start",
            normalizedAnchor: { x: 0.5, y: 0.5 },
            isPrecise: !1,
            isExact: !1
          },
          meta: {}
        }), O && o.bindings.push({
          id: ip(),
          typeName: "binding",
          type: "arrow",
          fromId: S,
          toId: O,
          props: {
            terminal: "end",
            normalizedAnchor: { x: 0.5, y: 0.5 },
            isPrecise: !1,
            isExact: !1
          },
          meta: {}
        });
        break;
      }
      case "text": {
        const { size: _, scale: E } = tJe(w.fontSize);
        o.shapes.push({
          ...C,
          type: "text",
          props: {
            size: _,
            scale: E,
            font: nJe[w.fontFamily] ?? "draw",
            color: ab[w.strokeColor] ?? "black",
            richText: dc(w.text),
            textAlign: aJe[w.textAlign]
          }
        });
        break;
      }
      case "image": {
        const _ = s[w.fileId];
        if (!_) break;
        const E = th.createId();
        o.assets.push({
          id: E,
          typeName: "asset",
          type: "image",
          props: {
            w: w.width,
            h: w.height,
            fileSize: _.size,
            name: w.id ?? "Untitled",
            isAnimated: !1,
            mimeType: _.mimeType,
            src: _.dataURL
          },
          meta: {}
        }), o.shapes.push({
          ...C,
          type: "image",
          props: {
            w: w.width,
            h: w.height,
            assetId: E
          }
        });
      }
    }
    f = Bc(f);
  }
  const p = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : void 0);
  t.putContentOntoCurrentPage(o, {
    point: p,
    select: !1,
    preserveIds: !0
  });
  for (const w of i.values())
    if (w.length > 1) {
      t.groupShapes(w);
      const S = t.getShape(w[0]);
      S != null && S.parentId && ei(S.parentId) && d.push(S.parentId);
    }
  for (const [w, S] of a)
    t.select(w), t.rotateShapesBy([w], S);
  const g = mt(d.map((w) => t.getShape(w))), y = _e.Common(g.map((w) => t.getShapePageBounds(w))), m = t.getViewportPageBounds().center;
  t.updateShapes(
    g.map((w) => {
      const S = {
        x: (w.x ?? 0) - (y.x + y.w / 2),
        y: (w.y ?? 0) - (y.y + y.h / 2)
      };
      return {
        id: w.id,
        type: w.type,
        x: m.x + S.x,
        y: m.y + S.y
      };
    })
  ), t.setSelectedShapes(d);
}
const JQe = (t) => {
  const e = t / 100;
  return e < 0.2 ? 0.1 : e < 0.4 ? 0.25 : e < 0.6 ? 0.5 : e < 0.8 ? 0.75 : 1;
}, Q1 = {
  1: "s",
  2: "m",
  3: "l",
  4: "xl"
}, eJe = {
  16: "s",
  20: "m",
  28: "l",
  36: "xl"
};
function tJe(t) {
  const e = eJe[t];
  return e ? { size: e, scale: 1 } : t < 16 ? { size: "s", scale: t / 16 } : t > 36 ? { size: "xl", scale: t / 36 } : { size: "m", scale: 1 };
}
const nJe = {
  1: "draw",
  2: "sans",
  3: "mono"
}, rJe = {
  gray: ["#f8f9fa", "#e9ecef", "#ced4da", "#868e96", "#343a40"],
  red: ["#fff5f5", "#ffc9c9", "#ff8787", "#fa5252", "#e03131"],
  pink: ["#fff0f6", "#fcc2d7", "#f783ac", "#e64980", "#c2255c"],
  grape: ["#f8f0fc", "#eebefa", "#da77f2", "#be4bdb", "#9c36b5"],
  violet: ["#f3f0ff", "#d0bfff", "#9775fa", "#7950f2", "#6741d9"],
  indigo: ["#edf2ff", "#bac8ff", "#748ffc", "#4c6ef5", "#3b5bdb"],
  blue: ["#e7f5ff", "#a5d8ff", "#4dabf7", "#228be6", "#1971c2"],
  cyan: ["#e3fafc", "#99e9f2", "#3bc9db", "#15aabf", "#0c8599"],
  teal: ["#e6fcf5", "#96f2d7", "#38d9a9", "#12b886", "#099268"],
  green: ["#ebfbee", "#b2f2bb", "#69db7c", "#40c057", "#2f9e44"],
  lime: ["#f4fce3", "#d8f5a2", "#a9e34b", "#82c91e", "#66a80f"],
  yellow: ["#fff9db", "#ffec99", "#ffd43b", "#fab005", "#f08c00"],
  orange: ["#fff4e6", "#ffd8a8", "#ffa94d", "#fd7e14", "#e8590c"]
};
function bl(t, e, n) {
  const r = [0, 1, 2, 3, 4].map((s) => rJe[t][s]);
  return Object.fromEntries(r.map((s, o) => [s, o < 3 ? e : n]));
}
const ab = {
  ...bl("gray", "grey", "black"),
  ...bl("red", "light-red", "red"),
  ...bl("pink", "light-red", "red"),
  ...bl("grape", "light-violet", "violet"),
  ...bl("blue", "light-blue", "blue"),
  ...bl("cyan", "light-blue", "blue"),
  ...bl("teal", "light-green", "green"),
  ...bl("green", "light-green", "green"),
  ...bl("yellow", "yellow", "orange"),
  ...bl("orange", "yellow", "orange"),
  "#ffffff": "white",
  "#000000": "black"
}, sJe = {
  solid: "draw",
  dashed: "dashed",
  dotted: "dotted"
}, oJe = {
  "cross-hatch": "pattern",
  hachure: "pattern",
  solid: "solid"
}, iJe = {
  left: "start",
  center: "middle",
  right: "end"
}, aJe = {
  left: "start",
  center: "middle",
  right: "end"
}, MV = {
  arrow: "arrow",
  dot: "dot",
  triangle: "triangle",
  bar: "pipe"
};
function cJe(t, e, n) {
  let r = 0;
  if (t.points.length > 2) {
    const s = new I(e[0], e[1]), o = new I(n[0], n[1]), i = new I(t.points[1][0], t.points[1][1]), a = I.Sub(o, s), c = I.Per(a), l = I.Med(o, s), d = I.Sub(l, c), u = I.Add(l, c), f = I.NearestPointOnLineSegment(d, u, i, !1);
    r = I.Dist(f, l), I.Clockwise(f, o, l) && (r *= -1);
  }
  return r;
}
const J1 = (t) => {
  let e = sJe[t.strokeStyle] ?? "draw";
  return e === "draw" && t.roughness === 0 && (e = "solid"), e;
}, lJe = (t) => t.backgroundColor === "transparent" ? "none" : oJe[t.fillStyle] ?? "solid", dJe = /(^|[^`])`([^`]+)`(?!`)/, uJe = /(^|[^`])`([^`]+)`(?!`)/g, Pue = Jl.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", $s(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      jp({
        find: dJe,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      $f({
        find: uJe,
        type: this.type
      })
    ];
  }
}), fJe = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, hJe = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, Iue = Jl.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", $s(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      jp({
        find: fJe,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      $f({
        find: hJe,
        type: this.type
      })
    ];
  }
}), pJe = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", gJe = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", uR = "numeric", fR = "ascii", hR = "alpha", Tx = "asciinumeric", Gb = "alphanumeric", pR = "domain", kue = "emoji", mJe = "scheme", yJe = "slashscheme", HO = "whitespace";
function vJe(t, e) {
  return t in e || (e[t] = []), e[t];
}
function Hh(t, e, n) {
  e[uR] && (e[Tx] = !0, e[Gb] = !0), e[fR] && (e[Tx] = !0, e[hR] = !0), e[Tx] && (e[Gb] = !0), e[hR] && (e[Gb] = !0), e[Gb] && (e[pR] = !0), e[kue] && (e[pR] = !0);
  for (const r in e) {
    const s = vJe(r, n);
    s.indexOf(t) < 0 && s.push(t);
  }
}
function bJe(t, e) {
  const n = {};
  for (const r in e)
    e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function Ni(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
Ni.groups = {};
Ni.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let r = 0; r < e.jr.length; r++) {
      const s = e.jr[r][0], o = e.jr[r][1];
      if (o && s.test(t))
        return o;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let s = 0; s < t.length; s++)
      this.tt(t[s], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || Ni.groups;
    let s;
    return e && e.j ? s = e : (s = new Ni(e), n && r && Hh(e, n, r)), this.jr.push([t, s]), s;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let s = this;
    const o = t.length;
    if (!o)
      return s;
    for (let i = 0; i < o - 1; i++)
      s = s.tt(t[i]);
    return s.tt(t[o - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || Ni.groups;
    const s = this;
    if (e && e.j)
      return s.j[t] = e, e;
    const o = e;
    let i, a = s.go(t);
    if (a ? (i = new Ni(), Object.assign(i.j, a.j), i.jr.push.apply(i.jr, a.jr), i.jd = a.jd, i.t = a.t) : i = new Ni(), o) {
      if (r)
        if (i.t && typeof i.t == "string") {
          const c = Object.assign(bJe(i.t, r), n);
          Hh(o, c, r);
        } else n && Hh(o, n, r);
      i.t = o;
    }
    return s.j[t] = i, i;
  }
};
const Ut = (t, e, n, r, s) => t.ta(e, n, r, s), Sr = (t, e, n, r, s) => t.tr(e, n, r, s), OV = (t, e, n, r, s) => t.ts(e, n, r, s), Ae = (t, e, n, r, s) => t.tt(e, n, r, s), jd = "WORD", gR = "UWORD", Aue = "ASCIINUMERICAL", Mue = "ALPHANUMERICAL", kw = "LOCALHOST", mR = "TLD", yR = "UTLD", d_ = "SCHEME", nm = "SLASH_SCHEME", V5 = "NUM", vR = "WS", W5 = "NL", Px = "OPENBRACE", Ix = "CLOSEBRACE", mT = "OPENBRACKET", yT = "CLOSEBRACKET", vT = "OPENPAREN", bT = "CLOSEPAREN", xT = "OPENANGLEBRACKET", wT = "CLOSEANGLEBRACKET", ST = "FULLWIDTHLEFTPAREN", CT = "FULLWIDTHRIGHTPAREN", _T = "LEFTCORNERBRACKET", ET = "RIGHTCORNERBRACKET", TT = "LEFTWHITECORNERBRACKET", PT = "RIGHTWHITECORNERBRACKET", IT = "FULLWIDTHLESSTHAN", kT = "FULLWIDTHGREATERTHAN", AT = "AMPERSAND", MT = "APOSTROPHE", OT = "ASTERISK", Vu = "AT", DT = "BACKSLASH", NT = "BACKTICK", jT = "CARET", Xu = "COLON", K5 = "COMMA", RT = "DOLLAR", Sl = "DOT", $T = "EQUALS", G5 = "EXCLAMATION", Ha = "HYPHEN", kx = "PERCENT", LT = "PIPE", FT = "PLUS", BT = "POUND", Ax = "QUERY", Y5 = "QUOTE", Oue = "FULLWIDTHMIDDLEDOT", q5 = "SEMI", Cl = "SLASH", Mx = "TILDE", zT = "UNDERSCORE", Due = "EMOJI", UT = "SYM";
var Nue = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: Mue,
  AMPERSAND: AT,
  APOSTROPHE: MT,
  ASCIINUMERICAL: Aue,
  ASTERISK: OT,
  AT: Vu,
  BACKSLASH: DT,
  BACKTICK: NT,
  CARET: jT,
  CLOSEANGLEBRACKET: wT,
  CLOSEBRACE: Ix,
  CLOSEBRACKET: yT,
  CLOSEPAREN: bT,
  COLON: Xu,
  COMMA: K5,
  DOLLAR: RT,
  DOT: Sl,
  EMOJI: Due,
  EQUALS: $T,
  EXCLAMATION: G5,
  FULLWIDTHGREATERTHAN: kT,
  FULLWIDTHLEFTPAREN: ST,
  FULLWIDTHLESSTHAN: IT,
  FULLWIDTHMIDDLEDOT: Oue,
  FULLWIDTHRIGHTPAREN: CT,
  HYPHEN: Ha,
  LEFTCORNERBRACKET: _T,
  LEFTWHITECORNERBRACKET: TT,
  LOCALHOST: kw,
  NL: W5,
  NUM: V5,
  OPENANGLEBRACKET: xT,
  OPENBRACE: Px,
  OPENBRACKET: mT,
  OPENPAREN: vT,
  PERCENT: kx,
  PIPE: LT,
  PLUS: FT,
  POUND: BT,
  QUERY: Ax,
  QUOTE: Y5,
  RIGHTCORNERBRACKET: ET,
  RIGHTWHITECORNERBRACKET: PT,
  SCHEME: d_,
  SEMI: q5,
  SLASH: Cl,
  SLASH_SCHEME: nm,
  SYM: UT,
  TILDE: Mx,
  TLD: mR,
  UNDERSCORE: zT,
  UTLD: yR,
  UWORD: gR,
  WORD: jd,
  WS: vR
});
const wd = /[a-z]/, cb = new RegExp("\\p{L}", "u"), VO = new RegExp("\\p{Emoji}", "u"), Sd = /\d/, WO = /\s/, DV = "\r", KO = `
`, xJe = "", wJe = "", GO = "";
let eC = null, tC = null;
function SJe(t = []) {
  const e = {};
  Ni.groups = e;
  const n = new Ni();
  eC == null && (eC = NV(pJe)), tC == null && (tC = NV(gJe)), Ae(n, "'", MT), Ae(n, "{", Px), Ae(n, "}", Ix), Ae(n, "[", mT), Ae(n, "]", yT), Ae(n, "(", vT), Ae(n, ")", bT), Ae(n, "<", xT), Ae(n, ">", wT), Ae(n, "", ST), Ae(n, "", CT), Ae(n, "", _T), Ae(n, "", ET), Ae(n, "", TT), Ae(n, "", PT), Ae(n, "", IT), Ae(n, "", kT), Ae(n, "&", AT), Ae(n, "*", OT), Ae(n, "@", Vu), Ae(n, "`", NT), Ae(n, "^", jT), Ae(n, ":", Xu), Ae(n, ",", K5), Ae(n, "$", RT), Ae(n, ".", Sl), Ae(n, "=", $T), Ae(n, "!", G5), Ae(n, "-", Ha), Ae(n, "%", kx), Ae(n, "|", LT), Ae(n, "+", FT), Ae(n, "#", BT), Ae(n, "?", Ax), Ae(n, '"', Y5), Ae(n, "/", Cl), Ae(n, ";", q5), Ae(n, "~", Mx), Ae(n, "_", zT), Ae(n, "\\", DT), Ae(n, "", Oue);
  const r = Sr(n, Sd, V5, {
    [uR]: !0
  });
  Sr(r, Sd, r);
  const s = Sr(r, wd, Aue, {
    [Tx]: !0
  }), o = Sr(r, cb, Mue, {
    [Gb]: !0
  }), i = Sr(n, wd, jd, {
    [fR]: !0
  });
  Sr(i, Sd, s), Sr(i, wd, i), Sr(s, Sd, s), Sr(s, wd, s);
  const a = Sr(n, cb, gR, {
    [hR]: !0
  });
  Sr(a, wd), Sr(a, Sd, o), Sr(a, cb, a), Sr(o, Sd, o), Sr(o, wd), Sr(o, cb, o);
  const c = Ae(n, KO, W5, {
    [HO]: !0
  }), l = Ae(n, DV, vR, {
    [HO]: !0
  }), d = Sr(n, WO, vR, {
    [HO]: !0
  });
  Ae(n, GO, d), Ae(l, KO, c), Ae(l, GO, d), Sr(l, WO, d), Ae(d, DV), Ae(d, KO), Sr(d, WO, d), Ae(d, GO, d);
  const u = Sr(n, VO, Due, {
    [kue]: !0
  });
  Ae(u, "#"), Sr(u, VO, u), Ae(u, xJe, u);
  const f = Ae(u, wJe);
  Ae(f, "#"), Sr(f, VO, u);
  const p = [[wd, i], [Sd, s]], g = [[wd, null], [cb, a], [Sd, o]];
  for (let y = 0; y < eC.length; y++)
    Du(n, eC[y], mR, jd, p);
  for (let y = 0; y < tC.length; y++)
    Du(n, tC[y], yR, gR, g);
  Hh(mR, {
    tld: !0,
    ascii: !0
  }, e), Hh(yR, {
    utld: !0,
    alpha: !0
  }, e), Du(n, "file", d_, jd, p), Du(n, "mailto", d_, jd, p), Du(n, "http", nm, jd, p), Du(n, "https", nm, jd, p), Du(n, "ftp", nm, jd, p), Du(n, "ftps", nm, jd, p), Hh(d_, {
    scheme: !0,
    ascii: !0
  }, e), Hh(nm, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((y, m) => y[0] > m[0] ? 1 : -1);
  for (let y = 0; y < t.length; y++) {
    const m = t[y][0], b = t[y][1] ? {
      [mJe]: !0
    } : {
      [yJe]: !0
    };
    m.indexOf("-") >= 0 ? b[pR] = !0 : wd.test(m) ? Sd.test(m) ? b[Tx] = !0 : b[fR] = !0 : b[uR] = !0, OV(n, m, m, b);
  }
  return OV(n, "localhost", kw, {
    ascii: !0
  }), n.jd = new Ni(UT), {
    start: n,
    tokens: Object.assign({
      groups: e
    }, Nue)
  };
}
function jue(t, e) {
  const n = CJe(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, s = [];
  let o = 0, i = 0;
  for (; i < r; ) {
    let a = t, c = null, l = 0, d = null, u = -1, f = -1;
    for (; i < r && (c = a.go(n[i])); )
      a = c, a.accepts() ? (u = 0, f = 0, d = a) : u >= 0 && (u += n[i].length, f++), l += n[i].length, o += n[i].length, i++;
    o -= u, i -= f, l -= u, s.push({
      t: d.t,
      // token type/name
      v: e.slice(o - l, o),
      // string value
      s: o - l,
      // start index
      e: o
      // end index (excluding)
    });
  }
  return s;
}
function CJe(t) {
  const e = [], n = t.length;
  let r = 0;
  for (; r < n; ) {
    let s = t.charCodeAt(r), o, i = s < 55296 || s > 56319 || r + 1 === n || (o = t.charCodeAt(r + 1)) < 56320 || o > 57343 ? t[r] : t.slice(r, r + 2);
    e.push(i), r += i.length;
  }
  return e;
}
function Du(t, e, n, r, s) {
  let o;
  const i = e.length;
  for (let a = 0; a < i - 1; a++) {
    const c = e[a];
    t.j[c] ? o = t.j[c] : (o = new Ni(r), o.jr = s.slice(), t.j[c] = o), t = o;
  }
  return o = new Ni(n), o.jr = s.slice(), t.j[e[i - 1]] = o, o;
}
function NV(t) {
  const e = [], n = [];
  let r = 0, s = "0123456789";
  for (; r < t.length; ) {
    let o = 0;
    for (; s.indexOf(t[r + o]) >= 0; )
      o++;
    if (o > 0) {
      e.push(n.join(""));
      for (let i = parseInt(t.substring(r, r + o), 10); i > 0; i--)
        n.pop();
      r += o;
    } else
      n.push(t[r]), r++;
  }
  return e;
}
const Aw = {
  defaultProtocol: "http",
  events: null,
  format: jV,
  formatHref: jV,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function X5(t, e = null) {
  let n = Object.assign({}, Aw);
  t && (n = Object.assign(n, t instanceof X5 ? t.o : t));
  const r = n.ignoreTags, s = [];
  for (let o = 0; o < r.length; o++)
    s.push(r[o].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = s;
}
X5.prototype = {
  o: Aw,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let s = this.o[t];
    return s && (typeof s == "object" ? (s = n.t in s ? s[n.t] : Aw[t], typeof s == "function" && r && (s = s(e, n))) : typeof s == "function" && r && (s = s(e, n.t, n)), s);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function jV(t) {
  return t;
}
function Rue(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
Rue.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = Aw.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), r = t.get("formatHref", n, this), s = t.get("tagName", n, e), o = this.toFormattedString(t), i = {}, a = t.get("className", n, e), c = t.get("target", n, e), l = t.get("rel", n, e), d = t.getObj("attributes", n, e), u = t.getObj("events", n, e);
    return i.href = r, a && (i.class = a), c && (i.target = c), l && (i.rel = l), d && Object.assign(i, d), {
      tagName: s,
      attributes: i,
      content: o,
      eventListeners: u
    };
  }
};
function Fk(t, e) {
  class n extends Rue {
    constructor(s, o) {
      super(s, o), this.t = t;
    }
  }
  for (const r in e)
    n.prototype[r] = e[r];
  return n.t = t, n;
}
const RV = Fk("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), $V = Fk("text"), _Je = Fk("nl"), nC = Fk("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = Aw.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== kw && t[1].t === Xu;
  }
}), Ba = (t) => new Ni(t);
function EJe({
  groups: t
}) {
  const e = t.domain.concat([AT, OT, Vu, DT, NT, jT, RT, $T, Ha, V5, kx, LT, FT, BT, Cl, UT, Mx, zT]), n = [MT, Xu, K5, Sl, G5, kx, Ax, Y5, q5, xT, wT, Px, Ix, yT, mT, vT, bT, ST, CT, _T, ET, TT, PT, IT, kT], r = [AT, MT, OT, DT, NT, jT, RT, $T, Ha, Px, Ix, kx, LT, FT, BT, Ax, Cl, UT, Mx, zT], s = Ba(), o = Ae(s, Mx);
  Ut(o, r, o), Ut(o, t.domain, o);
  const i = Ba(), a = Ba(), c = Ba();
  Ut(s, t.domain, i), Ut(s, t.scheme, a), Ut(s, t.slashscheme, c), Ut(i, r, o), Ut(i, t.domain, i);
  const l = Ae(i, Vu);
  Ae(o, Vu, l), Ae(a, Vu, l), Ae(c, Vu, l);
  const d = Ae(o, Sl);
  Ut(d, r, o), Ut(d, t.domain, o);
  const u = Ba();
  Ut(l, t.domain, u), Ut(u, t.domain, u);
  const f = Ae(u, Sl);
  Ut(f, t.domain, u);
  const p = Ba(RV);
  Ut(f, t.tld, p), Ut(f, t.utld, p), Ae(l, kw, p);
  const g = Ae(u, Ha);
  Ae(g, Ha, g), Ut(g, t.domain, u), Ut(p, t.domain, u), Ae(p, Sl, f), Ae(p, Ha, g);
  const y = Ae(p, Xu);
  Ut(y, t.numeric, RV);
  const m = Ae(i, Ha), v = Ae(i, Sl);
  Ae(m, Ha, m), Ut(m, t.domain, i), Ut(v, r, o), Ut(v, t.domain, i);
  const b = Ba(nC);
  Ut(v, t.tld, b), Ut(v, t.utld, b), Ut(b, t.domain, i), Ut(b, r, o), Ae(b, Sl, v), Ae(b, Ha, m), Ae(b, Vu, l);
  const x = Ae(b, Xu), w = Ba(nC);
  Ut(x, t.numeric, w);
  const S = Ba(nC), C = Ba();
  Ut(S, e, S), Ut(S, n, C), Ut(C, e, S), Ut(C, n, C), Ae(b, Cl, S), Ae(w, Cl, S);
  const _ = Ae(a, Xu), E = Ae(c, Xu), M = Ae(E, Cl), N = Ae(M, Cl);
  Ut(a, t.domain, i), Ae(a, Sl, v), Ae(a, Ha, m), Ut(c, t.domain, i), Ae(c, Sl, v), Ae(c, Ha, m), Ut(_, t.domain, S), Ae(_, Cl, S), Ae(_, Ax, S), Ut(N, t.domain, S), Ut(N, e, S), Ae(N, Cl, S);
  const O = [
    [Px, Ix],
    // {}
    [mT, yT],
    // []
    [vT, bT],
    // ()
    [xT, wT],
    // <>
    [ST, CT],
    // 
    [_T, ET],
    // 
    [TT, PT],
    // 
    [IT, kT]
    // 
  ];
  for (let D = 0; D < O.length; D++) {
    const [k, A] = O[D], R = Ae(S, k);
    Ae(C, k, R), Ae(R, A, S);
    const j = Ba(nC);
    Ut(R, e, j);
    const $ = Ba();
    Ut(R, n), Ut(j, e, j), Ut(j, n, $), Ut($, e, j), Ut($, n, $), Ae(j, A, S), Ae($, A, S);
  }
  return Ae(s, kw, b), Ae(s, W5, _Je), {
    start: s,
    tokens: Nue
  };
}
function TJe(t, e, n) {
  let r = n.length, s = 0, o = [], i = [];
  for (; s < r; ) {
    let a = t, c = null, l = null, d = 0, u = null, f = -1;
    for (; s < r && !(c = a.go(n[s].t)); )
      i.push(n[s++]);
    for (; s < r && (l = c || a.go(n[s].t)); )
      c = null, a = l, a.accepts() ? (f = 0, u = a) : f >= 0 && f++, s++, d++;
    if (f < 0)
      s -= d, s < r && (i.push(n[s]), s++);
    else {
      i.length > 0 && (o.push(YO($V, e, i)), i = []), s -= f, d -= f;
      const p = u.t, g = n.slice(s - d, s);
      o.push(YO(p, e, g));
    }
  }
  return i.length > 0 && o.push(YO($V, e, i)), o;
}
function YO(t, e, n) {
  const r = n[0].s, s = n[n.length - 1].e, o = e.slice(r, s);
  return new t(o, n);
}
const PJe = typeof console < "u" && console && console.warn || (() => {
}), IJe = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Zn = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function kJe() {
  return Ni.groups = {}, Zn.scanner = null, Zn.parser = null, Zn.tokenQueue = [], Zn.pluginQueue = [], Zn.customSchemes = [], Zn.initialized = !1, Zn;
}
function LV(t, e = !1) {
  if (Zn.initialized && PJe(`linkifyjs: already initialized - will not register custom scheme "${t}" ${IJe}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Zn.customSchemes.push([t, e]);
}
function AJe() {
  Zn.scanner = SJe(Zn.customSchemes);
  for (let t = 0; t < Zn.tokenQueue.length; t++)
    Zn.tokenQueue[t][1]({
      scanner: Zn.scanner
    });
  Zn.parser = EJe(Zn.scanner.tokens);
  for (let t = 0; t < Zn.pluginQueue.length; t++)
    Zn.pluginQueue[t][1]({
      scanner: Zn.scanner,
      parser: Zn.parser
    });
  return Zn.initialized = !0, Zn;
}
function Z5(t) {
  return Zn.initialized || AJe(), TJe(Zn.parser.start, t, jue(Zn.scanner.start, t));
}
Z5.scan = jue;
function $ue(t, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const r = new X5(n), s = Z5(t), o = [];
  for (let i = 0; i < s.length; i++) {
    const a = s[i];
    a.isLink && (!e || a.t === e) && r.check(a) && o.push(a.toFormattedObject(r));
  }
  return o;
}
const Q5 = "[\0- -\u2029]", MJe = new RegExp(Q5), OJe = new RegExp(`${Q5}$`), DJe = new RegExp(Q5, "g");
function NJe(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function jJe(t) {
  return new fo({
    key: new Oa("autolink"),
    appendTransaction: (e, n, r) => {
      const s = e.some((l) => l.docChanged) && !n.doc.eq(r.doc), o = e.some((l) => l.getMeta("preventAutolink"));
      if (!s || o)
        return;
      const { tr: i } = r, a = wKe(n.doc, [...e]);
      if (MKe(a).forEach(({ newRange: l }) => {
        const d = CKe(r.doc, l, (p) => p.isTextblock);
        let u, f;
        if (d.length > 1)
          u = d[0], f = r.doc.textBetween(u.pos, u.pos + u.node.nodeSize, void 0, " ");
        else if (d.length) {
          const p = r.doc.textBetween(l.from, l.to, " ", " ");
          if (!OJe.test(p))
            return;
          u = d[0], f = r.doc.textBetween(u.pos, l.to, void 0, " ");
        }
        if (u && f) {
          const p = f.split(MJe).filter(Boolean);
          if (p.length <= 0)
            return !1;
          const g = p[p.length - 1], y = u.pos + f.lastIndexOf(g);
          if (!g)
            return !1;
          const m = Z5(g).map((v) => v.toObject(t.defaultProtocol));
          if (!NJe(m))
            return !1;
          m.filter((v) => v.isLink).map((v) => ({
            ...v,
            from: y + v.start + 1,
            to: y + v.end + 1
          })).filter((v) => r.schema.marks.code ? !r.doc.rangeHasMark(v.from, v.to, r.schema.marks.code) : !0).filter((v) => t.validate(v.value)).filter((v) => t.shouldAutoLink(v.value)).forEach((v) => {
            J3(v.from, v.to, r.doc).some((b) => b.mark.type === t.type) || i.addMark(v.from, v.to, t.type.create({
              href: v.href
            }));
          });
        }
      }), !!i.steps.length)
        return i;
    }
  });
}
function RJe(t) {
  return new fo({
    key: new Oa("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var s, o;
        if (r.button !== 0 || !e.editable)
          return !1;
        let i = r.target;
        const a = [];
        for (; i.nodeName !== "DIV"; )
          a.push(i), i = i.parentNode;
        if (!a.find((f) => f.nodeName === "A"))
          return !1;
        const c = Vae(e.state, t.type.name), l = r.target, d = (s = l == null ? void 0 : l.href) !== null && s !== void 0 ? s : c.href, u = (o = l == null ? void 0 : l.target) !== null && o !== void 0 ? o : c.target;
        return l && d ? (window.open(d, u), !0) : !1;
      }
    }
  });
}
function $Je(t) {
  return new fo({
    key: new Oa("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { state: s } = e, { selection: o } = s, { empty: i } = o;
        if (i)
          return !1;
        let a = "";
        r.content.forEach((l) => {
          a += l.textContent;
        });
        const c = $ue(a, { defaultProtocol: t.defaultProtocol }).find((l) => l.isLink && l.value === a);
        return !a || !c ? !1 : t.editor.commands.setMark(t.type, {
          href: c.href
        });
      }
    }
  });
}
function Sh(t, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return e && e.forEach((r) => {
    const s = typeof r == "string" ? r : r.scheme;
    s && n.push(s);
  }), !t || t.replace(DJe, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const LJe = Jl.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        LV(t);
        return;
      }
      LV(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    kJe();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, e) => !!Sh(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const e = t.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (n) => !!Sh(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!Sh(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", $s(this.options.HTMLAttributes, t), 0] : [
      "a",
      $s(this.options.HTMLAttributes, { ...t, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Sh(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Sh(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() : !1;
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      $f({
        find: (t) => {
          const e = [];
          if (t) {
            const { protocols: n, defaultProtocol: r } = this.options, s = $ue(t).filter((o) => o.isLink && this.options.isAllowedUri(o.value, {
              defaultValidate: (i) => !!Sh(i, n),
              protocols: n,
              defaultProtocol: r
            }));
            s.length && s.forEach((o) => e.push({
              text: o.value,
              data: {
                href: o.href
              },
              index: o.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: e, defaultProtocol: n } = this.options;
    return this.options.autolink && t.push(jJe({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (r) => this.options.isAllowedUri(r, {
        defaultValidate: (s) => !!Sh(s, e),
        protocols: e,
        defaultProtocol: n
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === !0 && t.push(RJe({
      type: this.type
    })), this.options.linkOnPaste && t.push($Je({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t;
  }
}), FJe = /^\s*>\s$/, BJe = ul.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", $s(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      ww({
        find: FJe,
        type: this.type
      })
    ];
  }
}), zJe = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, UJe = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, HJe = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, VJe = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, WJe = Jl.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", $s(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      jp({
        find: zJe,
        type: this.type
      }),
      jp({
        find: HJe,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      $f({
        find: UJe,
        type: this.type
      }),
      $f({
        find: VJe,
        type: this.type
      })
    ];
  }
}), KJe = "listItem", FV = "textStyle", BV = /^\s*([-+*])\s$/, GJe = ul.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", $s(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(KJe, this.editor.getAttributes(FV)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = ww({
      find: BV,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = ww({
      find: BV,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(FV),
      editor: this.editor
    })), [
      t
    ];
  }
}), YJe = /^```([a-z]+)?[\s\n]$/, qJe = /^~~~([a-z]+)?[\s\n]$/, XJe = ul.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options, o = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((i) => i.startsWith(n)).map((i) => i.replace(n, ""))[0];
          return o || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      $s(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: r, empty: s } = n;
        if (!s || r.parent.type !== this.type)
          return !1;
        const o = r.parentOffset === r.parent.nodeSize - 2, i = r.parent.textContent.endsWith(`

`);
        return !o || !i ? !1 : t.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: r } = e, { $from: s, empty: o } = n;
        if (!o || s.parent.type !== this.type || !(s.parentOffset === s.parent.nodeSize - 2))
          return !1;
        const a = s.after();
        return a === void 0 ? !1 : r.nodeAt(a) ? t.commands.command(({ tr: l }) => (l.setSelection(Ht.near(r.resolve(a))), !0)) : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      Uj({
        find: YJe,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      Uj({
        find: qJe,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new fo({
        key: new Oa("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), s = r ? JSON.parse(r) : void 0, o = s == null ? void 0 : s.mode;
            if (!n || !o)
              return !1;
            const { tr: i, schema: a } = t.state, c = a.text(n.replace(/\r\n?/g, `
`));
            return i.replaceSelectionWith(this.type.create({ language: o }, c)), i.selection.$from.parent.type !== this.type && i.setSelection(Dt.near(i.doc.resolve(Math.max(0, i.selection.from - 2)))), i.setMeta("paste", !0), t.dispatch(i), !0;
          }
        }
      })
    ];
  }
}), ZJe = ul.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
function QJe(t = {}) {
  return new fo({
    view(e) {
      return new JJe(e, t);
    }
  });
}
class JJe {
  constructor(e, n) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((s) => {
      let o = (i) => {
        this[s](i);
      };
      return e.dom.addEventListener(s, o), { name: s, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r, s = this.editorView.dom, o = s.getBoundingClientRect(), i = o.width / s.offsetWidth, a = o.height / s.offsetHeight;
    if (n) {
      let u = e.nodeBefore, f = e.nodeAfter;
      if (u || f) {
        let p = this.editorView.nodeDOM(this.cursorPos - (u ? u.nodeSize : 0));
        if (p) {
          let g = p.getBoundingClientRect(), y = u ? g.bottom : g.top;
          u && f && (y = (y + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let m = this.width / 2 * a;
          r = { left: g.left, right: g.right, top: y - m, bottom: y + m };
        }
      }
    }
    if (!r) {
      let u = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * i;
      r = { left: u.left - f, right: u.left + f, top: u.top, bottom: u.bottom };
    }
    let c = this.editorView.dom.offsetParent;
    this.element || (this.element = c.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let l, d;
    if (!c || c == document.body && getComputedStyle(c).position == "static")
      l = -pageXOffset, d = -pageYOffset;
    else {
      let u = c.getBoundingClientRect(), f = u.width / c.offsetWidth, p = u.height / c.offsetHeight;
      l = u.left - c.scrollLeft * f, d = u.top - c.scrollTop * p;
    }
    this.element.style.left = (r.left - l) / i + "px", this.element.style.top = (r.top - d) / a + "px", this.element.style.width = (r.right - r.left) / i + "px", this.element.style.height = (r.bottom - r.top) / a + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), s = r && r.type.spec.disableDropCursor, o = typeof s == "function" ? s(this.editorView, n, e) : s;
    if (n && !o) {
      let i = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = $ie(this.editorView.state.doc, i, this.editorView.dragging.slice);
        a != null && (i = a);
      }
      this.setCursor(i), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
const eet = co.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      QJe(this.options)
    ];
  }
});
class Tr extends Ht {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return Tr.valid(r) ? new Tr(r) : Ht.near(r);
  }
  content() {
    return We.empty;
  }
  eq(e) {
    return e instanceof Tr && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Tr(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new J5(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !tet(e) || !net(e))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let s = n.contentMatchAt(e.index()).defaultType;
    return s && s.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e: for (; ; ) {
      if (!r && Tr.valid(e))
        return e;
      let s = e.pos, o = null;
      for (let i = e.depth; ; i--) {
        let a = e.node(i);
        if (n > 0 ? e.indexAfter(i) < a.childCount : e.index(i) > 0) {
          o = a.child(n > 0 ? e.indexAfter(i) : e.index(i) - 1);
          break;
        } else if (i == 0)
          return null;
        s += n;
        let c = e.doc.resolve(s);
        if (Tr.valid(c))
          return c;
      }
      for (; ; ) {
        let i = n > 0 ? o.firstChild : o.lastChild;
        if (!i) {
          if (o.isAtom && !o.isText && !ht.isSelectable(o)) {
            e = e.doc.resolve(s + o.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        o = i, s += n;
        let a = e.doc.resolve(s);
        if (Tr.valid(a))
          return a;
      }
      return null;
    }
  }
}
Tr.prototype.visible = !1;
Tr.findFrom = Tr.findGapCursorFrom;
Ht.jsonID("gapcursor", Tr);
class J5 {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new J5(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return Tr.valid(n) ? new Tr(n) : Ht.near(n);
  }
}
function Lue(t) {
  return t.isAtom || t.spec.isolating || t.spec.createGapCursor;
}
function tet(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let s = r.child(n - 1); ; s = s.lastChild) {
      if (s.childCount == 0 && !s.inlineContent || Lue(s.type))
        return !0;
      if (s.inlineContent)
        return !1;
    }
  }
  return !0;
}
function net(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let s = r.child(n); ; s = s.firstChild) {
      if (s.childCount == 0 && !s.inlineContent || Lue(s.type))
        return !0;
      if (s.inlineContent)
        return !1;
    }
  }
  return !0;
}
function ret() {
  return new fo({
    props: {
      decorations: aet,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && Tr.valid(n) ? new Tr(n) : null;
      },
      handleClick: oet,
      handleKeyDown: set,
      handleDOMEvents: { beforeinput: iet }
    }
  });
}
const set = Tae({
  ArrowLeft: rC("horiz", -1),
  ArrowRight: rC("horiz", 1),
  ArrowUp: rC("vert", -1),
  ArrowDown: rC("vert", 1)
});
function rC(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, s, o) {
    let i = r.selection, a = e > 0 ? i.$to : i.$from, c = i.empty;
    if (i instanceof Dt) {
      if (!o.endOfTextblock(n) || a.depth == 0)
        return !1;
      c = !1, a = r.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let l = Tr.findGapCursorFrom(a, e, c);
    return l ? (s && s(r.tr.setSelection(new Tr(l))), !0) : !1;
  };
}
function oet(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let r = t.state.doc.resolve(e);
  if (!Tr.valid(r))
    return !1;
  let s = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return s && s.inside > -1 && ht.isSelectable(t.state.doc.nodeAt(s.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new Tr(r))), !0);
}
function iet(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof Tr))
    return !1;
  let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!r)
    return !1;
  let s = Pe.empty;
  for (let i = r.length - 1; i >= 0; i--)
    s = Pe.from(r[i].createAndFill(null, s));
  let o = t.state.tr.replace(n.pos, n.pos, new We(s, 0, 0));
  return o.setSelection(Dt.near(o.doc.resolve(n.pos + 1))), t.dispatch(o), !1;
}
function aet(t) {
  if (!(t.selection instanceof Tr))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", hs.create(t.doc, [ec.widget(t.selection.head, e, { key: "gapcursor" })]);
}
const cet = co.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      ret()
    ];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = Kt(et(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
}), det = ul.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", $s(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: s, storedMarks: o } = n;
          if (s.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: i } = this.options, { splittableMarks: a } = r.extensionManager, c = o || s.$to.parentOffset && s.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: l, dispatch: d }) => {
            if (d && c && i) {
              const u = c.filter((f) => a.includes(f.type.name));
              l.ensureMarks(u);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), uet = ul.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, $s(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => Uj({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
});
var HT = 200, js = function() {
};
js.prototype.append = function(e) {
  return e.length ? (e = js.from(e), !this.length && e || e.length < HT && this.leafAppend(e) || this.length < HT && e.leafPrepend(this) || this.appendInner(e)) : this;
};
js.prototype.prepend = function(e) {
  return e.length ? js.from(e).append(this) : this;
};
js.prototype.appendInner = function(e) {
  return new fet(this, e);
};
js.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? js.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
js.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
js.prototype.forEach = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
js.prototype.map = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var s = [];
  return this.forEach(function(o, i) {
    return s.push(e(o, i));
  }, n, r), s;
};
js.from = function(e) {
  return e instanceof js ? e : e && e.length ? new Fue(e) : js.empty;
};
var Fue = /* @__PURE__ */ function(t) {
  function e(r) {
    t.call(this), this.values = r;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(s, o) {
    return s == 0 && o == this.length ? this : new e(this.values.slice(s, o));
  }, e.prototype.getInner = function(s) {
    return this.values[s];
  }, e.prototype.forEachInner = function(s, o, i, a) {
    for (var c = o; c < i; c++)
      if (s(this.values[c], a + c) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(s, o, i, a) {
    for (var c = o - 1; c >= i; c--)
      if (s(this.values[c], a + c) === !1)
        return !1;
  }, e.prototype.leafAppend = function(s) {
    if (this.length + s.length <= HT)
      return new e(this.values.concat(s.flatten()));
  }, e.prototype.leafPrepend = function(s) {
    if (this.length + s.length <= HT)
      return new e(s.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(js);
js.empty = new Fue([]);
var fet = /* @__PURE__ */ function(t) {
  function e(n, r) {
    t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, s, o, i) {
    var a = this.left.length;
    if (s < a && this.left.forEachInner(r, s, Math.min(o, a), i) === !1 || o > a && this.right.forEachInner(r, Math.max(s - a, 0), Math.min(this.length, o) - a, i + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, s, o, i) {
    var a = this.left.length;
    if (s > a && this.right.forEachInvertedInner(r, s - a, Math.max(o, a) - a, i + a) === !1 || o < a && this.left.forEachInvertedInner(r, Math.min(s, a), o, i) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, s) {
    if (r == 0 && s == this.length)
      return this;
    var o = this.left.length;
    return s <= o ? this.left.slice(r, s) : r >= o ? this.right.slice(r - o, s - o) : this.left.slice(r, o).append(this.right.slice(0, s - o));
  }, e.prototype.leafAppend = function(r) {
    var s = this.right.leafAppend(r);
    if (s)
      return new e(this.left, s);
  }, e.prototype.leafPrepend = function(r) {
    var s = this.left.leafPrepend(r);
    if (s)
      return new e(s, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(js);
const het = 500;
class jc {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let s, o;
    n && (s = this.remapping(r, this.items.length), o = s.maps.length);
    let i = e.tr, a, c, l = [], d = [];
    return this.items.forEach((u, f) => {
      if (!u.step) {
        s || (s = this.remapping(r, f + 1), o = s.maps.length), o--, d.push(u);
        return;
      }
      if (s) {
        d.push(new _l(u.map));
        let p = u.step.map(s.slice(o)), g;
        p && i.maybeStep(p).doc && (g = i.mapping.maps[i.mapping.maps.length - 1], l.push(new _l(g, void 0, void 0, l.length + d.length))), o--, g && s.appendMap(g, o);
      } else
        i.maybeStep(u.step);
      if (u.selection)
        return a = s ? u.selection.map(s.slice(o)) : u.selection, c = new jc(this.items.slice(0, r).append(d.reverse().concat(l)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: c, transform: i, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, s) {
    let o = [], i = this.eventCount, a = this.items, c = !s && a.length ? a.get(a.length - 1) : null;
    for (let d = 0; d < e.steps.length; d++) {
      let u = e.steps[d].invert(e.docs[d]), f = new _l(e.mapping.maps[d], u, n), p;
      (p = c && c.merge(f)) && (f = p, d ? o.pop() : a = a.slice(0, a.length - 1)), o.push(f), n && (i++, n = void 0), s || (c = f);
    }
    let l = i - r.depth;
    return l > get && (a = pet(a, l), i -= l), new jc(a.append(o), i);
  }
  remapping(e, n) {
    let r = new pw();
    return this.items.forEach((s, o) => {
      let i = s.mirrorOffset != null && o - s.mirrorOffset >= e ? r.maps.length - s.mirrorOffset : void 0;
      r.appendMap(s.map, i);
    }, e, n), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new jc(this.items.append(e.map((n) => new _l(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let r = [], s = Math.max(0, this.items.length - n), o = e.mapping, i = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, s);
    let c = n;
    this.items.forEach((f) => {
      let p = o.getMirror(--c);
      if (p == null)
        return;
      i = Math.min(i, p);
      let g = o.maps[p];
      if (f.step) {
        let y = e.steps[p].invert(e.docs[p]), m = f.selection && f.selection.map(o.slice(c + 1, p));
        m && a++, r.push(new _l(g, y, m));
      } else
        r.push(new _l(g));
    }, s);
    let l = [];
    for (let f = n; f < i; f++)
      l.push(new _l(o.maps[f]));
    let d = this.items.slice(0, s).append(l).append(r), u = new jc(d, a);
    return u.emptyItemCount() > het && (u = u.compress(this.items.length - r.length)), u;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), r = n.maps.length, s = [], o = 0;
    return this.items.forEach((i, a) => {
      if (a >= e)
        s.push(i), i.selection && o++;
      else if (i.step) {
        let c = i.step.map(n.slice(r)), l = c && c.getMap();
        if (r--, l && n.appendMap(l, r), c) {
          let d = i.selection && i.selection.map(n.slice(r));
          d && o++;
          let u = new _l(l.invert(), c, d), f, p = s.length - 1;
          (f = s.length && s[p].merge(u)) ? s[p] = f : s.push(u);
        }
      } else i.map && r--;
    }, this.items.length, 0), new jc(js.from(s.reverse()), o);
  }
}
jc.empty = new jc(js.empty, 0);
function pet(t, e) {
  let n;
  return t.forEach((r, s) => {
    if (r.selection && e-- == 0)
      return n = s, !1;
  }), t.slice(n);
}
class _l {
  constructor(e, n, r, s) {
    this.map = e, this.step = n, this.selection = r, this.mirrorOffset = s;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new _l(n.getMap().invert(), n, this.selection);
    }
  }
}
class Wu {
  constructor(e, n, r, s, o) {
    this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = s, this.prevComposition = o;
  }
}
const get = 20;
function met(t, e, n, r) {
  let s = n.getMeta(up), o;
  if (s)
    return s.historyState;
  n.getMeta(Bue) && (t = new Wu(t.done, t.undone, null, 0, -1));
  let i = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (i && i.getMeta(up))
    return i.getMeta(up).redo ? new Wu(t.done.addTransform(n, void 0, r, u_(e)), t.undone, zV(n.mapping.maps), t.prevTime, t.prevComposition) : new Wu(t.done, t.undone.addTransform(n, void 0, r, u_(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(i && i.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), c = t.prevTime == 0 || !i && t.prevComposition != a && (t.prevTime < (n.time || 0) - r.newGroupDelay || !yet(n, t.prevRanges)), l = i ? qO(t.prevRanges, n.mapping) : zV(n.mapping.maps);
    return new Wu(t.done.addTransform(n, c ? e.selection.getBookmark() : void 0, r, u_(e)), jc.empty, l, n.time, a ?? t.prevComposition);
  } else return (o = n.getMeta("rebased")) ? new Wu(t.done.rebased(n, o), t.undone.rebased(n, o), qO(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new Wu(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), qO(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function yet(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((r, s) => {
    for (let o = 0; o < e.length; o += 2)
      r <= e[o + 1] && s >= e[o] && (n = !0);
  }), n;
}
function zV(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((r, s, o, i) => e.push(o, i));
  return e;
}
function qO(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let s = e.map(t[r], 1), o = e.map(t[r + 1], -1);
    s <= o && n.push(s, o);
  }
  return n;
}
function vet(t, e, n) {
  let r = u_(e), s = up.get(e).spec.config, o = (n ? t.undone : t.done).popEvent(e, r);
  if (!o)
    return null;
  let i = o.selection.resolve(o.transform.doc), a = (n ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), s, r), c = new Wu(n ? a : o.remaining, n ? o.remaining : a, null, 0, -1);
  return o.transform.setSelection(i).setMeta(up, { redo: n, historyState: c });
}
let XO = !1, UV = null;
function u_(t) {
  let e = t.plugins;
  if (UV != e) {
    XO = !1, UV = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        XO = !0;
        break;
      }
  }
  return XO;
}
function r5t(t) {
  return t.setMeta(Bue, !0);
}
const up = new Oa("history"), Bue = new Oa("closeHistory");
function bet(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new fo({
    key: up,
    state: {
      init() {
        return new Wu(jc.empty, jc.empty, null, 0, -1);
      },
      apply(e, n, r) {
        return met(n, r, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let r = n.inputType, s = r == "historyUndo" ? Uue : r == "historyRedo" ? Hue : null;
          return !s || !e.editable ? !1 : (n.preventDefault(), s(e.state, e.dispatch));
        }
      }
    }
  });
}
function zue(t, e) {
  return (n, r) => {
    let s = up.getState(n);
    if (!s || (t ? s.undone : s.done).eventCount == 0)
      return !1;
    if (r) {
      let o = vet(s, n, t);
      o && r(e ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const Uue = zue(!1, !0), Hue = zue(!0, !0), xet = co.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => Uue(t, e),
      redo: () => ({ state: t, dispatch: e }) => Hue(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      bet(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
}), wet = ul.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", $s(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        if (!fGe(e, e.schema.nodes[this.name]))
          return !1;
        const { selection: n } = e, { $from: r, $to: s } = n, o = t();
        return r.parentOffset === 0 ? o.insertContentAt({
          from: Math.max(r.pos - 1, 0),
          to: s.pos
        }, {
          type: this.name
        }) : DKe(n) ? o.insertContentAt(s.pos, {
          type: this.name
        }) : o.insertContent({ type: this.name }), o.command(({ tr: i, dispatch: a }) => {
          var c;
          if (a) {
            const { $to: l } = i.selection, d = l.end();
            if (l.nodeAfter)
              l.nodeAfter.isTextblock ? i.setSelection(Dt.create(i.doc, l.pos + 1)) : l.nodeAfter.isBlock ? i.setSelection(ht.create(i.doc, l.pos)) : i.setSelection(Dt.create(i.doc, l.pos));
            else {
              const u = (c = l.parent.type.contentMatch.defaultType) === null || c === void 0 ? void 0 : c.create();
              u && (i.insert(d, u), i.setSelection(Dt.create(i.doc, d + 1)));
            }
            i.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      uGe({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), Cet = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, _et = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, Eet = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, Tet = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, Pet = Jl.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", $s(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      jp({
        find: Cet,
        type: this.type
      }),
      jp({
        find: Eet,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      $f({
        find: _et,
        type: this.type
      }),
      $f({
        find: Tet,
        type: this.type
      })
    ];
  }
}), Iet = ul.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", $s(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), ket = "listItem", HV = "textStyle", VV = /^(\d+)\.\s$/, Aet = ul.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", $s(this.options.HTMLAttributes, n), 0] : ["ol", $s(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ket, this.editor.getAttributes(HV)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = ww({
      find: VV,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = ww({
      find: VV,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(HV) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [
      t
    ];
  }
}), Met = ul.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", $s(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), Oet = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, Det = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, Net = Jl.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", $s(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      jp({
        find: Oet,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      $f({
        find: Det,
        type: this.type
      })
    ];
  }
}), jet = ul.create({
  name: "text",
  group: "inline"
}), Ret = co.create({
  name: "starterKit",
  addExtensions() {
    const t = [];
    return this.options.bold !== !1 && t.push(WJe.configure(this.options.bold)), this.options.blockquote !== !1 && t.push(BJe.configure(this.options.blockquote)), this.options.bulletList !== !1 && t.push(GJe.configure(this.options.bulletList)), this.options.code !== !1 && t.push(Pue.configure(this.options.code)), this.options.codeBlock !== !1 && t.push(XJe.configure(this.options.codeBlock)), this.options.document !== !1 && t.push(ZJe.configure(this.options.document)), this.options.dropcursor !== !1 && t.push(eet.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && t.push(cet.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && t.push(det.configure(this.options.hardBreak)), this.options.heading !== !1 && t.push(uet.configure(this.options.heading)), this.options.history !== !1 && t.push(xet.configure(this.options.history)), this.options.horizontalRule !== !1 && t.push(wet.configure(this.options.horizontalRule)), this.options.italic !== !1 && t.push(Pet.configure(this.options.italic)), this.options.listItem !== !1 && t.push(Iet.configure(this.options.listItem)), this.options.orderedList !== !1 && t.push(Aet.configure(this.options.orderedList)), this.options.paragraph !== !1 && t.push(Met.configure(this.options.paragraph)), this.options.strike !== !1 && t.push(Net.configure(this.options.strike)), this.options.text !== !1 && t.push(jet.configure(this.options.text)), t;
  }
}), e4 = {
  tldraw_draw: {
    normal: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw", format: "woff2" },
        weight: "normal"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_bold", format: "woff2" },
        weight: "bold"
      }
    },
    italic: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_sans: {
    normal: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_serif: {
    normal: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_mono: {
    normal: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  }
}, $et = Er(e4).flatMap(
  (t) => Er(t).flatMap((e) => Object.values(e))
), Let = co.create({
  name: "textDirection",
  addGlobalAttributes() {
    return [
      {
        types: ["heading", "paragraph"],
        attributes: {
          dir: {
            default: "auto",
            parseHTML: (t) => {
              const e = t.getAttribute("dir");
              return e && ["ltr", "rtl", "auto"].includes(e) ? e : "auto";
            },
            renderHTML: (t) => ({ dir: t.dir })
          }
        }
      }
    ];
  }
}), Fet = co.create({
  name: "keyboardShiftEnterHandler",
  addKeyboardShortcuts() {
    return {
      // We don't support soft breaks, so we just use the default enter command.
      "Shift-Enter": ({ editor: t }) => t.commands.enter()
    };
  }
});
Pue.config.excludes = void 0;
Iue.config.priority = 1100;
const mS = [
  Ret.configure({
    blockquote: !1,
    codeBlock: !1,
    horizontalRule: !1
  }),
  LJe.configure({
    openOnClick: !1,
    autolink: !0
  }),
  Iue,
  Fet,
  Let
], Bet = new No();
function t4(t, e) {
  return Bet.get(e, () => {
    var s;
    const n = ((s = t.getTextOptions().tipTapConfig) == null ? void 0 : s.extensions) ?? mS;
    return EKe(e, n).replaceAll('<p dir="auto"></p>', "<p><br /></p>") ?? "";
  });
}
function VT(t, e) {
  return `<div class="tl-rich-text">${t4(t, e)}</div>`;
}
const zet = new No();
function Ai(t) {
  return t.content.length === 1 && !t.content[0].content;
}
function Lp(t, e) {
  return Ai(e) ? "" : zet.get(e, () => {
    var r;
    const n = ((r = t.getTextOptions().tipTapConfig) == null ? void 0 : r.extensions) ?? mS;
    return PKe(e, n, {
      blockSeparator: `
`
    });
  });
}
function Uet(t, e) {
  var r;
  const n = ((r = t.getTextOptions().tipTapConfig) == null ? void 0 : r.extensions) ?? mS;
  return TKe(e, n);
}
function Vue(t, e, n) {
  for (const i of t.marks)
    i.type.name === "bold" && e.weight !== "bold" && (e = { ...e, weight: "bold" }), i.type.name === "italic" && e.style !== "italic" && (e = { ...e, style: "italic" }), i.type.name === "code" && e.family !== "tldraw_mono" && (e = { ...e, family: "tldraw_mono" });
  const r = Fr(e4, e.family);
  if (!r) return e;
  const s = Fr(r, e.style);
  if (!s) return e;
  const o = Fr(s, e.weight);
  return o && n(o), e;
}
const Het = "  ", Kx = class Kx {
  static normalizeText(e) {
    return e.replace(Kx.fixNewLines, `
`);
  }
  static normalizeTextForDom(e) {
    return e.replace(Kx.fixNewLines, `
`).split(`
`).map((n) => n || " ").join(`
`);
  }
};
P(Kx, "fixNewLines", /\r?\n|\r/g);
let WT = Kx;
const Vet = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
function Wue(t) {
  return Vet.test(t);
}
function Wet(t) {
  return t.replace(/\t/g, Het);
}
function Ket(t) {
  const e = t.split(`
`);
  for (; e[0] && e[0].trim().length === 0; )
    e.shift();
  let n = 1 / 0;
  for (const r of e)
    if (r.trim().length > 0) {
      const s = r.length - r.trimStart().length;
      n = Math.min(n, s);
    }
  return e.map((r) => r.slice(n)).join(`
`);
}
const Kue = {
  "&amp;": "&",
  "&quot;": '"',
  "&apos;": "'",
  "&#27;": "'",
  "&#34;": '"',
  "&#38;": "&",
  "&#39;": "'",
  "&#8211;": "",
  "&#8212;": "",
  "&#8216;": "",
  "&#8217;": "",
  "&#8220;": "",
  "&#8221;": "",
  "&#8230;": ""
}, Get = new RegExp(Object.keys(Kue).join("|"), "g");
function Gue(t) {
  return t.replace(Get, (e) => Kue[e]);
}
function Yet(t) {
  return t.replace(/[ \t]+$/gm, "").replace(/\n+$/, "");
}
function qet(t) {
  return Yet(Ket(Wet(t)));
}
const Xet = 5e3, Zet = 10 * 1024 * 1024;
function Qet(t, e) {
  t.registerExternalAssetHandler("file", async (n) => Jet(t, n, e)), t.registerExternalAssetHandler("url", async (n) => ttt(t, n, e)), t.registerExternalContentHandler("svg-text", async (n) => ntt(t, n)), t.registerExternalContentHandler("embed", (n) => rtt(t, n)), t.registerExternalContentHandler("files", async (n) => stt(t, n, e)), t.registerExternalContentHandler("file-replace", async (n) => ett(t, n, e)), t.registerExternalContentHandler("text", async (n) => ott(t, n)), t.registerExternalContentHandler("url", async (n) => itt(t, n, e)), t.registerExternalContentHandler("tldraw", async (n) => att(t, n)), t.registerExternalContentHandler("excalidraw", async (n) => ctt(t, n));
}
async function Jet(t, { file: e, assetId: n }, r) {
  n4(e, r) || tt(!1, "File checks failed");
  const o = await Zue(e, r, n), i = await t.uploadAsset(o, e);
  return o.props.src = i.src, i.meta && (o.meta = { ...o.meta, ...i.meta }), th.create(o);
}
async function ett(t, { file: e, shapeId: n, isImage: r }, s) {
  n4(e, s) || tt(!1, "File checks failed");
  const i = t.getShape(n);
  i || tt(!1, "Shape not found");
  const a = TJ(await e.arrayBuffer()), c = th.createId(a);
  t.createTemporaryAssetPreview(c, e);
  const l = await Yue(
    e,
    c,
    r,
    !r
    /* isVideo */
  );
  if (t.createAssets([l]), i.type === "image") {
    const u = i, f = u.props.crop;
    let p = l.props.w, g = l.props.h, y = u.x, m = u.y, v = f;
    if (f) {
      const b = GQe(
        u,
        l.props.w,
        l.props.h
      );
      v = b.crop, p = b.w, g = b.h, y = b.x, m = b.y;
    }
    t.updateShapes([
      {
        id: u.id,
        type: u.type,
        props: {
          assetId: c,
          crop: v,
          w: p,
          h: g
        },
        x: y,
        y: m
      }
    ]);
  } else i.type === "video" && t.updateShapes([
    {
      id: i.id,
      type: i.type,
      props: {
        assetId: c,
        w: l.props.w,
        h: l.props.h
      }
    }
  ]);
  const d = await t.getAssetForExternalContent({
    type: "file",
    file: e,
    assetId: c
  });
  return t.updateAssets([{ ...d, id: c }]), d;
}
async function ttt(t, { url: e }, { toasts: n, msg: r }) {
  var o, i, a, c, l;
  let s;
  try {
    const u = await (await qc(e, {
      method: "GET",
      mode: "no-cors"
    })).text(), f = new DOMParser().parseFromString(u, "text/html");
    s = {
      image: ((o = f.head.querySelector('meta[property="og:image"]')) == null ? void 0 : o.getAttribute("content")) ?? "",
      favicon: ((i = f.head.querySelector('link[rel="apple-touch-icon"]')) == null ? void 0 : i.getAttribute("href")) ?? ((a = f.head.querySelector('link[rel="icon"]')) == null ? void 0 : a.getAttribute("href")) ?? "",
      title: ((c = f.head.querySelector('meta[property="og:title"]')) == null ? void 0 : c.getAttribute("content")) ?? e,
      description: ((l = f.head.querySelector('meta[property="og:description"]')) == null ? void 0 : l.getAttribute("content")) ?? ""
    }, s.image.startsWith("http") || (s.image = new URL(s.image, e).href), s.favicon.startsWith("http") || (s.favicon = new URL(s.favicon, e).href);
  } catch (d) {
    console.error(d), n.addToast({
      title: r("assets.url.failed"),
      severity: "error"
    }), s = { image: "", favicon: "", title: "", description: "" };
  }
  return {
    id: th.createId(uF(e)),
    typeName: "asset",
    type: "bookmark",
    props: {
      src: e,
      description: s.description,
      image: s.image,
      favicon: s.favicon,
      title: s.title
    },
    meta: {}
  };
}
async function ntt(t, { point: e, text: n }) {
  const r = e ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.getViewportPageBounds().center), s = new DOMParser().parseFromString(n, "image/svg+xml").querySelector("svg");
  if (!s)
    throw new Error("No <svg/> element present");
  let o = parseFloat(s.getAttribute("width") || "0"), i = parseFloat(s.getAttribute("height") || "0");
  if (!(o && i)) {
    document.body.appendChild(s);
    const c = s.getBoundingClientRect();
    document.body.removeChild(s), o = c.width, i = c.height;
  }
  const a = await t.getAssetForExternalContent({
    type: "file",
    file: new File([n], "asset.svg", { type: "image/svg+xml" })
  });
  if (!a) throw Error("Could not create an asset");
  que(t, [a], r);
}
function rtt(t, { point: e, url: n, embed: r }) {
  const s = e ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.getViewportPageBounds().center), { width: o, height: i } = r, a = $n(), c = Ea(
    new I(s.x - (o || 450) / 2, s.y - (i || 450) / 2),
    t
  ), l = {
    id: a,
    type: "embed",
    x: c.x,
    y: c.y,
    props: {
      w: o,
      h: i,
      url: n
    }
  };
  t.canCreateShape(l) && t.createShape(l).select(a);
}
async function stt(t, { point: e, files: n }, r) {
  const { acceptedImageMimeTypes: s = nv, toasts: o, msg: i } = r;
  if (n.length > t.options.maxFilesAtOnce) {
    o.addToast({ title: i("assets.files.amount-too-big"), severity: "error" });
    return;
  }
  const a = e ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.getViewportPageBounds().center), c = new I(a.x, a.y), l = [], d = [];
  for (const u of n) {
    if (!n4(u, r)) continue;
    const p = await Zue(u, r);
    s.includes(u.type) && t.createTemporaryAssetPreview(p.id, u), l.push(p), d.push({ asset: p, file: u });
  }
  Promise.allSettled(
    d.map(async (u) => {
      try {
        const f = await t.getAssetForExternalContent({
          type: "file",
          file: u.file
        });
        if (!f)
          throw Error("Could not create an asset");
        t.updateAssets([{ ...f, id: u.asset.id }]);
      } catch (f) {
        o.addToast({
          title: i("assets.files.upload-failed"),
          severity: "error"
        }), console.error(f), t.deleteAssets([u.asset.id]);
        return;
      }
    })
  ), que(t, l, c);
}
async function ott(t, { point: e, text: n, html: r }) {
  const s = e ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.getViewportPageBounds().center), o = t.getShapeUtil("text").getDefaultProps(), i = qet(n), a = r ? Uet(t, r) : dc(i);
  let c, l, d, u = "middle";
  const f = r ?? i.replace(/\n/g, "<br>"), p = r ? a.content.length > 1 : i.split(`
`).length > 1, g = Wue(i);
  p && (u = p ? g ? "end" : "start" : "middle");
  const y = t.textMeasure.measureHtml(f, {
    ...Oo,
    fontFamily: Ff[o.font],
    fontSize: my[o.size],
    maxWidth: null
  }), m = Math.min(
    p ? t.getViewportPageBounds().width * 0.9 : 920,
    Math.max(200, t.getViewportPageBounds().width * 0.9)
  );
  if (y.w > m) {
    const x = t.textMeasure.measureHtml(f, {
      ...Oo,
      fontFamily: Ff[o.font],
      fontSize: my[o.size],
      maxWidth: m
    });
    c = x.w, l = x.h, d = !1, u = g ? "end" : "start";
  } else
    c = Math.max(y.w, 10), l = Math.max(y.h, 10), d = !0;
  s.y - l / 2 < t.getViewportPageBounds().minY + 40 && (s.y = t.getViewportPageBounds().minY + 40 + l / 2);
  const v = Ea(new I(s.x - c / 2, s.y - l / 2), t), b = $n();
  t.createShapes([
    {
      id: b,
      type: "text",
      x: v.x,
      y: v.y,
      props: {
        richText: a,
        // if the text has more than one line, align it to the left
        textAlign: u,
        autoSize: d,
        w: c
      }
    }
  ]);
}
async function itt(t, { point: e, url: n }, { toasts: r, msg: s }) {
  const o = t.getShapeUtil("embed"), i = o == null ? void 0 : o.getEmbedDefinition(n);
  if (i)
    return t.putExternalContent({
      type: "embed",
      url: i.url,
      point: e,
      embed: i.definition
    });
  const a = e ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.getViewportPageBounds().center), c = th.createId(uF(n)), l = ltt(t, n, a);
  let d = t.getAsset(c), u = !1;
  if (!d) {
    u = !0;
    try {
      const f = await t.getAssetForExternalContent({ type: "url", url: n });
      if (!f) throw Error("Could not create an asset");
      d = f;
    } catch {
      r.addToast({
        title: s("assets.url.failed"),
        severity: "error"
      });
      return;
    }
  }
  t.run(() => {
    u && t.createAssets([d]), t.updateShapes([
      {
        id: l.id,
        type: l.type,
        props: {
          assetId: d.id
        }
      }
    ]);
  });
}
async function att(t, { point: e, content: n }) {
  t.run(() => {
    const r = t.getSelectionPageBounds();
    t.markHistoryStoppingPoint("paste");
    for (const o of n.shapes)
      n.rootShapeIds.includes(o.id) && (o.isLocked = !1);
    t.putContentOntoCurrentPage(n, {
      point: e,
      select: !0
    });
    const s = t.getSelectionPageBounds();
    r && s && (r != null && r.collides(s)) && (t.updateInstanceState({ isChangingStyle: !0 }), t.timers.setTimeout(() => {
      t.updateInstanceState({ isChangingStyle: !1 });
    }, 150));
  });
}
async function ctt(t, { point: e, content: n }) {
  t.run(() => {
    QQe(t, n, e);
  });
}
async function Yue(t, e, n, r, s) {
  let o = t.type;
  t.type === "video/quicktime" && (o = "video/mp4");
  const i = n ? await ca.getImageSize(t) : await ca.getVideoSize(t), a = await ca.isAnimated(t) || r, c = {
    id: e,
    type: n ? "image" : "video",
    typeName: "asset",
    props: {
      name: t.name,
      src: "",
      w: i.w,
      h: i.h,
      fileSize: t.size,
      mimeType: o,
      isAnimated: a
    },
    meta: {}
  };
  if (s && isFinite(s)) {
    const l = { w: c.props.w, h: c.props.h }, d = ZQe(l, { w: s, h: s });
    l !== d && ca.isStaticImageType(t.type) && (c.props.w = d.w, c.props.h = d.h);
  }
  return c;
}
async function que(t, e, n) {
  if (!e.length) return [];
  const r = I.From(n), s = [];
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    switch (i.type) {
      case "image": {
        s.push({
          id: $n(),
          type: "image",
          x: r.x,
          y: r.y,
          opacity: 1,
          props: {
            assetId: i.id,
            w: i.props.w,
            h: i.props.h
          }
        }), r.x += i.props.w;
        break;
      }
      case "video":
        s.push({
          id: $n(),
          type: "video",
          x: r.x,
          y: r.y,
          opacity: 1,
          props: {
            assetId: i.id,
            w: i.props.w,
            h: i.props.h
          }
        }), r.x += i.props.w;
    }
  }
  return t.run(() => {
    const o = e.filter((i) => !t.getAsset(i.id));
    t.store.atomic(() => {
      t.canCreateShapes(s) && (o.length && t.createAssets(o), t.createShapes(s).select(...s.map((i) => i.id)), Xue(t, n));
    });
  }), s.map((o) => o.id);
}
function Xue(t, e) {
  const n = t.getViewportPageBounds();
  let r = t.getSelectionPageBounds();
  if (r) {
    const s = r.center.sub(e);
    t.updateShapes(
      t.getSelectedShapes().map((o) => {
        const i = t.getShapeParentTransform(o).decompose().rotation, a = I.Rot(s, -i);
        return {
          id: o.id,
          type: o.type,
          x: o.x - a.x,
          y: o.y - a.y
        };
      })
    );
  }
  if (r = t.getSelectionPageBounds(), r && t.getInstanceState().isGridMode) {
    const s = t.getDocumentSettings().gridSize, o = new I(r.minX, r.minY), i = o.clone().snapToGrid(s), a = I.Sub(o, i);
    t.updateShapes(
      t.getSelectedShapes().map((c) => {
        const l = { x: c.x - a.x, y: c.y - a.y };
        return {
          id: c.id,
          type: c.type,
          x: l.x,
          y: l.y
        };
      })
    );
  }
  r = t.getSelectionPageBounds(), r && !n.contains(r) && t.zoomToSelection({ animation: { duration: t.options.animationMediumMs } });
}
function ltt(t, e, n) {
  const r = {
    id: $n(),
    type: "bookmark",
    x: n.x - 150,
    y: n.y - 160,
    opacity: 1,
    props: {
      assetId: null,
      url: e
    }
  };
  return t.run(() => {
    t.createShape(r), t.getShape(r.id) && (t.select(r.id), Xue(t, n));
  }), t.getShape(r.id);
}
function n4(t, e) {
  const {
    acceptedImageMimeTypes: n = nv,
    acceptedVideoMimeTypes: r = bI,
    maxAssetSize: s = Zet,
    toasts: o,
    msg: i
  } = e, a = n.includes(t.type), c = r.includes(t.type);
  return !a && !c ? (o.addToast({
    title: i("assets.files.type-not-allowed"),
    severity: "error"
  }), !1) : t.size > s ? (o.addToast({
    title: i("assets.files.size-too-big"),
    severity: "error"
  }), !1) : t.type ? !0 : (o.addToast({
    title: i("assets.files.upload-failed"),
    severity: "error"
  }), console.error("No mime type"), !1);
}
async function Zue(t, e, n) {
  const {
    acceptedImageMimeTypes: r = nv,
    acceptedVideoMimeTypes: s = bI,
    maxImageDimension: o = Xet
  } = e, i = r.includes(t.type), a = s.includes(t.type), c = TJ(await t.arrayBuffer());
  return n ?? (n = th.createId(c)), await Yue(
    t,
    n,
    i,
    a,
    o
  );
}
var iD;
let dtt = (iD = class extends Xe {
  constructor() {
    super(...arguments);
    P(this, "isPrecise", !1);
    P(this, "isPreciseTimerId", null);
    P(this, "preciseTargetId", null);
  }
  onPointerMove() {
    this.update();
  }
  onPointerDown(n) {
    this.parent.transition("pointing", { ...n, isPrecise: this.isPrecise });
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 }), this.update();
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
  onExit() {
    B5(this.editor), this.isPreciseTimerId !== null && clearTimeout(this.isPreciseTimerId);
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp(n) {
    var r;
    if (this.update(), n.key === "Enter") {
      if (this.editor.getIsReadonly()) return null;
      const s = this.editor.getOnlySelectedShape();
      s && this.editor.getShapeUtil(s).canEdit(s) && (this.editor.setCurrentTool("select"), this.editor.setEditingShape(s.id), (r = this.editor.root.getCurrent()) == null || r.transition("editing_shape", {
        ...n,
        target: "shape",
        shape: s
      }));
    }
  }
  update() {
    const n = this.editor.getShapeUtil("arrow"), r = $k({
      editor: this.editor,
      pointInPageSpace: this.editor.inputs.currentPagePoint,
      arrow: void 0,
      isPrecise: this.isPrecise,
      currentBinding: void 0,
      oppositeBinding: void 0
    });
    r && r.target.id !== this.preciseTargetId ? (this.isPreciseTimerId !== null && clearTimeout(this.isPreciseTimerId), this.preciseTargetId = r.target.id, this.isPreciseTimerId = this.editor.timers.setTimeout(() => {
      this.isPrecise = !0, this.update();
    }, n.options.hoverPreciseTimeout)) : !r && this.preciseTargetId && (this.isPrecise = !1, this.preciseTargetId = null, this.isPreciseTimerId !== null && clearTimeout(this.isPreciseTimerId));
  }
}, P(iD, "id", "idle"), iD);
var aD;
let utt = (aD = class extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shape");
    P(this, "isPrecise", !1);
    P(this, "isPreciseTimerId", null);
    P(this, "markId", "");
  }
  onEnter(n) {
    if (this.markId = "", this.isPrecise = !!n.isPrecise, !$k({
      editor: this.editor,
      pointInPageSpace: this.editor.inputs.currentPagePoint,
      arrow: void 0,
      isPrecise: this.isPrecise,
      currentBinding: void 0,
      oppositeBinding: void 0
    }) && (this.createArrowShape(), !this.shape)) {
      this.cancel();
      return;
    }
    this.startPreciseTimeout();
  }
  onExit() {
    this.shape = void 0, B5(this.editor), this.clearPreciseTimeout();
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      if (this.shape || this.createArrowShape(), !this.shape) {
        this.cancel();
        return;
      }
      this.updateArrowShapeEndHandle(), this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        handle: { id: "end", type: "vertex", index: "a3", x: 0, y: 0 },
        isCreating: !0,
        creatingMarkId: this.markId || void 0,
        onInteractionEnd: "arrow"
      });
    }
  }
  onPointerUp() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.shape && this.editor.bailToMark(this.markId), this.parent.transition("idle");
  }
  createArrowShape() {
    var u;
    const { originPagePoint: n } = this.editor.inputs, r = $n();
    this.markId = this.editor.markHistoryStoppingPoint(`creating_arrow:${r}`);
    const s = Ea(n, this.editor);
    this.editor.createShape({
      id: r,
      type: "arrow",
      x: s.x,
      y: s.y,
      props: {
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const o = this.editor.getShape(r);
    if (!o) return;
    const i = this.editor.getShapeHandles(o);
    if (!i) throw Error("expected handles for arrow");
    const a = this.editor.getShapeUtil("arrow"), c = this.shape, l = i.find((f) => f.id === "start"), d = (u = a.onHandleDrag) == null ? void 0 : u.call(a, o, {
      handle: { ...l, x: 0, y: 0 },
      isPrecise: !0,
      initial: c
    });
    d && this.editor.updateShapes([d]), this.shape = this.editor.getShape(r), this.editor.select(r);
  }
  updateArrowShapeEndHandle() {
    var s, o;
    const n = this.shape;
    if (!n) throw Error("expected shape");
    const r = this.editor.getShapeHandles(n);
    if (!r) throw Error("expected handles for arrow");
    {
      const i = this.editor.getShapeUtil("arrow"), a = this.shape, c = r.find((d) => d.id === "start"), l = (s = i.onHandleDrag) == null ? void 0 : s.call(i, n, {
        handle: { ...c, x: 0, y: 0 },
        isPrecise: this.isPrecise,
        initial: a
      });
      l && this.editor.updateShapes([l]);
    }
    {
      const i = this.editor.getShapeUtil("arrow"), a = this.shape, c = this.editor.getPointInShapeSpace(n, this.editor.inputs.currentPagePoint), l = r.find((u) => u.id === "end"), d = (o = i.onHandleDrag) == null ? void 0 : o.call(i, this.editor.getShape(n), {
        handle: { ...l, x: c.x, y: c.y },
        isPrecise: !1,
        initial: a
      });
      d && this.editor.updateShapes([d]);
    }
    this.shape = this.editor.getShape(n.id);
  }
  startPreciseTimeout() {
    const n = this.editor.getShapeUtil("arrow");
    this.isPreciseTimerId = this.editor.timers.setTimeout(() => {
      this.getIsActive() && (this.isPrecise = !0);
    }, n.options.pointingPreciseTimeout);
  }
  clearPreciseTimeout() {
    this.isPreciseTimerId !== null && clearTimeout(this.isPreciseTimerId);
  }
}, P(aD, "id", "pointing"), aD);
class bR extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeType", "arrow");
  }
  static children() {
    return [dtt, utt];
  }
}
P(bR, "id", "arrow"), P(bR, "initial", "idle");
class r4 extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
    P(this, "initialShape");
    P(this, "shapeType", this.parent.id === "highlight" ? "highlight" : "draw");
    P(this, "util", this.editor.getShapeUtil(this.shapeType));
    P(this, "isPen", !1);
    P(this, "isPenOrStylus", !1);
    P(this, "segmentMode", "free");
    P(this, "didJustShiftClickToExtendPreviousShapeLine", !1);
    P(this, "pagePointWhereCurrentSegmentChanged", {});
    P(this, "pagePointWhereNextSegmentChanged", null);
    P(this, "lastRecordedPoint", {});
    P(this, "mergeNextPoint", !1);
    P(this, "currentLineLength", 0);
    P(this, "markId", null);
  }
  onEnter(n) {
    this.markId = null, this.info = n, this.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone(), this.startShape();
  }
  onPointerMove() {
    const { inputs: n } = this.editor;
    if (this.isPen && !n.isPen && this.markId) {
      this.editor.bailToMark(this.markId), this.startShape();
      return;
    }
    this.isPenOrStylus ? I.Dist(n.currentPagePoint, this.lastRecordedPoint) >= 1 / this.editor.getZoomLevel() ? (this.lastRecordedPoint = n.currentPagePoint.clone(), this.mergeNextPoint = !1) : this.mergeNextPoint = !0 : this.mergeNextPoint = !1, this.updateDrawingShape();
  }
  onKeyDown(n) {
    if (n.key === "Shift")
      switch (this.segmentMode) {
        case "free": {
          this.segmentMode = "starting_straight", this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_free":
          this.segmentMode = "starting_straight";
      }
    this.updateDrawingShape();
  }
  onKeyUp(n) {
    if (n.key === "Shift")
      switch (this.editor.snaps.clearIndicators(), this.segmentMode) {
        case "straight": {
          this.segmentMode = "starting_free", this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_straight": {
          this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
          break;
        }
      }
    this.updateDrawingShape();
  }
  onExit() {
    this.editor.snaps.clearIndicators(), this.pagePointWhereCurrentSegmentChanged = this.editor.inputs.currentPagePoint.clone();
  }
  canClose() {
    return this.shapeType !== "highlight";
  }
  getIsClosed(n, r, s) {
    if (!this.canClose()) return !1;
    const o = ys[r], i = n[0].points[0], a = n[n.length - 1], c = a.points[a.points.length - 1];
    return i !== c && this.currentLineLength > o * 4 * s && I.DistMin(i, c, o * 2 * s);
  }
  startShape() {
    const {
      inputs: { originPagePoint: n, isPen: r }
    } = this.editor;
    this.markId = this.editor.markHistoryStoppingPoint("draw start");
    const { z: s = 0.5 } = this.info.point;
    this.isPen = r, this.isPenOrStylus = r || s > 0 && s < 0.5 || s > 0.5 && s < 1;
    const o = this.isPenOrStylus ? s * 1.25 : 0.5;
    if (this.segmentMode = this.editor.inputs.shiftKey ? "straight" : "free", this.didJustShiftClickToExtendPreviousShapeLine = !1, this.lastRecordedPoint = n.clone(), this.initialShape) {
      const c = this.editor.getShape(this.initialShape.id);
      if (c && this.segmentMode === "straight") {
        this.didJustShiftClickToExtendPreviousShapeLine = !0;
        const l = Qs(c.props.segments);
        if (!l) throw Error("Expected a previous segment!");
        const d = Qs(l.points);
        if (!d) throw Error("Expected a previous point!");
        const { x: u, y: f } = this.editor.getPointInShapeSpace(c, n).toFixed(), p = {
          type: this.segmentMode,
          points: [
            {
              x: d.x,
              y: d.y,
              z: +o.toFixed(2)
            },
            {
              x: u,
              y: f,
              z: +o.toFixed(2)
            }
          ]
        }, g = we.applyToPoint(
          this.editor.getShapePageTransform(c.id),
          d
        );
        this.pagePointWhereCurrentSegmentChanged = g, this.pagePointWhereNextSegmentChanged = null;
        const y = [...c.props.segments, p];
        this.currentLineLength < ys[c.props.size] * 4 && (this.currentLineLength = this.getLineLength(y));
        const m = {
          id: c.id,
          type: this.shapeType,
          props: {
            segments: y
          }
        };
        this.canClose() && (m.props.isClosed = this.getIsClosed(
          y,
          c.props.size,
          c.props.scale
        )), this.editor.updateShapes([m]);
        return;
      }
    }
    this.pagePointWhereCurrentSegmentChanged = n.clone();
    const i = $n();
    if (this.editor.createShape({
      id: i,
      type: this.shapeType,
      x: n.x,
      y: n.y,
      props: {
        isPen: this.isPenOrStylus,
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,
        segments: [
          {
            type: this.segmentMode,
            points: [
              {
                x: 0,
                y: 0,
                z: +o.toFixed(2)
              }
            ]
          }
        ]
      }
    }), !this.editor.getShape(i)) {
      this.cancel();
      return;
    }
    this.currentLineLength = 0, this.initialShape = this.editor.getShape(i);
  }
  updateDrawingShape() {
    const { initialShape: n } = this, { inputs: r } = this.editor;
    if (!n) return;
    const {
      id: s,
      props: { size: o, scale: i }
    } = n, a = this.editor.getShape(s);
    if (!a) return;
    const { segments: c } = a.props, { x: l, y: d, z: u } = this.editor.getPointInShapeSpace(a, r.currentPagePoint).toFixed(), f = this.isPenOrStylus ? +(r.currentPagePoint.z * 1.25).toFixed(2) : 0.5, p = { x: l, y: d, z: f };
    switch (this.segmentMode) {
      case "starting_straight": {
        const { pagePointWhereNextSegmentChanged: g } = this;
        if (g === null)
          throw Error("We should have a point where the segment changed");
        if (I.Dist2(g, r.currentPagePoint) > this.editor.options.dragDistanceSquared) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "straight";
          const m = Qs(c);
          if (!m) throw Error("Expected a previous segment!");
          const v = Qs(m.points);
          if (!v) throw Error("Expected a previous last point!");
          let b;
          const x = this.editor.getPointInShapeSpace(a, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson();
          if (m.type === "straight") {
            this.currentLineLength += I.Dist(v, x), b = {
              type: "straight",
              points: [{ ...v }, x]
            };
            const S = this.editor.getShapePageTransform(a);
            this.pagePointWhereCurrentSegmentChanged = we.applyToPoint(S, v);
          } else
            b = {
              type: "straight",
              points: [x, p]
            };
          const w = {
            id: s,
            type: this.shapeType,
            props: {
              segments: [...c, b]
            }
          };
          this.canClose() && (w.props.isClosed = this.getIsClosed(
            c,
            o,
            i
          )), this.editor.updateShapes([w]);
        }
        break;
      }
      case "starting_free": {
        const { pagePointWhereNextSegmentChanged: g } = this;
        if (g === null)
          throw Error("We should have a point where the segment changed");
        if (I.Dist2(g, r.currentPagePoint) > this.editor.options.dragDistanceSquared) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
          const m = c.slice(), v = m[m.length - 1], b = Qs(v.points);
          if (!b)
            throw Error("No previous point!");
          const x = {
            type: "free",
            points: [
              ...I.PointsBetween(b, p, 6).map((C) => ({
                x: Nc(C.x),
                y: Nc(C.y),
                z: Nc(C.z)
              }))
            ]
          }, w = [...m, x];
          this.currentLineLength < ys[a.props.size] * 4 && (this.currentLineLength = this.getLineLength(w));
          const S = {
            id: s,
            type: this.shapeType,
            props: {
              segments: w
            }
          };
          this.canClose() && (S.props.isClosed = this.getIsClosed(
            w,
            o,
            i
          )), this.editor.updateShapes([S]);
        }
        break;
      }
      case "straight": {
        const g = c.slice(), y = g[g.length - 1], { pagePointWhereCurrentSegmentChanged: m } = this, { ctrlKey: v, currentPagePoint: b } = this.editor.inputs;
        if (!m)
          throw Error("We should have a point where the segment changed");
        let x, w = !1;
        this.didJustShiftClickToExtendPreviousShapeLine ? this.editor.inputs.isDragging && (w = !v, this.didJustShiftClickToExtendPreviousShapeLine = !1) : w = !v;
        let S = this.editor.getPointInShapeSpace(a, b).toFixed().toJson(), C = !1, _;
        if ((this.editor.user.getIsSnapMode() ? !v : v) && g.length > 2) {
          let N, O = 8 / this.editor.getZoomLevel();
          for (let D = 0, k = c.length - 2; D < k; D++) {
            const A = c[D];
            if (!A) break;
            if (A.type === "free") continue;
            const R = A.points[0], j = Qs(A.points);
            if (!(R && j)) continue;
            const $ = I.NearestPointOnLineSegment(
              R,
              j,
              S
            );
            if (I.DistMin($, S, O)) {
              N = $.toFixed().toJson(), O = I.Dist($, S), _ = A;
              break;
            }
          }
          N && (C = !0, S = N);
        }
        if (C && _) {
          const N = this.editor.getShapePageTransform(a), O = _.points[0], D = Qs(_.points);
          if (!D) throw Error("Expected a last point!");
          const k = we.applyToPoint(N, O), A = we.applyToPoint(N, D), R = we.applyToPoint(N, S);
          this.editor.snaps.setIndicators([
            {
              id: bn(),
              type: "points",
              points: [k, R, A]
            }
          ]);
        } else {
          if (this.editor.snaps.clearIndicators(), w) {
            const N = I.Angle(m, b), D = $E(N, 24) - N;
            x = I.RotWith(
              b,
              m,
              D
            );
          } else
            x = b;
          S = this.editor.getPointInShapeSpace(a, x).toFixed().toJson();
        }
        this.currentLineLength += I.Dist(y.points[0], S), g[g.length - 1] = {
          ...y,
          type: "straight",
          points: [y.points[0], S]
        };
        const M = {
          id: s,
          type: this.shapeType,
          props: {
            segments: g
          }
        };
        this.canClose() && (M.props.isClosed = this.getIsClosed(
          c,
          o,
          i
        )), this.editor.updateShapes([M]);
        break;
      }
      case "free": {
        const g = c.slice(), y = g[g.length - 1], m = [...y.points];
        if (m.length && this.mergeNextPoint) {
          const { z: b } = m[m.length - 1];
          m[m.length - 1] = {
            x: p.x,
            y: p.y,
            z: b ? Math.max(b, p.z) : p.z
          };
        } else
          this.currentLineLength += I.Dist(m[m.length - 1], p), m.push(p);
        g[g.length - 1] = {
          ...y,
          points: m
        }, this.currentLineLength < ys[a.props.size] * 4 && (this.currentLineLength = this.getLineLength(g));
        const v = {
          id: s,
          type: this.shapeType,
          props: {
            segments: g
          }
        };
        if (this.canClose() && (v.props.isClosed = this.getIsClosed(
          g,
          o,
          i
        )), this.editor.updateShapes([v]), m.length > this.util.options.maxPointsPerShape) {
          this.editor.updateShapes([{ id: s, type: this.shapeType, props: { isComplete: !0 } }]);
          const b = $n(), x = this.editor.getShape(s).props;
          if (!this.editor.canCreateShapes([b])) return this.cancel();
          this.editor.createShape({
            id: b,
            type: this.shapeType,
            x: Nc(r.currentPagePoint.x),
            y: Nc(r.currentPagePoint.y),
            props: {
              isPen: this.isPenOrStylus,
              scale: x.scale,
              segments: [
                {
                  type: "free",
                  points: [{ x: 0, y: 0, z: this.isPenOrStylus ? +(u * 1.25).toFixed() : 0.5 }]
                }
              ]
            }
          });
          const w = this.editor.getShape(b);
          if (!w)
            return this.cancel();
          this.initialShape = mr(w), this.mergeNextPoint = !1, this.lastRecordedPoint = r.currentPagePoint.clone(), this.currentLineLength = 0;
        }
        break;
      }
    }
  }
  getLineLength(n) {
    let r = 0;
    for (const s of n)
      for (let o = 0; o < s.points.length - 1; o++) {
        const i = s.points[o], a = s.points[o + 1];
        r += I.Dist2(a, i);
      }
    return Math.sqrt(r);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.editor.inputs.isDragging || (this.markId && this.editor.bailToMark(this.markId), this.cancel());
  }
  complete() {
    const { initialShape: n } = this;
    n && (this.editor.updateShapes([
      { id: n.id, type: n.type, props: { isComplete: !0 } }
    ]), this.parent.transition("idle"));
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
P(r4, "id", "drawing");
var cD;
let Que = (cD = class extends Xe {
  onPointerDown(e) {
    this.parent.transition("drawing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, P(cD, "id", "idle"), cD);
class Yb extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeType", "draw");
  }
  static children() {
    return [Que, r4];
  }
  onExit() {
    const n = this.children.drawing;
    n.initialShape = void 0;
  }
}
P(Yb, "id", "draw"), P(Yb, "initial", "idle"), P(Yb, "isLockable", !1), P(Yb, "useCoalescedEvents", !0);
class xR extends wj {
  constructor() {
    super(...arguments);
    P(this, "shapeType", "frame");
  }
  onCreate(n) {
    if (!n) return;
    const r = this.editor.getShapePageBounds(n), s = [], o = this.editor.getShapeAncestors(n).map((i) => i.id);
    this.editor.getSortedChildIdsForParent(n.parentId).map((i) => {
      const a = this.editor.getShape(i);
      if (!a || a.id === n.id || a.isLocked) return;
      const c = this.editor.getShapePageBounds(a);
      c && r.contains(c) && ftt(a, o, n) && s.push(a.id);
    }), this.editor.reparentShapes(s, n.id), this.editor.getInstanceState().isToolLocked ? this.editor.setCurrentTool("frame") : this.editor.setCurrentTool("select.idle");
  }
}
P(xR, "id", "frame"), P(xR, "initial", "idle");
function ftt(t, e, n) {
  return e.includes(t.id) ? !1 : t.parentId === n.parentId;
}
var lD;
let htt = (lD = class extends Xe {
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onKeyUp(e) {
    var n;
    if (e.key === "Enter") {
      if (this.editor.getIsReadonly()) return null;
      const r = this.editor.getOnlySelectedShape();
      r && this.editor.getShapeUtil(r).canEdit(r) && (this.editor.setCurrentTool("select"), this.editor.setEditingShape(r.id), (n = this.editor.root.getCurrent()) == null || n.transition("editing_shape", {
        ...e,
        target: "shape",
        shape: r
      }));
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, P(lD, "id", "idle"), lD);
var dD;
let ptt = (dD = class extends Xe {
  onPointerUp() {
    this.complete();
  }
  onPointerMove(e) {
    if (this.editor.inputs.isDragging) {
      const { originPagePoint: n } = this.editor.inputs, r = $n(), s = this.editor.markHistoryStoppingPoint(`creating_geo:${r}`), o = Ea(n, this.editor);
      if (this.editor.createShapes([
        {
          id: r,
          type: "geo",
          x: o.x,
          y: o.y,
          props: {
            w: 1,
            h: 1,
            geo: this.editor.getStyleForNextShape(Hc),
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]).select(r), !this.editor.getShape(r)) {
        this.cancel();
        return;
      }
      this.editor.setCurrentTool("select.resizing", {
        ...e,
        target: "selection",
        handle: "bottom_right",
        isCreating: !0,
        creatingMarkId: s,
        creationCursorOffset: { x: 1, y: 1 },
        onInteractionEnd: "geo"
      });
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { originPagePoint: e } = this.editor.inputs, n = $n();
    this.editor.markHistoryStoppingPoint(`creating_geo:${n}`);
    const r = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1, s = this.editor.getStyleForNextShape(Hc), o = s === "star" ? { w: 200, h: 190 } : s === "cloud" ? { w: 300, h: 180 } : { w: 200, h: 200 };
    this.editor.createShapes([
      {
        id: n,
        type: "geo",
        x: e.x,
        y: e.y,
        props: {
          geo: this.editor.getStyleForNextShape(Hc),
          scale: r,
          ...o
        }
      }
    ]);
    const i = this.editor.getShape(n);
    if (!i) {
      this.cancel();
      return;
    }
    const { w: a, h: c } = i.props, l = new I(a / 2, c / 2).mul(r), d = this.editor.getShapeParentTransform(i);
    d && l.rot(-d.rotation());
    const u = Ea(new I(i.x - l.x, i.y - l.y), this.editor);
    this.editor.select(n), this.editor.updateShape({
      id: i.id,
      type: "geo",
      x: u.x,
      y: u.y,
      props: {
        geo: this.editor.getStyleForNextShape(Hc),
        w: a * r,
        h: c * r
      }
    }), this.editor.getInstanceState().isToolLocked ? this.parent.transition("idle") : this.editor.setCurrentTool("select", {});
  }
  cancel() {
    this.parent.transition("idle");
  }
}, P(dD, "id", "pointing"), dD);
class wR extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeType", "geo");
  }
  static children() {
    return [htt, ptt];
  }
}
P(wR, "id", "geo"), P(wR, "initial", "idle");
class qb extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeType", "highlight");
  }
  static children() {
    return [Que, r4];
  }
  onExit() {
    const n = this.children.drawing;
    n.initialShape = void 0;
  }
}
P(qb, "id", "highlight"), P(qb, "initial", "idle"), P(qb, "useCoalescedEvents", !0), P(qb, "isLockable", !1);
var uD;
let gtt = (uD = class extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeId", "");
  }
  onEnter(n) {
    this.shapeId = n.shapeId, this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onPointerDown() {
    this.parent.transition("pointing", { shapeId: this.shapeId });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, P(uD, "id", "idle"), uD);
const WV = 2;
var fD;
let mtt = (fD = class extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shape", {});
    P(this, "markId");
  }
  onEnter(n) {
    const { inputs: r } = this.editor, { currentPagePoint: s } = r;
    this.markId = void 0;
    const o = n.shapeId && this.editor.getShape(n.shapeId);
    if (o && r.shiftKey) {
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${o.id}`), this.shape = o;
      const i = this.editor.getShapeHandles(this.shape);
      if (!i) return;
      const a = i.filter((g) => g.type === "vertex").sort(Js), c = a[a.length - 1], l = a[a.length - 2], d = we.applyToPoint(
        this.editor.getShapeParentTransform(this.shape),
        new I(this.shape.x, this.shape.y)
      ), u = I.Sub(s, d).addXY(0.1, 0.1), f = Ea(u, this.editor), p = mr(this.shape.props.points);
      if (I.DistMin(c, l, WV) || I.DistMin(f, c, WV))
        p[c.id] = {
          id: c.id,
          index: c.index,
          x: f.x,
          y: f.y
        };
      else {
        const g = Bc(c.index);
        p[g] = {
          id: g,
          index: g,
          x: f.x,
          y: f.y
        };
      }
      this.editor.updateShapes([
        {
          id: this.shape.id,
          type: this.shape.type,
          props: {
            points: p
          }
        }
      ]);
    } else {
      const i = $n();
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${i}`);
      const a = Ea(s, this.editor);
      if (this.editor.createShapes([
        {
          id: i,
          type: "line",
          x: a.x,
          y: a.y,
          props: {
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]), !this.editor.getShape(i)) {
        this.cancel();
        return;
      }
      this.editor.select(i), this.shape = this.editor.getShape(i);
    }
  }
  onPointerMove() {
    if (this.shape && this.editor.inputs.isDragging) {
      const n = this.editor.getShapeHandles(this.shape);
      if (!n)
        throw this.markId && this.editor.bailToMark(this.markId), Error("No handles found");
      const r = Qs(n);
      this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        isCreating: !0,
        creatingMarkId: this.markId,
        // remove the offset that we added to the handle when we created it
        handle: { ...r, x: r.x - 0.1, y: r.y - 0.1 },
        onInteractionEnd: "line"
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle"), this.markId && this.editor.bailToMark(this.markId), this.editor.snaps.clearIndicators();
  }
  complete() {
    this.parent.transition("idle", { shapeId: this.shape.id }), this.editor.snaps.clearIndicators();
  }
  cancel() {
    this.markId && this.editor.bailToMark(this.markId), this.parent.transition("idle", { shapeId: this.shape.id }), this.editor.snaps.clearIndicators();
  }
}, P(fD, "id", "pointing"), fD);
class SR extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeType", "line");
  }
  static children() {
    return [gtt, mtt];
  }
}
P(SR, "id", "line"), P(SR, "initial", "idle");
var hD;
let ytt = (hD = class extends Xe {
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, P(hD, "id", "idle"), hD);
const vtt = 0, jn = 200, Bk = new I(jn / 2, jn / 2), Jue = 10, btt = (t) => [
  [
    ["a1"],
    new I(jn * 0.5, jn * -0.5 - t.options.adjacentShapeMargin)
  ],
  // t
  [
    ["a2"],
    new I(jn * 1.5 + t.options.adjacentShapeMargin, jn * 0.5)
  ],
  // r
  [
    ["a3"],
    new I(jn * 0.5, jn * 1.5 + t.options.adjacentShapeMargin)
  ],
  // b
  [
    ["a4"],
    new I(jn * -0.5 - t.options.adjacentShapeMargin, jn * 0.5)
  ]
  // l
];
function xtt(t, e) {
  if (e === 1) return btt(t);
  const n = jn * e, r = t.options.adjacentShapeMargin * e;
  return [
    [["a1"], new I(n * 0.5, n * -0.5 - r)],
    // t
    [["a2"], new I(n * 1.5 + r, n * 0.5)],
    // r
    [["a3"], new I(n * 0.5, n * 1.5 + r)],
    // b
    [["a4"], new I(n * -0.5 - r, n * 0.5)]
    // l
  ];
}
function efe(t, e, n, r, s, o) {
  return Object.fromEntries(
    xtt(t, o).map(([i, a], c) => {
      const l = a.clone();
      return c === 0 && s ? l.y -= s : c === 2 && r && (l.y += r), [i, l.rot(n).add(e)];
    })
  );
}
function tfe(t, e, n, r) {
  const s = new Set(t.getSelectedShapeIds()), o = (jn + t.options.adjacentShapeMargin + r) ** 2, i = /* @__PURE__ */ new Map(), a = [];
  for (const d of t.getCurrentPageShapes()) {
    if (!t.isShapeOfType(d, "note") || n !== d.props.scale || s.has(d.id))
      continue;
    const u = t.getShapePageTransform(d.id);
    e === u.rotation() && (i.set(d, t.getShapePageBounds(d).center), a.push(
      ...Object.values(
        efe(
          t,
          u.point(),
          e,
          d.props.growY,
          r,
          n
        )
      )
    ));
  }
  const c = a.length;
  let l;
  for (const [d, u] of i)
    for (let f = 0; f < c; f++)
      l = a[f], l && (I.Dist2(u, l) > o || t.isPointInShape(d, l) && (a[f] = void 0));
  return mt(a);
}
function nfe(t, e, n, r, s = !1) {
  let o;
  const i = t.getCurrentPageShapesSorted(), a = (jn + t.options.adjacentShapeMargin ** 2) ** e.props.scale;
  for (let c = i.length - 1; c >= 0; c--) {
    const l = i[c];
    if (l.type === "note" && l.id !== e.id) {
      const d = t.getShapePageBounds(l);
      if (d && I.Dist2(d.center, n) < a && t.isPointInShape(l, n)) {
        o = l;
        break;
      }
    }
  }
  if (t.complete(), !o || s) {
    t.markHistoryStoppingPoint("creating note shape");
    const c = $n();
    t.createShape({
      id: c,
      type: "note",
      x: n.x,
      y: n.y,
      rotation: r,
      opacity: e.opacity,
      props: {
        // Use the props of the shape we're cloning
        ...e.props,
        richText: dc(""),
        growY: 0,
        fontSizeAdjustment: 0,
        url: ""
      }
    });
    const l = t.getShape(c);
    if (!l) return;
    const d = t.getPointInParentSpace(
      l,
      I.Sub(
        n,
        I.Rot(Bk.clone().mul(l.props.scale), r)
      )
    );
    t.updateShape({
      id: c,
      type: "note",
      x: d.x,
      y: d.y
    }), o = t.getShape(c);
  }
  return t.zoomToSelectionIfOffscreen(16, {
    animation: {
      duration: t.options.animationMediumMs
    },
    inset: 0
  }), o;
}
var pD;
let wtt = (pD = class extends Xe {
  constructor() {
    super(...arguments);
    P(this, "dragged", !1);
    P(this, "info", {});
    P(this, "markId", "");
    P(this, "shape", {});
  }
  onEnter() {
    const { editor: n } = this, r = $n();
    this.markId = n.markHistoryStoppingPoint(`creating_note:${r}`);
    const s = this.editor.inputs.originPagePoint.clone(), o = Stt(
      this.editor,
      s,
      this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
    );
    o && s.sub(o);
    const i = Ctt(this.editor, r, s);
    i ? this.shape = i : this.cancel();
  }
  onPointerMove(n) {
    this.editor.inputs.isDragging && this.editor.setCurrentTool("select.translating", {
      ...n,
      target: "shape",
      shape: this.shape,
      onInteractionEnd: "note",
      isCreating: !0,
      creatingMarkId: this.markId,
      onCreate: () => {
        this.editor.setEditingShape(this.shape.id), this.editor.setCurrentTool("select.editing_shape");
      }
    });
  }
  onPointerUp() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    this.editor.getInstanceState().isToolLocked ? this.parent.transition("idle") : (this.editor.setEditingShape(this.shape.id), this.editor.setCurrentTool("select.editing_shape", {
      ...this.info,
      target: "shape",
      shape: this.shape
    }));
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.parent.transition("idle", this.info);
  }
}, P(pD, "id", "pointing"), pD);
function Stt(t, e, n) {
  let r = Jue / t.getZoomLevel(), s;
  for (const o of tfe(t, 0, n, 0)) {
    const i = I.Sub(e, o), a = i.len();
    a < r && (r = a, s = i);
  }
  return s;
}
function Ctt(t, e, n) {
  t.createShape({
    id: e,
    type: "note",
    x: n.x,
    y: n.y,
    props: {
      scale: t.user.getIsDynamicResizeMode() ? 1 / t.getZoomLevel() : 1
    }
  });
  const r = t.getShape(e);
  if (!r) return;
  t.select(e);
  const s = t.getShapeGeometry(r).bounds, o = Ea(
    new I(r.x - s.width / 2, r.y - s.height / 2),
    t
  );
  return t.updateShapes([
    {
      id: e,
      type: "note",
      x: o.x,
      y: o.y
    }
  ]), t.getShape(e);
}
class CR extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeType", "note");
  }
  static children() {
    return [ytt, wtt];
  }
}
P(CR, "id", "note"), P(CR, "initial", "idle");
function _tt(t) {
  const e = t.getShapeAtPoint(t.inputs.currentPagePoint, {
    hitInside: !1,
    hitLabels: !1,
    margin: t.options.hitTestMargin / t.getZoomLevel(),
    renderingOnly: !0
  });
  if (!e) return t.setHoveredShape(null);
  let n;
  const r = t.getOutermostSelectableShape(e);
  return r === e || r.id === t.getFocusedGroupId() || t.getSelectedShapeIds().includes(r.id) ? n = e : n = r, t.setHoveredShape(n.id);
}
const Kd = bJ(
  _tt,
  process.env.NODE_ENV === "test" ? 0 : 32
);
var gD;
let Ett = (gD = class extends Xe {
  onPointerMove(e) {
    switch (e.target) {
      case "shape":
      case "canvas":
        Kd(this.editor);
    }
  }
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onExit() {
    Kd.cancel();
  }
  onKeyDown(e) {
    var n;
    if (e.key === "Enter") {
      if (this.editor.getIsReadonly()) return null;
      const r = this.editor.getOnlySelectedShape();
      r && this.editor.getShapeUtil(r).canEdit(r) && (this.editor.setCurrentTool("select"), this.editor.setEditingShape(r.id), (n = this.editor.root.getCurrent()) == null || n.transition("editing_shape", {
        ...e,
        target: "shape",
        shape: r
      }));
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, P(gD, "id", "idle"), gD);
var mD;
let Ttt = (mD = class extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shape");
    P(this, "markId", "");
    P(this, "enterTime", 0);
  }
  onEnter() {
    this.enterTime = Date.now();
  }
  onExit() {
    this.editor.setHintingShapes([]);
  }
  onPointerMove(n) {
    if (Date.now() - this.enterTime < 150) return;
    const { editor: r } = this, { isPointing: s } = r.inputs;
    if (!s) return;
    const { originPagePoint: o, currentPagePoint: i } = r.inputs, a = Math.abs(o.x - i.x), l = Math.sqrt(
      r.getInstanceState().isCoarsePointer ? r.options.coarseDragDistanceSquared : r.options.dragDistanceSquared
    ) * 6 / r.getZoomLevel();
    if (a > l) {
      const d = $n();
      this.markId = r.markHistoryStoppingPoint(`creating_text:${d}`);
      const u = this.createTextShape(d, o, !1, a);
      if (!u) {
        this.cancel();
        return;
      }
      this.shape = r.getShape(u), r.select(d);
      const f = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1;
      r.setCurrentTool("select.resizing", {
        ...n,
        target: "selection",
        handle: "right",
        isCreating: !0,
        creatingMarkId: this.markId,
        // Make sure the cursor offset takes into account how far we've already dragged
        creationCursorOffset: { x: a * f, y: 1 },
        onInteractionEnd: "text",
        onCreate: () => {
          r.setEditingShape(u.id);
        }
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.editor.markHistoryStoppingPoint("creating text shape");
    const n = $n(), { originPagePoint: r } = this.editor.inputs;
    this.createTextShape(n, r, !0, 20) && (this.editor.select(n), this.editor.setEditingShape(n));
  }
  cancel() {
    this.parent.transition("idle"), this.editor.bailToMark(this.markId);
  }
  createTextShape(n, r, s, o) {
    this.editor.createShape({
      id: n,
      type: "text",
      x: r.x,
      y: r.y,
      props: {
        richText: dc(""),
        autoSize: s,
        w: o,
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const i = this.editor.getShape(n);
    if (!i) {
      this.cancel();
      return;
    }
    const a = this.editor.getShapePageBounds(i), c = new I();
    if (s)
      switch (i.props.textAlign) {
        case "start": {
          c.x = 0;
          break;
        }
        case "middle": {
          c.x = -a.width / 2;
          break;
        }
        case "end": {
          c.x = -a.width;
          break;
        }
      }
    else
      c.x = 0;
    if (c.y = -a.height / 2, ei(i.parentId)) {
      const u = this.editor.getShapeParentTransform(i);
      c.rot(-u.rotation());
    }
    const l = i.x + c.x, d = i.y + c.y;
    if (this.editor.getInstanceState().isGridMode) {
      const u = new I(l, d), f = Ea(u, this.editor), p = I.Sub(u, f);
      this.editor.updateShape({
        ...i,
        x: l - p.x,
        y: d - p.y
      });
    } else
      this.editor.updateShape({
        ...i,
        x: l,
        y: d
      });
    return i;
  }
}, P(mD, "id", "pointing"), mD);
class _R extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeType", "text");
  }
  static children() {
    return [Ett, Ttt];
  }
}
P(_R, "id", "text"), P(_R, "initial", "idle");
const Ptt = [
  _R,
  Yb,
  wR,
  CR,
  SR,
  xR,
  bR,
  qb
], Itt = B.forwardRef(function({
  isEditing: e,
  text: n,
  handleFocus: r,
  handleChange: s,
  handleKeyDown: o,
  handlePaste: i,
  handleBlur: a,
  handleInputPointerDown: c,
  handleDoubleClick: l
}, d) {
  const u = (f) => {
    s({ plaintext: f.target.value });
  };
  return /* @__PURE__ */ h.jsx(
    "textarea",
    {
      ref: d,
      className: "tl-text tl-text-input",
      name: "text",
      tabIndex: -1,
      disabled: !e,
      readOnly: !e,
      autoComplete: "off",
      autoCapitalize: "off",
      autoCorrect: "off",
      autoSave: "off",
      placeholder: "",
      spellCheck: "true",
      wrap: "off",
      dir: "auto",
      defaultValue: n,
      onFocus: r,
      onChange: u,
      onKeyDown: (f) => o(f.nativeEvent),
      onBlur: a,
      onTouchEnd: cr,
      onContextMenu: e ? cr : void 0,
      onPointerDown: c,
      onPaste: i,
      onDoubleClick: l,
      onDragStart: xt
    }
  );
});
function ktt(t, e, n, r) {
  if ((t === "start-legacy" || t === "end-legacy") && n.length !== 0) {
    const s = _e.From(n[0].box);
    for (const { box: o } of n)
      s.union(o);
    if (t === "start-legacy")
      return (r - 2 * e - s.width) / 2;
    if (t === "end-legacy")
      return -(r - 2 * e - s.width) / 2;
  }
}
function rfe(t) {
  return t === "start-legacy" || t === "middle-legacy" || t === "end-legacy";
}
function Att(t, e, n) {
  const r = sfe(t), s = r.isEditing, o = ie(), i = fe(null), a = (n || "").trim().length === 0;
  me(() => {
    function d(u) {
      var f, p;
      u.shapeId === t && ((p = (f = i.current) == null ? void 0 : f.select) == null || p.call(f));
    }
    return o.on("select-all-text", d), () => {
      o.off("select-all-text", d);
    };
  }, [o, t, s]), me(() => {
    var d, u, f, p;
    s && (document.activeElement !== i.current && ((d = i.current) == null || d.focus()), o.getInstanceState().isCoarsePointer && ((u = i.current) == null || u.select()), dn.isSafari && ((f = i.current) == null || f.blur(), (p = i.current) == null || p.focus()));
  }, [o, s]);
  const c = re(
    (d) => {
      if (o.getEditingShapeId() === t)
        switch (d.key) {
          case "Enter": {
            (d.ctrlKey || d.metaKey) && o.complete();
            break;
          }
        }
    },
    [o, t]
  ), l = re(
    ({ plaintext: d }) => {
      if (o.getEditingShapeId() !== t) return;
      const u = WT.normalizeText(d || "");
      o.updateShape({
        id: t,
        type: e,
        props: { text: u }
      });
    },
    [o, t, e]
  );
  return {
    rInput: i,
    handleKeyDown: c,
    handleChange: l,
    isEmpty: a,
    ...r
  };
}
function s4(t, e) {
  return le(
    "isReadyForEditing",
    () => {
      const n = t.getEditingShapeId();
      return (
        // something's being editing... and either it's this shape OR this shape is hovered
        n !== null && (n === e || t.getHoveredShapeId() === e)
      );
    },
    [t, e]
  );
}
function sfe(t) {
  const e = ie(), n = le("isEditing", () => e.getEditingShapeId() === t, [e]), r = s4(e, t), s = re(
    (i) => {
      e.dispatch({
        ...la(i),
        type: "pointer",
        name: "pointer_down",
        target: "shape",
        shape: e.getShape(t)
      }), cr(i);
    },
    [e, t]
  ), o = re(
    (i) => {
      if (e.getEditingShapeId() === t && i.clipboardData) {
        const a = i.clipboardData.getData("text/html");
        a && a.includes("<div data-tldraw") && xt(i);
      }
    },
    [e, t]
  );
  return {
    handleFocus: nw,
    handleBlur: nw,
    handleInputPointerDown: s,
    handleDoubleClick: cr,
    handlePaste: o,
    isEditing: n,
    isReadyForEditing: r
  };
}
const Mtt = B.memo(function({
  shapeId: e,
  type: n,
  text: r,
  labelColor: s,
  font: o,
  fontSize: i,
  lineHeight: a,
  align: c,
  verticalAlign: l,
  wrap: d,
  isSelected: u,
  padding: f = 0,
  onKeyDown: p,
  classNamePrefix: g,
  style: y,
  textWidth: m,
  textHeight: v
}) {
  const { rInput: b, isEmpty: x, isEditing: w, isReadyForEditing: S, ...C } = Att(e, n, r), _ = WT.normalizeTextForDom(r || ""), E = _.length > 0, M = rfe(c);
  if (!w && !E)
    return null;
  const N = g || "tl-text";
  return /* @__PURE__ */ h.jsx(
    "div",
    {
      className: `${N}-label tl-text-wrapper tl-plain-text-wrapper`,
      "aria-hidden": !w,
      "data-font": o,
      "data-align": c,
      "data-hastext": !x,
      "data-isediting": w,
      "data-is-ready-for-editing": S,
      "data-textwrap": !!d,
      "data-isselected": u,
      style: {
        justifyContent: c === "middle" || M ? "center" : c,
        alignItems: l === "middle" ? "center" : l,
        padding: f,
        ...y
      },
      children: /* @__PURE__ */ h.jsxs(
        "div",
        {
          className: `${N}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize: i,
            lineHeight: a.toString(),
            minHeight: Math.floor(i * a) + "px",
            minWidth: Math.ceil(m || 0),
            color: s,
            width: m ? Math.ceil(m) : void 0,
            height: v ? Math.ceil(v) : void 0
          },
          children: [
            /* @__PURE__ */ h.jsx("div", { className: `${N} tl-text tl-text-content`, dir: "auto", children: _.split(`
`).map((O, D) => /* @__PURE__ */ h.jsx("div", { dir: "auto", children: O }, D)) }),
            (S || u) && /* @__PURE__ */ h.jsx(
              Itt,
              {
                ref: b,
                text: r,
                isEditing: w,
                shapeId: e,
                ...C,
                handleKeyDown: p ?? C.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});
function mc() {
  return mu({ isDarkMode: rS() });
}
function o4(t) {
  return {
    key: `${ou.id}:${t}`,
    async getElement() {
      return t !== "pattern" ? null : /* @__PURE__ */ h.jsx(Ott, {});
    }
  };
}
function Ott() {
  const t = a4(), e = gg(), n = mc(), r = 8 / 12;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs("mask", { id: e, children: [
      /* @__PURE__ */ h.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: "white" }),
      /* @__PURE__ */ h.jsxs("g", { strokeLinecap: "round", stroke: "black", children: [
        /* @__PURE__ */ h.jsx("line", { x1: r * 1, y1: r * 3, x2: r * 3, y2: r * 1 }),
        /* @__PURE__ */ h.jsx("line", { x1: r * 5, y1: r * 7, x2: r * 7, y2: r * 5 }),
        /* @__PURE__ */ h.jsx("line", { x1: r * 9, y1: r * 11, x2: r * 11, y2: r * 9 })
      ] })
    ] }),
    /* @__PURE__ */ h.jsx(
      "pattern",
      {
        id: t(1, n.id),
        width: "8",
        height: "8",
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ h.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: n.solid, mask: `url(#${e})` })
      }
    )
  ] });
}
function i4() {
  return {
    key: `${ou.id}:pattern`,
    component: Rtt
  };
}
const Xb = 8, KV = (t, e, n) => new Promise((r, s) => {
  const o = Xb * e * t, i = document.createElement("canvas");
  i.width = o, i.height = o;
  const a = i.getContext("2d");
  if (!a) return;
  a.fillStyle = n ? kE.darkMode.solid : kE.lightMode.solid, a.fillRect(0, 0, o, o), a.globalCompositeOperation = "destination-out", a.lineCap = "round", a.lineWidth = 1.25 * e * t;
  const c = 8 / 12, l = (d) => d * e * t;
  a.beginPath(), a.moveTo(l(c * 1), l(c * 3)), a.lineTo(l(c * 3), l(c * 1)), a.moveTo(l(c * 5), l(c * 7)), a.lineTo(l(c * 7), l(c * 5)), a.moveTo(l(c * 9), l(c * 11)), a.lineTo(l(c * 11), l(c * 9)), a.stroke(), i.toBlob((d) => {
    !d || ir.throwToBlob.get() ? s() : r(d);
  });
}), GV = (t, e) => {
  const n = document.createElement("canvas");
  n.width = t[0], n.height = t[1];
  const r = n.getContext("2d");
  return r ? (e(r), n.toDataURL()) : "";
};
let ZO = null;
function Dtt() {
  return ZO || (ZO = {
    white: GV([1, 1], (t) => {
      t.fillStyle = "#f8f9fa", t.fillRect(0, 0, 1, 1);
    }),
    black: GV([1, 1], (t) => {
      t.fillStyle = "#212529", t.fillRect(0, 0, 1, 1);
    })
  }), ZO;
}
function ofe(t) {
  return Math.ceil(Math.log2(Math.max(1, t)));
}
function a4() {
  const t = Xc("hash_pattern");
  return re(
    (e, n) => {
      const r = ofe(e);
      return f3(t, `${n}_${r}`);
    },
    [t]
  );
}
function ife(t) {
  const e = [], r = ofe(t);
  for (let s = 0; s <= r; s++)
    e.push(Math.pow(2, s));
  return e;
}
function Ntt(t) {
  const e = Dtt();
  return ife(t).flatMap((n) => [
    { zoom: n, url: e.white, theme: "light" },
    { zoom: n, url: e.black, theme: "dark" }
  ]);
}
function jtt() {
  const t = ie(), e = le("devicePixelRatio", () => t.getInstanceState().devicePixelRatio, [
    t
  ]), n = le("maxZoom", () => Math.ceil(Qs(t.getCameraOptions().zoomSteps)), [
    t
  ]), [r, s] = he(!1), [o, i] = he(
    () => Ntt(n)
  ), a = a4();
  return me(() => {
    if (process.env.NODE_ENV === "test") {
      s(!0);
      return;
    }
    const l = Promise.all(
      ife(n).flatMap((u) => [
        KV(e, u, !1).then((f) => ({
          zoom: u,
          theme: "light",
          url: URL.createObjectURL(f)
        })),
        KV(e, u, !0).then((f) => ({
          zoom: u,
          theme: "dark",
          url: URL.createObjectURL(f)
        }))
      ])
    );
    let d = !1;
    return l.then((u) => {
      d || (i(u), s(!0));
    }), () => {
      d = !0, s(!1), l.then((u) => {
        for (const { url: f } of u)
          URL.revokeObjectURL(f);
      });
    };
  }, [e, n]), { defs: /* @__PURE__ */ h.jsx(h.Fragment, { children: o.map((l) => {
    const d = a(l.zoom, l.theme);
    return /* @__PURE__ */ h.jsx(
      "pattern",
      {
        id: d,
        width: Xb,
        height: Xb,
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ h.jsx("image", { href: l.url, width: Xb, height: Xb })
      },
      d
    );
  }) }), isReady: r };
}
function Rtt() {
  const t = ie(), e = fe(null), { defs: n, isReady: r } = jtt();
  return me(() => {
    if (r && dn.isSafari) {
      const s = afe(e.current);
      s && t.timers.requestAnimationFrame(() => {
        s.style.display = "none", t.timers.requestAnimationFrame(() => {
          s.style.display = "";
        });
      });
    }
  }, [t, r]), /* @__PURE__ */ h.jsx("g", { ref: e, "data-testid": r ? "ready-pattern-fill-defs" : void 0, children: n });
}
function afe(t) {
  return t.classList.contains("tl-html-layer") ? t : t.parentElement ? afe(t.parentElement) : null;
}
const Mw = B.memo(function({
  theme: e,
  d: n,
  color: r,
  fill: s,
  scale: o
}) {
  switch (s) {
    case "none":
      return null;
    case "solid":
      return /* @__PURE__ */ h.jsx("path", { fill: e[r].semi, d: n });
    case "semi":
      return /* @__PURE__ */ h.jsx("path", { fill: e.solid, d: n });
    case "fill":
      return /* @__PURE__ */ h.jsx("path", { fill: e[r].fill, d: n });
    case "pattern":
      return /* @__PURE__ */ h.jsx($tt, { theme: e, color: r, fill: s, d: n, scale: o });
  }
});
function $tt({ d: t, color: e, theme: n }) {
  const r = ie(), s = J0(), o = le("zoomLevel", () => r.getZoomLevel(), [r]), i = a4(), a = r.getZoomLevel() <= 0.18;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx("path", { fill: n[e].pattern, d: t }),
    /* @__PURE__ */ h.jsx(
      "path",
      {
        fill: s ? `url(#${i(1, n.id)})` : a ? n[e].semi : `url(#${i(o, n.id)})`,
        d: t
      }
    )
  ] });
}
function Ltt(t) {
  return t.replace(/\s/g, "");
}
function ER(t, e, n) {
  const { padding: r = 0 } = n;
  if (e.length === 0) return null;
  const s = _e.From(e[0].box);
  for (const { box: l } of e)
    s.union(l);
  const o = r + (n.offsetX ?? 0), i = (n.offsetY ?? 0) + n.fontSize / 2 + (n.verticalTextAlign === "start" ? r : n.verticalTextAlign === "end" ? n.height - r - s.height : (Math.ceil(n.height) - s.height) / 2);
  let a = null;
  const c = [];
  for (const { text: l, box: d } of e)
    a !== null && d.y > a && c.push(
      /* @__PURE__ */ h.jsx(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: o,
          y: d.y + i,
          children: `
`
        },
        c.length
      )
    ), c.push(
      /* @__PURE__ */ h.jsx(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: d.x + o,
          y: d.y + i,
          unicodeBidi: "plaintext",
          children: Ltt(l)
        },
        c.length
      )
    ), a = d.y;
  return /* @__PURE__ */ h.jsx(
    "text",
    {
      fontSize: n.fontSize,
      fontFamily: n.fontFamily,
      fontStyle: n.fontStyle,
      fontWeight: n.fontWeight,
      dominantBaseline: "mathematical",
      alignmentBaseline: "mathematical",
      stroke: n.stroke,
      strokeWidth: n.strokeWidth,
      fill: n.fill,
      children: c
    }
  );
}
function Ftt({
  fontSize: t,
  font: e,
  align: n,
  verticalAlign: r,
  text: s,
  labelColor: o,
  bounds: i,
  padding: a = 16,
  stroke: c = !0,
  showTextOutline: l = !0
}) {
  const d = ie(), u = mc(), f = {
    fontSize: t,
    fontFamily: wte[e],
    textAlign: n,
    verticalTextAlign: r,
    width: Math.ceil(i.width),
    height: Math.ceil(i.height),
    padding: a,
    lineHeight: Oo.lineHeight,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "wrap",
    offsetX: 0,
    offsetY: 0,
    fill: o,
    stroke: void 0,
    strokeWidth: void 0
  }, p = d.textMeasure.measureTextSpans(s, f), g = ktt(n, a, p, i.width);
  g && (f.offsetX = g), f.offsetX += i.x, f.offsetY += i.y;
  const y = ER(d, p, f);
  let m = null;
  return l && c && (f.fill = u.background, f.stroke = u.background, f.strokeWidth = 3, m = ER(d, p, f)), /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    m,
    y
  ] });
}
function cfe(t, e, n) {
  switch (e.type) {
    case "straight":
      return new ln().moveTo(e.start.point.x, e.start.point.y, { offset: 0, roundness: 0 }).lineTo(e.end.point.x, e.end.point.y, { offset: 0, roundness: 0 }).toSvg(n);
    case "arc":
      return new ln().moveTo(e.start.point.x, e.start.point.y, { offset: 0, roundness: 0 }).circularArcTo(
        e.bodyArc.radius,
        !!e.bodyArc.largeArcFlag,
        !!e.bodyArc.sweepFlag,
        e.end.point.x,
        e.end.point.y,
        { offset: 0, roundness: 0 }
      ).toSvg(n);
    case "elbow": {
      const r = new ln();
      r.moveTo(e.start.point.x, e.start.point.y, {
        offset: 0
      });
      for (let s = 1; s < e.route.points.length; s++) {
        const o = e.route.points[s];
        e.route.skipPointsWhenDrawing.has(o) || r.lineTo(o.x, o.y, {
          offset: s === e.route.points.length - 1 ? 0 : void 0
        });
      }
      return r.toSvg(n);
    }
    default:
      Jt(e, "type");
  }
}
function Btt(t, e) {
  switch (t.type) {
    case "straight":
      return new ln().moveTo(t.start.handle.x, t.start.handle.y).lineTo(t.end.handle.x, t.end.handle.y).toSvg(e);
    case "arc":
      return new ln().moveTo(t.start.handle.x, t.start.handle.y).circularArcTo(
        t.handleArc.radius,
        !!t.handleArc.largeArcFlag,
        !!t.handleArc.sweepFlag,
        t.end.handle.x,
        t.end.handle.y
      ).toSvg(e);
    case "elbow": {
      const n = vQe(t.elbow, t.route);
      return ln.lineThroughPoints(n.points).toSvg(e);
    }
    default:
      Jt(t, "type");
  }
}
function yS(t, e) {
  const n = Xa(t, e);
  switch (n.type) {
    case "straight":
      return new ly({
        start: I.From(n.start.point),
        end: I.From(n.end.point)
      });
    case "arc":
      return new die({
        center: I.Cast(n.handleArc.center),
        start: I.Cast(n.start.point),
        end: I.Cast(n.end.point),
        sweepFlag: n.bodyArc.sweepFlag,
        largeArcFlag: n.bodyArc.largeArcFlag
      });
    case "elbow":
      return new Q0({ points: n.route.points });
    default:
      Jt(n, "type");
  }
}
const ztt = MI(
  "arrow label size",
  (t, e) => {
    t.fonts.trackFontsForShape(e);
    let n = 0, r = 0;
    const s = yS(t, e), o = e.props.text || "i", i = s.bounds, a = TR(e), { w: c, h: l } = t.textMeasure.measureText(o, {
      ...Oo,
      fontFamily: Ff[e.props.font],
      fontSize: a,
      maxWidth: null
    });
    n = c, r = l;
    let d = !1;
    const u = Xa(t, e), f = dfe(e), p = u.type === "elbow" ? Math.max(u.elbow.A.arrowheadOffset + f, 32) + Math.max(u.elbow.B.arrowheadOffset + f, 32) : 64;
    if (i.width > i.height ? (n = Math.max(Math.min(c, p), Math.min(i.width - p, c)), d = !0) : n > 16 * a && (n = 16 * a, d = !0), d) {
      const { w: g, h: y } = t.textMeasure.measureText(o, {
        ...Oo,
        fontFamily: Ff[e.props.font],
        fontSize: a,
        maxWidth: n
      });
      n = g, r = y;
    }
    return new I(n, r).addScalar(dR * 2 * e.props.scale);
  },
  {
    areRecordsEqual: (t, e) => {
      if (t.props === e.props) return !0;
      const n = H2e(t.props, e.props);
      return n.length === 1 && n[0] === "labelPosition";
    }
  }
);
function lfe(t, e) {
  return ztt.get(t, e.id) ?? new I(0, 0);
}
function dfe(t) {
  const e = ys[t.props.size];
  return (XQe + (e - ys.s) * 2 + (e === ys.xl ? 20 : 0)) * t.props.scale;
}
function Utt(t, e, n) {
  const r = yS(t, e), s = [], o = [new ui({ children: [r], debugColor: "lime" })], i = lfe(t, e), a = dfe(e), c = a / r.length;
  let l, d;
  if (n.type === "elbow")
    s.push(n.start.point, n.end.point), l = _e.FromCenter(n.start.point, i).expandBy(a), d = _e.FromCenter(n.end.point, i).expandBy(a);
  else {
    const v = r.interpolateAlongEdge(c), b = r.interpolateAlongEdge(1 - c);
    s.push(v, b), l = _e.FromCenter(v, i), d = _e.FromCenter(b, i);
  }
  const u = r.intersectPolygon(l.corners), f = r.intersectPolygon(d.corners), p = YV(n.start.point, u), g = YV(n.end.point, f);
  let y = p ? r.uninterpolateAlongEdge(p) : 0.5, m = g ? r.uninterpolateAlongEdge(g) : 0.5;
  y > m && (y = 0.5, m = 0.5);
  for (const v of [...u, ...f, ...s])
    o.push(
      new VE({
        x: v.x - 3,
        y: v.y - 3,
        radius: 3,
        isFilled: !1,
        debugColor: "magenta",
        ignore: !0
      })
    );
  return o.push(
    new uw({
      points: l.corners,
      debugColor: "lime",
      isFilled: !1,
      ignore: !0
    }),
    new uw({
      points: d.corners,
      debugColor: "lime",
      isFilled: !1,
      ignore: !0
    })
  ), { start: y, end: m, dbg: o };
}
function f_(t, e) {
  const n = [], r = Xa(t, e), s = {
    hasStartBinding: !!r.bindings.start,
    hasEndBinding: !!r.bindings.end,
    hasStartArrowhead: r.start.arrowhead !== "none",
    hasEndArrowhead: r.end.arrowhead !== "none"
  }, o = Utt(t, e, r);
  o.dbg && n.push(...o.dbg);
  const i = Htt(e, o, s), c = yS(t, e).interpolateAlongEdge(i), l = lfe(t, e);
  return { box: _e.FromCenter(c, l), debugGeom: n };
}
function Htt(t, e, n) {
  const { hasEndArrowhead: r, hasEndBinding: s, hasStartBinding: o, hasStartArrowhead: i } = n;
  return wt(
    t.props.labelPosition,
    i || o ? e.start : 0,
    r || s ? e.end : 1
  );
}
function YV(t, e) {
  let n = null, r = -1 / 0;
  for (const s of e) {
    const o = I.Dist2(t, s);
    o > r && (n = s, r = o);
  }
  return n;
}
function TR(t) {
  return qQe[t.props.size] * t.props.scale;
}
function ufe(t, e) {
  const n = Xa(t, e);
  switch (n.type) {
    case "straight":
    case "arc":
      return 0.5;
    case "elbow": {
      const r = n.route.midpointHandle, s = yS(t, e);
      return r && s ? s.uninterpolateAlongEdge(r.point) : 0.5;
    }
    default:
      Jt(n, "type");
  }
}
function Vtt(t, e, n) {
  const r = e === "end" ? t.end.point : t.start.point;
  let s;
  switch (t.type) {
    case "straight": {
      const o = e === "end" ? t.start.point : t.end.point, i = I.Dist(o, r), a = wt(i / 5, n, n * 3);
      s = I.Nudge(r, o, a);
      break;
    }
    case "arc": {
      const o = Math.abs(t.bodyArc.length), i = wt(o / 5, n, n * 3), a = xBe(
        r,
        i,
        t.handleArc.center,
        t.handleArc.radius
      );
      s = e === "end" ? t.handleArc.sweepFlag ? a[0] : a[1] : t.handleArc.sweepFlag ? a[1] : a[0];
      break;
    }
    case "elbow": {
      const o = e === "end" ? t.route.points[t.route.points.length - 2] : t.route.points[1], i = I.ManhattanDist(o, r), a = wt(i / 2, n, n * 3);
      s = o ? I.Nudge(r, o, a) : r;
      break;
    }
    default:
      Jt(t, "type");
  }
  return I.IsNaN(s) && (s = r), { point: r, int: s };
}
function Wtt({ point: t, int: e }) {
  const n = I.RotWith(e, t, mn / 6), r = I.RotWith(e, t, -mn / 6);
  return `M ${n.x} ${n.y} L ${t.x} ${t.y} L ${r.x} ${r.y}`;
}
function Ktt({ point: t, int: e }) {
  const n = I.RotWith(e, t, mn / 6), r = I.RotWith(e, t, -mn / 6);
  return `M ${n.x} ${n.y} L ${r.x} ${r.y} L ${t.x} ${t.y} Z`;
}
function Gtt({ point: t, int: e }) {
  const n = I.Sub(e, t).div(2), r = I.Add(t, I.Rot(n, ar)), s = I.Sub(t, I.Rot(n, ar));
  return `M ${r.x} ${r.y} L ${e.x} ${e.y} L ${s.x} ${s.y} Z`;
}
function Ytt({ point: t, int: e }) {
  const n = I.Lrp(t, e, 0.45), r = I.Dist(n, t);
  return `M ${n.x - r},${n.y}
  a ${r},${r} 0 1,0 ${r * 2},0
  a ${r},${r} 0 1,0 -${r * 2},0 `;
}
function qtt({ point: t, int: e }) {
  const n = I.Lrp(t, e, 0.75), r = I.RotWith(n, t, mn / 4), s = I.RotWith(n, t, -mn / 4), o = I.Lrp(r, s, 0.5);
  return o.add(I.Sub(o, t)), `M ${o.x} ${o.y} L ${s.x} ${s.y} ${t.x} ${t.y} L ${r.x} ${r.y} Z`;
}
function Xtt({ int: t, point: e }) {
  const n = I.Lrp(e, t, 0.85), r = I.Sub(n, e).div(2), s = I.Add(e, I.Rot(r, ar)), o = I.Sub(e, I.Rot(r, ar)), i = I.Add(n, I.Rot(r, ar)), a = I.Sub(n, I.Rot(r, ar));
  return `M ${s.x} ${s.y} L ${i.x} ${i.y} L ${a.x} ${a.y} L ${o.x} ${o.y} Z`;
}
function Ztt({ int: t, point: e }) {
  const n = I.Sub(t, e).div(2), r = I.Add(e, I.Rot(n, ar)), s = I.Sub(e, I.Rot(n, ar));
  return `M ${r.x} ${r.y} L ${s.x} ${s.y}`;
}
function KT(t, e, n) {
  const r = e === "end" ? t.end.arrowhead : t.start.arrowhead;
  if (r === "none") return;
  const s = Vtt(t, e, n);
  if (s) {
    switch (r) {
      case "bar":
        return Ztt(s);
      case "square":
        return Xtt(s);
      case "diamond":
        return qtt(s);
      case "dot":
        return Ytt(s);
      case "inverted":
        return Gtt(s);
      case "arrow":
        return Wtt(s);
      case "triangle":
        return Ktt(s);
    }
    return "";
  }
}
function Qtt({ arrow: t }) {
  var i, a;
  const e = ie(), n = le(
    "elbow arrow grid",
    () => {
      try {
        return Sue(
          e,
          e.getShape(t.id),
          As(e, t)
        );
      } catch (c) {
        console.error(c);
        return;
      }
    },
    [e, t.id]
  );
  if (!n) return null;
  const r = _e.Common([n.A.original, n.B.original]).expandBy(50), s = ((i = n.route) == null ? void 0 : i.name) ?? "", o = (a = n.route) == null ? void 0 : a.midpointHandle;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    n.midX !== null && /* @__PURE__ */ h.jsx(
      Vh,
      {
        a: { x: n.midX, y: r.minY },
        b: { x: n.midX, y: r.maxY },
        stroke: "red"
      }
    ),
    n.midY !== null && /* @__PURE__ */ h.jsx(
      Vh,
      {
        a: { x: r.minX, y: n.midY },
        b: { x: r.maxX, y: n.midY },
        stroke: "blue"
      }
    ),
    (o == null ? void 0 : o.axis) === "x" && n.midXRange && /* @__PURE__ */ h.jsx(
      Vh,
      {
        a: { x: n.midXRange.lo, y: o.point.y },
        b: { x: n.midXRange.hi, y: o.point.y },
        stroke: "red",
        strokeDasharray: "0 2"
      }
    ),
    (o == null ? void 0 : o.axis) === "y" && n.midYRange && /* @__PURE__ */ h.jsx(
      Vh,
      {
        a: { x: o.point.x, y: n.midYRange.lo },
        b: { x: o.point.x, y: n.midYRange.hi },
        stroke: "blue",
        strokeDasharray: "0 2"
      }
    ),
    /* @__PURE__ */ h.jsx(Wg, { box: n.A.original, stroke: "orange" }),
    /* @__PURE__ */ h.jsx(Wg, { box: n.A.expanded, stroke: "orange", strokeWidth: 0.5 }),
    /* @__PURE__ */ h.jsx(
      Wg,
      {
        box: n.A.original.clone().expandBy(n.options.minElbowLegLength),
        stroke: "orange",
        strokeWidth: 0.5
      }
    ),
    /* @__PURE__ */ h.jsx(Wg, { box: n.B.original, stroke: "lightskyblue" }),
    /* @__PURE__ */ h.jsx(Wg, { box: n.B.expanded, stroke: "lightskyblue", strokeWidth: 0.5 }),
    /* @__PURE__ */ h.jsx(
      Wg,
      {
        box: n.B.original.clone().expandBy(n.options.minElbowLegLength),
        stroke: "lightskyblue",
        strokeWidth: 0.5
      }
    ),
    /* @__PURE__ */ h.jsx(Nu, { edge: n.A.edges.top, axis: "x", stroke: "orange" }),
    /* @__PURE__ */ h.jsx(Nu, { edge: n.B.edges.top, axis: "x", stroke: "lightskyblue" }),
    /* @__PURE__ */ h.jsx(Nu, { edge: n.A.edges.right, axis: "y", stroke: "orange" }),
    /* @__PURE__ */ h.jsx(Nu, { edge: n.B.edges.right, axis: "y", stroke: "lightskyblue" }),
    /* @__PURE__ */ h.jsx(Nu, { edge: n.A.edges.bottom, axis: "x", stroke: "orange" }),
    /* @__PURE__ */ h.jsx(Nu, { edge: n.B.edges.bottom, axis: "x", stroke: "lightskyblue" }),
    /* @__PURE__ */ h.jsx(Nu, { edge: n.A.edges.left, axis: "y", stroke: "orange" }),
    /* @__PURE__ */ h.jsx(Nu, { edge: n.B.edges.left, axis: "y", stroke: "lightskyblue" }),
    n.route && /* @__PURE__ */ h.jsx(Jtt, { route: n.route.points, strokeWidth: 10 }),
    /* @__PURE__ */ h.jsx(
      "text",
      {
        x: r.minX + 5,
        y: r.minY - 3,
        fontSize: 10,
        fill: "black",
        stroke: "var(--color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: s
      }
    ),
    /* @__PURE__ */ h.jsxs(
      "text",
      {
        x: n.A.expanded.x,
        y: n.A.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "A",
          n.route && `, ${n.route.aEdgePicking}`,
          n.A.isPoint && ", point"
        ]
      }
    ),
    /* @__PURE__ */ h.jsxs(
      "text",
      {
        x: n.B.expanded.x,
        y: n.B.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "B",
          n.route && `, ${n.route.bEdgePicking}`,
          n.B.isPoint && ", point"
        ]
      }
    )
  ] });
}
function Vh({ a: t, b: e, ...n }) {
  return /* @__PURE__ */ h.jsx(
    "line",
    {
      fill: "none",
      strokeWidth: 1,
      strokeDasharray: "4,4",
      stroke: "green",
      x1: t.x,
      y1: t.y,
      x2: e.x,
      y2: e.y,
      ...n
    }
  );
}
function Jtt({ route: t, ...e }) {
  return /* @__PURE__ */ h.jsx(
    "polyline",
    {
      fill: "none",
      stroke: "darkorchid",
      strokeWidth: 3,
      opacity: 0.5,
      points: t.map((n) => `${n.x},${n.y}`).join(" "),
      ...e
    }
  );
}
function Nu({
  edge: t,
  axis: e,
  ...n
}) {
  if (!t || t.expanded === null) return null;
  const r = (s) => e === "x" ? { x: s.y, y: s.x } : s;
  return /* @__PURE__ */ h.jsxs("g", { children: [
    /* @__PURE__ */ h.jsx(
      Vh,
      {
        a: r({ x: t.expanded, y: t.cross.min }),
        b: r({ x: t.expanded, y: t.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...n
      }
    ),
    /* @__PURE__ */ h.jsx(
      Vh,
      {
        a: r({ x: t.expanded - 4, y: t.cross.min }),
        b: r({ x: t.expanded + 4, y: t.cross.min }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...n
      }
    ),
    /* @__PURE__ */ h.jsx(
      Vh,
      {
        a: r({ x: t.expanded - 4, y: t.cross.max }),
        b: r({ x: t.expanded + 4, y: t.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...n
      }
    )
  ] });
}
function Wg({ box: t, ...e }) {
  return /* @__PURE__ */ h.jsx(
    "rect",
    {
      x: t.minX,
      y: t.minY,
      width: t.width,
      height: t.height,
      strokeDasharray: "4,4",
      strokeWidth: 1,
      fill: "none",
      ...e
    }
  );
}
const ent = new No();
function tnt(t) {
  return ent.get(t, (e) => {
    const n = ve("current selected arrow shape", () => {
      const s = e.getOnlySelectedShape();
      return !s || !e.isShapeOfType(s, "arrow") ? null : s.id;
    }), r = e.store.query.ids("shape", () => {
      const s = n.get();
      return s ? {
        type: { eq: "arrow" },
        id: { neq: s }
      } : { type: { eq: "arrow" } };
    });
    return ve("elbow arrow snap lines", () => {
      var a, c;
      const s = /* @__PURE__ */ new Map(), o = e.getCurrentPageShapeIds(), i = e.getViewportPageBounds();
      for (const l of r.get()) {
        if (!o.has(l)) continue;
        const d = e.getShape(l);
        if ((d == null ? void 0 : d.type) !== "arrow") continue;
        const u = e.getShapePageBounds(l);
        if (!u || !i.includes(u)) continue;
        const f = As(e, d), p = e.getShapePageTransform(l);
        if (!p) continue;
        const g = e.getShapeGeometry(l), y = p.applyToPoints(g.vertices);
        for (let m = 1; m < y.length; m++) {
          const v = y[m - 1], b = y[m];
          let x = I.Angle(v, b);
          x < 0 && (x += Math.PI);
          let w = s.get(x);
          w || (w = /* @__PURE__ */ new Set(), s.set(x, w));
          const S = Zb(v, x);
          w.add({
            perpDistance: S,
            startBoundShapeId: (a = f.start) == null ? void 0 : a.toId,
            endBoundShapeId: (c = f.end) == null ? void 0 : c.toId
          });
        }
      }
      return s;
    });
  }).get();
}
function Zb(t, e) {
  const n = I.FromAngle(e).per();
  return I.Dpr(t, n);
}
class h_ extends sc {
  constructor() {
    super(...arguments);
    P(this, "options", {
      expandElbowLegLength: {
        s: 28,
        m: 36,
        l: 44,
        xl: 66
      },
      minElbowLegLength: {
        s: ys.s * 3,
        m: ys.m * 3,
        l: ys.l * 3,
        xl: ys.xl * 3
      },
      minElbowHandleDistance: 16,
      arcArrowCenterSnapDistance: 16,
      elbowArrowCenterSnapDistance: 24,
      elbowArrowEdgeSnapDistance: 20,
      elbowArrowPointSnapDistance: 24,
      elbowArrowAxisSnapDistance: 16,
      labelCenterSnapDistance: 10,
      elbowMidpointSnapDistance: 10,
      elbowMinSegmentLengthToShowMidpointHandle: 20,
      hoverPreciseTimeout: 600,
      pointingPreciseTimeout: 320,
      shouldBeExact: (n) => n.inputs.altKey,
      shouldIgnoreTargets: (n) => n.inputs.ctrlKey
    });
    P(this, "_resizeInitialBindings", new No());
  }
  canEdit() {
    return !0;
  }
  canBind({ toShapeType: n }) {
    return n !== "arrow";
  }
  canSnap() {
    return !1;
  }
  hideResizeHandles() {
    return !0;
  }
  hideRotateHandle() {
    return !0;
  }
  hideSelectionBoundsBg() {
    return !0;
  }
  hideSelectionBoundsFg() {
    return !0;
  }
  canBeLaidOut(n, r) {
    if (r.type === "flip") {
      const s = As(this.editor, n), { start: o, end: i } = s, { shapes: a = [] } = r;
      if (o && !a.find((c) => c.id === o.toId) || i && !a.find((c) => c.id === i.toId)) return !1;
    }
    return !0;
  }
  getFontFaces(n) {
    return n.props.text ? [e4[`tldraw_${n.props.font}`].normal.normal] : Br;
  }
  getDefaultProps() {
    return {
      kind: "arc",
      elbowMidPoint: 0.5,
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { x: 0, y: 0 },
      end: { x: 2, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      text: "",
      labelPosition: 0.5,
      font: "draw",
      scale: 1
    };
  }
  getGeometry(n) {
    const r = this.editor.getEditingShapeId() === n.id, s = Xa(this.editor, n), o = [], i = s.type === "straight" ? new ly({
      start: I.From(s.start.point),
      end: I.From(s.end.point)
    }) : s.type === "arc" ? new die({
      center: I.Cast(s.handleArc.center),
      start: I.Cast(s.start.point),
      end: I.Cast(s.end.point),
      sweepFlag: s.bodyArc.sweepFlag,
      largeArcFlag: s.bodyArc.largeArcFlag
    }) : new Q0({ points: s.route.points });
    let a;
    if (r || n.props.text.trim()) {
      const c = f_(this.editor, n);
      ir.debugGeometry.get() && o.push(...c.debugGeom), a = new ol({
        x: c.box.x,
        y: c.box.y,
        width: c.box.w,
        height: c.box.h,
        isFilled: !0,
        isLabel: !0
      });
    }
    return new ui({
      children: [...a ? [i, a] : [i], ...o]
    });
  }
  getHandles(n) {
    const r = Xa(this.editor, n), s = [
      {
        id: "start",
        type: "vertex",
        index: "a1",
        x: r.start.handle.x,
        y: r.start.handle.y
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: r.end.handle.x,
        y: r.end.handle.y
      }
    ];
    if (n.props.kind === "arc" && (r.type === "straight" || r.type === "arc") && s.push({
      id: "middle",
      type: "virtual",
      index: "a2",
      x: r.middle.x,
      y: r.middle.y
    }), n.props.kind === "elbow" && r.type === "elbow" && r.route.midpointHandle) {
      const o = this.editor.getShapePageTransform(n.id), i = o.applyToPoint(r.route.midpointHandle.segmentStart), a = o.applyToPoint(r.route.midpointHandle.segmentEnd);
      I.Dist(i, a) * this.editor.getZoomLevel() > this.options.elbowMinSegmentLengthToShowMidpointHandle && s.push({
        id: "middle",
        type: "vertex",
        index: "a2",
        x: r.route.midpointHandle.point.x,
        y: r.route.midpointHandle.point.y
      });
    }
    return s;
  }
  getText(n) {
    return n.props.text;
  }
  onHandleDrag(n, r) {
    const s = r.handle.id;
    switch (s) {
      case "middle":
        switch (n.props.kind) {
          case "arc":
            return this.onArcMidpointHandleDrag(n, r);
          case "elbow":
            return this.onElbowMidpointHandleDrag(n, r);
          default:
            Jt(n.props.kind);
        }
      case "start":
      case "end":
        return this.onTerminalHandleDrag(n, r, s);
      default:
        Jt(s);
    }
  }
  onArcMidpointHandleDrag(n, { handle: r }) {
    const s = As(this.editor, n), { start: o, end: i } = gm(this.editor, n, s), a = I.Sub(i, o), c = I.Per(a), l = I.Med(i, o), d = I.Sub(l, c), u = I.Add(l, c), f = I.NearestPointOnLineSegment(d, u, r, !1);
    let p = I.Dist(f, l);
    return I.Clockwise(f, i, l) && (p *= -1), { id: n.id, type: n.type, props: { bend: p } };
  }
  onElbowMidpointHandleDrag(n, { handle: r }) {
    var x, w, S, C, _;
    const s = Xa(this.editor, n);
    if ((s == null ? void 0 : s.type) !== "elbow") return;
    const o = this.editor.getShapePageTransform(n.id), i = o.applyToPoint(r), a = (x = s.route.midpointHandle) == null ? void 0 : x.axis;
    if (!a) return;
    const c = Pw[a], l = s.elbow[c.midRange];
    if (!l) return;
    let d = I.Angle(
      o.applyToPoint(c.v(0, 0)),
      o.applyToPoint(c.v(0, 1))
    );
    d < 0 && (d += Math.PI);
    const u = Zb(i, d), f = Zb(
      o.applyToPoint(c.v(l.lo, 0)),
      d
    ), p = Zb(
      o.applyToPoint(c.v(l.hi, 0)),
      d
    ), g = this.options.elbowMidpointSnapDistance / this.editor.getZoomLevel(), y = Zb(
      o.applyToPoint(c.v(kt(l.lo, l.hi, 0.5), 0)),
      d
    );
    let m = y, v = Math.abs(y - u);
    for (const [E, M] of tnt(this.editor)) {
      const { isParallel: N, isFlippedParallel: O } = snt(d, E);
      if (N || O)
        for (const D of M) {
          const k = D.startBoundShapeId && (D.startBoundShapeId === ((w = s.bindings.start) == null ? void 0 : w.toId) || D.startBoundShapeId === ((S = s.bindings.end) == null ? void 0 : S.toId)), A = D.endBoundShapeId && (D.endBoundShapeId === ((C = s.bindings.start) == null ? void 0 : C.toId) || D.endBoundShapeId === ((_ = s.bindings.end) == null ? void 0 : _.toId));
          if (!k && !A) continue;
          const R = O ? -D.perpDistance : D.perpDistance, j = Math.abs(R - u);
          j < v && (m = R, v = j);
        }
    }
    v > g && (m = u);
    const b = wt(sw(f, p, m), 0, 1);
    return {
      id: n.id,
      type: n.type,
      props: {
        elbowMidPoint: b
      }
    };
  }
  onTerminalHandleDrag(n, { handle: r, isPrecise: s }, o) {
    const i = As(this.editor, n), a = { id: n.id, type: "arrow", props: {} }, c = i[o], d = i[o === "start" ? "end" : "start"], u = $k({
      editor: this.editor,
      pointInPageSpace: this.editor.getShapePageTransform(n.id).applyToPoint(r),
      arrow: n,
      isPrecise: s,
      currentBinding: c,
      oppositeBinding: d
    });
    if (!u) {
      Kb(this.editor, n, o);
      const g = Ea(new I(r.x, r.y), this.editor);
      return a.props[o] = {
        x: g.x,
        y: g.y
      }, a;
    }
    const f = {
      terminal: o,
      normalizedAnchor: u.normalizedAnchor,
      isPrecise: u.isPrecise,
      isExact: u.isExact,
      snap: u.snap
    };
    ib(this.editor, n, u.target.id, f);
    const p = As(this.editor, n);
    return p.start && p.end && p.start.toId === p.end.toId && I.Equals(p.start.props.normalizedAnchor, p.end.props.normalizedAnchor) && ib(this.editor, n, p.end.toId, {
      ...p.end.props,
      normalizedAnchor: {
        x: p.end.props.normalizedAnchor.x + 0.05,
        y: p.end.props.normalizedAnchor.y
      }
    }), a;
  }
  onTranslateStart(n) {
    const r = As(this.editor, n);
    if (n.props.kind === "elbow" && this.editor.getOnlySelectedShapeId() === n.id) {
      const a = Xa(this.editor, n);
      if (!a) return;
      const c = { id: n.id, type: "arrow", props: {} };
      return r.start && (c.props.start = { x: a.start.point.x, y: a.start.point.y }, Kb(this.editor, n, "start")), r.end && (c.props.end = { x: a.end.point.x, y: a.end.point.y }, Kb(this.editor, n, "end")), c;
    }
    const s = gm(this.editor, n, r), o = this.editor.getShapePageTransform(n.id), i = this.editor.getSelectedShapeIds();
    if (!(r.start && (i.includes(r.start.toId) || this.editor.isAncestorSelected(r.start.toId)) || r.end && (i.includes(r.end.toId) || this.editor.isAncestorSelected(r.end.toId)))) {
      XV.set(n, {
        pagePosition: o.applyToPoint(n),
        terminalBindings: Qf(s, (a, c) => {
          const l = r[a];
          return l ? {
            binding: l,
            shapePosition: c,
            pagePosition: o.applyToPoint(c)
          } : null;
        })
      }), r.start && (gT({
        editor: this.editor,
        arrow: n,
        terminal: "start",
        useHandle: !0
      }), n = this.editor.getShape(n.id)), r.end && gT({
        editor: this.editor,
        arrow: n,
        terminal: "end",
        useHandle: !0
      });
      for (const a of [
        "start",
        "end"
        /* End */
      ]) {
        const c = r[a];
        c && this.editor.updateBinding({
          ...c,
          props: { ...c.props, isPrecise: !0 }
        });
      }
    }
  }
  onTranslate(n, r) {
    const s = XV.get(n);
    if (!s) return;
    const o = this.editor.getShapePageTransform(r.id), i = I.Sub(
      o.applyToPoint(r),
      s.pagePosition
    );
    for (const a of Object.values(s.terminalBindings)) {
      if (!a) continue;
      const c = I.Add(a.pagePosition, I.Mul(i, 0.5)), l = this.editor.getShapeAtPoint(c, {
        hitInside: !0,
        hitFrameInside: !0,
        margin: 0,
        filter: (d) => !d.isLocked && this.editor.canBindShapes({ fromShape: r, toShape: d, binding: "arrow" })
      });
      if ((l == null ? void 0 : l.id) === a.binding.toId) {
        const d = _e.ZeroFix(this.editor.getShapeGeometry(l).bounds), u = this.editor.getPointInShapeSpace(l, c), f = {
          x: (u.x - d.minX) / d.width,
          y: (u.y - d.minY) / d.height
        };
        ib(this.editor, r, l.id, {
          ...a.binding.props,
          normalizedAnchor: f,
          isPrecise: !0
        });
      } else
        Kb(this.editor, r, a.binding.props.terminal);
    }
  }
  onResize(n, r) {
    const { scaleX: s, scaleY: o } = r, i = this._resizeInitialBindings.get(
      n,
      () => As(this.editor, n)
    ), a = gm(this.editor, n, i), { start: c, end: l } = mr(n.props);
    let { bend: d } = n.props;
    i.start || (c.x = a.start.x * s, c.y = a.start.y * o), i.end || (l.x = a.end.x * s, l.y = a.end.y * o);
    const u = Math.abs(s), f = Math.abs(o), p = i != null && i.start ? I.From(i.start.props.normalizedAnchor) : null, g = i != null && i.end ? I.From(i.end.props.normalizedAnchor) : null;
    return s < 0 && o >= 0 ? (d !== 0 && (d *= -1, d *= Math.max(u, f)), p && (p.x = 1 - p.x), g && (g.x = 1 - g.x)) : s >= 0 && o < 0 ? (d !== 0 && (d *= -1, d *= Math.max(u, f)), p && (p.y = 1 - p.y), g && (g.y = 1 - g.y)) : s >= 0 && o >= 0 ? d !== 0 && (d *= Math.max(u, f)) : s < 0 && o < 0 && (d !== 0 && (d *= Math.max(u, f)), p && (p.x = 1 - p.x, p.y = 1 - p.y), g && (g.x = 1 - g.x, g.y = 1 - g.y)), i.start && p && ib(this.editor, n, i.start.toId, {
      ...i.start.props,
      normalizedAnchor: p.toJson()
    }), i.end && g && ib(this.editor, n, i.end.toId, {
      ...i.end.props,
      normalizedAnchor: g.toJson()
    }), {
      props: {
        start: c,
        end: l,
        bend: d
      }
    };
  }
  onDoubleClickHandle(n, r) {
    switch (r.id) {
      case "start":
        return {
          id: n.id,
          type: n.type,
          props: {
            ...n.props,
            arrowheadStart: n.props.arrowheadStart === "none" ? "arrow" : "none"
          }
        };
      case "end":
        return {
          id: n.id,
          type: n.type,
          props: {
            ...n.props,
            arrowheadEnd: n.props.arrowheadEnd === "none" ? "arrow" : "none"
          }
        };
    }
  }
  component(n) {
    const r = mc(), s = this.editor.getOnlySelectedShape(), o = this.editor.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "select.translating",
      "arrow.dragging"
    ) && !this.editor.getIsReadonly(), i = Xa(this.editor, n);
    if (!(i != null && i.isValid)) return null;
    const a = f_(this.editor, n), c = n.id === this.editor.getOnlySelectedShapeId(), d = this.editor.getEditingShapeId() === n.id || n.props.text;
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsxs(jf, { style: { minWidth: 50, minHeight: 50 }, children: [
        /* @__PURE__ */ h.jsx(
          qV,
          {
            shape: n,
            shouldDisplayHandles: o && (s == null ? void 0 : s.id) === n.id
          }
        ),
        n.props.kind === "elbow" && ir.debugElbowArrows.get() && /* @__PURE__ */ h.jsx(Qtt, { arrow: n })
      ] }),
      d && /* @__PURE__ */ h.jsx(
        Mtt,
        {
          shapeId: n.id,
          classNamePrefix: "tl-arrow",
          type: "arrow",
          font: n.props.font,
          fontSize: TR(n),
          lineHeight: Oo.lineHeight,
          align: "middle",
          verticalAlign: "middle",
          text: n.props.text,
          labelColor: r[n.props.labelColor].solid,
          textWidth: a.box.w - dR * 2 * n.props.scale,
          isSelected: c,
          padding: 0,
          style: {
            transform: `translate(${a.box.center.x}px, ${a.box.center.y}px)`
          }
        }
      )
    ] });
  }
  indicator(n) {
    const r = aS(n.id), s = Xc(n.id + "_clip"), o = Xa(this.editor, n);
    if (!o) return null;
    const { start: i, end: a } = gm(this.editor, n, o == null ? void 0 : o.bindings), c = this.editor.getShapeGeometry(n), l = c.bounds, d = r || n.props.text.trim() ? c.children[1] : null;
    if (I.Equals(i, a)) return null;
    const u = ys[n.props.size] * n.props.scale, f = o.start.arrowhead && KT(o, "start", u), p = o.end.arrowhead && KT(o, "end", u), g = f && o.start.arrowhead !== "arrow" || p && o.end.arrowhead !== "arrow" || !!d, y = d ? d.getBounds() : new _e(0, 0, 0, 0);
    if (r && d)
      return /* @__PURE__ */ h.jsx(
        "rect",
        {
          x: ne(y.x),
          y: ne(y.y),
          width: y.w,
          height: y.h,
          rx: 3.5 * n.props.scale,
          ry: 3.5 * n.props.scale
        }
      );
    const m = !(o.start.arrowhead === "none" || o.start.arrowhead === "arrow"), v = !(o.end.arrowhead === "none" || o.end.arrowhead === "arrow");
    return /* @__PURE__ */ h.jsxs("g", { children: [
      g && /* @__PURE__ */ h.jsx("defs", { children: /* @__PURE__ */ h.jsx(
        ffe,
        {
          radius: 3.5 * n.props.scale,
          hasText: n.props.text.trim().length > 0,
          bounds: l,
          labelBounds: y,
          as: m && f ? f : "",
          ae: v && p ? p : ""
        }
      ) }),
      /* @__PURE__ */ h.jsxs(
        "g",
        {
          style: {
            clipPath: g ? `url(#${s})` : void 0,
            WebkitClipPath: g ? `url(#${s})` : void 0
          },
          children: [
            g && /* @__PURE__ */ h.jsx(
              "rect",
              {
                x: l.minX - 100,
                y: l.minY - 100,
                width: l.width + 200,
                height: l.height + 200,
                opacity: 0
              }
            ),
            cfe(
              n,
              o,
              n.props.dash === "draw" ? {
                style: "draw",
                randomSeed: n.id,
                strokeWidth: 1,
                passes: 1,
                offset: 0,
                roundness: u * 2,
                props: { strokeWidth: void 0 }
              } : { style: "solid", strokeWidth: 1, props: { strokeWidth: void 0 } }
            )
          ]
        }
      ),
      f && /* @__PURE__ */ h.jsx("path", { d: f }),
      p && /* @__PURE__ */ h.jsx("path", { d: p }),
      d && /* @__PURE__ */ h.jsx(
        "rect",
        {
          x: ne(y.x),
          y: ne(y.y),
          width: y.w,
          height: y.h,
          rx: 3.5,
          ry: 3.5
        }
      )
    ] });
  }
  onEditStart(n) {
    if (n.props.text.trim() === "") {
      const r = ufe(this.editor, n);
      this.editor.updateShape({
        id: n.id,
        type: n.type,
        props: { labelPosition: r }
      });
    }
  }
  onEditEnd(n) {
    const {
      id: r,
      type: s,
      props: { text: o }
    } = n;
    o.trimEnd() !== n.props.text && this.editor.updateShapes([
      {
        id: r,
        type: s,
        props: {
          text: o.trimEnd()
        }
      }
    ]);
  }
  toSvg(n, r) {
    r.addExportDef(o4(n.props.fill));
    const s = mu(r), o = 1 / n.props.scale;
    return /* @__PURE__ */ h.jsxs("g", { transform: `scale(${o})`, children: [
      /* @__PURE__ */ h.jsx(qV, { shape: n, shouldDisplayHandles: !1 }),
      /* @__PURE__ */ h.jsx(
        Ftt,
        {
          fontSize: TR(n),
          font: n.props.font,
          align: "middle",
          verticalAlign: "middle",
          text: n.props.text,
          labelColor: s[n.props.labelColor].solid,
          bounds: f_(this.editor, n).box.clone().expandBy(-dR * n.props.scale),
          padding: 0,
          showTextOutline: !0
        }
      )
    ] });
  }
  getCanvasSvgDefs() {
    return [
      i4(),
      {
        key: "arrow:dot",
        component: nnt
      },
      {
        key: "arrow:cross",
        component: rnt
      }
    ];
  }
  getInterpolatedProps(n, r, s) {
    return {
      ...s > 0.5 ? r.props : n.props,
      scale: kt(n.props.scale, r.props.scale, s),
      start: {
        x: kt(n.props.start.x, r.props.start.x, s),
        y: kt(n.props.start.y, r.props.start.y, s)
      },
      end: {
        x: kt(n.props.end.x, r.props.end.x, s),
        y: kt(n.props.end.y, r.props.end.y, s)
      },
      bend: kt(n.props.bend, r.props.bend, s),
      labelPosition: kt(n.props.labelPosition, r.props.labelPosition, s)
    };
  }
}
P(h_, "type", "arrow"), P(h_, "props", Cte), P(h_, "migrations", _te);
const qV = Kr(function({
  shape: e,
  shouldDisplayHandles: n
}) {
  const r = ie(), s = mc(), o = Xa(r, e), i = le(
    "force solid",
    () => r.getZoomLevel() < 0.2,
    [r]
  ), a = Xc(e.id + "_clip"), c = Xc("arrowhead-dot"), l = Xc("arrowhead-cross"), d = aS(e.id), u = r.getShapeGeometry(e);
  if (!u) return null;
  const f = _e.ZeroFix(u.bounds), p = As(r, e);
  if (!(o != null && o.isValid)) return null;
  const g = ys[e.props.size] * e.props.scale, y = o.start.arrowhead && KT(o, "start", g), m = o.end.arrowhead && KT(o, "end", g);
  let v = null;
  n && (p.start || p.end) && (v = Btt(o, {
    style: "dashed",
    start: "skip",
    end: "skip",
    lengthRatio: 2.5,
    strokeWidth: 2 / r.getZoomLevel(),
    props: {
      className: "tl-arrow-hint",
      markerStart: p.start ? p.start.props.isExact ? "" : p.start.props.isPrecise ? `url(#${l})` : `url(#${c})` : "",
      markerEnd: p.end ? p.end.props.isExact ? "" : p.end.props.isPrecise ? `url(#${l})` : `url(#${c})` : "",
      opacity: 0.16
    }
  }));
  const b = f_(r, e), x = !(o.start.arrowhead === "none" || o.start.arrowhead === "arrow"), w = !(o.end.arrowhead === "none" || o.end.arrowhead === "arrow");
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx("defs", { children: /* @__PURE__ */ h.jsx("clipPath", { id: a, children: /* @__PURE__ */ h.jsx(
      ffe,
      {
        radius: 3.5 * e.props.scale,
        hasText: d || e.props.text.trim().length > 0,
        bounds: f,
        labelBounds: b.box,
        as: x && y ? y : "",
        ae: w && m ? m : ""
      }
    ) }) }),
    /* @__PURE__ */ h.jsxs(
      "g",
      {
        fill: "none",
        stroke: s[e.props.color].solid,
        strokeWidth: g,
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none",
        children: [
          v,
          /* @__PURE__ */ h.jsxs(
            "g",
            {
              style: {
                clipPath: `url(#${a})`,
                WebkitClipPath: `url(#${a})`
              },
              children: [
                /* @__PURE__ */ h.jsx(
                  "rect",
                  {
                    x: ne(f.minX - 100),
                    y: ne(f.minY - 100),
                    width: ne(f.width + 200),
                    height: ne(f.height + 200),
                    opacity: 0
                  }
                ),
                cfe(e, o, {
                  style: e.props.dash,
                  strokeWidth: g,
                  forceSolid: i,
                  randomSeed: e.id
                })
              ]
            }
          ),
          y && x && e.props.fill !== "none" && /* @__PURE__ */ h.jsx(
            Mw,
            {
              theme: s,
              d: y,
              color: e.props.color,
              fill: e.props.fill,
              scale: e.props.scale
            }
          ),
          m && w && e.props.fill !== "none" && /* @__PURE__ */ h.jsx(
            Mw,
            {
              theme: s,
              d: m,
              color: e.props.color,
              fill: e.props.fill,
              scale: e.props.scale
            }
          ),
          y && /* @__PURE__ */ h.jsx("path", { d: y }),
          m && /* @__PURE__ */ h.jsx("path", { d: m })
        ]
      }
    )
  ] });
});
function ffe({
  radius: t,
  hasText: e,
  bounds: n,
  labelBounds: r,
  as: s,
  ae: o
}) {
  const i = Ke(() => {
    const a = new ln();
    return a.moveTo(n.left - 100, n.top - 100).lineTo(n.right + 100, n.top - 100).lineTo(n.right + 100, n.bottom + 100).lineTo(n.left - 100, n.bottom + 100).close(), e && a.moveTo(r.left, r.top + t).lineTo(r.left, r.bottom - t).circularArcTo(t, !1, !1, r.left + t, r.bottom).lineTo(r.right - t, r.bottom).circularArcTo(t, !1, !1, r.right, r.bottom - t).lineTo(r.right, r.top + t).circularArcTo(t, !1, !1, r.right - t, r.top).lineTo(r.left + t, r.top).circularArcTo(t, !1, !1, r.left, r.top + t).close(), a.toD();
  }, [
    t,
    e,
    n.bottom,
    n.left,
    n.right,
    n.top,
    r.bottom,
    r.left,
    r.right,
    r.top
  ]);
  return /* @__PURE__ */ h.jsx("path", { d: `${i}${s}${o}` });
}
const XV = /* @__PURE__ */ new WeakMap();
function nnt() {
  const t = Xc("arrowhead-dot");
  return /* @__PURE__ */ h.jsx("marker", { id: t, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: /* @__PURE__ */ h.jsx("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) });
}
function rnt() {
  const t = Xc("arrowhead-cross");
  return /* @__PURE__ */ h.jsxs("marker", { id: t, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "auto", children: [
    /* @__PURE__ */ h.jsx("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
    /* @__PURE__ */ h.jsx("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
  ] });
}
function snt(t, e, n = 1e-4) {
  const r = Math.abs(t - e), s = r < n, o = Math.abs(r - Math.PI) < n, i = Math.abs(r - Bn) < n;
  return { isParallel: s || i, isFlippedParallel: o };
}
const ZV = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
function yy({ url: t }) {
  const e = ie(), n = le("zoomLevel", () => e.getZoomLevel() < 0.32, [e]), r = re(
    (s) => {
      e.inputs.shiftKey || cr(s);
    },
    [e]
  );
  return /* @__PURE__ */ h.jsx(
    "a",
    {
      className: Je("tl-hyperlink-button", {
        "tl-hyperlink-button__hidden": n
      }),
      href: t,
      target: "_blank",
      rel: "noopener noreferrer",
      onPointerDown: r,
      onPointerUp: r,
      title: t,
      draggable: !1,
      children: /* @__PURE__ */ h.jsx(
        "div",
        {
          className: "tl-hyperlink__icon",
          style: {
            mask: `url("${ZV}") center 100% / 100% no-repeat`,
            WebkitMask: `url("${ZV}") center 100% / 100% no-repeat`
          }
        }
      )
    }
  );
}
const QV = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E", ont = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
];
function GT(t) {
  return ont.map((n) => {
    const { offsetX: r, offsetY: s, blur: o, spread: i, color: a } = n, c = new I(r, s), { x: l, y: d } = c.rot(-t);
    return `${l}px ${d}px ${o}px ${i}px ${a}`;
  }).join(", ");
}
const int = 300, hfe = 320, ant = 46, cnt = 101;
class p_ extends uv {
  canResize() {
    return !1;
  }
  hideSelectionBoundsFg() {
    return !0;
  }
  getText(e) {
    return e.props.url;
  }
  getAriaDescriptor(e) {
    const n = e.props.assetId ? this.editor.getAsset(e.props.assetId) : null;
    if (n != null && n.props.title)
      return Gue(n.props.title) + (n.props.description ? ", " + n.props.description : "");
  }
  getDefaultProps() {
    return {
      url: "",
      w: int,
      h: hfe,
      assetId: null
    };
  }
  component(e) {
    return /* @__PURE__ */ h.jsx(lnt, { shape: e });
  }
  indicator(e) {
    return /* @__PURE__ */ h.jsx(
      "rect",
      {
        width: ne(e.props.w),
        height: ne(e.props.h),
        rx: "6",
        ry: "6"
      }
    );
  }
  onBeforeCreate(e) {
    return JV(this.editor, e);
  }
  onBeforeUpdate(e, n) {
    if (e.props.url !== n.props.url)
      if (_a.isValid(n.props.url))
        unt(this.editor, n);
      else
        return { ...n, props: { ...n.props, url: e.props.url } };
    if (e.props.assetId !== n.props.assetId)
      return JV(this.editor, n);
  }
  getInterpolatedProps(e, n, r) {
    return {
      ...r > 0.5 ? n.props : e.props,
      w: kt(e.props.w, n.props.w, r),
      h: kt(e.props.h, n.props.h, r)
    };
  }
}
P(p_, "type", "bookmark"), P(p_, "props", Ate), P(p_, "migrations", Mte);
function lnt({ shape: t }) {
  const e = ie(), n = t.props.assetId ? e.getAsset(t.props.assetId) : null, r = !!J0() && dn.isSafari, s = e.getShapePageTransform(t).rotation(), o = dnt(t), [i, a] = he(!0), c = () => a(!1), l = re(
    (d) => {
      e.inputs.shiftKey || cr(d);
    },
    [e]
  );
  return /* @__PURE__ */ h.jsx(Zd, { children: /* @__PURE__ */ h.jsxs(
    "div",
    {
      className: Je(
        "tl-bookmark__container",
        r && "tl-bookmark__container--safariExport"
      ),
      style: {
        boxShadow: r ? void 0 : GT(s),
        maxHeight: t.props.h
      },
      children: [
        (!n || n.props.image) && /* @__PURE__ */ h.jsxs("div", { className: "tl-bookmark__image_container", children: [
          n ? /* @__PURE__ */ h.jsx(
            "img",
            {
              className: "tl-bookmark__image",
              draggable: !1,
              referrerPolicy: "strict-origin-when-cross-origin",
              src: n == null ? void 0 : n.props.image,
              alt: (n == null ? void 0 : n.props.title) || ""
            }
          ) : /* @__PURE__ */ h.jsx("div", { className: "tl-bookmark__placeholder" }),
          (n == null ? void 0 : n.props.image) && /* @__PURE__ */ h.jsx(yy, { url: t.props.url })
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "tl-bookmark__copy_container", children: [
          n != null && n.props.title ? /* @__PURE__ */ h.jsx("h2", { className: "tl-bookmark__heading", children: Gue(n.props.title) }) : null,
          n != null && n.props.description && (n != null && n.props.image) ? /* @__PURE__ */ h.jsx("p", { className: "tl-bookmark__description", children: n.props.description }) : null,
          /* @__PURE__ */ h.jsxs(
            "a",
            {
              className: "tl-bookmark__link",
              href: t.props.url || "",
              target: "_blank",
              rel: "noopener noreferrer",
              draggable: !1,
              onPointerDown: l,
              onPointerUp: l,
              children: [
                i && (n != null && n.props.favicon) ? /* @__PURE__ */ h.jsx(
                  "img",
                  {
                    className: "tl-bookmark__favicon",
                    src: n == null ? void 0 : n.props.favicon,
                    referrerPolicy: "strict-origin-when-cross-origin",
                    onError: c,
                    alt: `favicon of ${o}`
                  }
                ) : /* @__PURE__ */ h.jsx(
                  "div",
                  {
                    className: "tl-hyperlink__icon",
                    style: {
                      mask: `url("${QV}") center 100% / 100% no-repeat`,
                      WebkitMask: `url("${QV}") center 100% / 100% no-repeat`
                    }
                  }
                ),
                /* @__PURE__ */ h.jsx("span", { children: o })
              ]
            }
          )
        ] })
      ]
    }
  ) });
}
function JV(t, e) {
  const n = e.props.assetId ? t.getAsset(e.props.assetId) : null;
  let r = hfe;
  return n && (n.props.image || (n.props.title ? r = cnt : r = ant)), {
    ...e,
    props: {
      ...e.props,
      h: r
    }
  };
}
const dnt = (t) => {
  try {
    return new URL(t.props.url).hostname.replace(/^www\./, "");
  } catch {
    return t.props.url;
  }
};
function unt(t, e) {
  const { url: n } = e.props, r = th.createId(uF(n));
  t.getAsset(r) ? e.props.assetId !== r && t.updateShapes([
    {
      id: e.id,
      type: e.type,
      props: { assetId: r }
    }
  ]) : (t.updateShapes([
    {
      id: e.id,
      type: e.type,
      props: { assetId: null }
    }
  ]), fnt(t, e));
}
const fnt = vI(async (t, e) => {
  if (t.isDisposed) return;
  const { url: n } = e.props, r = await t.getAssetForExternalContent({ type: "url", url: n });
  r && t.run(() => {
    t.createAssets([r]), t.updateShapes([
      {
        id: e.id,
        type: e.type,
        props: { assetId: r.id }
      }
    ]);
  });
}, 500);
function Ow(t, e = !1) {
  const n = t.length;
  if (n < 2)
    return "";
  let r = t[0].point, s = t[1].point;
  if (n === 2)
    return `M${eo(r)}L${eo(s)}`;
  let o = "";
  for (let i = 2, a = n - 1; i < a; i++)
    r = t[i].point, s = t[i + 1].point, o += Oi(r, s);
  return e ? `M${Oi(t[0].point, t[1].point)}Q${eo(t[1].point)}${Oi(
    t[1].point,
    t[2].point
  )}T${o}${Oi(t[n - 1].point, t[0].point)}${Oi(
    t[0].point,
    t[1].point
  )}Z` : `M${eo(t[0].point)}Q${eo(t[1].point)}${Oi(
    t[1].point,
    t[2].point
  )}${t.length > 3 ? "T" : ""}${o}L${eo(t[n - 1].point)}`;
}
function hnt(t, e = {}) {
  const { start: n = {}, end: r = {} } = e, { cap: s = !0 } = n, { cap: o = !0 } = r;
  tt(!n.taper && !r.taper, "cap taper not supported here"), tt(!n.easing && !r.easing, "cap easing not supported here"), tt(s && o, "cap must be true");
  const i = Lf(t, e);
  z5(i, e);
  const a = pnt(i);
  let c = "";
  for (const l of a)
    c += mnt(l, e);
  return c;
}
function pnt(t) {
  if (t.length <= 2) return [t];
  const e = [];
  let n = [t[0]], r = I.Sub(t[1].point, t[0].point).uni(), s, o, i, a, c;
  for (let l = 1, d = t.length; l < d - 1; l++) {
    if (i = t[l - 1], a = t[l], c = t[l + 1], s = I.Sub(c.point, a.point).uni(), o = I.Dpr(r, s), r = s, o < -0.8) {
      const u = {
        ...a,
        point: a.input
      };
      n.push(u), e.push(QO(n)), n = [u];
      continue;
    }
    if (n.push(a), !(o > 0.7) && (I.Dist2(i.point, a.point) + I.Dist2(a.point, c.point)) / ((i.radius + a.radius + c.radius) / 3) ** 2 < 1.5) {
      n.push(a), e.push(QO(n)), n = [a];
      continue;
    }
  }
  return n.push(t[t.length - 1]), e.push(QO(n)), e;
}
function QO(t) {
  const e = t[0];
  let n;
  for (; t.length > 2 && (n = t[1], I.Dist2(e.point, n.point) < ((e.radius + n.radius) / 2 * 0.5) ** 2); )
    t.splice(1, 1);
  const r = t[t.length - 1];
  let s;
  for (; t.length > 2 && (s = t[t.length - 2], I.Dist2(r.point, s.point) < ((r.radius + s.radius) / 2 * 0.5) ** 2); )
    t.splice(t.length - 2, 1);
  return t.length > 1 && (t[0] = {
    ...t[0],
    vector: I.Sub(t[0].point, t[1].point).uni()
  }, t[t.length - 1] = {
    ...t[t.length - 1],
    vector: I.Sub(
      t[t.length - 2].point,
      t[t.length - 1].point
    ).uni()
  }), t;
}
function gnt(t, e, n) {
  return "M " + t + " " + e + " m -" + n + ", 0 a " + n + "," + n + " 0 1,1 " + n * 2 + ",0 a " + n + "," + n + " 0 1,1 -" + n * 2 + ",0";
}
function mnt(t, e = {}) {
  if (t.length === 0) return "";
  if (t.length === 1)
    return gnt(t[0].point.x, t[0].point.y, t[0].radius);
  const { left: n, right: r } = _ue(t, e);
  r.reverse();
  let s = `M${eo(n[0])}T`;
  for (let o = 1; o < n.length; o++)
    s += Oi(n[o - 1], n[o]);
  {
    const o = t[t.length - 1], i = o.radius, a = o.vector.clone().per().neg(), c = I.Add(o.point, I.Mul(a, i)), l = I.Add(o.point, I.Mul(a, -i));
    s += `${eo(c)}A${ne(i)},${ne(
      i
    )} 0 0 1 ${eo(l)}T`;
  }
  for (let o = 1; o < r.length; o++)
    s += Oi(r[o - 1], r[o]);
  {
    const o = t[0], i = o.radius, a = o.vector.clone().per(), c = I.Add(o.point, I.Mul(a, i)), l = I.Add(o.point, I.Mul(a, -i));
    s += `${eo(c)}A${ne(i)},${ne(
      i
    )} 0 0 1 ${eo(l)}Z`;
  }
  return s;
}
const pfe = (t, e, n) => {
  const r = [], s = [];
  t.forEach((l) => r.push(...l.points)), e.forEach((l) => s.push(...l.points));
  const o = Math.max(r.length, s.length), i = [], a = [];
  for (let l = 0; l < o; l++)
    i.push(r[l] || r[r.length - 1]), a.push(s[l] || s[s.length - 1]);
  return [
    {
      type: "free",
      points: i.map((l, d) => {
        let u = 0.5;
        return a[d].z !== void 0 && l.z !== void 0 && (u = kt(l.z, a[d].z, n)), {
          x: kt(l.x, a[d].x, n),
          y: kt(l.y, a[d].y, n),
          z: u
        };
      })
    }
  ];
}, ynt = (t) => t * 0.65 + M4e(t * mn / 2) * 0.35, vnt = (t) => ({
  size: t,
  thinning: 0.5,
  streamline: ql(t, [9, 16], [0.64, 0.74], !0),
  // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
  smoothing: 0.62,
  easing: Mo.easeOutSine,
  simulatePressure: !0
}), bnt = (t) => ({
  size: 1 + t * 1.2,
  thinning: 0.62,
  streamline: 0.62,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: ynt
}), e7 = (t) => ({
  size: t,
  thinning: 0,
  streamline: ql(t, [9, 16], [0.64, 0.74], !0),
  // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: Mo.linear
}), xnt = (t) => ({
  size: t,
  thinning: 0,
  streamline: 0.62,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: Mo.linear
});
function c4({
  strokeWidth: t,
  showAsComplete: e
}) {
  return {
    size: 1 + t,
    thinning: 0,
    streamline: 0.5,
    smoothing: 0.5,
    simulatePressure: !1,
    easing: Mo.easeOutSine,
    last: e
  };
}
function PR(t, e, n, r) {
  const s = t.isComplete || n;
  return r ? t.isPen ? { ...xnt(e), last: s } : { ...e7(e), last: s } : t.dash === "draw" ? t.isPen ? { ...bnt(e), last: s } : { ...vnt(e), last: s } : { ...e7(e), last: s };
}
function vy(t) {
  const e = [];
  for (const n of t)
    if (n.type === "free" || n.points.length < 2)
      e.push(...n.points.map(I.Cast));
    else {
      const r = Math.max(
        4,
        Math.floor(I.Dist(n.points[0], n.points[1]) / 16)
      );
      e.push(...I.PointsBetween(n.points[0], n.points[1], r));
    }
  return e;
}
function wnt(t, e, n) {
  return {
    draw: "none",
    solid: "none",
    dotted: `${n} ${e * 2}`,
    dashed: `${e * 2} ${e * 2}`
  }[t.props.dash];
}
class g_ extends sc {
  constructor() {
    super(...arguments);
    P(this, "options", {
      maxPointsPerShape: 600
    });
  }
  hideResizeHandles(n) {
    return JO(n);
  }
  hideRotateHandle(n) {
    return JO(n);
  }
  hideSelectionBoundsFg(n) {
    return JO(n);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      isComplete: !1,
      isClosed: !1,
      isPen: !1,
      scale: 1
    };
  }
  getGeometry(n) {
    const r = vy(n.props.segments), s = (ys[n.props.size] + 1) * n.props.scale;
    if (n.props.segments.length === 1) {
      const i = _e.FromPoints(r);
      if (i.width < s * 2 && i.height < s * 2)
        return new VE({
          x: -s,
          y: -s,
          radius: s,
          isFilled: !0
        });
    }
    const o = Lf(
      r,
      PR(n.props, s, n.props.isPen, !0)
    ).map((i) => i.point);
    return n.props.isClosed && o.length > 2 ? new uw({
      points: o,
      isFilled: n.props.fill !== "none"
    }) : o.length === 1 ? new VE({
      x: -s,
      y: -s,
      radius: s,
      isFilled: !0
    }) : new Q0({
      points: o
    });
  }
  component(n) {
    return /* @__PURE__ */ h.jsx(jf, { children: /* @__PURE__ */ h.jsx(t7, { shape: n }) });
  }
  indicator(n) {
    var d;
    const r = vy(n.props.segments);
    let s = (ys[n.props.size] + 1) * n.props.scale;
    !le(
      "force solid",
      () => {
        const u = this.editor.getZoomLevel();
        return u < 0.5 && u < 1.5 / s;
      },
      [this.editor, s]
    ) && !n.props.isPen && n.props.dash === "draw" && r.length === 1 && (s += lg(n.id)() * (s / 6));
    const i = n.props.isComplete || ((d = Qs(n.props.segments)) == null ? void 0 : d.type) === "straight", a = PR(n.props, s, i, !0), c = Lf(r, a), l = c.length > 1 ? Ow(c, n.props.isClosed) : gfe(r[0], s);
    return /* @__PURE__ */ h.jsx("path", { d: l });
  }
  toSvg(n, r) {
    r.addExportDef(o4(n.props.fill));
    const s = 1 / n.props.scale;
    return /* @__PURE__ */ h.jsx("g", { transform: `scale(${s})`, children: /* @__PURE__ */ h.jsx(t7, { shape: n, zoomOverride: 1 }) });
  }
  getCanvasSvgDefs() {
    return [i4()];
  }
  onResize(n, r) {
    const { scaleX: s, scaleY: o } = r, i = [];
    for (const a of n.props.segments)
      i.push({
        ...a,
        points: a.points.map(({ x: c, y: l, z: d }) => ({
          x: Nc(s * c),
          y: Nc(o * l),
          z: d
        }))
      });
    return {
      props: {
        segments: i
      }
    };
  }
  expandSelectionOutlinePx(n) {
    const r = n.props.dash === "draw" ? 1.6 : 1;
    return ys[n.props.size] * r / 2 * n.props.scale;
  }
  getInterpolatedProps(n, r, s) {
    return {
      ...s > 0.5 ? r.props : n.props,
      segments: pfe(n.props.segments, r.props.segments, s),
      scale: kt(n.props.scale, r.props.scale, s)
    };
  }
}
P(g_, "type", "draw"), P(g_, "props", Dte), P(g_, "migrations", Nte);
function gfe(t, e) {
  const n = (e + 1) * 0.5;
  return `M ${t.x} ${t.y} m -${n}, 0 a ${n},${n} 0 1,0 ${n * 2},0 a ${n},${n} 0 1,0 -${n * 2},0`;
}
function JO(t) {
  return t.props.segments.length === 1 && t.props.segments[0].points.length < 2;
}
function t7({ shape: t, zoomOverride: e }) {
  var p;
  const n = mc(), r = ie(), s = vy(t.props.segments), o = t.props.isComplete || ((p = Qs(t.props.segments)) == null ? void 0 : p.type) === "straight";
  let i = (ys[t.props.size] + 1) * t.props.scale;
  const a = le(
    "force solid",
    () => {
      const g = e ?? r.getZoomLevel();
      return g < 0.5 && g < 1.5 / i;
    },
    [r, i, e]
  ), c = le(
    "dot adjustment",
    () => (e ?? r.getZoomLevel()) < 0.2 ? 0 : 0.1,
    [r, e]
  );
  !a && !t.props.isPen && t.props.dash === "draw" && s.length === 1 && (i += lg(t.id)() * (i / 6));
  const l = PR(t.props, i, o, a);
  if (!a && t.props.dash === "draw")
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      t.props.isClosed && t.props.fill && s.length > 1 ? /* @__PURE__ */ h.jsx(
        Mw,
        {
          d: Ow(
            Lf(s, l),
            t.props.isClosed
          ),
          theme: n,
          color: t.props.color,
          fill: t.props.isClosed ? t.props.fill : "none",
          scale: t.props.scale
        }
      ) : null,
      /* @__PURE__ */ h.jsx(
        "path",
        {
          d: hnt(s, l),
          strokeLinecap: "round",
          fill: n[t.props.color].solid
        }
      )
    ] });
  const d = Lf(s, l), u = d.length < 2, f = u ? gfe(s[0], 0) : Ow(d, t.props.isClosed);
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(
      Mw,
      {
        d: f,
        theme: n,
        color: t.props.color,
        fill: u || t.props.isClosed ? t.props.fill : "none",
        scale: t.props.scale
      }
    ),
    /* @__PURE__ */ h.jsx(
      "path",
      {
        d: f,
        strokeLinecap: "round",
        fill: u ? n[t.props.color].solid : "none",
        stroke: n[t.props.color].solid,
        strokeWidth: i,
        strokeDasharray: u ? "none" : wnt(t, i, c),
        strokeDashoffset: "0"
      }
    )
  ] });
}
function Snt(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Cnt(t, e) {
  const n = bt(e);
  if (!n) return;
  const r = n.host.replace("www.", "");
  for (const s of t)
    if (mfe(s.hostnames, r)) {
      const o = s.fromEmbedUrl(e);
      if (o)
        return {
          definition: s,
          url: o,
          embedUrl: e
        };
    }
}
const _nt = (t) => t.split("*").map((e) => Snt(e)).join(".+"), mfe = (t, e) => !!t.find((n) => {
  const r = new RegExp(_nt(n));
  return e.match(r);
});
function Ent(t, e) {
  const n = bt(e);
  if (!n) return;
  const r = n.host.replace("www.", "");
  for (const s of t)
    if (mfe(s.hostnames, r)) {
      const o = s.toEmbedUrl(e);
      if (o)
        return {
          definition: s,
          embedUrl: o,
          url: e
        };
    }
}
function Tnt(t, e) {
  try {
    return Ent(t, e) ?? Cnt(t, e);
  } catch {
    return;
  }
}
const Pnt = (t) => Object.entries(t).filter(([e, n]) => n).map(([e]) => e).join(" "), Ld = class Ld extends uv {
  static setEmbedDefinitions(e) {
    Ld.embedDefinitions = e;
  }
  getEmbedDefinitions() {
    return Ld.embedDefinitions;
  }
  getEmbedDefinition(e) {
    return Tnt(Ld.embedDefinitions, e);
  }
  getText(e) {
    return e.props.url;
  }
  getAriaDescriptor(e) {
    const n = this.getEmbedDefinition(e.props.url);
    return n == null ? void 0 : n.definition.title;
  }
  hideSelectionBoundsFg(e) {
    return !this.canResize(e);
  }
  canEdit() {
    return !0;
  }
  canResize(e) {
    var n, r;
    return !!((r = (n = this.getEmbedDefinition(e.props.url)) == null ? void 0 : n.definition) != null && r.doesResize);
  }
  canEditInReadonly() {
    return !0;
  }
  getDefaultProps() {
    return {
      w: 300,
      h: 300,
      url: ""
    };
  }
  isAspectRatioLocked(e) {
    const n = this.getEmbedDefinition(e.props.url);
    return (n == null ? void 0 : n.definition.isAspectRatioLocked) ?? !1;
  }
  onResize(e, n) {
    const r = this.isAspectRatioLocked(e), s = this.getEmbedDefinition(e.props.url);
    let o = (s == null ? void 0 : s.definition.minWidth) ?? 200, i = (s == null ? void 0 : s.definition.minHeight) ?? 200;
    if (r) {
      const a = e.props.w / e.props.h;
      a > 1 ? o *= a : i /= a;
    }
    return iS(e, n, { minWidth: o, minHeight: i });
  }
  component(e) {
    const n = J0(), { w: r, h: s, url: o } = e.props, i = aS(e.id), a = this.getEmbedDefinition(o), c = le(
      "is hovering",
      () => {
        const { editingShapeId: p, hoveredShapeId: g } = this.editor.getCurrentPageState();
        if (p && g !== p) {
          const y = this.editor.getShape(p);
          if (y && this.editor.isShapeOfType(y, "embed"))
            return !0;
        }
        return !1;
      },
      []
    ), l = this.editor.getShapePageTransform(e).rotation();
    if (n)
      return /* @__PURE__ */ h.jsx(Zd, { className: "tl-embed-container", id: e.id, children: /* @__PURE__ */ h.jsx(
        "div",
        {
          className: "tl-embed",
          style: {
            border: 0,
            boxShadow: GT(l),
            borderRadius: (a == null ? void 0 : a.definition.overrideOutlineRadius) ?? 8,
            background: (a == null ? void 0 : a.definition.backgroundColor) ?? "var(--color-background)",
            width: r,
            height: s
          }
        }
      ) });
    const d = i || c;
    if (typeof window < "u" && (window !== window.top || window.self !== window.parent) && (a == null ? void 0 : a.definition.type) === "tldraw") return null;
    if ((a == null ? void 0 : a.definition.type) === "github_gist") {
      const p = a.url.split("/").pop();
      if (!p) throw Error("No gist id!");
      return /* @__PURE__ */ h.jsx(Zd, { className: "tl-embed-container", id: e.id, children: /* @__PURE__ */ h.jsx(
        Int,
        {
          id: p,
          width: ne(r),
          height: ne(s),
          isInteractive: d,
          pageRotation: l
        }
      ) });
    }
    const f = Pnt({
      ...tZe,
      ...(a == null ? void 0 : a.definition.overridePermissions) ?? {}
    });
    return /* @__PURE__ */ h.jsx(Zd, { className: "tl-embed-container", id: e.id, children: a != null && a.definition ? /* @__PURE__ */ h.jsx(
      "iframe",
      {
        className: "tl-embed",
        sandbox: f,
        src: a.embedUrl,
        width: ne(r),
        height: ne(s),
        draggable: !1,
        frameBorder: "0",
        referrerPolicy: "no-referrer-when-downgrade",
        tabIndex: i ? 0 : -1,
        style: {
          border: 0,
          pointerEvents: d ? "auto" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: d ? "" : "-1",
          boxShadow: GT(l),
          borderRadius: (a == null ? void 0 : a.definition.overrideOutlineRadius) ?? 8,
          background: a == null ? void 0 : a.definition.backgroundColor
        }
      }
    ) : null });
  }
  indicator(e) {
    const n = this.getEmbedDefinition(e.props.url);
    return /* @__PURE__ */ h.jsx(
      "rect",
      {
        width: ne(e.props.w),
        height: ne(e.props.h),
        rx: (n == null ? void 0 : n.definition.overrideOutlineRadius) ?? 8,
        ry: (n == null ? void 0 : n.definition.overrideOutlineRadius) ?? 8
      }
    );
  }
  getInterpolatedProps(e, n, r) {
    return {
      ...r > 0.5 ? n.props : e.props,
      w: kt(e.props.w, n.props.w, r),
      h: kt(e.props.h, n.props.h, r)
    };
  }
};
P(Ld, "type", "embed"), P(Ld, "props", jte), P(Ld, "migrations", Rte), P(Ld, "embedDefinitions", D5);
let YT = Ld;
function Int({
  id: t,
  isInteractive: e,
  width: n,
  height: r,
  style: s,
  pageRotation: o
}) {
  if (!t.match(/^[0-9a-f]+$/)) throw Error("No gist id!");
  return /* @__PURE__ */ h.jsx(
    "iframe",
    {
      className: "tl-embed",
      draggable: !1,
      width: ne(n),
      height: ne(r),
      frameBorder: "0",
      scrolling: "no",
      referrerPolicy: "no-referrer-when-downgrade",
      tabIndex: e ? 0 : -1,
      style: {
        ...s,
        pointerEvents: e ? "all" : "none",
        // Fix for safari <https://stackoverflow.com/a/49150908>
        zIndex: e ? "" : "-1",
        boxShadow: GT(o)
      },
      srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${`https://gist.github.com/${t}.js`}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
    }
  );
}
function IR(t, e) {
  const s = ((RE(t.getShapePageTransform(e.id).rotation()) + Math.PI / 4) * (2 / Math.PI) + 4) % 4;
  return Math.floor(s);
}
const n7 = /* @__PURE__ */ new WeakMap();
function r7(t, e, n) {
  if (process.env.NODE_ENV === "test")
    return new _e(0, -n.height, e.props.w, n.height);
  let r = n7.get(e.props);
  if (!r) {
    const s = l4(e.props.name, "Frame") + "", o = t.textMeasure.measureTextSpans(s, n), i = o[0], a = Qs(o);
    r = a.box.w + a.box.x - i.box.x, n7.set(e.props, r);
  }
  return new _e(0, -n.height, r, n.height);
}
function s7(t, e) {
  return {
    fontSize: 12,
    fontFamily: e ? "Arial" : "Inter, sans-serif",
    textAlign: "start",
    width: t,
    height: 24,
    // --frame-height
    padding: 0,
    lineHeight: 1,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "truncate-ellipsis",
    verticalTextAlign: "middle",
    offsetY: -34,
    // --frame-minimum-height + (border width * 2)
    offsetX: 0
  };
}
function yfe(t, e, n) {
  const r = n ? "" : "px", s = n ? "" : "deg";
  let o;
  switch (e) {
    case 0:
      o = "";
      break;
    case 3:
      o = `translate(${ne(t.props.w)}${r}, 0${r}) rotate(90${s})`;
      break;
    case 2:
      o = `translate(${ne(t.props.w)}${r}, ${ne(
        t.props.h
      )}${r}) rotate(180${s})`;
      break;
    case 1:
      o = `translate(0${r}, ${ne(t.props.h)}${r}) rotate(270${s})`;
      break;
    default:
      throw Error("labelSide out of bounds");
  }
  return o;
}
const knt = du(({ id: t, name: e, isEditing: n }, r) => {
  const s = ie(), o = re(
    (c) => {
      c.key === "Enter" && !c.nativeEvent.isComposing && (cr(c), c.currentTarget.blur(), s.setEditingShape(null));
    },
    [s]
  ), i = re(
    (c) => {
      const l = s.getShape(t);
      if (!l) return;
      const d = l.props.name, u = c.currentTarget.value.trim();
      d !== u && s.updateShapes([
        {
          id: t,
          type: "frame",
          props: { name: u }
        }
      ]);
    },
    [t, s]
  ), a = re(
    (c) => {
      const l = s.getShape(t);
      if (!l) return;
      const d = l.props.name, u = c.currentTarget.value;
      d !== u && s.updateShapes([
        {
          id: t,
          type: "frame",
          props: { name: u }
        }
      ]);
    },
    [t, s]
  );
  return /* @__PURE__ */ h.jsxs("div", { className: `tl-frame-label ${n ? "tl-frame-label__editing" : ""}`, children: [
    /* @__PURE__ */ h.jsx(
      "input",
      {
        className: "tl-frame-name-input",
        ref: r,
        disabled: !n,
        readOnly: !n,
        style: { display: n ? void 0 : "none" },
        value: e,
        autoFocus: !0,
        onKeyDown: o,
        onBlur: i,
        onChange: a,
        onPointerDown: n ? cr : void 0,
        draggable: !1
      }
    ),
    l4(e, "Frame") + ""
  ] });
}), Ant = it(function({
  id: e,
  name: n,
  width: r,
  height: s,
  fill: o,
  stroke: i,
  color: a,
  offsetX: c,
  showColors: l
}) {
  const d = ie(), { side: u, translation: f } = le(
    "shape rotation",
    () => {
      const y = d.getShape(e);
      if (!y)
        return {
          side: 0,
          translation: "translate(0, 0)"
        };
      const m = IR(d, y);
      return {
        side: m,
        translation: yfe(y, m, !1)
      };
    },
    [d, c, e]
  ), p = fe(null), g = aS(e);
  return me(() => {
    const y = p.current;
    y && g && (y.focus(), y.select());
  }, [p, g]), /* @__PURE__ */ h.jsx(
    "div",
    {
      className: "tl-frame-heading",
      style: {
        overflow: g ? "visible" : "hidden",
        maxWidth: `calc(var(--tl-zoom) * ${Math.ceil(u === 0 || u === 2 ? r : s)}px + ${l ? "0px" : "var(--frame-offset-width)"})`,
        bottom: "100%",
        transform: `${f} scale(var(--tl-scale)) translateX(${c}px)`
      },
      children: /* @__PURE__ */ h.jsx(
        "div",
        {
          className: "tl-frame-heading-hit-area",
          style: { color: a, backgroundColor: o, boxShadow: `inset 0px 0px 0px 1px ${i}` },
          children: /* @__PURE__ */ h.jsx(knt, { ref: p, id: e, name: n, isEditing: g })
        }
      )
    }
  );
}), Mnt = 12, Ont = 32, Dnt = -7, Nnt = 4;
function l4(t, e) {
  return t.match(/^\s*$/) ? e : t;
}
class m_ extends uv {
  constructor() {
    super(...arguments);
    P(this, "options", {
      showColors: !1
    });
  }
  // evil crimes :)
  // By default, showColors is off. Because they use style props, which are picked up
  // automatically, we don't have DefaultColorStyle in the props in the schema by default.
  // Instead, when someone calls .configure to turn the option on, we manually add in the color
  // style here so it plays nicely with the other editor APIs.
  static configure(n) {
    const r = super.configure.call(this, n);
    return n.showColors && (r.props = { ...r.props, color: di }), r;
  }
  canEdit() {
    return !0;
  }
  canResize() {
    return !0;
  }
  canResizeChildren() {
    return !1;
  }
  getDefaultProps() {
    return { w: 160 * 2, h: 90 * 2, name: "", color: "black" };
  }
  getAriaDescriptor(n) {
    return n.props.name;
  }
  getGeometry(n) {
    const { editor: r } = this, s = r.getZoomLevel(), o = IR(r, n), i = o % 2 === 1, a = i ? n.props.h : n.props.w, c = s7(a, !1), l = r7(r, n, c), d = this.options.showColors, u = Mnt / s, f = Ont / s, p = a + (d ? 1 : u), g = l.w / s, y = l.h / s, m = wt(g + u, f, p), v = (d ? -1 : Dnt) / s, b = Nnt / s, x = i ? y : m, w = i ? m : y;
    let S, C;
    switch (o) {
      case 0: {
        S = v, C = -(y + b);
        break;
      }
      case 1: {
        S = -(y + b), C = n.props.h - (v + m);
        break;
      }
      case 2: {
        S = n.props.w - (v + m), C = n.props.h + b;
        break;
      }
      case 3: {
        S = n.props.w + b, C = v;
        break;
      }
    }
    return new ui({
      children: [
        new ol({
          width: n.props.w,
          height: n.props.h,
          isFilled: !1
        }),
        new ol({
          x: S,
          y: C,
          width: x,
          height: w,
          isFilled: !0,
          isLabel: !0
        })
      ]
    });
  }
  getText(n) {
    return n.props.name;
  }
  component(n) {
    const r = mc(), s = le(
      "is creating this shape",
      () => {
        const f = this.editor.getStateDescendant("select.resizing");
        if (!f || !f.getIsActive()) return !1;
        const p = f == null ? void 0 : f.info;
        return p ? p.isCreating && this.editor.getOnlySelectedShapeId() === n.id : !1;
      },
      [n.id]
    ), o = this.options.showColors, i = r[n.props.color], a = o ? i.frame.fill : r.black.frame.fill, c = o ? i.frame.stroke : r.black.frame.stroke, l = o ? i.frame.headingStroke : r.background, d = o ? i.frame.headingFill : r.background, u = o ? i.frame.text : r.text;
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(jf, { children: /* @__PURE__ */ h.jsx(
        "rect",
        {
          className: Je("tl-frame__body", { "tl-frame__creating": s }),
          fill: a,
          stroke: c,
          style: {
            width: `calc(${n.props.w}px + 1px / var(--tl-zoom))`,
            height: `calc(${n.props.h}px + 1px / var(--tl-zoom))`,
            transform: "translate(calc(-0.5px / var(--tl-zoom)), calc(-0.5px / var(--tl-zoom)))"
          }
        }
      ) }),
      s ? null : /* @__PURE__ */ h.jsx(
        Ant,
        {
          id: n.id,
          name: n.props.name,
          fill: d,
          stroke: l,
          color: u,
          width: n.props.w,
          height: n.props.h,
          offsetX: o ? -1 : -7,
          showColors: this.options.showColors
        }
      )
    ] });
  }
  toSvg(n, r) {
    const s = mu({ isDarkMode: r.isDarkMode }), o = IR(this.editor, n), a = o % 2 === 1 ? n.props.h : n.props.w, c = yfe(n, o, !0), l = s7(a - 12, !0), d = l4(n.props.name, "Frame") + "", u = r7(this.editor, n, l), f = this.editor.textMeasure.measureTextSpans(d, l), p = ER(this.editor, f, l), g = this.options.showColors, y = s[n.props.color], m = g ? y.frame.fill : s.black.frame.fill, v = g ? y.frame.stroke : s.black.frame.stroke, b = g ? y.frame.headingStroke : s.background, x = g ? y.frame.headingFill : s.background, w = g ? y.frame.text : s.text;
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(
        "rect",
        {
          width: n.props.w,
          height: n.props.h,
          fill: m,
          stroke: v,
          strokeWidth: 1,
          x: 0,
          rx: 0,
          ry: 0
        }
      ),
      /* @__PURE__ */ h.jsxs("g", { fill: w, transform: c, children: [
        /* @__PURE__ */ h.jsx(
          "rect",
          {
            x: u.x - (g ? 0 : 6),
            y: u.y - 6,
            width: Math.min(a, u.width + 12),
            height: u.height,
            fill: x,
            stroke: b,
            rx: 4,
            ry: 4
          }
        ),
        /* @__PURE__ */ h.jsx("g", { transform: `translate(${g ? 8 : 0}, 4)`, children: p })
      ] })
    ] });
  }
  indicator(n) {
    return /* @__PURE__ */ h.jsx(
      "rect",
      {
        width: ne(n.props.w),
        height: ne(n.props.h),
        className: "tl-frame-indicator"
      }
    );
  }
  providesBackgroundForChildren() {
    return !0;
  }
  canReceiveNewChildrenOfType(n) {
    return !n.isLocked;
  }
  onResize(n, r) {
    return iS(n, r);
  }
  getInterpolatedProps(n, r, s) {
    return {
      ...s > 0.5 ? r.props : n.props,
      w: kt(n.props.w, r.props.w, s),
      h: kt(n.props.h, r.props.h, s)
    };
  }
  onDoubleClickEdge(n, r) {
    if (r.target !== "selection") return;
    const { handle: s } = r;
    if (!s) return;
    const o = s === "left" || s === "right", i = s === "top" || s === "bottom", a = this.editor.getSortedChildIdsForParent(n.id), c = mt(a.map((p) => this.editor.getShape(p)));
    if (!c.length) return;
    const { dx: l, dy: d, w: u, h: f } = iue(c, this.editor, { padding: 10 });
    return this.editor.run(() => {
      const p = a.map((g) => {
        const y = this.editor.getShape(g);
        return {
          id: y.id,
          type: y.type,
          x: o ? y.x + l : y.x,
          y: i ? y.y + d : y.y
        };
      });
      this.editor.updateShapes(p);
    }), {
      id: n.id,
      type: n.type,
      props: {
        w: o ? u : n.props.w,
        h: i ? f : n.props.h
      }
    };
  }
  onDoubleClickCorner(n) {
    return aue(this.editor, n.id, { padding: 10 }), {
      id: n.id,
      type: n.type
    };
  }
  onDragShapesIn(n, r, { initialParentIds: s, initialIndices: o }) {
    const { editor: i } = this;
    if (r.every((l) => l.parentId === n.id)) return;
    let a = !1;
    const c = r.filter((l) => n.id === s.get(l.id));
    if (c.length > 0) {
      const l = mt(
        i.getSortedChildIdsForParent(n).map((d) => i.getShape(d))
      );
      c.every((d) => !l.find((u) => u.index === d.index)) && (a = !0);
    }
    if (!r.some((l) => i.hasAncestor(n, l.id)) && (i.reparentShapes(r, n.id), a))
      for (const l of c)
        i.updateShape({
          id: l.id,
          type: l.type,
          index: o.get(l.id)
        });
  }
  onDragShapesOut(n, r, s) {
    const { editor: o } = this;
    s.nextDraggingOverShapeId || o.reparentShapes(
      r.filter(
        (i) => i.parentId === n.id && this.canReceiveNewChildrenOfType(i)
      ),
      o.getCurrentPageId()
    );
  }
}
P(m_, "type", "frame"), P(m_, "props", $te), P(m_, "migrations", Lte);
var Ui = "top", uc = "bottom", fc = "right", Hi = "left", d4 = "auto", vS = [Ui, uc, fc, Hi], by = "start", Dw = "end", jnt = "clippingParents", vfe = "viewport", lb = "popper", Rnt = "reference", o7 = /* @__PURE__ */ vS.reduce(function(t, e) {
  return t.concat([e + "-" + by, e + "-" + Dw]);
}, []), u4 = /* @__PURE__ */ [].concat(vS, [d4]).reduce(function(t, e) {
  return t.concat([e, e + "-" + by, e + "-" + Dw]);
}, []), $nt = "beforeRead", Lnt = "read", Fnt = "afterRead", Bnt = "beforeMain", znt = "main", Unt = "afterMain", Hnt = "beforeWrite", Vnt = "write", Wnt = "afterWrite", Knt = [$nt, Lnt, Fnt, Bnt, znt, Unt, Hnt, Vnt, Wnt];
function Bf(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function Ta(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Fp(t) {
  var e = Ta(t).Element;
  return t instanceof e || t instanceof Element;
}
function Hl(t) {
  var e = Ta(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function f4(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Ta(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function Vl(t) {
  return t.split("-")[0];
}
var fp = Math.max, qT = Math.min, xy = Math.round;
function kR() {
  var t = navigator.userAgentData;
  return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function bfe() {
  return !/^((?!chrome|android).)*safari/i.test(kR());
}
function wy(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var r = t.getBoundingClientRect(), s = 1, o = 1;
  e && Hl(t) && (s = t.offsetWidth > 0 && xy(r.width) / t.offsetWidth || 1, o = t.offsetHeight > 0 && xy(r.height) / t.offsetHeight || 1);
  var i = Fp(t) ? Ta(t) : window, a = i.visualViewport, c = !bfe() && n, l = (r.left + (c && a ? a.offsetLeft : 0)) / s, d = (r.top + (c && a ? a.offsetTop : 0)) / o, u = r.width / s, f = r.height / o;
  return {
    width: u,
    height: f,
    top: d,
    right: l + u,
    bottom: d + f,
    left: l,
    x: l,
    y: d
  };
}
function h4(t) {
  var e = wy(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: r
  };
}
function xfe(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && f4(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function iu(t) {
  return Ta(t).getComputedStyle(t);
}
function Gnt(t) {
  return ["table", "td", "th"].indexOf(Bf(t)) >= 0;
}
function dh(t) {
  return ((Fp(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function zk(t) {
  return Bf(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (f4(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    dh(t)
  );
}
function i7(t) {
  return !Hl(t) || // https://github.com/popperjs/popper-core/issues/837
  iu(t).position === "fixed" ? null : t.offsetParent;
}
function Ynt(t) {
  var e = /firefox/i.test(kR()), n = /Trident/i.test(kR());
  if (n && Hl(t)) {
    var r = iu(t);
    if (r.position === "fixed")
      return null;
  }
  var s = zk(t);
  for (f4(s) && (s = s.host); Hl(s) && ["html", "body"].indexOf(Bf(s)) < 0; ) {
    var o = iu(s);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none")
      return s;
    s = s.parentNode;
  }
  return null;
}
function bS(t) {
  for (var e = Ta(t), n = i7(t); n && Gnt(n) && iu(n).position === "static"; )
    n = i7(n);
  return n && (Bf(n) === "html" || Bf(n) === "body" && iu(n).position === "static") ? e : n || Ynt(t) || e;
}
function p4(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function Ox(t, e, n) {
  return fp(t, qT(e, n));
}
function qnt(t, e, n) {
  var r = Ox(t, e, n);
  return r > n ? n : r;
}
function wfe() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Sfe(t) {
  return Object.assign({}, wfe(), t);
}
function Cfe(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var Xnt = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, Sfe(typeof e != "number" ? e : Cfe(e, vS));
};
function Znt(t) {
  var e, n = t.state, r = t.name, s = t.options, o = n.elements.arrow, i = n.modifiersData.popperOffsets, a = Vl(n.placement), c = p4(a), l = [Hi, fc].indexOf(a) >= 0, d = l ? "height" : "width";
  if (!(!o || !i)) {
    var u = Xnt(s.padding, n), f = h4(o), p = c === "y" ? Ui : Hi, g = c === "y" ? uc : fc, y = n.rects.reference[d] + n.rects.reference[c] - i[c] - n.rects.popper[d], m = i[c] - n.rects.reference[c], v = bS(o), b = v ? c === "y" ? v.clientHeight || 0 : v.clientWidth || 0 : 0, x = y / 2 - m / 2, w = u[p], S = b - f[d] - u[g], C = b / 2 - f[d] / 2 + x, _ = Ox(w, C, S), E = c;
    n.modifiersData[r] = (e = {}, e[E] = _, e.centerOffset = _ - C, e);
  }
}
function Qnt(t) {
  var e = t.state, n = t.options, r = n.element, s = r === void 0 ? "[data-popper-arrow]" : r;
  s != null && (typeof s == "string" && (s = e.elements.popper.querySelector(s), !s) || xfe(e.elements.popper, s) && (e.elements.arrow = s));
}
const Jnt = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Znt,
  effect: Qnt,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Sy(t) {
  return t.split("-")[1];
}
var ert = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function trt(t, e) {
  var n = t.x, r = t.y, s = e.devicePixelRatio || 1;
  return {
    x: xy(n * s) / s || 0,
    y: xy(r * s) / s || 0
  };
}
function a7(t) {
  var e, n = t.popper, r = t.popperRect, s = t.placement, o = t.variation, i = t.offsets, a = t.position, c = t.gpuAcceleration, l = t.adaptive, d = t.roundOffsets, u = t.isFixed, f = i.x, p = f === void 0 ? 0 : f, g = i.y, y = g === void 0 ? 0 : g, m = typeof d == "function" ? d({
    x: p,
    y
  }) : {
    x: p,
    y
  };
  p = m.x, y = m.y;
  var v = i.hasOwnProperty("x"), b = i.hasOwnProperty("y"), x = Hi, w = Ui, S = window;
  if (l) {
    var C = bS(n), _ = "clientHeight", E = "clientWidth";
    if (C === Ta(n) && (C = dh(n), iu(C).position !== "static" && a === "absolute" && (_ = "scrollHeight", E = "scrollWidth")), C = C, s === Ui || (s === Hi || s === fc) && o === Dw) {
      w = uc;
      var M = u && C === S && S.visualViewport ? S.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        C[_]
      );
      y -= M - r.height, y *= c ? 1 : -1;
    }
    if (s === Hi || (s === Ui || s === uc) && o === Dw) {
      x = fc;
      var N = u && C === S && S.visualViewport ? S.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        C[E]
      );
      p -= N - r.width, p *= c ? 1 : -1;
    }
  }
  var O = Object.assign({
    position: a
  }, l && ert), D = d === !0 ? trt({
    x: p,
    y
  }, Ta(n)) : {
    x: p,
    y
  };
  if (p = D.x, y = D.y, c) {
    var k;
    return Object.assign({}, O, (k = {}, k[w] = b ? "0" : "", k[x] = v ? "0" : "", k.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + y + "px)" : "translate3d(" + p + "px, " + y + "px, 0)", k));
  }
  return Object.assign({}, O, (e = {}, e[w] = b ? y + "px" : "", e[x] = v ? p + "px" : "", e.transform = "", e));
}
function nrt(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, s = r === void 0 ? !0 : r, o = n.adaptive, i = o === void 0 ? !0 : o, a = n.roundOffsets, c = a === void 0 ? !0 : a, l = {
    placement: Vl(e.placement),
    variation: Sy(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: s,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, a7(Object.assign({}, l, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: i,
    roundOffsets: c
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, a7(Object.assign({}, l, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: c
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const rrt = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: nrt,
  data: {}
};
var sC = {
  passive: !0
};
function srt(t) {
  var e = t.state, n = t.instance, r = t.options, s = r.scroll, o = s === void 0 ? !0 : s, i = r.resize, a = i === void 0 ? !0 : i, c = Ta(e.elements.popper), l = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return o && l.forEach(function(d) {
    d.addEventListener("scroll", n.update, sC);
  }), a && c.addEventListener("resize", n.update, sC), function() {
    o && l.forEach(function(d) {
      d.removeEventListener("scroll", n.update, sC);
    }), a && c.removeEventListener("resize", n.update, sC);
  };
}
const ort = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: srt,
  data: {}
};
var irt = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function y_(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return irt[e];
  });
}
var art = {
  start: "end",
  end: "start"
};
function c7(t) {
  return t.replace(/start|end/g, function(e) {
    return art[e];
  });
}
function g4(t) {
  var e = Ta(t), n = e.pageXOffset, r = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function m4(t) {
  return wy(dh(t)).left + g4(t).scrollLeft;
}
function crt(t, e) {
  var n = Ta(t), r = dh(t), s = n.visualViewport, o = r.clientWidth, i = r.clientHeight, a = 0, c = 0;
  if (s) {
    o = s.width, i = s.height;
    var l = bfe();
    (l || !l && e === "fixed") && (a = s.offsetLeft, c = s.offsetTop);
  }
  return {
    width: o,
    height: i,
    x: a + m4(t),
    y: c
  };
}
function lrt(t) {
  var e, n = dh(t), r = g4(t), s = (e = t.ownerDocument) == null ? void 0 : e.body, o = fp(n.scrollWidth, n.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), i = fp(n.scrollHeight, n.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0), a = -r.scrollLeft + m4(t), c = -r.scrollTop;
  return iu(s || n).direction === "rtl" && (a += fp(n.clientWidth, s ? s.clientWidth : 0) - o), {
    width: o,
    height: i,
    x: a,
    y: c
  };
}
function y4(t) {
  var e = iu(t), n = e.overflow, r = e.overflowX, s = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + s + r);
}
function _fe(t) {
  return ["html", "body", "#document"].indexOf(Bf(t)) >= 0 ? t.ownerDocument.body : Hl(t) && y4(t) ? t : _fe(zk(t));
}
function Dx(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = _fe(t), s = r === ((n = t.ownerDocument) == null ? void 0 : n.body), o = Ta(r), i = s ? [o].concat(o.visualViewport || [], y4(r) ? r : []) : r, a = e.concat(i);
  return s ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Dx(zk(i)))
  );
}
function AR(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function drt(t, e) {
  var n = wy(t, !1, e === "fixed");
  return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n;
}
function l7(t, e, n) {
  return e === vfe ? AR(crt(t, n)) : Fp(e) ? drt(e, n) : AR(lrt(dh(t)));
}
function urt(t) {
  var e = Dx(zk(t)), n = ["absolute", "fixed"].indexOf(iu(t).position) >= 0, r = n && Hl(t) ? bS(t) : t;
  return Fp(r) ? e.filter(function(s) {
    return Fp(s) && xfe(s, r) && Bf(s) !== "body";
  }) : [];
}
function frt(t, e, n, r) {
  var s = e === "clippingParents" ? urt(t) : [].concat(e), o = [].concat(s, [n]), i = o[0], a = o.reduce(function(c, l) {
    var d = l7(t, l, r);
    return c.top = fp(d.top, c.top), c.right = qT(d.right, c.right), c.bottom = qT(d.bottom, c.bottom), c.left = fp(d.left, c.left), c;
  }, l7(t, i, r));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Efe(t) {
  var e = t.reference, n = t.element, r = t.placement, s = r ? Vl(r) : null, o = r ? Sy(r) : null, i = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, c;
  switch (s) {
    case Ui:
      c = {
        x: i,
        y: e.y - n.height
      };
      break;
    case uc:
      c = {
        x: i,
        y: e.y + e.height
      };
      break;
    case fc:
      c = {
        x: e.x + e.width,
        y: a
      };
      break;
    case Hi:
      c = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      c = {
        x: e.x,
        y: e.y
      };
  }
  var l = s ? p4(s) : null;
  if (l != null) {
    var d = l === "y" ? "height" : "width";
    switch (o) {
      case by:
        c[l] = c[l] - (e[d] / 2 - n[d] / 2);
        break;
      case Dw:
        c[l] = c[l] + (e[d] / 2 - n[d] / 2);
        break;
    }
  }
  return c;
}
function Nw(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, s = r === void 0 ? t.placement : r, o = n.strategy, i = o === void 0 ? t.strategy : o, a = n.boundary, c = a === void 0 ? jnt : a, l = n.rootBoundary, d = l === void 0 ? vfe : l, u = n.elementContext, f = u === void 0 ? lb : u, p = n.altBoundary, g = p === void 0 ? !1 : p, y = n.padding, m = y === void 0 ? 0 : y, v = Sfe(typeof m != "number" ? m : Cfe(m, vS)), b = f === lb ? Rnt : lb, x = t.rects.popper, w = t.elements[g ? b : f], S = frt(Fp(w) ? w : w.contextElement || dh(t.elements.popper), c, d, i), C = wy(t.elements.reference), _ = Efe({
    reference: C,
    element: x,
    strategy: "absolute",
    placement: s
  }), E = AR(Object.assign({}, x, _)), M = f === lb ? E : C, N = {
    top: S.top - M.top + v.top,
    bottom: M.bottom - S.bottom + v.bottom,
    left: S.left - M.left + v.left,
    right: M.right - S.right + v.right
  }, O = t.modifiersData.offset;
  if (f === lb && O) {
    var D = O[s];
    Object.keys(N).forEach(function(k) {
      var A = [fc, uc].indexOf(k) >= 0 ? 1 : -1, R = [Ui, uc].indexOf(k) >= 0 ? "y" : "x";
      N[k] += D[R] * A;
    });
  }
  return N;
}
function hrt(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, s = n.boundary, o = n.rootBoundary, i = n.padding, a = n.flipVariations, c = n.allowedAutoPlacements, l = c === void 0 ? u4 : c, d = Sy(r), u = d ? a ? o7 : o7.filter(function(g) {
    return Sy(g) === d;
  }) : vS, f = u.filter(function(g) {
    return l.indexOf(g) >= 0;
  });
  f.length === 0 && (f = u);
  var p = f.reduce(function(g, y) {
    return g[y] = Nw(t, {
      placement: y,
      boundary: s,
      rootBoundary: o,
      padding: i
    })[Vl(y)], g;
  }, {});
  return Object.keys(p).sort(function(g, y) {
    return p[g] - p[y];
  });
}
function prt(t) {
  if (Vl(t) === d4)
    return [];
  var e = y_(t);
  return [c7(t), e, c7(e)];
}
function grt(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var s = n.mainAxis, o = s === void 0 ? !0 : s, i = n.altAxis, a = i === void 0 ? !0 : i, c = n.fallbackPlacements, l = n.padding, d = n.boundary, u = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, g = p === void 0 ? !0 : p, y = n.allowedAutoPlacements, m = e.options.placement, v = Vl(m), b = v === m, x = c || (b || !g ? [y_(m)] : prt(m)), w = [m].concat(x).reduce(function(Z, K) {
      return Z.concat(Vl(K) === d4 ? hrt(e, {
        placement: K,
        boundary: d,
        rootBoundary: u,
        padding: l,
        flipVariations: g,
        allowedAutoPlacements: y
      }) : K);
    }, []), S = e.rects.reference, C = e.rects.popper, _ = /* @__PURE__ */ new Map(), E = !0, M = w[0], N = 0; N < w.length; N++) {
      var O = w[N], D = Vl(O), k = Sy(O) === by, A = [Ui, uc].indexOf(D) >= 0, R = A ? "width" : "height", j = Nw(e, {
        placement: O,
        boundary: d,
        rootBoundary: u,
        altBoundary: f,
        padding: l
      }), $ = A ? k ? fc : Hi : k ? uc : Ui;
      S[R] > C[R] && ($ = y_($));
      var F = y_($), L = [];
      if (o && L.push(j[D] <= 0), a && L.push(j[$] <= 0, j[F] <= 0), L.every(function(Z) {
        return Z;
      })) {
        M = O, E = !1;
        break;
      }
      _.set(O, L);
    }
    if (E)
      for (var z = g ? 3 : 1, H = function(K) {
        var oe = w.find(function(Y) {
          var ee = _.get(Y);
          if (ee)
            return ee.slice(0, K).every(function(ae) {
              return ae;
            });
        });
        if (oe)
          return M = oe, "break";
      }, U = z; U > 0; U--) {
        var W = H(U);
        if (W === "break") break;
      }
    e.placement !== M && (e.modifiersData[r]._skip = !0, e.placement = M, e.reset = !0);
  }
}
const mrt = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: grt,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function d7(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function u7(t) {
  return [Ui, fc, uc, Hi].some(function(e) {
    return t[e] >= 0;
  });
}
function yrt(t) {
  var e = t.state, n = t.name, r = e.rects.reference, s = e.rects.popper, o = e.modifiersData.preventOverflow, i = Nw(e, {
    elementContext: "reference"
  }), a = Nw(e, {
    altBoundary: !0
  }), c = d7(i, r), l = d7(a, s, o), d = u7(c), u = u7(l);
  e.modifiersData[n] = {
    referenceClippingOffsets: c,
    popperEscapeOffsets: l,
    isReferenceHidden: d,
    hasPopperEscaped: u
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": d,
    "data-popper-escaped": u
  });
}
const vrt = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: yrt
};
function brt(t, e, n) {
  var r = Vl(t), s = [Hi, Ui].indexOf(r) >= 0 ? -1 : 1, o = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, i = o[0], a = o[1];
  return i = i || 0, a = (a || 0) * s, [Hi, fc].indexOf(r) >= 0 ? {
    x: a,
    y: i
  } : {
    x: i,
    y: a
  };
}
function xrt(t) {
  var e = t.state, n = t.options, r = t.name, s = n.offset, o = s === void 0 ? [0, 0] : s, i = u4.reduce(function(d, u) {
    return d[u] = brt(u, e.rects, o), d;
  }, {}), a = i[e.placement], c = a.x, l = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += c, e.modifiersData.popperOffsets.y += l), e.modifiersData[r] = i;
}
const wrt = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: xrt
};
function Srt(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = Efe({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const Crt = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Srt,
  data: {}
};
function _rt(t) {
  return t === "x" ? "y" : "x";
}
function Ert(t) {
  var e = t.state, n = t.options, r = t.name, s = n.mainAxis, o = s === void 0 ? !0 : s, i = n.altAxis, a = i === void 0 ? !1 : i, c = n.boundary, l = n.rootBoundary, d = n.altBoundary, u = n.padding, f = n.tether, p = f === void 0 ? !0 : f, g = n.tetherOffset, y = g === void 0 ? 0 : g, m = Nw(e, {
    boundary: c,
    rootBoundary: l,
    padding: u,
    altBoundary: d
  }), v = Vl(e.placement), b = Sy(e.placement), x = !b, w = p4(v), S = _rt(w), C = e.modifiersData.popperOffsets, _ = e.rects.reference, E = e.rects.popper, M = typeof y == "function" ? y(Object.assign({}, e.rects, {
    placement: e.placement
  })) : y, N = typeof M == "number" ? {
    mainAxis: M,
    altAxis: M
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, M), O = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, D = {
    x: 0,
    y: 0
  };
  if (C) {
    if (o) {
      var k, A = w === "y" ? Ui : Hi, R = w === "y" ? uc : fc, j = w === "y" ? "height" : "width", $ = C[w], F = $ + m[A], L = $ - m[R], z = p ? -E[j] / 2 : 0, H = b === by ? _[j] : E[j], U = b === by ? -E[j] : -_[j], W = e.elements.arrow, Z = p && W ? h4(W) : {
        width: 0,
        height: 0
      }, K = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : wfe(), oe = K[A], Y = K[R], ee = Ox(0, _[j], Z[j]), ae = x ? _[j] / 2 - z - ee - oe - N.mainAxis : H - ee - oe - N.mainAxis, de = x ? -_[j] / 2 + z + ee + Y + N.mainAxis : U + ee + Y + N.mainAxis, ye = e.elements.arrow && bS(e.elements.arrow), G = ye ? w === "y" ? ye.clientTop || 0 : ye.clientLeft || 0 : 0, xe = (k = O == null ? void 0 : O[w]) != null ? k : 0, ge = $ + ae - xe - G, ze = $ + de - xe, Ge = Ox(p ? qT(F, ge) : F, $, p ? fp(L, ze) : L);
      C[w] = Ge, D[w] = Ge - $;
    }
    if (a) {
      var Ct, vn = w === "x" ? Ui : Hi, Yt = w === "x" ? uc : fc, X = C[S], ce = S === "y" ? "height" : "width", pe = X + m[vn], Ie = X - m[Yt], ke = [Ui, Hi].indexOf(v) !== -1, Ce = (Ct = O == null ? void 0 : O[S]) != null ? Ct : 0, De = ke ? pe : X - _[ce] - E[ce] - Ce + N.altAxis, ot = ke ? X + _[ce] + E[ce] - Ce - N.altAxis : Ie, Nt = p && ke ? qnt(De, X, ot) : Ox(p ? De : pe, X, p ? ot : Ie);
      C[S] = Nt, D[S] = Nt - X;
    }
    e.modifiersData[r] = D;
  }
}
const Trt = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Ert,
  requiresIfExists: ["offset"]
};
function Prt(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function Irt(t) {
  return t === Ta(t) || !Hl(t) ? g4(t) : Prt(t);
}
function krt(t) {
  var e = t.getBoundingClientRect(), n = xy(e.width) / t.offsetWidth || 1, r = xy(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function Art(t, e, n) {
  n === void 0 && (n = !1);
  var r = Hl(e), s = Hl(e) && krt(e), o = dh(e), i = wy(t, s, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((Bf(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  y4(o)) && (a = Irt(e)), Hl(e) ? (c = wy(e, !0), c.x += e.clientLeft, c.y += e.clientTop) : o && (c.x = m4(o))), {
    x: i.left + a.scrollLeft - c.x,
    y: i.top + a.scrollTop - c.y,
    width: i.width,
    height: i.height
  };
}
function Mrt(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(o) {
    e.set(o.name, o);
  });
  function s(o) {
    n.add(o.name);
    var i = [].concat(o.requires || [], o.requiresIfExists || []);
    i.forEach(function(a) {
      if (!n.has(a)) {
        var c = e.get(a);
        c && s(c);
      }
    }), r.push(o);
  }
  return t.forEach(function(o) {
    n.has(o.name) || s(o);
  }), r;
}
function Ort(t) {
  var e = Mrt(t);
  return Knt.reduce(function(n, r) {
    return n.concat(e.filter(function(s) {
      return s.phase === r;
    }));
  }, []);
}
function Drt(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function Nrt(t) {
  var e = t.reduce(function(n, r) {
    var s = n[r.name];
    return n[r.name] = s ? Object.assign({}, s, r, {
      options: Object.assign({}, s.options, r.options),
      data: Object.assign({}, s.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var f7 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function h7() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function jrt(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, s = e.defaultOptions, o = s === void 0 ? f7 : s;
  return function(a, c, l) {
    l === void 0 && (l = o);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, f7, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: c
      },
      attributes: {},
      styles: {}
    }, u = [], f = !1, p = {
      state: d,
      setOptions: function(v) {
        var b = typeof v == "function" ? v(d.options) : v;
        y(), d.options = Object.assign({}, o, d.options, b), d.scrollParents = {
          reference: Fp(a) ? Dx(a) : a.contextElement ? Dx(a.contextElement) : [],
          popper: Dx(c)
        };
        var x = Ort(Nrt([].concat(r, d.options.modifiers)));
        return d.orderedModifiers = x.filter(function(w) {
          return w.enabled;
        }), g(), p.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var v = d.elements, b = v.reference, x = v.popper;
          if (h7(b, x)) {
            d.rects = {
              reference: Art(b, bS(x), d.options.strategy === "fixed"),
              popper: h4(x)
            }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function(N) {
              return d.modifiersData[N.name] = Object.assign({}, N.data);
            });
            for (var w = 0; w < d.orderedModifiers.length; w++) {
              if (d.reset === !0) {
                d.reset = !1, w = -1;
                continue;
              }
              var S = d.orderedModifiers[w], C = S.fn, _ = S.options, E = _ === void 0 ? {} : _, M = S.name;
              typeof C == "function" && (d = C({
                state: d,
                options: E,
                name: M,
                instance: p
              }) || d);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Drt(function() {
        return new Promise(function(m) {
          p.forceUpdate(), m(d);
        });
      }),
      destroy: function() {
        y(), f = !0;
      }
    };
    if (!h7(a, c))
      return p;
    p.setOptions(l).then(function(m) {
      !f && l.onFirstUpdate && l.onFirstUpdate(m);
    });
    function g() {
      d.orderedModifiers.forEach(function(m) {
        var v = m.name, b = m.options, x = b === void 0 ? {} : b, w = m.effect;
        if (typeof w == "function") {
          var S = w({
            state: d,
            name: v,
            instance: p,
            options: x
          }), C = function() {
          };
          u.push(S || C);
        }
      });
    }
    function y() {
      u.forEach(function(m) {
        return m();
      }), u = [];
    }
    return p;
  };
}
const Rrt = B.forwardRef(function({
  shapeId: e,
  isEditing: n,
  richText: r,
  handleFocus: s,
  handleChange: o,
  handleBlur: i,
  handleKeyDown: a,
  handleDoubleClick: c,
  hasCustomTabBehavior: l,
  handlePaste: d
}, u) {
  const f = ie(), p = gg("tip-tap-editor"), g = f.getTextOptions().tipTapConfig, y = fe(r), m = fe(null), v = fe(null);
  un(() => {
    m.current ? y.current !== r && m.current.commands.setContent(r) : y.current = r;
  }, [r]);
  const b = fe({
    selectAll: !1,
    caretPosition: null
  });
  un(() => {
    function M(O) {
      O.shapeId === f.getEditingShapeId() && (b.current.selectAll = !0);
    }
    function N(O) {
      O.shapeId === f.getEditingShapeId() && (b.current.caretPosition = O.point);
    }
    return f.on("select-all-text", M), f.on("place-caret", N), () => {
      f.off("select-all-text", M), f.off("place-caret", N);
    };
  }, [f, n]);
  const x = kl(o), w = kl(a), S = kl(s), C = kl(i), _ = kl(c), E = kl(d);
  return un(() => {
    if (!n || !g || !v.current) return;
    const { editorProps: M, ...N } = g, O = new dGe({
      element: v.current,
      autofocus: !0,
      editable: n,
      onUpdate: (k) => {
        const A = k.editor.state.doc.toJSON();
        y.current = A, x({ richText: A });
      },
      onFocus: S,
      onBlur: C,
      // onCreate is called after a `setTimeout(0)`
      onCreate: (k) => {
        var $;
        if (f.getEditingShapeId() !== e) return;
        const A = k.editor;
        f.setRichTextEditor(A);
        const { selectAll: R, caretPosition: j } = b.current;
        if (R)
          A.chain().focus().selectAll().run();
        else if (j) {
          const F = ($ = A.view.posAtCoords({
            left: j.x,
            top: j.y
          })) == null ? void 0 : $.pos;
          F ? A.chain().focus().setTextSelection(F).run() : A.chain().focus().selectAll().run();
        }
      },
      editorProps: {
        handleKeyDown: (k, A) => {
          !l && A.key === "Tab" && $rt(f, k, A), w(A);
        },
        handlePaste: (k, A) => {
          if (E(A), A.defaultPrevented) return !0;
        },
        handleDoubleClick: (k, A, R) => _(R),
        ...M
      },
      coreExtensionOptions: {
        clipboardTextSerializer: {
          blockSeparator: `
`
        }
      },
      ...N,
      content: y.current
    }), D = f.timers.setTimeout(() => {
      b.current.caretPosition || b.current.selectAll ? O.commands.focus() : O.commands.focus("end"), b.current.selectAll = !1, b.current.caretPosition = null;
    }, 100);
    return m.current = O, () => {
      m.current = null, clearTimeout(D), O.destroy();
    };
  }, [
    n,
    g,
    S,
    C,
    _,
    x,
    E,
    w,
    f,
    e,
    l
  ]), !n || !g ? null : /* @__PURE__ */ h.jsx(
    "div",
    {
      id: p,
      ref: u,
      tabIndex: -1,
      "data-testid": "rich-text-area",
      className: "tl-rich-text tl-text tl-text-input",
      onContextMenu: n ? cr : void 0,
      onPointerDownCapture: cr,
      onTouchEnd: cr,
      onDragStart: xt,
      children: /* @__PURE__ */ h.jsx("div", { className: "tl-rich-text", ref: v })
    }
  );
});
function $rt(t, e, n) {
  n.preventDefault();
  const r = t.getRichTextEditor();
  if (r != null && r.isActive("bulletList") || r != null && r.isActive("orderedList")) return;
  const { state: s, dispatch: o } = e, { $from: i, $to: a } = s.selection, c = n.shiftKey;
  let l = s.tr, d = a.end();
  for (; d >= i.start(); ) {
    const f = s.doc.resolve(d).blockRange();
    if (!f) break;
    const p = f.start, g = f.end, y = s.doc.textBetween(p, g, `
`);
    let m = !1;
    s.doc.nodesBetween(p, g, (v) => {
      if (v.type.name === "bulletList" || v.type.name === "orderedList")
        return m = !0, !1;
    }), m || (c ? y.startsWith("	") && (l = l.delete(p + 1, p + 2)) : l = l.insertText("	", p + 1)), d = p - 1;
  }
  const u = s.selection.map(l.doc, l.mapping);
  l.setSelection(u), l.docChanged && o(l);
}
function Lrt(t, e, n) {
  const r = sfe(t), s = r.isEditing, o = ie(), i = fe(null), a = n && Ai(n);
  me(() => {
    var u;
    if (!s) return;
    const d = (u = i.current) == null ? void 0 : u.querySelector("[contenteditable]");
    d && document.activeElement !== i.current && d.focus();
  }, [o, s]);
  const c = re(
    (d) => {
      o.getEditingShapeId() === t && d.key === "Enter" && ms(d) && o.complete();
    },
    [o, t]
  ), l = re(
    ({ richText: d }) => {
      o.getEditingShapeId() === t && o.updateShape({
        id: t,
        type: e,
        props: { richText: d }
      });
    },
    [o, t, e]
  );
  return {
    rInput: i,
    handleKeyDown: c,
    handleChange: l,
    isEmpty: a,
    ...r
  };
}
const v4 = B.memo(function({
  shapeId: e,
  type: n,
  richText: r,
  labelColor: s,
  font: o,
  fontSize: i,
  lineHeight: a,
  align: c,
  verticalAlign: l,
  wrap: d,
  isSelected: u,
  padding: f = 0,
  onKeyDown: p,
  classNamePrefix: g,
  style: y,
  textWidth: m,
  textHeight: v,
  hasCustomTabBehavior: b
}) {
  const x = ie(), w = B.useRef(!1), { rInput: S, isEmpty: C, isEditing: _, isReadyForEditing: E, ...M } = Lrt(e, n, r), N = Ke(() => {
    if (r)
      return t4(x, r);
  }, [x, r]), O = le(
    "isSelectToolActive",
    () => x.getCurrentToolId() === "select",
    [x]
  );
  UF(
    "isDragging",
    () => {
      x.getInstanceState(), w.current = x.inputs.isDragging;
    },
    [x]
  );
  const D = rfe(c), k = (R) => {
    var j;
    if (R.target instanceof HTMLElement && (R.target.tagName === "A" || R.target.closest("a"))) {
      if (xt(R), !O) return;
      const $ = ((j = R.target.closest("a")) == null ? void 0 : j.getAttribute("href")) ?? "", F = (L) => {
        L.name === "pointer_up" && (w.current || window.open($, "_blank", "noopener, noreferrer"), x.off("event", F));
      };
      x.on("event", F);
    }
  };
  if (!_ && C) return null;
  const A = g || "tl-text";
  return /* @__PURE__ */ h.jsx(
    "div",
    {
      className: `${A}-label tl-text-wrapper tl-rich-text-wrapper`,
      "aria-hidden": !_,
      "data-font": o,
      "data-align": c,
      "data-hastext": !C,
      "data-isediting": _,
      "data-textwrap": !!d,
      "data-isselected": u,
      style: {
        justifyContent: c === "middle" || D ? "center" : c,
        alignItems: l === "middle" ? "center" : l,
        padding: f,
        ...y
      },
      children: /* @__PURE__ */ h.jsxs(
        "div",
        {
          className: `${A}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize: i,
            lineHeight: a.toString(),
            minHeight: Math.floor(i * a) + "px",
            minWidth: Math.ceil(m || 0),
            color: s,
            width: m ? Math.ceil(m) : void 0,
            height: v ? Math.ceil(v) : void 0
          },
          children: [
            /* @__PURE__ */ h.jsx("div", { className: `${A} tl-text tl-text-content`, dir: "auto", children: r && /* @__PURE__ */ h.jsx(
              "div",
              {
                className: "tl-rich-text",
                "data-is-select-tool-active": O,
                dangerouslySetInnerHTML: { __html: N || "" },
                onPointerDown: k,
                "data-is-ready-for-editing": E
              }
            ) }),
            (E || u) && /* @__PURE__ */ h.jsx(
              Rrt,
              {
                ref: S,
                richText: r,
                isEditing: _,
                shapeId: e,
                ...M,
                hasCustomTabBehavior: b,
                handleKeyDown: p ?? M.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});
function b4({
  bounds: t,
  richText: e,
  fontSize: n,
  font: r,
  align: s,
  verticalAlign: o,
  wrap: i,
  labelColor: a,
  padding: c,
  showTextOutline: l = !0
}) {
  const d = ie(), u = t4(d, e), f = s === "middle" ? "center" : s === "start" ? "start" : "end", p = s === "middle" ? "center" : s === "start" ? "flex-start" : "flex-end", g = o === "middle" ? "center" : o === "start" ? "flex-start" : "flex-end", y = {
    display: "flex",
    fontFamily: wte[r],
    height: "100%",
    justifyContent: p,
    alignItems: g,
    padding: `${c}px`
  }, m = {
    fontSize: `${n}px`,
    wrap: i ? "wrap" : "nowrap",
    color: a,
    lineHeight: Oo.lineHeight,
    textAlign: f,
    width: "100%",
    wordWrap: "break-word",
    overflowWrap: "break-word",
    whiteSpace: "pre-wrap",
    textShadow: l ? "var(--tl-text-outline)" : "none"
  };
  return /* @__PURE__ */ h.jsx(
    "foreignObject",
    {
      x: t.minX,
      y: t.minY,
      width: t.w,
      height: t.h,
      className: "tl-export-embed-styles tl-rich-text tl-rich-text-svg",
      children: /* @__PURE__ */ h.jsx("div", { style: y, children: /* @__PURE__ */ h.jsx("div", { dangerouslySetInnerHTML: { __html: u }, style: m }) })
    }
  );
}
const Frt = new No();
function MR(t) {
  return Frt.get(t, Brt);
}
function Brt(t) {
  const e = Math.max(1, t.props.w), n = Math.max(1, t.props.h + t.props.growY), r = e / 2, s = n / 2, o = da[t.props.size] * t.props.scale, i = t.props.fill !== "none";
  switch (t.props.geo) {
    case "arrow-down": {
      const a = e * 0.16, c = Math.min(e, n) * 0.38;
      return new ln().moveTo(a, 0, { geometry: { isFilled: i } }).lineTo(e - a, 0).lineTo(e - a, n - c).lineTo(e, n - c).lineTo(e / 2, n).lineTo(0, n - c).lineTo(a, n - c).close();
    }
    case "arrow-left": {
      const a = Math.min(e, n) * 0.38, c = n * 0.16;
      return new ln().moveTo(a, 0, { geometry: { isFilled: i } }).lineTo(a, c).lineTo(e, c).lineTo(e, n - c).lineTo(a, n - c).lineTo(a, n).lineTo(0, n / 2).close();
    }
    case "arrow-right": {
      const a = Math.min(e, n) * 0.38, c = n * 0.16;
      return new ln().moveTo(0, c, { geometry: { isFilled: i } }).lineTo(e - a, c).lineTo(e - a, 0).lineTo(e, n / 2).lineTo(e - a, n).lineTo(e - a, n - c).lineTo(0, n - c).close();
    }
    case "arrow-up": {
      const a = e * 0.16, c = Math.min(e, n) * 0.38;
      return new ln().moveTo(e / 2, 0, { geometry: { isFilled: i } }).lineTo(e, c).lineTo(e - a, c).lineTo(e - a, n).lineTo(a, n).lineTo(a, c).lineTo(0, c).close();
    }
    case "check-box": {
      const a = Math.min(e, n) * 0.82, c = (e - a) / 2, l = (n - a) / 2;
      return new ln().moveTo(0, 0, { geometry: { isFilled: i } }).lineTo(e, 0).lineTo(e, n).lineTo(0, n).close().moveTo(wt(c + a * 0.25, 0, e), wt(l + a * 0.52, 0, n), {
        geometry: { isInternal: !0, isFilled: !1 },
        offset: 0
      }).lineTo(wt(c + a * 0.45, 0, e), wt(l + a * 0.82, 0, n)).lineTo(wt(c + a * 0.82, 0, e), wt(l + a * 0.22, 0, n), { offset: 0 });
    }
    case "diamond":
      return new ln().moveTo(r, 0, { geometry: { isFilled: i } }).lineTo(e, s).lineTo(r, n).lineTo(0, s).close();
    case "ellipse":
      return new ln().moveTo(0, s, { geometry: { isFilled: i } }).arcTo(r, s, !1, !0, 0, e, s).arcTo(r, s, !1, !0, 0, 0, s).close();
    case "heart": {
      const a = e / 4, c = n / 4;
      return new ln().moveTo(r, n, { geometry: { isFilled: i } }).cubicBezierTo(0, c * 1.2, a * 1.5, c * 3, 0, c * 2.5).cubicBezierTo(r, c * 0.9, 0, -c * 0.32, a * 1.85, -c * 0.32).cubicBezierTo(e, c * 1.2, a * 2.15, -c * 0.32, e, -c * 0.32).cubicBezierTo(r, n, e, c * 2.5, a * 2.5, c * 3).close();
    }
    case "hexagon":
      return ln.lineThroughPoints(QM(e, n, 6), {
        geometry: { isFilled: i }
      }).close();
    case "octagon":
      return ln.lineThroughPoints(QM(e, n, 8), {
        geometry: { isFilled: i }
      }).close();
    case "oval":
      return Urt(e, n, i);
    case "pentagon":
      return ln.lineThroughPoints(QM(e, n, 5), {
        geometry: { isFilled: i }
      }).close();
    case "rectangle":
      return new ln().moveTo(0, 0, { geometry: { isFilled: i } }).lineTo(e, 0).lineTo(e, n).lineTo(0, n).close();
    case "rhombus": {
      const a = Math.min(e * 0.38, n * 0.38);
      return new ln().moveTo(a, 0, { geometry: { isFilled: i } }).lineTo(e, 0).lineTo(e - a, n).lineTo(0, n).close();
    }
    case "rhombus-2": {
      const a = Math.min(e * 0.38, n * 0.38);
      return new ln().moveTo(0, 0, { geometry: { isFilled: i } }).lineTo(e - a, 0).lineTo(e, n).lineTo(a, n).close();
    }
    case "star":
      return Hrt(e, n, i);
    case "trapezoid": {
      const a = Math.min(e * 0.38, n * 0.38);
      return new ln().moveTo(a, 0, { geometry: { isFilled: i } }).lineTo(e - a, 0).lineTo(e, n).lineTo(0, n).close();
    }
    case "triangle":
      return new ln().moveTo(r, 0, { geometry: { isFilled: i } }).lineTo(e, n).lineTo(0, n).close();
    case "x-box":
      return zrt(e, n, o, t.props.dash, i);
    case "cloud":
      return Grt(e, n, t.id, t.props.size, t.props.scale, i);
    default:
      Jt(t.props.geo);
  }
}
function zrt(t, e, n, r, s) {
  const o = t / 2, i = e / 2, a = new ln().moveTo(0, 0, { geometry: { isFilled: s } }).lineTo(t, 0).lineTo(t, e).lineTo(0, e).close();
  if (r === "dashed" || r === "dotted")
    return a.moveTo(0, 0, {
      geometry: { isInternal: !0, isFilled: !1 },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(o, i).moveTo(t, e, {
      geometry: { isInternal: !0, isFilled: !1 },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(o, i).moveTo(0, e, {
      geometry: { isInternal: !0, isFilled: !1 },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(o, i).moveTo(t, 0, {
      geometry: { isInternal: !0, isFilled: !1 },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(o, i);
  const c = r === "draw" ? 0.62 : 0;
  return a.moveTo(wt(n * c, 0, t), wt(n * c, 0, e), {
    geometry: { isInternal: !0, isFilled: !1 }
  }).lineTo(wt(t - n * c, 0, t), wt(e - n * c, 0, e)).moveTo(wt(t - n * c, 0, t), wt(n * c, 0, e)).lineTo(wt(n * c, 0, t), wt(e - n * c, 0, e)), a;
}
function Urt(t, e, n) {
  if (e > t) {
    const s = t / 2;
    return new ln().moveTo(0, s, { geometry: { isFilled: n } }).arcTo(s, s, !1, !0, 0, t, s).lineTo(t, e - s).arcTo(s, s, !1, !0, 0, 0, e - s).close();
  }
  const r = e / 2;
  return new ln().moveTo(r, e, { geometry: { isFilled: n } }).arcTo(r, r, !1, !0, 0, r, 0).lineTo(t - r, 0).arcTo(r, r, !1, !0, 0, t - r, e).close();
}
function Hrt(t, e, n) {
  const s = Bn / 5 / 2, o = Math.floor(5 / 4) * 2, i = 5 * 2 - o, a = 0, c = Math.floor(5 / 2) * 2, l = Math.cos(-ar + o * s) * t / 2, d = Math.cos(-ar + i * s) * t / 2, u = Math.sin(-ar + a * s) * e / 2, f = Math.sin(-ar + c * s) * e / 2, p = t - Math.abs(l - d), g = e - Math.abs(f - u), y = t / 2 + d - (t / 2 - l), m = e / 2 + u - (e / 2 - f), v = 1, b = (t - y) / 2, x = (e - m) / 2, w = (t + p) / 2, S = (e + g) / 2, C = w * v / 2, _ = S * v / 2;
  return ln.lineThroughPoints(
    Array.from(Array(5 * 2), (E, M) => {
      const N = -ar + M * s;
      return new I(
        b + (M % 2 ? C : w) * Math.cos(N),
        x + (M % 2 ? _ : S) * Math.sin(N)
      );
    }),
    { geometry: { isFilled: n } }
  ).close();
}
function p7(t, e) {
  return t > e ? (mn * (e / 2) + (t - e)) * 2 : (mn * (t / 2) + (e - t)) * 2;
}
function Vrt(t, e, n) {
  const r = Math.min(t, e) / 2, s = Math.max(t, e) - r * 2, i = (Math.PI * (r * 2) + 2 * s) / n, a = t > e ? [
    {
      type: "straight",
      start: new I(r, 0),
      delta: new I(1, 0)
    },
    {
      type: "arc",
      center: new I(t - r, r),
      startAngle: -mn / 2
    },
    {
      type: "straight",
      start: new I(t - r, e),
      delta: new I(-1, 0)
    },
    {
      type: "arc",
      center: new I(r, r),
      startAngle: mn / 2
    }
  ] : [
    {
      type: "straight",
      start: new I(t, r),
      delta: new I(0, 1)
    },
    {
      type: "arc",
      center: new I(r, e - r),
      startAngle: 0
    },
    {
      type: "straight",
      start: new I(0, e - r),
      delta: new I(0, -1)
    },
    {
      type: "arc",
      center: new I(r, r),
      startAngle: mn
    }
  ];
  let c = 0;
  const l = [];
  for (let d = 0; d < n; d++) {
    const u = a[0];
    u.type === "straight" ? l.push(I.Add(u.start, I.Mul(u.delta, c))) : l.push(
      d3(u.center, r, u.startAngle + c / r)
    ), c += i;
    let f = u.type === "straight" ? s : mn * r;
    for (; c > f; )
      c -= f, a.push(a.shift()), f = a[0].type === "straight" ? s : mn * r;
  }
  return l;
}
const Wrt = {
  s: 50,
  m: 70,
  l: 100,
  xl: 130
}, Krt = 0.2;
function Grt(t, e, n, r, s, o) {
  const i = new ln(), a = lg(n), c = p7(t, e), l = Math.max(
    Math.ceil(c / Wrt[r]),
    6,
    Math.ceil(c / Math.min(t, e))
  ), d = c / l * Krt, u = Math.max(t - d * 2, 1), f = Math.max(e - d * 2, 1), g = p7(u, f) / l, y = (t - u) / 2, m = (e - f) / 2, v = Vrt(u, f, l).map((S) => S.addXY(y, m)), b = t < 20 ? 0 : d * 0.3, x = e < 20 ? 0 : d * 0.3, w = v.slice(0);
  for (let S = 0; S < Math.floor(l / 2); S++)
    w[S] = I.AddXY(
      w[S],
      a() * b * s,
      a() * x * s
    ), w[l - S - 1] = I.AddXY(
      w[l - S - 1],
      a() * b * s,
      a() * x * s
    );
  for (let S = 0; S < w.length; S++) {
    const C = S === w.length - 1 ? 0 : S + 1, _ = w[S], E = w[C], M = v[S], N = v[C], O = I.Dist(M, N), D = g - O, A = I.Dist(_, E) / O, R = (Math.max(y, m) + D) * A, j = I.Lrp(M, N, 0.5).add(
      I.Sub(N, M).uni().per().mul(R)
    );
    j.x < 0 ? j.x = 0 : j.x > t && (j.x = t), j.y < 0 ? j.y = 0 : j.y > e && (j.y = e);
    const $ = nne(_, E, j), F = I.Dist(
      $ || I.Average([_, E]),
      _
    );
    S === 0 && i.moveTo(_.x, _.y, { geometry: { isFilled: o } }), i.circularArcTo(F, !1, !0, E.x, E.y);
  }
  return i.close();
}
function g7({
  shape: t,
  shouldScale: e,
  forceSolid: n
}) {
  const r = e ? t.props.scale : 1, s = mc(), { props: o } = t, { color: i, fill: a, dash: c, size: l } = o, d = ys[l] * r, u = MR(t), f = c === "draw" && !n ? u.toDrawD({ strokeWidth: d, randomSeed: t.id, passes: 1, offset: 0, onlyFilled: !0 }) : u.toD({ onlyFilled: !0 });
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(Mw, { theme: s, d: f, color: i, fill: a, scale: r }),
    u.toSvg({
      style: c,
      strokeWidth: d,
      forceSolid: n,
      randomSeed: t.id,
      props: { fill: "none", stroke: s[i].solid }
    })
  ] });
}
const m7 = 17 * 3;
class v_ extends uv {
  canEdit() {
    return !0;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      dash: "draw",
      growY: 0,
      url: "",
      scale: 1,
      // Text properties
      color: "black",
      labelColor: "black",
      fill: "none",
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      richText: dc("")
    };
  }
  getGeometry(e) {
    const n = Math.max(1, e.props.w), r = Math.max(1, e.props.h + e.props.growY), s = MR(e), o = oC(this.editor, e), i = n / e.props.scale, a = r / e.props.scale, c = Math.min(100, i / 2), l = Math.min(
      Ef[e.props.size] * Oo.lineHeight + ri * 2,
      a / 2
    ), d = Math.min(
      i,
      Math.max(o.w, Math.min(c, Math.max(1, i - 8)))
    ), u = Math.min(
      a,
      Math.max(o.h, Math.min(l, Math.max(1, a - 8)))
    );
    return new ui({
      children: [
        s.toGeometry(),
        new ol({
          x: e.props.align === "start" ? 0 : e.props.align === "end" ? (i - d) * e.props.scale : (i - d) / 2 * e.props.scale,
          y: e.props.verticalAlign === "start" ? 0 : e.props.verticalAlign === "end" ? (a - u) * e.props.scale : (a - u) / 2 * e.props.scale,
          width: d * e.props.scale,
          height: u * e.props.scale,
          isFilled: !0,
          isLabel: !0,
          isEmptyLabel: Ai(e.props.richText)
        })
      ]
    });
  }
  getHandleSnapGeometry(e) {
    const n = this.getGeometry(e), r = n.children[0];
    switch (e.props.geo) {
      case "arrow-down":
      case "arrow-left":
      case "arrow-right":
      case "arrow-up":
      case "check-box":
      case "diamond":
      case "hexagon":
      case "octagon":
      case "pentagon":
      case "rectangle":
      case "rhombus":
      case "rhombus-2":
      case "star":
      case "trapezoid":
      case "triangle":
      case "x-box":
        return { outline: r, points: [...r.vertices, n.bounds.center] };
      case "cloud":
      case "ellipse":
      case "heart":
      case "oval":
        return { outline: r, points: [n.bounds.center] };
      default:
        Jt(e.props.geo);
    }
  }
  getText(e) {
    return Lp(this.editor, e.props.richText);
  }
  getFontFaces(e) {
    return Ai(e.props.richText) ? Br : t5(this.editor, e.props.richText, {
      family: `tldraw_${e.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(e) {
    const { id: n, type: r, props: s } = e, { fill: o, font: i, align: a, verticalAlign: c, size: l, richText: d } = s, u = mc(), { editor: f } = this, p = le(
      "isGeoOnlySelected",
      () => e.id === f.getOnlySelectedShapeId(),
      [f]
    ), g = s4(f, e.id), y = Ai(e.props.richText), m = g || !y, v = le("force solid", () => f.getZoomLevel() < 0.2, [f]);
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(jf, { children: /* @__PURE__ */ h.jsx(g7, { shape: e, shouldScale: !0, forceSolid: v }) }),
      m && /* @__PURE__ */ h.jsx(
        Zd,
        {
          style: {
            overflow: "hidden",
            width: e.props.w,
            height: e.props.h + s.growY
          },
          children: /* @__PURE__ */ h.jsx(
            v4,
            {
              shapeId: n,
              type: r,
              font: i,
              fontSize: Ef[l] * e.props.scale,
              lineHeight: Oo.lineHeight,
              padding: ri * e.props.scale,
              fill: o,
              align: a,
              verticalAlign: c,
              richText: d,
              isSelected: p,
              labelColor: u[s.labelColor].solid,
              wrap: !0
            }
          )
        }
      ),
      e.props.url && /* @__PURE__ */ h.jsx(yy, { url: e.props.url })
    ] });
  }
  indicator(e) {
    const n = le("isZoomedOut", () => this.editor.getZoomLevel() < 0.25, [
      this.editor
    ]), { size: r, dash: s, scale: o } = e.props, i = ys[r];
    return MR(e).toSvg({
      style: s === "draw" ? "draw" : "solid",
      strokeWidth: 1,
      passes: 1,
      randomSeed: e.id,
      offset: 0,
      roundness: i * 2 * o,
      props: { strokeWidth: void 0 },
      forceSolid: n
    });
  }
  toSvg(e, n) {
    const r = e.props.scale, s = {
      ...e,
      props: {
        ...e.props,
        w: e.props.w / r,
        h: (e.props.h + e.props.growY) / r,
        growY: 0
        // growY throws off the path calculations, so we set it to 0
      }
    }, o = s.props;
    n.addExportDef(o4(o.fill));
    let i;
    if (!Ai(o.richText)) {
      const a = mu(n), c = new _e(0, 0, o.w, (e.props.h + e.props.growY) / r);
      i = /* @__PURE__ */ h.jsx(
        b4,
        {
          fontSize: Ef[o.size],
          font: o.font,
          align: o.align,
          verticalAlign: o.verticalAlign,
          richText: o.richText,
          labelColor: a[o.labelColor].solid,
          bounds: c,
          padding: ri
        }
      );
    }
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(g7, { shouldScale: !1, shape: s, forceSolid: !1 }),
      i
    ] });
  }
  getCanvasSvgDefs() {
    return [i4()];
  }
  onResize(e, { handle: n, newPoint: r, scaleX: s, scaleY: o, initialShape: i }) {
    const a = i.props.w / i.props.scale, c = i.props.h / i.props.scale, l = i.props.growY / i.props.scale;
    let d = a * s, u = (c + l) * o, f = 0, p = 0;
    const g = m7;
    if (!Ai(e.props.richText)) {
      let w = Math.max(Math.abs(d), g), S = Math.max(Math.abs(u), g);
      w < g && S === g && (w = g), w === g && S < g && (S = g);
      const C = oC(this.editor, {
        ...e,
        props: {
          ...e.props,
          w: w * e.props.scale,
          h: S * e.props.scale
        }
      }), _ = Math.max(Math.abs(d), C.w) * Math.sign(d), E = Math.max(Math.abs(u), C.h) * Math.sign(u);
      f = Math.abs(_) - Math.abs(d), p = Math.abs(E) - Math.abs(u), d = _, u = E;
    }
    const y = d * e.props.scale, m = u * e.props.scale, v = new I(0, 0);
    s < 0 && (v.x += y), (n === "left" || n === "top_left" || n === "bottom_left") && (v.x += s < 0 ? f : -f), o < 0 && (v.y += m), (n === "top" || n === "top_left" || n === "top_right") && (v.y += o < 0 ? p : -p);
    const { x: b, y: x } = v.rot(e.rotation).add(r);
    return {
      x: b,
      y: x,
      props: {
        w: Math.max(Math.abs(y), 1),
        h: Math.max(Math.abs(m), 1),
        growY: 0
      }
    };
  }
  onBeforeCreate(e) {
    if (Ai(e.props.richText))
      return e.props.growY ? {
        ...e,
        props: {
          ...e.props,
          growY: 0
        }
      } : void 0;
    const n = e.props.h / e.props.scale, r = oC(this.editor, e).h;
    let s = null;
    if (r > n ? s = r - n : e.props.growY && (s = 0), s !== null)
      return {
        ...e,
        props: {
          ...e.props,
          // scale the growY
          growY: s * e.props.scale
        }
      };
  }
  onBeforeUpdate(e, n) {
    if (Zf(e.props.richText, n.props.richText) && e.props.font === n.props.font && e.props.size === n.props.size)
      return;
    const r = Ai(e.props.richText), s = Ai(n.props.richText);
    if (!r && s)
      return {
        ...n,
        props: {
          ...n.props,
          growY: 0
        }
      };
    const o = e.props.w / e.props.scale, i = e.props.h / e.props.scale, a = e.props.growY / e.props.scale, c = oC(this.editor, n);
    if (r && !s && Lp(this.editor, n.props.richText)) {
      let d = Math.max(o, c.w), u = Math.max(i, c.h);
      const f = m7;
      return o < f && i < f && (d = Math.max(d, f), u = Math.max(u, f), d = Math.max(d, u), u = Math.max(d, u)), {
        ...n,
        props: {
          ...n.props,
          // Scale the results
          w: d * n.props.scale,
          h: u * n.props.scale,
          growY: 0
        }
      };
    }
    let l = null;
    if (c.h > i ? l = c.h - i : a && (l = 0), l !== null) {
      const d = n.props.w / n.props.scale;
      return {
        ...n,
        props: {
          ...n.props,
          // Scale the results
          growY: l * n.props.scale,
          w: Math.max(d, c.w) * n.props.scale
        }
      };
    }
    if (c.w > o)
      return {
        ...n,
        props: {
          ...n.props,
          // Scale the results
          w: c.w * n.props.scale
        }
      };
  }
  onDoubleClick(e) {
    if (this.editor.inputs.altKey)
      switch (e.props.geo) {
        case "rectangle":
          return {
            ...e,
            props: {
              geo: "check-box"
            }
          };
        case "check-box":
          return {
            ...e,
            props: {
              geo: "rectangle"
            }
          };
      }
  }
  getInterpolatedProps(e, n, r) {
    return {
      ...r > 0.5 ? n.props : e.props,
      w: kt(e.props.w, n.props.w, r),
      h: kt(e.props.h, n.props.h, r),
      scale: kt(e.props.scale, n.props.scale, r)
    };
  }
}
P(v_, "type", "geo"), P(v_, "props", Fte), P(v_, "migrations", Bte);
const Yrt = {
  s: 12,
  m: 14,
  l: 16,
  xl: 20
}, qrt = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function oC(t, e) {
  const { richText: n, font: r, size: s, w: o } = e.props;
  if (!n || Ai(n))
    return { w: 0, h: 0 };
  const i = Yrt[s], a = VT(t, n), c = t.textMeasure.measureHtml(a, {
    ...Oo,
    fontFamily: Ff[r],
    fontSize: Ef[s],
    minWidth: i,
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(i + qrt[s]),
      // The actual text size
      Math.ceil(o / e.props.scale - ri * 2)
    )
  });
  return {
    w: c.w + ri * 2,
    h: c.h + ri * 2
  };
}
function Xrt() {
  const [t, e] = he(!1);
  return me(() => {
    const r = CSS.supports("color", "color(display-p3 1 1 1)"), s = matchMedia("(color-gamut: p3)");
    e(r && s.matches);
    const o = () => e(r && s.matches);
    return s.addEventListener("change", o), () => s.removeEventListener("change", o);
  }, []), le(ir.forceSrgb) || !t ? "srgb" : "p3";
}
class b_ extends sc {
  constructor() {
    super(...arguments);
    P(this, "options", {
      maxPointsPerShape: 600,
      underlayOpacity: 0.82,
      overlayOpacity: 0.35
    });
  }
  hideResizeHandles(n) {
    return iC(n);
  }
  hideRotateHandle(n) {
    return iC(n);
  }
  hideSelectionBoundsFg(n) {
    return iC(n);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      size: "m",
      isComplete: !1,
      isPen: !1,
      scale: 1
    };
  }
  getGeometry(n) {
    const r = Ph(n);
    if (iC(n))
      return new VE({
        x: -r / 2,
        y: -r / 2,
        radius: r / 2,
        isFilled: !0
      });
    const { strokePoints: s, sw: o } = y7(n, r, !0), i = c4({ strokeWidth: o, showAsComplete: !0 });
    return z5(s, i), new uw({
      points: Eue(s, i),
      isFilled: !0
    });
  }
  component(n) {
    const r = e2(this.editor, n), s = Ph(n);
    return /* @__PURE__ */ h.jsx(jf, { children: /* @__PURE__ */ h.jsx(
      aC,
      {
        shape: n,
        forceSolid: r,
        strokeWidth: s,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  backgroundComponent(n) {
    const r = e2(this.editor, n), s = Ph(n);
    return /* @__PURE__ */ h.jsx(jf, { children: /* @__PURE__ */ h.jsx(
      aC,
      {
        shape: n,
        forceSolid: r,
        strokeWidth: s,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  indicator(n) {
    const r = e2(this.editor, n), s = Ph(n), { strokePoints: o, sw: i } = y7(n, s, r), a = vy(n.props.segments);
    let c;
    return o.length < 2 ? c = Qrt(a[0], i) : c = Ow(o, !1), /* @__PURE__ */ h.jsx("path", { d: c });
  }
  toSvg(n) {
    const r = Ph(n), s = r < 1.5, o = 1 / n.props.scale;
    return /* @__PURE__ */ h.jsx("g", { transform: `scale(${o})`, children: /* @__PURE__ */ h.jsx(
      aC,
      {
        forceSolid: s,
        strokeWidth: r,
        shape: n,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  toBackgroundSvg(n) {
    const r = Ph(n), s = r < 1.5, o = 1 / n.props.scale;
    return /* @__PURE__ */ h.jsx("g", { transform: `scale(${o})`, children: /* @__PURE__ */ h.jsx(
      aC,
      {
        forceSolid: s,
        strokeWidth: r,
        shape: n,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  onResize(n, r) {
    const { scaleX: s, scaleY: o } = r, i = [];
    for (const a of n.props.segments)
      i.push({
        ...a,
        points: a.points.map(({ x: c, y: l, z: d }) => ({
          x: s * c,
          y: o * l,
          z: d
        }))
      });
    return {
      props: {
        segments: i
      }
    };
  }
  getInterpolatedProps(n, r, s) {
    return {
      ...s > 0.5 ? r.props : n.props,
      ...r.props,
      segments: pfe(n.props.segments, r.props.segments, s),
      scale: kt(n.props.scale, r.props.scale, s)
    };
  }
}
P(b_, "type", "highlight"), P(b_, "props", Hte), P(b_, "migrations", Vte);
function Zrt(t) {
  return `M ${t.x} ${t.y} m -${0.1}, 0 a ${0.1},${0.1} 0 1,0 ${0.1 * 2},0 a ${0.1},${0.1} 0 1,0 -${0.1 * 2},0`;
}
function Qrt(t, e) {
  const n = e / 2;
  return `M ${t.x} ${t.y} m -${n}, 0 a ${n},${n} 0 1,0 ${n * 2},0 a ${n},${n} 0 1,0 -${n * 2},0`;
}
function y7(t, e, n) {
  var c;
  const r = vy(t.props.segments), s = t.props.isComplete || ((c = Qs(t.props.segments)) == null ? void 0 : c.type) === "straight";
  let o = e;
  !n && !t.props.isPen && r.length === 1 && (o += lg(t.id)() * (e / 6));
  const i = c4({
    strokeWidth: o,
    showAsComplete: s
  });
  return { strokePoints: Lf(r, i), sw: o };
}
function Ph(t) {
  return my[t.props.size] * 1.12 * t.props.scale;
}
function iC(t) {
  return t.props.segments.length === 1 && t.props.segments[0].points.length < 2;
}
function aC({
  strokeWidth: t,
  forceSolid: e,
  shape: n,
  opacity: r
}) {
  var f;
  const s = mc(), o = vy(n.props.segments);
  let i = t;
  !e && !n.props.isPen && o.length === 1 && (i += lg(n.id)() * (i / 6));
  const a = c4({
    strokeWidth: i,
    showAsComplete: n.props.isComplete || ((f = Qs(n.props.segments)) == null ? void 0 : f.type) === "straight"
  }), c = Lf(o, a), l = c.length > 1 ? Ow(c, !1) : Zrt(n.props.segments[0].points[0]), d = Xrt(), u = s[n.props.color].highlight[d];
  return /* @__PURE__ */ h.jsx(
    "path",
    {
      d: l,
      strokeLinecap: "round",
      fill: "none",
      pointerEvents: "all",
      stroke: u,
      strokeWidth: i,
      opacity: r
    }
  );
}
function e2(t, e) {
  return le(
    "forceSolid",
    () => {
      const n = Ph(e), r = t.getZoomLevel();
      return n / r < 1.5;
    },
    [t]
  );
}
function Tfe() {
  return /* @__PURE__ */ h.jsxs(
    "svg",
    {
      width: "15",
      height: "15",
      viewBox: "0 0 30 30",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ h.jsx("path", { d: "M3,11 L3,3 11,3", strokeWidth: "2" }),
        /* @__PURE__ */ h.jsx("path", { d: "M19,27 L27,27 L27,19", strokeWidth: "2" }),
        /* @__PURE__ */ h.jsx("path", { d: "M27,3 L3,27", strokeWidth: "2" })
      ]
    }
  );
}
function Pfe({ shapeId: t, assetId: e, width: n }) {
  const r = ie(), s = J0(), o = nze(), [i, a] = he(() => ({
    asset: e ? r.getAsset(e) ?? null : null,
    url: null
  })), c = fe(!1), l = fe(null);
  return me(() => {
    if (!e) return;
    let d = !1, u;
    const f = ya("update state", () => {
      if (!s && t && r.getCulledShapes().has(t)) return;
      const p = r.getAsset(e);
      if (!p) {
        a((m) => ({ ...m, asset: null, url: null }));
        return;
      }
      if (!p.props.src) {
        const m = r.getTemporaryAssetPreview(p.id);
        if (m) {
          l.current !== m && (l.current = m, a((v) => ({ ...v, isPlaceholder: !0, url: m })), o());
          return;
        }
      }
      const g = s ? s.scale * (n / p.props.w) : r.getZoomLevel() * (n / p.props.w);
      function y(m, v) {
        d || l.current !== v && (c.current = !0, l.current = v, a({ asset: m, url: v }), o());
      }
      if (c.current) {
        let m = 0;
        const v = () => {
          m++, m > 500 / 16 && (v7(r, e, g, s, (b) => y(p, b)), u == null || u());
        };
        u == null || u(), r.on("tick", v), u = () => r.off("tick", v);
      } else
        v7(r, e, g, s, (m) => y(p, m));
    });
    return () => {
      f(), u == null || u(), d = !0;
    };
  }, [r, e, s, o, t, n]), i;
}
function v7(t, e, n, r, s) {
  t.resolveAssetUrl(e, {
    screenScale: n,
    shouldResolveToOriginal: r ? r.pixelRatio === null : !1,
    dpr: (r == null ? void 0 : r.pixelRatio) ?? void 0
  }).then((o) => {
    s(o);
  });
}
async function Jrt(t) {
  const n = await (await qc(t)).blob();
  return oi.blobToDataUrl(n);
}
const est = new No();
class x_ extends uv {
  isAspectRatioLocked() {
    return !0;
  }
  canCrop() {
    return !0;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      playing: !0,
      url: "",
      crop: null,
      flipX: !1,
      flipY: !1,
      altText: ""
    };
  }
  getGeometry(e) {
    var n;
    return (n = e.props.crop) != null && n.isCircle ? new n9e({
      width: e.props.w,
      height: e.props.h,
      isFilled: !0
    }) : new ol({
      width: e.props.w,
      height: e.props.h,
      isFilled: !0
    });
  }
  getAriaDescriptor(e) {
    return e.props.altText;
  }
  onResize(e, n) {
    let r = iS(e, n);
    const { flipX: s, flipY: o } = n.initialShape.props, { scaleX: i, scaleY: a, mode: c } = n;
    if (r = {
      ...r,
      props: {
        ...r.props,
        flipX: i < 0 !== s,
        flipY: a < 0 !== o
      }
    }, !e.props.crop) return r;
    const l = (
      // We used the flip horizontally feature
      // We resized the shape past it's bounds, so it flipped
      c === "scale_shape" && i === -1 || c === "resize_bounds" && s !== r.props.flipX
    ), d = (
      // We used the flip vertically feature
      // We resized the shape past it's bounds, so it flipped
      c === "scale_shape" && a === -1 || c === "resize_bounds" && o !== r.props.flipY
    ), { topLeft: u, bottomRight: f } = e.props.crop;
    return r.props.crop = {
      topLeft: {
        x: l ? 1 - f.x : u.x,
        y: d ? 1 - f.y : u.y
      },
      bottomRight: {
        x: l ? 1 - u.x : f.x,
        y: d ? 1 - u.y : f.y
      },
      isCircle: e.props.crop.isCircle
    }, r;
  }
  component(e) {
    return /* @__PURE__ */ h.jsx(tst, { shape: e });
  }
  indicator(e) {
    var r;
    return this.editor.getCroppingShapeId() === e.id ? null : (r = e.props.crop) != null && r.isCircle ? /* @__PURE__ */ h.jsx(
      "ellipse",
      {
        cx: ne(e.props.w / 2),
        cy: ne(e.props.h / 2),
        rx: ne(e.props.w / 2),
        ry: ne(e.props.h / 2)
      }
    ) : /* @__PURE__ */ h.jsx("rect", { width: ne(e.props.w), height: ne(e.props.h) });
  }
  async toSvg(e, n) {
    const r = e.props;
    if (!r.assetId) return null;
    const s = this.editor.getAsset(r.assetId);
    if (!s) return null;
    const { w: o } = il(e.props, r.crop), i = await est.get(s, async () => {
      let a = await n.resolveAssetUrl(s.id, o);
      if (!a) return null;
      if ((a.startsWith("blob:") || a.startsWith("http") || a.startsWith("/") || a.startsWith("./")) && (a = await Jrt(a) || ""), Ife(this.editor, s.id)) {
        const { promise: c } = Afe(a);
        a = await c;
      }
      return a;
    });
    return i ? /* @__PURE__ */ h.jsx(nst, { shape: e, src: i }) : null;
  }
  onDoubleClickEdge(e) {
    const n = e.props;
    if (!n || this.editor.getCroppingShapeId() !== e.id)
      return;
    const r = mr(n.crop) || {
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 }
    }, { w: s, h: o } = il(e.props, r), i = new I(r.topLeft.x * s, r.topLeft.y * o).rot(e.rotation), a = {
      id: e.id,
      type: e.type,
      x: e.x - i.x,
      y: e.y - i.y,
      props: {
        crop: {
          topLeft: { x: 0, y: 0 },
          bottomRight: { x: 1, y: 1 }
        },
        w: s,
        h: o
      }
    };
    this.editor.updateShapes([a]);
  }
  getInterpolatedProps(e, n, r) {
    function s(o, i) {
      var u, f, p, g;
      if (o.props.crop === null && i.props.crop === null) return null;
      const a = ((u = o.props.crop) == null ? void 0 : u.topLeft) || { x: 0, y: 0 }, c = ((f = o.props.crop) == null ? void 0 : f.bottomRight) || { x: 1, y: 1 }, l = ((p = i.props.crop) == null ? void 0 : p.topLeft) || { x: 0, y: 0 }, d = ((g = i.props.crop) == null ? void 0 : g.bottomRight) || { x: 1, y: 1 };
      return {
        topLeft: { x: kt(a.x, l.x, r), y: kt(a.y, l.y, r) },
        bottomRight: { x: kt(c.x, d.x, r), y: kt(c.y, d.y, r) }
      };
    }
    return {
      ...r > 0.5 ? n.props : e.props,
      w: kt(e.props.w, n.props.w, r),
      h: kt(e.props.h, n.props.h, r),
      crop: s(e, n)
    };
  }
}
P(x_, "type", "image"), P(x_, "props", Wte), P(x_, "migrations", Kte);
const tst = it(function({ shape: e }) {
  var b, x;
  const n = ie(), { w: r } = il(e.props, e.props.crop), { asset: s, url: o } = Pfe({
    shapeId: e.id,
    assetId: e.props.assetId,
    width: r
  }), i = Wae(), [a, c] = he(""), [l, d] = he(null), u = s && Ife(n, s.id);
  me(() => {
    if (o && u) {
      const { promise: w, cancel: S } = Afe(o);
      return w.then((C) => {
        c(C), d(o);
      }), () => {
        S();
      };
    }
  }, [n, u, i, o]);
  const f = le(
    "show crop preview",
    () => e.id === n.getOnlySelectedShapeId() && n.getCroppingShapeId() === e.id && n.isIn("select.crop"),
    [n, e.id]
  ), p = i && (((b = s == null ? void 0 : s.props.mimeType) == null ? void 0 : b.includes("video")) || u), g = kfe(e), y = o === l ? null : o, m = p ? a : l;
  if (!o && !(s != null && s.props.src))
    return /* @__PURE__ */ h.jsxs(
      Zd,
      {
        id: e.id,
        style: {
          overflow: "hidden",
          width: e.props.w,
          height: e.props.h,
          color: "var(--color-text-3)",
          backgroundColor: "var(--color-low)",
          border: "1px solid var(--color-low-border)"
        },
        children: [
          /* @__PURE__ */ h.jsx(
            "div",
            {
              className: Je("tl-image-container", s && "tl-image-container-loading"),
              style: g,
              children: s ? null : /* @__PURE__ */ h.jsx(Tfe, {})
            }
          ),
          "url" in e.props && e.props.url && /* @__PURE__ */ h.jsx(yy, { url: e.props.url })
        ]
      }
    );
  const v = u ? "anonymous" : void 0;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    f && m && /* @__PURE__ */ h.jsx("div", { style: g, children: /* @__PURE__ */ h.jsx(
      "img",
      {
        className: "tl-image",
        style: { ...Nx(e), opacity: 0.1 },
        crossOrigin: v,
        src: m,
        referrerPolicy: "strict-origin-when-cross-origin",
        draggable: !1,
        alt: ""
      }
    ) }),
    /* @__PURE__ */ h.jsxs(
      Zd,
      {
        id: e.id,
        style: {
          overflow: "hidden",
          width: e.props.w,
          height: e.props.h,
          borderRadius: (x = e.props.crop) != null && x.isCircle ? "50%" : void 0
        },
        children: [
          /* @__PURE__ */ h.jsxs("div", { className: Je("tl-image-container"), style: g, children: [
            m && /* @__PURE__ */ h.jsx(
              "img",
              {
                className: "tl-image",
                style: Nx(e),
                crossOrigin: v,
                src: m,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: !1,
                alt: ""
              },
              m
            ),
            y && /* @__PURE__ */ h.jsx(
              "img",
              {
                className: "tl-image",
                style: Nx(e),
                crossOrigin: v,
                src: y,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: !1,
                alt: e.props.altText,
                onLoad: () => d(y)
              },
              y
            )
          ] }),
          e.props.url && /* @__PURE__ */ h.jsx(yy, { url: e.props.url })
        ]
      }
    )
  ] });
});
function Ife(t, e) {
  const n = e ? t.getAsset(e) : void 0;
  return n ? "mimeType" in n.props && ca.isAnimatedImageType(n == null ? void 0 : n.props.mimeType) || "isAnimated" in n.props && n.props.isAnimated : !1;
}
function kfe(t) {
  const e = t.props.crop, n = e == null ? void 0 : e.topLeft;
  if (!n)
    return {
      width: t.props.w,
      height: t.props.h
    };
  const { w: r, h: s } = il(t.props, e), o = -n.x * r, i = -n.y * s;
  return {
    transform: `translate(${o}px, ${i}px)`,
    width: r,
    height: s
  };
}
function Nx(t, e) {
  const { flipX: n, flipY: r, crop: s } = t.props;
  if (!n && !r) return;
  let o, i;
  if (s) {
    const { w: l, h: d } = il(t.props, s), u = s.bottomRight.x - s.topLeft.x, f = s.bottomRight.y - s.topLeft.y;
    o = ql(s.topLeft.x, [0, 1 - u], [0, l - t.props.w]), i = ql(s.topLeft.y, [0, 1 - f], [0, d - t.props.h]);
  }
  const a = `scale(${n ? -1 : 1}, ${r ? -1 : 1})`;
  return {
    transform: `${e ? `translate(${(n ? e.width : 0) - (o || 0)}px,
		             ${(r ? e.height : 0) - (i || 0)}px)` : ""} ${a}`,
    // in SVG, flipping around the center doesn't work so we use explicit width/height
    transformOrigin: e ? "0 0" : "center center"
  };
}
function nst({ shape: t, src: e }) {
  const n = gg(), r = kfe(t), s = t.props.crop;
  if (r.transform && s) {
    const { transform: o, width: i, height: a } = r, c = (s.bottomRight.x - s.topLeft.x) * i, l = (s.bottomRight.y - s.topLeft.y) * a, d = [
      new I(0, 0),
      new I(c, 0),
      new I(c, l),
      new I(0, l)
    ], u = Nx(t, { width: i, height: a });
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx("defs", { children: /* @__PURE__ */ h.jsx("clipPath", { id: n, children: s.isCircle ? /* @__PURE__ */ h.jsx(
        "ellipse",
        {
          cx: c / 2,
          cy: l / 2,
          rx: c / 2,
          ry: l / 2
        }
      ) : /* @__PURE__ */ h.jsx("polygon", { points: d.map((f) => `${f.x},${f.y}`).join(" ") }) }) }),
      /* @__PURE__ */ h.jsx("g", { clipPath: `url(#${n})`, children: /* @__PURE__ */ h.jsx(
        "image",
        {
          href: e,
          width: i,
          height: a,
          "aria-label": t.props.altText,
          style: u ? { ...u } : { transform: o }
        }
      ) })
    ] });
  } else
    return /* @__PURE__ */ h.jsx(
      "image",
      {
        href: e,
        width: t.props.w,
        height: t.props.h,
        "aria-label": t.props.altText,
        style: Nx(t, { width: t.props.w, height: t.props.h })
      }
    );
}
function Afe(t) {
  let e = !1;
  return { promise: new Promise((r) => {
    const s = rw();
    s.onload = () => {
      if (e) return;
      const o = document.createElement("canvas");
      o.width = s.width, o.height = s.height;
      const i = o.getContext("2d");
      i && (i.drawImage(s, 0, 0), r(o.toDataURL()));
    }, s.crossOrigin = "anonymous", s.src = t;
  }), cancel: () => e = !0 };
}
const rst = new No();
class w_ extends sc {
  hideResizeHandles() {
    return !0;
  }
  hideRotateHandle() {
    return !0;
  }
  hideSelectionBoundsFg() {
    return !0;
  }
  hideSelectionBoundsBg() {
    return !0;
  }
  getDefaultProps() {
    const [e, n] = ow(2);
    return {
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      points: {
        [e]: { id: e, index: e, x: 0, y: 0 },
        [n]: { id: n, index: n, x: 0.1, y: 0.1 }
      },
      scale: 1
    };
  }
  getGeometry(e) {
    const n = OR(e).toGeometry();
    return tt(n instanceof Vj), n;
  }
  getHandles(e) {
    return rst.get(e.props, () => {
      const n = this.getGeometry(e), r = Qb(e), s = r.map((o) => ({
        ...o,
        id: o.index,
        type: "vertex",
        canSnap: !0
      }));
      for (let o = 0; o < r.length - 1; o++) {
        const i = oy(r[o].index, r[o + 1].index), c = n.getSegments()[o].interpolateAlongEdge(0.5);
        s.push({
          id: i,
          type: "create",
          index: i,
          x: c.x,
          y: c.y,
          canSnap: !0
        });
      }
      return s.sort(Js);
    });
  }
  //   Events
  onResize(e, n) {
    const { scaleX: r, scaleY: s } = n;
    return {
      props: {
        points: Qf(e.props.points, (o, { id: i, index: a, x: c, y: l }) => ({
          id: i,
          index: a,
          x: c * r,
          y: l * s
        }))
      }
    };
  }
  onBeforeCreate(e) {
    const {
      props: { points: n }
    } = e, r = Object.keys(n);
    if (r.length < 2)
      return;
    const s = n[r[0]];
    if (r.every((i) => {
      const a = n[i];
      return a.x === s.x && a.y === s.y;
    })) {
      const i = r[r.length - 1];
      return n[i] = {
        ...n[i],
        x: n[i].x + 0.1,
        y: n[i].y + 0.1
      }, e;
    }
  }
  onHandleDrag(e, { handle: n }) {
    const r = Ea(new I(n.x, n.y), this.editor);
    return {
      ...e,
      props: {
        ...e.props,
        points: {
          ...e.props.points,
          [n.id]: { id: n.id, index: n.index, x: r.x, y: r.y }
        }
      }
    };
  }
  onHandleDragStart(e, { handle: n }) {
    if (n.type === "create")
      return {
        ...e,
        props: {
          ...e.props,
          points: {
            ...e.props.points,
            [n.index]: { id: n.index, index: n.index, x: n.x, y: n.y }
          }
        }
      };
  }
  component(e) {
    return /* @__PURE__ */ h.jsx(jf, { style: { minWidth: 50, minHeight: 50 }, children: /* @__PURE__ */ h.jsx(b7, { shape: e }) });
  }
  indicator(e) {
    const n = da[e.props.size] * e.props.scale, r = OR(e), { dash: s } = e.props;
    return r.toSvg({
      style: s === "draw" ? "draw" : "solid",
      strokeWidth: 1,
      passes: 1,
      randomSeed: e.id,
      offset: 0,
      roundness: n * 2,
      props: { strokeWidth: void 0 }
    });
  }
  toSvg(e) {
    return /* @__PURE__ */ h.jsx(b7, { shouldScale: !0, shape: e });
  }
  getHandleSnapGeometry(e) {
    const n = Qb(e);
    return {
      points: n,
      getSelfSnapPoints: (r) => {
        const s = this.getHandles(e).filter((o) => o.type === "vertex").findIndex((o) => o.id === r.id);
        return n.filter((o, i) => Math.abs(i - s) > 1).map(I.From);
      },
      getSelfSnapOutline: (r) => {
        const s = this.getHandles(e).filter((i) => i.type === "vertex").findIndex((i) => i.id === r.id), o = this.getGeometry(e).getSegments().filter((i, a) => a !== s - 1 && a !== s);
        return o.length ? new ui({ children: o }) : null;
      }
    };
  }
  getInterpolatedProps(e, n, r) {
    const s = Qb(e), o = Qb(n), i = [], a = [];
    let c = GJ;
    if (s.length > o.length)
      for (let l = 0; l < s.length; l++)
        i[l] = { ...s[l] }, o[l] === void 0 ? a[l] = { ...o[o.length - 1], id: c } : a[l] = { ...o[l], id: c }, c = Bc(c);
    else if (o.length > s.length)
      for (let l = 0; l < o.length; l++)
        a[l] = { ...o[l] }, s[l] === void 0 ? i[l] = {
          ...s[s.length - 1],
          id: c
        } : i[l] = { ...s[l], id: c }, c = Bc(c);
    else
      for (let l = 0; l < o.length; l++)
        i[l] = s[l], a[l] = o[l];
    return {
      ...r > 0.5 ? n.props : e.props,
      points: Object.fromEntries(
        i.map((l, d) => {
          const u = a[d];
          return [
            l.id,
            {
              ...l,
              x: kt(l.x, u.x, r),
              y: kt(l.y, u.y, r)
            }
          ];
        })
      ),
      scale: kt(e.props.scale, n.props.scale, r)
    };
  }
}
P(w_, "type", "line"), P(w_, "props", Gte), P(w_, "migrations", Yte);
function Qb(t) {
  return Object.values(t.props.points).sort(Js);
}
const sst = new No();
function OR(t) {
  return sst.get(t, () => {
    const e = Qb(t).map(I.From);
    switch (t.props.spline) {
      case "cubic":
        return ln.cubicSplineThroughPoints(e, { endOffsets: 0 });
      case "line":
        return ln.lineThroughPoints(e, { endOffsets: 0 });
    }
  });
}
function b7({
  shape: t,
  shouldScale: e = !1,
  forceSolid: n = !1
}) {
  const r = mc(), s = OR(t), { dash: o, color: i, size: a } = t.props, c = 1 / t.props.scale, l = e ? c : 1, d = da[a] * t.props.scale;
  return s.toSvg({
    style: o,
    strokeWidth: d,
    forceSolid: n,
    randomSeed: t.id,
    props: { transform: `scale(${l})`, stroke: r[i].solid, fill: "none" }
  });
}
function XT(t, e, n = !1) {
  t.select(e), t.setEditingShape(e), t.setCurrentTool("select.editing_shape", {
    target: "shape",
    shape: e
  }), n && t.emit("select-all-text", { shapeId: e.id });
}
class S_ extends sc {
  constructor() {
    super(...arguments);
    P(this, "options", {
      resizeMode: "none"
    });
  }
  canEdit() {
    return !0;
  }
  hideResizeHandles() {
    const { resizeMode: n } = this.options;
    switch (n) {
      case "none":
        return !0;
      case "scale":
        return !1;
      default:
        throw Jt(n);
    }
  }
  isAspectRatioLocked() {
    return this.options.resizeMode === "scale";
  }
  hideSelectionBoundsFg() {
    return !1;
  }
  getDefaultProps() {
    return {
      color: "black",
      richText: dc(""),
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      labelColor: "black",
      growY: 0,
      fontSizeAdjustment: 0,
      url: "",
      scale: 1
    };
  }
  getGeometry(n) {
    const { labelHeight: r, labelWidth: s } = Mfe(this.editor, n), { scale: o } = n.props, i = r * o, a = s * o, c = jn * o, l = cC(n);
    return new ui({
      children: [
        new ol({ width: c, height: l, isFilled: !0 }),
        new ol({
          x: n.props.align === "start" ? 0 : n.props.align === "end" ? c - a : (c - a) / 2,
          y: n.props.verticalAlign === "start" ? 0 : n.props.verticalAlign === "end" ? l - i : (l - i) / 2,
          width: a,
          height: i,
          isFilled: !0,
          isLabel: !0
        })
      ]
    });
  }
  getHandles(n) {
    const { scale: r } = n.props;
    if (this.editor.getInstanceState().isCoarsePointer) return [];
    const o = this.editor.getZoomLevel();
    if (o * r < 0.25) return [];
    const i = cC(n), a = jn * r, c = vtt / o * r;
    return o * r < 0.5 ? [
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: a / 2,
        y: i + c
      }
    ] : [
      {
        id: "top",
        index: "a1",
        type: "clone",
        x: a / 2,
        y: -c
      },
      {
        id: "right",
        index: "a2",
        type: "clone",
        x: a + c,
        y: i / 2
      },
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: a / 2,
        y: i + c
      },
      {
        id: "left",
        index: "a4",
        type: "clone",
        x: -c,
        y: i / 2
      }
    ];
  }
  onResize(n, r) {
    const { resizeMode: s } = this.options;
    switch (s) {
      case "none":
        return;
      case "scale":
        return lie(n, r);
      default:
        throw Jt(s);
    }
  }
  getText(n) {
    return Lp(this.editor, n.props.richText);
  }
  getFontFaces(n) {
    return Ai(n.props.richText) ? Br : t5(this.editor, n.props.richText, {
      family: `tldraw_${n.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(n) {
    const {
      id: r,
      type: s,
      props: {
        labelColor: o,
        scale: i,
        color: a,
        font: c,
        size: l,
        align: d,
        richText: u,
        verticalAlign: f,
        fontSizeAdjustment: p
      }
    } = n, g = ast(r), y = mc(), m = jn * i, v = cC(n), b = le(
      "shape rotation",
      () => {
        var E;
        return ((E = this.editor.getShapePageTransform(r)) == null ? void 0 : E.rotation()) ?? 0;
      },
      [this.editor]
    ), x = le("zoom", () => this.editor.getZoomLevel() < 0.35 / i, [
      i,
      this.editor
    ]), w = le("dark mode", () => this.editor.user.getIsDarkMode(), [this.editor]), S = n.id === this.editor.getOnlySelectedShapeId(), C = s4(this.editor, n.id), _ = Ai(u);
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(
        "div",
        {
          id: r,
          className: "tl-note__container",
          style: {
            width: m,
            height: v,
            backgroundColor: y[a].note.fill,
            borderBottom: x ? w ? `${2 * i}px solid rgb(20, 20, 20)` : `${2 * i}px solid rgb(144, 144, 144)` : "none",
            boxShadow: x ? "none" : cst(n.id, b, i)
          },
          children: (S || C || !_) && /* @__PURE__ */ h.jsx(
            v4,
            {
              shapeId: r,
              type: s,
              font: c,
              fontSize: (p || Ef[l]) * i,
              lineHeight: Oo.lineHeight,
              align: d,
              verticalAlign: f,
              richText: u,
              isSelected: S,
              labelColor: o === "black" ? y[a].note.text : y[o].fill,
              wrap: !0,
              padding: ri * i,
              hasCustomTabBehavior: !0,
              onKeyDown: g
            }
          )
        }
      ),
      "url" in n.props && n.props.url && /* @__PURE__ */ h.jsx(yy, { url: n.props.url })
    ] });
  }
  indicator(n) {
    const { scale: r } = n.props;
    return /* @__PURE__ */ h.jsx(
      "rect",
      {
        rx: r,
        width: ne(jn * r),
        height: ne(cC(n))
      }
    );
  }
  toSvg(n, r) {
    const s = mu({ isDarkMode: r.isDarkMode }), o = lst(n), i = /* @__PURE__ */ h.jsx(
      b4,
      {
        fontSize: n.props.fontSizeAdjustment || Ef[n.props.size],
        font: n.props.font,
        align: n.props.align,
        verticalAlign: n.props.verticalAlign,
        richText: n.props.richText,
        labelColor: s[n.props.color].note.text,
        bounds: o,
        padding: ri,
        showTextOutline: !1
      }
    );
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx("rect", { x: 5, y: 5, rx: 1, width: jn - 10, height: o.h, fill: "rgba(0,0,0,.1)" }),
      /* @__PURE__ */ h.jsx(
        "rect",
        {
          rx: 1,
          width: jn,
          height: o.h,
          fill: s[n.props.color].note.fill
        }
      ),
      i
    ] });
  }
  onBeforeCreate(n) {
    return x7(this.editor, n);
  }
  onBeforeUpdate(n, r) {
    if (!(Zf(n.props.richText, r.props.richText) && n.props.font === r.props.font && n.props.size === r.props.size))
      return x7(this.editor, r);
  }
  getInterpolatedProps(n, r, s) {
    return {
      ...s > 0.5 ? r.props : n.props,
      scale: kt(n.props.scale, r.props.scale, s)
    };
  }
}
P(S_, "type", "note"), P(S_, "props", qte), P(S_, "migrations", Xte);
function x7(t, e) {
  const { labelHeight: n, fontSizeAdjustment: r } = Mfe(t, e), s = Math.max(0, n - jn);
  if (s !== e.props.growY || r !== e.props.fontSizeAdjustment)
    return {
      ...e,
      props: {
        ...e.props,
        growY: s,
        fontSizeAdjustment: r
      }
    };
}
function ost(t, e) {
  const { richText: n } = e.props;
  if (Ai(n))
    return { labelHeight: Ef[e.props.size] * Oo.lineHeight + ri * 2, labelWidth: 100, fontSizeAdjustment: 0 };
  const r = Ef[e.props.size];
  let s = 0, o = 0, i = jn, a = jn;
  const c = 1;
  do {
    s = Math.min(r, r - o);
    const l = VT(t, n), d = t.textMeasure.measureHtml(l, {
      ...Oo,
      fontFamily: Ff[e.props.font],
      fontSize: s,
      maxWidth: jn - ri * 2 - c,
      disableOverflowWrapBreaking: !0,
      measureScrollWidth: !0
    });
    if (i = d.h + ri * 2, a = d.w + ri * 2, s <= 14) {
      const u = VT(t, n), f = t.textMeasure.measureHtml(u, {
        ...Oo,
        fontFamily: Ff[e.props.font],
        fontSize: s,
        maxWidth: jn - ri * 2 - c
      });
      i = f.h + ri * 2, a = f.w + ri * 2;
      break;
    }
    if (d.scrollWidth.toFixed(0) === d.w.toFixed(0))
      break;
  } while (o++ < 50);
  return {
    labelHeight: i,
    labelWidth: a,
    fontSizeAdjustment: s
  };
}
const ist = new No();
function Mfe(t, e) {
  return ist.get(e, () => ost(t, e));
}
function ast(t) {
  const e = ie(), n = qae();
  return re(
    (r) => {
      const s = e.getShape(t);
      if (!s) return;
      const o = r.key === "Tab", i = (r.metaKey || r.ctrlKey) && r.key === "Enter";
      if (o || i) {
        r.preventDefault();
        const a = e.getShapePageTransform(t), c = a.rotation(), l = !!(n.dir === "rtl" || // todo: can we check a partial of the text, so that we don't have to render the whole thing?
        Wue(Lp(e, s.props.richText))), d = (jn + e.options.adjacentShapeMargin + // If we're growing down, we need to account for the current shape's growY
        (i && !r.shiftKey ? s.props.growY : 0)) * s.props.scale, u = new I(
          o ? r.shiftKey != l ? -1 : 1 : 0,
          i ? r.shiftKey ? -1 : 1 : 0
        ).mul(d).add(Bk.clone().mul(s.props.scale)).rot(c).add(a.point()), f = nfe(e, s, u, c);
        f && XT(
          e,
          f,
          !0
          /* selectAll */
        );
      }
    },
    [t, e, n.dir]
  );
}
function cC(t) {
  return (jn + t.props.growY) * t.props.scale;
}
function cst(t, e, n) {
  const r = lg(t), s = Math.abs(r()) + 0.5, o = Math.cos(e), i = 5 * n, a = 4 * n, c = 6 * n, l = 7 * n;
  return `0px ${i - s}px ${i}px -${i}px rgba(15, 23, 31, .6),
	0px ${(a + s * l) * Math.max(0, o)}px ${c + s * l}px -${a + s * c}px rgba(15, 23, 31, ${(0.3 + s * 0.1).toFixed(2)}), 
	0px ${48 * n}px ${10 * n}px -${10 * n}px inset rgba(15, 23, 44, ${((0.022 + r() * 5e-3) * ((1 + o) / 2)).toFixed(2)})`;
}
function lst(t) {
  return new _e(0, 0, jn, jn + t.props.growY);
}
const dst = MI(
  "text size",
  (t, e) => (t.fonts.trackFontsForShape(e), Ofe(t, e.props)),
  { areRecordsEqual: (t, e) => t.props === e.props }
);
class C_ extends sc {
  constructor() {
    super(...arguments);
    P(this, "options", {
      extraArrowHorizontalPadding: 10
    });
  }
  getDefaultProps() {
    return {
      color: "black",
      size: "m",
      w: 8,
      font: "draw",
      textAlign: "start",
      autoSize: !0,
      scale: 1,
      richText: dc("")
    };
  }
  getMinDimensions(n) {
    return dst.get(this.editor, n.id);
  }
  getGeometry(n, r) {
    const { scale: s } = n.props, { width: o, height: i } = this.getMinDimensions(n), a = (r == null ? void 0 : r.context) ?? "none";
    return new ol({
      x: (a === "@tldraw/arrow-without-arrowhead" ? -this.options.extraArrowHorizontalPadding : 0) * s,
      width: (o + (a === "@tldraw/arrow-without-arrowhead" ? this.options.extraArrowHorizontalPadding * 2 : 0)) * s,
      height: i * s,
      isFilled: !0,
      isLabel: !0
    });
  }
  getFontFaces(n) {
    return t5(this.editor, n.props.richText, {
      family: `tldraw_${n.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  getText(n) {
    return Lp(this.editor, n.props.richText);
  }
  canEdit() {
    return !0;
  }
  isAspectRatioLocked() {
    return !0;
  }
  // WAIT NO THIS IS HARD CODED IN THE RESIZE HANDLER
  component(n) {
    const {
      id: r,
      props: { font: s, size: o, richText: i, color: a, scale: c, textAlign: l }
    } = n, { width: d, height: u } = this.getMinDimensions(n), f = n.id === this.editor.getOnlySelectedShapeId(), p = mc(), g = ust(r);
    return /* @__PURE__ */ h.jsx(
      v4,
      {
        shapeId: r,
        classNamePrefix: "tl-text-shape",
        type: "text",
        font: s,
        fontSize: my[o],
        lineHeight: Oo.lineHeight,
        align: l,
        verticalAlign: "middle",
        richText: i,
        labelColor: p[a].solid,
        isSelected: f,
        textWidth: d,
        textHeight: u,
        style: {
          transform: `scale(${c})`,
          transformOrigin: "top left"
        },
        wrap: !0,
        onKeyDown: g
      }
    );
  }
  indicator(n) {
    const r = this.editor.getShapeGeometry(n).bounds, s = ie();
    return n.props.autoSize && s.getEditingShapeId() === n.id ? null : /* @__PURE__ */ h.jsx("rect", { width: ne(r.width), height: ne(r.height) });
  }
  toSvg(n, r) {
    const s = this.editor.getShapeGeometry(n).bounds, o = s.width / (n.props.scale ?? 1), i = s.height / (n.props.scale ?? 1), a = mu(r), c = new _e(0, 0, o, i);
    return /* @__PURE__ */ h.jsx(
      b4,
      {
        fontSize: my[n.props.size],
        font: n.props.font,
        align: n.props.textAlign,
        verticalAlign: "middle",
        richText: n.props.richText,
        labelColor: a[n.props.color].solid,
        bounds: c,
        padding: 0
      }
    );
  }
  onResize(n, r) {
    const { newPoint: s, initialBounds: o, initialShape: i, scaleX: a, handle: c } = r;
    if (r.mode === "scale_shape" || c !== "right" && c !== "left")
      return {
        id: n.id,
        type: n.type,
        ...lie(n, r)
      };
    {
      const l = Math.max(1, Math.abs(o.width * a)), { x: d, y: u } = a < 0 ? I.Sub(s, I.FromAngle(n.rotation).mul(l)) : s;
      return {
        id: n.id,
        type: n.type,
        x: d,
        y: u,
        props: {
          w: l / i.props.scale,
          autoSize: !1
        }
      };
    }
  }
  onEditEnd(n) {
    Lp(this.editor, n.props.richText).trimEnd().length === 0 && this.editor.deleteShapes([n.id]);
  }
  onBeforeUpdate(n, r) {
    if (!r.props.autoSize) return;
    const s = n.props.size !== r.props.size || n.props.textAlign !== r.props.textAlign || n.props.font !== r.props.font || n.props.scale !== 1 && r.props.scale === 1, o = !Zf(n.props.richText, r.props.richText);
    if (!s && !o) return;
    const i = this.getMinDimensions(n), a = Ofe(this.editor, r.props), c = i.width * n.props.scale, l = i.height * n.props.scale, d = a.width * r.props.scale, u = a.height * r.props.scale;
    let f;
    switch (r.props.textAlign) {
      case "middle": {
        f = new I((d - c) / 2, o ? 0 : (u - l) / 2);
        break;
      }
      case "end": {
        f = new I(d - c, o ? 0 : (u - l) / 2);
        break;
      }
      default: {
        if (o) break;
        f = new I(0, (u - l) / 2);
        break;
      }
    }
    if (f) {
      f.rot(r.rotation);
      const { x: p, y: g } = r;
      return {
        ...r,
        x: p - f.x,
        y: g - f.y,
        props: { ...r.props, w: d }
      };
    } else
      return {
        ...r,
        props: { ...r.props, w: d }
      };
  }
  // 	todo: The edge doubleclicking feels like a mistake more often than
  //  not, especially on multiline text. Removed June 16 2024
  // override onDoubleClickEdge = (shape: TLTextShape) => {
  // 	// If the shape has a fixed width, set it to autoSize.
  // 	if (!shape.props.autoSize) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				autoSize: true,
  // 			},
  // 		}
  // 	}
  // 	// If the shape is scaled, reset the scale to 1.
  // 	if (shape.props.scale !== 1) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				scale: 1,
  // 			},
  // 		}
  // 	}
  // }
}
P(C_, "type", "text"), P(C_, "props", Zte), P(C_, "migrations", Qte);
function Ofe(t, e) {
  const { font: n, richText: r, size: s, w: o } = e, i = 16, a = my[s], c = e.autoSize ? null : Math.max(i, Math.floor(o)), l = VT(t, r), d = t.textMeasure.measureHtml(l, {
    ...Oo,
    fontFamily: Ff[n],
    fontSize: a,
    maxWidth: c
  });
  return {
    width: c ?? Math.max(i, d.w + 1),
    height: Math.max(a, d.h)
  };
}
function ust(t) {
  const e = ie();
  return re(
    (n) => {
      if (e.getEditingShapeId() === t)
        switch (n.key) {
          case "Enter": {
            (n.ctrlKey || n.metaKey) && e.complete();
            break;
          }
        }
    },
    [e, t]
  );
}
const fst = new No();
class __ extends uv {
  constructor() {
    super(...arguments);
    P(this, "options", {
      autoplay: !0
    });
  }
  canEdit() {
    return !0;
  }
  isAspectRatioLocked() {
    return !0;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      autoplay: this.options.autoplay,
      url: "",
      altText: "",
      // Not used, but once upon a time were used to sync video state between users
      time: 0,
      playing: !0
    };
  }
  getAriaDescriptor(n) {
    return n.props.altText;
  }
  component(n) {
    return /* @__PURE__ */ h.jsx(hst, { shape: n });
  }
  indicator(n) {
    return /* @__PURE__ */ h.jsx("rect", { width: ne(n.props.w), height: ne(n.props.h) });
  }
  async toSvg(n, r) {
    const s = n.props;
    if (!s.assetId) return null;
    const o = this.editor.getAsset(s.assetId);
    if (!o) return null;
    const i = await fst.get(o, async () => {
      const a = await r.resolveAssetUrl(o.id, s.w);
      if (!a) return null;
      const c = await ca.loadVideo(a);
      return await ca.getVideoFrameAsDataUrl(c, 0);
    });
    return i ? /* @__PURE__ */ h.jsx("image", { href: i, width: s.w, height: s.h, "aria-label": n.props.altText }) : null;
  }
}
P(__, "type", "video"), P(__, "props", Jte), P(__, "migrations", ene);
const hst = it(function({ shape: e }) {
  const n = ie(), r = n.getShapeGeometry(e).bounds.w * n.getZoomLevel() >= 110, s = aS(e.id), o = Wae(), { Spinner: i } = Ln(), { asset: a, url: c } = Pfe({
    shapeId: e.id,
    assetId: e.props.assetId,
    width: e.props.w
  }), l = fe(null), [d, u] = he(!1), f = re((y) => {
    y.currentTarget && u(!0);
  }, []), [p, g] = he(!1);
  return me(() => {
    const y = () => g(document.fullscreenElement === l.current);
    return document.addEventListener("fullscreenchange", y), () => document.removeEventListener("fullscreenchange", y);
  }), me(() => {
    const y = l.current;
    y && s && document.activeElement !== y && y.focus();
  }, [s, d]), /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(
      Zd,
      {
        id: e.id,
        style: {
          color: "var(--color-text-3)",
          backgroundColor: a ? "transparent" : "var(--color-low)",
          border: a ? "none" : "1px solid var(--color-low-border)"
        },
        children: /* @__PURE__ */ h.jsx("div", { className: "tl-counter-scaled", children: /* @__PURE__ */ h.jsx("div", { className: "tl-video-container", children: a ? i && !a.props.src ? /* @__PURE__ */ h.jsx(i, {}) : c ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
          /* @__PURE__ */ h.jsx(
            "video",
            {
              ref: l,
              style: s ? { pointerEvents: "all" } : d ? void 0 : { display: "none" },
              className: Je("tl-video", `tl-video-shape-${e.id.split(":")[1]}`, {
                "tl-video-is-fullscreen": p
              }),
              width: "100%",
              height: "100%",
              draggable: !1,
              playsInline: !0,
              autoPlay: e.props.autoplay && !o,
              muted: !0,
              loop: !0,
              disableRemotePlayback: !0,
              disablePictureInPicture: !0,
              controls: s && r,
              onLoadedData: f,
              hidden: !d,
              "aria-label": e.props.altText,
              children: /* @__PURE__ */ h.jsx("source", { src: c })
            },
            c
          ),
          !d && i && /* @__PURE__ */ h.jsx(i, {})
        ] }) : null : /* @__PURE__ */ h.jsx(Tfe, {}) }) })
      }
    ),
    "url" in e.props && e.props.url && /* @__PURE__ */ h.jsx(yy, { url: e.props.url })
  ] });
}), Dfe = [
  C_,
  p_,
  g_,
  v_,
  S_,
  w_,
  m_,
  h_,
  b_,
  YT,
  x_,
  __
];
function pst(t) {
  return t.sideEffects.register({
    instance_page_state: {
      afterChange: (e, n) => {
        if (e.croppingShapeId !== n.croppingShapeId) {
          const r = t.isIn("select.crop");
          !e.croppingShapeId && n.croppingShapeId ? r || t.setCurrentTool("select.crop.idle") : e.croppingShapeId && !n.croppingShapeId && r && t.setCurrentTool("select.idle");
        }
        if (e.editingShapeId !== n.editingShapeId)
          if (!e.editingShapeId && n.editingShapeId) {
            if (!t.isIn("select.editing_shape")) {
              const r = t.getEditingShape();
              r && r.type === "text" && t.isInAny("text.pointing", "select.resizing") && t.getInstanceState().isToolLocked ? t.setCurrentTool("select.editing_shape", {
                isCreatingTextWhileToolLocked: !0
              }) : t.setCurrentTool("select.editing_shape");
            }
          } else e.editingShapeId && !n.editingShapeId && t.isIn("select.editing_shape") && t.setCurrentTool("select.idle");
      }
    }
  });
}
class Nfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
    P(this, "scribbleId", "id");
    P(this, "markId", "");
    P(this, "excludedShapeIds", /* @__PURE__ */ new Set());
  }
  onEnter(n) {
    this.markId = this.editor.markHistoryStoppingPoint("erase scribble begin"), this.info = n;
    const { originPagePoint: r } = this.editor.inputs;
    this.excludedShapeIds = new Set(
      this.editor.getCurrentPageShapes().filter((o) => {
        if (this.editor.isShapeOrAncestorLocked(o)) return !0;
        if (this.editor.isShapeOfType(o, "group") || this.editor.isShapeOfType(o, "frame")) {
          const i = this.editor.getPointInShapeSpace(o, r);
          return this.editor.getShapeGeometry(o).bounds.containsPoint(i);
        }
        return !1;
      }).map((o) => o.id)
    );
    const s = this.editor.scribbles.addScribble({
      color: "muted-1",
      size: 12
    });
    this.scribbleId = s.id, this.update();
  }
  pushPointToScribble() {
    const { x: n, y: r } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, n, r);
  }
  onExit() {
    this.editor.setErasingShapes([]), this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  update() {
    const { editor: n, excludedShapeIds: r } = this, s = n.getErasingShapeIds(), o = n.getZoomLevel(), i = n.getCurrentPageRenderingShapesSorted(), {
      inputs: { currentPagePoint: a, previousPagePoint: c }
    } = n;
    this.pushPointToScribble();
    const l = new Set(s), d = this.editor.options.hitTestMargin / o;
    for (const u of i) {
      if (n.isShapeOfType(u, "group")) continue;
      const f = n.getShapeMask(u.id);
      if (f && !li(a, f))
        continue;
      const p = n.getShapeGeometry(u), g = n.getShapePageTransform(u);
      if (!p || !g) continue;
      const y = g.clone().invert(), m = y.applyToPoint(c), v = y.applyToPoint(a), { bounds: b } = p;
      b.minX - d > Math.max(m.x, v.x) || b.minY - d > Math.max(m.y, v.y) || b.maxX + d < Math.min(m.x, v.x) || b.maxY + d < Math.min(m.y, v.y) || p.hitTestLineSegment(m, v, d) && l.add(n.getOutermostSelectableShape(u).id);
    }
    this.editor.setErasingShapes([...l].filter((u) => !r.has(u)));
  }
  complete() {
    const { editor: n } = this;
    n.deleteShapes(n.getCurrentPageState().erasingShapeIds), this.parent.transition("idle");
  }
  cancel() {
    const { editor: n } = this;
    n.bailToMark(this.markId), this.parent.transition("idle", this.info);
  }
}
P(Nfe, "id", "erasing");
var yD;
let gst = (yD = class extends Xe {
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, P(yD, "id", "idle"), yD);
var vD;
let mst = (vD = class extends Xe {
  onEnter() {
    const e = this.editor.getZoomLevel(), n = this.editor.getCurrentPageRenderingShapesSorted(), {
      inputs: { currentPagePoint: r }
    } = this.editor, s = /* @__PURE__ */ new Set(), o = s.size;
    for (let i = n.length, a = i - 1; a >= 0; a--) {
      const c = n[a];
      if (!(this.editor.isShapeOrAncestorLocked(c) || this.editor.isShapeOfType(c, "group")) && this.editor.isPointInShape(c, r, {
        hitInside: !1,
        margin: this.editor.options.hitTestMargin / e
      })) {
        const l = this.editor.getOutermostSelectableShape(c);
        if (this.editor.isShapeOfType(l, "frame") && s.size > o)
          break;
        s.add(l.id);
      }
    }
    this.editor.setErasingShapes([...s]);
  }
  onLongPress(e) {
    this.startErasing(e);
  }
  onExit(e, n) {
    n !== "erasing" && this.editor.setErasingShapes([]);
  }
  onPointerMove(e) {
    this.editor.inputs.isDragging && this.startErasing(e);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  startErasing(e) {
    this.parent.transition("erasing", e);
  }
  complete() {
    const e = this.editor.getErasingShapeIds();
    e.length && (this.editor.markHistoryStoppingPoint("erase end"), this.editor.deleteShapes(e)), this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
}, P(vD, "id", "pointing"), vD);
class E_ extends Xe {
  static children() {
    return [gst, mst, Nfe];
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
}
P(E_, "id", "eraser"), P(E_, "initial", "idle"), P(E_, "isLockable", !1);
class jfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "initialCamera", new I());
  }
  onEnter() {
    this.initialCamera = I.From(this.editor.getCamera()), this.update();
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.parent.transition("idle");
  }
  onComplete() {
    this.complete();
  }
  update() {
    const { initialCamera: n, editor: r } = this, { currentScreenPoint: s, originScreenPoint: o } = r.inputs, i = I.Sub(s, o).div(r.getZoomLevel());
    i.len2() !== 0 && r.setCamera(n.clone().add(i));
  }
  complete() {
    const { editor: n } = this, { pointerVelocity: r } = n.inputs, s = Math.min(r.len(), 2);
    s > 0.1 && this.editor.slideCamera({ speed: s, direction: r }), this.parent.transition("idle");
  }
}
P(jfe, "id", "dragging");
var bD;
let yst = (bD = class extends Xe {
  onEnter() {
    this.editor.setCursor({ type: "grab", rotation: 0 });
  }
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, P(bD, "id", "idle"), bD);
var xD;
let vst = (xD = class extends Xe {
  onEnter() {
    this.editor.stopCameraAnimation(), this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onLongPress() {
    this.startDragging();
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.startDragging();
  }
  startDragging() {
    this.parent.transition("dragging");
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
}, P(xD, "id", "pointing"), xD);
class T_ extends Xe {
  static children() {
    return [yst, vst, jfe];
  }
  onDoubleClick(e) {
    if (e.phase === "settle") {
      const { currentScreenPoint: n } = this.editor.inputs;
      this.editor.zoomIn(n, {
        animation: { duration: 220, easing: Mo.easeOutQuint }
      });
    }
  }
  onTripleClick(e) {
    if (e.phase === "settle") {
      const { currentScreenPoint: n } = this.editor.inputs;
      this.editor.zoomOut(n, {
        animation: { duration: 320, easing: Mo.easeOutQuint }
      });
    }
  }
  onQuadrupleClick(e) {
    if (e.phase === "settle") {
      const n = this.editor.getZoomLevel(), {
        inputs: { currentScreenPoint: r }
      } = this.editor;
      n === 1 ? this.editor.zoomToFit({ animation: { duration: 400, easing: Mo.easeOutQuint } }) : this.editor.resetZoom(r, {
        animation: { duration: 320, easing: Mo.easeOutQuint }
      });
    }
  }
}
P(T_, "id", "hand"), P(T_, "initial", "idle"), P(T_, "isLockable", !1);
var wD;
let bst = (wD = class extends Xe {
  onCancel() {
    this.editor.setCurrentTool("select");
  }
  onPointerDown(e) {
    this.parent.transition("lasering", e);
  }
}, P(wD, "id", "idle"), wD);
class Rfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "scribbleId", "id");
  }
  onEnter() {
    const n = this.editor.scribbles.addScribble({
      color: "laser",
      opacity: 0.7,
      size: 4,
      delay: this.editor.options.laserDelayMs,
      shrink: 0.05,
      taper: !0
    });
    this.scribbleId = n.id, this.pushPointToScribble();
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.pushPointToScribble();
  }
  onPointerUp() {
    this.complete();
  }
  pushPointToScribble() {
    const { x: n, y: r } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, n, r);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
}
P(Rfe, "id", "lasering");
class P_ extends Xe {
  static children() {
    return [bst, Rfe];
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
}
P(P_, "id", "laser"), P(P_, "initial", "idle"), P(P_, "isLockable", !1);
class $fe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
    P(this, "initialSelectedShapeIds", []);
    P(this, "excludedShapeIds", /* @__PURE__ */ new Set());
    P(this, "isWrapMode", !1);
    P(this, "viewportDidChange", !1);
  }
  cleanupViewportChangeReactor() {
  }
  // cleanup function for the viewport reactor
  onEnter(n) {
    const { editor: r } = this, { altKey: s } = r.inputs;
    this.isWrapMode = r.user.getIsWrapMode(), this.viewportDidChange = !1;
    let o = !0;
    if (this.cleanupViewportChangeReactor = ya("viewport change while brushing", () => {
      r.getViewportPageBounds(), !o && !this.viewportDidChange && (this.viewportDidChange = !0);
    }), s) {
      this.parent.transition("scribble_brushing", n);
      return;
    }
    this.excludedShapeIds = new Set(
      r.getCurrentPageShapes().filter(
        (i) => r.isShapeOfType(i, "group") || r.isShapeOrAncestorLocked(i)
      ).map((i) => i.id)
    ), this.info = n, this.initialSelectedShapeIds = r.getSelectedShapeIds().slice(), this.hitTestShapes(), o = !1;
  }
  onExit() {
    this.initialSelectedShapeIds = [], this.editor.updateInstanceState({ brush: null }), this.cleanupViewportChangeReactor();
  }
  onTick({ elapsed: n }) {
    const { editor: r } = this;
    r.edgeScrollManager.updateEdgeScrolling(n);
  }
  onPointerMove() {
    this.hitTestShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel(n) {
    this.editor.setSelectedShapes(this.initialSelectedShapeIds), this.parent.transition("idle", n);
  }
  onKeyDown(n) {
    this.editor.inputs.altKey ? this.parent.transition("scribble_brushing", n) : this.hitTestShapes();
  }
  onKeyUp() {
    this.hitTestShapes();
  }
  complete() {
    this.hitTestShapes(), this.parent.transition("idle");
  }
  hitTestShapes() {
    const { editor: n, excludedShapeIds: r, isWrapMode: s } = this, {
      inputs: { originPagePoint: o, currentPagePoint: i, shiftKey: a, ctrlKey: c }
    } = n, l = new Set(a ? this.initialSelectedShapeIds : []), d = s ? !c : c, u = _e.FromPoints([o, i]), { corners: f } = u;
    let p, g, y, m, v, b;
    const w = n.getViewportPageBounds().contains(u) && !this.viewportDidChange ? n.getCurrentPageRenderingShapesSorted() : n.getCurrentPageShapesSorted(), S = n.getCurrentPageId();
    e: for (let E = 0, M = w.length; E < M; E++) {
      if (y = w[E], r.has(y.id) || l.has(y.id) || (m = n.getShapePageBounds(y), !m)) continue e;
      if (u.contains(m)) {
        this.handleHit(y, i, S, l, f);
        continue e;
      }
      if (d || n.isShapeOfType(y, "frame"))
        continue e;
      if (u.collides(m)) {
        if (v = n.getShapePageTransform(y), !v) continue e;
        b = v.clone().invert().applyToPoints(f);
        const N = n.getShapeGeometry(y);
        t: for (let O = 0; O < 4; O++)
          if (p = b[O], g = b[(O + 1) % 4], N.hitTestLineSegment(p, g, 0)) {
            this.handleHit(y, i, S, l, f);
            break t;
          }
      }
    }
    const C = n.getInstanceState().brush;
    (!C || !u.equals(C)) && n.updateInstanceState({ brush: { ...u.toJson() } });
    const _ = n.getSelectedShapeIds();
    (_.length !== l.size || _.some((E) => !l.has(E))) && n.setSelectedShapes(Array.from(l));
  }
  onInterrupt() {
    this.editor.updateInstanceState({ brush: null });
  }
  handleHit(n, r, s, o, i) {
    if (n.parentId === s) {
      o.add(n.id);
      return;
    }
    const a = this.editor.getOutermostSelectableShape(n), c = this.editor.getShapeMask(a.id);
    c && !kne(c, i) && !li(r, c) || o.add(a.id);
  }
}
P($fe, "id", "brushing");
const Cy = {
  bottom: "ns-resize",
  top: "ns-resize",
  left: "ew-resize",
  right: "ew-resize",
  bottom_left: "nesw-resize",
  bottom_right: "nwse-resize",
  top_left: "nwse-resize",
  top_right: "nesw-resize",
  bottom_left_rotate: "swne-rotate",
  bottom_right_rotate: "senw-rotate",
  top_left_rotate: "nwse-rotate",
  top_right_rotate: "nesw-rotate",
  mobile_rotate: "grabbing"
};
class Lfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
  }
  updateCursor() {
    const n = this.editor.getSelectedShapes(), r = Cy[this.info.handle];
    this.editor.setCursor({
      type: r,
      rotation: n.length === 1 ? this.editor.getSelectionRotation() : 0
    });
  }
  onEnter(n) {
    this.info = n, this.updateCursor();
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.startResizing();
  }
  onLongPress() {
    this.startResizing();
  }
  startResizing() {
    this.editor.getIsReadonly() || this.parent.transition("resizing", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  cancel() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
}
P(Lfe, "id", "pointing_resize_handle");
class x4 extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
    P(this, "markId", "");
    P(this, "snapshot", {});
  }
  onEnter(n) {
    this.info = n, this.markId = this.editor.markHistoryStoppingPoint("cropping"), this.snapshot = this.createSnapshot(), this.updateShapes();
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    this.updateShapes();
  }
  onKeyUp() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  updateCursor() {
    if (!this.editor.getSelectedShapes()[0]) return;
    const r = Cy[this.info.handle];
    this.editor.setCursor({ type: r, rotation: this.editor.getSelectionRotation() });
  }
  updateShapes() {
    var p;
    const { shape: n, cursorHandleOffset: r } = this.snapshot;
    if (!n) return;
    const s = this.editor.getShapeUtil(n.type);
    if (!s) return;
    const { shiftKey: o } = this.editor.inputs, i = this.editor.inputs.currentPagePoint.clone().sub(r), a = this.editor.inputs.originPagePoint.clone().sub(r), c = i.clone().sub(a).rot(-n.rotation), l = n.props.crop ?? Vc(), d = il(n.props, l), f = (((p = s.onCrop) == null ? void 0 : p.bind(s)) ?? VQe)(n, {
      handle: this.info.handle,
      change: c,
      crop: l,
      uncroppedSize: d,
      initialShape: this.snapshot.shape,
      aspectRatioLocked: o
    });
    f && (this.editor.updateShapes([
      {
        id: n.id,
        type: n.type,
        ...f
      }
    ]), this.updateCursor());
  }
  complete() {
    this.updateShapes(), An(this.editor, [this.snapshot.shape.id]), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
  createSnapshot() {
    const n = this.editor.getSelectionRotation(), {
      inputs: { originPagePoint: r }
    } = this.editor, s = this.editor.getOnlySelectedShape(), o = this.editor.getSelectionRotatedPageBounds(), i = I.RotWith(
      o.getHandlePoint(this.info.handle),
      o.point,
      n
    ), a = I.Sub(r, i);
    return {
      shape: s,
      cursorHandleOffset: a
    };
  }
}
P(x4, "id", "cropping");
function w4(t, e = !1) {
  const n = t.getZoomLevel(), {
    inputs: { currentPagePoint: r }
  } = t;
  return (
    // hovered shape at point
    // selected shape at point
    t.getShapeAtPoint(r, {
      hitInside: !1,
      hitLabels: e,
      margin: t.options.hitTestMargin / n,
      renderingOnly: !0
    }) ?? t.getSelectedShapeAtPoint(r)
  );
}
function Ffe(t, e, n) {
  if (!e)
    throw Error("Needs to translate a cropped shape!");
  const { crop: r } = e.props;
  if (!r)
    return;
  const s = t.inputs.shiftKey ? Math.abs(n.x) < Math.abs(n.y) ? "x" : "y" : null;
  s === "x" ? n.x = 0 : s === "y" && (n.y = 0), n.rot(-e.rotation);
  const { w: o, h: i } = il(e.props, r), a = r.bottomRight.x - r.topLeft.x, c = r.bottomRight.y - r.topLeft.y, l = mr(r), d = 1 - a, u = 1 - c;
  return l.topLeft.x = wt(l.topLeft.x - n.x / o, 0, d), l.topLeft.y = wt(l.topLeft.y - n.y / i, 0, u), l.bottomRight.x = l.topLeft.x + a, l.bottomRight.y = l.topLeft.y + c, {
    id: e.id,
    type: e.type,
    props: {
      crop: l
    }
  };
}
var SD;
let xst = (SD = class extends Xe {
  onEnter() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    const e = this.editor.getOnlySelectedShape();
    e && this.editor.setCroppingShape(e.id);
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onCancel() {
    this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle", {});
  }
  onPointerDown(e) {
    var n;
    if (e.accelKey) {
      this.cancel(), this.editor.root.handleEvent(e);
      return;
    }
    switch (e.target) {
      case "canvas": {
        const r = w4(this.editor);
        if (r && !this.editor.isShapeOfType(r, "group")) {
          this.onPointerDown({
            ...e,
            shape: r,
            target: "shape"
          });
          return;
        }
        this.cancel(), this.editor.root.handleEvent(e);
        break;
      }
      case "shape": {
        if (e.shape.id === this.editor.getCroppingShapeId()) {
          this.editor.setCurrentTool("select.crop.pointing_crop", e);
          return;
        } else
          (n = this.editor.getShapeUtil(e.shape)) != null && n.canCrop(e.shape) ? (this.editor.setCroppingShape(e.shape.id), this.editor.setSelectedShapes([e.shape.id]), this.editor.setCurrentTool("select.crop.pointing_crop", e)) : (this.cancel(), this.editor.root.handleEvent(e));
        break;
      }
      case "selection": {
        switch (e.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            this.editor.setCurrentTool("select.pointing_rotate_handle", {
              ...e,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            this.editor.setCurrentTool("select.crop.pointing_crop_handle", {
              ...e,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          default:
            this.cancel();
        }
        break;
      }
    }
  }
  onDoubleClick(e) {
    var o;
    if (this.editor.inputs.shiftKey || e.phase !== "up") return;
    const n = this.editor.getCroppingShapeId();
    if (!n) return;
    const r = this.editor.getShape(n);
    if (!r) return;
    const s = this.editor.getShapeUtil(r);
    if (s) {
      if (e.target === "selection") {
        (o = s.onDoubleClickEdge) == null || o.call(s, r, e);
        return;
      }
      this.cancel(), this.editor.root.handleEvent(e);
    }
  }
  onKeyDown() {
    this.nudgeCroppingImage(!1);
  }
  onKeyRepeat() {
    this.nudgeCroppingImage(!0);
  }
  onKeyUp(e) {
    switch (e.code) {
      case "Enter": {
        this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle", {});
        break;
      }
    }
  }
  cancel() {
    this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle", {});
  }
  nudgeCroppingImage(e = !1) {
    const {
      editor: {
        inputs: { keys: n }
      }
    } = this, r = n.has("ShiftLeft"), s = new I(0, 0);
    if (n.has("ArrowLeft") && (s.x += 1), n.has("ArrowRight") && (s.x -= 1), n.has("ArrowUp") && (s.y += 1), n.has("ArrowDown") && (s.y -= 1), s.equals(new I(0, 0))) return;
    r && s.mul(10);
    const o = this.editor.getShape(this.editor.getCroppingShapeId());
    if (!o) return;
    const i = Ffe(this.editor, o, s);
    i && (e || this.editor.markHistoryStoppingPoint("translate crop"), this.editor.updateShapes([i]));
  }
}, P(SD, "id", "idle"), SD);
class Bfe extends Xe {
  onCancel() {
    this.editor.setCurrentTool("select.crop.idle", {});
  }
  onPointerMove(e) {
    this.editor.inputs.isDragging && this.startDragging(e);
  }
  onLongPress(e) {
    this.startDragging(e);
  }
  onPointerUp(e) {
    this.editor.setCurrentTool("select.crop.idle", e);
  }
  startDragging(e) {
    this.editor.setCurrentTool("select.crop.translating_crop", e);
  }
}
P(Bfe, "id", "pointing_crop");
class S4 extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
  }
  onEnter(n) {
    this.info = n, this.parent.setCurrentToolIdMask(n.onInteractionEnd);
    const r = this.editor.getSelectedShapes()[0];
    if (!r) return;
    const s = Cy[this.info.handle];
    this.editor.setCursor({ type: s, rotation: this.editor.getSelectionRotation() }), this.editor.setCroppingShape(r.id);
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 }), this.parent.setCurrentToolIdMask(void 0);
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.startCropping();
  }
  onLongPress() {
    this.startCropping();
  }
  startCropping() {
    this.editor.getIsReadonly() || this.parent.transition("cropping", {
      ...this.info,
      onInteractionEnd: this.info.onInteractionEnd
    });
  }
  onPointerUp() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
}
P(S4, "id", "pointing_crop_handle");
class zfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
    P(this, "markId", "");
    P(this, "snapshot", {});
  }
  onEnter(n) {
    this.info = n, this.snapshot = this.createSnapshot(), this.markId = this.editor.markHistoryStoppingPoint("translating_crop"), this.editor.setCursor({ type: "move", rotation: 0 }), this.updateShapes();
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onKeyDown(n) {
    switch (n.key) {
      case "Alt":
      case "Shift": {
        this.updateShapes();
        return;
      }
    }
  }
  onKeyUp(n) {
    switch (n.key) {
      case "Enter": {
        this.complete();
        return;
      }
      case "Alt":
      case "Shift":
        this.updateShapes();
    }
  }
  complete() {
    this.updateShapes(), this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  createSnapshot() {
    return { shape: this.editor.getOnlySelectedShape() };
  }
  updateShapes() {
    const n = this.snapshot.shape;
    if (!n) return;
    const { originPagePoint: r, currentPagePoint: s } = this.editor.inputs, o = s.clone().sub(r), i = Ffe(this.editor, n, o);
    i && this.editor.updateShapes([i]);
  }
}
P(zfe, "id", "translating_crop");
class DR extends Xe {
  constructor() {
    super(...arguments);
    P(this, "markId", "");
    P(this, "didExit", !1);
  }
  static children() {
    return [xst, zfe, Bfe, S4, x4];
  }
  onEnter() {
    this.didExit = !1, this.markId = this.editor.markHistoryStoppingPoint("crop");
  }
  onExit() {
    this.didExit || (this.didExit = !0, this.editor.squashToMark(this.markId));
  }
  onCancel() {
    this.didExit || (this.didExit = !0, this.editor.bailToMark(this.markId));
  }
}
P(DR, "id", "crop"), P(DR, "initial", "idle");
class Ufe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeId");
    P(this, "initialHandle");
    P(this, "initialAdjacentHandle");
    P(this, "initialPagePoint");
    P(this, "markId");
    P(this, "initialPageTransform");
    P(this, "initialPageRotation");
    P(this, "info");
    P(this, "isPrecise", !1);
    P(this, "isPreciseId", null);
    P(this, "pointingId", null);
    // Only relevant to arrows
    P(this, "exactTimeout", -1);
  }
  onEnter(n) {
    var f;
    const { shape: r, isCreating: s, creatingMarkId: o, handle: i } = n;
    if (this.info = n, this.parent.setCurrentToolIdMask(n.onInteractionEnd), this.shapeId = r.id, this.markId = "", s)
      if (o)
        this.markId = o;
      else {
        const p = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        p && (this.markId = p);
      }
    else
      this.markId = this.editor.markHistoryStoppingPoint("dragging handle");
    this.initialHandle = mr(i), this.initialPageTransform = this.editor.getShapePageTransform(r), this.initialPageRotation = this.initialPageTransform.rotation(), this.initialPagePoint = this.editor.inputs.originPagePoint.clone(), this.editor.setCursor({ type: s ? "cross" : "grabbing", rotation: 0 });
    const a = this.editor.getShapeHandles(r).sort(Js), c = a.findIndex((p) => p.id === n.handle.id);
    this.initialAdjacentHandle = null;
    for (let p = c + 1; p < a.length; p++) {
      const g = a[p];
      if (g.type === "vertex" && g.id !== "middle" && g.id !== n.handle.id) {
        this.initialAdjacentHandle = g;
        break;
      }
    }
    if (!this.initialAdjacentHandle)
      for (let p = a.length - 1; p >= 0; p--) {
        const g = a[p];
        if (g.type === "vertex" && g.id !== "middle" && g.id !== n.handle.id) {
          this.initialAdjacentHandle = g;
          break;
        }
      }
    if (this.editor.isShapeOfType(r, "arrow")) {
      const p = As(this.editor, r)[n.handle.id];
      this.isPrecise = !1, p && (this.isPrecise = p.props.isPrecise, this.isPrecise ? this.isPreciseId = p.toId : this.resetExactTimeout());
    }
    const l = {
      handle: this.initialHandle,
      isPrecise: this.isPrecise,
      initial: r
    }, d = this.editor.getShapeUtil(r), u = (f = d.onHandleDragStart) == null ? void 0 : f.call(d, r, l);
    u && this.editor.updateShapes([{ ...u, id: r.id, type: r.type }]), this.update(), this.editor.select(this.shapeId);
  }
  // Only relevant to arrows
  resetExactTimeout() {
    this.exactTimeout !== -1 && this.clearExactTimeout(), this.exactTimeout = this.editor.timers.setTimeout(() => {
      this.getIsActive() && !this.isPrecise && (this.isPrecise = !0, this.isPreciseId = this.pointingId, this.update()), this.exactTimeout = -1;
    }, 750);
  }
  // Only relevant to arrows
  clearExactTimeout() {
    this.exactTimeout !== -1 && (clearTimeout(this.exactTimeout), this.exactTimeout = -1);
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.update(), this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), B5(this.editor), this.editor.snaps.clearIndicators(), this.editor.setCursor({ type: "default", rotation: 0 });
  }
  complete() {
    var s;
    this.editor.snaps.clearIndicators(), An(this.editor, [this.shapeId]);
    const n = this.editor.getShape(this.shapeId);
    if (n) {
      const o = this.editor.getShapeUtil(n), i = {
        handle: this.initialHandle,
        isPrecise: this.isPrecise,
        initial: this.info.shape
      }, a = (s = o.onHandleDragEnd) == null ? void 0 : s.call(o, n, i);
      a && this.editor.updateShapes([{ ...a, id: n.id, type: n.type }]);
    }
    const { onInteractionEnd: r } = this.info;
    if (this.editor.getInstanceState().isToolLocked && r) {
      this.editor.setCurrentTool(r, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    var s;
    const n = this.editor.getShape(this.shapeId);
    if (n) {
      const o = this.editor.getShapeUtil(n), i = {
        handle: this.initialHandle,
        isPrecise: this.isPrecise,
        initial: this.info.shape
      };
      (s = o.onHandleDragCancel) == null || s.call(o, n, i);
    }
    this.editor.bailToMark(this.markId), this.editor.snaps.clearIndicators();
    const { onInteractionEnd: r } = this.info;
    if (r) {
      this.editor.setCurrentTool(r, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle");
  }
  update() {
    var _;
    const { editor: n, shapeId: r, initialPagePoint: s } = this, { initialHandle: o, initialPageRotation: i, initialAdjacentHandle: a } = this, c = this.editor.user.getIsSnapMode(), {
      snaps: l,
      inputs: { currentPagePoint: d, shiftKey: u, ctrlKey: f, altKey: p, pointerVelocity: g }
    } = n, y = this.info.shape, m = n.getShape(r);
    if (!m) return;
    const v = n.getShapeUtil(m), b = n.isShapeOfType(m, "arrow") ? As(n, m)[o.id] : void 0;
    let x = d.clone().sub(s).rot(-i).add(o);
    if (u && a && o.id !== "middle") {
      const E = I.Angle(a, x), N = $E(E, 24) - E;
      x = I.RotWith(x, a, N);
    }
    n.snaps.clearIndicators();
    let w = { ...o, x: x.x, y: x.y };
    if (o.canSnap && (c ? !f : f)) {
      if (!n.getShapePageTransform(m.id)) throw Error("Expected a page transform");
      const M = l.handles.snapHandle({ currentShapeId: r, handle: w });
      M && (M.nudge.rot(-n.getShapeParentTransform(m).rotation()), x.add(M.nudge), w = { ...o, x: x.x, y: x.y });
    }
    const S = (_ = v.onHandleDrag) == null ? void 0 : _.call(v, m, {
      handle: w,
      isPrecise: this.isPrecise || p,
      initial: y
    }), C = { id: m.id, type: m.type, ...S };
    if (o.type === "vertex" && this.editor.isShapeOfType(m, "arrow")) {
      const E = As(n, m)[o.id];
      E ? (b == null ? void 0 : b.toId) !== E.toId && (this.pointingId = E.toId, this.isPrecise = g.len() < 0.5 || p, this.isPreciseId = this.isPrecise ? E.toId : null, this.resetExactTimeout()) : b && (this.pointingId = null, this.isPrecise = !1, this.isPreciseId = null, this.resetExactTimeout());
    }
    S && n.updateShapes([C]);
  }
}
P(Ufe, "id", "dragging_handle");
function Hfe(t) {
  return t.isLabel ? [t] : t instanceof ui ? t.children.filter((e) => e.isLabel) : [];
}
class Vfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "hitShapeForPointerUp", null);
    P(this, "info", {});
  }
  onEnter(n) {
    const r = this.editor.getEditingShape();
    if (!r) throw Error("Entered editing state without an editing shape");
    this.hitShapeForPointerUp = null, this.info = n, n.isCreatingTextWhileToolLocked && this.parent.setCurrentToolIdMask("text"), Kd(this.editor), this.editor.select(r);
  }
  onExit() {
    const { editingShapeId: n } = this.editor.getCurrentPageState();
    n && (this.editor.setEditingShape(null), Kd.cancel(), this.info.isCreatingTextWhileToolLocked && (this.parent.setCurrentToolIdMask(void 0), this.editor.setCurrentTool("text", {})));
  }
  onPointerMove(n) {
    if (this.hitShapeForPointerUp && this.editor.inputs.isDragging) {
      if (this.editor.getIsReadonly() || this.hitShapeForPointerUp.isLocked) return;
      this.editor.select(this.hitShapeForPointerUp), this.parent.transition("translating", n), this.hitShapeForPointerUp = null;
      return;
    }
    switch (n.target) {
      case "shape":
      case "canvas": {
        Kd(this.editor);
        return;
      }
    }
  }
  onPointerDown(n) {
    switch (this.hitShapeForPointerUp = null, n.target) {
      case "canvas": {
        const r = w4(
          this.editor,
          !0
          /* hitLabels */
        );
        if (r) {
          this.onPointerDown({
            ...n,
            shape: r,
            target: "shape"
          });
          return;
        }
        break;
      }
      case "shape": {
        const { shape: r } = n, s = this.editor.getEditingShape();
        if (!s)
          throw Error("Expected an editing shape!");
        const o = this.editor.getShapeUtil(r).getGeometry(r), i = Hfe(o), a = i.length === 1 ? i[0] : void 0, c = this.editor.isShapeOfType(s, "text") && Lp(this.editor, s.props.richText).trim() === "";
        if (a && !c) {
          const l = this.editor.getPointInShapeSpace(
            r,
            this.editor.inputs.currentPagePoint
          );
          if (a.bounds.containsPoint(l, 0) && a.hitTestPoint(l)) {
            if (r.id === s.id)
              return;
            this.hitShapeForPointerUp = r, this.editor.markHistoryStoppingPoint("editing on pointer up"), this.editor.select(r.id);
            return;
          }
        } else {
          if (r.id === s.id)
            this.editor.isShapeOfType(r, "frame") && (this.editor.setEditingShape(null), this.parent.transition("idle", n));
          else {
            this.parent.transition("pointing_shape", n);
            return;
          }
          return;
        }
        break;
      }
    }
    this.parent.transition("idle", n), this.editor.root.handleEvent(n);
  }
  onPointerUp(n) {
    const r = this.hitShapeForPointerUp;
    if (!r) return;
    this.hitShapeForPointerUp = null;
    const s = this.editor.getShapeUtil(r);
    if (r.isLocked) return;
    if (this.editor.getIsReadonly() && !s.canEditInReadonly(r)) {
      this.parent.transition("pointing_shape", n);
      return;
    }
    this.editor.select(r.id);
    const o = this.editor.getEditingShape(), i = o && o.id !== r.id;
    this.editor.setEditingShape(r.id);
    const a = dn.isIos || dn.isAndroid;
    !a || !i ? this.editor.emit("place-caret", { shapeId: r.id, point: n.point }) : a && i && this.editor.emit("select-all-text", { shapeId: r.id }), Kd(this.editor);
  }
  onComplete(n) {
    this.editor.getContainer().focus(), this.parent.transition("idle", n);
  }
  onCancel(n) {
    this.editor.getContainer().focus(), this.parent.transition("idle", n);
  }
}
P(Vfe, "id", "editing_shape");
function w7(t) {
  const e = t.getOnlySelectedShape();
  return !!(e && !t.isShapeOrAncestorLocked(e) && t.getShapeUtil(e).canCrop(e));
}
function ZT(t, e) {
  const n = t.getSelectedShapeIds(), { currentPagePoint: r } = t.inputs, { shiftKey: s, altKey: o, accelKey: i } = e, a = s || i, c = t.getShapeAtPoint(r, {
    hitInside: !1,
    margin: t.options.hitTestMargin / t.getZoomLevel(),
    hitLabels: !0,
    renderingOnly: !0,
    filter: (l) => !l.isLocked
  });
  if (c) {
    const l = t.getOutermostSelectableShape(c);
    if (a && !o)
      t.cancelDoubleClick(), n.includes(l.id) ? (t.markHistoryStoppingPoint("deselecting shape"), t.deselect(l)) : (t.markHistoryStoppingPoint("shift selecting shape"), t.setSelectedShapes([...n, l.id]));
    else {
      let d;
      l === c || l.id === t.getFocusedGroupId() || n.includes(l.id) ? d = c : d = l, d && !n.includes(d.id) && (t.markHistoryStoppingPoint("selecting shape"), t.select(d.id));
    }
  } else {
    if (a)
      return;
    {
      n.length > 0 && (t.markHistoryStoppingPoint("selecting none"), t.selectNone());
      const l = t.getFocusedGroupId();
      if (ei(l)) {
        const d = t.getShape(l);
        t.isPointInShape(d, r, { margin: 0, hitInside: !0 }) || t.setFocusedGroup(null);
      }
    }
  }
}
const wst = [
  "Delete",
  "Backspace",
  "[",
  "]",
  "Enter",
  " ",
  "Shift",
  "Tab"
];
var CD;
let Sst = (CD = class extends Xe {
  constructor() {
    super(...arguments);
    P(this, "selectedShapesOnKeyDown", []);
  }
  onEnter() {
    this.parent.setCurrentToolIdMask(void 0), Kd(this.editor), this.selectedShapesOnKeyDown = [], this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onExit() {
    Kd.cancel();
  }
  onPointerMove() {
    Kd(this.editor);
  }
  onPointerDown(n) {
    const r = n.ctrlKey && w7(this.editor);
    switch (n.target) {
      case "canvas": {
        const s = w4(this.editor);
        if (s && !s.isLocked) {
          this.onPointerDown({
            ...n,
            shape: s,
            target: "shape"
          });
          return;
        }
        const o = this.editor.getSelectedShapeIds(), i = this.editor.getOnlySelectedShape(), {
          inputs: { currentPagePoint: a }
        } = this.editor;
        if ((o.length > 1 || i && !this.editor.getShapeUtil(i).hideSelectionBoundsBg(i)) && S7(this.editor, a)) {
          this.onPointerDown({
            ...n,
            target: "selection"
          });
          return;
        }
        this.parent.transition("pointing_canvas", n);
        break;
      }
      case "shape": {
        const { shape: s } = n;
        if (this.isOverArrowLabelTest(s)) {
          this.parent.transition("pointing_arrow_label", n);
          break;
        }
        if (this.editor.isShapeOrAncestorLocked(s)) {
          this.parent.transition("pointing_canvas", n);
          break;
        }
        this.parent.transition("pointing_shape", n);
        break;
      }
      case "handle": {
        if (this.editor.getIsReadonly()) break;
        this.editor.inputs.altKey ? this.parent.transition("pointing_shape", n) : this.parent.transition("pointing_handle", n);
        break;
      }
      case "selection": {
        switch (n.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            if (n.accelKey) {
              this.parent.transition("brushing", n);
              break;
            }
            this.parent.transition("pointing_rotate_handle", n);
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            if (r)
              this.parent.transition("crop.pointing_crop_handle", n);
            else {
              if (n.accelKey) {
                this.parent.transition("brushing", n);
                break;
              }
              this.parent.transition("pointing_resize_handle", n);
            }
            break;
          }
          default: {
            const s = this.editor.getHoveredShape();
            if (s && !this.editor.getSelectedShapeIds().includes(s.id) && !s.isLocked) {
              this.onPointerDown({
                ...n,
                shape: s,
                target: "shape"
              });
              return;
            }
            this.parent.transition("pointing_selection", n);
          }
        }
        break;
      }
    }
  }
  onDoubleClick(n) {
    var r, s, o, i, a;
    if (!(this.editor.inputs.shiftKey || n.phase !== "up") && !(n.ctrlKey || n.shiftKey))
      switch (n.target) {
        case "canvas": {
          const c = this.editor.getHoveredShape(), l = c && !this.editor.isShapeOfType(c, "group") ? c : this.editor.getSelectedShapeAtPoint(this.editor.inputs.currentPagePoint) ?? this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
            margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
            hitInside: !1
          }), d = this.editor.getFocusedGroupId();
          if (l) {
            if (this.editor.isShapeOfType(l, "group")) {
              ZT(this.editor, n);
              return;
            } else {
              const u = this.editor.getShape(l.parentId);
              if (u && this.editor.isShapeOfType(u, "group") && !(d && u.id === d)) {
                ZT(this.editor, n);
                return;
              }
            }
            this.onDoubleClick({
              ...n,
              shape: l,
              target: "shape"
            });
            return;
          }
          this.editor.inputs.shiftKey || this.handleDoubleClickOnCanvas(n);
          break;
        }
        case "selection": {
          if (this.editor.getIsReadonly()) break;
          const c = this.editor.getOnlySelectedShape();
          if (c) {
            const l = this.editor.getShapeUtil(c);
            if (!this.canInteractWithShapeInReadOnly(c))
              return;
            if (n.handle === "right" || n.handle === "left" || n.handle === "top" || n.handle === "bottom") {
              const d = (r = l.onDoubleClickEdge) == null ? void 0 : r.call(l, c, n);
              if (d) {
                this.editor.markHistoryStoppingPoint("double click edge"), this.editor.updateShapes([d]), An(this.editor, [c.id]);
                return;
              }
            }
            if (n.handle === "top_left" || n.handle === "top_right" || n.handle === "bottom_right" || n.handle === "bottom_left") {
              const d = (s = l.onDoubleClickCorner) == null ? void 0 : s.call(l, c, n);
              if (d) {
                this.editor.markHistoryStoppingPoint("double click corner"), this.editor.updateShapes([d]), An(this.editor, [c.id]);
                return;
              }
            }
            if (l.canCrop(c) && !this.editor.isShapeOrAncestorLocked(c)) {
              this.parent.transition("crop", n);
              return;
            }
            this.shouldStartEditingShape(c) && this.startEditingShape(
              c,
              n,
              !0
              /* select all */
            );
          }
          break;
        }
        case "shape": {
          const { shape: c } = n, l = this.editor.getShapeUtil(c);
          if (c.type !== "video" && c.type !== "embed" && this.editor.getIsReadonly()) break;
          if (l.onDoubleClick) {
            const d = (o = l.onDoubleClick) == null ? void 0 : o.call(l, c);
            if (d) {
              this.editor.updateShapes([d]);
              return;
            }
          }
          if (l.canCrop(c) && !this.editor.isShapeOrAncestorLocked(c)) {
            this.editor.markHistoryStoppingPoint("select and crop"), this.editor.select((i = n.shape) == null ? void 0 : i.id), this.parent.transition("crop", n);
            return;
          }
          this.shouldStartEditingShape(c) ? this.startEditingShape(
            c,
            n,
            !0
            /* select all */
          ) : this.handleDoubleClickOnCanvas(n);
          break;
        }
        case "handle": {
          if (this.editor.getIsReadonly()) break;
          const { shape: c, handle: l } = n, d = this.editor.getShapeUtil(c), u = (a = d.onDoubleClickHandle) == null ? void 0 : a.call(d, c, l);
          u ? this.editor.updateShapes([u]) : this.shouldStartEditingShape(c) && this.startEditingShape(
            c,
            n,
            !0
            /* select all */
          );
        }
      }
  }
  onRightClick(n) {
    switch (n.target) {
      case "canvas": {
        const r = this.editor.getHoveredShape(), s = r && !this.editor.isShapeOfType(r, "group") ? r : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
          margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
          hitInside: !1,
          hitLabels: !0,
          hitLocked: !0,
          hitFrameInside: !0,
          renderingOnly: !0
        });
        if (s) {
          this.onRightClick({
            ...n,
            shape: s,
            target: "shape"
          });
          return;
        }
        const o = this.editor.getSelectedShapeIds(), i = this.editor.getOnlySelectedShape(), {
          inputs: { currentPagePoint: a }
        } = this.editor;
        if ((o.length > 1 || i && !this.editor.getShapeUtil(i).hideSelectionBoundsBg(i)) && S7(this.editor, a)) {
          this.onRightClick({
            ...n,
            target: "selection"
          });
          return;
        }
        this.editor.selectNone();
        break;
      }
      case "shape": {
        const { selectedShapeIds: r } = this.editor.getCurrentPageState(), { shape: s } = n, o = this.editor.getOutermostSelectableShape(
          s,
          (i) => !r.includes(i.id)
        );
        !r.includes(o.id) && !this.editor.findShapeAncestor(
          o,
          (i) => r.includes(i.id)
        ) && (this.editor.markHistoryStoppingPoint("selecting shape"), this.editor.setSelectedShapes([o.id]));
        break;
      }
    }
  }
  onCancel() {
    this.editor.getFocusedGroupId() !== this.editor.getCurrentPageId() && this.editor.getSelectedShapeIds().length > 0 ? this.editor.popFocusedGroupId() : (this.editor.markHistoryStoppingPoint("clearing selection"), this.editor.selectNone());
  }
  onKeyDown(n) {
    switch (this.selectedShapesOnKeyDown = this.editor.getSelectedShapes(), n.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        if (n.accelKey) {
          n.shiftKey ? n.code === "ArrowDown" ? this.editor.selectFirstChildShape() : n.code === "ArrowUp" && this.editor.selectParentShape() : this.editor.selectAdjacentShape(
            n.code.replace("Arrow", "").toLowerCase()
          );
          return;
        }
        this.nudgeSelectedShapes(!1);
        return;
      }
    }
    if (ir.editOnType.get() && !wst.includes(n.key) && !n.altKey && !n.ctrlKey) {
      const r = this.editor.getOnlySelectedShape();
      if (r && // If it's a note shape, then edit on type
      this.editor.isShapeOfType(r, "note") && // If it's not locked or anything
      this.shouldStartEditingShape(r)) {
        this.startEditingShape(
          r,
          {
            ...n,
            target: "shape",
            shape: r
          },
          !0
          /* select all */
        );
        return;
      }
    }
  }
  onKeyRepeat(n) {
    switch (n.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        if (n.accelKey) {
          this.editor.selectAdjacentShape(
            n.code.replace("Arrow", "").toLowerCase()
          );
          return;
        }
        this.nudgeSelectedShapes(!0);
        break;
      }
      case "Tab": {
        this.editor.getSelectedShapes().length && this.editor.selectAdjacentShape(n.shiftKey ? "prev" : "next");
        break;
      }
    }
  }
  onKeyUp(n) {
    switch (n.code) {
      case "Enter": {
        if (!this.selectedShapesOnKeyDown.length) return;
        const r = this.editor.getSelectedShapes();
        if (r.every((o) => this.editor.isShapeOfType(o, "group"))) {
          this.editor.setSelectedShapes(
            r.flatMap((o) => this.editor.getSortedChildIdsForParent(o.id))
          );
          return;
        }
        const s = this.editor.getOnlySelectedShape();
        if (s && this.shouldStartEditingShape(s)) {
          this.startEditingShape(
            s,
            {
              ...n,
              target: "shape",
              shape: s
            },
            !0
            /* select all */
          );
          return;
        }
        w7(this.editor) && this.parent.transition("crop", n);
        break;
      }
      case "Tab": {
        this.editor.getSelectedShapes().length && this.editor.selectAdjacentShape(n.shiftKey ? "prev" : "next");
        break;
      }
    }
  }
  shouldStartEditingShape(n = this.editor.getOnlySelectedShape()) {
    return !n || this.editor.isShapeOrAncestorLocked(n) && n.type !== "embed" || !this.canInteractWithShapeInReadOnly(n) ? !1 : this.editor.getShapeUtil(n).canEdit(n);
  }
  startEditingShape(n, r, s) {
    this.editor.isShapeOrAncestorLocked(n) && n.type !== "embed" || (this.editor.markHistoryStoppingPoint("editing shape"), XT(this.editor, n, s), this.parent.transition("editing_shape", r));
  }
  isOverArrowLabelTest(n) {
    if (!n) return !1;
    if (this.editor.isShapeOfType(n, "arrow")) {
      const r = this.editor.getPointInShapeSpace(
        n,
        this.editor.inputs.currentPagePoint
      ), s = this.editor.getShapeGeometry(n).children[1];
      if (s && li(r, s.vertices))
        return !0;
    }
    return !1;
  }
  handleDoubleClickOnCanvas(n) {
    if (this.editor.getIsReadonly() || !this.editor.options.createTextOnCanvasDoubleClick) return;
    this.editor.markHistoryStoppingPoint("creating text shape");
    const r = $n(), { x: s, y: o } = this.editor.inputs.currentPagePoint;
    this.editor.createShapes([
      {
        id: r,
        type: "text",
        x: s,
        y: o,
        props: {
          richText: dc(""),
          autoSize: !0
        }
      }
    ]);
    const i = this.editor.getShape(r);
    if (!i) return;
    const a = this.editor.getShapeUtil(i);
    this.editor.getIsReadonly() && !a.canEditInReadonly(i) || (this.editor.setEditingShape(r), this.editor.select(r), this.parent.transition("editing_shape", n));
  }
  nudgeSelectedShapes(n = !1) {
    const {
      editor: {
        inputs: { keys: r }
      }
    } = this, s = r.has("ShiftLeft"), o = new I(0, 0);
    if (r.has("ArrowLeft") && (o.x -= 1), r.has("ArrowRight") && (o.x += 1), r.has("ArrowUp") && (o.y -= 1), r.has("ArrowDown") && (o.y += 1), o.equals(new I(0, 0))) return;
    n || this.editor.markHistoryStoppingPoint("nudge shapes");
    const { gridSize: i } = this.editor.getDocumentSettings(), a = this.editor.getInstanceState().isGridMode ? s ? i * Est : i : s ? Cst : _st, c = this.editor.getSelectedShapeIds();
    this.editor.nudgeShapes(c, o.mul(a)), An(this.editor, c);
  }
  canInteractWithShapeInReadOnly(n) {
    return !!(!this.editor.getIsReadonly() || this.editor.getShapeUtil(n).canEditInReadonly(n));
  }
}, P(CD, "id", "idle"), CD);
const Cst = 10, _st = 1, Est = 5;
function S7(t, e) {
  const n = t.getSelectionRotatedPageBounds();
  if (!n) return !1;
  const r = t.getSelectionRotation();
  return r ? li(
    e,
    n.corners.map((s) => I.RotWith(s, n.point, r))
  ) : n.containsPoint(e);
}
class Wfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "shapeId", "");
    P(this, "markId", "");
    P(this, "wasAlreadySelected", !1);
    P(this, "didDrag", !1);
    P(this, "didCtrlOnEnter", !1);
    P(this, "info", {});
    P(this, "_labelDragOffset", new I(0, 0));
  }
  updateCursor() {
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onEnter(n) {
    const { shape: r } = n;
    this.parent.setCurrentToolIdMask(n.onInteractionEnd), this.info = n, this.shapeId = r.id, this.didDrag = !1, this.didCtrlOnEnter = n.accelKey, this.wasAlreadySelected = this.editor.getOnlySelectedShapeId() === r.id, this.updateCursor();
    const o = this.editor.getShapeGeometry(r).children[1];
    if (!o)
      throw Error(`Expected to find an arrow label geometry for shape: ${r.id}`);
    const { currentPagePoint: i } = this.editor.inputs, a = this.editor.getPointInShapeSpace(r, i);
    if (this._labelDragOffset = I.Sub(o.center, a), this.markId = this.editor.markHistoryStoppingPoint("label-drag start"), n.shiftKey || n.accelKey) {
      const l = this.editor.getSelectedShapeIds();
      this.editor.setSelectedShapes([...l, this.shapeId]);
      return;
    }
    this.editor.setSelectedShapes([this.shapeId]);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    const { isDragging: n } = this.editor.inputs;
    if (!n) return;
    if (this.didCtrlOnEnter) {
      this.parent.transition("brushing", this.info);
      return;
    }
    const r = this.editor.getShape(this.shapeId);
    if (!r) return;
    const s = this.editor.getShapeUtil("arrow").options, o = yS(this.editor, r), i = this.editor.getShapePageTransform(r.id), a = this.editor.getPointInShapeSpace(r, this.editor.inputs.currentPagePoint).add(this._labelDragOffset), c = ufe(this.editor, r);
    let l = o.uninterpolateAlongEdge(a);
    isNaN(l) && (l = c);
    const d = i.applyToPoint(o.interpolateAlongEdge(l)), u = i.applyToPoint(
      o.interpolateAlongEdge(c)
    );
    I.DistMin(
      d,
      u,
      s.labelCenterSnapDistance / this.editor.getZoomLevel()
    ) && (l = c), this.didDrag = !0, this.editor.updateShape({
      id: r.id,
      type: r.type,
      props: { labelPosition: l }
    });
  }
  onPointerUp() {
    const n = this.editor.getShape(this.shapeId);
    n && (this.didDrag || !this.wasAlreadySelected ? this.complete() : this.editor.getIsReadonly() || (this.editor.setEditingShape(n.id), this.editor.setCurrentTool("select.editing_shape")));
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
}
P(Wfe, "id", "pointing_arrow_label");
class Kfe extends Xe {
  onEnter(e) {
    e.shiftKey || e.accelKey || this.editor.getSelectedShapeIds().length > 0 && (this.editor.markHistoryStoppingPoint("selecting none"), this.editor.selectNone());
  }
  onPointerMove(e) {
    this.editor.inputs.isDragging && this.parent.transition("brushing", e);
  }
  onPointerUp(e) {
    ZT(this.editor, e), this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle");
  }
  complete() {
    this.parent.transition("idle");
  }
}
P(Kfe, "id", "pointing_canvas");
class Gfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "didCtrlOnEnter", !1);
    P(this, "info", {});
  }
  onEnter(n) {
    this.info = n, this.didCtrlOnEnter = n.accelKey;
    const { shape: r } = n;
    if (this.editor.isShapeOfType(r, "arrow")) {
      const s = As(this.editor, r), o = s[n.handle.id], i = s[n.handle.id === "start" ? "end" : "start"], a = this.editor.getShapePageTransform(r.id);
      o && $k({
        editor: this.editor,
        pointInPageSpace: a.applyToPoint(n.handle),
        arrow: r,
        isPrecise: o.props.isPrecise,
        currentBinding: o,
        oppositeBinding: i
      });
    }
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onExit() {
    this.editor.setHintingShapes([]), this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerUp() {
    const { shape: n, handle: r } = this.info;
    if (this.editor.isShapeOfType(n, "note")) {
      const { editor: s } = this, o = C7(s, n, r, !1);
      if (o) {
        XT(
          s,
          o,
          !0
          /* selectAll */
        );
        return;
      }
    }
    this.parent.transition("idle", this.info);
  }
  onPointerMove(n) {
    const { editor: r } = this;
    r.inputs.isDragging && (this.didCtrlOnEnter ? this.parent.transition("brushing", n) : this.startDraggingHandle());
  }
  onLongPress() {
    this.startDraggingHandle();
  }
  startDraggingHandle() {
    const { editor: n } = this;
    if (n.getIsReadonly()) return;
    const { shape: r, handle: s } = this.info;
    if (n.isShapeOfType(r, "note")) {
      const o = C7(n, r, s, !0);
      if (o) {
        const i = n.getPointInParentSpace(o, n.inputs.originPagePoint).sub(I.Rot(Bk.clone().mul(r.props.scale), o.rotation));
        n.updateShape({ ...o, x: i.x, y: i.y }), n.setHoveredShape(o.id).select(o.id).setCurrentTool("select.translating", {
          ...this.info,
          target: "shape",
          shape: n.getShape(o),
          onInteractionEnd: "note",
          isCreating: !0,
          onCreate: () => {
            XT(
              n,
              o,
              !0
              /* selectAll */
            );
          }
        });
        return;
      }
    }
    this.parent.transition("dragging_handle", this.info);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
}
P(Gfe, "id", "pointing_handle");
function C7(t, e, n, r) {
  const s = t.getShapePageTransform(e.id), o = s.point(), i = s.rotation(), c = efe(
    t,
    o,
    i,
    e.props.growY * e.props.scale,
    0,
    e.props.scale
  )[n.index];
  if (c)
    return nfe(t, e, c, i, r);
}
class Yfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
  }
  updateCursor() {
    this.editor.setCursor({
      type: Cy[this.info.handle],
      rotation: this.editor.getSelectionRotation()
    });
  }
  onEnter(n) {
    this.parent.setCurrentToolIdMask(n.onInteractionEnd), this.info = n, this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.startRotating();
  }
  onLongPress() {
    this.startRotating();
  }
  startRotating() {
    this.editor.getIsReadonly() || this.parent.transition("rotating", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  cancel() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
}
P(Yfe, "id", "pointing_rotate_handle");
class qfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
  }
  onEnter(n) {
    this.info = n;
  }
  onPointerUp(n) {
    ZT(this.editor, n), this.parent.transition("idle", n);
  }
  onPointerMove(n) {
    this.editor.inputs.isDragging && this.startTranslating(n);
  }
  onLongPress(n) {
    this.startTranslating(n);
  }
  startTranslating(n) {
    this.editor.getIsReadonly() || this.parent.transition("translating", n);
  }
  onDoubleClick(n) {
    var o, i;
    const r = this.editor.getHoveredShape(), s = r && !this.editor.isShapeOfType(r, "group") ? r : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
      hitInside: !0,
      margin: 0,
      renderingOnly: !0
    });
    if (s) {
      this.parent.transition("idle"), (i = (o = this.parent).onDoubleClick) == null || i.call(o, {
        ...n,
        target: "shape",
        shape: this.editor.getShape(s)
      });
      return;
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
}
P(qfe, "id", "pointing_selection");
class Xfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "hitShape", {});
    P(this, "hitShapeForPointerUp", {});
    P(this, "isDoubleClick", !1);
    P(this, "didCtrlOnEnter", !1);
    P(this, "didSelectOnEnter", !1);
  }
  onEnter(n) {
    const r = this.editor.getSelectedShapeIds(), s = this.editor.getSelectionRotatedPageBounds(), o = this.editor.getFocusedGroupId(), {
      inputs: { currentPagePoint: i }
    } = this.editor, { shiftKey: a, altKey: c, accelKey: l } = n;
    this.hitShape = n.shape, this.isDoubleClick = !1, this.didCtrlOnEnter = l;
    const d = this.editor.getOutermostSelectableShape(n.shape), u = this.editor.findShapeAncestor(
      d,
      (f) => r.includes(f.id)
    );
    if (this.didCtrlOnEnter || // If the shape has an onClick handler
    this.editor.getShapeUtil(n.shape).onClick || // ...or if the shape is the focused layer (e.g. group)
    d.id === o || // ...or if the shape is within the selection
    r.includes(d.id) || // ...or if an ancestor of the shape is selected
    u || // ...or if the current point is NOT within the selection bounds
    r.length > 1 && (s != null && s.containsPoint(i))) {
      this.didSelectOnEnter = !1, this.hitShapeForPointerUp = d;
      return;
    }
    this.didSelectOnEnter = !0, a && !c ? (this.editor.cancelDoubleClick(), r.includes(d.id) || (this.editor.markHistoryStoppingPoint("shift selecting shape"), this.editor.setSelectedShapes([...r, d.id]))) : (this.editor.markHistoryStoppingPoint("selecting shape"), this.editor.setSelectedShapes([d.id]));
  }
  onPointerUp(n) {
    var d;
    const r = this.editor.getSelectedShapeIds(), s = this.editor.getFocusedGroupId(), o = this.editor.getZoomLevel(), {
      inputs: { currentPagePoint: i }
    } = this.editor, a = n.shiftKey || n.accelKey, c = this.editor.getShapeAtPoint(i, {
      margin: this.editor.options.hitTestMargin / o,
      hitInside: !0,
      renderingOnly: !0
    }) ?? this.hitShape, l = c ? this.editor.getOutermostSelectableShape(c) : this.hitShapeForPointerUp;
    if (l) {
      const u = this.editor.getShapeUtil(l);
      if (u.onClick) {
        const f = (d = u.onClick) == null ? void 0 : d.call(u, l);
        if (f) {
          this.editor.markHistoryStoppingPoint("shape on click"), this.editor.updateShapes([f]), this.parent.transition("idle", n);
          return;
        }
      }
      if (l.id === s) {
        r.length > 0 ? (this.editor.markHistoryStoppingPoint("clearing shape ids"), this.editor.setSelectedShapes([])) : this.editor.popFocusedGroupId(), this.parent.transition("idle", n);
        return;
      }
    }
    if (!this.didSelectOnEnter) {
      const u = this.editor.getOutermostSelectableShape(
        c,
        // if a group is selected, we want to stop before reaching that group
        // so we can drill down into the group
        (f) => !r.includes(f.id)
      );
      if (r.includes(u.id))
        if (a)
          this.editor.markHistoryStoppingPoint("deselecting on pointer up"), this.editor.deselect(l);
        else if (r.includes(l.id)) {
          if (r.length === 1) {
            const f = this.editor.getShapeUtil(l).getGeometry(l), p = Hfe(f), g = p.length === 1 ? p[0] : void 0;
            if (g) {
              const y = this.editor.getPointInShapeSpace(
                l,
                i
              );
              if (g.bounds.containsPoint(y, 0) && g.hitTestPoint(y)) {
                this.editor.run(() => {
                  this.editor.markHistoryStoppingPoint("editing on pointer up"), this.editor.select(l.id);
                  const m = this.editor.getShapeUtil(l);
                  this.editor.getIsReadonly() && !m.canEditInReadonly(l) || (this.editor.setEditingShape(l.id), this.editor.setCurrentTool("select.editing_shape"), this.isDoubleClick ? this.editor.emit("select-all-text", { shapeId: l.id }) : this.editor.emit("place-caret", {
                    shapeId: l.id,
                    point: n.point
                  }));
                });
                return;
              }
            }
          }
          this.editor.markHistoryStoppingPoint("selecting on pointer up"), this.editor.select(l.id);
        } else
          this.editor.markHistoryStoppingPoint("selecting on pointer up"), this.editor.select(l);
      else if (a) {
        const f = this.editor.getShapeAncestors(u);
        this.editor.markHistoryStoppingPoint("shift deselecting on pointer up"), this.editor.setSelectedShapes([
          ...this.editor.getSelectedShapeIds().filter((p) => !f.find((g) => g.id === p)),
          u.id
        ]);
      } else
        this.editor.markHistoryStoppingPoint("selecting on pointer up"), this.editor.setSelectedShapes([u.id]);
    }
    this.parent.transition("idle", n);
  }
  onDoubleClick() {
    this.isDoubleClick = !0;
  }
  onPointerMove(n) {
    this.editor.inputs.isDragging && (this.didCtrlOnEnter ? this.parent.transition("brushing", n) : this.startTranslating(n));
  }
  onLongPress(n) {
    this.startTranslating(n);
  }
  startTranslating(n) {
    this.editor.getIsReadonly() || (this.editor.focus(), this.parent.transition("translating", n));
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
}
P(Xfe, "id", "pointing_shape");
class Zfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
    P(this, "markId", "");
    // A switch to detect when the user is holding ctrl
    P(this, "didHoldCommand", !1);
    // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
    // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
    // so we allow passing a further offset into this state to negate such issues
    P(this, "creationCursorOffset", { x: 0, y: 0 });
    P(this, "snapshot", {});
  }
  onEnter(n) {
    const { isCreating: r = !1, creatingMarkId: s, creationCursorOffset: o = { x: 0, y: 0 } } = n;
    this.info = n, this.didHoldCommand = !1, this.parent.setCurrentToolIdMask(n.onInteractionEnd), this.creationCursorOffset = o;
    try {
      this.snapshot = this._createSnapshot();
    } catch (i) {
      console.error(i), this.cancel();
      return;
    }
    if (this.markId = "", r)
      if (s)
        this.markId = s;
      else {
        const i = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        i && (this.markId = i);
      }
    else
      this.markId = this.editor.markHistoryStoppingPoint("starting resizing");
    r && this.editor.setCursor({ type: "cross", rotation: 0 }), this.handleResizeStart(), this.updateShapes();
  }
  onTick({ elapsed: n }) {
    const { editor: r } = this;
    r.edgeScrollManager.updateEdgeScrolling(n);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    this.updateShapes();
  }
  onKeyUp() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  cancel() {
    const { shapeSnapshots: n } = this.snapshot;
    n.forEach(({ shape: r }) => {
      var o;
      const s = this.editor.getShape(r.id);
      if (s) {
        const i = this.editor.getShapeUtil(r);
        (o = i.onResizeCancel) == null || o.call(i, r, s);
      }
    }), this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  complete() {
    var n, r;
    if (An(this.editor, this.snapshot.selectedShapeIds), this.handleResizeEnd(), this.info.isCreating && this.info.onCreate) {
      (r = (n = this.info).onCreate) == null || r.call(n, this.editor.getOnlySelectedShape());
      return;
    }
    if (this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
      return;
    }
    this.parent.transition("idle");
  }
  handleResizeStart() {
    const { shapeSnapshots: n } = this.snapshot, r = [];
    n.forEach(({ shape: s }) => {
      var a;
      const o = this.editor.getShapeUtil(s), i = (a = o.onResizeStart) == null ? void 0 : a.call(o, s);
      i && r.push(i);
    }), r.length > 0 && this.editor.updateShapes(r);
  }
  handleResizeEnd() {
    const { shapeSnapshots: n } = this.snapshot, r = [];
    n.forEach(({ shape: s }) => {
      var c;
      const o = this.editor.getShape(s.id), i = this.editor.getShapeUtil(s), a = (c = i.onResizeEnd) == null ? void 0 : c.call(i, s, o);
      a && r.push(a);
    }), r.length > 0 && this.editor.updateShapes(r);
  }
  updateShapes() {
    const { altKey: n, shiftKey: r } = this.editor.inputs, {
      frames: s,
      shapeSnapshots: o,
      selectionBounds: i,
      cursorHandleOffset: a,
      selectedShapeIds: c,
      selectionRotation: l,
      canShapesDeform: d
    } = this.snapshot;
    let u = r || !d;
    if (o.size === 1) {
      const E = [...o.values()][0];
      this.editor.isShapeOfType(E.shape, "text") && (u = !(this.info.handle === "left" || this.info.handle === "right"));
    }
    const f = ms(this.editor.inputs), p = this.editor.inputs.currentPagePoint.clone().sub(a).sub(this.creationCursorOffset), g = this.editor.inputs.originPagePoint.clone().sub(a);
    if (this.editor.getInstanceState().isGridMode && !f) {
      const { gridSize: E } = this.editor.getDocumentSettings();
      p.snapToGrid(E);
    }
    const y = this.info.handle, m = _7(y, Math.PI);
    if (this.editor.snaps.clearIndicators(), (this.editor.user.getIsSnapMode() ? !f : f) && l % ar === 0) {
      const { nudge: E } = this.editor.snaps.shapeBounds.snapResizeShapes({
        dragDelta: I.Sub(p, g),
        initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
        handle: _7(y, l),
        isAspectRatioLocked: u,
        isResizingFromCenter: n
      });
      p.add(E);
    }
    const b = I.RotWith(
      n ? i.center : i.getHandlePoint(m),
      i.point,
      l
    ), x = I.Sub(p, b).rot(
      -l
    ), w = I.Sub(g, b).rot(
      -l
    ), S = I.DivV(x, w);
    Number.isFinite(S.x) || (S.x = 1), Number.isFinite(S.y) || (S.y = 1);
    const C = y === "top" || y === "bottom", _ = y === "left" || y === "right";
    u ? _ ? S.y = Math.abs(S.x) : C ? S.x = Math.abs(S.y) : Math.abs(S.x) > Math.abs(S.y) ? S.y = Math.abs(S.x) * (S.y < 0 ? -1 : 1) : S.x = Math.abs(S.y) * (S.x < 0 ? -1 : 1) : (C && (S.x = 1), _ && (S.y = 1)), this.info.isCreating || this.updateCursor({
      dragHandle: y,
      isFlippedX: S.x < 0,
      isFlippedY: S.y < 0,
      rotation: l
    });
    for (const E of o.keys()) {
      const M = o.get(E);
      this.editor.resizeShape(E, S, {
        initialShape: M.shape,
        initialBounds: M.bounds,
        initialPageTransform: M.pageTransform,
        dragHandle: y,
        mode: c.length === 1 && E === c[0] ? "resize_bounds" : "scale_shape",
        scaleOrigin: b,
        isAspectRatioLocked: u,
        scaleAxisRotation: l,
        skipStartAndEndCallbacks: !0
      });
    }
    if (f) {
      this.didHoldCommand = !0;
      for (const { id: E, children: M } of s) {
        if (!M.length) continue;
        const N = o.get(E).shape, O = this.editor.getShape(E);
        if (!(N && O)) continue;
        const D = O.x - N.x, k = O.y - N.y, A = new I(D, k).rot(-N.rotation);
        if (A.x !== 0 || A.y !== 0)
          for (const R of M)
            this.editor.updateShape({
              id: R.id,
              type: R.type,
              x: R.x - A.x,
              y: R.y - A.y
            });
      }
    } else if (this.didHoldCommand) {
      this.didHoldCommand = !1;
      for (const { children: E } of s)
        if (E.length)
          for (const M of E)
            this.editor.updateShape({
              id: M.id,
              type: M.type,
              x: M.x,
              y: M.y
            });
    }
  }
  // ---
  updateCursor({
    dragHandle: n,
    isFlippedX: r,
    isFlippedY: s,
    rotation: o
  }) {
    const i = { ...this.editor.getInstanceState().cursor };
    switch (n) {
      case "top_left":
      case "bottom_right": {
        i.type = "nwse-resize", r !== s && (i.type = "nesw-resize");
        break;
      }
      case "top_right":
      case "bottom_left": {
        i.type = "nesw-resize", r !== s && (i.type = "nwse-resize");
        break;
      }
    }
    i.rotation = o, this.editor.setCursor(i);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.editor.setCursor({ type: "default", rotation: 0 }), this.editor.snaps.clearIndicators();
  }
  _createSnapshot() {
    const { editor: n } = this, r = n.getSelectedShapeIds(), s = n.getSelectionRotation(), {
      inputs: { originPagePoint: o }
    } = n, i = n.getSelectionRotatedPageBounds();
    if (!i) throw Error("Resizing but nothing is selected");
    const a = I.RotWith(
      i.getHandlePoint(this.info.handle),
      i.point,
      s
    ), c = I.Sub(o, a), l = /* @__PURE__ */ new Map(), d = [], u = (p) => {
      const g = n.getShape(p);
      if (!g) return !1;
      const y = n.getShapeUtil(g);
      if (y.canResize(g)) {
        const m = n.getShapePageTransform(g);
        l.set(g.id, {
          shape: g,
          bounds: n.getShapeGeometry(g).bounds,
          pageTransform: m,
          pageRotation: we.Decompose(m).rotation,
          isAspectRatioLocked: y.isAspectRatioLocked(g)
        });
      }
      if (n.isShapeOfType(g, "frame") && d.push({
        id: g.id,
        children: mt(
          n.getSortedChildIdsForParent(g).map((m) => n.getShape(m))
        )
      }), !y.canResizeChildren(g)) return !1;
    };
    r.forEach((p) => {
      u(p) !== !1 && n.visitDescendants(p, u);
    });
    const f = ![...l.values()].some(
      (p) => !tne(p.pageRotation, s) || p.isAspectRatioLocked
    );
    return {
      shapeSnapshots: l,
      selectionBounds: i,
      cursorHandleOffset: c,
      selectionRotation: s,
      selectedShapeIds: r,
      canShapesDeform: f,
      initialSelectionPageBounds: this.editor.getSelectionPageBounds(),
      frames: d
    };
  }
}
P(Zfe, "id", "resizing");
const t2 = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function _7(t, e) {
  e = e % Bn;
  const n = Math.round(e / (mn / 4)), r = t2.indexOf(t);
  return t2[(r + n) % t2.length];
}
const E7 = Math.PI / 180;
class Qfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "snapshot", {});
    P(this, "info", {});
    P(this, "markId", "");
  }
  onEnter(n) {
    this.info = n, this.parent.setCurrentToolIdMask(n.onInteractionEnd), this.markId = this.editor.markHistoryStoppingPoint("rotate start");
    const r = sre({
      editor: this.editor,
      ids: this.editor.getSelectedShapeIds()
    });
    if (!r) return this.parent.transition("idle", this.info);
    this.snapshot = r;
    const s = this._getRotationFromPointerPosition({
      snapToNearestDegree: !1
    });
    r_({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !1 }),
      snapshot: this.snapshot,
      stage: "start"
    }), this.editor.setCursor({
      type: Cy[this.info.handle],
      rotation: s + this.snapshot.initialShapesRotation
    });
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 }), this.parent.setCurrentToolIdMask(void 0), this.snapshot = {};
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  // ---
  update() {
    const n = this._getRotationFromPointerPosition({
      snapToNearestDegree: !1
    });
    r_({
      editor: this.editor,
      delta: n,
      snapshot: this.snapshot,
      stage: "update"
    }), this.editor.setCursor({
      type: Cy[this.info.handle],
      rotation: n + this.snapshot.initialShapesRotation
    });
  }
  cancel() {
    const { shapeSnapshots: n } = this.snapshot;
    n.forEach(({ shape: r }) => {
      var o;
      const s = this.editor.getShape(r.id);
      if (s) {
        const i = this.editor.getShapeUtil(r);
        (o = i.onRotateCancel) == null || o.call(i, r, s);
      }
    }), this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : this.parent.transition("idle", this.info);
  }
  complete() {
    r_({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !0 }),
      snapshot: this.snapshot,
      stage: "end"
    }), An(
      this.editor,
      this.snapshot.shapeSnapshots.map((n) => n.shape.id)
    ), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : this.parent.transition("idle", this.info);
  }
  _getRotationFromPointerPosition({ snapToNearestDegree: n }) {
    const {
      inputs: { shiftKey: r, currentPagePoint: s }
    } = this.editor, { initialCursorAngle: o, initialShapesRotation: i, initialPageCenter: a } = this.snapshot, c = a.angle(s) - o;
    let l = i + c;
    if (r)
      l = $E(l, 24);
    else if (n && (l = Math.round(l / E7) * E7, this.editor.getInstanceState().isCoarsePointer)) {
      const d = $E(l, 4), u = e_(l, d);
      Math.abs(u) < N4e(5) && (l = d);
    }
    return l - i;
  }
}
P(Qfe, "id", "rotating");
class Jfe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "hits", /* @__PURE__ */ new Set());
    P(this, "size", 0);
    P(this, "scribbleId", "id");
    P(this, "initialSelectedShapeIds", /* @__PURE__ */ new Set());
    P(this, "newlySelectedShapeIds", /* @__PURE__ */ new Set());
  }
  onEnter() {
    this.initialSelectedShapeIds = new Set(
      this.editor.inputs.shiftKey ? this.editor.getSelectedShapeIds() : []
    ), this.newlySelectedShapeIds = /* @__PURE__ */ new Set(), this.size = 0, this.hits.clear();
    const n = this.editor.scribbles.addScribble({
      color: "selection-stroke",
      opacity: 0.32,
      size: 12
    });
    this.scribbleId = n.id, this.updateScribbleSelection(!0), this.editor.updateInstanceState({ brush: null });
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.updateScribbleSelection(!0);
  }
  onPointerUp() {
    this.complete();
  }
  onKeyDown() {
    this.updateScribbleSelection(!1);
  }
  onKeyUp() {
    this.editor.inputs.altKey ? this.updateScribbleSelection(!1) : this.parent.transition("brushing");
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  pushPointToScribble() {
    const { x: n, y: r } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, n, r);
  }
  updateScribbleSelection(n) {
    const { editor: r } = this, s = this.editor.getCurrentPageRenderingShapesSorted(), {
      inputs: { shiftKey: o, originPagePoint: i, previousPagePoint: a, currentPagePoint: c }
    } = this.editor, { newlySelectedShapeIds: l, initialSelectedShapeIds: d } = this;
    n && this.pushPointToScribble();
    const u = s;
    let f, p, g, y;
    const m = 0;
    for (let x = 0, w = u.length; x < w; x++) {
      if (f = u[x], r.isShapeOfType(f, "group") || l.has(f.id) || r.isShapeOrAncestorLocked(f) || (p = r.getShapeGeometry(f), r.isShapeOfType(f, "frame") && p.bounds.containsPoint(r.getPointInShapeSpace(f, i))))
        continue;
      const S = r.getShapePageTransform(f);
      if (!p || !S) continue;
      const C = S.clone().invert();
      g = C.applyToPoint(a), y = C.applyToPoint(c);
      const { bounds: _ } = p;
      if (!(_.minX - m > Math.max(g.x, y.x) || _.minY - m > Math.max(g.y, y.y) || _.maxX + m < Math.min(g.x, y.x) || _.maxY + m < Math.min(g.y, y.y)) && p.hitTestLineSegment(g, y, m)) {
        const E = this.editor.getOutermostSelectableShape(f), M = this.editor.getShapeMask(E.id);
        if (M && Ine(
          a,
          c,
          M
        ) !== null && !li(c, M))
          continue;
        l.add(E.id);
      }
    }
    const v = r.getSelectedShapeIds(), b = new Set(
      o ? [...l, ...d] : [...l]
    );
    (v.length !== b.size || v.some((x) => !b.has(x))) && this.editor.setSelectedShapes(Array.from(b));
  }
  complete() {
    this.updateScribbleSelection(!0), this.parent.transition("idle");
  }
  cancel() {
    this.editor.setSelectedShapes([...this.initialSelectedShapeIds]), this.parent.transition("idle");
  }
}
P(Jfe, "id", "scribble_brushing");
var Tst = Object.create, ehe = Object.defineProperty, Pst = Object.getOwnPropertyDescriptor, Ist = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), the = (t) => {
  throw TypeError(t);
}, nhe = (t, e, n) => e in t ? ehe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, kst = (t) => [, , , Tst(null)], rhe = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], she = (t) => t !== void 0 && typeof t != "function" ? the("Function expected") : t, Ast = (t, e, n, r, s) => ({ kind: rhe[t], name: e, metadata: r, addInitializer: (o) => n._ ? the("Already initialized") : s.push(she(o || null)) }), Mst = (t, e) => nhe(e, Ist("metadata"), t[3]), Ost = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, Dst = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = rhe[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, Pst(s, n)), v = r.length - 1; v >= 0; v--)
    c = Ast(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, she(i) && (m[g] = i);
  return m && ehe(s, n, m), s;
}, Cd = (t, e, n) => nhe(t, typeof e != "symbol" ? e + "" : e, n), ohe, Uk;
const Nst = 320, jst = 60;
ohe = [Li];
class C4 {
  constructor(e) {
    this.editor = e, Ost(Uk, 5, this), Cd(this, "shapesToActuallyMove", []), Cd(this, "draggedOverShapeIds", /* @__PURE__ */ new Set()), Cd(this, "initialGroupIds", /* @__PURE__ */ new Map()), Cd(this, "initialParentIds", /* @__PURE__ */ new Map()), Cd(this, "initialIndices", /* @__PURE__ */ new Map()), Cd(this, "initialDraggingOverShape"), Cd(this, "prevDraggingOverShape"), Cd(this, "prevPagePoint", new I()), Cd(this, "intervalTimerId", -1), e.disposables.add(this.dispose);
  }
  startDraggingShapes(e, n, r) {
    const { editor: s } = this;
    if (this.intervalTimerId !== -1) return;
    const o = new Set(e), i = /* @__PURE__ */ new Set();
    for (const l of o) {
      const d = s.getShapeParent(l);
      d && s.isShapeOfType(d, "group") && (i.has(d) || i.add(d));
    }
    for (const l of i) {
      const d = mt(
        s.getSortedChildIdsForParent(l).map((u) => s.getShape(u))
      );
      o.add(l);
      for (const u of d)
        o.delete(u);
    }
    this.initialParentIds.clear();
    for (const l of o) {
      const d = s.getShapeParent(l);
      d && this.initialParentIds.set(l.id, d.id), this.initialIndices.set(l.id, l.index);
      const u = s.findShapeAncestor(
        l,
        (f) => s.isShapeOfType(f, "group")
      );
      u && this.initialGroupIds.set(l.id, u.id);
    }
    const a = s.getCurrentPageShapesSorted();
    this.shapesToActuallyMove = Array.from(o).filter((l) => !l.isLocked).sort((l, d) => a.indexOf(l) - a.indexOf(d)), this.initialDraggingOverShape = s.getDraggingOverShape(n, this.shapesToActuallyMove), this.prevDraggingOverShape = this.initialDraggingOverShape, this.updateDraggingShapes(n, r);
    let c = 0;
    this.intervalTimerId = this.editor.timers.setInterval(
      () => {
        c++, !(c % 3 && this.editor.inputs.pointerVelocity.len() > 0.5) && this.updateDraggingShapes(s.inputs.currentPagePoint, r);
      },
      e.length > 10 ? Nst : jst
    );
  }
  dropShapes(e) {
    var s, o;
    const { editor: n } = this;
    this.updateDraggingShapes(n.inputs.currentPagePoint);
    const r = n.getDraggingOverShape(n.inputs.currentPagePoint, e);
    if (r) {
      const i = n.getShapeUtil(r);
      (o = i.onDropShapesOver) == null || o.call(i, r, e, {
        initialDraggingOverShapeId: ((s = this.initialDraggingOverShape) == null ? void 0 : s.id) ?? null,
        initialParentIds: this.initialParentIds,
        initialIndices: this.initialIndices
      });
    }
    this.dispose();
  }
  clear() {
    clearInterval(this.intervalTimerId), this.intervalTimerId = -1, this.initialParentIds.clear(), this.initialIndices.clear(), this.shapesToActuallyMove = [], this.initialDraggingOverShape = void 0, this.prevDraggingOverShape = void 0, this.editor.setHintingShapes([]);
  }
  dispose() {
    this.clear();
  }
  updateDraggingShapes(e, n) {
    const { editor: r } = this, s = mt(this.shapesToActuallyMove.map((a) => r.getShape(a)));
    if (!s.length) return;
    const o = r.getDraggingOverShape(e, this.shapesToActuallyMove), i = !this.prevPagePoint.equals(r.inputs.currentPagePoint);
    this.prevPagePoint.setTo(r.inputs.currentPagePoint), r.run(() => {
      var a, c, l, d, u, f, p, g;
      if (((a = this.prevDraggingOverShape) == null ? void 0 : a.id) === (o == null ? void 0 : o.id)) {
        if (i && o && ei(o.id) && !r.inputs.previousPagePoint.equals(r.inputs.currentPagePoint)) {
          const y = r.getShapeUtil(o);
          (l = y.onDragShapesOver) == null || l.call(y, o, s, {
            initialDraggingOverShapeId: ((c = this.initialDraggingOverShape) == null ? void 0 : c.id) ?? null,
            initialParentIds: this.initialParentIds,
            initialIndices: this.initialIndices
          });
        }
        return;
      }
      if (this.prevDraggingOverShape) {
        const y = r.getShapeUtil(this.prevDraggingOverShape);
        (u = y.onDragShapesOut) == null || u.call(y, this.editor.getShape(this.prevDraggingOverShape), s, {
          nextDraggingOverShapeId: (o == null ? void 0 : o.id) ?? null,
          initialDraggingOverShapeId: ((d = this.initialDraggingOverShape) == null ? void 0 : d.id) ?? null,
          initialParentIds: this.initialParentIds,
          initialIndices: this.initialIndices
        });
      }
      if (o) {
        const y = r.getShapeUtil(o);
        (g = y.onDragShapesIn) == null || g.call(y, o, s, {
          initialDraggingOverShapeId: ((f = this.initialDraggingOverShape) == null ? void 0 : f.id) ?? null,
          prevDraggingOverShapeId: ((p = this.prevDraggingOverShape) == null ? void 0 : p.id) ?? null,
          initialParentIds: this.initialParentIds,
          initialIndices: this.initialIndices
        }), r.setHintingShapes([o.id]);
      } else this.prevDraggingOverShape && r.setHintingShapes([]);
      n == null || n();
    }), this.prevDraggingOverShape = o;
  }
}
Uk = kst();
Dst(Uk, 1, "dispose", ohe, C4);
Mst(Uk, C4);
var Rst = Object.create, ihe = Object.defineProperty, $st = Object.getOwnPropertyDescriptor, ahe = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), che = (t) => {
  throw TypeError(t);
}, lhe = (t, e, n) => e in t ? ihe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Lst = (t) => [, , , Rst((t == null ? void 0 : t[ahe("metadata")]) ?? null)], dhe = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], uhe = (t) => t !== void 0 && typeof t != "function" ? che("Function expected") : t, Fst = (t, e, n, r, s) => ({ kind: dhe[t], name: e, metadata: r, addInitializer: (o) => n._ ? che("Already initialized") : s.push(uhe(o || null)) }), Bst = (t, e) => lhe(e, ahe("metadata"), t[3]), zst = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, Ust = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = dhe[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, $st(s, n)), v = r.length - 1; v >= 0; v--)
    c = Fst(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, uhe(i) && (m[g] = i);
  return m && ihe(s, n, m), s;
}, Uu = (t, e, n) => lhe(t, typeof e != "symbol" ? e + "" : e, n), fhe, NR, Hk;
class Vk extends (NR = Xe, fhe = [Li], NR) {
  constructor() {
    super(...arguments), zst(Hk, 5, this), Uu(this, "info", {}), Uu(this, "selectionSnapshot", {}), Uu(this, "snapshot", {}), Uu(this, "markId", ""), Uu(this, "isCloning", !1), Uu(this, "isCreating", !1), Uu(this, "dragAndDropManager", new C4(this.editor));
  }
  onCreate(e) {
  }
  onEnter(e) {
    var o;
    const { isCreating: n = !1, creatingMarkId: r, onCreate: s = () => {
    } } = e;
    if (!((o = this.editor.getSelectedShapeIds()) != null && o.length)) {
      this.parent.transition("idle");
      return;
    }
    if (this.info = e, this.parent.setCurrentToolIdMask(e.onInteractionEnd), this.isCreating = n, this.markId = "", n)
      if (r)
        this.markId = r;
      else {
        const i = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        i && (this.markId = i);
      }
    else
      this.markId = this.editor.markHistoryStoppingPoint("translating");
    this.onCreate = s, this.isCloning = !1, this.info = e, this.editor.setCursor({ type: "move", rotation: 0 }), this.selectionSnapshot = T7(this.editor), !(!this.isCreating && this.editor.inputs.altKey && (this.startCloning(), this.isCloning)) && (this.snapshot = this.selectionSnapshot, this.handleStart(), this.updateShapes());
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.selectionSnapshot = {}, this.snapshot = {}, this.editor.snaps.clearIndicators(), this.editor.setCursor({ type: "default", rotation: 0 }), this.dragAndDropManager.clear();
  }
  onTick({ elapsed: e }) {
    const { editor: n } = this;
    n.edgeScrollManager.updateEdgeScrolling(e);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    this.editor.inputs.altKey && !this.isCloning && (this.startCloning(), this.isCloning) || this.updateShapes();
  }
  onKeyUp() {
    if (!this.editor.inputs.altKey && this.isCloning) {
      this.stopCloning();
      return;
    }
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  startCloning() {
    if (this.isCreating) return;
    const e = Array.from(this.editor.getSelectedShapeIds());
    this.editor.canCreateShapes(e) && (this.isCloning = !0, this.reset(), this.markId = this.editor.markHistoryStoppingPoint("translate cloning"), this.editor.duplicateShapes(Array.from(this.editor.getSelectedShapeIds())), this.snapshot = T7(this.editor), this.handleStart(), this.updateShapes());
  }
  stopCloning() {
    this.isCloning = !1, this.snapshot = this.selectionSnapshot, this.reset(), this.markId = this.editor.markHistoryStoppingPoint("translate"), this.updateShapes();
  }
  reset() {
    this.editor.bailToMark(this.markId);
  }
  complete() {
    var e;
    this.updateShapes(), this.dragAndDropManager.dropShapes(this.snapshot.movingShapes), this.handleEnd(), An(
      this.editor,
      this.snapshot.movingShapes.map((n) => n.id)
    ), this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd) : this.isCreating ? (e = this.onCreate) == null || e.call(this, this.editor.getOnlySelectedShape()) : this.parent.transition("idle");
  }
  cancel() {
    const { movingShapes: e } = this.snapshot;
    e.forEach((n) => {
      var s;
      const r = this.editor.getShape(n.id);
      if (r) {
        const o = this.editor.getShapeUtil(n);
        (s = o.onTranslateCancel) == null || s.call(o, n, r);
      }
    }), this.reset(), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd) : this.parent.transition("idle", this.info);
  }
  handleStart() {
    const { movingShapes: e } = this.snapshot, n = [];
    e.forEach((r) => {
      var i;
      const s = this.editor.getShapeUtil(r), o = (i = s.onTranslateStart) == null ? void 0 : i.call(s, r);
      o && n.push(o);
    }), n.length > 0 && this.editor.updateShapes(n), this.dragAndDropManager.startDraggingShapes(
      // Get fresh shapes from the snapshot, in case onTranslateStart mutates the shape
      mt(this.snapshot.movingShapes.map((r) => this.editor.getShape(r.id))),
      // Start from the place where the user started dragging
      this.editor.inputs.originPagePoint,
      this.updateParentTransforms
    ), this.editor.setHoveredShape(null);
  }
  handleEnd() {
    const { movingShapes: e } = this.snapshot;
    if (this.isCloning && e.length > 0) {
      const r = I.Average(
        e.map((o) => this.editor.getShapePageTransform(o.id).point())
      ), s = I.Sub(r, this.selectionSnapshot.averagePagePoint);
      I.IsNaN(s) || this.editor.updateInstanceState({
        duplicateProps: {
          shapeIds: e.map((o) => o.id),
          offset: { x: s.x, y: s.y }
        }
      });
    }
    const n = [];
    e.forEach((r) => {
      var a;
      const s = this.editor.getShape(r.id), o = this.editor.getShapeUtil(r), i = (a = o.onTranslateEnd) == null ? void 0 : a.call(o, r, s);
      i && n.push(i);
    }), n.length > 0 && this.editor.updateShapes(n);
  }
  updateShapes() {
    const { snapshot: e } = this;
    this.dragAndDropManager.startDraggingShapes(
      e.movingShapes,
      this.editor.inputs.originPagePoint,
      this.updateParentTransforms
    ), Hst({
      editor: this.editor,
      snapshot: e
    });
    const { movingShapes: n } = e, r = [];
    n.forEach((s) => {
      var c;
      const o = this.editor.getShape(s.id), i = this.editor.getShapeUtil(s), a = (c = i.onTranslate) == null ? void 0 : c.call(i, s, o);
      a && r.push(a);
    }), r.length > 0 && this.editor.updateShapes(r);
  }
  updateParentTransforms() {
    const {
      editor: e,
      snapshot: { shapeSnapshots: n }
    } = this;
    n.forEach((r) => {
      const s = e.getShape(r.shape.id);
      if (!s) return null;
      const o = Ys(s.parentId) ? null : we.Inverse(e.getShapePageTransform(s.parentId));
      r.parentTransform = o;
    });
  }
}
Hk = Lst(NR);
Ust(Hk, 1, "updateParentTransforms", fhe, Vk);
Bst(Hk, Vk);
Uu(Vk, "id", "translating");
function T7(t) {
  var u;
  const e = [], n = [], r = t.getSelectedShapeIds(), s = mt(
    r.map((f) => {
      const p = t.getShape(f);
      if (!p) return null;
      e.push(p);
      const g = t.getShapePageTransform(f), y = g.point(), m = g.rotation();
      n.push(y);
      const v = ci.isId(p.parentId) ? null : we.Inverse(t.getShapePageTransform(p.parentId));
      return {
        shape: p,
        pagePoint: y,
        pageRotation: m,
        parentTransform: v
      };
    })
  ), o = t.getOnlySelectedShape();
  let i = [];
  if (o)
    i = t.snaps.shapeBounds.getSnapPoints(o.id);
  else {
    const f = t.getSelectionPageBounds();
    f && (i = f.cornersAndCenter.map((p, g) => ({
      id: "selection:" + g,
      x: p.x,
      y: p.y
    })));
  }
  let a, c;
  const { originPagePoint: l } = t.inputs, d = s.filter(
    (f) => t.isShapeOfType(f.shape, "note") && t.isPointInShape(f.shape, l)
  );
  if (d.length !== 0) if (d.length === 1)
    c = d[0];
  else {
    const f = t.getCurrentPageShapesSorted();
    c = (u = d.map((p) => ({
      snapshot: p,
      index: f.findIndex((g) => g.id === p.shape.id)
    })).sort((p, g) => g.index - p.index)[0]) == null ? void 0 : u.snapshot;
  }
  return c && (a = tfe(
    t,
    c.pageRotation,
    c.shape.props.scale,
    c.shape.props.growY ?? 0
  )), {
    averagePagePoint: I.Average(n),
    movingShapes: e,
    shapeSnapshots: s,
    initialPageBounds: t.getSelectionPageBounds(),
    initialSnapPoints: i,
    noteAdjacentPositions: a,
    noteSnapshot: c
  };
}
function Hst({
  editor: t,
  snapshot: e
}) {
  const { inputs: n } = t, {
    noteSnapshot: r,
    noteAdjacentPositions: s,
    initialPageBounds: o,
    initialSnapPoints: i,
    shapeSnapshots: a,
    averagePagePoint: c
  } = e, l = t.getInstanceState().isGridMode, d = t.getDocumentSettings().gridSize, u = I.Sub(n.currentPagePoint, n.originPagePoint), f = t.inputs.shiftKey ? Math.abs(u.x) < Math.abs(u.y) ? "x" : "y" : null;
  f === "x" ? u.x = 0 : f === "y" && (u.y = 0), t.snaps.clearIndicators();
  const p = t.user.getIsSnapMode() ? !n.ctrlKey : n.ctrlKey;
  let g = !1;
  if (p && t.inputs.pointerVelocity.len() < 0.5) {
    const { nudge: b } = t.snaps.shapeBounds.snapTranslateShapes({
      dragDelta: u,
      initialSelectionPageBounds: o,
      lockedAxis: f,
      initialSelectionSnapPoints: i
    });
    u.add(b);
  } else if (r && s) {
    const { scale: b } = r.shape.props, x = r.pagePoint.clone().add(u).add(Bk.clone().mul(b).rot(r.pageRotation));
    let w = Jue / t.getZoomLevel(), S = new I(0, 0);
    for (const C of s) {
      const _ = I.Sub(x, C), E = _.len();
      E < w && (g = !0, w = E, S = _);
    }
    u.sub(S);
  }
  const y = I.Add(c, u), m = t.snaps.getIndicators();
  l && !n.ctrlKey && !g && m.length === 0 && y.snapToGrid(d);
  const v = I.Sub(y, c);
  t.updateShapes(
    mt(
      a.map(({ shape: b, pagePoint: x, parentTransform: w }) => {
        const S = I.Add(x, v), C = w ? we.applyToPoint(w, S) : S;
        return {
          id: b.id,
          type: b.type,
          x: C.x,
          y: C.y
        };
      })
    )
  );
}
class I_ extends Xe {
  constructor() {
    super(...arguments);
    P(this, "reactor");
  }
  static children() {
    return [
      DR,
      x4,
      Sst,
      Kfe,
      Xfe,
      Vk,
      $fe,
      Jfe,
      S4,
      qfe,
      Lfe,
      Vfe,
      Zfe,
      Qfe,
      Yfe,
      Wfe,
      Gfe,
      Ufe
    ];
  }
  // We want to clean up the duplicate props when the selection changes
  cleanUpDuplicateProps() {
    const n = this.editor.getSelectedShapeIds(), r = this.editor.getInstanceState();
    if (!r.duplicateProps) return;
    const s = new Set(r.duplicateProps.shapeIds);
    n.length === s.size && n.every((o) => s.has(o)) || this.editor.updateInstanceState({
      duplicateProps: null
    });
  }
  onEnter() {
    this.reactor = ya("clean duplicate props", () => {
      try {
        this.cleanUpDuplicateProps();
      } catch (n) {
        typeof process < "u" && process.env.NODE_ENV === "test" || console.error(n);
      }
    });
  }
  onExit() {
    var n;
    (n = this.reactor) == null || n.call(this), this.editor.getCurrentPageState().editingShapeId && this.editor.setEditingShape(null);
  }
}
P(I_, "id", "select"), P(I_, "initial", "idle"), P(I_, "isLockable", !1);
class hhe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
  }
  onEnter(n) {
    this.info = n;
  }
  onPointerDown() {
    this.parent.transition("pointing", this.info);
  }
}
P(hhe, "id", "idle");
class phe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
  }
  onEnter(n) {
    this.info = n;
  }
  onPointerUp() {
    this.complete();
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.parent.transition("zoom_brushing", this.info);
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    const { currentScreenPoint: n } = this.editor.inputs;
    this.editor.inputs.altKey ? this.editor.zoomOut(n, { animation: { duration: 220 } }) : this.editor.zoomIn(n, { animation: { duration: 220 } }), this.parent.transition("idle", this.info);
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
P(phe, "id", "pointing");
class ghe extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
    P(this, "zoomBrush", new _e());
  }
  onEnter(n) {
    this.info = n, this.update();
  }
  onExit() {
    this.editor.updateInstanceState({ zoomBrush: null });
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  update() {
    const {
      inputs: { originPagePoint: n, currentPagePoint: r }
    } = this.editor;
    this.zoomBrush.setTo(_e.FromPoints([n, r])), this.editor.updateInstanceState({ zoomBrush: this.zoomBrush.toJson() });
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
  complete() {
    const { zoomBrush: n } = this, r = 8 / this.editor.getZoomLevel();
    if (n.width < r && n.height < r) {
      const s = this.editor.inputs.currentScreenPoint;
      this.editor.inputs.altKey ? this.editor.zoomOut(s, { animation: { duration: 220 } }) : this.editor.zoomIn(s, { animation: { duration: 220 } });
    } else {
      const s = this.editor.inputs.altKey ? this.editor.getZoomLevel() / 2 : void 0;
      this.editor.zoomToBounds(n, { targetZoom: s, animation: { duration: 220 } });
    }
    this.parent.transition("idle", this.info);
  }
}
P(ghe, "id", "zoom_brushing");
class k_ extends Xe {
  constructor() {
    super(...arguments);
    P(this, "info", {});
  }
  static children() {
    return [hhe, ghe, phe];
  }
  onEnter(n) {
    this.info = n, this.parent.setCurrentToolIdMask(n.onInteractionEnd), this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.editor.updateInstanceState({ zoomBrush: null, cursor: { type: "default", rotation: 0 } }), this.parent.setCurrentToolIdMask(void 0);
  }
  onKeyDown() {
    this.updateCursor();
  }
  onKeyUp(n) {
    this.updateCursor(), n.code === "KeyZ" && this.complete();
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    this.info.onInteractionEnd && this.info.onInteractionEnd !== "select" ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : this.parent.transition("select");
  }
  updateCursor() {
    this.editor.inputs.altKey ? this.editor.setCursor({ type: "zoom-out", rotation: 0 }) : this.editor.setCursor({ type: "zoom-in", rotation: 0 });
  }
}
P(k_, "id", "zoom"), P(k_, "initial", "idle"), P(k_, "isLockable", !1);
const Vst = [E_, T_, P_, k_, I_];
function Wst() {
  const t = ie(), e = le("follow", () => t.getInstanceState().followingUserId, [
    t
  ]);
  return e ? /* @__PURE__ */ h.jsx(Kst, { userId: e }) : null;
}
function Kst({ userId: t }) {
  const e = qI(t);
  return e ? /* @__PURE__ */ h.jsx("div", { className: "tlui-following-indicator", style: { borderColor: e.color } }) : null;
}
let jR = {
  fonts: {
    tldraw_mono: `${ts()}/fonts/IBMPlexMono-Medium.woff2`,
    tldraw_mono_italic: `${ts()}/fonts/IBMPlexMono-MediumItalic.woff2`,
    tldraw_mono_bold: `${ts()}/fonts/IBMPlexMono-Bold.woff2`,
    tldraw_mono_italic_bold: `${ts()}/fonts/IBMPlexMono-BoldItalic.woff2`,
    tldraw_serif: `${ts()}/fonts/IBMPlexSerif-Medium.woff2`,
    tldraw_serif_italic: `${ts()}/fonts/IBMPlexSerif-MediumItalic.woff2`,
    tldraw_serif_bold: `${ts()}/fonts/IBMPlexSerif-Bold.woff2`,
    tldraw_serif_italic_bold: `${ts()}/fonts/IBMPlexSerif-BoldItalic.woff2`,
    tldraw_sans: `${ts()}/fonts/IBMPlexSans-Medium.woff2`,
    tldraw_sans_italic: `${ts()}/fonts/IBMPlexSans-MediumItalic.woff2`,
    tldraw_sans_bold: `${ts()}/fonts/IBMPlexSans-Bold.woff2`,
    tldraw_sans_italic_bold: `${ts()}/fonts/IBMPlexSans-BoldItalic.woff2`,
    tldraw_draw: `${ts()}/fonts/Shantell_Sans-Informal_Regular.woff2`,
    tldraw_draw_italic: `${ts()}/fonts/Shantell_Sans-Informal_Regular_Italic.woff2`,
    tldraw_draw_bold: `${ts()}/fonts/Shantell_Sans-Informal_Bold.woff2`,
    tldraw_draw_italic_bold: `${ts()}/fonts/Shantell_Sans-Informal_Bold_Italic.woff2`
  }
};
function mhe(t) {
  return Ke(() => t ? {
    fonts: { ...jR.fonts, ...t == null ? void 0 : t.fonts }
  } : jR, [t]);
}
const Gst = [
  "align-bottom",
  "align-center-horizontal",
  "align-center-vertical",
  "align-left",
  "align-right",
  "align-top",
  "alt",
  "arrow-arc",
  "arrow-cycle",
  "arrow-elbow",
  "arrow-left",
  "arrowhead-arrow",
  "arrowhead-bar",
  "arrowhead-diamond",
  "arrowhead-dot",
  "arrowhead-none",
  "arrowhead-square",
  "arrowhead-triangle-inverted",
  "arrowhead-triangle",
  "blob",
  "bold",
  "bookmark",
  "bring-forward",
  "bring-to-front",
  "broken",
  "bulletList",
  "check-circle",
  "check",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-ne",
  "chevrons-sw",
  "clipboard-copied",
  "clipboard-copy",
  "code",
  "color",
  "comment",
  "corners",
  "crop",
  "cross-2",
  "cross-circle",
  "dash-dashed",
  "dash-dotted",
  "dash-draw",
  "dash-solid",
  "disconnected",
  "discord",
  "distribute-horizontal",
  "distribute-vertical",
  "dot",
  "dots-horizontal",
  "dots-vertical",
  "download",
  "drag-handle-dots",
  "duplicate",
  "edit",
  "external-link",
  "fill-fill",
  "fill-none",
  "fill-pattern",
  "fill-semi",
  "fill-solid",
  "follow",
  "following",
  "font-draw",
  "font-mono",
  "font-sans",
  "font-serif",
  "geo-arrow-down",
  "geo-arrow-left",
  "geo-arrow-right",
  "geo-arrow-up",
  "geo-check-box",
  "geo-cloud",
  "geo-diamond",
  "geo-ellipse",
  "geo-heart",
  "geo-hexagon",
  "geo-octagon",
  "geo-oval",
  "geo-pentagon",
  "geo-rectangle",
  "geo-rhombus-2",
  "geo-rhombus",
  "geo-star",
  "geo-trapezoid",
  "geo-triangle",
  "geo-x-box",
  "github",
  "group",
  "heading",
  "help-circle",
  "highlight",
  "horizontal-align-end",
  "horizontal-align-middle",
  "horizontal-align-start",
  "info-circle",
  "italic",
  "leading",
  "link",
  "list",
  "lock",
  "manual",
  "menu",
  "minus",
  "mixed",
  "pack",
  "plus",
  "question-mark-circle",
  "question-mark",
  "redo",
  "reset-zoom",
  "rotate-ccw",
  "rotate-cw",
  "send-backward",
  "send-to-back",
  "share-1",
  "size-extra-large",
  "size-large",
  "size-medium",
  "size-small",
  "spline-cubic",
  "spline-line",
  "stack-horizontal",
  "stack-vertical",
  "status-offline",
  "stretch-horizontal",
  "stretch-vertical",
  "strike",
  "text-align-center",
  "text-align-left",
  "text-align-right",
  "toggle-off",
  "toggle-on",
  "tool-arrow",
  "tool-eraser",
  "tool-frame",
  "tool-hand",
  "tool-highlight",
  "tool-laser",
  "tool-line",
  "tool-media",
  "tool-note",
  "tool-pencil",
  "tool-pointer",
  "tool-screenshot",
  "tool-text",
  "trash",
  "twitter",
  "underline",
  "undo",
  "ungroup",
  "unlock",
  "vertical-align-end",
  "vertical-align-middle",
  "vertical-align-start",
  "warning-triangle",
  "zoom-in",
  "zoom-out"
];
let db = {
  ...jR,
  icons: Object.fromEntries(
    Gst.map((t) => [t, `${ts()}/icons/icon/0_merged.svg#${t}`])
  ),
  translations: Object.fromEntries(
    lw.map((t) => [
      t.locale,
      `${ts()}/translations/${t.locale}.json`
    ])
  ),
  embedIcons: Object.fromEntries(
    D5.map((t) => [
      t.type,
      `${ts()}/embed-icons/${t.type}.png`
    ])
  )
};
function yhe(t) {
  return Ke(() => t ? {
    fonts: Object.assign({ ...db.fonts }, { ...t == null ? void 0 : t.fonts }),
    icons: Object.assign({ ...db.icons }, { ...t == null ? void 0 : t.icons }),
    embedIcons: Object.assign({ ...db.embedIcons }, { ...t == null ? void 0 : t.embedIcons }),
    translations: Object.assign(
      { ...db.translations },
      { ...t == null ? void 0 : t.translations }
    )
  } : db, [t]);
}
function Bp({ id: t, children: e, onOpenChange: n, open: r }) {
  const [s, o] = vu(t, n);
  return /* @__PURE__ */ h.jsx(hI, { onOpenChange: o, open: r || s, children: /* @__PURE__ */ h.jsx("div", { className: "tlui-popover", children: e }) });
}
function zp({ children: t }) {
  return /* @__PURE__ */ h.jsx(pI, { asChild: !0, dir: "ltr", children: t });
}
function Up({
  side: t,
  children: e,
  align: n = "center",
  sideOffset: r = 8,
  alignOffset: s = 0,
  disableEscapeKeyDown: o = !1,
  autoFocusFirstButton: i = !0
}) {
  const a = Gr(), c = B.useRef(null), l = B.useCallback(() => {
    var p;
    if (!i) return;
    const f = [...((p = c.current) == null ? void 0 : p.querySelectorAll("button:not([disabled])")) ?? []].filter(
      (g) => g.offsetWidth || g.offsetHeight
    )[0];
    f && f.focus();
  }, [i]);
  return /* @__PURE__ */ h.jsx(gI, { container: a, children: /* @__PURE__ */ h.jsx(
    $0,
    {
      className: "tlui-popover__content",
      side: t,
      sideOffset: r,
      align: n,
      alignOffset: s,
      dir: "ltr",
      ref: c,
      onOpenAutoFocus: l,
      onEscapeKeyDown: (d) => o && d.preventDefault(),
      children: e
    }
  ) });
}
function Yst(t) {
  return t.getSelectedShapeIds().map((r) => t.getShape(r)).filter((r) => {
    if (!r) return !1;
    if (t.isShapeOfType(r, "arrow")) {
      const s = As(t, r);
      if (s.start || s.end) return !1;
    }
    return !0;
  });
}
const vhe = () => {
  const t = ie();
  return le("threeStackableItems", () => Yst(t).length > 2, [t]);
}, wu = () => {
  const t = ie();
  return le("isInSelectState", () => t.isIn("select"), [t]);
}, bhe = () => {
  const t = ie();
  return le(
    "allow group",
    () => {
      const e = t.getSelectedShapes();
      if (e.length < 2) return !1;
      for (const n of e)
        if (t.isShapeOfType(n, "arrow")) {
          const r = As(t, n);
          if (r.start && !e.some((s) => s.id === r.start.toId) || r.end && !e.some((s) => s.id === r.end.toId))
            return !1;
        }
      return !0;
    },
    [t]
  );
}, xhe = () => {
  const t = ie();
  return le(
    "allowUngroup",
    () => t.getSelectedShapeIds().some((e) => {
      var n;
      return ((n = t.getShape(e)) == null ? void 0 : n.type) === "group";
    }),
    [t]
  );
}, qst = typeof window < "u" && "navigator" in window && !!navigator.clipboard && !!navigator.clipboard.read;
function whe(t, e) {
  const n = ie();
  return le(
    "selectedShapes",
    () => n.getSelectedShapes().length >= t,
    [n, t, e]
  );
}
function yi(t, e) {
  const n = ie();
  return le(
    "selectedShapes",
    () => {
      const r = n.getSelectedShapes().filter((s) => !n.isShapeOrAncestorLocked(s)).length;
      return t === void 0 ? r : r >= t;
    },
    [n]
  );
}
function Xst() {
  const t = ie();
  return le(
    "showAutoSizeToggle",
    () => {
      const e = t.getSelectedShapes();
      return e.length === 1 && t.isShapeOfType(e[0], "text") && e[0].props.autoSize === !1;
    },
    [t]
  );
}
function She() {
  const t = ie();
  return le(
    "hasLinkShapeSelected",
    () => {
      const e = t.getOnlySelectedShape();
      return !!(e && e.type !== "embed" && "url" in e.props && !e.isLocked);
    },
    [t]
  );
}
function Zst() {
  const t = ie();
  return le(
    "onlyFlippableShape",
    () => {
      const e = t.getOnlySelectedShape();
      return e && (t.isShapeOfType(e, "group") || t.isShapeOfType(e, "image") || t.isShapeOfType(e, "arrow") || t.isShapeOfType(e, "line") || t.isShapeOfType(e, "draw"));
    },
    [t]
  );
}
function Che() {
  const t = ie();
  return le("useCanRedo", () => t.getCanRedo(), [t]);
}
function _he() {
  const t = ie();
  return le("useCanUndo", () => t.getCanUndo(), [t]);
}
function Qst() {
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(Jst, {}),
    /* @__PURE__ */ h.jsx(eot, {}),
    /* @__PURE__ */ h.jsx(tot, {}),
    /* @__PURE__ */ h.jsx(not, {}),
    /* @__PURE__ */ h.jsx(rot, {}),
    /* @__PURE__ */ h.jsx(iot, {}),
    /* @__PURE__ */ h.jsx(aot, {}),
    /* @__PURE__ */ h.jsx(cot, {})
  ] });
}
function Jst() {
  const t = yi(2), e = wu(), n = t && e;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "align-left", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "align-center-horizontal", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "align-right", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "stretch-horizontal", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "align-top", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "align-center-vertical", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "align-bottom", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "stretch-vertical", disabled: !n })
  ] });
}
function eot() {
  const t = yi(3), e = wu(), n = t && e;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "distribute-horizontal", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "distribute-vertical", disabled: !n })
  ] });
}
function tot() {
  const t = vhe(), e = wu(), n = t && e;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "stack-horizontal", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "stack-vertical", disabled: !n })
  ] });
}
function not() {
  const t = yi(1), e = wu(), n = t && e;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "send-to-back", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "send-backward", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "bring-forward", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "bring-to-front", disabled: !n })
  ] });
}
function rot() {
  return Uo() < Ir.TABLET_SM ? /* @__PURE__ */ h.jsx(sot, {}) : /* @__PURE__ */ h.jsx(oot, {});
}
function sot() {
  const t = ie(), e = le("zoom is 1", () => t.getZoomLevel() === 1, [t]);
  return /* @__PURE__ */ h.jsx(be, { actionId: "zoom-to-100", disabled: e });
}
function oot() {
  const t = yi(1), e = wu(), n = t && e;
  return /* @__PURE__ */ h.jsx(be, { actionId: "rotate-ccw", disabled: !n });
}
function iot() {
  const t = yi(1), e = wu(), n = t && e;
  return /* @__PURE__ */ h.jsx(be, { actionId: "rotate-cw", disabled: !n });
}
function aot() {
  const t = She(), e = wu(), n = t && e;
  return /* @__PURE__ */ h.jsx(be, { actionId: "edit-link", disabled: !n });
}
function cot() {
  const t = bhe(), e = xhe();
  return t ? /* @__PURE__ */ h.jsx(P7, {}) : e ? /* @__PURE__ */ h.jsx(lot, {}) : /* @__PURE__ */ h.jsx(P7, {});
}
function P7() {
  const t = yi(2), e = wu(), n = t && e;
  return /* @__PURE__ */ h.jsx(be, { actionId: "group", disabled: !n });
}
function lot() {
  return /* @__PURE__ */ h.jsx(be, { actionId: "ungroup" });
}
const dot = it(function({
  children: e
}) {
  const n = Ze(), r = Uo(), s = Da(), o = fe(null);
  yu(o);
  const i = ie(), a = le(
    "should display quick actions when in readonly",
    () => i.isInAny("hand", "zoom"),
    [i]
  ), c = e ?? /* @__PURE__ */ h.jsx(Qst, {});
  if (!(s && !a))
    return /* @__PURE__ */ h.jsxs(Bp, { id: "actions-menu", children: [
      /* @__PURE__ */ h.jsx(zp, { children: /* @__PURE__ */ h.jsx(
        Ds,
        {
          type: "icon",
          "data-testid": "actions-menu.button",
          title: n("actions-menu.title"),
          children: /* @__PURE__ */ h.jsx(gt, { icon: "dots-vertical", small: !0 })
        }
      ) }),
      /* @__PURE__ */ h.jsx(
        Up,
        {
          side: r >= Ir.TABLET ? "bottom" : "top",
          sideOffset: 6,
          children: /* @__PURE__ */ h.jsx(
            zr,
            {
              ref: o,
              label: n("actions-menu.title"),
              className: "tlui-actions-menu tlui-buttons__grid",
              "data-testid": "actions-menu.content",
              children: /* @__PURE__ */ h.jsx(pi, { type: "icons", sourceId: "actions-menu", children: c })
            }
          )
        }
      )
    ] });
});
function Ehe() {
  return Xst() ? /* @__PURE__ */ h.jsx(be, { actionId: "toggle-auto-size" }) : null;
}
function The() {
  return She() ? /* @__PURE__ */ h.jsx(be, { actionId: "edit-link" }) : null;
}
function uot() {
  return yi(1) ? /* @__PURE__ */ h.jsx(be, { actionId: "duplicate" }) : null;
}
function Phe() {
  const t = ie();
  return le(
    "should display flatten option",
    () => {
      if (t.getSelectedShapeIds().length === 0) return !1;
      const r = t.getOnlySelectedShape();
      return !(r && t.isShapeOfType(r, "image"));
    },
    [t]
  ) ? /* @__PURE__ */ h.jsx(be, { actionId: "flatten-to-image" }) : null;
}
function fot() {
  const t = ie();
  return le(
    "should display download original option",
    () => {
      const n = t.getSelectedShapes();
      return n.length === 0 ? !1 : n.some((r) => wue(r, t));
    },
    [t]
  ) ? /* @__PURE__ */ h.jsx(be, { actionId: "download-original" }) : null;
}
function Ihe() {
  return bhe() ? /* @__PURE__ */ h.jsx(be, { actionId: "group" }) : null;
}
function khe() {
  return xhe() ? /* @__PURE__ */ h.jsx(be, { actionId: "ungroup" }) : null;
}
function Ahe() {
  const t = ie();
  return le(
    "allow unframe",
    () => {
      const n = t.getSelectedShapes();
      return n.length === 0 ? !1 : n.every((r) => t.isShapeOfType(r, "frame"));
    },
    [t]
  ) ? /* @__PURE__ */ h.jsx(be, { actionId: "remove-frame" }) : null;
}
function Mhe() {
  const t = ie();
  return le(
    "allow fit frame to content",
    () => {
      const n = t.getOnlySelectedShape();
      return n ? t.isShapeOfType(n, "frame") && t.getSortedChildIdsForParent(n).length > 0 : !1;
    },
    [t]
  ) ? /* @__PURE__ */ h.jsx(be, { actionId: "fit-frame-to-content" }) : null;
}
function Ohe() {
  const t = ie();
  return le("selected shapes", () => t.getSelectedShapes().length > 0, [
    t
  ]) ? /* @__PURE__ */ h.jsx(be, { actionId: "toggle-lock" }) : null;
}
function _4() {
  const t = ie(), e = le(
    "isTransparentBg",
    () => !t.getInstanceState().exportBackground,
    [t]
  );
  return /* @__PURE__ */ h.jsx(
    gc,
    {
      actionId: "toggle-transparent",
      checked: e,
      toggle: !0
    }
  );
}
function hot() {
  const t = ie(), e = le("any shapes", () => t.getCurrentPageShapeIds().size > 0, [
    t
  ]);
  return /* @__PURE__ */ h.jsx(be, { actionId: "unlock-all", disabled: !e });
}
function Dhe() {
  const t = ie(), e = le("zoomed to 100", () => t.getZoomLevel() === 1, [t]);
  return /* @__PURE__ */ h.jsx(be, { actionId: "zoom-to-100", noClose: !0, disabled: e });
}
function Nhe() {
  const t = ie(), e = le("has shapes", () => t.getCurrentPageShapeIds().size > 0, [t]);
  return /* @__PURE__ */ h.jsx(
    be,
    {
      actionId: "zoom-to-fit",
      disabled: !e,
      "data-testid": "minimap.zoom-menu.zoom-to-fit",
      noClose: !0
    }
  );
}
function jhe() {
  const t = ie(), e = le("has shapes", () => t.getSelectedShapeIds().length > 0, [
    t
  ]);
  return /* @__PURE__ */ h.jsx(
    be,
    {
      actionId: "zoom-to-selection",
      disabled: !e,
      "data-testid": "minimap.zoom-menu.zoom-to-selection",
      noClose: !0
    }
  );
}
function Rhe() {
  return /* @__PURE__ */ h.jsxs(At, { id: "clipboard", children: [
    /* @__PURE__ */ h.jsx(got, {}),
    /* @__PURE__ */ h.jsx(mot, {}),
    /* @__PURE__ */ h.jsx(yot, {}),
    /* @__PURE__ */ h.jsx(uot, {}),
    /* @__PURE__ */ h.jsx(vot, {})
  ] });
}
function pot() {
  var n;
  const t = ie(), e = le(
    "atLeastOneShapeOnPage",
    () => t.getCurrentPageShapeIds().size > 0,
    [t]
  );
  return /* @__PURE__ */ h.jsxs(
    Yi,
    {
      id: "copy-as",
      label: "context-menu.copy-as",
      size: "small",
      disabled: !e,
      children: [
        /* @__PURE__ */ h.jsxs(At, { id: "copy-as-group", children: [
          /* @__PURE__ */ h.jsx(be, { actionId: "copy-as-svg" }),
          !!((n = window.navigator.clipboard) != null && n.write) && /* @__PURE__ */ h.jsx(be, { actionId: "copy-as-png" })
        ] }),
        /* @__PURE__ */ h.jsx(At, { id: "copy-as-bg", children: /* @__PURE__ */ h.jsx(_4, {}) })
      ]
    }
  );
}
function got() {
  const t = yi(1);
  return /* @__PURE__ */ h.jsx(be, { actionId: "cut", disabled: !t });
}
function mot() {
  const t = whe(1);
  return /* @__PURE__ */ h.jsx(be, { actionId: "copy", disabled: !t });
}
function yot() {
  const t = qst;
  return /* @__PURE__ */ h.jsx(be, { actionId: "paste", disabled: !t });
}
function $he() {
  const t = ie();
  return le(
    "atLeastOneShapeOnPage",
    () => t.getCurrentPageShapeIds().size > 0,
    [t]
  ) ? /* @__PURE__ */ h.jsxs(At, { id: "conversions", children: [
    /* @__PURE__ */ h.jsx(pot, {}),
    /* @__PURE__ */ h.jsxs(Yi, { id: "export-as", label: "context-menu.export-as", size: "small", children: [
      /* @__PURE__ */ h.jsxs(At, { id: "export-as-group", children: [
        /* @__PURE__ */ h.jsx(be, { actionId: "export-as-svg" }),
        /* @__PURE__ */ h.jsx(be, { actionId: "export-as-png" })
      ] }),
      /* @__PURE__ */ h.jsx(At, { id: "export-as-bg", children: /* @__PURE__ */ h.jsx(_4, {}) })
    ] }),
    /* @__PURE__ */ h.jsx(fot, {})
  ] }) : null;
}
function Lhe() {
  const t = ie(), e = le(
    "atLeastOneShapeOnPage",
    () => t.getCurrentPageShapeIds().size > 0,
    [t]
  );
  return /* @__PURE__ */ h.jsx(be, { actionId: "select-all", disabled: !e });
}
function vot() {
  const t = yi(1);
  return /* @__PURE__ */ h.jsx(be, { actionId: "delete", disabled: !t });
}
function bot() {
  const t = Da();
  return !whe(1) || t ? null : /* @__PURE__ */ h.jsxs(Yi, { id: "edit", label: "context-menu.edit", size: "small", children: [
    /* @__PURE__ */ h.jsx(Ihe, {}),
    /* @__PURE__ */ h.jsx(khe, {}),
    /* @__PURE__ */ h.jsx(Phe, {}),
    /* @__PURE__ */ h.jsx(The, {}),
    /* @__PURE__ */ h.jsx(Mhe, {}),
    /* @__PURE__ */ h.jsx(Ahe, {}),
    /* @__PURE__ */ h.jsx(Bhe, {}),
    /* @__PURE__ */ h.jsx(Fhe, {}),
    /* @__PURE__ */ h.jsx(Ehe, {}),
    /* @__PURE__ */ h.jsx(Ohe, {})
  ] });
}
function xot() {
  const t = yi(2), e = Zst();
  return Da() || !(t || e) ? null : /* @__PURE__ */ h.jsxs(Yi, { id: "arrange", label: "context-menu.arrange", size: "small", children: [
    t && /* @__PURE__ */ h.jsxs(At, { id: "align", children: [
      /* @__PURE__ */ h.jsx(be, { actionId: "align-left" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-center-horizontal" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-right" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-top" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-center-vertical" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "align-bottom" })
    ] }),
    /* @__PURE__ */ h.jsx(wot, {}),
    t && /* @__PURE__ */ h.jsxs(At, { id: "stretch", children: [
      /* @__PURE__ */ h.jsx(be, { actionId: "stretch-horizontal" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "stretch-vertical" })
    ] }),
    (t || e) && /* @__PURE__ */ h.jsxs(At, { id: "flip", children: [
      /* @__PURE__ */ h.jsx(be, { actionId: "flip-horizontal" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "flip-vertical" })
    ] }),
    /* @__PURE__ */ h.jsx(Sot, {})
  ] });
}
function wot() {
  return yi(3) ? /* @__PURE__ */ h.jsxs(At, { id: "distribute", children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "distribute-horizontal" }),
    /* @__PURE__ */ h.jsx(be, { actionId: "distribute-vertical" })
  ] }) : null;
}
function Sot() {
  const t = yi(2), e = vhe();
  return t ? /* @__PURE__ */ h.jsxs(At, { id: "order", children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "pack" }),
    e && /* @__PURE__ */ h.jsx(be, { actionId: "stack-horizontal" }),
    e && /* @__PURE__ */ h.jsx(be, { actionId: "stack-vertical" })
  ] }) : null;
}
function Cot() {
  const t = Da(), e = yi(1);
  return t || !e ? null : /* @__PURE__ */ h.jsx(Yi, { id: "reorder", label: "context-menu.reorder", size: "small", children: /* @__PURE__ */ h.jsxs(At, { id: "reorder", children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "bring-to-front" }),
    /* @__PURE__ */ h.jsx(be, { actionId: "bring-forward" }),
    /* @__PURE__ */ h.jsx(be, { actionId: "send-backward" }),
    /* @__PURE__ */ h.jsx(be, { actionId: "send-to-back" })
  ] }) });
}
function _ot() {
  const t = ie(), e = le("pages", () => t.getPages(), [t]), n = le("current page id", () => t.getCurrentPageId(), [t]), { addToast: r } = bu(), s = xr(), o = Da();
  return !yi(1) || o ? null : /* @__PURE__ */ h.jsxs(Yi, { id: "move-to-page", label: "context-menu.move-to-page", size: "small", children: [
    /* @__PURE__ */ h.jsx(At, { id: "pages", children: e.map((a) => /* @__PURE__ */ h.jsx(
      Zt,
      {
        id: a.id,
        disabled: n === a.id,
        label: a.name.length > 30 ? `${a.name.slice(0, 30)}` : a.name,
        onSelect: () => {
          t.markHistoryStoppingPoint("move_shapes_to_page"), t.moveShapesToPage(t.getSelectedShapeIds(), a.id);
          const c = t.getPage(a.id);
          c && r({
            title: "Changed Page",
            description: `Moved to ${c.name}.`,
            actions: [
              {
                label: "Go Back",
                type: "primary",
                onClick: () => {
                  t.markHistoryStoppingPoint("change-page"), t.setCurrentPage(n);
                }
              }
            ]
          }), s("move-to-page", { source: "context-menu" });
        }
      },
      a.id
    )) }),
    /* @__PURE__ */ h.jsx(At, { id: "new-page", children: /* @__PURE__ */ h.jsx(be, { actionId: "move-to-new-page" }) })
  ] });
}
function Fhe() {
  const t = ie();
  return le(
    "oneEmbedSelected",
    () => {
      const n = t.getOnlySelectedShape();
      return n ? !!(t.isShapeOfType(n, "embed") && n.props.url && !t.isShapeOrAncestorLocked(n)) : !1;
    },
    [t]
  ) ? /* @__PURE__ */ h.jsx(be, { actionId: "convert-to-bookmark" }) : null;
}
function Bhe() {
  const t = ie(), e = N5();
  return le(
    "oneEmbeddableBookmarkSelected",
    () => {
      const r = t.getOnlySelectedShape();
      return r ? !!(t.isShapeOfType(r, "bookmark") && r.props.url && e(r.props.url) && !t.isShapeOrAncestorLocked(r)) : !1;
    },
    [t]
  ) ? /* @__PURE__ */ h.jsx(be, { actionId: "convert-to-embed" }) : null;
}
function Eot() {
  const t = ie(), e = le("isSnapMode", () => t.user.getIsSnapMode(), [t]);
  return /* @__PURE__ */ h.jsx(gc, { actionId: "toggle-snap-mode", checked: e });
}
function Tot() {
  const t = ie(), e = le("isToolLock", () => t.getInstanceState().isToolLocked, [t]);
  return /* @__PURE__ */ h.jsx(gc, { actionId: "toggle-tool-lock", checked: e });
}
function Pot() {
  const t = ie(), e = le("isGridMode", () => t.getInstanceState().isGridMode, [t]);
  return /* @__PURE__ */ h.jsx(gc, { actionId: "toggle-grid", checked: e });
}
function Iot() {
  const t = ie(), e = le("isWrapMode", () => t.user.getIsWrapMode(), [t]);
  return /* @__PURE__ */ h.jsx(gc, { actionId: "toggle-wrap-mode", checked: e });
}
function kot() {
  const t = ie(), e = le("isFocusMode", () => t.getInstanceState().isFocusMode, [t]);
  return /* @__PURE__ */ h.jsx(gc, { actionId: "toggle-focus-mode", checked: e });
}
function Aot() {
  const t = ie(), e = le("edgeScrollSpeed", () => t.user.getEdgeScrollSpeed(), [
    t
  ]);
  return /* @__PURE__ */ h.jsx(
    gc,
    {
      actionId: "toggle-edge-scrolling",
      checked: e === 1
    }
  );
}
function Mot() {
  const t = ie(), e = le("animationSpeed", () => t.user.getAnimationSpeed(), [t]);
  return /* @__PURE__ */ h.jsx(
    gc,
    {
      actionId: "toggle-reduce-motion",
      checked: e === 0
    }
  );
}
function Oot() {
  const t = ie(), e = le(
    "keyboardShortcuts",
    () => t.user.getAreKeyboardShortcutsEnabled(),
    [t]
  );
  return /* @__PURE__ */ h.jsx(
    gc,
    {
      actionId: "toggle-keyboard-shortcuts",
      checked: e
    }
  );
}
function Dot() {
  const t = ie(), e = le("isDebugMode", () => t.getInstanceState().isDebugMode, [t]);
  return /* @__PURE__ */ h.jsx(gc, { actionId: "toggle-debug-mode", checked: e });
}
function Not() {
  const t = ie(), e = le(
    "dynamic resize",
    () => t.user.getIsDynamicResizeMode(),
    [t]
  );
  return /* @__PURE__ */ h.jsx(
    gc,
    {
      actionId: "toggle-dynamic-size-mode",
      checked: e
    }
  );
}
function jot() {
  const t = ie(), e = le("paste at cursor", () => t.user.getIsPasteAtCursorMode(), [
    t
  ]);
  return /* @__PURE__ */ h.jsx(gc, { actionId: "toggle-paste-at-cursor", checked: e });
}
function Rot() {
  const t = ie();
  return le(
    "show cursor chat",
    () => t.getCurrentToolId() === "select" && !t.getInstanceState().isCoarsePointer,
    [t]
  ) ? /* @__PURE__ */ h.jsx(be, { actionId: "open-cursor-chat" }) : null;
}
function zhe() {
  const t = ie(), e = Ok(), n = le(
    "isSelectToolActive",
    () => t.getCurrentToolId() === "select",
    [t]
  ), r = le("isSinglePageMode", () => t.options.maxPages <= 1, [
    t
  ]);
  return n ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    e && /* @__PURE__ */ h.jsx(Rot, {}),
    /* @__PURE__ */ h.jsxs(At, { id: "modify", children: [
      /* @__PURE__ */ h.jsx(bot, {}),
      /* @__PURE__ */ h.jsx(xot, {}),
      /* @__PURE__ */ h.jsx(Cot, {}),
      !r && /* @__PURE__ */ h.jsx(_ot, {})
    ] }),
    /* @__PURE__ */ h.jsx(Rhe, {}),
    /* @__PURE__ */ h.jsx($he, {}),
    /* @__PURE__ */ h.jsx(At, { id: "select-all", children: /* @__PURE__ */ h.jsx(Lhe, {}) })
  ] }) : null;
}
const Uhe = it(function({
  children: e,
  disabled: n = !1
}) {
  const r = ie(), s = Ze(), { Canvas: o } = Ln(), i = re(
    (f) => {
      f.key === "Escape" && (f.stopPropagation(), r.getContainer().focus());
    },
    [r]
  );
  me(() => () => {
    document.body.removeEventListener("keydown", i, {
      capture: !0
    });
  }, [i]);
  const a = re(
    (f) => {
      if (f) {
        if (document.body.addEventListener("keydown", i, {
          capture: !0
        }), r.getInstanceState().isCoarsePointer) {
          const p = r.getSelectedShapes(), {
            inputs: { currentPagePoint: g }
          } = r, y = r.getShapesAtPoint(g);
          if (
            // if there are no selected shapes
            !r.getSelectedShapes().length || // OR if none of the shapes at the point include the selected shape
            !y.some((m) => p.includes(m))
          ) {
            const m = y.filter((v) => r.isShapeOrAncestorLocked(v));
            m.length && r.select(...m.map((v) => v.id));
          }
        }
      } else {
        const p = r.getOnlySelectedShape();
        p && r.isShapeOrAncestorLocked(p) && r.setSelectedShapes([]), r.timers.requestAnimationFrame(() => {
          document.body.removeEventListener("keydown", i, {
            capture: !0
          });
        });
      }
    },
    [r, i]
  ), c = Gr(), [l, d] = vu("context menu", a), u = e ?? /* @__PURE__ */ h.jsx(zhe, {});
  return /* @__PURE__ */ h.jsxs($Ye, { dir: "ltr", onOpenChange: d, modal: !1, children: [
    /* @__PURE__ */ h.jsx(LYe, { onContextMenu: void 0, dir: "ltr", disabled: n, children: o ? /* @__PURE__ */ h.jsx(o, {}) : null }),
    l && /* @__PURE__ */ h.jsx(FYe, { container: c, children: /* @__PURE__ */ h.jsx(
      BYe,
      {
        className: "tlui-menu tlui-scrollable",
        "data-testid": "context-menu",
        "aria-label": s("context-menu.title"),
        alignOffset: -4,
        collisionPadding: 4,
        onContextMenu: xt,
        children: /* @__PURE__ */ h.jsx(pi, { type: "context-menu", sourceId: "context-menu", children: u })
      }
    ) })
  ] });
}), $ot = 2e3, Lot = 5e3, Fot = Kr(function() {
  const e = ie(), { isChatting: n, chatMessage: r } = e.getInstanceState(), s = fe(-1), [o, i] = he("");
  return me(() => {
    if (!n && r || n) {
      const c = n ? Lot : $ot;
      s.current = e.timers.setTimeout(() => {
        e.updateInstanceState({ chatMessage: "", isChatting: !1 }), i(""), e.focus();
      }, c);
    }
    return () => {
      clearTimeout(s.current);
    };
  }, [e, r, n]), n ? /* @__PURE__ */ h.jsx(zot, { value: o, setValue: i, chatMessage: r }) : r.trim() ? /* @__PURE__ */ h.jsx(Bot, { chatMessage: r }) : null;
});
function Hhe(t) {
  const e = ie();
  un(() => {
    var i;
    if (!t.current) return;
    const { x: r, y: s } = e.inputs.currentScreenPoint;
    (i = t.current) == null || i.style.setProperty("transform", `translate(${r}px, ${s}px)`);
    function o(a) {
      var d;
      const { minX: c, minY: l } = e.getViewportScreenBounds();
      (d = t.current) == null || d.style.setProperty(
        "transform",
        `translate(${a.clientX - c}px, ${a.clientY - l}px)`
      );
    }
    return window.addEventListener("pointermove", o), () => {
      window.removeEventListener("pointermove", o);
    };
  }, [t, e]);
}
const Bot = ({ chatMessage: t }) => {
  const e = ie(), n = fe(null);
  return Hhe(n), /* @__PURE__ */ h.jsx(
    "div",
    {
      ref: n,
      className: "tl-cursor-chat tl-cursor-chat__bubble",
      style: { backgroundColor: e.user.getColor() },
      children: t
    }
  );
}, zot = Kr(function({
  chatMessage: e,
  value: n,
  setValue: r
}) {
  const s = ie(), o = Ze(), i = fe(null), a = e || o("cursor-chat.type-to-chat");
  Hhe(i), un(() => {
    const f = i.current;
    if (!f) return;
    const p = s.textMeasure.measureText(n || a, {
      fontFamily: "var(--font-body)",
      fontSize: 12,
      fontWeight: "500",
      fontStyle: "normal",
      maxWidth: null,
      lineHeight: 1,
      padding: "6px"
    });
    f.style.setProperty("width", p.w + "px");
  }, [s, n, a]), un(() => {
    const f = s.timers.requestAnimationFrame(() => {
      var p;
      (p = i.current) == null || p.focus();
    });
    return () => {
      cancelAnimationFrame(f);
    };
  }, [s]);
  const c = re(() => {
    s.updateInstanceState({ isChatting: !1 }), s.focus();
  }, [s]), l = re(
    (f) => {
      const { value: p } = f.target;
      r(p.slice(0, 64)), s.updateInstanceState({ chatMessage: p });
    },
    [s, r]
  ), d = re(
    (f) => {
      const p = i.current;
      if (!p) return;
      const { value: g } = p;
      switch (f.key) {
        case "Enter": {
          if (xt(f), f.stopPropagation(), !g) {
            c();
            return;
          }
          r("");
          break;
        }
        case "Escape": {
          xt(f), f.stopPropagation(), c();
          break;
        }
      }
    },
    [c, r]
  ), u = re((f) => {
    f.stopPropagation();
  }, []);
  return /* @__PURE__ */ h.jsx(
    "input",
    {
      ref: i,
      className: "tl-cursor-chat",
      style: { backgroundColor: s.user.getColor() },
      onBlur: c,
      onChange: l,
      onKeyDown: d,
      onPaste: u,
      value: n,
      placeholder: a,
      spellCheck: !1
    }
  );
});
function RR({ checked: t }) {
  const e = Ze();
  return /* @__PURE__ */ h.jsx(
    ed,
    {
      "data-checked": !!t,
      label: e(t ? "ui.checked" : "ui.unchecked"),
      icon: t ? "check" : "none",
      className: "tlui-button__icon",
      small: !0
    }
  );
}
function Uot() {
  const t = ie(), { addToast: e } = bu(), { addDialog: n } = gS(), [r, s] = B.useState(!1);
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs(At, { id: "items", children: [
      /* @__PURE__ */ h.jsx(Zt, { id: "hard-reset", onSelect: lne, label: "Hard reset" }),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "add-toast",
          onSelect: () => {
            e({
              id: bn(),
              title: "Something good happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              severity: "success"
            }), e({
              id: bn(),
              title: "Something happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              severity: "info",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            }), e({
              id: bn(),
              title: "Something maybe bad happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              severity: "warning",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            }), e({
              id: bn(),
              title: "Something bad happened",
              severity: "error",
              keepOpen: !0
            });
          },
          label: "Show toast"
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "show-dialog",
          label: "Show dialog",
          onSelect: () => {
            n({
              component: ({ onClose: o }) => /* @__PURE__ */ h.jsx(
                Wot,
                {
                  displayDontShowAgain: !0,
                  onCancel: () => o(),
                  onContinue: () => o()
                }
              ),
              onClose: () => {
              }
            });
          }
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "create-shapes",
          label: "Create 100 shapes",
          onSelect: () => Kot(t, 100)
        }
      ),
      /* @__PURE__ */ h.jsx(
        Zt,
        {
          id: "count-nodes",
          label: "Count shapes / nodes",
          onSelect: () => {
            var a;
            const o = t.getSelectedShapes(), i = o.length === 0 ? t.getRenderingShapes() : o;
            window.alert(
              `Shapes ${i.length}, DOM nodes:${(a = document.querySelector(".tl-shapes").querySelectorAll("*")) == null ? void 0 : a.length}`
            );
          }
        }
      ),
      (() => {
        if (r) throw Error("oh no!");
        return null;
      })(),
      /* @__PURE__ */ h.jsx(Zt, { id: "throw-error", onSelect: () => s(!0), label: "Throw error" })
    ] }),
    /* @__PURE__ */ h.jsxs(At, { id: "flags", children: [
      /* @__PURE__ */ h.jsx(Hot, {}),
      /* @__PURE__ */ h.jsx(Vot, {})
    ] })
  ] });
}
function Hot() {
  const t = Object.values(ir);
  return t.length ? /* @__PURE__ */ h.jsx(Yi, { id: "debug flags", label: "Debug Flags", children: /* @__PURE__ */ h.jsx(At, { id: "debug flags", children: t.map((e) => /* @__PURE__ */ h.jsx(Vhe, { flag: e }, e.name)) }) }) : null;
}
function Vot() {
  const t = Object.values(B4e);
  return t.length ? /* @__PURE__ */ h.jsx(Yi, { id: "feature flags", label: "Feature Flags", children: /* @__PURE__ */ h.jsx(At, { id: "feature flags", children: t.map((e) => /* @__PURE__ */ h.jsx(Vhe, { flag: e }, e.name)) }) }) : null;
}
function Wot({
  title: t = "title",
  body: e = "hello hello hello",
  cancel: n = "Cancel",
  confirm: r = "Continue",
  displayDontShowAgain: s = !1,
  maxWidth: o = "350",
  onCancel: i,
  onContinue: a
}) {
  const [c, l] = B.useState(!1);
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs(Ik, { children: [
      /* @__PURE__ */ h.jsx(kk, { children: t }),
      /* @__PURE__ */ h.jsx(Ak, {})
    ] }),
    /* @__PURE__ */ h.jsx(Ew, { style: { maxWidth: o }, children: e }),
    /* @__PURE__ */ h.jsxs(O5, { className: "tlui-dialog__footer__actions", children: [
      s && /* @__PURE__ */ h.jsxs(
        yt,
        {
          type: "normal",
          onClick: () => l(!c),
          style: { marginRight: "auto" },
          children: [
            /* @__PURE__ */ h.jsx(RR, { checked: c }),
            /* @__PURE__ */ h.jsx(Pr, { children: "Dont show again" })
          ]
        }
      ),
      /* @__PURE__ */ h.jsx(yt, { type: "normal", onClick: i, children: /* @__PURE__ */ h.jsx(Pr, { children: n }) }),
      /* @__PURE__ */ h.jsx(yt, { type: "primary", onClick: async () => a(), children: /* @__PURE__ */ h.jsx(Pr, { children: r }) })
    ] })
  ] });
}
const Vhe = Kr(function({
  flag: e,
  onChange: n
}) {
  const r = e.get();
  return /* @__PURE__ */ h.jsx(
    Rk,
    {
      id: e.name,
      title: e.name,
      label: e.name.replace(/([a-z0-9])([A-Z])/g, (s) => `${s[0]} ${s[1].toLowerCase()}`).replace(/^[a-z]/, (s) => s.toUpperCase()),
      checked: r,
      onSelect: () => {
        e.set(!r), n == null || n(!r);
      }
    }
  );
});
let I7 = 0;
function Kot(t, e) {
  const n = t.options.adjacentShapeMargin, r = Array(e), s = Math.floor(Math.sqrt(e));
  for (let o = 0; o < e; o++)
    I7++, r[o] = {
      id: $n("box" + I7),
      type: "geo",
      x: o % s * (100 + n),
      y: Math.floor(o / s) * (100 + n)
    };
  t.run(() => {
    t.createShapes(r).setSelectedShapes(r.map((o) => o.id));
  });
}
function Got({ children: t }) {
  const e = t ?? /* @__PURE__ */ h.jsx(Uot, {});
  return /* @__PURE__ */ h.jsxs(Dk, { id: "debug", children: [
    /* @__PURE__ */ h.jsx(Nk, { children: /* @__PURE__ */ h.jsx(yt, { type: "icon", title: "Debug menu", children: /* @__PURE__ */ h.jsx(gt, { icon: "dots-horizontal" }) }) }),
    /* @__PURE__ */ h.jsx(jk, { side: "top", align: "end", alignOffset: 0, children: /* @__PURE__ */ h.jsx(pi, { type: "menu", sourceId: "debug-panel", children: e }) })
  ] });
}
const Yot = it(function() {
  const { DebugMenu: e } = uh(), n = fe(null);
  return yu(n), /* @__PURE__ */ h.jsxs("footer", { ref: n, className: "tlui-debug-panel", children: [
    /* @__PURE__ */ h.jsx(Xot, {}),
    /* @__PURE__ */ h.jsx(Zot, {}),
    e && /* @__PURE__ */ h.jsx(e, {})
  ] });
});
function qot(t = !0) {
  const [e, n] = he(0), r = ie();
  me(() => {
    if (!t) return;
    const s = () => n((o) => o + 1);
    return r.on("tick", s), () => {
      r.off("tick", s);
    };
  }, [r, t]);
}
const Xot = Kr(function() {
  qot();
  const e = ie(), n = e.getPath(), r = e.getHoveredShape(), s = e.getOnlySelectedShape(), o = n === "select.idle" || !n.includes("select.") ? r : s, i = o && n.includes("select.") ? ` / ${o.type || ""}${"geo" in o.props ? " / " + o.props.geo : ""} / [${I.ToInt(e.getPointInShapeSpace(o, e.inputs.currentPagePoint))}]` : "", a = n.startsWith("select.") && !n.includes(".idle") ? ` / [${I.ToInt(e.inputs.originPagePoint)}]  [${I.ToInt(
    e.inputs.currentPagePoint
  )}] = ${I.Dist(e.inputs.originPagePoint, e.inputs.currentPagePoint).toFixed(0)}` : "";
  return /* @__PURE__ */ h.jsx("div", { className: "tlui-debug-panel__current-state", children: `${n}${i}${a}` });
});
function Zot() {
  const t = ie(), e = le("show_fps", () => ir.showFps.get(), [ir]), n = fe(null);
  return me(() => {
    if (!e) return;
    const r = 250;
    let s = 0, o = -1, i = performance.now(), a = 0, c = 0, l = !1;
    function d() {
      if (c++, a = performance.now() - i, a > r) {
        const u = Math.round(
          c * (r / a) * (1e3 / r)
        );
        u > s && (s = u);
        const f = s * 0.75;
        (u < f && !l || u >= f && l) && (l = !l), n.current.innerHTML = `FPS ${u.toString()}`, n.current.className = "tlui-debug-panel__fps" + (l ? " tlui-debug-panel__fps__slow" : ""), a -= r, c = 0, i = performance.now();
      }
      o = t.timers.requestAnimationFrame(d);
    }
    return d(), () => {
      cancelAnimationFrame(o);
    };
  }, [e, t]), e ? /* @__PURE__ */ h.jsx("div", { ref: n }) : null;
}
const Qot = it(function() {
  const e = Uo(), n = Ze(), r = fe(null);
  yu(r);
  const { MainMenu: s, QuickActions: o, ActionsMenu: i, PageMenu: a } = uh(), c = ie(), l = le("isSinglePageMode", () => c.options.maxPages <= 1, [
    c
  ]), d = c.options.actionShortcutsLocation === "menu" ? !0 : c.options.actionShortcutsLocation === "toolbar" ? !1 : e >= Ir.TABLET;
  return !s && !a && !d ? null : /* @__PURE__ */ h.jsx("nav", { ref: r, className: "tlui-menu-zone", children: /* @__PURE__ */ h.jsxs("div", { className: "tlui-buttons__horizontal", children: [
    s && /* @__PURE__ */ h.jsx(s, {}),
    a && !l && /* @__PURE__ */ h.jsx(a, {}),
    d ? /* @__PURE__ */ h.jsxs(zr, { className: "tlui-buttons__horizontal", label: n("actions-menu.title"), children: [
      o && /* @__PURE__ */ h.jsx(o, {}),
      i && /* @__PURE__ */ h.jsx(i, {})
    ] }) : null
  ] }) });
});
function Jot() {
  const t = ie(), e = xu(), [n, r] = he(!1), s = fe(!1);
  return Ep(
    "toggle showback to content",
    () => {
      const o = s.current, i = t.getCurrentPageShapeIds();
      let a = !1;
      i.size && (a = i.size === t.getCulledShapes().size), o !== a && (r(a), s.current = a);
    },
    [t]
  ), n ? /* @__PURE__ */ h.jsx(
    be,
    {
      actionId: "back-to-content",
      onSelect: () => {
        e["back-to-content"].onSelect("helper-buttons"), r(!1);
      }
    }
  ) : null;
}
function eit() {
  const t = ie();
  return le("is pen mode", () => t.getInstanceState().isPenMode, [t]) ? /* @__PURE__ */ h.jsx(be, { actionId: "exit-pen-mode" }) : null;
}
function tit() {
  const t = ie(), e = xu();
  return le(
    "is following user",
    () => !!t.getInstanceState().followingUserId,
    [t]
  ) ? /* @__PURE__ */ h.jsx(Zt, { ...e["stop-following"] }) : null;
}
function nit() {
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(eit, {}),
    /* @__PURE__ */ h.jsx(Jot, {}),
    /* @__PURE__ */ h.jsx(tit, {})
  ] });
}
function rit({ children: t }) {
  const e = t ?? /* @__PURE__ */ h.jsx(nit, {});
  return /* @__PURE__ */ h.jsx("div", { className: "tlui-helper-buttons", children: /* @__PURE__ */ h.jsx(pi, { type: "helper-buttons", sourceId: "helper-buttons", children: e }) });
}
function Whe() {
  const t = uo(), e = xr(), n = le("locale", () => t == null ? void 0 : t.user.getLocale(), [t]);
  return t ? /* @__PURE__ */ h.jsx(Yi, { id: "help menu language", label: "menu.language", children: /* @__PURE__ */ h.jsx(At, { id: "languages", className: "tlui-language-menu", children: lw.map(({ locale: r, label: s }) => /* @__PURE__ */ h.jsx(
    Rk,
    {
      id: `language-${r}`,
      title: r,
      label: s,
      checked: r === n,
      readonlyOk: !0,
      onSelect: () => {
        t.user.updateUserPreferences({ locale: r }), e("change-language", { source: "menu", locale: r });
      }
    },
    r
  )) }) }) : null;
}
function sit() {
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(Whe, {}),
    /* @__PURE__ */ h.jsx(Khe, {})
  ] });
}
function Khe() {
  const { KeyboardShortcutsDialog: t } = uh(), { addDialog: e } = gS(), n = re(() => {
    t && e({ component: t });
  }, [e, t]);
  return t ? /* @__PURE__ */ h.jsx(
    Zt,
    {
      id: "keyboard-shortcuts-button",
      label: "help-menu.keyboard-shortcuts",
      readonlyOk: !0,
      onSelect: n
    }
  ) : null;
}
function oit() {
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs(At, { id: "basic", children: [
      /* @__PURE__ */ h.jsx(ait, {}),
      /* @__PURE__ */ h.jsx(uit, {}),
      /* @__PURE__ */ h.jsx(iit, {}),
      /* @__PURE__ */ h.jsx(fit, {})
    ] }),
    /* @__PURE__ */ h.jsx(hit, {})
  ] });
}
function iit() {
  return /* @__PURE__ */ h.jsxs(Yi, { id: "export-all-as", label: "context-menu.export-all-as", size: "small", children: [
    /* @__PURE__ */ h.jsxs(At, { id: "export-all-as-group", children: [
      /* @__PURE__ */ h.jsx(be, { actionId: "export-all-as-svg" }),
      /* @__PURE__ */ h.jsx(be, { actionId: "export-all-as-png" })
    ] }),
    /* @__PURE__ */ h.jsx(At, { id: "export-all-as-bg", children: /* @__PURE__ */ h.jsx(_4, {}) })
  ] });
}
function ait() {
  return /* @__PURE__ */ h.jsxs(Yi, { id: "edit", label: "menu.edit", children: [
    /* @__PURE__ */ h.jsx(dit, {}),
    /* @__PURE__ */ h.jsx(Rhe, {}),
    /* @__PURE__ */ h.jsx($he, {}),
    /* @__PURE__ */ h.jsx(cit, {}),
    /* @__PURE__ */ h.jsx(lit, {}),
    /* @__PURE__ */ h.jsx(At, { id: "select-all", children: /* @__PURE__ */ h.jsx(Lhe, {}) })
  ] });
}
function cit() {
  return /* @__PURE__ */ h.jsxs(At, { id: "misc", children: [
    /* @__PURE__ */ h.jsx(Ihe, {}),
    /* @__PURE__ */ h.jsx(khe, {}),
    /* @__PURE__ */ h.jsx(The, {}),
    /* @__PURE__ */ h.jsx(Ehe, {}),
    /* @__PURE__ */ h.jsx(Ahe, {}),
    /* @__PURE__ */ h.jsx(Mhe, {}),
    /* @__PURE__ */ h.jsx(Bhe, {}),
    /* @__PURE__ */ h.jsx(Fhe, {}),
    /* @__PURE__ */ h.jsx(Phe, {})
  ] });
}
function lit() {
  return /* @__PURE__ */ h.jsxs(At, { id: "lock", children: [
    /* @__PURE__ */ h.jsx(Ohe, {}),
    /* @__PURE__ */ h.jsx(hot, {})
  ] });
}
function dit() {
  const t = _he(), e = Che();
  return /* @__PURE__ */ h.jsxs(At, { id: "undo-redo", children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "undo", disabled: !t }),
    /* @__PURE__ */ h.jsx(be, { actionId: "redo", disabled: !e })
  ] });
}
function uit() {
  return /* @__PURE__ */ h.jsx(Yi, { id: "view", label: "menu.view", children: /* @__PURE__ */ h.jsxs(At, { id: "view-actions", children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "zoom-in" }),
    /* @__PURE__ */ h.jsx(be, { actionId: "zoom-out" }),
    /* @__PURE__ */ h.jsx(Dhe, {}),
    /* @__PURE__ */ h.jsx(Nhe, {}),
    /* @__PURE__ */ h.jsx(jhe, {})
  ] }) });
}
function fit() {
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "insert-embed" }),
    /* @__PURE__ */ h.jsx(be, { actionId: "insert-media" })
  ] });
}
function hit() {
  return /* @__PURE__ */ h.jsxs(At, { id: "preferences", children: [
    /* @__PURE__ */ h.jsxs(Yi, { id: "preferences", label: "menu.preferences", children: [
      /* @__PURE__ */ h.jsxs(At, { id: "preferences-actions", children: [
        /* @__PURE__ */ h.jsx(Eot, {}),
        /* @__PURE__ */ h.jsx(Tot, {}),
        /* @__PURE__ */ h.jsx(Pot, {}),
        /* @__PURE__ */ h.jsx(Iot, {}),
        /* @__PURE__ */ h.jsx(kot, {}),
        /* @__PURE__ */ h.jsx(Aot, {}),
        /* @__PURE__ */ h.jsx(Mot, {}),
        /* @__PURE__ */ h.jsx(Oot, {}),
        /* @__PURE__ */ h.jsx(Not, {}),
        /* @__PURE__ */ h.jsx(jot, {}),
        /* @__PURE__ */ h.jsx(Dot, {})
      ] }),
      /* @__PURE__ */ h.jsx(At, { id: "color-scheme", children: /* @__PURE__ */ h.jsx(ZZe, {}) })
    ] }),
    /* @__PURE__ */ h.jsx(Whe, {}),
    /* @__PURE__ */ h.jsx(Khe, {})
  ] });
}
const pit = it(function({ children: e }) {
  const n = Gr(), [r, s] = vu("main menu"), o = Ze(), i = e ?? /* @__PURE__ */ h.jsx(oit, {});
  return /* @__PURE__ */ h.jsxs(y5, { dir: "ltr", open: r, onOpenChange: s, modal: !1, children: [
    /* @__PURE__ */ h.jsx(v5, { asChild: !0, dir: "ltr", children: /* @__PURE__ */ h.jsx(yt, { type: "icon", "data-testid": "main-menu.button", title: o("menu.title"), children: /* @__PURE__ */ h.jsx(gt, { icon: "menu", small: !0 }) }) }),
    /* @__PURE__ */ h.jsx(xk, { container: n, children: /* @__PURE__ */ h.jsx(
      b5,
      {
        className: "tlui-menu",
        side: "bottom",
        align: "start",
        collisionPadding: 4,
        alignOffset: 0,
        sideOffset: 6,
        children: /* @__PURE__ */ h.jsx(pi, { type: "menu", sourceId: "main-menu", children: i })
      }
    ) })
  ] });
}), n2 = {};
function ub(t) {
  if (n2[t])
    return n2[t];
  const n = document.createElement("canvas").getContext("2d");
  n.fillStyle = t, n.fillRect(0, 0, 1, 1);
  const [r, s, o, i] = n.getImageData(0, 0, 1, 1).data, a = new Float32Array([r / 255, s / 255, o / 255, i / 255]);
  return n2[t] = a, a;
}
const A_ = 10, Ghe = (
  // num triangles in corners
  // num triangles in outer rects
  4 * 6 * A_ + // num triangles in center rect
  12 + 4 * 12
);
function rm(t, {
  center: e,
  radius: n,
  numArcSegments: r = 20,
  startAngle: s = 0,
  endAngle: o = Bn,
  offset: i = 0
}) {
  const a = (o - s) / r;
  let c = i;
  for (let l = s; l < o; l += a)
    t[c++] = e.x, t[c++] = e.y, t[c++] = e.x + Math.cos(l) * n, t[c++] = e.y + Math.sin(l) * n, t[c++] = e.x + Math.cos(l + a) * n, t[c++] = e.y + Math.sin(l + a) * n;
  return t;
}
function sm(t, e, n, r, s, o) {
  t[e++] = n, t[e++] = r, t[e++] = n, t[e++] = r + o, t[e++] = n + s, t[e++] = r, t[e++] = n + s, t[e++] = r, t[e++] = n, t[e++] = r + o, t[e++] = n + s, t[e++] = r + o;
}
function git(t, e, n) {
  const r = A_;
  n = Math.min(n, Math.min(e.w, e.h) / 2);
  const s = _e.ExpandBy(e, -n);
  if (s.w <= 0 || s.h <= 0)
    return rm(t, { center: e.center, radius: n, numArcSegments: A_ * 4 }), A_ * 4 * 6;
  let o = 0;
  return sm(t, o, s.minX, s.minY, s.w, s.h), o += 12, sm(t, o, s.minX, e.minY, s.w, n), o += 12, sm(t, o, s.maxX, s.minY, n, s.h), o += 12, sm(t, o, s.minX, s.maxY, s.w, n), o += 12, sm(t, o, e.minX, s.minY, n, s.h), o += 12, rm(t, {
    numArcSegments: r,
    offset: o,
    center: s.point,
    radius: n,
    startAngle: mn,
    endAngle: mn * 1.5
  }), o += r * 6, rm(t, {
    numArcSegments: r,
    offset: o,
    center: I.Add(s.point, new I(s.w, 0)),
    radius: n,
    startAngle: mn * 1.5,
    endAngle: Bn
  }), o += r * 6, rm(t, {
    numArcSegments: r,
    offset: o,
    center: I.Add(s.point, s.size),
    radius: n,
    startAngle: 0,
    endAngle: ar
  }), o += r * 6, rm(t, {
    numArcSegments: r,
    offset: o,
    center: I.Add(s.point, new I(0, s.h)),
    radius: n,
    startAngle: ar,
    endAngle: mn
  }), Ghe;
}
function mit(t) {
  if (!t) throw new Error("Canvas element not found");
  const e = t.getContext("webgl2", {
    premultipliedAlpha: !1
  });
  if (!e) throw new Error("Failed to get webgl2 context");
  const n = `#version 300 es
  precision mediump float;
  
  in vec2 shapeVertexPosition;

	uniform vec4 canvasPageBounds;

	// taken (with thanks) from
	// https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html
  void main() {
		// convert the position from pixels to 0.0 to 1.0
		vec2 zeroToOne = (shapeVertexPosition - canvasPageBounds.xy) / canvasPageBounds.zw;
	
		// convert from 0->1 to 0->2
		vec2 zeroToTwo = zeroToOne * 2.0;
	
		// convert from 0->2 to -1->+1 (clipspace)
		vec2 clipSpace = zeroToTwo - 1.0;
	
		gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  }`, r = e.createShader(e.VERTEX_SHADER);
  if (!r)
    throw new Error("Failed to create vertex shader");
  if (e.shaderSource(r, n), e.compileShader(r), !e.getShaderParameter(r, e.COMPILE_STATUS))
    throw new Error("Failed to compile vertex shader");
  const s = `#version 300 es
  precision mediump float;
  
	uniform vec4 fillColor;
  out vec4 outputColor;

  void main() {
	outputColor = fillColor;
  }`, o = e.createShader(e.FRAGMENT_SHADER);
  if (!o)
    throw new Error("Failed to create fragment shader");
  if (e.shaderSource(o, s), e.compileShader(o), !e.getShaderParameter(o, e.COMPILE_STATUS))
    throw new Error("Failed to compile fragment shader");
  const i = e.createProgram();
  if (!i)
    throw new Error("Failed to create program");
  if (e.attachShader(i, r), e.attachShader(i, o), e.linkProgram(i), !e.getProgramParameter(i, e.LINK_STATUS))
    throw new Error("Failed to link program");
  e.useProgram(i);
  const a = e.getAttribLocation(
    i,
    "shapeVertexPosition"
  );
  if (a < 0)
    throw new Error("Failed to get shapeVertexPosition attribute location");
  e.enableVertexAttribArray(a);
  const c = e.getUniformLocation(i, "canvasPageBounds"), l = e.getUniformLocation(i, "fillColor");
  if (!e.createBuffer()) throw new Error("Failed to create buffer");
  if (!e.createBuffer()) throw new Error("Failed to create buffer");
  return {
    context: e,
    selectedShapes: lC(e, 1024),
    unselectedShapes: lC(e, 4096),
    viewport: lC(e, Ghe),
    collaborators: lC(e, 1024),
    prepareTriangles(f, p) {
      e.bindBuffer(e.ARRAY_BUFFER, f.buffer), e.bufferData(e.ARRAY_BUFFER, f.vertices, e.STATIC_DRAW, 0, p), e.enableVertexAttribArray(a), e.vertexAttribPointer(
        a,
        2,
        e.FLOAT,
        !1,
        0,
        0
      );
    },
    drawTrianglesTransparently(f) {
      e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA), e.drawArrays(e.TRIANGLES, 0, f / 2), e.disable(e.BLEND);
    },
    drawTriangles(f) {
      e.drawArrays(e.TRIANGLES, 0, f / 2);
    },
    setFillColor(f) {
      e.uniform4fv(l, f);
    },
    setCanvasPageBounds(f) {
      e.uniform4fv(c, f);
    }
  };
}
function lC(t, e) {
  const n = t.createBuffer();
  if (!n) throw new Error("Failed to create buffer");
  return { buffer: n, vertices: new Float32Array(e) };
}
function k7(t, e, n) {
  let r = t.vertices.length;
  for (; r < e + n.length; )
    r *= 2;
  if (r != t.vertices.length) {
    const s = new Float32Array(r);
    s.set(t.vertices), t.vertices = s;
  }
  t.vertices.set(n, e);
}
var yit = Object.create, Yhe = Object.defineProperty, vit = Object.getOwnPropertyDescriptor, bit = (t, e) => (e = Symbol[t]) ? e : Symbol.for("Symbol." + t), qhe = (t) => {
  throw TypeError(t);
}, Xhe = (t, e, n) => e in t ? Yhe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, xit = (t) => [, , , yit(null)], Zhe = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], Qhe = (t) => t !== void 0 && typeof t != "function" ? qhe("Function expected") : t, wit = (t, e, n, r, s) => ({ kind: Zhe[t], name: e, metadata: r, addInitializer: (o) => n._ ? qhe("Already initialized") : s.push(Qhe(o || null)) }), Sit = (t, e) => Xhe(e, bit("metadata"), t[3]), Cit = (t, e, n, r) => {
  for (var s = 0, o = t[e >> 1], i = o && o.length; s < i; s++) o[s].call(n);
  return r;
}, ad = (t, e, n, r, s, o) => {
  for (var i, a, c, l, d = e & 7, u = !!(e & 8), f = !!(e & 16), p = 2, g = Zhe[d + 5], y = t[p] || (t[p] = []), m = (s = s.prototype, vit(s, n)), v = r.length - 1; v >= 0; v--)
    c = wit(d, n, a = {}, t[3], y), c.static = u, c.private = f, l = c.access = { has: (b) => n in b }, l.get = (b) => b[n], i = (0, r[v])(m[g], c), a._ = 1, Qhe(i) && (m[g] = i);
  return m && Yhe(s, n, m), s;
}, _d = (t, e, n) => Xhe(t, typeof e != "symbol" ? e + "" : e, n), Jhe, epe, tpe, npe, rpe, spe, ope, ipe, ape, cpe, Na;
cpe = [Li], ape = [ve], ipe = [ve], ope = [ve], spe = [ve], rpe = [ve], npe = [ve], tpe = [ve], epe = [ve], Jhe = [Li];
class yc {
  constructor(e, n, r) {
    this.editor = e, this.elem = n, this.container = r, Cit(Na, 5, this), _d(this, "disposables", []), _d(this, "gl"), _d(this, "shapeGeometryCache"), _d(this, "colors"), _d(this, "id", bn()), _d(this, "canvasBoundingClientRect", yr("canvasBoundingClientRect", new _e())), _d(this, "originPagePoint", new I()), _d(this, "originPageCenter", new I()), _d(this, "isInViewport", !1), this.gl = mit(n), this.shapeGeometryCache = e.store.createComputedCache("webgl-geometry", (s) => {
      const o = e.getShapeMaskedPageBounds(s.id);
      if (!o) return null;
      const i = new Float32Array(12);
      return sm(i, 0, o.x, o.y, o.w, o.h), i;
    }), this.colors = this._getColors(), this.disposables.push(this._listenForCanvasResize(), ya("minimap render", this.render));
  }
  close() {
    return this.disposables.forEach((e) => e());
  }
  _getColors() {
    const e = getComputedStyle(this.editor.getContainer());
    return {
      shapeFill: ub(e.getPropertyValue("--color-text-3").trim()),
      selectFill: ub(e.getPropertyValue("--color-selected").trim()),
      viewportFill: ub(e.getPropertyValue("--color-muted-1").trim()),
      background: ub(e.getPropertyValue("--color-low").trim())
    };
  }
  // this should be called after dark/light mode changes have propagated to the dom
  updateColors() {
    this.colors = this._getColors();
  }
  getDpr() {
    return this.editor.getInstanceState().devicePixelRatio;
  }
  getContentPageBounds() {
    const e = this.editor.getViewportPageBounds(), n = this.editor.getCurrentPageBounds();
    return n ? _e.Expand(n, e) : e;
  }
  getContentScreenBounds() {
    const e = this.getContentPageBounds(), n = this.editor.pageToScreen(e.point), r = this.editor.pageToScreen(
      new I(e.maxX, e.maxY)
    );
    return new _e(n.x, n.y, r.x - n.x, r.y - n.y);
  }
  _getCanvasBoundingRect() {
    const { x: e, y: n, width: r, height: s } = this.elem.getBoundingClientRect();
    return new _e(e, n, r, s);
  }
  getCanvasScreenBounds() {
    return this.canvasBoundingClientRect.get();
  }
  _listenForCanvasResize() {
    const e = new ResizeObserver(() => {
      const n = this._getCanvasBoundingRect();
      this.canvasBoundingClientRect.set(n);
    });
    return e.observe(this.elem), e.observe(this.container), () => e.disconnect();
  }
  getCanvasSize() {
    const e = this.canvasBoundingClientRect.get(), n = this.getDpr();
    return new I(e.width * n, e.height * n);
  }
  getCanvasClientPosition() {
    return this.canvasBoundingClientRect.get().point;
  }
  getCanvasPageBounds() {
    const e = this.getCanvasScreenBounds(), n = this.getContentPageBounds(), r = e.width / e.height;
    let s = n.width, o = s / r;
    o < n.height && (o = n.height, s = o * r);
    const i = new _e(0, 0, s, o);
    return i.center = n.center, i;
  }
  getZoom() {
    return this.getCanvasPageBounds().width / this.getCanvasScreenBounds().width;
  }
  getCanvasPageBoundsArray() {
    const { x: e, y: n, w: r, h: s } = this.getCanvasPageBounds();
    return new Float32Array([e, n, r, s]);
  }
  getMinimapPagePoint(e, n) {
    const r = this.getCanvasPageBounds(), s = this.getCanvasScreenBounds();
    let o = e - s.x, i = n - s.y;
    return o *= r.width / s.width, i *= r.height / s.height, o += r.minX, i += r.minY, new I(o, i, 1);
  }
  minimapScreenPointToPagePoint(e, n, r = !1, s = !1) {
    const { editor: o } = this, i = o.getViewportPageBounds();
    let { x: a, y: c } = this.getMinimapPagePoint(e, n);
    if (s) {
      const l = this.editor.getCurrentPageBounds() ?? new _e(), d = l.minX - i.width / 2, u = l.maxX + i.width / 2, f = l.minY - i.height / 2, p = l.maxY + i.height / 2, g = Math.max(0, d + i.width - a), y = Math.max(0, -(u - i.width - a)), m = Math.max(0, f + i.height - c), v = Math.max(0, -(p - i.height - c));
      a += (g - y) / 2, c += (m - v) / 2, a = wt(a, d, u), c = wt(c, f, p);
    }
    if (r) {
      const { originPagePoint: l } = this, d = Math.abs(a - l.x), u = Math.abs(c - l.y);
      d > u ? c = l.y : a = l.x;
    }
    return new I(a, c);
  }
  render() {
    const e = this.gl.context, n = this.getCanvasSize();
    this.gl.setCanvasPageBounds(this.getCanvasPageBoundsArray()), this.elem.width = n.x, this.elem.height = n.y, e.viewport(0, 0, n.x, n.y), e.clearColor(
      this.colors.background[0],
      this.colors.background[1],
      this.colors.background[2],
      1
    ), e.clear(e.COLOR_BUFFER_BIT);
    const r = new Set(this.editor.getSelectedShapeIds()), s = this.colors;
    let o = 0, i = 0;
    const a = this.editor.getCurrentPageShapeIdsSorted();
    for (let c = 0, l = a.length; c < l; c++) {
      const d = a[c], u = this.shapeGeometryCache.get(d);
      if (!u) continue;
      const f = u.length;
      r.has(d) ? (k7(this.gl.selectedShapes, o, u), o += f) : (k7(this.gl.unselectedShapes, i, u), i += f);
    }
    this.drawShapes(this.gl.unselectedShapes, i, s.shapeFill), this.drawShapes(this.gl.selectedShapes, o, s.selectFill), this.drawViewport(), this.drawCollaborators();
  }
  drawShapes(e, n, r) {
    this.gl.prepareTriangles(e, n), this.gl.setFillColor(r), this.gl.drawTriangles(n);
  }
  drawViewport() {
    const e = this.editor.getViewportPageBounds(), n = git(this.gl.viewport.vertices, e, 4 * this.getZoom());
    this.gl.prepareTriangles(this.gl.viewport, n), this.gl.setFillColor(this.colors.viewportFill), this.gl.drawTrianglesTransparently(n), dn.isSafari && (this.gl.drawTrianglesTransparently(n), this.gl.drawTrianglesTransparently(n), this.gl.drawTrianglesTransparently(n));
  }
  drawCollaborators() {
    const e = this.editor.getCollaboratorsOnCurrentPage();
    if (!e.length) return;
    const n = 20, r = n * 6, s = r * e.length;
    this.gl.collaborators.vertices.length < s && (this.gl.collaborators.vertices = new Float32Array(s));
    const o = this.gl.collaborators.vertices;
    let i = 0;
    const a = this.getZoom();
    for (const { cursor: c } of e)
      c && (rm(o, {
        center: I.From(c),
        radius: 3 * a,
        offset: i,
        numArcSegments: n
      }), i += r);
    this.gl.prepareTriangles(this.gl.collaborators, s), i = 0;
    for (const { color: c } of e)
      this.gl.setFillColor(ub(c)), this.gl.context.drawArrays(this.gl.context.TRIANGLES, i / 2, r / 2), i += r;
  }
}
Na = xit();
ad(Na, 1, "close", cpe, yc);
ad(Na, 1, "getDpr", ape, yc);
ad(Na, 1, "getContentPageBounds", ipe, yc);
ad(Na, 1, "getContentScreenBounds", ope, yc);
ad(Na, 1, "getCanvasSize", spe, yc);
ad(Na, 1, "getCanvasClientPosition", rpe, yc);
ad(Na, 1, "getCanvasPageBounds", npe, yc);
ad(Na, 1, "getZoom", tpe, yc);
ad(Na, 1, "getCanvasPageBoundsArray", epe, yc);
ad(Na, 1, "render", Jhe, yc);
Sit(Na, yc);
function _it() {
  const t = ie(), e = Gr(), n = Ze(), r = T.useRef(null), s = T.useRef(!1), o = T.useRef();
  T.useEffect(() => {
    try {
      const u = new yc(t, r.current, e);
      return o.current = u, o.current.close;
    } catch (u) {
      t.annotateError(u, {
        origin: "minimap",
        willCrashApp: !1
      }), t.timers.setTimeout(() => {
        throw u;
      });
    }
  }, [t, e]);
  const i = T.useCallback(
    (u) => {
      if (!t.getCurrentPageShapeIds().size || !o.current) return;
      const f = o.current.minimapScreenPointToPagePoint(
        u.clientX,
        u.clientY,
        !1,
        !1
      ), p = o.current.minimapScreenPointToPagePoint(
        u.clientX,
        u.clientY,
        !1,
        !0
      );
      o.current.originPagePoint.setTo(p), o.current.originPageCenter.setTo(t.getViewportPageBounds().center), t.centerOnPoint(f, { animation: { duration: t.options.animationMediumMs } });
    },
    [t]
  ), a = T.useCallback(
    (u) => {
      if (!o.current) return;
      const f = u.currentTarget;
      if (q0(f, u), !t.getCurrentPageShapeIds().size) return;
      s.current = !0, o.current.isInViewport = !1;
      const p = o.current.minimapScreenPointToPagePoint(
        u.clientX,
        u.clientY,
        !1,
        !1
      ), g = t.getViewportPageBounds(), y = o.current.getContentPageBounds();
      if (new _e(
        y.x - g.width / 2,
        y.y - g.height / 2,
        y.width + g.width,
        y.height + g.height
      ).containsPoint(p) && !g.containsPoint(p)) {
        o.current.isInViewport = g.containsPoint(p);
        const b = I.Sub(g.center, g.point), x = I.Add(p, b);
        o.current.originPagePoint.setTo(x), o.current.originPageCenter.setTo(p), t.centerOnPoint(p, { animation: { duration: t.options.animationMediumMs } });
      } else {
        const b = o.current.minimapScreenPointToPagePoint(
          u.clientX,
          u.clientY,
          !1,
          !0
        );
        o.current.isInViewport = g.containsPoint(b), o.current.originPagePoint.setTo(b), o.current.originPageCenter.setTo(g.center);
      }
      function v(b) {
        f && X0(f, b), s.current = !1, document.body.removeEventListener("pointerup", v);
      }
      document.body.addEventListener("pointerup", v);
    },
    [t]
  ), c = T.useCallback(
    (u) => {
      if (!o.current) return;
      const f = o.current.minimapScreenPointToPagePoint(
        u.clientX,
        u.clientY,
        u.shiftKey,
        !0
      );
      if (s.current) {
        if (o.current.isInViewport) {
          const m = o.current.originPagePoint.clone().sub(o.current.originPageCenter);
          t.centerOnPoint(I.Sub(f, m));
          return;
        }
        t.centerOnPoint(f);
      }
      const p = o.current.getMinimapPagePoint(u.clientX, u.clientY), g = t.pageToScreen(p), y = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...la(u),
        point: g,
        isPen: t.getInstanceState().isPenMode
      };
      t.dispatch(y);
    },
    [t]
  ), l = T.useCallback(
    (u) => {
      const f = rie(u);
      t.dispatch({
        type: "wheel",
        name: "wheel",
        delta: f,
        point: new I(u.clientX, u.clientY),
        shiftKey: u.shiftKey,
        altKey: u.altKey,
        ctrlKey: u.metaKey || u.ctrlKey,
        metaKey: u.metaKey,
        accelKey: ms(u)
      });
    },
    [t]
  ), d = rS();
  return T.useEffect(() => {
    t.timers.setTimeout(() => {
      var u, f;
      (u = o.current) == null || u.updateColors(), (f = o.current) == null || f.render();
    });
  }, [d, t]), /* @__PURE__ */ h.jsx("div", { className: "tlui-minimap", children: /* @__PURE__ */ h.jsx(
    "canvas",
    {
      role: "img",
      "aria-label": n("navigation-zone.minimap"),
      ref: r,
      className: "tlui-minimap__canvas",
      onDoubleClick: i,
      onPointerMove: c,
      onPointerDown: a,
      onWheelCapture: l
    }
  ) });
}
function Eit(t, e) {
  const [n, r] = B.useState(e);
  B.useLayoutEffect(() => {
    const o = pF(t);
    if (o)
      try {
        r(JSON.parse(o));
      } catch {
        console.error(`Could not restore value ${t} from local storage.`);
      }
  }, [t]);
  const s = B.useCallback(
    (o) => {
      r((i) => {
        const a = typeof o == "function" ? o(i) : o;
        return gF(t, JSON.stringify(a)), a;
      });
    },
    [t]
  );
  return [n, s];
}
const Tit = it(function() {
  const e = xu(), n = Ze(), r = Uo(), s = fe(null);
  yu(s);
  const [o, i] = Eit("minimap", !0), a = re(() => {
    i((d) => !d);
  }, [i]), { ZoomMenu: c, Minimap: l } = uh();
  return r < Ir.MOBILE ? null : /* @__PURE__ */ h.jsxs("div", { ref: s, className: "tlui-navigation-panel", children: [
    /* @__PURE__ */ h.jsx(zr, { className: "tlui-buttons__horizontal", label: n("navigation-zone.title"), children: c && r < Ir.TABLET ? /* @__PURE__ */ h.jsx(c, {}) : /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      !o && /* @__PURE__ */ h.jsx(
        Ds,
        {
          type: "icon",
          "data-testid": "minimap.zoom-out",
          title: `${n(Tw(e["zoom-out"].label))} ${rR(e["zoom-out"].kbd)}`,
          onClick: () => e["zoom-out"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "minus" })
        }
      ),
      c && /* @__PURE__ */ h.jsx(c, {}, "zoom-menu"),
      !o && /* @__PURE__ */ h.jsx(
        Ds,
        {
          type: "icon",
          "data-testid": "minimap.zoom-in",
          title: `${n(Tw(e["zoom-in"].label))} ${rR(e["zoom-in"].kbd)}`,
          onClick: () => e["zoom-in"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "plus" })
        }
      ),
      l && /* @__PURE__ */ h.jsx(
        Ds,
        {
          type: "icon",
          "data-testid": "minimap.toggle-button",
          title: n("navigation-zone.toggle-minimap"),
          onClick: a,
          children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: o ? "chevron-right" : "chevron-left" })
        }
      )
    ] }) }),
    l && r >= Ir.TABLET && !o && /* @__PURE__ */ h.jsx(l, {})
  ] });
}), Pit = function({
  name: e,
  id: n,
  isCurrentPage: r,
  onCancel: s,
  onComplete: o
}) {
  const i = ie(), a = xr(), c = fe(null), l = fe(null), d = re(() => {
    l.current = i.markHistoryStoppingPoint("rename page");
  }, [i]), u = re(
    (p) => {
      i.renamePage(n, p || "New Page"), a("rename-page", { source: "page-menu" });
    },
    [i, n, a]
  ), f = re(() => {
    l.current && i.bailToMark(l.current), s();
  }, [i, s]);
  return /* @__PURE__ */ h.jsx(
    mv,
    {
      className: "tlui-page-menu__item__input",
      ref: (p) => c.current = p,
      defaultValue: e,
      onValueChange: u,
      onComplete: o,
      onCancel: f,
      onFocus: d,
      shouldManuallyMaintainScrollPositionWhenFocused: !0,
      autoFocus: r,
      autoSelect: !0
    }
  );
}, $R = (t, e, n, r, s) => {
  let o;
  const i = t.getPages(), a = n > r ? i[r - 1] : i[r], c = n > r ? i[r] : i[r + 1];
  a && !c ? o = Bc(a.index) : !a && c ? o = iDe(i[0].index) : o = oy(a.index, c.index), o !== i[n].index && (t.markHistoryStoppingPoint("moving page"), t.updatePage({
    id: e,
    index: o
  }), s("move-page", { source: "page-menu" }));
}, A7 = Kr(function({
  index: e,
  listSize: n,
  item: r,
  onRename: s
}) {
  const o = ie(), i = Ze(), a = o.getPages(), c = xr(), l = re(() => {
    o.markHistoryStoppingPoint("creating page");
    const p = ci.createId();
    o.duplicatePage(r.id, p), c("duplicate-page", { source: "page-menu" });
  }, [o, r, c]), d = re(() => {
    $R(o, r.id, e, e - 1, c);
  }, [o, r, e, c]), u = re(() => {
    $R(o, r.id, e, e + 1, c);
  }, [o, r, e, c]), f = re(() => {
    o.markHistoryStoppingPoint("deleting page"), o.deletePage(r.id), c("delete-page", { source: "page-menu" });
  }, [o, r, c]);
  return /* @__PURE__ */ h.jsxs(Dk, { id: `page item submenu ${e}`, children: [
    /* @__PURE__ */ h.jsx(Nk, { children: /* @__PURE__ */ h.jsx(yt, { type: "icon", title: i("page-menu.submenu.title"), children: /* @__PURE__ */ h.jsx(gt, { icon: "dots-vertical", small: !0 }) }) }),
    /* @__PURE__ */ h.jsx(jk, { alignOffset: 0, side: "right", sideOffset: -4, children: /* @__PURE__ */ h.jsxs(pi, { type: "menu", sourceId: "page-menu", children: [
      /* @__PURE__ */ h.jsxs(At, { id: "modify", children: [
        s && /* @__PURE__ */ h.jsx(Zt, { id: "rename", label: "page-menu.submenu.rename", onSelect: s }),
        /* @__PURE__ */ h.jsx(
          Zt,
          {
            id: "duplicate",
            label: "page-menu.submenu.duplicate-page",
            onSelect: l,
            disabled: a.length >= o.options.maxPages
          }
        ),
        e > 0 && /* @__PURE__ */ h.jsx(
          Zt,
          {
            id: "move-up",
            onSelect: d,
            label: "page-menu.submenu.move-up"
          }
        ),
        e < n - 1 && /* @__PURE__ */ h.jsx(
          Zt,
          {
            id: "move-down",
            label: "page-menu.submenu.move-down",
            onSelect: u
          }
        )
      ] }),
      n > 1 && /* @__PURE__ */ h.jsx(At, { id: "delete", children: /* @__PURE__ */ h.jsx(Zt, { id: "delete", onSelect: f, label: "page-menu.submenu.delete" }) })
    ] }) })
  ] });
}), Iit = it(function() {
  const e = ie(), n = xr(), r = Ze(), s = Uo(), o = re(() => v(!1), []), [i, a] = vu("page-menu", o), c = 36, l = fe(null), d = le("pages", () => e.getPages(), [e]), u = le("currentPage", () => e.getCurrentPage(), [e]), f = le("currentPageId", () => e.getCurrentPageId(), [e]), p = Da(), g = le(
    "maxPageCountReached",
    () => e.getPages().length >= e.options.maxPages,
    [e]
  ), y = le(
    "isCoarsePointer",
    () => e.getInstanceState().isCoarsePointer,
    [e]
  ), [m, v] = he(!1);
  me(
    function() {
      function A() {
        m || document.activeElement === document.body && e.menus.clearOpenMenus();
      }
      return document.addEventListener("keydown", A, { passive: !0 }), () => {
        document.removeEventListener("keydown", A);
      };
    },
    [e, m]
  );
  const b = re(() => {
    p || v((k) => !k);
  }, [p]), x = fe({
    isPointing: !1,
    status: "idle",
    pointing: null,
    startY: 0,
    startIndex: 0,
    dragIndex: 0
  }), [w, S] = he(
    Object.fromEntries(
      d.map((k, A) => [k.id, { y: A * c, offsetY: 0, isSelected: !1 }])
    )
  );
  un(() => {
    S(
      Object.fromEntries(
        d.map((k, A) => [k.id, { y: A * c, offsetY: 0, isSelected: !1 }])
      )
    );
  }, [c, d]), me(() => {
    i && e.timers.requestAnimationFrame(() => {
      var A;
      const k = document.querySelector(`[data-pageid="${f}"]`);
      if (k) {
        (A = k.querySelector("button")) == null || A.focus();
        const R = l.current;
        if (!R) return;
        const j = k.offsetTop, $ = R.scrollTop;
        j < $ && R.scrollTo({ top: j });
        const F = j + c, L = R.scrollTop + R.offsetHeight;
        F > L && R.scrollTo({ top: F - R.offsetHeight });
      }
    });
  }, [c, f, i, e]);
  const C = re(
    (k) => {
      const { clientY: A, currentTarget: R } = k, {
        dataset: { id: j, index: $ }
      } = R;
      if (!j || !$) return;
      const F = x.current;
      q0(k.currentTarget, k), F.status = "pointing", F.pointing = { id: j, index: +$ };
      const z = w[j].y;
      F.startY = A, F.startIndex = Math.max(0, Math.min(Math.round(z / c), d.length - 1));
    },
    [c, d.length, w]
  ), _ = re(
    (k) => {
      const A = x.current;
      if (A.status === "pointing") {
        const { clientY: R } = k, j = R - A.startY;
        Math.abs(j) > 5 && (A.status = "dragging");
      }
      if (A.status === "dragging") {
        const { clientY: R } = k, j = R - A.startY, $ = w[A.pointing.id], { startIndex: F, pointing: L } = A, z = $.y + j, H = Math.max(0, Math.min(Math.round(z / c), d.length - 1)), U = { ...w };
        if (U[L.id] = {
          y: $.y,
          offsetY: j,
          isSelected: !0
        }, H !== A.dragIndex) {
          A.dragIndex = H;
          for (let W = 0; W < d.length; W++) {
            const Z = d[W];
            if (Z.id === A.pointing.id)
              continue;
            let { y: K } = U[Z.id];
            H === F ? K = W * c : H < F ? H <= W && W < F ? K = (W + 1) * c : K = W * c : H > F && (H >= W && W > F ? K = (W - 1) * c : K = W * c), K !== U[Z.id].y && (U[Z.id] = { y: K, offsetY: 0, isSelected: !0 });
          }
        }
        S(U);
      }
    },
    [c, d, w]
  ), E = re(
    (k) => {
      const A = x.current;
      if (A.status === "dragging") {
        const { id: R, index: j } = A.pointing;
        $R(e, R, j, A.dragIndex, n);
      }
      X0(k.currentTarget, k), A.status = "idle";
    },
    [e, n]
  ), M = re(
    (k) => {
      const A = x.current;
      k.key === "Escape" && (A.status === "dragging" && S(
        Object.fromEntries(
          d.map((R, j) => [
            R.id,
            { y: j * c, offsetY: 0, isSelected: !1 }
          ])
        )
      ), A.status = "idle");
    },
    [c, d]
  ), N = re(() => {
    p || (e.run(() => {
      e.markHistoryStoppingPoint("creating page");
      const k = ci.createId();
      e.createPage({ name: r("page-menu.new-page-initial-name"), id: k }), e.setCurrentPage(k), v(!0), e.timers.requestAnimationFrame(() => {
        var R;
        const A = document.querySelector(`[data-pageid="${k}"]`);
        A && ((R = A.querySelector("button")) == null || R.focus());
      });
    }), n("new-page", { source: "page-menu" }));
  }, [e, r, p, n]), O = re(
    (k) => {
      e.setCurrentPage(k), n("change-page", { source: "page-menu" });
    },
    [e, n]
  ), D = re(
    (k, A) => {
      e.renamePage(k, A), n("rename-page", { source: "page-menu" });
    },
    [e, n]
  );
  return /* @__PURE__ */ h.jsxs(Bp, { id: "pages", onOpenChange: a, open: i, children: [
    /* @__PURE__ */ h.jsx(zp, { "data-testid": "main.page-menu", children: /* @__PURE__ */ h.jsxs(
      yt,
      {
        type: "menu",
        title: u.name,
        "data-testid": "page-menu.button",
        className: "tlui-page-menu__trigger",
        children: [
          /* @__PURE__ */ h.jsx("div", { className: "tlui-page-menu__name", children: u.name }),
          /* @__PURE__ */ h.jsx(gt, { icon: "chevron-down", small: !0 })
        ]
      }
    ) }),
    /* @__PURE__ */ h.jsx(
      Up,
      {
        side: "bottom",
        align: "start",
        sideOffset: 0,
        disableEscapeKeyDown: m,
        children: /* @__PURE__ */ h.jsxs("div", { className: "tlui-page-menu__wrapper", children: [
          /* @__PURE__ */ h.jsxs("div", { className: "tlui-page-menu__header", children: [
            /* @__PURE__ */ h.jsx("div", { className: "tlui-page-menu__header__title", children: r("page-menu.title") }),
            !p && /* @__PURE__ */ h.jsxs("div", { className: "tlui-buttons__horizontal", children: [
              /* @__PURE__ */ h.jsx(
                yt,
                {
                  type: "icon",
                  "data-testid": "page-menu.edit",
                  title: r(m ? "page-menu.edit-done" : "page-menu.edit-start"),
                  onClick: b,
                  children: /* @__PURE__ */ h.jsx(gt, { icon: m ? "check" : "edit" })
                }
              ),
              /* @__PURE__ */ h.jsx(
                yt,
                {
                  type: "icon",
                  "data-testid": "page-menu.create",
                  title: r(
                    g ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
                  ),
                  disabled: g,
                  onClick: N,
                  children: /* @__PURE__ */ h.jsx(gt, { icon: "plus" })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ h.jsx(
            "div",
            {
              "data-testid": "page-menu.list",
              className: "tlui-page-menu__list tlui-menu__group",
              style: { height: c * d.length + 4 },
              ref: l,
              children: d.map((k, A) => {
                const R = w[k.id] ?? {
                  position: A * 40,
                  offsetY: 0
                };
                return m ? /* @__PURE__ */ h.jsxs(
                  "div",
                  {
                    "data-testid": "page-menu.item",
                    "data-pageid": k.id,
                    className: "tlui-page_menu__item__sortable",
                    style: {
                      zIndex: k.id === u.id ? 888 : A,
                      transform: `translate(0px, ${R.y + R.offsetY}px)`
                    },
                    children: [
                      /* @__PURE__ */ h.jsx(
                        yt,
                        {
                          type: "icon",
                          tabIndex: -1,
                          className: "tlui-page_menu__item__sortable__handle",
                          onPointerDown: C,
                          onPointerUp: E,
                          onPointerMove: _,
                          onKeyDown: M,
                          "data-id": k.id,
                          "data-index": A,
                          children: /* @__PURE__ */ h.jsx(gt, { icon: "drag-handle-dots" })
                        }
                      ),
                      s < Ir.TABLET_SM && y ? (
                        // sigh, this is a workaround for iOS Safari
                        // because the device and the radix popover seem
                        // to be fighting over scroll position. Nothing
                        // else seems to work!
                        /* @__PURE__ */ h.jsxs(yt, {
                          type: "normal",
                          className: "tlui-page-menu__item__button",
                          onClick: () => {
                            const j = window.prompt("Rename page", k.name);
                            j && j !== k.name && D(k.id, j);
                          },
                          onDoubleClick: b,
                          children: [
                            /* @__PURE__ */ h.jsx(RR, { checked: k.id === u.id }),
                            /* @__PURE__ */ h.jsx(Pr, { children: k.name })
                          ]
                        })
                      ) : /* @__PURE__ */ h.jsx(
                        "div",
                        {
                          className: "tlui-page_menu__item__sortable__title",
                          style: { height: c },
                          children: /* @__PURE__ */ h.jsx(
                            Pit,
                            {
                              id: k.id,
                              name: k.name,
                              isCurrentPage: k.id === u.id,
                              onComplete: () => {
                                v(!1);
                              },
                              onCancel: () => {
                                v(!1);
                              }
                            }
                          )
                        }
                      ),
                      !p && /* @__PURE__ */ h.jsx("div", { className: "tlui-page_menu__item__submenu", "data-isediting": m, children: /* @__PURE__ */ h.jsx(A7, { index: A, item: k, listSize: d.length }) })
                    ]
                  },
                  k.id + "_editing"
                ) : /* @__PURE__ */ h.jsxs(
                  "div",
                  {
                    "data-pageid": k.id,
                    "data-testid": "page-menu.item",
                    className: "tlui-page-menu__item",
                    children: [
                      /* @__PURE__ */ h.jsxs(
                        yt,
                        {
                          type: "normal",
                          className: "tlui-page-menu__item__button",
                          onClick: () => O(k.id),
                          onDoubleClick: b,
                          title: r("page-menu.go-to-page"),
                          onKeyDown: (j) => {
                            j.key === "Enter" && k.id === u.id && (b(), cr(j));
                          },
                          children: [
                            /* @__PURE__ */ h.jsx(RR, { checked: k.id === u.id }),
                            /* @__PURE__ */ h.jsx(Pr, { children: k.name })
                          ]
                        }
                      ),
                      !p && /* @__PURE__ */ h.jsx("div", { className: "tlui-page_menu__item__submenu", children: /* @__PURE__ */ h.jsx(
                        A7,
                        {
                          index: A,
                          item: k,
                          listSize: d.length,
                          onRename: () => {
                            if (dn.isIos) {
                              const j = window.prompt("Rename page", k.name);
                              j && j !== k.name && D(k.id, j);
                            } else
                              v(!0), f !== k.id && O(k.id);
                          }
                        }
                      ) })
                    ]
                  },
                  k.id
                );
              })
            }
          )
        ] })
      }
    )
  ] });
});
function kit() {
  const t = ie(), e = Da(), n = le(
    "should display quick actions",
    () => t.isInAny("select", "hand", "zoom"),
    [t]
  );
  if (!(e && !n))
    return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(Mit, {}),
      /* @__PURE__ */ h.jsx(Ait, {})
    ] });
}
function Ait() {
  const t = yi(1), e = wu(), n = t && e;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "delete", disabled: !n }),
    /* @__PURE__ */ h.jsx(be, { actionId: "duplicate", disabled: !n })
  ] });
}
function Mit() {
  const t = _he(), e = Che();
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "undo", disabled: !t }),
    /* @__PURE__ */ h.jsx(be, { actionId: "redo", disabled: !e })
  ] });
}
const Oit = it(function({
  children: e
}) {
  const n = e ?? /* @__PURE__ */ h.jsx(kit, {});
  return /* @__PURE__ */ h.jsx(pi, { type: "small-icons", sourceId: "quick-actions", children: n });
});
function Dit({ userId: t }) {
  var n;
  const e = qI(t);
  return e ? /* @__PURE__ */ h.jsx(
    "div",
    {
      className: "tlui-people-menu__avatar",
      style: {
        backgroundColor: e.color
      },
      children: ((n = e.userName) == null ? void 0 : n[0]) ?? ""
    },
    t
  ) : null;
}
const Nit = Kr(function({ userId: e }) {
  var l;
  const n = ie(), r = Ze(), s = xr(), o = qI(e), i = re(() => {
    n.getInstanceState().followingUserId === e ? (n.stopFollowingUser(), s("stop-following", { source: "people-menu" })) : (n.startFollowingUser(e), s("start-following", { source: "people-menu" }));
  }, [n, e, s]), a = (o == null ? void 0 : o.followingUserId) === n.user.getId(), c = n.getInstanceState().followingUserId === e;
  return o ? /* @__PURE__ */ h.jsxs(
    "div",
    {
      className: "tlui-people-menu__item tlui-buttons__horizontal",
      "data-follow": c || a,
      children: [
        /* @__PURE__ */ h.jsxs(
          yt,
          {
            type: "menu",
            className: "tlui-people-menu__item__button",
            onClick: () => n.zoomToUser(e),
            onDoubleClick: i,
            children: [
              /* @__PURE__ */ h.jsx(ed, { label: r("people-menu.avatar-color"), icon: "color", color: o.color }),
              /* @__PURE__ */ h.jsx("div", { className: "tlui-people-menu__name", children: ((l = o.userName) == null ? void 0 : l.trim()) || r("people-menu.anonymous-user") })
            ]
          }
        ),
        /* @__PURE__ */ h.jsx(
          yt,
          {
            type: "icon",
            className: "tlui-people-menu__item__follow",
            title: r(a ? "people-menu.leading" : c ? "people-menu.following" : "people-menu.follow"),
            onClick: i,
            disabled: a,
            children: /* @__PURE__ */ h.jsx(
              gt,
              {
                icon: a ? "leading" : c ? "following" : "follow"
              }
            )
          }
        )
      ]
    }
  ) : null;
});
function jit({ count: t }) {
  return /* @__PURE__ */ h.jsx("div", { className: "tlui-people-menu__avatar tlui-people-menu__more", children: Math.abs(t) });
}
const Rit = Kr(function() {
  const e = ie(), n = Gr(), r = Ze(), s = xr(), o = fe(!1), [i, a] = he(!1), c = re((y) => {
    a(y);
  }, []), l = e.user.getColor(), d = re(
    (y) => {
      e.user.updateUserPreferences({ color: y }), s("set-color", { source: "people-menu" });
    },
    [e, s]
  ), {
    handleButtonClick: u,
    handleButtonPointerDown: f,
    handleButtonPointerEnter: p,
    handleButtonPointerUp: g
  } = B.useMemo(() => {
    const y = () => {
      o.current = !1, window.removeEventListener("pointerup", y);
    };
    return {
      handleButtonClick: (w) => {
        const { id: S } = w.currentTarget.dataset;
        S && l !== S && d(S);
      },
      handleButtonPointerDown: (w) => {
        const { id: S } = w.currentTarget.dataset;
        S && (d(S), o.current = !0, window.addEventListener("pointerup", y));
      },
      handleButtonPointerEnter: (w) => {
        if (!o.current) return;
        const { id: S } = w.currentTarget.dataset;
        S && d(S);
      },
      handleButtonPointerUp: (w) => {
        const { id: S } = w.currentTarget.dataset;
        S && d(S);
      }
    };
  }, [l, d]);
  return /* @__PURE__ */ h.jsxs(hI, { onOpenChange: c, open: i, children: [
    /* @__PURE__ */ h.jsx(pI, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ h.jsx(
      yt,
      {
        type: "icon",
        className: "tlui-people-menu__user__color",
        style: { color: e.user.getColor() },
        title: r("people-menu.change-color"),
        children: /* @__PURE__ */ h.jsx(gt, { icon: "color" })
      }
    ) }),
    /* @__PURE__ */ h.jsx(gI, { container: n, children: /* @__PURE__ */ h.jsx(
      $0,
      {
        dir: "ltr",
        className: "tlui-menu tlui-people-menu__user__color-picker",
        align: "start",
        side: "left",
        sideOffset: 8,
        children: /* @__PURE__ */ h.jsx("div", { className: "tlui-buttons__grid", children: ij.map((y) => /* @__PURE__ */ h.jsx(
          yt,
          {
            type: "icon",
            "data-id": y,
            "data-testid": y,
            "aria-label": y,
            isActive: l === y,
            title: y,
            className: "tlui-button-grid__button",
            style: { color: y },
            onPointerEnter: p,
            onPointerDown: f,
            onPointerUp: g,
            onClick: u,
            children: /* @__PURE__ */ h.jsx(gt, { icon: "color" })
          },
          y
        )) })
      }
    ) })
  ] });
});
function $it() {
  const t = ie(), e = xr(), n = le("userName", () => t.user.getName(), []), r = Ze(), s = fe(n), o = fe(n), [i, a] = he(!1), c = re(() => {
    a((f) => !f);
  }, []), l = re(
    (f) => {
      o.current = f, t.user.updateUserPreferences({ name: f });
    },
    [t]
  ), d = re(() => {
    s.current !== o.current && (e("change-user-name", { source: "people-menu" }), s.current = o.current);
  }, [e]), u = re(() => {
    a(!1), t.user.updateUserPreferences({ name: s.current }), t.menus.clearOpenMenus();
  }, [t]);
  return /* @__PURE__ */ h.jsxs("div", { className: "tlui-people-menu__user", children: [
    /* @__PURE__ */ h.jsx(Rit, {}),
    i ? /* @__PURE__ */ h.jsx(
      mv,
      {
        className: "tlui-people-menu__user__input",
        defaultValue: n,
        onValueChange: l,
        onComplete: c,
        onCancel: u,
        onBlur: d,
        shouldManuallyMaintainScrollPositionWhenFocused: !0,
        autoFocus: !0,
        autoSelect: !0
      }
    ) : /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
      /* @__PURE__ */ h.jsx(
        "div",
        {
          className: "tlui-people-menu__user__name",
          onDoubleClick: () => {
            i || a(!0);
          },
          children: n || r("people-menu.anonymous-user")
        }
      ),
      n ? null : /* @__PURE__ */ h.jsx("div", { className: "tlui-people-menu__user__label", children: r("people-menu.user") })
    ] }),
    /* @__PURE__ */ h.jsx(
      yt,
      {
        type: "icon",
        className: "tlui-people-menu__user__edit",
        "data-testid": "people-menu.change-name",
        title: r("people-menu.change-name"),
        onClick: c,
        children: /* @__PURE__ */ h.jsx(gt, { icon: i ? "check" : "edit" })
      }
    )
  ] });
}
function Lit({ children: t }) {
  const e = Ze(), n = Gr(), r = ie(), s = cie(), o = le("user", () => r.user.getColor(), [r]), i = le("user", () => r.user.getName(), [r]), [a, c] = vu("people menu");
  return s.length ? /* @__PURE__ */ h.jsxs(hI, { onOpenChange: c, open: a, children: [
    /* @__PURE__ */ h.jsx(pI, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ h.jsx("button", { className: "tlui-people-menu__avatars-button", title: e("people-menu.title"), children: /* @__PURE__ */ h.jsxs("div", { className: "tlui-people-menu__avatars", children: [
      s.slice(-5).map((l) => /* @__PURE__ */ h.jsx(Dit, { userId: l }, l)),
      s.length > 0 && /* @__PURE__ */ h.jsx(
        "div",
        {
          className: "tlui-people-menu__avatar",
          style: {
            backgroundColor: o
          },
          children: (i == null ? void 0 : i[0]) ?? ""
        }
      ),
      s.length > 5 && /* @__PURE__ */ h.jsx(jit, { count: s.length - 5 })
    ] }) }) }),
    /* @__PURE__ */ h.jsx(gI, { container: n, children: /* @__PURE__ */ h.jsx(
      $0,
      {
        dir: "ltr",
        className: "tlui-menu",
        side: "bottom",
        sideOffset: 2,
        collisionPadding: 4,
        children: /* @__PURE__ */ h.jsxs("div", { className: "tlui-people-menu__wrapper", children: [
          /* @__PURE__ */ h.jsx("div", { className: "tlui-people-menu__section", children: /* @__PURE__ */ h.jsx($it, {}) }),
          s.length > 0 && /* @__PURE__ */ h.jsx("div", { className: "tlui-people-menu__section", children: s.map((l) => /* @__PURE__ */ h.jsx(Nit, { userId: l }, l + "_presence")) }),
          t
        ] })
      }
    ) })
  ] }) : null;
}
function Fit() {
  return /* @__PURE__ */ h.jsx("div", { className: "tlui-share-zone", draggable: !1, children: /* @__PURE__ */ h.jsx(Lit, {}) });
}
const Bit = Object.freeze([
  di,
  kp,
  Ap,
  Xl
]);
function lpe(t = Bit) {
  const e = ie();
  return le(
    "getRelevantStyles",
    () => {
      var o;
      const n = new hj(e.getSharedStyles()), r = !!((o = e.root.getCurrent()) != null && o.shapeType), s = e.isIn("select") && e.getSelectedShapeIds().length > 0;
      if (n.size === 0 && e.isIn("select") && e.getSelectedShapeIds().length === 0)
        for (const i of t)
          n.applyValue(i, e.getStyleForNextShape(i));
      return r || s || n.size > 0 ? n : null;
    },
    [e]
  );
}
const ua = {
  color: [
    { value: "black", icon: "color" },
    { value: "grey", icon: "color" },
    { value: "light-violet", icon: "color" },
    { value: "violet", icon: "color" },
    { value: "blue", icon: "color" },
    { value: "light-blue", icon: "color" },
    { value: "yellow", icon: "color" },
    { value: "orange", icon: "color" },
    { value: "green", icon: "color" },
    { value: "light-green", icon: "color" },
    { value: "light-red", icon: "color" },
    { value: "red", icon: "color" }
  ],
  fill: [
    { value: "none", icon: "fill-none" },
    { value: "semi", icon: "fill-semi" },
    { value: "solid", icon: "fill-solid" },
    { value: "pattern", icon: "fill-pattern" }
    // { value: 'fill', icon: 'fill-fill' },
  ],
  dash: [
    { value: "draw", icon: "dash-draw" },
    { value: "dashed", icon: "dash-dashed" },
    { value: "dotted", icon: "dash-dotted" },
    { value: "solid", icon: "dash-solid" }
  ],
  size: [
    { value: "s", icon: "size-small" },
    { value: "m", icon: "size-medium" },
    { value: "l", icon: "size-large" },
    { value: "xl", icon: "size-extra-large" }
  ],
  font: [
    { value: "draw", icon: "font-draw" },
    { value: "sans", icon: "font-sans" },
    { value: "serif", icon: "font-serif" },
    { value: "mono", icon: "font-mono" }
  ],
  textAlign: [
    { value: "start", icon: "text-align-left" },
    { value: "middle", icon: "text-align-center" },
    { value: "end", icon: "text-align-right" }
  ],
  horizontalAlign: [
    { value: "start", icon: "horizontal-align-start" },
    { value: "middle", icon: "horizontal-align-middle" },
    { value: "end", icon: "horizontal-align-end" }
  ],
  verticalAlign: [
    { value: "start", icon: "vertical-align-start" },
    { value: "middle", icon: "vertical-align-middle" },
    { value: "end", icon: "vertical-align-end" }
  ],
  geo: [
    { value: "rectangle", icon: "geo-rectangle" },
    { value: "ellipse", icon: "geo-ellipse" },
    { value: "triangle", icon: "geo-triangle" },
    { value: "diamond", icon: "geo-diamond" },
    { value: "star", icon: "geo-star" },
    { value: "pentagon", icon: "geo-pentagon" },
    { value: "hexagon", icon: "geo-hexagon" },
    { value: "octagon", icon: "geo-octagon" },
    { value: "rhombus", icon: "geo-rhombus" },
    { value: "rhombus-2", icon: "geo-rhombus-2" },
    { value: "oval", icon: "geo-oval" },
    { value: "trapezoid", icon: "geo-trapezoid" },
    { value: "arrow-left", icon: "geo-arrow-left" },
    { value: "arrow-up", icon: "geo-arrow-up" },
    { value: "arrow-down", icon: "geo-arrow-down" },
    { value: "arrow-right", icon: "geo-arrow-right" },
    { value: "cloud", icon: "geo-cloud" },
    { value: "x-box", icon: "geo-x-box" },
    { value: "check-box", icon: "geo-check-box" },
    { value: "heart", icon: "geo-heart" }
  ],
  arrowKind: [
    { value: "arc", icon: "arrow-arc" },
    { value: "elbow", icon: "arrow-elbow" }
  ],
  arrowheadStart: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  arrowheadEnd: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  spline: [
    { value: "line", icon: "spline-line" },
    { value: "cubic", icon: "spline-cubic" }
  ]
}, Wh = it(function(e) {
  const {
    uiType: n,
    items: r,
    title: s,
    style: o,
    value: i,
    // columns = clamp(items.length, 2, 4),
    onValueChange: a,
    onHistoryMark: c,
    theme: l
  } = e, d = ie(), u = Ze(), f = Uo(), p = fe(!1), g = fe(null), {
    handleButtonClick: y,
    handleButtonPointerDown: m,
    handleButtonPointerEnter: v,
    handleButtonPointerUp: b
  } = Ke(() => {
    const x = () => {
      p.current = !1, window.removeEventListener("pointerup", x);
      const E = g.current;
      E && (["TEXTAREA", "INPUT"].includes(E.nodeName) || E.isContentEditable) ? E.focus() : f >= Ir.TABLET_SM && d.getContainer().focus(), g.current = null;
    };
    return {
      handleButtonClick: (E) => {
        const { id: M } = E.currentTarget.dataset;
        i.type === "shared" && i.value === M || (c == null || c("point picker item"), a(o, M));
      },
      handleButtonPointerDown: (E) => {
        const { id: M } = E.currentTarget.dataset;
        c == null || c("point picker item"), a(o, M), p.current = !0, g.current = document.activeElement, window.addEventListener("pointerup", x);
      },
      handleButtonPointerEnter: (E) => {
        if (!p.current) return;
        const { id: M } = E.currentTarget.dataset;
        a(o, M);
      },
      handleButtonPointerUp: (E) => {
        const { id: M } = E.currentTarget.dataset;
        i.type === "shared" && i.value === M || a(o, M);
      }
    };
  }, [d, f, i, c, a, o]);
  return /* @__PURE__ */ h.jsx(
    pZe,
    {
      "data-testid": `style.${n}`,
      type: "single",
      className: Je("tlui-buttons__grid"),
      value: i.type === "shared" ? i.value : void 0,
      children: r.map((x) => {
        const w = s + "  " + u(`${n}-style.${x.value}`);
        return /* @__PURE__ */ h.jsx(
          gZe,
          {
            type: "icon",
            "data-id": x.value,
            "data-testid": `style.${n}.${x.value}`,
            "aria-label": w,
            value: x.value,
            "data-state": i.type === "shared" && i.value === x.value ? "on" : "off",
            "data-isactive": i.type === "shared" && i.value === x.value,
            title: w,
            className: Je("tlui-button-grid__button"),
            style: o === di ? { color: l[x.value].solid } : void 0,
            onPointerEnter: v,
            onPointerDown: m,
            onPointerUp: b,
            onClick: y,
            children: /* @__PURE__ */ h.jsx(gt, { icon: x.icon })
          },
          x.value
        );
      })
    }
  );
}), dpe = B.forwardRef(function({
  onHistoryMark: e,
  title: n,
  min: r,
  steps: s,
  value: o,
  label: i,
  onValueChange: a,
  ["data-testid"]: c,
  ariaValueModifier: l = 1
}, d) {
  const u = Ze(), [f, p] = he(-1);
  me(() => {
    p(0);
  }, []);
  const g = re(
    (v) => {
      a(v[0]);
    },
    [a]
  ), y = re(() => {
    e("click slider");
  }, [e]), m = re((v) => {
    v.key === "Tab" && v.stopPropagation();
  }, []);
  return /* @__PURE__ */ h.jsx("div", { className: "tlui-slider__container", children: /* @__PURE__ */ h.jsxs(
    EXe,
    {
      "data-testid": c,
      className: "tlui-slider",
      dir: "ltr",
      min: r ?? 0,
      max: s,
      step: 1,
      value: o !== null ? [o] : void 0,
      onPointerDown: y,
      onValueChange: g,
      onKeyDownCapture: m,
      onKeyUpCapture: m,
      title: n + "  " + u(i),
      children: [
        /* @__PURE__ */ h.jsx(TXe, { className: "tlui-slider__track", dir: "ltr", children: o !== null && /* @__PURE__ */ h.jsx(PXe, { className: "tlui-slider__range", dir: "ltr" }) }),
        o !== null && /* @__PURE__ */ h.jsx(
          IXe,
          {
            "aria-valuemin": (r ?? 0) * l,
            "aria-valuenow": o * l,
            "aria-valuemax": s * l,
            className: "tlui-slider__thumb",
            dir: "ltr",
            ref: d,
            tabIndex: f
          }
        )
      ]
    }
  ) });
});
function zit({
  label: t,
  uiTypeA: e,
  uiTypeB: n,
  labelA: r,
  labelB: s,
  itemsA: o,
  itemsB: i,
  styleA: a,
  styleB: c,
  valueA: l,
  valueB: d,
  onValueChange: u
}) {
  const f = ie(), p = Ze(), [g, y] = T.useState(!1), [m, v] = T.useState(!1), b = T.useMemo(
    () => {
      var C;
      return ((C = o.find((_) => l.type === "shared" && l.value === _.value)) == null ? void 0 : C.icon) ?? "mixed";
    },
    [o, l]
  ), x = T.useMemo(
    () => {
      var C;
      return ((C = i.find((_) => d.type === "shared" && d.value === _.value)) == null ? void 0 : C.icon) ?? "mixed";
    },
    [i, d]
  );
  if (l === void 0 && d === void 0) return null;
  const w = `style panel ${e} A`, S = `style panel ${n} B`;
  return /* @__PURE__ */ h.jsxs("div", { className: "tlui-style-panel__double-select-picker", children: [
    /* @__PURE__ */ h.jsx("div", { title: p(t), className: "tlui-style-panel__double-select-picker-label", children: p(t) }),
    /* @__PURE__ */ h.jsxs(zr, { label: p(t), className: "tlui-buttons__horizontal", children: [
      /* @__PURE__ */ h.jsxs(Bp, { id: w, open: g, onOpenChange: y, children: [
        /* @__PURE__ */ h.jsx(zp, { children: /* @__PURE__ */ h.jsx(
          Ds,
          {
            type: "icon",
            "data-testid": `style.${e}`,
            title: p(r) + "  " + (l === null || l.type === "mixed" ? p("style-panel.mixed") : p(`${e}-style.${l.value}`)),
            children: /* @__PURE__ */ h.jsx(gt, { icon: b, small: !0, invertIcon: !0 })
          }
        ) }),
        /* @__PURE__ */ h.jsx(Up, { side: "left", align: "center", sideOffset: 80, alignOffset: 0, children: /* @__PURE__ */ h.jsx(zr, { label: p(r), className: "tlui-buttons__grid", children: /* @__PURE__ */ h.jsx(pi, { type: "icons", sourceId: "style-panel", children: o.map((C) => /* @__PURE__ */ h.jsx(
          Ds,
          {
            "data-testid": `style.${e}.${C.value}`,
            type: "icon",
            onClick: () => {
              u(a, C.value), ni.deleteOpenMenu(w, f.contextId), y(!1);
            },
            title: `${p(r)}  ${p(`${e}-style.${C.value}`)}`,
            children: /* @__PURE__ */ h.jsx(gt, { icon: C.icon, invertIcon: !0 })
          },
          C.value
        )) }) }) })
      ] }),
      /* @__PURE__ */ h.jsxs(Bp, { id: S, open: m, onOpenChange: v, children: [
        /* @__PURE__ */ h.jsx(zp, { children: /* @__PURE__ */ h.jsx(
          Ds,
          {
            type: "icon",
            "data-testid": `style.${n}`,
            title: p(s) + "  " + (d === null || d.type === "mixed" ? p("style-panel.mixed") : p(`${n}-style.${d.value}`)),
            children: /* @__PURE__ */ h.jsx(gt, { icon: x, small: !0 })
          }
        ) }),
        /* @__PURE__ */ h.jsx(Up, { side: "left", align: "center", sideOffset: 116, alignOffset: 0, children: /* @__PURE__ */ h.jsx(zr, { label: p(s), className: "tlui-buttons__grid", children: /* @__PURE__ */ h.jsx(pi, { type: "icons", sourceId: "style-panel", children: i.map((C) => /* @__PURE__ */ h.jsx(
          Ds,
          {
            type: "icon",
            title: `${p(s)}  ${p(`${n}-style.${C.value}`)}`,
            "data-testid": `style.${n}.${C.value}`,
            onClick: () => {
              u(c, C.value), ni.deleteOpenMenu(S, f.contextId), v(!1);
            },
            children: /* @__PURE__ */ h.jsx(gt, { icon: C.icon })
          },
          C.value
        )) }) }) })
      ] })
    ] })
  ] });
}
const Uit = T.memo(
  zit
);
function Hit({
  id: t,
  label: e,
  uiType: n,
  stylePanelType: r,
  style: s,
  items: o,
  type: i,
  value: a,
  onValueChange: c
}) {
  const l = Ze(), d = ie(), [u, f] = T.useState(!1), p = T.useMemo(
    () => {
      var b;
      return (b = o.find((x) => a.type === "shared" && x.value === a.value)) == null ? void 0 : b.icon;
    },
    [o, a]
  ), g = l(`style-panel.${r}`), y = a.type === "mixed" ? l("style-panel.mixed") : g + "  " + l(`${n}-style.${a.value}`), m = e ? l(e) : "", v = `style panel ${t}`;
  return /* @__PURE__ */ h.jsxs(Bp, { id: v, open: u, onOpenChange: f, children: [
    /* @__PURE__ */ h.jsx(zp, { children: /* @__PURE__ */ h.jsxs(
      Ds,
      {
        type: i,
        "data-testid": `style.${n}`,
        "data-direction": "left",
        title: y,
        children: [
          m && /* @__PURE__ */ h.jsx(Pr, { children: m }),
          /* @__PURE__ */ h.jsx(gt, { icon: p ?? "mixed" })
        ]
      }
    ) }),
    /* @__PURE__ */ h.jsx(Up, { side: "left", align: "center", children: /* @__PURE__ */ h.jsx(
      zr,
      {
        label: m,
        className: Je("tlui-buttons__grid", `tlui-buttons__${r}`),
        children: /* @__PURE__ */ h.jsx(pi, { type: "icons", sourceId: "style-panel", children: o.map((b) => /* @__PURE__ */ h.jsx(
          Ds,
          {
            type: "icon",
            "data-testid": `style.${n}.${b.value}`,
            title: g + "  " + l(`${n}-style.${b.value}`),
            isActive: p === b.icon,
            onClick: () => {
              d.markHistoryStoppingPoint("select style dropdown item"), c(s, b.value), ni.deleteOpenMenu(v, d.contextId), f(!1);
            },
            children: /* @__PURE__ */ h.jsx(gt, { icon: b.icon })
          },
          b.value
        )) })
      }
    ) })
  ] });
}
const Wk = T.memo(Hit);
function Vit({ styles: t }) {
  const e = rS();
  if (!t) return null;
  const n = t.get(Hc), r = t.get(ME), s = t.get(AE), o = t.get(aw), i = t.get(jE), a = t.get(ou), c = n === void 0, l = r === void 0 && s === void 0, d = i === void 0, u = o === void 0, f = a === void 0, p = mu({ isDarkMode: e });
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(Wit, { theme: p, styles: t }),
    !f && /* @__PURE__ */ h.jsx(Kit, { theme: p, styles: t }),
    !(c && l && d && u) && /* @__PURE__ */ h.jsxs("div", { className: "tlui-style-panel__section", children: [
      /* @__PURE__ */ h.jsx(Git, { styles: t }),
      /* @__PURE__ */ h.jsx(qit, { styles: t }),
      /* @__PURE__ */ h.jsx(Xit, { styles: t }),
      /* @__PURE__ */ h.jsx(Yit, { styles: t })
    ] })
  ] });
}
function yv() {
  const t = ie(), e = xr();
  return B.useMemo(
    () => function(r, s) {
      t.run(() => {
        t.isIn("select") && t.setStyleForSelectedShapes(r, s), t.setStyleForNextShapes(r, s), t.updateInstanceState({ isChangingStyle: !0 });
      }), e("set-style", { source: "style-panel", id: r.id, value: s });
    },
    [t, e]
  );
}
function Wit({ styles: t, theme: e }) {
  const n = Ze(), r = ie(), s = re((u) => r.markHistoryStoppingPoint(u), [r]), o = yv(), i = t.get(di), a = t.get(Ap), c = t.get(kp), l = t.get(Xl), d = a !== void 0 || c !== void 0 || l !== void 0;
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsxs("div", { className: "tlui-style-panel__section__common", "data-testid": "style.panel", children: [
      i === void 0 ? null : /* @__PURE__ */ h.jsx(zr, { label: n("style-panel.color"), children: /* @__PURE__ */ h.jsx(
        Wh,
        {
          title: n("style-panel.color"),
          uiType: "color",
          style: di,
          items: ua.color,
          value: i,
          onValueChange: o,
          theme: e,
          onHistoryMark: s
        }
      ) }),
      /* @__PURE__ */ h.jsx(Zit, {})
    ] }),
    d && /* @__PURE__ */ h.jsxs("div", { className: "tlui-style-panel__section", children: [
      a === void 0 ? null : /* @__PURE__ */ h.jsx(zr, { label: n("style-panel.fill"), children: /* @__PURE__ */ h.jsx(
        Wh,
        {
          title: n("style-panel.fill"),
          uiType: "fill",
          style: Ap,
          items: ua.fill,
          value: a,
          onValueChange: o,
          theme: e,
          onHistoryMark: s
        }
      ) }),
      c === void 0 ? null : /* @__PURE__ */ h.jsx(zr, { label: n("style-panel.dash"), children: /* @__PURE__ */ h.jsx(
        Wh,
        {
          title: n("style-panel.dash"),
          uiType: "dash",
          style: kp,
          items: ua.dash,
          value: c,
          onValueChange: o,
          theme: e,
          onHistoryMark: s
        }
      ) }),
      l === void 0 ? null : /* @__PURE__ */ h.jsx(zr, { label: n("style-panel.size"), children: /* @__PURE__ */ h.jsx(
        Wh,
        {
          title: n("style-panel.size"),
          uiType: "size",
          style: Xl,
          items: ua.size,
          value: l,
          onValueChange: (u, f) => {
            o(u, f);
            const p = r.getSelectedShapeIds();
            p.length > 0 && An(r, p);
          },
          theme: e,
          onHistoryMark: s
        }
      ) })
    ] })
  ] });
}
function Kit({ theme: t, styles: e }) {
  const n = Ze(), r = yv(), s = ie(), o = re((d) => s.markHistoryStoppingPoint(d), [s]), i = e.get(ou), a = e.get(sj), c = e.get(DE), l = e.get(NE);
  return i === void 0 && c === void 0 ? null : /* @__PURE__ */ h.jsxs("div", { className: "tlui-style-panel__section", children: [
    i === void 0 ? null : /* @__PURE__ */ h.jsx(zr, { label: n("style-panel.font"), children: /* @__PURE__ */ h.jsx(
      Wh,
      {
        title: n("style-panel.font"),
        uiType: "font",
        style: ou,
        items: ua.font,
        value: i,
        onValueChange: r,
        theme: t,
        onHistoryMark: o
      }
    ) }),
    a === void 0 ? null : /* @__PURE__ */ h.jsxs(zr, { label: n("style-panel.align"), className: "tlui-style-panel__row", children: [
      /* @__PURE__ */ h.jsx(
        Wh,
        {
          title: n("style-panel.align"),
          uiType: "align",
          style: sj,
          items: ua.textAlign,
          value: a,
          onValueChange: r,
          theme: t,
          onHistoryMark: o
        }
      ),
      /* @__PURE__ */ h.jsx("div", { className: "tlui-style-panel__row__extra-button", children: /* @__PURE__ */ h.jsx(
        Ds,
        {
          type: "icon",
          title: n("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: !0,
          children: /* @__PURE__ */ h.jsx(gt, { icon: "vertical-align-middle" })
        }
      ) })
    ] }),
    c === void 0 ? null : /* @__PURE__ */ h.jsxs(zr, { label: n("style-panel.label-align"), className: "tlui-style-panel__row", children: [
      /* @__PURE__ */ h.jsx(
        Wh,
        {
          title: n("style-panel.label-align"),
          uiType: "align",
          style: DE,
          items: ua.horizontalAlign,
          value: c,
          onValueChange: r,
          theme: t,
          onHistoryMark: o
        }
      ),
      /* @__PURE__ */ h.jsx("div", { className: "tlui-style-panel__row__extra-button", children: l === void 0 ? /* @__PURE__ */ h.jsx(
        Ds,
        {
          type: "icon",
          title: n("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: !0,
          children: /* @__PURE__ */ h.jsx(gt, { icon: "vertical-align-middle" })
        }
      ) : /* @__PURE__ */ h.jsx(
        Wk,
        {
          type: "icon",
          id: "geo-vertical-alignment",
          uiType: "verticalAlign",
          stylePanelType: "vertical-align",
          style: NE,
          items: ua.verticalAlign,
          value: l,
          onValueChange: r
        }
      ) })
    ] })
  ] });
}
function Git({ styles: t }) {
  const e = Ze(), n = yv(), r = t.get(Hc);
  return r === void 0 ? null : /* @__PURE__ */ h.jsx(zr, { label: e("style-panel.geo"), children: /* @__PURE__ */ h.jsx(
    Wk,
    {
      id: "geo",
      type: "menu",
      label: "style-panel.geo",
      uiType: "geo",
      stylePanelType: "geo",
      style: Hc,
      items: ua.geo,
      value: r,
      onValueChange: n
    }
  ) });
}
function Yit({ styles: t }) {
  const e = Ze(), n = yv(), r = t.get(jE);
  return r === void 0 ? null : /* @__PURE__ */ h.jsx(zr, { label: e("style-panel.spline"), children: /* @__PURE__ */ h.jsx(
    Wk,
    {
      id: "spline",
      type: "menu",
      label: "style-panel.spline",
      uiType: "spline",
      stylePanelType: "spline",
      style: jE,
      items: ua.spline,
      value: r,
      onValueChange: n
    }
  ) });
}
function qit({ styles: t }) {
  const e = Ze(), n = yv(), r = t.get(aw);
  return r === void 0 ? null : /* @__PURE__ */ h.jsx(zr, { label: e("style-panel.arrow-kind"), children: /* @__PURE__ */ h.jsx(
    Wk,
    {
      id: "arrow-kind",
      type: "menu",
      label: "style-panel.arrow-kind",
      uiType: "arrow-kind",
      stylePanelType: "arrow-kind",
      style: aw,
      items: ua.arrowKind,
      value: r,
      onValueChange: n
    }
  ) });
}
function Xit({ styles: t }) {
  const e = yv(), n = t.get(ME), r = t.get(AE);
  return !n || !r ? null : /* @__PURE__ */ h.jsx(
    Uit,
    {
      label: "style-panel.arrowheads",
      uiTypeA: "arrowheadStart",
      styleA: AE,
      itemsA: ua.arrowheadStart,
      valueA: r,
      uiTypeB: "arrowheadEnd",
      styleB: ME,
      itemsB: ua.arrowheadEnd,
      valueB: n,
      onValueChange: e,
      labelA: "style-panel.arrowhead-start",
      labelB: "style-panel.arrowhead-end"
    }
  );
}
const fb = [0.1, 0.25, 0.5, 0.75, 1];
function Zit() {
  const t = ie(), e = re((a) => t.markHistoryStoppingPoint(a), [t]), n = le("opacity", () => t.getSharedOpacity(), [t]), r = xr(), s = Ze(), o = B.useCallback(
    (a) => {
      const c = fb[a];
      t.run(() => {
        t.isIn("select") && t.setOpacityForSelectedShapes(c), t.setOpacityForNextShapes(c), t.updateInstanceState({ isChangingStyle: !0 });
      }), r("set-style", { source: "style-panel", id: "opacity", value: a });
    },
    [t, r]
  );
  if (n === void 0) return null;
  const i = n.type === "mixed" ? -1 : fb.indexOf(
    _J(
      fb,
      (a) => Math.abs(a - n.value)
    )
  );
  return /* @__PURE__ */ h.jsx(
    dpe,
    {
      "data-testid": "style.opacity",
      value: i >= 0 ? i : fb.length - 1,
      label: n.type === "mixed" ? "style-panel.mixed" : `opacity-style.${n.value}`,
      onValueChange: o,
      steps: fb.length - 1,
      title: s("style-panel.opacity"),
      onHistoryMark: e,
      ariaValueModifier: 25
    }
  );
}
const Qit = it(function({
  isMobile: e,
  children: n
}) {
  const r = ie(), s = fe(null);
  yu(s);
  const o = lpe(), i = re(() => {
    e || r.updateInstanceState({ isChangingStyle: !1 });
  }, [r, e]), a = n ?? /* @__PURE__ */ h.jsx(Vit, { styles: o });
  return me(() => {
    function c(d) {
      var u;
      d.key === "Escape" && ((u = s.current) != null && u.contains(document.activeElement)) && (d.stopPropagation(), r.getContainer().focus());
    }
    const l = s.current;
    return l == null || l.addEventListener("keydown", c, { capture: !0 }), () => {
      l == null || l.removeEventListener("keydown", c, { capture: !0 });
    };
  }, [r]), /* @__PURE__ */ h.jsx(
    "div",
    {
      ref: s,
      className: Je("tlui-style-panel", { "tlui-style-panel__wrapper": !e }),
      "data-ismobile": e,
      onPointerLeave: i,
      children: a
    }
  );
}), Jit = 150, eat = 16, tat = 16, M7 = 16 ** 2, nat = 8, ju = 16, rat = !1, E4 = ({
  children: t,
  className: e,
  isMousingDown: n,
  getSelectionBounds: r,
  changeOnlyWhenYChanges: s = !1,
  label: o
}) => {
  const i = ie(), a = fe(null);
  yu(a), QHe(a);
  const { isVisible: c, isInteractive: l, hide: d, show: u, position: f, move: p } = iat(s), g = fe(!1), [y, m] = he(!1), v = K0("content size update counter", 0);
  me(() => {
    tt(a.current);
    const x = new ResizeObserver(() => {
      v.update((w) => w + 1);
    });
    return x.observe(a.current), () => x.disconnect();
  }, [v]), me(() => {
    let x = v.get();
    return ya("toolbar position", function() {
      const S = a.current;
      if (!S) return;
      const C = v.get();
      i.getCamera(), v.get();
      const _ = sat(i, S, r);
      if (!_)
        g.current && (g.current = !1, m(!1));
      else {
        if (i.getCameraState() === "moving")
          a.current.style.setProperty("transform", `translate(${_.x}px, ${_.y}px)`);
        else {
          const M = x !== C;
          p(_.x, _.y, M);
        }
        g.current || (g.current = !0, m(!0));
      }
      x = C;
    });
  }, [i, r, v, p]);
  const b = le("camera state", () => i.getCameraState(), [i]);
  return me(() => {
    if (b === "moving" && rat) {
      d(!0);
      return;
    }
    if (n || !y) {
      d();
      return;
    }
    u();
  }, [y, b, n, u, d]), un(() => {
    const x = a.current;
    x && (x.dataset.visible = `${c}`);
  }, [c, f]), un(() => {
    const x = a.current;
    x && x.style.setProperty("transform", `translate(${f.x}px, ${f.y}px)`);
  }, [f]), un(() => {
    const x = a.current;
    x && (x.dataset.interactive = `${l}`);
  }, [l]), /* @__PURE__ */ h.jsx(
    "div",
    {
      ref: a,
      "data-interactive": !1,
      "data-visible": !1,
      "data-testid": "contextual-toolbar",
      className: Je("tlui-contextual-toolbar", e),
      onPointerDown: cr,
      children: /* @__PURE__ */ h.jsx(zr, { className: "tlui-menu tlui-buttons__horizontal", label: o, children: t })
    }
  );
};
function upe(t) {
  return new _e(t.x, t.y, t.width, t.height);
}
function sat(t, e, n) {
  var d;
  const r = (d = n()) == null ? void 0 : d.clone();
  if (!r) return;
  const s = t.getViewportScreenBounds();
  if (r.x -= s.x, r.y -= s.y, r.midY < ju || r.midY > s.h - ju || r.midX < ju || r.midX > s.w - ju)
    return;
  const o = upe(e.getBoundingClientRect());
  if (!o.width || !o.height) return;
  const { scrollLeft: i, scrollTop: a } = t.getContainer();
  let c = r.midX - o.w / 2, l = r.y - o.h - nat;
  return c = wt(c, ju, s.w - o.w - ju), l = wt(l, ju, s.h - o.h - ju), c += i, l += a, c = Math.round(c), l = Math.round(l), { x: c, y: l };
}
function oat(t, e, n) {
  return n ? I.Sub(e, t).y ** 2 >= M7 : I.Len2(I.Sub(e, t)) >= M7;
}
function iat(t) {
  const e = ie(), n = fe({ name: "hidden" }), [r, s] = he(!1), [o, i] = he(!1), [a, c] = he({ x: -1e3, y: -1e3 }), l = fe(new I(-1e3, -1e3)), d = fe(new I(-1e3, -1e3)), u = fe(-1), f = fe(-1), p = re(
    (m, v, b = !1) => {
      if (d.current.x = m, d.current.y = v, n.current.name === "hidden" || n.current.name === "showing") return;
      clearTimeout(f.current);
      const x = () => {
        if (n.current.name === "shown" && oat(d.current, l.current, t)) {
          const { x: w, y: S } = d.current;
          l.current = new I(w, S), b ? x0(() => c({ x: w, y: S })) : c({ x: w, y: S });
        }
      };
      b ? x() : f.current = e.timers.setTimeout(x, Jit);
    },
    [e, t]
  ), g = re(
    (m = !1) => {
      switch (n.current.name) {
        case "showing": {
          clearTimeout(u.current), n.current = { name: "hidden" };
          break;
        }
        case "shown": {
          n.current = { name: "hiding" }, s(!1), m ? (n.current = { name: "hidden" }, i(!1)) : u.current = e.timers.setTimeout(() => {
            n.current = { name: "hidden" }, i(!1);
          }, eat);
          break;
        }
      }
    },
    [e]
  ), y = re(() => {
    switch (n.current.name) {
      case "hidden": {
        n.current = { name: "showing" }, u.current = e.timers.setTimeout(() => {
          const { x: m, y: v } = d.current;
          l.current = new I(m, v), c({ x: m, y: v }), n.current = { name: "shown" }, i(!0), s(!0);
        }, tat);
        break;
      }
      case "hiding": {
        clearTimeout(u.current), n.current = { name: "shown" }, s(!0), p(d.current.x, d.current.y);
        break;
      }
    }
  }, [e, p]);
  return { isVisible: o, isInteractive: r, show: y, hide: g, move: p, position: a };
}
function fpe({ shapeId: t, onClose: e, source: n }) {
  const r = ie(), [s, o] = he(() => {
    const g = r.getShape(t);
    if (!g) return "";
    if (!("altText" in g.props)) throw Error("Shape does not have altText property");
    return g.props.altText || "";
  }), i = Ze(), a = fe(null), c = xr(), l = r.getIsReadonly(), d = (g) => o(g), u = () => {
    c("set-alt-text", { source: n });
    const g = r.getShape(t);
    g && (r.updateShapes([
      {
        id: g.id,
        type: g.type,
        props: { altText: s }
      }
    ]), e());
  }, f = () => u(), p = re(() => e(), [e]);
  return me(() => {
    var y;
    (y = a.current) == null || y.select();
    function g(m) {
      m.key === "Escape" && (m.stopPropagation(), p());
    }
    return document.addEventListener("keydown", g, { capture: !0 }), () => {
      document.removeEventListener("keydown", g, { capture: !0 });
    };
  }, [p]), /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(
      mv,
      {
        ref: a,
        className: "tlui-media__toolbar-alt-text-input",
        "data-testid": "media-toolbar.alt-text-input",
        value: s,
        placeholder: i("tool.media-alt-text-desc"),
        onValueChange: d,
        onComplete: u,
        onCancel: p,
        disabled: l
      }
    ),
    !l && /* @__PURE__ */ h.jsx(
      yt,
      {
        title: i("tool.media-alt-text-confirm"),
        type: "icon",
        onPointerDown: xt,
        onClick: f,
        children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "check" })
      }
    )
  ] });
}
const aat = Kr(function({
  imageShapeId: e,
  isManipulating: n,
  onEditAltTextStart: r,
  onManipulatingStart: s,
  onManipulatingEnd: o
}) {
  const i = ie(), a = xr(), c = Ze(), l = "image-toolbar", d = fe(null), u = i.getIsReadonly(), f = le("crop", () => i.getShape(e).props.crop, [
    i,
    e
  ]), p = f ? Math.min(1 - (f.bottomRight.x - f.topLeft.x), 1 - (f.bottomRight.y - f.topLeft.y)) : 0, [g, y] = he(
    f ? Math.max(p, 1 - 1 / Pi) : Pi
  ), m = xu();
  me(() => {
    y(f ? Math.max(p, 1 - 1 / Pi) : Pi);
  }, [f, p, g]);
  const v = re((O) => i.markHistoryStoppingPoint(O), [i]), b = re((O, D) => {
    const k = Pi / (Pi - 1);
    return Math.pow(O / D, k) * D;
  }, []), x = f && g ? ql(
    b(p, g),
    [0, g],
    [0, 100],
    !0
    /* clamp */
  ) : 0, w = re(
    (O) => {
      i.setCurrentTool("select.crop.idle");
      const D = O / 100, k = 1 - 1 / Pi, A = Math.min(k, g ?? k), R = Pi / (Pi - 1), j = Math.pow(D, 1 / R) * A, $ = j >= 1 ? 1 : j / (2 * (1 - j)), F = i.getShape(e);
      if (!F) return;
      const L = KQe($, F, g);
      i.updateShape({
        id: F.id,
        type: F.type,
        x: L.x,
        y: L.y,
        props: {
          w: L.w,
          h: L.h,
          crop: L.crop
        }
      }), a("set-style", { source: "image-toolbar", id: "zoom", value: O });
    },
    [i, a, e, g]
  ), S = re(
    () => m["image-replace"].onSelect("image-toolbar"),
    [m]
  ), C = re(
    () => m["download-original"].onSelect("image-toolbar"),
    [m]
  ), _ = (O) => {
    const D = i.getShape(e);
    D && i.run(() => {
      i.setCurrentTool("select.crop.idle");
      const k = YQe(O, D);
      i.markHistoryStoppingPoint("aspect ratio"), i.updateShape({
        id: e,
        type: "image",
        x: k.x,
        y: k.y,
        props: {
          crop: k.crop,
          w: k.w,
          h: k.h
        }
      }), An(i, [e]);
    });
  }, E = le(
    "altText",
    () => i.getShape(e).props.altText,
    [i, e]
  ), M = le(
    "shapeAspectRatio",
    () => {
      const O = i.getShape(e);
      return O.props.w / O.props.h;
    },
    [i, e]
  ), N = !f || Zf(f, Vc());
  return me(() => {
    n && i.timers.setTimeout(() => {
      var O;
      return (O = d.current) == null ? void 0 : O.focus();
    }, 0);
  }, [i, n]), me(() => {
    function O(k) {
      n && (k.key === "Escape" ? (i.cancel(), o()) : k.key === "Enter" && (i.complete(), o()));
    }
    const D = d.current;
    return D && D.addEventListener("keydown", O), () => {
      D && D.removeEventListener("keydown", O);
    };
  }, [i, n, o]), n ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(
      dpe,
      {
        ref: d,
        value: x,
        label: "tool.image-zoom",
        onValueChange: w,
        onHistoryMark: v,
        min: 0,
        steps: 100,
        "data-testid": "tool.image-zoom",
        title: c("tool.image-zoom")
      }
    ),
    /* @__PURE__ */ h.jsxs(Dk, { id: "image-toolbar-aspect-ratio", children: [
      /* @__PURE__ */ h.jsx(Nk, { children: /* @__PURE__ */ h.jsx(yt, { title: c("tool.aspect-ratio"), type: "icon", children: /* @__PURE__ */ h.jsx(gt, { icon: "corners" }) }) }),
      /* @__PURE__ */ h.jsx(jk, { side: "top", align: "center", children: HQe.map((O) => {
        let D = !1;
        return N ? O === "original" && (D = !0) : O === "circle" ? D = !!f.isCircle : O === "square" ? D = !(f != null && f.isCircle) && Hr(M, lR[O], 0.1) : O === "original" ? D = !1 : D = !N && Hr(M, lR[O], 0.01), /* @__PURE__ */ h.jsx(
          hZe,
          {
            onSelect: () => _(O),
            checked: D,
            title: c(`tool.aspect-ratio.${O}`),
            children: /* @__PURE__ */ h.jsx(Pr, { children: c(`tool.aspect-ratio.${O}`) })
          },
          O
        );
      }) })
    ] }),
    /* @__PURE__ */ h.jsx(
      yt,
      {
        type: "icon",
        onClick: o,
        "data-testid": "tool.image-confirm",
        style: { borderLeft: "1px solid var(--color-divider)", marginLeft: "2px" },
        children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "check" })
      }
    )
  ] }) : /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    !u && /* @__PURE__ */ h.jsx(yt, { type: "icon", title: c("tool.replace-media"), onClick: S, children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "tool-media" }) }),
    !u && /* @__PURE__ */ h.jsx(yt, { type: "icon", title: c("tool.image-crop"), onClick: s, children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "crop" }) }),
    /* @__PURE__ */ h.jsx(
      yt,
      {
        type: "icon",
        title: c("action.download-original"),
        onClick: C,
        children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "download" })
      }
    ),
    (E || !u) && /* @__PURE__ */ h.jsx(
      yt,
      {
        type: "normal",
        title: c("tool.media-alt-text"),
        onClick: () => {
          a("alt-text-start", { source: l }), r();
        },
        children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "alt" })
      }
    )
  ] });
});
function cat({ children: t }) {
  const e = ie(), n = le(
    "imageShape",
    () => {
      const o = e.getOnlySelectedShape();
      return !o || o.type !== "image" ? null : o.id;
    },
    [e]
  ), r = le(
    "showToolbar",
    () => e.isInAny("select.idle", "select.pointing_shape", "select.crop"),
    [e]
  ), s = le(
    "locked",
    () => {
      var o;
      return n ? (o = e.getShape(n)) == null ? void 0 : o.isLocked : !1;
    },
    [e, n]
  );
  return !n || !r || s ? null : /* @__PURE__ */ h.jsx(lat, { imageShapeId: n, children: t }, n);
}
function lat({
  children: t,
  imageShapeId: e
}) {
  const n = ie(), r = Ze(), s = le(
    "editor path",
    () => n.isInAny(
      "select.crop.cropping",
      "select.crop.pointing_crop_handle",
      "select.crop.translating_crop"
    ),
    [n]
  ), o = le("camera", () => n.getCamera(), [n]), i = le("editor path", () => n.isIn("select.crop."), [n]), a = fe(), c = re(() => {
    n.setCroppingShape(null), n.setCurrentTool("select.idle");
  }, [n]), [l, d] = he(!1), u = re(() => d(!0), []), f = re(
    () => n.setCurrentTool("select.crop.idle"),
    [n]
  ), p = re(() => d(!1), []);
  me(() => {
    a.current = void 0;
  }, [o]);
  const g = re(() => {
    if (i && a.current)
      return a.current;
    const y = n.getSelectionScreenBounds();
    if (!y) return;
    const m = new _e(y.x, y.y, y.width, 0);
    return a.current = m, m;
  }, [n, i]);
  return s ? (a.current = void 0, null) : /* @__PURE__ */ h.jsx(
    E4,
    {
      className: "tlui-image__toolbar",
      getSelectionBounds: g,
      label: r("tool.image-toolbar-title"),
      children: t || (l ? /* @__PURE__ */ h.jsx(fpe, { shapeId: e, onClose: p, source: "image-toolbar" }) : /* @__PURE__ */ h.jsx(
        aat,
        {
          imageShapeId: e,
          isManipulating: i,
          onEditAltTextStart: u,
          onManipulatingStart: f,
          onManipulatingEnd: c
        }
      ))
    }
  );
}
function dat({
  textEditor: t,
  onEditLinkStart: e
}) {
  const n = xr(), r = Ze(), s = "rich-text-menu", [o, i] = he(0);
  return me(
    function() {
      function l() {
        i((d) => d + 1);
      }
      t.on("update", l), t.on("selectionUpdate", l);
    },
    [t]
  ), me(() => {
    function c(l) {
      e && ms(l) && l.shiftKey && l.key === "k" && (l.preventDefault(), e());
    }
    return document.addEventListener("keydown", c), () => {
      document.removeEventListener("keydown", c);
    };
  }, [e]), Ke(() => {
    function c(l, d) {
      n("rich-text", { operation: l, source: s }), t.chain().focus()[d]().run();
    }
    return [
      // { name: 'heading', attrs: { level: 3 }, onSelect() { textEditor.chain().focus().toggleHeading({ level: 3}).run() }},
      {
        name: "bold",
        onSelect() {
          c("bold", "toggleBold");
        }
      },
      {
        name: "italic",
        onSelect() {
          c("bold", "toggleItalic");
        }
      },
      // { name: 'underline', onSelect() { handleOp('underline', 'toggleUnderline') }},
      // { name: 'strike', onSelect() { handleOp('strike', 'toggleStrike')  }},
      {
        name: "code",
        onSelect() {
          c("bold", "toggleCode");
        }
      },
      e ? {
        name: "link",
        onSelect() {
          e();
        }
      } : void 0,
      // ? is this really optional?
      {
        name: "bulletList",
        onSelect() {
          c("bulletList", "toggleBulletList");
        }
      },
      {
        name: "highlight",
        onSelect() {
          c("bulletList", "toggleHighlight");
        }
      }
    ].filter(Boolean);
  }, [t, n, e]).map(({ name: c, attrs: l, onSelect: d }) => {
    const u = t.isActive(c, l);
    return /* @__PURE__ */ h.jsx(
      Ds,
      {
        title: r(`tool.rich-text-${c}`),
        "data-testid": `rich-text.${c}`,
        type: "icon",
        isActive: u,
        onPointerDown: xt,
        onClick: d,
        role: "option",
        "aria-pressed": u,
        children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: c })
      },
      c
    );
  });
}
function uat({ textEditor: t, value: e, onClose: n }) {
  const r = ie(), [s, o] = he(e), i = Ze(), a = fe(null), c = xr(), l = "rich-text-menu", d = s.startsWith("http") ? s : `https://${s}`, u = (m) => o(m), f = (m) => {
    c("rich-text", { operation: "link-edit", source: l }), !m.startsWith("http://") && !m.startsWith("https://") && (m = `https://${m}`), t.commands.setLink({ href: m }), r.getInstanceState().isCoarsePointer ? t.commands.blur() : t.commands.focus(), n();
  }, p = () => {
    c("rich-text", { operation: "link-visit", source: l }), window.open(d, "_blank", "noopener, noreferrer"), n();
  }, g = () => {
    c("rich-text", { operation: "link-remove", source: l }), t.chain().unsetLink().focus().run(), n();
  }, y = () => n();
  return me(() => {
    var m;
    (m = a.current) == null || m.focus();
  }, [s]), me(() => {
    o(e);
  }, [e]), /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(
      mv,
      {
        ref: a,
        "data-testid": "rich-text.link-input",
        className: "tlui-rich-text__toolbar-link-input",
        value: s,
        onValueChange: u,
        onComplete: f,
        onCancel: y,
        placeholder: "example.com"
      }
    ),
    /* @__PURE__ */ h.jsx(
      yt,
      {
        className: "tlui-rich-text__toolbar-link-visit",
        title: i("tool.rich-text-link-visit"),
        type: "icon",
        onPointerDown: xt,
        onClick: p,
        disabled: !s,
        children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "external-link" })
      }
    ),
    /* @__PURE__ */ h.jsx(
      yt,
      {
        className: "tlui-rich-text__toolbar-link-remove",
        title: i("tool.rich-text-link-remove"),
        "data-testid": "rich-text.link-remove",
        type: "icon",
        onPointerDown: xt,
        onClick: g,
        children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "trash" })
      }
    )
  ] });
}
const fat = Kr(function({
  children: e
}) {
  const n = ie(), r = le("textEditor", () => n.getRichTextEditor(), [n]);
  return n.getInstanceState().isCoarsePointer || !r ? null : /* @__PURE__ */ h.jsx(hat, { textEditor: r, children: e });
});
function hat({
  textEditor: t,
  children: e
}) {
  const { isEditingLink: n, onEditLinkStart: r, onEditLinkClose: s } = pat(t), [o, i] = he(null), a = fe(), c = gat(t), l = Ze(), d = re(() => {
    if (n)
      return a.current;
    const u = window.getSelection();
    if (!o || !u || u.rangeCount === 0 || u.isCollapsed)
      return;
    const f = [];
    for (let g = 0; g < u.rangeCount; g++) {
      const y = u.getRangeAt(g);
      f.push(upe(y.getBoundingClientRect()));
    }
    const p = _e.Common(f);
    return a.current = p, p;
  }, [o, n]);
  return me(() => {
    const u = ({ editor: f }) => i(f.state.selection);
    return t.on("selectionUpdate", u), u({ editor: t }), () => {
      t.off("selectionUpdate", u);
    };
  }, [t]), /* @__PURE__ */ h.jsx(
    E4,
    {
      className: "tlui-rich-text__toolbar",
      getSelectionBounds: d,
      isMousingDown: c,
      changeOnlyWhenYChanges: !0,
      label: l("tool.rich-text-toolbar-title"),
      children: e || (n ? /* @__PURE__ */ h.jsx(
        uat,
        {
          textEditor: t,
          value: t.isActive("link") ? t.getAttributes("link").href : "",
          onClose: s
        }
      ) : /* @__PURE__ */ h.jsx(dat, { textEditor: t, onEditLinkStart: r }))
    }
  );
}
function pat(t) {
  const [e, n] = he(!1);
  me(() => {
    if (!t) {
      n(!1);
      return;
    }
    const i = () => {
      const a = t.isActive("link");
      n(a);
    };
    return t.view.dom.addEventListener("click", i), () => {
      t.view.dom.removeEventListener("click", i);
    };
  }, [t, e]), me(() => {
    if (t && t.isActive("link"))
      try {
        const { from: i, to: a } = dk(
          t.state.doc.resolve(t.state.selection.from),
          t.schema.marks.link
        );
        t.state.selection.empty && t.commands.setTextSelection({ from: i, to: a });
      } catch {
      }
  }, [t, e]);
  const r = re(() => {
    n(!0);
  }, []), s = re(() => {
    n(!1);
  }, []), o = re(() => {
    if (n(!1), !t) return;
    const i = t.state.selection.from;
    t.commands.setTextSelection({ from: i, to: i });
  }, [t]);
  return { isEditingLink: e, onEditLinkStart: r, onEditLinkClose: o, onEditLinkCancel: s };
}
function gat(t) {
  const [e, n] = he(!1);
  return me(() => {
    if (!t) return;
    const r = vI(({ isPointing: c }) => {
      n(c);
    }, 16), s = () => r({ isPointing: !0 }), o = () => r({ isPointing: !1 }), i = ["touchstart", "pointerdown", "mousedown"], a = ["touchend", "pointerup", "mouseup"];
    return i.forEach((c) => {
      t.view.dom.addEventListener(c, s);
    }), a.forEach((c) => {
      document.body.addEventListener(c, o);
    }), () => {
      i.forEach((c) => {
        t.view.dom.removeEventListener(c, s);
      }), a.forEach((c) => {
        document.body.removeEventListener(c, o);
      });
    };
  }, [t]), e;
}
function mat() {
  const t = ie(), e = Ze(), n = lpe(), r = n == null ? void 0 : n.get(di), s = mu({ isDarkMode: t.user.getIsDarkMode() }), o = ((r == null ? void 0 : r.type) === "shared" ? s[r.value] : s.black).solid, i = le(
    "disable style panel",
    () => t.isInAny("hand", "zoom", "eraser", "laser"),
    [t]
  ), a = re(
    (l) => {
      l || t.updateInstanceState({ isChangingStyle: !1 });
    },
    [t]
  ), { StylePanel: c } = uh();
  return c ? /* @__PURE__ */ h.jsxs(Bp, { id: "mobile style menu", onOpenChange: a, children: [
    /* @__PURE__ */ h.jsx(zp, { children: /* @__PURE__ */ h.jsx(
      yt,
      {
        type: "tool",
        "data-testid": "mobile-styles.button",
        style: {
          color: i ? "var(--color-muted-1)" : o
        },
        title: e("style-panel.title"),
        disabled: i,
        children: /* @__PURE__ */ h.jsx(
          gt,
          {
            icon: i ? "blob" : (r == null ? void 0 : r.type) === "mixed" ? "mixed" : "blob"
          }
        )
      }
    ) }),
    /* @__PURE__ */ h.jsx(Up, { side: "top", align: "end", children: c && /* @__PURE__ */ h.jsx(c, { isMobile: !0 }) })
  ] }) : null;
}
function hpe() {
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(vat, {}),
    /* @__PURE__ */ h.jsx(bat, {}),
    /* @__PURE__ */ h.jsx(xat, {}),
    /* @__PURE__ */ h.jsx(wat, {}),
    /* @__PURE__ */ h.jsx(Sat, {}),
    /* @__PURE__ */ h.jsx(Cat, {}),
    /* @__PURE__ */ h.jsx(_at, {}),
    /* @__PURE__ */ h.jsx(Eat, {}),
    /* @__PURE__ */ h.jsx(Tat, {}),
    /* @__PURE__ */ h.jsx(Pat, {}),
    /* @__PURE__ */ h.jsx(kat, {}),
    /* @__PURE__ */ h.jsx(Iat, {}),
    /* @__PURE__ */ h.jsx(Oat, {}),
    /* @__PURE__ */ h.jsx(jat, {}),
    /* @__PURE__ */ h.jsx(Aat, {}),
    /* @__PURE__ */ h.jsx(Nat, {}),
    /* @__PURE__ */ h.jsx(Dat, {}),
    /* @__PURE__ */ h.jsx(Mat, {}),
    /* @__PURE__ */ h.jsx(Rat, {}),
    /* @__PURE__ */ h.jsx($at, {}),
    /* @__PURE__ */ h.jsx(Lat, {}),
    /* @__PURE__ */ h.jsx(Fat, {}),
    /* @__PURE__ */ h.jsx(Bat, {}),
    /* @__PURE__ */ h.jsx(zat, {}),
    /* @__PURE__ */ h.jsx(Uat, {}),
    /* @__PURE__ */ h.jsx(Hat, {}),
    /* @__PURE__ */ h.jsx(Wat, {}),
    /* @__PURE__ */ h.jsx(Vat, {})
  ] });
}
function yat(t) {
  var r;
  const e = ie(), n = (r = t == null ? void 0 : t.meta) == null ? void 0 : r.geo;
  return le(
    "is tool selected",
    () => {
      if (!t) return !1;
      const s = e.getCurrentToolId();
      return s === "geo" ? n === e.getSharedStyles().getAsKnownValue(Hc) : s === t.id;
    },
    [e, t == null ? void 0 : t.id, n]
  );
}
function Un({ tool: t }) {
  const e = L5(), n = yat(e[t]);
  return /* @__PURE__ */ h.jsx(wi, { toolId: t, isSelected: n });
}
function vat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "select" });
}
function bat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "hand" });
}
function xat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "draw" });
}
function wat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "eraser" });
}
function Sat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "arrow" });
}
function Cat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "text" });
}
function _at() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "note" });
}
function Eat() {
  return /* @__PURE__ */ h.jsx(wi, { toolId: "asset" });
}
function Tat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "rectangle" });
}
function Pat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "ellipse" });
}
function Iat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "diamond" });
}
function kat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "triangle" });
}
function Aat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "rhombus" });
}
function Mat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "heart" });
}
function Oat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "hexagon" });
}
function Dat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "cloud" });
}
function Nat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "star" });
}
function jat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "oval" });
}
function Rat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "x-box" });
}
function $at() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "check-box" });
}
function Lat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "arrow-left" });
}
function Fat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "arrow-up" });
}
function Bat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "arrow-down" });
}
function zat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "arrow-right" });
}
function Uat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "line" });
}
function Hat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "highlight" });
}
function Vat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "frame" });
}
function Wat() {
  return /* @__PURE__ */ h.jsx(Un, { tool: "laser" });
}
const r2 = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function s2(t, e, n, r) {
  t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on".concat(e), n);
}
function hb(t, e, n, r) {
  t.removeEventListener ? t.removeEventListener(e, n, r) : t.detachEvent && t.detachEvent("on".concat(e), n);
}
function ppe(t, e) {
  const n = e.slice(0, e.length - 1);
  for (let r = 0; r < n.length; r++) n[r] = t[n[r].toLowerCase()];
  return n;
}
function gpe(t) {
  typeof t != "string" && (t = ""), t = t.replace(/\s/g, "");
  const e = t.split(",");
  let n = e.lastIndexOf("");
  for (; n >= 0; )
    e[n - 1] += ",", e.splice(n, 1), n = e.lastIndexOf("");
  return e;
}
function Kat(t, e) {
  const n = t.length >= e.length ? t : e, r = t.length >= e.length ? e : t;
  let s = !0;
  for (let o = 0; o < n.length; o++)
    r.indexOf(n[o]) === -1 && (s = !1);
  return s;
}
const jw = {
  backspace: 8,
  "": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  /// https://w3c.github.io/uievents/#events-keyboard-key-location
  arrowup: 38,
  arrowdown: 40,
  arrowleft: 37,
  arrowright: 39,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": r2 ? 173 : 189,
  "=": r2 ? 61 : 187,
  ";": r2 ? 59 : 186,
  "'": 222,
  "{": 219,
  "}": 221,
  "[": 219,
  "]": 221,
  "\\": 220
}, Qc = {
  // shiftKey
  "": 16,
  shift: 16,
  // altKey
  "": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "": 91,
  cmd: 91,
  meta: 91,
  command: 91
}, Jb = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, Zs = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, br = {};
for (let t = 1; t < 20; t++)
  jw["f".concat(t)] = 111 + t;
let or = [], jx = null, mpe = "all";
const $d = /* @__PURE__ */ new Map(), vv = (t) => jw[t.toLowerCase()] || Qc[t.toLowerCase()] || t.toUpperCase().charCodeAt(0), Gat = (t) => Object.keys(jw).find((e) => jw[e] === t), Yat = (t) => Object.keys(Qc).find((e) => Qc[e] === t);
function ype(t) {
  mpe = t || "all";
}
function Rw() {
  return mpe || "all";
}
function qat() {
  return or.slice(0);
}
function Xat() {
  return or.map((t) => Gat(t) || Yat(t) || String.fromCharCode(t));
}
function Zat() {
  const t = [];
  return Object.keys(br).forEach((e) => {
    br[e].forEach((n) => {
      let {
        key: r,
        scope: s,
        mods: o,
        shortcut: i
      } = n;
      t.push({
        scope: s,
        shortcut: i,
        mods: o,
        keys: r.split("+").map((a) => vv(a))
      });
    });
  }), t;
}
function Qat(t) {
  const e = t.target || t.srcElement, {
    tagName: n
  } = e;
  let r = !0;
  const s = n === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(e.type);
  return (e.isContentEditable || (s || n === "TEXTAREA" || n === "SELECT") && !e.readOnly) && (r = !1), r;
}
function Jat(t) {
  return typeof t == "string" && (t = vv(t)), or.indexOf(t) !== -1;
}
function ect(t, e) {
  let n, r;
  t || (t = Rw());
  for (const s in br)
    if (Object.prototype.hasOwnProperty.call(br, s))
      for (n = br[s], r = 0; r < n.length; )
        n[r].scope === t ? n.splice(r, 1).forEach((i) => {
          let {
            element: a
          } = i;
          return T4(a);
        }) : r++;
  Rw() === t && ype(e || "all");
}
function tct(t) {
  let e = t.keyCode || t.which || t.charCode;
  t.key && t.key.toLowerCase() === "capslock" && (e = vv(t.key));
  const n = or.indexOf(e);
  if (n >= 0 && or.splice(n, 1), t.key && t.key.toLowerCase() === "meta" && or.splice(0, or.length), (e === 93 || e === 224) && (e = 91), e in Zs) {
    Zs[e] = !1;
    for (const r in Qc) Qc[r] === e && (tc[r] = !1);
  }
}
function vpe(t) {
  if (typeof t > "u")
    Object.keys(br).forEach((s) => {
      Array.isArray(br[s]) && br[s].forEach((o) => dC(o)), delete br[s];
    }), T4(null);
  else if (Array.isArray(t))
    t.forEach((s) => {
      s.key && dC(s);
    });
  else if (typeof t == "object")
    t.key && dC(t);
  else if (typeof t == "string") {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
      n[r - 1] = arguments[r];
    let [s, o] = n;
    typeof s == "function" && (o = s, s = ""), dC({
      key: t,
      scope: s,
      method: o,
      splitKey: "+"
    });
  }
}
const dC = (t) => {
  let {
    key: e,
    scope: n,
    method: r,
    splitKey: s = "+"
  } = t;
  gpe(e).forEach((i) => {
    const a = i.split(s), c = a.length, l = a[c - 1], d = l === "*" ? "*" : vv(l);
    if (!br[d]) return;
    n || (n = Rw());
    const u = c > 1 ? ppe(Qc, a) : [], f = [];
    br[d] = br[d].filter((p) => {
      const y = (r ? p.method === r : !0) && p.scope === n && Kat(p.mods, u);
      return y && f.push(p.element), !y;
    }), f.forEach((p) => T4(p));
  });
};
function O7(t, e, n, r) {
  if (e.element !== r)
    return;
  let s;
  if (e.scope === n || e.scope === "all") {
    s = e.mods.length > 0;
    for (const o in Zs)
      Object.prototype.hasOwnProperty.call(Zs, o) && (!Zs[o] && e.mods.indexOf(+o) > -1 || Zs[o] && e.mods.indexOf(+o) === -1) && (s = !1);
    (e.mods.length === 0 && !Zs[16] && !Zs[18] && !Zs[17] && !Zs[91] || s || e.shortcut === "*") && (e.keys = [], e.keys = e.keys.concat(or), e.method(t, e) === !1 && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0)));
  }
}
function D7(t, e) {
  const n = br["*"];
  let r = t.keyCode || t.which || t.charCode;
  if (t.key && t.key.toLowerCase() === "capslock" || !tc.filter.call(this, t)) return;
  if ((r === 93 || r === 224) && (r = 91), or.indexOf(r) === -1 && r !== 229 && or.push(r), ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((a) => {
    const c = Jb[a];
    t[a] && or.indexOf(c) === -1 ? or.push(c) : !t[a] && or.indexOf(c) > -1 ? or.splice(or.indexOf(c), 1) : a === "metaKey" && t[a] && (or = or.filter((l) => l in Jb || l === r));
  }), r in Zs) {
    Zs[r] = !0;
    for (const a in Qc)
      if (Object.prototype.hasOwnProperty.call(Qc, a)) {
        const c = Jb[Qc[a]];
        tc[a] = t[c];
      }
    if (!n) return;
  }
  for (const a in Zs)
    Object.prototype.hasOwnProperty.call(Zs, a) && (Zs[a] = t[Jb[a]]);
  t.getModifierState && !(t.altKey && !t.ctrlKey) && t.getModifierState("AltGraph") && (or.indexOf(17) === -1 && or.push(17), or.indexOf(18) === -1 && or.push(18), Zs[17] = !0, Zs[18] = !0);
  const s = Rw();
  if (n)
    for (let a = 0; a < n.length; a++)
      n[a].scope === s && (t.type === "keydown" && n[a].keydown || t.type === "keyup" && n[a].keyup) && O7(t, n[a], s, e);
  if (!(r in br)) return;
  const o = br[r], i = o.length;
  for (let a = 0; a < i; a++)
    if ((t.type === "keydown" && o[a].keydown || t.type === "keyup" && o[a].keyup) && o[a].key) {
      const c = o[a], {
        splitKey: l
      } = c, d = c.key.split(l), u = [];
      for (let f = 0; f < d.length; f++)
        u.push(vv(d[f]));
      u.sort().join("") === or.sort().join("") && O7(t, c, s, e);
    }
}
function tc(t, e, n) {
  or = [];
  const r = gpe(t);
  let s = [], o = "all", i = document, a = 0, c = !1, l = !0, d = "+", u = !1, f = !1;
  for (n === void 0 && typeof e == "function" && (n = e), Object.prototype.toString.call(e) === "[object Object]" && (e.scope && (o = e.scope), e.element && (i = e.element), e.keyup && (c = e.keyup), e.keydown !== void 0 && (l = e.keydown), e.capture !== void 0 && (u = e.capture), typeof e.splitKey == "string" && (d = e.splitKey), e.single === !0 && (f = !0)), typeof e == "string" && (o = e), f && vpe(t, o); a < r.length; a++)
    t = r[a].split(d), s = [], t.length > 1 && (s = ppe(Qc, t)), t = t[t.length - 1], t = t === "*" ? "*" : vv(t), t in br || (br[t] = []), br[t].push({
      keyup: c,
      keydown: l,
      scope: o,
      mods: s,
      shortcut: r[a],
      method: n,
      key: r[a],
      splitKey: d,
      element: i
    });
  if (typeof i < "u" && window) {
    if (!$d.has(i)) {
      const p = function() {
        let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return D7(y, i);
      }, g = function() {
        let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        D7(y, i), tct(y);
      };
      $d.set(i, {
        keydownListener: p,
        keyupListenr: g,
        capture: u
      }), s2(i, "keydown", p, u), s2(i, "keyup", g, u);
    }
    if (!jx) {
      const p = () => {
        or = [];
      };
      jx = {
        listener: p,
        capture: u
      }, s2(window, "focus", p, u);
    }
  }
}
function nct(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(br).forEach((n) => {
    br[n].filter((s) => s.scope === e && s.shortcut === t).forEach((s) => {
      s && s.method && s.method();
    });
  });
}
function T4(t) {
  const e = Object.values(br).flat();
  if (e.findIndex((r) => {
    let {
      element: s
    } = r;
    return s === t;
  }) < 0) {
    const {
      keydownListener: r,
      keyupListenr: s,
      capture: o
    } = $d.get(t) || {};
    r && s && (hb(t, "keyup", s, o), hb(t, "keydown", r, o), $d.delete(t));
  }
  if ((e.length <= 0 || $d.size <= 0) && (Object.keys($d).forEach((s) => {
    const {
      keydownListener: o,
      keyupListenr: i,
      capture: a
    } = $d.get(s) || {};
    o && i && (hb(s, "keyup", i, a), hb(s, "keydown", o, a), $d.delete(s));
  }), $d.clear(), Object.keys(br).forEach((s) => delete br[s]), jx)) {
    const {
      listener: s,
      capture: o
    } = jx;
    hb(window, "focus", s, o), jx = null;
  }
}
const o2 = {
  getPressedKeyString: Xat,
  setScope: ype,
  getScope: Rw,
  deleteScope: ect,
  getPressedKeyCodes: qat,
  getAllKeyCodes: Zat,
  isPressed: Jat,
  filter: Qat,
  trigger: nct,
  unbind: vpe,
  keyMap: jw,
  modifier: Qc,
  modifierMap: Jb
};
for (const t in o2)
  Object.prototype.hasOwnProperty.call(o2, t) && (tc[t] = o2[t]);
if (typeof window < "u") {
  const t = window.hotkeys;
  tc.noConflict = (e) => (e && window.hotkeys === tc && (window.hotkeys = t), tc), window.hotkeys = tc;
}
const N7 = [
  // we set these in useNativeClipboardEvents instead
  "copy",
  "cut",
  "paste",
  // There's also an upload asset action, so we don't want to set the kbd twice
  "asset"
];
function rct() {
  const t = ie(), e = Da(), n = xu(), r = L5(), s = le("is focused", () => t.getInstanceState().isFocused, [t]);
  me(() => {
    if (!s) return;
    const o = new Array(), i = t.getContainer(), a = (l, d) => {
      tc(l, { element: i.ownerDocument.body }, d), o.push(() => {
        tc.unbind(l, d);
      });
    }, c = (l, d) => {
      tc(
        l,
        { element: i.ownerDocument.body, keyup: !0, keydown: !1 },
        d
      ), o.push(() => {
        tc.unbind(l, d);
      });
    };
    for (const l of Object.values(n))
      l.kbd && (e && !l.readonlyOk || N7.includes(l.id) || a(j7(l.kbd), (d) => {
        ex(t) && !l.isRequiredA11yAction || (xt(d), l.onSelect("kbd"));
      }));
    for (const l of Object.values(r))
      !l.kbd || !l.readonlyOk && t.getIsReadonly() || N7.includes(l.id) || a(j7(l.kbd), (d) => {
        ex(t) || (xt(d), l.onSelect("kbd"));
      });
    return a(",", (l) => {
      if (ex(t) || t.inputs.keys.has("Comma")) return;
      xt(l), t.focus(), t.inputs.keys.add("Comma");
      const { x: d, y: u, z: f } = t.inputs.currentPagePoint, p = t.pageToScreen({ x: d, y: u }), g = {
        type: "pointer",
        name: "pointer_down",
        point: { x: p.x, y: p.y, z: f },
        shiftKey: l.shiftKey,
        altKey: l.altKey,
        ctrlKey: l.metaKey || l.ctrlKey,
        metaKey: l.metaKey,
        accelKey: ms(l),
        pointerId: 0,
        button: 0,
        isPen: t.getInstanceState().isPenMode,
        target: "canvas"
      };
      t.dispatch(g);
    }), c(",", (l) => {
      if (ex(t) || !t.inputs.keys.has("Comma")) return;
      t.inputs.keys.delete("Comma");
      const { x: d, y: u, z: f } = t.inputs.currentScreenPoint, p = {
        type: "pointer",
        name: "pointer_up",
        point: { x: d, y: u, z: f },
        shiftKey: l.shiftKey,
        altKey: l.altKey,
        ctrlKey: l.metaKey || l.ctrlKey,
        metaKey: l.metaKey,
        accelKey: ms(l),
        pointerId: 0,
        button: 0,
        isPen: t.getInstanceState().isPenMode,
        target: "canvas"
      };
      t.dispatch(p);
    }), () => {
      o.forEach((l) => l());
    };
  }, [n, r, e, t, s]);
}
function ex(t) {
  return t.menus.hasAnyOpenMenus() || t.getEditingShapeId() !== null || t.getCrashingError() || !t.user.getAreKeyboardShortcutsEnabled();
}
function j7(t) {
  return sct(t).map((e) => {
    let n = "";
    const r = e.includes("!"), s = e.includes("?"), o = e.includes("$"), i = e.replace(/[!?$]/g, "");
    return r && s && o ? n = `cmd+shift+alt+${i},ctrl+shift+alt+${i}` : r && o ? n = `cmd+shift+${i},ctrl+shift+${i}` : s && o ? n = `cmd+alt+${i},ctrl+alt+${i}` : s && r ? n = `shift+alt+${i}` : r ? n = `shift+${i}` : s ? n = `alt+${i}` : o ? n = `cmd+${i},ctrl+${i}` : n = i, n;
  }).join(",");
}
function sct(t) {
  typeof t != "string" && (t = ""), t = t.replace(/\s/g, "");
  const e = t.split(",");
  let n = e.lastIndexOf("");
  for (; n >= 0; )
    e[n - 1] += ",", e.splice(n, 1), n = e.lastIndexOf("");
  return e;
}
const oct = zn(!1), ict = {
  1: 0,
  2: 1,
  3: 2,
  4: 3,
  5: 4,
  6: 5,
  7: 6,
  8: 7,
  9: 8,
  0: 9
};
function act({ children: t }) {
  const e = ie(), n = gg(), r = Uo(), s = Ze(), o = fe([]), [i, a] = he(!1), c = Math.min(8, 5 + r), [l, d] = he(0), u = fe(null), [f, p] = he(null), g = Ke(() => {
    const v = f ? `:not([data-value="${f}"])` : "";
    return `
			#${n}_main > *:nth-child(n + ${c + (f ? 1 : 2)})${v} {
				display: none;
			}
			#${n}_more > *:nth-child(-n + ${c}) {
				display: none;
			}
			#${n}_more > *:nth-child(-n + ${c + 4}) {
				margin-top: 0;
			}
        `;
  }, [f, n, c]), y = kl(() => {
    var w;
    if (!u.current) return;
    const v = Array.from(u.current.children);
    d(v.length), v.findIndex(
      (S) => S.getAttribute("data-value") === f
    ) <= c && p(null);
    const x = Array.from(u.current.children).findIndex(
      (S) => S.getAttribute("aria-pressed") === "true"
    );
    x !== -1 && (x >= c && p(v[x].getAttribute("data-value")), o.current = Array.from(((w = u.current) == null ? void 0 : w.children) ?? []).filter(
      (S) => !(S instanceof HTMLElement) || S.tagName.toLowerCase() !== "button" ? !1 : !!(S.offsetWidth || S.offsetHeight)
    ));
  });
  un(() => {
    y();
  }), un(() => {
    if (!u.current) return;
    const v = new MutationObserver(y);
    return v.observe(u.current, {
      childList: !0,
      subtree: !0,
      attributeFilter: ["data-value", "aria-pressed"]
    }), () => {
      v.disconnect();
    };
  }, [y]), me(() => {
    if (!e.options.enableToolbarKeyboardShortcuts) return;
    function v(b) {
      var w;
      if (ex(e) || one(
        !0
        /* allow buttons */
      ) || b.ctrlKey || b.metaKey || b.altKey || b.shiftKey) return;
      const x = ict[b.key];
      typeof x == "number" && (xt(b), (w = o.current[x]) == null || w.click());
    }
    return document.addEventListener("keydown", v), () => {
      document.removeEventListener("keydown", v);
    };
  }, [e]);
  const m = "toolbar overflow";
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx("style", { nonce: e.options.nonce, children: g }),
    /* @__PURE__ */ h.jsxs(
      zr,
      {
        className: Je("tlui-toolbar__tools", {
          "tlui-toolbar__tools__mobile": r < Ir.TABLET_SM
        }),
        label: s("tool-panel.title"),
        children: [
          /* @__PURE__ */ h.jsx("div", { id: `${n}_main`, ref: u, className: "tlui-toolbar__tools__list", children: /* @__PURE__ */ h.jsx(pi, { type: "toolbar", sourceId: "toolbar", children: t }) }),
          l > c + 1 && /* @__PURE__ */ h.jsx(oct.Provider, { value: !0, children: /* @__PURE__ */ h.jsxs(Bp, { id: m, open: i, onOpenChange: a, children: [
            /* @__PURE__ */ h.jsx(zp, { children: /* @__PURE__ */ h.jsx(
              Ds,
              {
                title: s("tool-panel.more"),
                type: "tool",
                className: "tlui-toolbar__overflow",
                "data-testid": "tools.more-button",
                children: /* @__PURE__ */ h.jsx(gt, { icon: "chevron-up" })
              }
            ) }),
            /* @__PURE__ */ h.jsx(Up, { side: "top", align: "center", children: /* @__PURE__ */ h.jsx(
              zr,
              {
                className: "tlui-buttons__grid",
                "data-testid": "tools.more-content",
                label: s("tool-panel.more"),
                id: `${n}_more`,
                onClick: () => {
                  ni.deleteOpenMenu(m, e.contextId), a(!1);
                },
                children: /* @__PURE__ */ h.jsx(pi, { type: "toolbar-overflow", sourceId: "toolbar", children: t })
              }
            ) })
          ] }) })
        ]
      }
    )
  ] });
}
function cct({ activeToolId: t }) {
  const e = ie(), n = Uo(), r = Ze(), s = le("is tool locked", () => e.getInstanceState().isToolLocked, [
    e
  ]), o = le("current tool", () => e.getCurrentTool(), [e]);
  return !t || !o.isLockable ? null : /* @__PURE__ */ h.jsx(
    yt,
    {
      type: "normal",
      title: r("action.toggle-tool-lock"),
      "data-testid": "tool-lock",
      className: Je("tlui-toolbar__lock-button", {
        "tlui-toolbar__lock-button__mobile": n < Ir.TABLET_SM
      }),
      onClick: () => e.updateInstanceState({ isToolLocked: !s }),
      children: /* @__PURE__ */ h.jsx(gt, { icon: s ? "lock" : "unlock", small: !0 })
    }
  );
}
const bpe = it(function({ children: e }) {
  const n = ie(), r = Ze(), s = Uo(), o = Da(), i = le("current tool id", () => n.getCurrentToolId(), [n]), a = fe(null);
  yu(a);
  const { ActionsMenu: c, QuickActions: l } = uh(), d = n.options.actionShortcutsLocation === "menu" ? !1 : n.options.actionShortcutsLocation === "toolbar" ? !0 : s < Ir.TABLET;
  return /* @__PURE__ */ h.jsx("div", { ref: a, className: "tlui-toolbar", children: /* @__PURE__ */ h.jsxs("div", { className: "tlui-toolbar__inner", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "tlui-toolbar__left", children: [
      !o && /* @__PURE__ */ h.jsxs("div", { className: "tlui-toolbar__extras", children: [
        d && /* @__PURE__ */ h.jsxs(
          zr,
          {
            className: "tlui-toolbar__extras__controls tlui-buttons__horizontal",
            label: r("actions-menu.title"),
            children: [
              l && /* @__PURE__ */ h.jsx(l, {}),
              c && /* @__PURE__ */ h.jsx(c, {})
            ]
          }
        ),
        /* @__PURE__ */ h.jsx(cct, { activeToolId: i })
      ] }),
      /* @__PURE__ */ h.jsx(act, { children: e ?? /* @__PURE__ */ h.jsx(hpe, {}) })
    ] }),
    s < Ir.TABLET_SM && !o && /* @__PURE__ */ h.jsx("div", { className: "tlui-toolbar__tools", children: /* @__PURE__ */ h.jsx(mat, {}) })
  ] }) });
}), lct = Kr(function({
  videoShapeId: e,
  onEditAltTextStart: n
}) {
  const r = ie(), s = xr(), o = Ze(), i = "video-toolbar", a = r.getIsReadonly(), c = xu(), l = re(
    () => c["video-replace"].onSelect("video-toolbar"),
    [c]
  ), d = re(
    () => c["download-original"].onSelect("video-toolbar"),
    [c]
  ), u = le(
    "altText",
    () => r.getShape(e).props.altText,
    [r, e]
  );
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    !a && /* @__PURE__ */ h.jsx(yt, { type: "icon", title: o("tool.replace-media"), onClick: l, children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "tool-media" }) }),
    /* @__PURE__ */ h.jsx(
      yt,
      {
        type: "icon",
        title: o("action.download-original"),
        onClick: d,
        children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "download" })
      }
    ),
    (u || !a) && /* @__PURE__ */ h.jsx(
      yt,
      {
        type: "normal",
        isActive: !!u,
        title: o("tool.media-alt-text"),
        onClick: () => {
          s("alt-text-start", { source: i }), n();
        },
        children: /* @__PURE__ */ h.jsx(gt, { small: !0, icon: "alt" })
      }
    )
  ] });
}), dct = Kr(function({
  children: e
}) {
  const n = ie(), r = le(
    "videoShape",
    () => {
      const i = n.getOnlySelectedShape();
      return !i || i.type !== "video" ? null : i.id;
    },
    [n]
  ), s = n.isInAny("select.idle", "select.pointing_shape"), o = le(
    "locked",
    () => {
      var i;
      return r ? (i = n.getShape(r)) == null ? void 0 : i.isLocked : !1;
    },
    [n, r]
  );
  return !r || !s || o ? null : /* @__PURE__ */ h.jsx(uct, { videoShapeId: r, children: e }, r);
});
function uct({
  children: t,
  videoShapeId: e
}) {
  const n = ie(), r = Ze(), [s, o] = he(!1), i = re(() => o(!0), []), a = re(() => o(!1), []), c = re(() => {
    const l = n.getSelectionScreenBounds();
    if (l)
      return new _e(l.x, l.y, l.width, 0);
  }, [n]);
  return /* @__PURE__ */ h.jsx(
    E4,
    {
      className: "tlui-video__toolbar",
      getSelectionBounds: c,
      label: r("tool.video-toolbar-title"),
      children: t || (s ? /* @__PURE__ */ h.jsx(fpe, { shapeId: e, onClose: a, source: "video-toolbar" }) : /* @__PURE__ */ h.jsx(
        lct,
        {
          videoShapeId: e,
          onEditAltTextStart: i
        }
      ))
    }
  );
}
function fct() {
  const t = Ze();
  return /* @__PURE__ */ h.jsxs("div", { className: Je("tlui-offline-indicator"), children: [
    t("status.offline"),
    /* @__PURE__ */ h.jsx(ed, { label: t("status.offline"), icon: "status-offline", small: !0 })
  ] });
}
function hct({
  maxWidth: t = 420,
  ignoreRightWidth: e = 0,
  stylePanelWidth: n = 148,
  marginBetweenZones: r = 12,
  squeezeAmount: s = 52,
  children: o
}) {
  const i = fe(null), a = Uo(), c = re(() => {
    const l = i.current;
    if (!l) return;
    const d = l.parentElement.parentElement, u = d.querySelector(".tlui-layout__top__left"), f = d.querySelector(".tlui-layout__top__right"), p = d.offsetWidth, g = u.offsetWidth, y = f.offsetWidth, m = l.offsetWidth - e;
    let v = (p - m) / 2;
    p % 2 !== 0 && (v -= 0.5);
    const b = g + r, x = l.offsetLeft, w = Math.min(
      p - y - g - 2 * r,
      t
    ), S = Math.max(v, b) - x;
    f.offsetWidth > n && a <= 6 ? l.style.setProperty("max-width", w - s + "px") : l.style.setProperty("max-width", w + "px"), l.style.setProperty("transform", `translate(${S}px, 0px)`);
  }, [a, e, r, t, s, n]);
  return un(() => {
    const l = i.current;
    if (!l) return;
    const d = l.parentElement.parentElement, u = d.querySelector(".tlui-layout__top__left"), f = d.querySelector(".tlui-layout__top__right"), p = new ResizeObserver(c);
    return p.observe(u), p.observe(f), p.observe(d), p.observe(l), c(), () => {
      p.disconnect();
    };
  }, [c]), un(() => {
    c();
  }), /* @__PURE__ */ h.jsx("div", { ref: i, className: "tlui-top-panel__container", children: o });
}
function pct() {
  const t = aZe() === "offline";
  return /* @__PURE__ */ h.jsx(hct, { children: t && /* @__PURE__ */ h.jsx(fct, {}) });
}
function gct() {
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx(be, { actionId: "zoom-in", noClose: !0 }),
    /* @__PURE__ */ h.jsx(be, { actionId: "zoom-out", noClose: !0 }),
    /* @__PURE__ */ h.jsx(Dhe, {}),
    /* @__PURE__ */ h.jsx(Nhe, {}),
    /* @__PURE__ */ h.jsx(jhe, {})
  ] });
}
const mct = it(function({ children: e }) {
  const n = Gr(), [r, s] = vu("zoom menu"), o = e ?? /* @__PURE__ */ h.jsx(gct, {});
  return /* @__PURE__ */ h.jsxs(y5, { dir: "ltr", open: r, onOpenChange: s, modal: !1, children: [
    /* @__PURE__ */ h.jsx(yct, {}),
    /* @__PURE__ */ h.jsx(xk, { container: n, children: /* @__PURE__ */ h.jsx(
      b5,
      {
        className: "tlui-menu",
        side: "top",
        align: "start",
        alignOffset: 0,
        sideOffset: 8,
        collisionPadding: 4,
        children: /* @__PURE__ */ h.jsx(pi, { type: "menu", sourceId: "zoom-menu", children: o })
      }
    ) })
  ] });
}), yct = () => {
  const t = ie(), e = Uo(), n = le("zoom", () => t.getZoomLevel(), [t]), r = Ze(), s = re(() => {
    t.resetZoom(t.getViewportScreenCenter(), {
      animation: { duration: t.options.animationMediumMs }
    });
  }, [t]), o = `${Math.floor(n * 100)}%`;
  return /* @__PURE__ */ h.jsx(
    Ds,
    {
      asChild: !0,
      type: "icon",
      "aria-label": `${r("navigation-zone.zoom")}  ${o}`,
      title: `${r("navigation-zone.zoom")}  ${o}`,
      "data-testid": "minimap.zoom-menu-button",
      className: "tlui-zoom-menu__button",
      onDoubleClick: s,
      children: /* @__PURE__ */ h.jsx(v5, { dir: "ltr", children: e < Ir.MOBILE ? null : /* @__PURE__ */ h.jsx("span", { style: { flexGrow: 0, textAlign: "center" }, children: o }) })
    }
  );
}, xpe = zn(null);
function vct({
  overrides: t = {},
  children: e
}) {
  const n = cv(t), r = Ok();
  return /* @__PURE__ */ h.jsx(
    xpe.Provider,
    {
      value: Ke(
        () => ({
          ContextMenu: Uhe,
          ActionsMenu: dot,
          HelpMenu: null,
          ZoomMenu: mct,
          MainMenu: pit,
          Minimap: _it,
          StylePanel: Qit,
          PageMenu: Iit,
          NavigationPanel: Tit,
          Toolbar: bpe,
          RichTextToolbar: fat,
          ImageToolbar: cat,
          VideoToolbar: dct,
          KeyboardShortcutsDialog: bue,
          QuickActions: Oit,
          HelperButtons: rit,
          DebugPanel: Yot,
          DebugMenu: Got,
          MenuPanel: Qot,
          SharePanel: r ? Fit : null,
          CursorChatBubble: r ? Fot : null,
          TopPanel: r ? pct : null,
          Dialogs: JZe,
          Toasts: rQe,
          A11y: wGe,
          ...n
        }),
        [n, r]
      ),
      children: e
    }
  );
}
function uh() {
  const t = tn(xpe);
  if (!t)
    throw new Error("useTldrawUiComponents must be used within a TldrawUiComponentsProvider");
  return t;
}
const bct = Kr(function({
  overrides: e,
  components: n,
  assetUrls: r,
  onUiEvent: s,
  forceMobile: o,
  mediaMimeTypes: i,
  children: a
}) {
  const c = uo();
  return /* @__PURE__ */ h.jsx(gue.Provider, { value: i, children: /* @__PURE__ */ h.jsx(Gae, { assetUrls: yhe(r), children: /* @__PURE__ */ h.jsx(
    Xae,
    {
      overrides: yue(e),
      locale: (c == null ? void 0 : c.user.getLocale()) ?? Ua.locale,
      children: /* @__PURE__ */ h.jsx(_Ge, { onEvent: s, children: /* @__PURE__ */ h.jsx(yZe, { children: /* @__PURE__ */ h.jsx(mZe, { context: "tla", children: /* @__PURE__ */ h.jsx(mGe, { children: /* @__PURE__ */ h.jsx(iZe, { forceMobile: o, children: /* @__PURE__ */ h.jsx(vct, { overrides: n, children: /* @__PURE__ */ h.jsx(xct, { overrides: e, children: a }) }) }) }) }) }) })
    }
  ) }) });
});
function xct({
  overrides: t,
  children: e
}) {
  const n = HZe(t);
  return /* @__PURE__ */ h.jsx(YZe, { overrides: n.actions, children: /* @__PURE__ */ h.jsx(VZe, { overrides: n.tools, children: e }) });
}
function wct() {
  const t = ie(), { addToast: e } = bu();
  me(() => {
    function n({ name: r, count: s }) {
      e({
        title: "Maximum Shapes Reached",
        description: `You've reached the maximum number of shapes allowed on ${r} (${s}). Please delete some shapes or move to a different page to continue.`,
        severity: "warning"
      });
    }
    return t.addListener("max-shapes", n), () => {
      t.removeListener("max-shapes", n);
    };
  }, [t, e]);
}
const Sct = B.memo(function({
  renderDebugMenuItems: e,
  children: n,
  hideUi: r,
  components: s,
  ...o
}) {
  return /* @__PURE__ */ h.jsx(bct, { ...o, components: s, children: /* @__PURE__ */ h.jsx(Cct, { hideUi: r, renderDebugMenuItems: e, children: n }) });
}), Cct = B.memo(function({
  children: e,
  hideUi: n,
  ...r
}) {
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    e,
    n ? null : /* @__PURE__ */ h.jsx(_ct, { ...r })
  ] });
}), _ct = B.memo(function() {
  const e = ie(), n = Ze(), r = Uo(), s = Da(), o = le("focus", () => e.getInstanceState().isFocusMode, [e]), i = le("debug", () => e.getInstanceState().isDebugMode, [e]), {
    SharePanel: a,
    TopPanel: c,
    MenuPanel: l,
    StylePanel: d,
    Toolbar: u,
    HelpMenu: f,
    NavigationPanel: p,
    HelperButtons: g,
    DebugPanel: y,
    CursorChatBubble: m,
    RichTextToolbar: v,
    ImageToolbar: b,
    VideoToolbar: x,
    Toasts: w,
    Dialogs: S,
    A11y: C
  } = uh();
  rct(), DZe(), wct();
  const _ = fe(!1), E = fe(-1), [M, N] = he(!1);
  UF(
    "update hide toolbar while delayed",
    () => {
      if (!(dn.isIos || dn.isAndroid)) return;
      if (e.getEditingShapeId() === null) {
        _.current && (_.current = !1, clearTimeout(E.current), dn.isAndroid ? E.current = e.timers.setTimeout(() => {
          N(!1);
        }, 150) : N(!1));
        return;
      }
      _.current || (_.current = !0, clearTimeout(E.current), N(!0));
    },
    []
  );
  const { "toggle-focus-mode": O } = xu();
  return /* @__PURE__ */ h.jsxs(
    "div",
    {
      className: Je("tlui-layout", {
        "tlui-layout__mobile": r < Ir.TABLET_SM
      }),
      "data-iseditinganything": M,
      "data-breakpoint": r,
      children: [
        /* @__PURE__ */ h.jsx(xGe, {}),
        o ? /* @__PURE__ */ h.jsx("div", { className: "tlui-layout__top", children: /* @__PURE__ */ h.jsx(
          yt,
          {
            type: "icon",
            className: "tlui-focus-button",
            title: n("focus-mode.toggle-focus-mode"),
            onClick: () => O.onSelect("menu"),
            children: /* @__PURE__ */ h.jsx(gt, { icon: "dot" })
          }
        ) }) : /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
          /* @__PURE__ */ h.jsxs("div", { className: "tlui-layout__top", children: [
            /* @__PURE__ */ h.jsxs("div", { className: "tlui-layout__top__left", children: [
              l && /* @__PURE__ */ h.jsx(l, {}),
              g && /* @__PURE__ */ h.jsx(g, {})
            ] }),
            /* @__PURE__ */ h.jsx("div", { className: "tlui-layout__top__center", children: c && /* @__PURE__ */ h.jsx(c, {}) }),
            /* @__PURE__ */ h.jsxs("div", { className: "tlui-layout__top__right", children: [
              a && /* @__PURE__ */ h.jsx(a, {}),
              d && r >= Ir.TABLET_SM && !s && /* @__PURE__ */ h.jsx(d, {})
            ] })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "tlui-layout__bottom", children: [
            /* @__PURE__ */ h.jsxs("div", { className: "tlui-layout__bottom__main", children: [
              p && /* @__PURE__ */ h.jsx(p, {}),
              u && /* @__PURE__ */ h.jsx(u, {}),
              f && /* @__PURE__ */ h.jsx(f, {})
            ] }),
            i && y && /* @__PURE__ */ h.jsx(y, {}),
            C && /* @__PURE__ */ h.jsx(C, {})
          ] })
        ] }),
        v && /* @__PURE__ */ h.jsx(v, {}),
        b && /* @__PURE__ */ h.jsx(b, {}),
        x && /* @__PURE__ */ h.jsx(x, {}),
        w && /* @__PURE__ */ h.jsx(w, {}),
        S && /* @__PURE__ */ h.jsx(S, {}),
        /* @__PURE__ */ h.jsx(Wst, {}),
        m && /* @__PURE__ */ h.jsx(m, {})
      ]
    }
  );
}), Ect = () => {
  const { Spinner: t } = Ln();
  return /* @__PURE__ */ h.jsx(Voe, { children: t ? /* @__PURE__ */ h.jsx(t, {}) : null });
}, Tct = [...Vst, ...Ptt];
function Pct(t) {
  var D;
  const {
    children: e,
    maxImageDimension: n,
    maxAssetSize: r,
    acceptedImageMimeTypes: s,
    acceptedVideoMimeTypes: o,
    onMount: i,
    components: a = {},
    shapeUtils: c = [],
    bindingUtils: l = [],
    tools: d = [],
    embeds: u,
    textOptions: f,
    ...p
  } = t, g = cv(a), y = Ke(
    () => ({
      Scribble: kV,
      ShapeIndicators: UQe,
      CollaboratorScribble: kV,
      SelectionForeground: FQe,
      Handles: IQe,
      Overlays: OQe,
      Spinner: sR,
      LoadingScreen: Ect,
      ...g
    }),
    [g]
  ), m = Yu(c), v = Ke(
    () => hx("type", m, Dfe),
    [m]
  ), b = Yu(l), x = Ke(
    () => hx("type", b, Tue),
    [b]
  ), w = Yu(d), S = Ke(
    () => hx("id", w, Tct),
    [w]
  ), C = Yu(
    s ?? nv
  ), _ = Yu(
    o ?? bI
  ), E = Ke(() => ({
    addFontsFromNode: Vue,
    ...f,
    tipTapConfig: {
      extensions: mS,
      ...f == null ? void 0 : f.tipTapConfig
    }
  }), [f]), M = Ke(
    () => [...C, ..._],
    [C, _]
  ), N = mhe(p.assetUrls);
  return v.find((k) => k.type === "embed") && u && YT.setEmbedDefinitions(u), // We provide an extra higher layer of asset+translations providers here so that
  // loading UI (which is rendered outside of TldrawUi) may be translated.
  // Ideally we would refactor to hoist all the UI context providers we can up here. Maybe later.
  /* @__PURE__ */ h.jsx(
    Gae,
    { assetUrls: yhe(p.assetUrls), children: /* @__PURE__ */ h.jsx(
      Xae,
      {
        overrides: yue(p.overrides),
        locale: ((D = p.user) == null ? void 0 : D.userPreferences.get().locale) ?? Ua.locale,
        children: /* @__PURE__ */ h.jsx(
          ZUe,
          {
            initialState: "select",
            ...p,
            components: y,
            shapeUtils: v,
            bindingUtils: x,
            tools: S,
            textOptions: E,
            assetUrls: N,
            children: /* @__PURE__ */ h.jsxs(Sct, { ...p, components: y, mediaMimeTypes: M, children: [
              /* @__PURE__ */ h.jsx(
                Ict,
                {
                  maxImageDimension: n,
                  maxAssetSize: r,
                  acceptedImageMimeTypes: C,
                  acceptedVideoMimeTypes: _,
                  onMount: i
                }
              ),
              e
            ] })
          }
        )
      }
    ) }
  );
}
function Ict({
  maxImageDimension: t,
  maxAssetSize: e,
  acceptedImageMimeTypes: n,
  acceptedVideoMimeTypes: r,
  onMount: s
}) {
  const o = ie(), i = bu(), a = Ze(), c = xr();
  Woe(() => {
    const u = [];
    return u.push(pst(o)), o.fonts.requestFonts($et), o.once("edit", () => c("edit", { source: "unknown" })), Qet(o, {
      maxImageDimension: t,
      maxAssetSize: e,
      acceptedImageMimeTypes: n,
      acceptedVideoMimeTypes: r,
      toasts: i,
      msg: a
    }), u.push(o.store.props.onMount(o)), u.push(s == null ? void 0 : s(o)), () => {
      u.forEach((f) => f == null ? void 0 : f());
    };
  });
  const { Canvas: l } = Ln(), { ContextMenu: d } = uh();
  return d ? /* @__PURE__ */ h.jsx(d, {}) : l ? /* @__PURE__ */ h.jsx(l, {}) : null;
}
const kct = {
  tipTapConfig: {
    extensions: mS
  },
  addFontsFromNode: Vue
};
it(function(e) {
  const [n, r] = he(null), [s, o] = he(null), i = Yu(e.shapeUtils ?? []), a = Ke(
    () => hx("type", i, Dfe),
    [i]
  ), c = Yu(e.bindingUtils ?? []), l = Ke(
    () => hx("type", c, Tue),
    [c]
  ), d = JHe({ snapshot: e.snapshot, shapeUtils: a }), {
    pageId: u,
    bounds: f,
    scale: p,
    pixelRatio: g,
    background: y,
    padding: m,
    darkMode: v,
    preserveAspectRatio: b,
    format: x = "svg",
    licenseKey: w,
    assetUrls: S,
    textOptions: C = kct
  } = e, _ = mhe(S);
  return un(() => {
    if (!s || !d) return;
    let E = !1;
    const M = document.createElement("div");
    s.appendChild(M), s.classList.add("tl-container", "tl-theme__light");
    const N = new Le({
      store: d,
      shapeUtils: a,
      bindingUtils: l,
      tools: [],
      getContainer: () => M,
      licenseKey: w,
      fontAssetUrls: _.fonts,
      textOptions: C
    });
    u && N.setCurrentPage(u);
    const O = N.getCurrentPageShapeIds();
    async function D() {
      await N.fonts.loadRequiredFontsForCurrentPage(N.options.maxFontsToLoadBeforeRender);
      const k = await N.toImage([...O], {
        bounds: f,
        scale: p,
        background: y,
        padding: m,
        darkMode: v,
        preserveAspectRatio: b,
        format: x
      });
      if (!k || E) return;
      const A = URL.createObjectURL(k.blob);
      r(A), N.dispose();
    }
    return D(), () => {
      E = !0;
    };
  }, [
    x,
    s,
    d,
    a,
    l,
    u,
    f,
    p,
    y,
    m,
    v,
    b,
    w,
    g,
    _,
    C
  ]), me(() => () => {
    n && URL.revokeObjectURL(n);
  }, [n]), /* @__PURE__ */ h.jsx("div", { ref: o, style: { position: "relative", width: "100%", height: "100%" }, children: n && /* @__PURE__ */ h.jsx(
    "img",
    {
      src: n,
      referrerPolicy: "strict-origin-when-cross-origin",
      style: { width: "100%", height: "100%" }
    }
  ) });
});
it(function({ children: e }) {
  const n = Ze(), r = Uo(), s = fe(null);
  yu(s);
  const o = e ?? /* @__PURE__ */ h.jsx(sit, {});
  return r < Ir.MOBILE ? null : /* @__PURE__ */ h.jsx("div", { ref: s, className: "tlui-help-menu", children: /* @__PURE__ */ h.jsxs(Dk, { id: "help menu", children: [
    /* @__PURE__ */ h.jsx(Nk, { children: /* @__PURE__ */ h.jsx(yt, { type: "help", title: n("help-menu.title"), "data-testid": "help-menu.button", children: /* @__PURE__ */ h.jsx(gt, { icon: "question-mark", small: !0 }) }) }),
    /* @__PURE__ */ h.jsx(jk, { side: "top", align: "end", alignOffset: 0, sideOffset: 8, children: /* @__PURE__ */ h.jsx(pi, { type: "menu", sourceId: "help-menu", children: o }) })
  ] }) });
});
const Act = Gt({
  schemaVersion: Do(1),
  storeVersion: JC,
  recordVersions: IE(
    Et,
    Gt({
      version: JC,
      subTypeVersions: IE(Et, JC).optional(),
      subTypeKey: Et.optional()
    })
  )
}), Mct = Gt({
  schemaVersion: Do(2),
  sequences: IE(Et, JC)
});
Gt({
  tldrawFileFormatVersion: m5e,
  schema: y5e("schemaVersion", {
    1: Act,
    2: Mct
  }),
  records: Ms(
    Gt({
      id: Et,
      typeName: Et
    }).allowUnknownProperties()
  )
});
Xf(
  "tldraw",
  "3.15.5",
  "esm"
);
function Oct(t) {
  const { artifacts: e } = uu();
  return Ke(() => t && e.find((n) => n.id === t) || null, [e, t]);
}
const Dct = {
  notes: yp,
  board: G$,
  diagram: C0,
  canvas: Wq,
  calendar: yp
}, Nct = {
  notes: "hsl(199, 89%, 48%)",
  board: "hsl(142, 76%, 36%)",
  diagram: "hsl(262, 83%, 58%)",
  canvas: "hsl(25, 95%, 53%)",
  calendar: "hsl(0, 84%, 60%)"
};
function jct(t) {
  var e;
  switch (t.type) {
    case "notes": {
      const n = t.data;
      if (!Array.isArray(n)) return null;
      const r = n.slice(0, 2).map((s) => s.content && Array.isArray(s.content) ? s.content.map((o) => o.text || "").join("") : "").filter(Boolean).join(" ");
      return r.slice(0, 60) + (r.length > 60 ? "..." : "");
    }
    case "board": {
      const n = t.data;
      if (!(n != null && n.columns)) return null;
      const r = n.columns.reduce((s, o) => s + o.cards.length, 0);
      return `${n.columns.length} cols  ${r} cards`;
    }
    case "diagram": {
      const n = t.data;
      return `${((e = n == null ? void 0 : n.nodes) == null ? void 0 : e.length) || 0} nodes`;
    }
    case "canvas": {
      const n = t.data;
      return n != null && n.store ? `${Object.keys(n.store).filter((s) => s.startsWith("shape:")).length} shapes` : null;
    }
    default:
      return null;
  }
}
function Rct({ shape: t }) {
  const e = Oct(t.props.artifactId);
  if (!e)
    return /* @__PURE__ */ h.jsxs(
      "div",
      {
        className: "flex items-center gap-2 p-3 bg-destructive/10 border border-destructive/30 rounded-lg text-destructive",
        style: { width: t.props.w, height: t.props.h },
        children: [
          /* @__PURE__ */ h.jsx(Xxe, { className: "h-4 w-4 flex-shrink-0" }),
          /* @__PURE__ */ h.jsxs("span", { className: "text-xs truncate", children: [
            "Missing: ",
            t.props.artifactName
          ] })
        ]
      }
    );
  const n = Dct[e.type], r = Nct[e.type], s = jct(e);
  return /* @__PURE__ */ h.jsxs(
    "div",
    {
      className: "flex items-start gap-2.5 rounded-lg border bg-card p-2.5 h-full cursor-pointer hover:bg-accent/30 transition-colors",
      style: {
        width: t.props.w,
        borderLeftColor: r,
        borderLeftWidth: 3
      },
      title: "Double-click to open, or right-click  Open",
      children: [
        /* @__PURE__ */ h.jsx(
          "div",
          {
            className: "rounded p-1.5 flex-shrink-0",
            style: { backgroundColor: `${r}20` },
            children: /* @__PURE__ */ h.jsx(n, { className: "h-4 w-4", style: { color: r } })
          }
        ),
        /* @__PURE__ */ h.jsxs("div", { className: "flex-1 min-w-0 overflow-hidden", children: [
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ h.jsx("span", { className: "font-medium text-sm truncate", children: e.name }),
            /* @__PURE__ */ h.jsx(ewe, { className: "h-3 w-3 text-muted-foreground flex-shrink-0" })
          ] }),
          s && /* @__PURE__ */ h.jsx("p", { className: "text-xs text-muted-foreground mt-0.5 truncate", children: s }),
          /* @__PURE__ */ h.jsx("p", { className: "text-[10px] text-muted-foreground/60 mt-0.5 capitalize", children: e.type })
        ] })
      ]
    }
  );
}
function wpe(t) {
  nu().getArtifact(t).then((e) => {
    e && window.location.assign(`/${e.type}/${e.id}`);
  });
}
class LR extends sc {
  constructor() {
    super(...arguments);
    P(this, "canResize", () => !0);
    P(this, "isAspectRatioLocked", () => !1);
    // Handle double-click at the ShapeUtil level to navigate
    P(this, "onDoubleClick", (n) => {
      wpe(n.props.artifactId);
    });
  }
  getDefaultProps() {
    return {
      w: 240,
      h: 80,
      artifactId: "",
      artifactName: "Untitled"
    };
  }
  getGeometry(n) {
    return new ol({
      width: n.props.w,
      height: n.props.h,
      isFilled: !0
    });
  }
  onResize(n, r) {
    return iS(n, r);
  }
  component(n) {
    return /* @__PURE__ */ h.jsx(
      Zd,
      {
        style: {
          width: n.props.w,
          height: n.props.h,
          pointerEvents: "all"
        },
        children: /* @__PURE__ */ h.jsx(Rct, { shape: n })
      }
    );
  }
  indicator(n) {
    return /* @__PURE__ */ h.jsx("rect", { width: n.props.w, height: n.props.h });
  }
}
P(LR, "type", "artifact-embed"), P(LR, "props", {
  w: dt,
  h: dt,
  artifactId: Et,
  artifactName: Et
});
const P4 = T.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ h.jsxs(Ule, { ref: r, className: Oe("relative overflow-hidden", t), ...n, children: [
  /* @__PURE__ */ h.jsx(Nqe, { className: "h-full w-full rounded-[inherit]", children: e }),
  /* @__PURE__ */ h.jsx(Spe, {}),
  /* @__PURE__ */ h.jsx(jqe, {})
] }));
P4.displayName = Ule.displayName;
const Spe = T.forwardRef(({ className: t, orientation: e = "vertical", ...n }, r) => /* @__PURE__ */ h.jsx(
  C5,
  {
    ref: r,
    orientation: e,
    className: Oe(
      "flex touch-none select-none transition-colors",
      e === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      e === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      t
    ),
    ...n,
    children: /* @__PURE__ */ h.jsx($le, { className: "relative flex-1 rounded-full bg-border" })
  }
));
Spe.displayName = C5.displayName;
const $ct = {
  notes: yp,
  board: G$,
  diagram: C0,
  canvas: Wq,
  calendar: yp
  // Not used but needed for type
}, Lct = {
  notes: "hsl(199, 89%, 48%)",
  board: "hsl(142, 76%, 36%)",
  diagram: "hsl(262, 83%, 58%)",
  canvas: "hsl(25, 95%, 53%)",
  calendar: "hsl(0, 84%, 60%)"
};
function Fct({
  open: t,
  onOpenChange: e,
  onSelect: n,
  excludeId: r
}) {
  const [s, o] = he(""), { artifacts: i } = uu(), a = Ke(() => i.filter((c) => c.id !== r).filter(
    (c) => c.name.toLowerCase().includes(s.toLowerCase()) || c.type.toLowerCase().includes(s.toLowerCase())
  ).slice(0, 20), [i, r, s]);
  return /* @__PURE__ */ h.jsx(ig, { open: t, onOpenChange: e, children: /* @__PURE__ */ h.jsxs(Gf, { className: "max-w-md", children: [
    /* @__PURE__ */ h.jsx(ag, { children: /* @__PURE__ */ h.jsx(cg, { children: "Embed Artifact" }) }),
    /* @__PURE__ */ h.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ h.jsx(Kq, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" }),
      /* @__PURE__ */ h.jsx(
        pa,
        {
          placeholder: "Search artifacts...",
          value: s,
          onChange: (c) => o(c.target.value),
          className: "pl-9",
          autoFocus: !0
        }
      )
    ] }),
    /* @__PURE__ */ h.jsx(P4, { className: "h-64", children: /* @__PURE__ */ h.jsx("div", { className: "space-y-1", children: a.length === 0 ? /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground text-center py-8", children: "No artifacts found" }) : a.map((c) => {
      const l = $ct[c.type], d = Lct[c.type];
      return /* @__PURE__ */ h.jsxs(
        "button",
        {
          onClick: () => n(c),
          className: "w-full flex items-center gap-3 p-2 rounded-lg hover:bg-accent transition-colors text-left",
          children: [
            /* @__PURE__ */ h.jsx(
              "div",
              {
                className: "rounded-md p-1.5",
                style: { backgroundColor: `${d}20` },
                children: /* @__PURE__ */ h.jsx(l, { className: "h-4 w-4", style: { color: d } })
              }
            ),
            /* @__PURE__ */ h.jsxs("div", { className: "flex-1 min-w-0", children: [
              /* @__PURE__ */ h.jsx("p", { className: "font-medium text-sm truncate", children: c.name }),
              /* @__PURE__ */ h.jsx("p", { className: "text-xs text-muted-foreground capitalize", children: c.type })
            ] })
          ]
        },
        c.id
      );
    }) }) })
  ] }) });
}
const Bct = [LR];
let Cpe = {
  openPicker: () => {
  }
};
function zct() {
  return /* @__PURE__ */ h.jsxs(bpe, { children: [
    /* @__PURE__ */ h.jsx(
      Zt,
      {
        id: "embed-artifact",
        icon: "link",
        label: "Embed Artifact",
        onSelect: () => Cpe.openPicker()
      }
    ),
    /* @__PURE__ */ h.jsx(hpe, {})
  ] });
}
function Uct() {
  const n = ie().getSelectedShapes().find(
    (r) => r.type === "artifact-embed"
  );
  return /* @__PURE__ */ h.jsxs(Uhe, { children: [
    n && /* @__PURE__ */ h.jsx(At, { id: "artifact-actions", children: /* @__PURE__ */ h.jsx(
      Zt,
      {
        id: "open-artifact",
        label: "Open Artifact",
        icon: "external-link",
        onSelect: () => {
          wpe(n.props.artifactId);
        }
      }
    ) }),
    /* @__PURE__ */ h.jsx(zhe, {})
  ] });
}
const Hct = {
  Toolbar: zct,
  ContextMenu: Uct
};
function Vct({ initialData: t, onSave: e, currentArtifactId: n }) {
  const { resolvedTheme: r } = Yy(), s = fe(null), [o, i] = he(!1);
  Cpe = {
    openPicker: () => i(!0)
  };
  const a = re((l) => {
    if (s.current = l, t)
      try {
        l.store.loadSnapshot(t);
      } catch (u) {
        console.error("Failed to load snapshot:", u);
      }
    const d = l.store.listen(() => {
      if (e) {
        const u = l.store.getSnapshot();
        e(u);
      }
    }, { source: "user", scope: "document" });
    return () => {
      d();
    };
  }, [t, e]), c = re((l) => {
    const d = s.current;
    if (!d) return;
    const u = d.getViewportScreenCenter(), f = d.screenToPage(u);
    d.createShape({
      type: "artifact-embed",
      x: f.x - 120,
      y: f.y - 40,
      props: {
        w: 260,
        h: 90,
        artifactId: l.id,
        artifactName: l.name
      }
    }), i(!1);
  }, []);
  return /* @__PURE__ */ h.jsxs("div", { className: "w-full h-full relative", children: [
    /* @__PURE__ */ h.jsx(
      Pct,
      {
        onMount: a,
        inferDarkMode: r === "dark",
        shapeUtils: Bct,
        components: Hct
      }
    ),
    /* @__PURE__ */ h.jsx(
      Fct,
      {
        open: o,
        onOpenChange: i,
        onSelect: c,
        excludeId: n
      }
    )
  ] });
}
function Wct({ open: t, onOpenChange: e }) {
  return /* @__PURE__ */ h.jsx(ig, { open: t, onOpenChange: e, children: /* @__PURE__ */ h.jsxs(Gf, { className: "max-w-md", children: [
    /* @__PURE__ */ h.jsx(ag, { children: /* @__PURE__ */ h.jsx(cg, { children: "Whiteboard Tips" }) }),
    /* @__PURE__ */ h.jsxs("div", { className: "space-y-4 text-sm", children: [
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(AD, { className: "h-4 w-4 text-primary" }),
          "Embedding Artifacts"
        ] }),
        /* @__PURE__ */ h.jsxs("p", { className: "text-muted-foreground", children: [
          "Click the ",
          /* @__PURE__ */ h.jsx(AD, { className: "inline h-3 w-3" }),
          " icon to embed other docs, boards, diagrams, or whiteboards. Embedded artifacts are clickable and will open in their native tool."
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(Uq, { className: "h-4 w-4 text-primary" }),
          "Navigation"
        ] }),
        /* @__PURE__ */ h.jsxs("ul", { className: "text-muted-foreground space-y-1 ml-6 list-disc", children: [
          /* @__PURE__ */ h.jsx("li", { children: "Click and drag to pan the canvas" }),
          /* @__PURE__ */ h.jsx("li", { children: "Scroll to zoom in/out" }),
          /* @__PURE__ */ h.jsx("li", { children: "Double-click to create a text box" })
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(K$, { className: "h-4 w-4 text-primary" }),
          "Keyboard Shortcuts"
        ] }),
        /* @__PURE__ */ h.jsxs("ul", { className: "text-muted-foreground space-y-1", children: [
          /* @__PURE__ */ h.jsxs("li", { className: "flex justify-between", children: [
            /* @__PURE__ */ h.jsx("span", { children: "Select tool" }),
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 bg-muted rounded text-xs", children: "V" })
          ] }),
          /* @__PURE__ */ h.jsxs("li", { className: "flex justify-between", children: [
            /* @__PURE__ */ h.jsx("span", { children: "Hand (pan)" }),
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 bg-muted rounded text-xs", children: "H" })
          ] }),
          /* @__PURE__ */ h.jsxs("li", { className: "flex justify-between", children: [
            /* @__PURE__ */ h.jsx("span", { children: "Draw" }),
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 bg-muted rounded text-xs", children: "D" })
          ] }),
          /* @__PURE__ */ h.jsxs("li", { className: "flex justify-between", children: [
            /* @__PURE__ */ h.jsx("span", { children: "Rectangle" }),
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 bg-muted rounded text-xs", children: "R" })
          ] }),
          /* @__PURE__ */ h.jsxs("li", { className: "flex justify-between", children: [
            /* @__PURE__ */ h.jsx("span", { children: "Text" }),
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 bg-muted rounded text-xs", children: "T" })
          ] }),
          /* @__PURE__ */ h.jsxs("li", { className: "flex justify-between", children: [
            /* @__PURE__ */ h.jsx("span", { children: "Undo" }),
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 bg-muted rounded text-xs", children: "Z" })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(awe, { className: "h-4 w-4 text-primary" }),
          "Linking to Other Artifacts"
        ] }),
        /* @__PURE__ */ h.jsxs("p", { className: "text-muted-foreground", children: [
          "Use ",
          /* @__PURE__ */ h.jsx("code", { className: "bg-muted px-1 rounded", children: "[[Artifact Name]]" }),
          " syntax in text boxes to create links. These appear in the backlinks panel."
        ] })
      ] })
    ] })
  ] }) });
}
let uC;
const Kct = new Uint8Array(16);
function Gct() {
  if (!uC && (uC = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !uC))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return uC(Kct);
}
const Gs = [];
for (let t = 0; t < 256; ++t)
  Gs.push((t + 256).toString(16).slice(1));
function Yct(t, e = 0) {
  return Gs[t[e + 0]] + Gs[t[e + 1]] + Gs[t[e + 2]] + Gs[t[e + 3]] + "-" + Gs[t[e + 4]] + Gs[t[e + 5]] + "-" + Gs[t[e + 6]] + Gs[t[e + 7]] + "-" + Gs[t[e + 8]] + Gs[t[e + 9]] + "-" + Gs[t[e + 10]] + Gs[t[e + 11]] + Gs[t[e + 12]] + Gs[t[e + 13]] + Gs[t[e + 14]] + Gs[t[e + 15]];
}
const qct = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), R7 = {
  randomUUID: qct
};
function _pe(t, e, n) {
  if (R7.randomUUID && !e && !t)
    return R7.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || Gct)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Yct(r);
}
const Xct = {
  canvas: "Untitled Canvas",
  diagram: "Untitled Diagram",
  board: "Untitled Board",
  notes: "Untitled Note",
  calendar: "Untitled Calendar"
};
function I4(t, e, n = {}) {
  const { autoSave: r = !0, autoSaveDelay: s = 1e3 } = n, o = rd(), i = nu(), [a, c] = he(null), [l, d] = he(!0), [u, f] = he(null), [p, g] = he(!1), y = e === "new" || !e, m = fe(null), v = fe(null);
  me(() => {
    async function E() {
      d(!0), f(null);
      try {
        if (y) {
          const M = {
            id: _pe(),
            type: t,
            name: Xct[t],
            data: null,
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
            favorite: !1,
            schemaVersion: ss,
            pinned: !1
          };
          c(M);
        } else if (e) {
          const M = await i.getArtifact(e);
          M ? c(M) : f("Artifact not found");
        }
      } catch (M) {
        f(M instanceof Error ? M.message : "Failed to load");
      } finally {
        d(!1);
      }
    }
    E();
  }, [e, t, y, i]), me(() => () => {
    m.current && clearTimeout(m.current);
  }, []);
  const b = re(async (E) => {
    if (a) {
      g(!0);
      try {
        const M = {
          ...a,
          data: E,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          schemaVersion: a.schemaVersion ?? ss
        };
        await i.saveArtifact(M), c(M), y && o(`/${t}/${M.id}`, { replace: !0 });
      } catch (M) {
        f(M instanceof Error ? M.message : "Failed to save");
      } finally {
        g(!1);
      }
    }
  }, [a, i, y, t, o]), x = re(async (E) => {
    if (v.current = E, !r) {
      await b(E);
      return;
    }
    m.current && clearTimeout(m.current), m.current = setTimeout(async () => {
      v.current !== null && (await b(v.current), v.current = null);
    }, s);
  }, [r, s, b]), w = re(async (E) => {
    if (!a) return;
    const M = {
      ...a,
      name: E,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      schemaVersion: a.schemaVersion ?? ss
    };
    await i.saveArtifact(M), c(M);
  }, [a, i]), S = re(async () => {
    if (!a) return;
    const E = {
      ...a,
      favorite: !a.favorite,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      schemaVersion: a.schemaVersion ?? ss
    };
    await i.saveArtifact(E), c(E);
  }, [a, i]), C = re(async () => {
    if (!a) return;
    const E = {
      ...a,
      pinned: !a.pinned,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      schemaVersion: a.schemaVersion ?? ss
    };
    await i.saveArtifact(E), c(E);
  }, [a, i]), _ = re(async (E) => {
    if (!a) return;
    const M = {
      ...a,
      tags: E.length > 0 ? E : void 0,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      schemaVersion: a.schemaVersion ?? ss
    };
    await i.saveArtifact(M), c(M);
  }, [a, i]);
  return {
    artifact: a,
    loading: l,
    error: u,
    saving: p,
    save: x,
    rename: w,
    toggleFavorite: S,
    togglePinned: C,
    updateTags: _,
    isNew: y
  };
}
const $7 = er.canvas;
function L7() {
  const { id: t } = $P(), { artifact: e, loading: n, error: r, saving: s, save: o, rename: i, toggleFavorite: a, updateTags: c } = I4("canvas", t || "new"), [l, d] = he(!1), u = Ke(() => /* @__PURE__ */ h.jsx(
    _t,
    {
      variant: "ghost",
      size: "icon",
      className: "h-8 w-8",
      onClick: () => d(!0),
      title: "Help",
      children: /* @__PURE__ */ h.jsx(Vy, { className: "h-4 w-4" })
    }
  ), []);
  return /* @__PURE__ */ h.jsxs(
    rF,
    {
      title: $7.title,
      icon: $7.icon,
      artifact: e,
      loading: n,
      error: r,
      saving: s,
      onRename: i,
      onToggleFavorite: a,
      onUpdateTags: c,
      headerActions: u,
      children: [
        /* @__PURE__ */ h.jsx(Vct, { initialData: e == null ? void 0 : e.data, onSave: o, currentArtifactId: e == null ? void 0 : e.id }),
        /* @__PURE__ */ h.jsx(Wct, { open: l, onOpenChange: d })
      ]
    }
  );
}
const fC = er.diagram;
function Zct() {
  return /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(zl, { title: fC.title, icon: fC.icon }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 overflow-auto", children: /* @__PURE__ */ h.jsx(
      nF,
      {
        type: "diagram",
        newPath: "/diagram/new",
        emptyTitle: `No ${fC.typeLabel}s yet`,
        emptyDescription: "Create your first flow chart, mind map, or system diagram",
        newButtonLabel: `New ${fC.title}`
      }
    ) })
  ] });
}
function ds(t) {
  if (typeof t == "string" || typeof t == "number") return "" + t;
  let e = "";
  if (Array.isArray(t))
    for (let n = 0, r; n < t.length; n++)
      (r = ds(t[n])) !== "" && (e += (e && " ") + r);
  else
    for (let n in t)
      t[n] && (e += (e && " ") + n);
  return e;
}
var Qct = { value: () => {
} };
function Kk() {
  for (var t = 0, e = arguments.length, n = {}, r; t < e; ++t) {
    if (!(r = arguments[t] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new M_(n);
}
function M_(t) {
  this._ = t;
}
function Jct(t, e) {
  return t.trim().split(/^|\s+/).map(function(n) {
    var r = "", s = n.indexOf(".");
    if (s >= 0 && (r = n.slice(s + 1), n = n.slice(0, s)), n && !e.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
M_.prototype = Kk.prototype = {
  constructor: M_,
  on: function(t, e) {
    var n = this._, r = Jct(t + "", n), s, o = -1, i = r.length;
    if (arguments.length < 2) {
      for (; ++o < i; ) if ((s = (t = r[o]).type) && (s = elt(n[s], t.name))) return s;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++o < i; )
      if (s = (t = r[o]).type) n[s] = F7(n[s], t.name, e);
      else if (e == null) for (s in n) n[s] = F7(n[s], t.name, null);
    return this;
  },
  copy: function() {
    var t = {}, e = this._;
    for (var n in e) t[n] = e[n].slice();
    return new M_(t);
  },
  call: function(t, e) {
    if ((s = arguments.length - 2) > 0) for (var n = new Array(s), r = 0, s, o; r < s; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (o = this._[t], r = 0, s = o.length; r < s; ++r) o[r].value.apply(e, n);
  },
  apply: function(t, e, n) {
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (var r = this._[t], s = 0, o = r.length; s < o; ++s) r[s].value.apply(e, n);
  }
};
function elt(t, e) {
  for (var n = 0, r = t.length, s; n < r; ++n)
    if ((s = t[n]).name === e)
      return s.value;
}
function F7(t, e, n) {
  for (var r = 0, s = t.length; r < s; ++r)
    if (t[r].name === e) {
      t[r] = Qct, t = t.slice(0, r).concat(t.slice(r + 1));
      break;
    }
  return n != null && t.push({ name: e, value: n }), t;
}
var FR = "http://www.w3.org/1999/xhtml";
const B7 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: FR,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Gk(t) {
  var e = t += "", n = e.indexOf(":");
  return n >= 0 && (e = t.slice(0, n)) !== "xmlns" && (t = t.slice(n + 1)), B7.hasOwnProperty(e) ? { space: B7[e], local: t } : t;
}
function tlt(t) {
  return function() {
    var e = this.ownerDocument, n = this.namespaceURI;
    return n === FR && e.documentElement.namespaceURI === FR ? e.createElement(t) : e.createElementNS(n, t);
  };
}
function nlt(t) {
  return function() {
    return this.ownerDocument.createElementNS(t.space, t.local);
  };
}
function Epe(t) {
  var e = Gk(t);
  return (e.local ? nlt : tlt)(e);
}
function rlt() {
}
function k4(t) {
  return t == null ? rlt : function() {
    return this.querySelector(t);
  };
}
function slt(t) {
  typeof t != "function" && (t = k4(t));
  for (var e = this._groups, n = e.length, r = new Array(n), s = 0; s < n; ++s)
    for (var o = e[s], i = o.length, a = r[s] = new Array(i), c, l, d = 0; d < i; ++d)
      (c = o[d]) && (l = t.call(c, c.__data__, d, o)) && ("__data__" in c && (l.__data__ = c.__data__), a[d] = l);
  return new Pa(r, this._parents);
}
function olt(t) {
  return t == null ? [] : Array.isArray(t) ? t : Array.from(t);
}
function ilt() {
  return [];
}
function Tpe(t) {
  return t == null ? ilt : function() {
    return this.querySelectorAll(t);
  };
}
function alt(t) {
  return function() {
    return olt(t.apply(this, arguments));
  };
}
function clt(t) {
  typeof t == "function" ? t = alt(t) : t = Tpe(t);
  for (var e = this._groups, n = e.length, r = [], s = [], o = 0; o < n; ++o)
    for (var i = e[o], a = i.length, c, l = 0; l < a; ++l)
      (c = i[l]) && (r.push(t.call(c, c.__data__, l, i)), s.push(c));
  return new Pa(r, s);
}
function Ppe(t) {
  return function() {
    return this.matches(t);
  };
}
function Ipe(t) {
  return function(e) {
    return e.matches(t);
  };
}
var llt = Array.prototype.find;
function dlt(t) {
  return function() {
    return llt.call(this.children, t);
  };
}
function ult() {
  return this.firstElementChild;
}
function flt(t) {
  return this.select(t == null ? ult : dlt(typeof t == "function" ? t : Ipe(t)));
}
var hlt = Array.prototype.filter;
function plt() {
  return Array.from(this.children);
}
function glt(t) {
  return function() {
    return hlt.call(this.children, t);
  };
}
function mlt(t) {
  return this.selectAll(t == null ? plt : glt(typeof t == "function" ? t : Ipe(t)));
}
function ylt(t) {
  typeof t != "function" && (t = Ppe(t));
  for (var e = this._groups, n = e.length, r = new Array(n), s = 0; s < n; ++s)
    for (var o = e[s], i = o.length, a = r[s] = [], c, l = 0; l < i; ++l)
      (c = o[l]) && t.call(c, c.__data__, l, o) && a.push(c);
  return new Pa(r, this._parents);
}
function kpe(t) {
  return new Array(t.length);
}
function vlt() {
  return new Pa(this._enter || this._groups.map(kpe), this._parents);
}
function QT(t, e) {
  this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = e;
}
QT.prototype = {
  constructor: QT,
  appendChild: function(t) {
    return this._parent.insertBefore(t, this._next);
  },
  insertBefore: function(t, e) {
    return this._parent.insertBefore(t, e);
  },
  querySelector: function(t) {
    return this._parent.querySelector(t);
  },
  querySelectorAll: function(t) {
    return this._parent.querySelectorAll(t);
  }
};
function blt(t) {
  return function() {
    return t;
  };
}
function xlt(t, e, n, r, s, o) {
  for (var i = 0, a, c = e.length, l = o.length; i < l; ++i)
    (a = e[i]) ? (a.__data__ = o[i], r[i] = a) : n[i] = new QT(t, o[i]);
  for (; i < c; ++i)
    (a = e[i]) && (s[i] = a);
}
function wlt(t, e, n, r, s, o, i) {
  var a, c, l = /* @__PURE__ */ new Map(), d = e.length, u = o.length, f = new Array(d), p;
  for (a = 0; a < d; ++a)
    (c = e[a]) && (f[a] = p = i.call(c, c.__data__, a, e) + "", l.has(p) ? s[a] = c : l.set(p, c));
  for (a = 0; a < u; ++a)
    p = i.call(t, o[a], a, o) + "", (c = l.get(p)) ? (r[a] = c, c.__data__ = o[a], l.delete(p)) : n[a] = new QT(t, o[a]);
  for (a = 0; a < d; ++a)
    (c = e[a]) && l.get(f[a]) === c && (s[a] = c);
}
function Slt(t) {
  return t.__data__;
}
function Clt(t, e) {
  if (!arguments.length) return Array.from(this, Slt);
  var n = e ? wlt : xlt, r = this._parents, s = this._groups;
  typeof t != "function" && (t = blt(t));
  for (var o = s.length, i = new Array(o), a = new Array(o), c = new Array(o), l = 0; l < o; ++l) {
    var d = r[l], u = s[l], f = u.length, p = _lt(t.call(d, d && d.__data__, l, r)), g = p.length, y = a[l] = new Array(g), m = i[l] = new Array(g), v = c[l] = new Array(f);
    n(d, u, y, m, v, p, e);
    for (var b = 0, x = 0, w, S; b < g; ++b)
      if (w = y[b]) {
        for (b >= x && (x = b + 1); !(S = m[x]) && ++x < g; ) ;
        w._next = S || null;
      }
  }
  return i = new Pa(i, r), i._enter = a, i._exit = c, i;
}
function _lt(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function Elt() {
  return new Pa(this._exit || this._groups.map(kpe), this._parents);
}
function Tlt(t, e, n) {
  var r = this.enter(), s = this, o = this.exit();
  return typeof t == "function" ? (r = t(r), r && (r = r.selection())) : r = r.append(t + ""), e != null && (s = e(s), s && (s = s.selection())), n == null ? o.remove() : n(o), r && s ? r.merge(s).order() : s;
}
function Plt(t) {
  for (var e = t.selection ? t.selection() : t, n = this._groups, r = e._groups, s = n.length, o = r.length, i = Math.min(s, o), a = new Array(s), c = 0; c < i; ++c)
    for (var l = n[c], d = r[c], u = l.length, f = a[c] = new Array(u), p, g = 0; g < u; ++g)
      (p = l[g] || d[g]) && (f[g] = p);
  for (; c < s; ++c)
    a[c] = n[c];
  return new Pa(a, this._parents);
}
function Ilt() {
  for (var t = this._groups, e = -1, n = t.length; ++e < n; )
    for (var r = t[e], s = r.length - 1, o = r[s], i; --s >= 0; )
      (i = r[s]) && (o && i.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(i, o), o = i);
  return this;
}
function klt(t) {
  t || (t = Alt);
  function e(u, f) {
    return u && f ? t(u.__data__, f.__data__) : !u - !f;
  }
  for (var n = this._groups, r = n.length, s = new Array(r), o = 0; o < r; ++o) {
    for (var i = n[o], a = i.length, c = s[o] = new Array(a), l, d = 0; d < a; ++d)
      (l = i[d]) && (c[d] = l);
    c.sort(e);
  }
  return new Pa(s, this._parents).order();
}
function Alt(t, e) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Mlt() {
  var t = arguments[0];
  return arguments[0] = this, t.apply(null, arguments), this;
}
function Olt() {
  return Array.from(this);
}
function Dlt() {
  for (var t = this._groups, e = 0, n = t.length; e < n; ++e)
    for (var r = t[e], s = 0, o = r.length; s < o; ++s) {
      var i = r[s];
      if (i) return i;
    }
  return null;
}
function Nlt() {
  let t = 0;
  for (const e of this) ++t;
  return t;
}
function jlt() {
  return !this.node();
}
function Rlt(t) {
  for (var e = this._groups, n = 0, r = e.length; n < r; ++n)
    for (var s = e[n], o = 0, i = s.length, a; o < i; ++o)
      (a = s[o]) && t.call(a, a.__data__, o, s);
  return this;
}
function $lt(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function Llt(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function Flt(t, e) {
  return function() {
    this.setAttribute(t, e);
  };
}
function Blt(t, e) {
  return function() {
    this.setAttributeNS(t.space, t.local, e);
  };
}
function zlt(t, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.removeAttribute(t) : this.setAttribute(t, n);
  };
}
function Ult(t, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, n);
  };
}
function Hlt(t, e) {
  var n = Gk(t);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((e == null ? n.local ? Llt : $lt : typeof e == "function" ? n.local ? Ult : zlt : n.local ? Blt : Flt)(n, e));
}
function Ape(t) {
  return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView;
}
function Vlt(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function Wlt(t, e, n) {
  return function() {
    this.style.setProperty(t, e, n);
  };
}
function Klt(t, e, n) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.style.removeProperty(t) : this.style.setProperty(t, r, n);
  };
}
function Glt(t, e, n) {
  return arguments.length > 1 ? this.each((e == null ? Vlt : typeof e == "function" ? Klt : Wlt)(t, e, n ?? "")) : _y(this.node(), t);
}
function _y(t, e) {
  return t.style.getPropertyValue(e) || Ape(t).getComputedStyle(t, null).getPropertyValue(e);
}
function Ylt(t) {
  return function() {
    delete this[t];
  };
}
function qlt(t, e) {
  return function() {
    this[t] = e;
  };
}
function Xlt(t, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? delete this[t] : this[t] = n;
  };
}
function Zlt(t, e) {
  return arguments.length > 1 ? this.each((e == null ? Ylt : typeof e == "function" ? Xlt : qlt)(t, e)) : this.node()[t];
}
function Mpe(t) {
  return t.trim().split(/^|\s+/);
}
function A4(t) {
  return t.classList || new Ope(t);
}
function Ope(t) {
  this._node = t, this._names = Mpe(t.getAttribute("class") || "");
}
Ope.prototype = {
  add: function(t) {
    var e = this._names.indexOf(t);
    e < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t) {
    var e = this._names.indexOf(t);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t) {
    return this._names.indexOf(t) >= 0;
  }
};
function Dpe(t, e) {
  for (var n = A4(t), r = -1, s = e.length; ++r < s; ) n.add(e[r]);
}
function Npe(t, e) {
  for (var n = A4(t), r = -1, s = e.length; ++r < s; ) n.remove(e[r]);
}
function Qlt(t) {
  return function() {
    Dpe(this, t);
  };
}
function Jlt(t) {
  return function() {
    Npe(this, t);
  };
}
function edt(t, e) {
  return function() {
    (e.apply(this, arguments) ? Dpe : Npe)(this, t);
  };
}
function tdt(t, e) {
  var n = Mpe(t + "");
  if (arguments.length < 2) {
    for (var r = A4(this.node()), s = -1, o = n.length; ++s < o; ) if (!r.contains(n[s])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? edt : e ? Qlt : Jlt)(n, e));
}
function ndt() {
  this.textContent = "";
}
function rdt(t) {
  return function() {
    this.textContent = t;
  };
}
function sdt(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function odt(t) {
  return arguments.length ? this.each(t == null ? ndt : (typeof t == "function" ? sdt : rdt)(t)) : this.node().textContent;
}
function idt() {
  this.innerHTML = "";
}
function adt(t) {
  return function() {
    this.innerHTML = t;
  };
}
function cdt(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function ldt(t) {
  return arguments.length ? this.each(t == null ? idt : (typeof t == "function" ? cdt : adt)(t)) : this.node().innerHTML;
}
function ddt() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function udt() {
  return this.each(ddt);
}
function fdt() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function hdt() {
  return this.each(fdt);
}
function pdt(t) {
  var e = typeof t == "function" ? t : Epe(t);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function gdt() {
  return null;
}
function mdt(t, e) {
  var n = typeof t == "function" ? t : Epe(t), r = e == null ? gdt : typeof e == "function" ? e : k4(e);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function ydt() {
  var t = this.parentNode;
  t && t.removeChild(this);
}
function vdt() {
  return this.each(ydt);
}
function bdt() {
  var t = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function xdt() {
  var t = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function wdt(t) {
  return this.select(t ? xdt : bdt);
}
function Sdt(t) {
  return arguments.length ? this.property("__data__", t) : this.node().__data__;
}
function Cdt(t) {
  return function(e) {
    t.call(this, e, this.__data__);
  };
}
function _dt(t) {
  return t.trim().split(/^|\s+/).map(function(e) {
    var n = "", r = e.indexOf(".");
    return r >= 0 && (n = e.slice(r + 1), e = e.slice(0, r)), { type: e, name: n };
  });
}
function Edt(t) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var n = 0, r = -1, s = e.length, o; n < s; ++n)
        o = e[n], (!t.type || o.type === t.type) && o.name === t.name ? this.removeEventListener(o.type, o.listener, o.options) : e[++r] = o;
      ++r ? e.length = r : delete this.__on;
    }
  };
}
function Tdt(t, e, n) {
  return function() {
    var r = this.__on, s, o = Cdt(e);
    if (r) {
      for (var i = 0, a = r.length; i < a; ++i)
        if ((s = r[i]).type === t.type && s.name === t.name) {
          this.removeEventListener(s.type, s.listener, s.options), this.addEventListener(s.type, s.listener = o, s.options = n), s.value = e;
          return;
        }
    }
    this.addEventListener(t.type, o, n), s = { type: t.type, name: t.name, value: e, listener: o, options: n }, r ? r.push(s) : this.__on = [s];
  };
}
function Pdt(t, e, n) {
  var r = _dt(t + ""), s, o = r.length, i;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var c = 0, l = a.length, d; c < l; ++c)
        for (s = 0, d = a[c]; s < o; ++s)
          if ((i = r[s]).type === d.type && i.name === d.name)
            return d.value;
    }
    return;
  }
  for (a = e ? Tdt : Edt, s = 0; s < o; ++s) this.each(a(r[s], e, n));
  return this;
}
function jpe(t, e, n) {
  var r = Ape(t), s = r.CustomEvent;
  typeof s == "function" ? s = new s(e, n) : (s = r.document.createEvent("Event"), n ? (s.initEvent(e, n.bubbles, n.cancelable), s.detail = n.detail) : s.initEvent(e, !1, !1)), t.dispatchEvent(s);
}
function Idt(t, e) {
  return function() {
    return jpe(this, t, e);
  };
}
function kdt(t, e) {
  return function() {
    return jpe(this, t, e.apply(this, arguments));
  };
}
function Adt(t, e) {
  return this.each((typeof e == "function" ? kdt : Idt)(t, e));
}
function* Mdt() {
  for (var t = this._groups, e = 0, n = t.length; e < n; ++e)
    for (var r = t[e], s = 0, o = r.length, i; s < o; ++s)
      (i = r[s]) && (yield i);
}
var Rpe = [null];
function Pa(t, e) {
  this._groups = t, this._parents = e;
}
function xS() {
  return new Pa([[document.documentElement]], Rpe);
}
function Odt() {
  return this;
}
Pa.prototype = xS.prototype = {
  constructor: Pa,
  select: slt,
  selectAll: clt,
  selectChild: flt,
  selectChildren: mlt,
  filter: ylt,
  data: Clt,
  enter: vlt,
  exit: Elt,
  join: Tlt,
  merge: Plt,
  selection: Odt,
  order: Ilt,
  sort: klt,
  call: Mlt,
  nodes: Olt,
  node: Dlt,
  size: Nlt,
  empty: jlt,
  each: Rlt,
  attr: Hlt,
  style: Glt,
  property: Zlt,
  classed: tdt,
  text: odt,
  html: ldt,
  raise: udt,
  lower: hdt,
  append: pdt,
  insert: mdt,
  remove: vdt,
  clone: wdt,
  datum: Sdt,
  on: Pdt,
  dispatch: Adt,
  [Symbol.iterator]: Mdt
};
function aa(t) {
  return typeof t == "string" ? new Pa([[document.querySelector(t)]], [document.documentElement]) : new Pa([[t]], Rpe);
}
function Ddt(t) {
  let e;
  for (; e = t.sourceEvent; ) t = e;
  return t;
}
function Oc(t, e) {
  if (t = Ddt(t), e === void 0 && (e = t.currentTarget), e) {
    var n = e.ownerSVGElement || e;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = t.clientX, r.y = t.clientY, r = r.matrixTransform(e.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (e.getBoundingClientRect) {
      var s = e.getBoundingClientRect();
      return [t.clientX - s.left - e.clientLeft, t.clientY - s.top - e.clientTop];
    }
  }
  return [t.pageX, t.pageY];
}
const Ndt = { passive: !1 }, $w = { capture: !0, passive: !1 };
function i2(t) {
  t.stopImmediatePropagation();
}
function Nm(t) {
  t.preventDefault(), t.stopImmediatePropagation();
}
function $pe(t) {
  var e = t.document.documentElement, n = aa(t).on("dragstart.drag", Nm, $w);
  "onselectstart" in e ? n.on("selectstart.drag", Nm, $w) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function Lpe(t, e) {
  var n = t.document.documentElement, r = aa(t).on("dragstart.drag", null);
  e && (r.on("click.drag", Nm, $w), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const hC = (t) => () => t;
function BR(t, {
  sourceEvent: e,
  subject: n,
  target: r,
  identifier: s,
  active: o,
  x: i,
  y: a,
  dx: c,
  dy: l,
  dispatch: d
}) {
  Object.defineProperties(this, {
    type: { value: t, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: s, enumerable: !0, configurable: !0 },
    active: { value: o, enumerable: !0, configurable: !0 },
    x: { value: i, enumerable: !0, configurable: !0 },
    y: { value: a, enumerable: !0, configurable: !0 },
    dx: { value: c, enumerable: !0, configurable: !0 },
    dy: { value: l, enumerable: !0, configurable: !0 },
    _: { value: d }
  });
}
BR.prototype.on = function() {
  var t = this._.on.apply(this._, arguments);
  return t === this._ ? this : t;
};
function jdt(t) {
  return !t.ctrlKey && !t.button;
}
function Rdt() {
  return this.parentNode;
}
function $dt(t, e) {
  return e ?? { x: t.x, y: t.y };
}
function Ldt() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Fpe() {
  var t = jdt, e = Rdt, n = $dt, r = Ldt, s = {}, o = Kk("start", "drag", "end"), i = 0, a, c, l, d, u = 0;
  function f(w) {
    w.on("mousedown.drag", p).filter(r).on("touchstart.drag", m).on("touchmove.drag", v, Ndt).on("touchend.drag touchcancel.drag", b).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function p(w, S) {
    if (!(d || !t.call(this, w, S))) {
      var C = x(this, e.call(this, w, S), w, S, "mouse");
      C && (aa(w.view).on("mousemove.drag", g, $w).on("mouseup.drag", y, $w), $pe(w.view), i2(w), l = !1, a = w.clientX, c = w.clientY, C("start", w));
    }
  }
  function g(w) {
    if (Nm(w), !l) {
      var S = w.clientX - a, C = w.clientY - c;
      l = S * S + C * C > u;
    }
    s.mouse("drag", w);
  }
  function y(w) {
    aa(w.view).on("mousemove.drag mouseup.drag", null), Lpe(w.view, l), Nm(w), s.mouse("end", w);
  }
  function m(w, S) {
    if (t.call(this, w, S)) {
      var C = w.changedTouches, _ = e.call(this, w, S), E = C.length, M, N;
      for (M = 0; M < E; ++M)
        (N = x(this, _, w, S, C[M].identifier, C[M])) && (i2(w), N("start", w, C[M]));
    }
  }
  function v(w) {
    var S = w.changedTouches, C = S.length, _, E;
    for (_ = 0; _ < C; ++_)
      (E = s[S[_].identifier]) && (Nm(w), E("drag", w, S[_]));
  }
  function b(w) {
    var S = w.changedTouches, C = S.length, _, E;
    for (d && clearTimeout(d), d = setTimeout(function() {
      d = null;
    }, 500), _ = 0; _ < C; ++_)
      (E = s[S[_].identifier]) && (i2(w), E("end", w, S[_]));
  }
  function x(w, S, C, _, E, M) {
    var N = o.copy(), O = Oc(M || C, S), D, k, A;
    if ((A = n.call(w, new BR("beforestart", {
      sourceEvent: C,
      target: f,
      identifier: E,
      active: i,
      x: O[0],
      y: O[1],
      dx: 0,
      dy: 0,
      dispatch: N
    }), _)) != null)
      return D = A.x - O[0] || 0, k = A.y - O[1] || 0, function R(j, $, F) {
        var L = O, z;
        switch (j) {
          case "start":
            s[E] = R, z = i++;
            break;
          case "end":
            delete s[E], --i;
          case "drag":
            O = Oc(F || $, S), z = i;
            break;
        }
        N.call(
          j,
          w,
          new BR(j, {
            sourceEvent: $,
            subject: A,
            target: f,
            identifier: E,
            active: z,
            x: O[0] + D,
            y: O[1] + k,
            dx: O[0] - L[0],
            dy: O[1] - L[1],
            dispatch: N
          }),
          _
        );
      };
  }
  return f.filter = function(w) {
    return arguments.length ? (t = typeof w == "function" ? w : hC(!!w), f) : t;
  }, f.container = function(w) {
    return arguments.length ? (e = typeof w == "function" ? w : hC(w), f) : e;
  }, f.subject = function(w) {
    return arguments.length ? (n = typeof w == "function" ? w : hC(w), f) : n;
  }, f.touchable = function(w) {
    return arguments.length ? (r = typeof w == "function" ? w : hC(!!w), f) : r;
  }, f.on = function() {
    var w = o.on.apply(o, arguments);
    return w === o ? f : w;
  }, f.clickDistance = function(w) {
    return arguments.length ? (u = (w = +w) * w, f) : Math.sqrt(u);
  }, f;
}
function M4(t, e, n) {
  t.prototype = e.prototype = n, n.constructor = t;
}
function Bpe(t, e) {
  var n = Object.create(t.prototype);
  for (var r in e) n[r] = e[r];
  return n;
}
function wS() {
}
var Lw = 0.7, JT = 1 / Lw, jm = "\\s*([+-]?\\d+)\\s*", Fw = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Wl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Fdt = /^#([0-9a-f]{3,8})$/, Bdt = new RegExp(`^rgb\\(${jm},${jm},${jm}\\)$`), zdt = new RegExp(`^rgb\\(${Wl},${Wl},${Wl}\\)$`), Udt = new RegExp(`^rgba\\(${jm},${jm},${jm},${Fw}\\)$`), Hdt = new RegExp(`^rgba\\(${Wl},${Wl},${Wl},${Fw}\\)$`), Vdt = new RegExp(`^hsl\\(${Fw},${Wl},${Wl}\\)$`), Wdt = new RegExp(`^hsla\\(${Fw},${Wl},${Wl},${Fw}\\)$`), z7 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
M4(wS, Hp, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: U7,
  // Deprecated! Use color.formatHex.
  formatHex: U7,
  formatHex8: Kdt,
  formatHsl: Gdt,
  formatRgb: H7,
  toString: H7
});
function U7() {
  return this.rgb().formatHex();
}
function Kdt() {
  return this.rgb().formatHex8();
}
function Gdt() {
  return zpe(this).formatHsl();
}
function H7() {
  return this.rgb().formatRgb();
}
function Hp(t) {
  var e, n;
  return t = (t + "").trim().toLowerCase(), (e = Fdt.exec(t)) ? (n = e[1].length, e = parseInt(e[1], 16), n === 6 ? V7(e) : n === 3 ? new Fi(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : n === 8 ? pC(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : n === 4 ? pC(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = Bdt.exec(t)) ? new Fi(e[1], e[2], e[3], 1) : (e = zdt.exec(t)) ? new Fi(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = Udt.exec(t)) ? pC(e[1], e[2], e[3], e[4]) : (e = Hdt.exec(t)) ? pC(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = Vdt.exec(t)) ? G7(e[1], e[2] / 100, e[3] / 100, 1) : (e = Wdt.exec(t)) ? G7(e[1], e[2] / 100, e[3] / 100, e[4]) : z7.hasOwnProperty(t) ? V7(z7[t]) : t === "transparent" ? new Fi(NaN, NaN, NaN, 0) : null;
}
function V7(t) {
  return new Fi(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function pC(t, e, n, r) {
  return r <= 0 && (t = e = n = NaN), new Fi(t, e, n, r);
}
function Ydt(t) {
  return t instanceof wS || (t = Hp(t)), t ? (t = t.rgb(), new Fi(t.r, t.g, t.b, t.opacity)) : new Fi();
}
function zR(t, e, n, r) {
  return arguments.length === 1 ? Ydt(t) : new Fi(t, e, n, r ?? 1);
}
function Fi(t, e, n, r) {
  this.r = +t, this.g = +e, this.b = +n, this.opacity = +r;
}
M4(Fi, zR, Bpe(wS, {
  brighter(t) {
    return t = t == null ? JT : Math.pow(JT, t), new Fi(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Lw : Math.pow(Lw, t), new Fi(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Fi(hp(this.r), hp(this.g), hp(this.b), eP(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: W7,
  // Deprecated! Use color.formatHex.
  formatHex: W7,
  formatHex8: qdt,
  formatRgb: K7,
  toString: K7
}));
function W7() {
  return `#${Kh(this.r)}${Kh(this.g)}${Kh(this.b)}`;
}
function qdt() {
  return `#${Kh(this.r)}${Kh(this.g)}${Kh(this.b)}${Kh((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function K7() {
  const t = eP(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${hp(this.r)}, ${hp(this.g)}, ${hp(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function eP(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function hp(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function Kh(t) {
  return t = hp(t), (t < 16 ? "0" : "") + t.toString(16);
}
function G7(t, e, n, r) {
  return r <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new Rc(t, e, n, r);
}
function zpe(t) {
  if (t instanceof Rc) return new Rc(t.h, t.s, t.l, t.opacity);
  if (t instanceof wS || (t = Hp(t)), !t) return new Rc();
  if (t instanceof Rc) return t;
  t = t.rgb();
  var e = t.r / 255, n = t.g / 255, r = t.b / 255, s = Math.min(e, n, r), o = Math.max(e, n, r), i = NaN, a = o - s, c = (o + s) / 2;
  return a ? (e === o ? i = (n - r) / a + (n < r) * 6 : n === o ? i = (r - e) / a + 2 : i = (e - n) / a + 4, a /= c < 0.5 ? o + s : 2 - o - s, i *= 60) : a = c > 0 && c < 1 ? 0 : i, new Rc(i, a, c, t.opacity);
}
function Xdt(t, e, n, r) {
  return arguments.length === 1 ? zpe(t) : new Rc(t, e, n, r ?? 1);
}
function Rc(t, e, n, r) {
  this.h = +t, this.s = +e, this.l = +n, this.opacity = +r;
}
M4(Rc, Xdt, Bpe(wS, {
  brighter(t) {
    return t = t == null ? JT : Math.pow(JT, t), new Rc(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Lw : Math.pow(Lw, t), new Rc(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * e, s = 2 * n - r;
    return new Fi(
      a2(t >= 240 ? t - 240 : t + 120, s, r),
      a2(t, s, r),
      a2(t < 120 ? t + 240 : t - 120, s, r),
      this.opacity
    );
  },
  clamp() {
    return new Rc(Y7(this.h), gC(this.s), gC(this.l), eP(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = eP(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${Y7(this.h)}, ${gC(this.s) * 100}%, ${gC(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function Y7(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function gC(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function a2(t, e, n) {
  return (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e) * 255;
}
const O4 = (t) => () => t;
function Zdt(t, e) {
  return function(n) {
    return t + n * e;
  };
}
function Qdt(t, e, n) {
  return t = Math.pow(t, n), e = Math.pow(e, n) - t, n = 1 / n, function(r) {
    return Math.pow(t + r * e, n);
  };
}
function Jdt(t) {
  return (t = +t) == 1 ? Upe : function(e, n) {
    return n - e ? Qdt(e, n, t) : O4(isNaN(e) ? n : e);
  };
}
function Upe(t, e) {
  var n = e - t;
  return n ? Zdt(t, n) : O4(isNaN(t) ? e : t);
}
const tP = function t(e) {
  var n = Jdt(e);
  function r(s, o) {
    var i = n((s = zR(s)).r, (o = zR(o)).r), a = n(s.g, o.g), c = n(s.b, o.b), l = Upe(s.opacity, o.opacity);
    return function(d) {
      return s.r = i(d), s.g = a(d), s.b = c(d), s.opacity = l(d), s + "";
    };
  }
  return r.gamma = t, r;
}(1);
function eut(t, e) {
  e || (e = []);
  var n = t ? Math.min(e.length, t.length) : 0, r = e.slice(), s;
  return function(o) {
    for (s = 0; s < n; ++s) r[s] = t[s] * (1 - o) + e[s] * o;
    return r;
  };
}
function tut(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function nut(t, e) {
  var n = e ? e.length : 0, r = t ? Math.min(n, t.length) : 0, s = new Array(r), o = new Array(n), i;
  for (i = 0; i < r; ++i) s[i] = Rx(t[i], e[i]);
  for (; i < n; ++i) o[i] = e[i];
  return function(a) {
    for (i = 0; i < r; ++i) o[i] = s[i](a);
    return o;
  };
}
function rut(t, e) {
  var n = /* @__PURE__ */ new Date();
  return t = +t, e = +e, function(r) {
    return n.setTime(t * (1 - r) + e * r), n;
  };
}
function Al(t, e) {
  return t = +t, e = +e, function(n) {
    return t * (1 - n) + e * n;
  };
}
function sut(t, e) {
  var n = {}, r = {}, s;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (s in e)
    s in t ? n[s] = Rx(t[s], e[s]) : r[s] = e[s];
  return function(o) {
    for (s in n) r[s] = n[s](o);
    return r;
  };
}
var UR = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, c2 = new RegExp(UR.source, "g");
function out(t) {
  return function() {
    return t;
  };
}
function iut(t) {
  return function(e) {
    return t(e) + "";
  };
}
function Hpe(t, e) {
  var n = UR.lastIndex = c2.lastIndex = 0, r, s, o, i = -1, a = [], c = [];
  for (t = t + "", e = e + ""; (r = UR.exec(t)) && (s = c2.exec(e)); )
    (o = s.index) > n && (o = e.slice(n, o), a[i] ? a[i] += o : a[++i] = o), (r = r[0]) === (s = s[0]) ? a[i] ? a[i] += s : a[++i] = s : (a[++i] = null, c.push({ i, x: Al(r, s) })), n = c2.lastIndex;
  return n < e.length && (o = e.slice(n), a[i] ? a[i] += o : a[++i] = o), a.length < 2 ? c[0] ? iut(c[0].x) : out(e) : (e = c.length, function(l) {
    for (var d = 0, u; d < e; ++d) a[(u = c[d]).i] = u.x(l);
    return a.join("");
  });
}
function Rx(t, e) {
  var n = typeof e, r;
  return e == null || n === "boolean" ? O4(e) : (n === "number" ? Al : n === "string" ? (r = Hp(e)) ? (e = r, tP) : Hpe : e instanceof Hp ? tP : e instanceof Date ? rut : tut(e) ? eut : Array.isArray(e) ? nut : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? sut : Al)(t, e);
}
var q7 = 180 / Math.PI, HR = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function Vpe(t, e, n, r, s, o) {
  var i, a, c;
  return (i = Math.sqrt(t * t + e * e)) && (t /= i, e /= i), (c = t * n + e * r) && (n -= t * c, r -= e * c), (a = Math.sqrt(n * n + r * r)) && (n /= a, r /= a, c /= a), t * r < e * n && (t = -t, e = -e, c = -c, i = -i), {
    translateX: s,
    translateY: o,
    rotate: Math.atan2(e, t) * q7,
    skewX: Math.atan(c) * q7,
    scaleX: i,
    scaleY: a
  };
}
var mC;
function aut(t) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t + "");
  return e.isIdentity ? HR : Vpe(e.a, e.b, e.c, e.d, e.e, e.f);
}
function cut(t) {
  return t == null || (mC || (mC = document.createElementNS("http://www.w3.org/2000/svg", "g")), mC.setAttribute("transform", t), !(t = mC.transform.baseVal.consolidate())) ? HR : (t = t.matrix, Vpe(t.a, t.b, t.c, t.d, t.e, t.f));
}
function Wpe(t, e, n, r) {
  function s(l) {
    return l.length ? l.pop() + " " : "";
  }
  function o(l, d, u, f, p, g) {
    if (l !== u || d !== f) {
      var y = p.push("translate(", null, e, null, n);
      g.push({ i: y - 4, x: Al(l, u) }, { i: y - 2, x: Al(d, f) });
    } else (u || f) && p.push("translate(" + u + e + f + n);
  }
  function i(l, d, u, f) {
    l !== d ? (l - d > 180 ? d += 360 : d - l > 180 && (l += 360), f.push({ i: u.push(s(u) + "rotate(", null, r) - 2, x: Al(l, d) })) : d && u.push(s(u) + "rotate(" + d + r);
  }
  function a(l, d, u, f) {
    l !== d ? f.push({ i: u.push(s(u) + "skewX(", null, r) - 2, x: Al(l, d) }) : d && u.push(s(u) + "skewX(" + d + r);
  }
  function c(l, d, u, f, p, g) {
    if (l !== u || d !== f) {
      var y = p.push(s(p) + "scale(", null, ",", null, ")");
      g.push({ i: y - 4, x: Al(l, u) }, { i: y - 2, x: Al(d, f) });
    } else (u !== 1 || f !== 1) && p.push(s(p) + "scale(" + u + "," + f + ")");
  }
  return function(l, d) {
    var u = [], f = [];
    return l = t(l), d = t(d), o(l.translateX, l.translateY, d.translateX, d.translateY, u, f), i(l.rotate, d.rotate, u, f), a(l.skewX, d.skewX, u, f), c(l.scaleX, l.scaleY, d.scaleX, d.scaleY, u, f), l = d = null, function(p) {
      for (var g = -1, y = f.length, m; ++g < y; ) u[(m = f[g]).i] = m.x(p);
      return u.join("");
    };
  };
}
var lut = Wpe(aut, "px, ", "px)", "deg)"), dut = Wpe(cut, ", ", ")", ")"), uut = 1e-12;
function X7(t) {
  return ((t = Math.exp(t)) + 1 / t) / 2;
}
function fut(t) {
  return ((t = Math.exp(t)) - 1 / t) / 2;
}
function hut(t) {
  return ((t = Math.exp(2 * t)) - 1) / (t + 1);
}
const O_ = function t(e, n, r) {
  function s(o, i) {
    var a = o[0], c = o[1], l = o[2], d = i[0], u = i[1], f = i[2], p = d - a, g = u - c, y = p * p + g * g, m, v;
    if (y < uut)
      v = Math.log(f / l) / e, m = function(_) {
        return [
          a + _ * p,
          c + _ * g,
          l * Math.exp(e * _ * v)
        ];
      };
    else {
      var b = Math.sqrt(y), x = (f * f - l * l + r * y) / (2 * l * n * b), w = (f * f - l * l - r * y) / (2 * f * n * b), S = Math.log(Math.sqrt(x * x + 1) - x), C = Math.log(Math.sqrt(w * w + 1) - w);
      v = (C - S) / e, m = function(_) {
        var E = _ * v, M = X7(S), N = l / (n * b) * (M * hut(e * E + S) - fut(S));
        return [
          a + N * p,
          c + N * g,
          l * M / X7(e * E + S)
        ];
      };
    }
    return m.duration = v * 1e3 * e / Math.SQRT2, m;
  }
  return s.rho = function(o) {
    var i = Math.max(1e-3, +o), a = i * i, c = a * a;
    return t(i, a, c);
  }, s;
}(Math.SQRT2, 2, 4);
var Ey = 0, tx = 0, pb = 0, Kpe = 1e3, nP, nx, rP = 0, Vp = 0, Yk = 0, Bw = typeof performance == "object" && performance.now ? performance : Date, Gpe = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) {
  setTimeout(t, 17);
};
function D4() {
  return Vp || (Gpe(put), Vp = Bw.now() + Yk);
}
function put() {
  Vp = 0;
}
function sP() {
  this._call = this._time = this._next = null;
}
sP.prototype = Ype.prototype = {
  constructor: sP,
  restart: function(t, e, n) {
    if (typeof t != "function") throw new TypeError("callback is not a function");
    n = (n == null ? D4() : +n) + (e == null ? 0 : +e), !this._next && nx !== this && (nx ? nx._next = this : nP = this, nx = this), this._call = t, this._time = n, VR();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, VR());
  }
};
function Ype(t, e, n) {
  var r = new sP();
  return r.restart(t, e, n), r;
}
function gut() {
  D4(), ++Ey;
  for (var t = nP, e; t; )
    (e = Vp - t._time) >= 0 && t._call.call(void 0, e), t = t._next;
  --Ey;
}
function Z7() {
  Vp = (rP = Bw.now()) + Yk, Ey = tx = 0;
  try {
    gut();
  } finally {
    Ey = 0, yut(), Vp = 0;
  }
}
function mut() {
  var t = Bw.now(), e = t - rP;
  e > Kpe && (Yk -= e, rP = t);
}
function yut() {
  for (var t, e = nP, n, r = 1 / 0; e; )
    e._call ? (r > e._time && (r = e._time), t = e, e = e._next) : (n = e._next, e._next = null, e = t ? t._next = n : nP = n);
  nx = t, VR(r);
}
function VR(t) {
  if (!Ey) {
    tx && (tx = clearTimeout(tx));
    var e = t - Vp;
    e > 24 ? (t < 1 / 0 && (tx = setTimeout(Z7, t - Bw.now() - Yk)), pb && (pb = clearInterval(pb))) : (pb || (rP = Bw.now(), pb = setInterval(mut, Kpe)), Ey = 1, Gpe(Z7));
  }
}
function Q7(t, e, n) {
  var r = new sP();
  return e = e == null ? 0 : +e, r.restart((s) => {
    r.stop(), t(s + e);
  }, e, n), r;
}
var vut = Kk("start", "end", "cancel", "interrupt"), but = [], qpe = 0, J7 = 1, WR = 2, D_ = 3, eW = 4, KR = 5, N_ = 6;
function qk(t, e, n, r, s, o) {
  var i = t.__transition;
  if (!i) t.__transition = {};
  else if (n in i) return;
  xut(t, n, {
    name: e,
    index: r,
    // For context during callback.
    group: s,
    // For context during callback.
    on: vut,
    tween: but,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: qpe
  });
}
function N4(t, e) {
  var n = fl(t, e);
  if (n.state > qpe) throw new Error("too late; already scheduled");
  return n;
}
function cd(t, e) {
  var n = fl(t, e);
  if (n.state > D_) throw new Error("too late; already running");
  return n;
}
function fl(t, e) {
  var n = t.__transition;
  if (!n || !(n = n[e])) throw new Error("transition not found");
  return n;
}
function xut(t, e, n) {
  var r = t.__transition, s;
  r[e] = n, n.timer = Ype(o, 0, n.time);
  function o(l) {
    n.state = J7, n.timer.restart(i, n.delay, n.time), n.delay <= l && i(l - n.delay);
  }
  function i(l) {
    var d, u, f, p;
    if (n.state !== J7) return c();
    for (d in r)
      if (p = r[d], p.name === n.name) {
        if (p.state === D_) return Q7(i);
        p.state === eW ? (p.state = N_, p.timer.stop(), p.on.call("interrupt", t, t.__data__, p.index, p.group), delete r[d]) : +d < e && (p.state = N_, p.timer.stop(), p.on.call("cancel", t, t.__data__, p.index, p.group), delete r[d]);
      }
    if (Q7(function() {
      n.state === D_ && (n.state = eW, n.timer.restart(a, n.delay, n.time), a(l));
    }), n.state = WR, n.on.call("start", t, t.__data__, n.index, n.group), n.state === WR) {
      for (n.state = D_, s = new Array(f = n.tween.length), d = 0, u = -1; d < f; ++d)
        (p = n.tween[d].value.call(t, t.__data__, n.index, n.group)) && (s[++u] = p);
      s.length = u + 1;
    }
  }
  function a(l) {
    for (var d = l < n.duration ? n.ease.call(null, l / n.duration) : (n.timer.restart(c), n.state = KR, 1), u = -1, f = s.length; ++u < f; )
      s[u].call(t, d);
    n.state === KR && (n.on.call("end", t, t.__data__, n.index, n.group), c());
  }
  function c() {
    n.state = N_, n.timer.stop(), delete r[e];
    for (var l in r) return;
    delete t.__transition;
  }
}
function j_(t, e) {
  var n = t.__transition, r, s, o = !0, i;
  if (n) {
    e = e == null ? null : e + "";
    for (i in n) {
      if ((r = n[i]).name !== e) {
        o = !1;
        continue;
      }
      s = r.state > WR && r.state < KR, r.state = N_, r.timer.stop(), r.on.call(s ? "interrupt" : "cancel", t, t.__data__, r.index, r.group), delete n[i];
    }
    o && delete t.__transition;
  }
}
function wut(t) {
  return this.each(function() {
    j_(this, t);
  });
}
function Sut(t, e) {
  var n, r;
  return function() {
    var s = cd(this, t), o = s.tween;
    if (o !== n) {
      r = n = o;
      for (var i = 0, a = r.length; i < a; ++i)
        if (r[i].name === e) {
          r = r.slice(), r.splice(i, 1);
          break;
        }
    }
    s.tween = r;
  };
}
function Cut(t, e, n) {
  var r, s;
  if (typeof n != "function") throw new Error();
  return function() {
    var o = cd(this, t), i = o.tween;
    if (i !== r) {
      s = (r = i).slice();
      for (var a = { name: e, value: n }, c = 0, l = s.length; c < l; ++c)
        if (s[c].name === e) {
          s[c] = a;
          break;
        }
      c === l && s.push(a);
    }
    o.tween = s;
  };
}
function _ut(t, e) {
  var n = this._id;
  if (t += "", arguments.length < 2) {
    for (var r = fl(this.node(), n).tween, s = 0, o = r.length, i; s < o; ++s)
      if ((i = r[s]).name === t)
        return i.value;
    return null;
  }
  return this.each((e == null ? Sut : Cut)(n, t, e));
}
function j4(t, e, n) {
  var r = t._id;
  return t.each(function() {
    var s = cd(this, r);
    (s.value || (s.value = {}))[e] = n.apply(this, arguments);
  }), function(s) {
    return fl(s, r).value[e];
  };
}
function Xpe(t, e) {
  var n;
  return (typeof e == "number" ? Al : e instanceof Hp ? tP : (n = Hp(e)) ? (e = n, tP) : Hpe)(t, e);
}
function Eut(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function Tut(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function Put(t, e, n) {
  var r, s = n + "", o;
  return function() {
    var i = this.getAttribute(t);
    return i === s ? null : i === r ? o : o = e(r = i, n);
  };
}
function Iut(t, e, n) {
  var r, s = n + "", o;
  return function() {
    var i = this.getAttributeNS(t.space, t.local);
    return i === s ? null : i === r ? o : o = e(r = i, n);
  };
}
function kut(t, e, n) {
  var r, s, o;
  return function() {
    var i, a = n(this), c;
    return a == null ? void this.removeAttribute(t) : (i = this.getAttribute(t), c = a + "", i === c ? null : i === r && c === s ? o : (s = c, o = e(r = i, a)));
  };
}
function Aut(t, e, n) {
  var r, s, o;
  return function() {
    var i, a = n(this), c;
    return a == null ? void this.removeAttributeNS(t.space, t.local) : (i = this.getAttributeNS(t.space, t.local), c = a + "", i === c ? null : i === r && c === s ? o : (s = c, o = e(r = i, a)));
  };
}
function Mut(t, e) {
  var n = Gk(t), r = n === "transform" ? dut : Xpe;
  return this.attrTween(t, typeof e == "function" ? (n.local ? Aut : kut)(n, r, j4(this, "attr." + t, e)) : e == null ? (n.local ? Tut : Eut)(n) : (n.local ? Iut : Put)(n, r, e));
}
function Out(t, e) {
  return function(n) {
    this.setAttribute(t, e.call(this, n));
  };
}
function Dut(t, e) {
  return function(n) {
    this.setAttributeNS(t.space, t.local, e.call(this, n));
  };
}
function Nut(t, e) {
  var n, r;
  function s() {
    var o = e.apply(this, arguments);
    return o !== r && (n = (r = o) && Dut(t, o)), n;
  }
  return s._value = e, s;
}
function jut(t, e) {
  var n, r;
  function s() {
    var o = e.apply(this, arguments);
    return o !== r && (n = (r = o) && Out(t, o)), n;
  }
  return s._value = e, s;
}
function Rut(t, e) {
  var n = "attr." + t;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  var r = Gk(t);
  return this.tween(n, (r.local ? Nut : jut)(r, e));
}
function $ut(t, e) {
  return function() {
    N4(this, t).delay = +e.apply(this, arguments);
  };
}
function Lut(t, e) {
  return e = +e, function() {
    N4(this, t).delay = e;
  };
}
function Fut(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? $ut : Lut)(e, t)) : fl(this.node(), e).delay;
}
function But(t, e) {
  return function() {
    cd(this, t).duration = +e.apply(this, arguments);
  };
}
function zut(t, e) {
  return e = +e, function() {
    cd(this, t).duration = e;
  };
}
function Uut(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? But : zut)(e, t)) : fl(this.node(), e).duration;
}
function Hut(t, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    cd(this, t).ease = e;
  };
}
function Vut(t) {
  var e = this._id;
  return arguments.length ? this.each(Hut(e, t)) : fl(this.node(), e).ease;
}
function Wut(t, e) {
  return function() {
    var n = e.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    cd(this, t).ease = n;
  };
}
function Kut(t) {
  if (typeof t != "function") throw new Error();
  return this.each(Wut(this._id, t));
}
function Gut(t) {
  typeof t != "function" && (t = Ppe(t));
  for (var e = this._groups, n = e.length, r = new Array(n), s = 0; s < n; ++s)
    for (var o = e[s], i = o.length, a = r[s] = [], c, l = 0; l < i; ++l)
      (c = o[l]) && t.call(c, c.__data__, l, o) && a.push(c);
  return new au(r, this._parents, this._name, this._id);
}
function Yut(t) {
  if (t._id !== this._id) throw new Error();
  for (var e = this._groups, n = t._groups, r = e.length, s = n.length, o = Math.min(r, s), i = new Array(r), a = 0; a < o; ++a)
    for (var c = e[a], l = n[a], d = c.length, u = i[a] = new Array(d), f, p = 0; p < d; ++p)
      (f = c[p] || l[p]) && (u[p] = f);
  for (; a < r; ++a)
    i[a] = e[a];
  return new au(i, this._parents, this._name, this._id);
}
function qut(t) {
  return (t + "").trim().split(/^|\s+/).every(function(e) {
    var n = e.indexOf(".");
    return n >= 0 && (e = e.slice(0, n)), !e || e === "start";
  });
}
function Xut(t, e, n) {
  var r, s, o = qut(e) ? N4 : cd;
  return function() {
    var i = o(this, t), a = i.on;
    a !== r && (s = (r = a).copy()).on(e, n), i.on = s;
  };
}
function Zut(t, e) {
  var n = this._id;
  return arguments.length < 2 ? fl(this.node(), n).on.on(t) : this.each(Xut(n, t, e));
}
function Qut(t) {
  return function() {
    var e = this.parentNode;
    for (var n in this.__transition) if (+n !== t) return;
    e && e.removeChild(this);
  };
}
function Jut() {
  return this.on("end.remove", Qut(this._id));
}
function eft(t) {
  var e = this._name, n = this._id;
  typeof t != "function" && (t = k4(t));
  for (var r = this._groups, s = r.length, o = new Array(s), i = 0; i < s; ++i)
    for (var a = r[i], c = a.length, l = o[i] = new Array(c), d, u, f = 0; f < c; ++f)
      (d = a[f]) && (u = t.call(d, d.__data__, f, a)) && ("__data__" in d && (u.__data__ = d.__data__), l[f] = u, qk(l[f], e, n, f, l, fl(d, n)));
  return new au(o, this._parents, e, n);
}
function tft(t) {
  var e = this._name, n = this._id;
  typeof t != "function" && (t = Tpe(t));
  for (var r = this._groups, s = r.length, o = [], i = [], a = 0; a < s; ++a)
    for (var c = r[a], l = c.length, d, u = 0; u < l; ++u)
      if (d = c[u]) {
        for (var f = t.call(d, d.__data__, u, c), p, g = fl(d, n), y = 0, m = f.length; y < m; ++y)
          (p = f[y]) && qk(p, e, n, y, f, g);
        o.push(f), i.push(d);
      }
  return new au(o, i, e, n);
}
var nft = xS.prototype.constructor;
function rft() {
  return new nft(this._groups, this._parents);
}
function sft(t, e) {
  var n, r, s;
  return function() {
    var o = _y(this, t), i = (this.style.removeProperty(t), _y(this, t));
    return o === i ? null : o === n && i === r ? s : s = e(n = o, r = i);
  };
}
function Zpe(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function oft(t, e, n) {
  var r, s = n + "", o;
  return function() {
    var i = _y(this, t);
    return i === s ? null : i === r ? o : o = e(r = i, n);
  };
}
function ift(t, e, n) {
  var r, s, o;
  return function() {
    var i = _y(this, t), a = n(this), c = a + "";
    return a == null && (c = a = (this.style.removeProperty(t), _y(this, t))), i === c ? null : i === r && c === s ? o : (s = c, o = e(r = i, a));
  };
}
function aft(t, e) {
  var n, r, s, o = "style." + e, i = "end." + o, a;
  return function() {
    var c = cd(this, t), l = c.on, d = c.value[o] == null ? a || (a = Zpe(e)) : void 0;
    (l !== n || s !== d) && (r = (n = l).copy()).on(i, s = d), c.on = r;
  };
}
function cft(t, e, n) {
  var r = (t += "") == "transform" ? lut : Xpe;
  return e == null ? this.styleTween(t, sft(t, r)).on("end.style." + t, Zpe(t)) : typeof e == "function" ? this.styleTween(t, ift(t, r, j4(this, "style." + t, e))).each(aft(this._id, t)) : this.styleTween(t, oft(t, r, e), n).on("end.style." + t, null);
}
function lft(t, e, n) {
  return function(r) {
    this.style.setProperty(t, e.call(this, r), n);
  };
}
function dft(t, e, n) {
  var r, s;
  function o() {
    var i = e.apply(this, arguments);
    return i !== s && (r = (s = i) && lft(t, i, n)), r;
  }
  return o._value = e, o;
}
function uft(t, e, n) {
  var r = "style." + (t += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (e == null) return this.tween(r, null);
  if (typeof e != "function") throw new Error();
  return this.tween(r, dft(t, e, n ?? ""));
}
function fft(t) {
  return function() {
    this.textContent = t;
  };
}
function hft(t) {
  return function() {
    var e = t(this);
    this.textContent = e ?? "";
  };
}
function pft(t) {
  return this.tween("text", typeof t == "function" ? hft(j4(this, "text", t)) : fft(t == null ? "" : t + ""));
}
function gft(t) {
  return function(e) {
    this.textContent = t.call(this, e);
  };
}
function mft(t) {
  var e, n;
  function r() {
    var s = t.apply(this, arguments);
    return s !== n && (e = (n = s) && gft(s)), e;
  }
  return r._value = t, r;
}
function yft(t) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t == null) return this.tween(e, null);
  if (typeof t != "function") throw new Error();
  return this.tween(e, mft(t));
}
function vft() {
  for (var t = this._name, e = this._id, n = Qpe(), r = this._groups, s = r.length, o = 0; o < s; ++o)
    for (var i = r[o], a = i.length, c, l = 0; l < a; ++l)
      if (c = i[l]) {
        var d = fl(c, e);
        qk(c, t, n, l, i, {
          time: d.time + d.delay + d.duration,
          delay: 0,
          duration: d.duration,
          ease: d.ease
        });
      }
  return new au(r, this._parents, t, n);
}
function bft() {
  var t, e, n = this, r = n._id, s = n.size();
  return new Promise(function(o, i) {
    var a = { value: i }, c = { value: function() {
      --s === 0 && o();
    } };
    n.each(function() {
      var l = cd(this, r), d = l.on;
      d !== t && (e = (t = d).copy(), e._.cancel.push(a), e._.interrupt.push(a), e._.end.push(c)), l.on = e;
    }), s === 0 && o();
  });
}
var xft = 0;
function au(t, e, n, r) {
  this._groups = t, this._parents = e, this._name = n, this._id = r;
}
function Qpe() {
  return ++xft;
}
var Ed = xS.prototype;
au.prototype = {
  constructor: au,
  select: eft,
  selectAll: tft,
  selectChild: Ed.selectChild,
  selectChildren: Ed.selectChildren,
  filter: Gut,
  merge: Yut,
  selection: rft,
  transition: vft,
  call: Ed.call,
  nodes: Ed.nodes,
  node: Ed.node,
  size: Ed.size,
  empty: Ed.empty,
  each: Ed.each,
  on: Zut,
  attr: Mut,
  attrTween: Rut,
  style: cft,
  styleTween: uft,
  text: pft,
  textTween: yft,
  remove: Jut,
  tween: _ut,
  delay: Fut,
  duration: Uut,
  ease: Vut,
  easeVarying: Kut,
  end: bft,
  [Symbol.iterator]: Ed[Symbol.iterator]
};
function wft(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var Sft = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: wft
};
function Cft(t, e) {
  for (var n; !(n = t.__transition) || !(n = n[e]); )
    if (!(t = t.parentNode))
      throw new Error(`transition ${e} not found`);
  return n;
}
function _ft(t) {
  var e, n;
  t instanceof au ? (e = t._id, t = t._name) : (e = Qpe(), (n = Sft).time = D4(), t = t == null ? null : t + "");
  for (var r = this._groups, s = r.length, o = 0; o < s; ++o)
    for (var i = r[o], a = i.length, c, l = 0; l < a; ++l)
      (c = i[l]) && qk(c, t, e, l, i, n || Cft(c, e));
  return new au(r, this._parents, t, e);
}
xS.prototype.interrupt = wut;
xS.prototype.transition = _ft;
const yC = (t) => () => t;
function Eft(t, {
  sourceEvent: e,
  target: n,
  transform: r,
  dispatch: s
}) {
  Object.defineProperties(this, {
    type: { value: t, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: s }
  });
}
function Gd(t, e, n) {
  this.k = t, this.x = e, this.y = n;
}
Gd.prototype = {
  constructor: Gd,
  scale: function(t) {
    return t === 1 ? this : new Gd(this.k * t, this.x, this.y);
  },
  translate: function(t, e) {
    return t === 0 & e === 0 ? this : new Gd(this.k, this.x + this.k * t, this.y + this.k * e);
  },
  apply: function(t) {
    return [t[0] * this.k + this.x, t[1] * this.k + this.y];
  },
  applyX: function(t) {
    return t * this.k + this.x;
  },
  applyY: function(t) {
    return t * this.k + this.y;
  },
  invert: function(t) {
    return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
  },
  invertX: function(t) {
    return (t - this.x) / this.k;
  },
  invertY: function(t) {
    return (t - this.y) / this.k;
  },
  rescaleX: function(t) {
    return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t));
  },
  rescaleY: function(t) {
    return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var Xk = new Gd(1, 0, 0);
Jpe.prototype = Gd.prototype;
function Jpe(t) {
  for (; !t.__zoom; ) if (!(t = t.parentNode)) return Xk;
  return t.__zoom;
}
function l2(t) {
  t.stopImmediatePropagation();
}
function gb(t) {
  t.preventDefault(), t.stopImmediatePropagation();
}
function Tft(t) {
  return (!t.ctrlKey || t.type === "wheel") && !t.button;
}
function Pft() {
  var t = this;
  return t instanceof SVGElement ? (t = t.ownerSVGElement || t, t.hasAttribute("viewBox") ? (t = t.viewBox.baseVal, [[t.x, t.y], [t.x + t.width, t.y + t.height]]) : [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]]) : [[0, 0], [t.clientWidth, t.clientHeight]];
}
function tW() {
  return this.__zoom || Xk;
}
function Ift(t) {
  return -t.deltaY * (t.deltaMode === 1 ? 0.05 : t.deltaMode ? 1 : 2e-3) * (t.ctrlKey ? 10 : 1);
}
function kft() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Aft(t, e, n) {
  var r = t.invertX(e[0][0]) - n[0][0], s = t.invertX(e[1][0]) - n[1][0], o = t.invertY(e[0][1]) - n[0][1], i = t.invertY(e[1][1]) - n[1][1];
  return t.translate(
    s > r ? (r + s) / 2 : Math.min(0, r) || Math.max(0, s),
    i > o ? (o + i) / 2 : Math.min(0, o) || Math.max(0, i)
  );
}
function ege() {
  var t = Tft, e = Pft, n = Aft, r = Ift, s = kft, o = [0, 1 / 0], i = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], a = 250, c = O_, l = Kk("start", "zoom", "end"), d, u, f, p = 500, g = 150, y = 0, m = 10;
  function v(A) {
    A.property("__zoom", tW).on("wheel.zoom", E, { passive: !1 }).on("mousedown.zoom", M).on("dblclick.zoom", N).filter(s).on("touchstart.zoom", O).on("touchmove.zoom", D).on("touchend.zoom touchcancel.zoom", k).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  v.transform = function(A, R, j, $) {
    var F = A.selection ? A.selection() : A;
    F.property("__zoom", tW), A !== F ? S(A, R, j, $) : F.interrupt().each(function() {
      C(this, arguments).event($).start().zoom(null, typeof R == "function" ? R.apply(this, arguments) : R).end();
    });
  }, v.scaleBy = function(A, R, j, $) {
    v.scaleTo(A, function() {
      var F = this.__zoom.k, L = typeof R == "function" ? R.apply(this, arguments) : R;
      return F * L;
    }, j, $);
  }, v.scaleTo = function(A, R, j, $) {
    v.transform(A, function() {
      var F = e.apply(this, arguments), L = this.__zoom, z = j == null ? w(F) : typeof j == "function" ? j.apply(this, arguments) : j, H = L.invert(z), U = typeof R == "function" ? R.apply(this, arguments) : R;
      return n(x(b(L, U), z, H), F, i);
    }, j, $);
  }, v.translateBy = function(A, R, j, $) {
    v.transform(A, function() {
      return n(this.__zoom.translate(
        typeof R == "function" ? R.apply(this, arguments) : R,
        typeof j == "function" ? j.apply(this, arguments) : j
      ), e.apply(this, arguments), i);
    }, null, $);
  }, v.translateTo = function(A, R, j, $, F) {
    v.transform(A, function() {
      var L = e.apply(this, arguments), z = this.__zoom, H = $ == null ? w(L) : typeof $ == "function" ? $.apply(this, arguments) : $;
      return n(Xk.translate(H[0], H[1]).scale(z.k).translate(
        typeof R == "function" ? -R.apply(this, arguments) : -R,
        typeof j == "function" ? -j.apply(this, arguments) : -j
      ), L, i);
    }, $, F);
  };
  function b(A, R) {
    return R = Math.max(o[0], Math.min(o[1], R)), R === A.k ? A : new Gd(R, A.x, A.y);
  }
  function x(A, R, j) {
    var $ = R[0] - j[0] * A.k, F = R[1] - j[1] * A.k;
    return $ === A.x && F === A.y ? A : new Gd(A.k, $, F);
  }
  function w(A) {
    return [(+A[0][0] + +A[1][0]) / 2, (+A[0][1] + +A[1][1]) / 2];
  }
  function S(A, R, j, $) {
    A.on("start.zoom", function() {
      C(this, arguments).event($).start();
    }).on("interrupt.zoom end.zoom", function() {
      C(this, arguments).event($).end();
    }).tween("zoom", function() {
      var F = this, L = arguments, z = C(F, L).event($), H = e.apply(F, L), U = j == null ? w(H) : typeof j == "function" ? j.apply(F, L) : j, W = Math.max(H[1][0] - H[0][0], H[1][1] - H[0][1]), Z = F.__zoom, K = typeof R == "function" ? R.apply(F, L) : R, oe = c(Z.invert(U).concat(W / Z.k), K.invert(U).concat(W / K.k));
      return function(Y) {
        if (Y === 1) Y = K;
        else {
          var ee = oe(Y), ae = W / ee[2];
          Y = new Gd(ae, U[0] - ee[0] * ae, U[1] - ee[1] * ae);
        }
        z.zoom(null, Y);
      };
    });
  }
  function C(A, R, j) {
    return !j && A.__zooming || new _(A, R);
  }
  function _(A, R) {
    this.that = A, this.args = R, this.active = 0, this.sourceEvent = null, this.extent = e.apply(A, R), this.taps = 0;
  }
  _.prototype = {
    event: function(A) {
      return A && (this.sourceEvent = A), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(A, R) {
      return this.mouse && A !== "mouse" && (this.mouse[1] = R.invert(this.mouse[0])), this.touch0 && A !== "touch" && (this.touch0[1] = R.invert(this.touch0[0])), this.touch1 && A !== "touch" && (this.touch1[1] = R.invert(this.touch1[0])), this.that.__zoom = R, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(A) {
      var R = aa(this.that).datum();
      l.call(
        A,
        this.that,
        new Eft(A, {
          sourceEvent: this.sourceEvent,
          target: v,
          type: A,
          transform: this.that.__zoom,
          dispatch: l
        }),
        R
      );
    }
  };
  function E(A, ...R) {
    if (!t.apply(this, arguments)) return;
    var j = C(this, R).event(A), $ = this.__zoom, F = Math.max(o[0], Math.min(o[1], $.k * Math.pow(2, r.apply(this, arguments)))), L = Oc(A);
    if (j.wheel)
      (j.mouse[0][0] !== L[0] || j.mouse[0][1] !== L[1]) && (j.mouse[1] = $.invert(j.mouse[0] = L)), clearTimeout(j.wheel);
    else {
      if ($.k === F) return;
      j.mouse = [L, $.invert(L)], j_(this), j.start();
    }
    gb(A), j.wheel = setTimeout(z, g), j.zoom("mouse", n(x(b($, F), j.mouse[0], j.mouse[1]), j.extent, i));
    function z() {
      j.wheel = null, j.end();
    }
  }
  function M(A, ...R) {
    if (f || !t.apply(this, arguments)) return;
    var j = A.currentTarget, $ = C(this, R, !0).event(A), F = aa(A.view).on("mousemove.zoom", U, !0).on("mouseup.zoom", W, !0), L = Oc(A, j), z = A.clientX, H = A.clientY;
    $pe(A.view), l2(A), $.mouse = [L, this.__zoom.invert(L)], j_(this), $.start();
    function U(Z) {
      if (gb(Z), !$.moved) {
        var K = Z.clientX - z, oe = Z.clientY - H;
        $.moved = K * K + oe * oe > y;
      }
      $.event(Z).zoom("mouse", n(x($.that.__zoom, $.mouse[0] = Oc(Z, j), $.mouse[1]), $.extent, i));
    }
    function W(Z) {
      F.on("mousemove.zoom mouseup.zoom", null), Lpe(Z.view, $.moved), gb(Z), $.event(Z).end();
    }
  }
  function N(A, ...R) {
    if (t.apply(this, arguments)) {
      var j = this.__zoom, $ = Oc(A.changedTouches ? A.changedTouches[0] : A, this), F = j.invert($), L = j.k * (A.shiftKey ? 0.5 : 2), z = n(x(b(j, L), $, F), e.apply(this, R), i);
      gb(A), a > 0 ? aa(this).transition().duration(a).call(S, z, $, A) : aa(this).call(v.transform, z, $, A);
    }
  }
  function O(A, ...R) {
    if (t.apply(this, arguments)) {
      var j = A.touches, $ = j.length, F = C(this, R, A.changedTouches.length === $).event(A), L, z, H, U;
      for (l2(A), z = 0; z < $; ++z)
        H = j[z], U = Oc(H, this), U = [U, this.__zoom.invert(U), H.identifier], F.touch0 ? !F.touch1 && F.touch0[2] !== U[2] && (F.touch1 = U, F.taps = 0) : (F.touch0 = U, L = !0, F.taps = 1 + !!d);
      d && (d = clearTimeout(d)), L && (F.taps < 2 && (u = U[0], d = setTimeout(function() {
        d = null;
      }, p)), j_(this), F.start());
    }
  }
  function D(A, ...R) {
    if (this.__zooming) {
      var j = C(this, R).event(A), $ = A.changedTouches, F = $.length, L, z, H, U;
      for (gb(A), L = 0; L < F; ++L)
        z = $[L], H = Oc(z, this), j.touch0 && j.touch0[2] === z.identifier ? j.touch0[0] = H : j.touch1 && j.touch1[2] === z.identifier && (j.touch1[0] = H);
      if (z = j.that.__zoom, j.touch1) {
        var W = j.touch0[0], Z = j.touch0[1], K = j.touch1[0], oe = j.touch1[1], Y = (Y = K[0] - W[0]) * Y + (Y = K[1] - W[1]) * Y, ee = (ee = oe[0] - Z[0]) * ee + (ee = oe[1] - Z[1]) * ee;
        z = b(z, Math.sqrt(Y / ee)), H = [(W[0] + K[0]) / 2, (W[1] + K[1]) / 2], U = [(Z[0] + oe[0]) / 2, (Z[1] + oe[1]) / 2];
      } else if (j.touch0) H = j.touch0[0], U = j.touch0[1];
      else return;
      j.zoom("touch", n(x(z, H, U), j.extent, i));
    }
  }
  function k(A, ...R) {
    if (this.__zooming) {
      var j = C(this, R).event(A), $ = A.changedTouches, F = $.length, L, z;
      for (l2(A), f && clearTimeout(f), f = setTimeout(function() {
        f = null;
      }, p), L = 0; L < F; ++L)
        z = $[L], j.touch0 && j.touch0[2] === z.identifier ? delete j.touch0 : j.touch1 && j.touch1[2] === z.identifier && delete j.touch1;
      if (j.touch1 && !j.touch0 && (j.touch0 = j.touch1, delete j.touch1), j.touch0) j.touch0[1] = this.__zoom.invert(j.touch0[0]);
      else if (j.end(), j.taps === 2 && (z = Oc(z, this), Math.hypot(u[0] - z[0], u[1] - z[1]) < m)) {
        var H = aa(this).on("dblclick.zoom");
        H && H.apply(this, arguments);
      }
    }
  }
  return v.wheelDelta = function(A) {
    return arguments.length ? (r = typeof A == "function" ? A : yC(+A), v) : r;
  }, v.filter = function(A) {
    return arguments.length ? (t = typeof A == "function" ? A : yC(!!A), v) : t;
  }, v.touchable = function(A) {
    return arguments.length ? (s = typeof A == "function" ? A : yC(!!A), v) : s;
  }, v.extent = function(A) {
    return arguments.length ? (e = typeof A == "function" ? A : yC([[+A[0][0], +A[0][1]], [+A[1][0], +A[1][1]]]), v) : e;
  }, v.scaleExtent = function(A) {
    return arguments.length ? (o[0] = +A[0], o[1] = +A[1], v) : [o[0], o[1]];
  }, v.translateExtent = function(A) {
    return arguments.length ? (i[0][0] = +A[0][0], i[1][0] = +A[1][0], i[0][1] = +A[0][1], i[1][1] = +A[1][1], v) : [[i[0][0], i[0][1]], [i[1][0], i[1][1]]];
  }, v.constrain = function(A) {
    return arguments.length ? (n = A, v) : n;
  }, v.duration = function(A) {
    return arguments.length ? (a = +A, v) : a;
  }, v.interpolate = function(A) {
    return arguments.length ? (c = A, v) : c;
  }, v.on = function() {
    var A = l.on.apply(l, arguments);
    return A === l ? v : A;
  }, v.clickDistance = function(A) {
    return arguments.length ? (y = (A = +A) * A, v) : Math.sqrt(y);
  }, v.tapDistance = function(A) {
    return arguments.length ? (m = +A, v) : m;
  }, v;
}
const Ia = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (t) => `Node type "${t}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (t) => `The old edge with id=${t} does not exist.`,
  error009: (t) => `Marker type "${t}" doesn't exist.`,
  error008: (t, { id: e, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${t} handle id: "${t === "source" ? n : r}", edge id: ${e}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (t) => `Edge type "${t}" not found. Using fallback type "default".`,
  error012: (t) => `Node with id "${t}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (t = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${t}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, zw = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], tge = ["Enter", " ", "Escape"], nge = {
  "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.ariaLiveMessage": ({ direction: t, x: e, y: n }) => `Moved selected node ${t}. New position, x: ${e}, y: ${n}`,
  "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
  // Control elements
  "controls.ariaLabel": "Control Panel",
  "controls.zoomIn.ariaLabel": "Zoom In",
  "controls.zoomOut.ariaLabel": "Zoom Out",
  "controls.fitView.ariaLabel": "Fit View",
  "controls.interactive.ariaLabel": "Toggle Interactivity",
  // Mini map
  "minimap.ariaLabel": "Mini Map",
  // Handle
  "handle.ariaLabel": "Handle"
};
var Ty;
(function(t) {
  t.Strict = "strict", t.Loose = "loose";
})(Ty || (Ty = {}));
var pp;
(function(t) {
  t.Free = "free", t.Vertical = "vertical", t.Horizontal = "horizontal";
})(pp || (pp = {}));
var Uw;
(function(t) {
  t.Partial = "partial", t.Full = "full";
})(Uw || (Uw = {}));
const rge = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null,
  pointer: null
};
var Zu;
(function(t) {
  t.Bezier = "default", t.Straight = "straight", t.Step = "step", t.SmoothStep = "smoothstep", t.SimpleBezier = "simplebezier";
})(Zu || (Zu = {}));
var oP;
(function(t) {
  t.Arrow = "arrow", t.ArrowClosed = "arrowclosed";
})(oP || (oP = {}));
var lt;
(function(t) {
  t.Left = "left", t.Top = "top", t.Right = "right", t.Bottom = "bottom";
})(lt || (lt = {}));
const nW = {
  [lt.Left]: lt.Right,
  [lt.Right]: lt.Left,
  [lt.Top]: lt.Bottom,
  [lt.Bottom]: lt.Top
};
function sge(t) {
  return t === null ? null : t ? "valid" : "invalid";
}
const oge = (t) => "id" in t && "source" in t && "target" in t, Mft = (t) => "id" in t && "position" in t && !("source" in t) && !("target" in t), R4 = (t) => "id" in t && "internals" in t && !("source" in t) && !("target" in t), SS = (t, e = [0, 0]) => {
  const { width: n, height: r } = Su(t), s = t.origin ?? e, o = n * s[0], i = r * s[1];
  return {
    x: t.position.x - o,
    y: t.position.y - i
  };
}, Oft = (t, e = { nodeOrigin: [0, 0] }) => {
  if (process.env.NODE_ENV === "development" && !e.nodeLookup && console.warn("Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows."), t.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = t.reduce((r, s) => {
    const o = typeof s == "string";
    let i = !e.nodeLookup && !o ? s : void 0;
    e.nodeLookup && (i = o ? e.nodeLookup.get(s) : R4(s) ? s : e.nodeLookup.get(s.id));
    const a = i ? iP(i, e.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return Zk(r, a);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return Qk(n);
}, CS = (t, e = {}) => {
  let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }, r = !1;
  return t.forEach((s) => {
    (e.filter === void 0 || e.filter(s)) && (n = Zk(n, iP(s)), r = !0);
  }), r ? Qk(n) : { x: 0, y: 0, width: 0, height: 0 };
}, $4 = (t, e, [n, r, s] = [0, 0, 1], o = !1, i = !1) => {
  const a = {
    ...ES(e, [n, r, s]),
    width: e.width / s,
    height: e.height / s
  }, c = [];
  for (const l of t.values()) {
    const { measured: d, selectable: u = !0, hidden: f = !1 } = l;
    if (i && !u || f)
      continue;
    const p = d.width ?? l.width ?? l.initialWidth ?? null, g = d.height ?? l.height ?? l.initialHeight ?? null, y = Hw(a, Iy(l)), m = (p ?? 0) * (g ?? 0), v = o && y > 0;
    (!l.internals.handleBounds || v || y >= m || l.dragging) && c.push(l);
  }
  return c;
}, Dft = (t, e) => {
  const n = /* @__PURE__ */ new Set();
  return t.forEach((r) => {
    n.add(r.id);
  }), e.filter((r) => n.has(r.source) || n.has(r.target));
};
function Nft(t, e) {
  const n = /* @__PURE__ */ new Map(), r = e != null && e.nodes ? new Set(e.nodes.map((s) => s.id)) : null;
  return t.forEach((s) => {
    s.measured.width && s.measured.height && ((e == null ? void 0 : e.includeHiddenNodes) || !s.hidden) && (!r || r.has(s.id)) && n.set(s.id, s);
  }), n;
}
async function jft({ nodes: t, width: e, height: n, panZoom: r, minZoom: s, maxZoom: o }, i) {
  if (t.size === 0)
    return Promise.resolve(!0);
  const a = Nft(t, i), c = CS(a), l = L4(c, e, n, (i == null ? void 0 : i.minZoom) ?? s, (i == null ? void 0 : i.maxZoom) ?? o, (i == null ? void 0 : i.padding) ?? 0.1);
  return await r.setViewport(l, {
    duration: i == null ? void 0 : i.duration,
    ease: i == null ? void 0 : i.ease,
    interpolate: i == null ? void 0 : i.interpolate
  }), Promise.resolve(!0);
}
function ige({ nodeId: t, nextPosition: e, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: s, onError: o }) {
  const i = n.get(t), a = i.parentId ? n.get(i.parentId) : void 0, { x: c, y: l } = a ? a.internals.positionAbsolute : { x: 0, y: 0 }, d = i.origin ?? r;
  let u = i.extent || s;
  if (i.extent === "parent" && !i.expandParent)
    if (!a)
      o == null || o("005", Ia.error005());
    else {
      const p = a.measured.width, g = a.measured.height;
      p && g && (u = [
        [c, l],
        [c + p, l + g]
      ]);
    }
  else a && ky(i.extent) && (u = [
    [i.extent[0][0] + c, i.extent[0][1] + l],
    [i.extent[1][0] + c, i.extent[1][1] + l]
  ]);
  const f = ky(u) ? Wp(e, u, i.measured) : e;
  return (i.measured.width === void 0 || i.measured.height === void 0) && (o == null || o("015", Ia.error015())), {
    position: {
      x: f.x - c + (i.measured.width ?? 0) * d[0],
      y: f.y - l + (i.measured.height ?? 0) * d[1]
    },
    positionAbsolute: f
  };
}
async function Rft({ nodesToRemove: t = [], edgesToRemove: e = [], nodes: n, edges: r, onBeforeDelete: s }) {
  const o = new Set(t.map((f) => f.id)), i = [];
  for (const f of n) {
    if (f.deletable === !1)
      continue;
    const p = o.has(f.id), g = !p && f.parentId && i.find((y) => y.id === f.parentId);
    (p || g) && i.push(f);
  }
  const a = new Set(e.map((f) => f.id)), c = r.filter((f) => f.deletable !== !1), d = Dft(i, c);
  for (const f of c)
    a.has(f.id) && !d.find((g) => g.id === f.id) && d.push(f);
  if (!s)
    return {
      edges: d,
      nodes: i
    };
  const u = await s({
    nodes: i,
    edges: d
  });
  return typeof u == "boolean" ? u ? { edges: d, nodes: i } : { edges: [], nodes: [] } : u;
}
const Py = (t, e = 0, n = 1) => Math.min(Math.max(t, e), n), Wp = (t = { x: 0, y: 0 }, e, n) => ({
  x: Py(t.x, e[0][0], e[1][0] - ((n == null ? void 0 : n.width) ?? 0)),
  y: Py(t.y, e[0][1], e[1][1] - ((n == null ? void 0 : n.height) ?? 0))
});
function age(t, e, n) {
  const { width: r, height: s } = Su(n), { x: o, y: i } = n.internals.positionAbsolute;
  return Wp(t, [
    [o, i],
    [o + r, i + s]
  ], e);
}
const rW = (t, e, n) => t < e ? Py(Math.abs(t - e), 1, e) / e : t > n ? -Py(Math.abs(t - n), 1, e) / e : 0, cge = (t, e, n = 15, r = 40) => {
  const s = rW(t.x, r, e.width - r) * n, o = rW(t.y, r, e.height - r) * n;
  return [s, o];
}, Zk = (t, e) => ({
  x: Math.min(t.x, e.x),
  y: Math.min(t.y, e.y),
  x2: Math.max(t.x2, e.x2),
  y2: Math.max(t.y2, e.y2)
}), GR = ({ x: t, y: e, width: n, height: r }) => ({
  x: t,
  y: e,
  x2: t + n,
  y2: e + r
}), Qk = ({ x: t, y: e, x2: n, y2: r }) => ({
  x: t,
  y: e,
  width: n - t,
  height: r - e
}), Iy = (t, e = [0, 0]) => {
  var s, o;
  const { x: n, y: r } = R4(t) ? t.internals.positionAbsolute : SS(t, e);
  return {
    x: n,
    y: r,
    width: ((s = t.measured) == null ? void 0 : s.width) ?? t.width ?? t.initialWidth ?? 0,
    height: ((o = t.measured) == null ? void 0 : o.height) ?? t.height ?? t.initialHeight ?? 0
  };
}, iP = (t, e = [0, 0]) => {
  var s, o;
  const { x: n, y: r } = R4(t) ? t.internals.positionAbsolute : SS(t, e);
  return {
    x: n,
    y: r,
    x2: n + (((s = t.measured) == null ? void 0 : s.width) ?? t.width ?? t.initialWidth ?? 0),
    y2: r + (((o = t.measured) == null ? void 0 : o.height) ?? t.height ?? t.initialHeight ?? 0)
  };
}, lge = (t, e) => Qk(Zk(GR(t), GR(e))), Hw = (t, e) => {
  const n = Math.max(0, Math.min(t.x + t.width, e.x + e.width) - Math.max(t.x, e.x)), r = Math.max(0, Math.min(t.y + t.height, e.y + e.height) - Math.max(t.y, e.y));
  return Math.ceil(n * r);
}, sW = (t) => Wc(t.width) && Wc(t.height) && Wc(t.x) && Wc(t.y), Wc = (t) => !isNaN(t) && isFinite(t), dge = (t, e) => {
  process.env.NODE_ENV === "development" && console.warn(`[React Flow]: ${e} Help: https://reactflow.dev/error#${t}`);
}, _S = (t, e = [1, 1]) => ({
  x: e[0] * Math.round(t.x / e[0]),
  y: e[1] * Math.round(t.y / e[1])
}), ES = ({ x: t, y: e }, [n, r, s], o = !1, i = [1, 1]) => {
  const a = {
    x: (t - n) / s,
    y: (e - r) / s
  };
  return o ? _S(a, i) : a;
}, aP = ({ x: t, y: e }, [n, r, s]) => ({
  x: t * s + n,
  y: e * s + r
});
function Kg(t, e) {
  if (typeof t == "number")
    return Math.floor((e - e / (1 + t)) * 0.5);
  if (typeof t == "string" && t.endsWith("px")) {
    const n = parseFloat(t);
    if (!Number.isNaN(n))
      return Math.floor(n);
  }
  if (typeof t == "string" && t.endsWith("%")) {
    const n = parseFloat(t);
    if (!Number.isNaN(n))
      return Math.floor(e * n * 0.01);
  }
  return console.error(`[React Flow] The padding value "${t}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function $ft(t, e, n) {
  if (typeof t == "string" || typeof t == "number") {
    const r = Kg(t, n), s = Kg(t, e);
    return {
      top: r,
      right: s,
      bottom: r,
      left: s,
      x: s * 2,
      y: r * 2
    };
  }
  if (typeof t == "object") {
    const r = Kg(t.top ?? t.y ?? 0, n), s = Kg(t.bottom ?? t.y ?? 0, n), o = Kg(t.left ?? t.x ?? 0, e), i = Kg(t.right ?? t.x ?? 0, e);
    return { top: r, right: i, bottom: s, left: o, x: o + i, y: r + s };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function Lft(t, e, n, r, s, o) {
  const { x: i, y: a } = aP(t, [e, n, r]), { x: c, y: l } = aP({ x: t.x + t.width, y: t.y + t.height }, [e, n, r]), d = s - c, u = o - l;
  return {
    left: Math.floor(i),
    top: Math.floor(a),
    right: Math.floor(d),
    bottom: Math.floor(u)
  };
}
const L4 = (t, e, n, r, s, o) => {
  const i = $ft(o, e, n), a = (e - i.x) / t.width, c = (n - i.y) / t.height, l = Math.min(a, c), d = Py(l, r, s), u = t.x + t.width / 2, f = t.y + t.height / 2, p = e / 2 - u * d, g = n / 2 - f * d, y = Lft(t, p, g, d, e, n), m = {
    left: Math.min(y.left - i.left, 0),
    top: Math.min(y.top - i.top, 0),
    right: Math.min(y.right - i.right, 0),
    bottom: Math.min(y.bottom - i.bottom, 0)
  };
  return {
    x: p - m.left + m.right,
    y: g - m.top + m.bottom,
    zoom: d
  };
}, Vw = () => {
  var t;
  return typeof navigator < "u" && ((t = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : t.indexOf("Mac")) >= 0;
};
function ky(t) {
  return t != null && t !== "parent";
}
function Su(t) {
  var e, n;
  return {
    width: ((e = t.measured) == null ? void 0 : e.width) ?? t.width ?? t.initialWidth ?? 0,
    height: ((n = t.measured) == null ? void 0 : n.height) ?? t.height ?? t.initialHeight ?? 0
  };
}
function uge(t) {
  var e, n;
  return (((e = t.measured) == null ? void 0 : e.width) ?? t.width ?? t.initialWidth) !== void 0 && (((n = t.measured) == null ? void 0 : n.height) ?? t.height ?? t.initialHeight) !== void 0;
}
function fge(t, e = { width: 0, height: 0 }, n, r, s) {
  const o = { ...t }, i = r.get(n);
  if (i) {
    const a = i.origin || s;
    o.x += i.internals.positionAbsolute.x - (e.width ?? 0) * a[0], o.y += i.internals.positionAbsolute.y - (e.height ?? 0) * a[1];
  }
  return o;
}
function oW(t, e) {
  if (t.size !== e.size)
    return !1;
  for (const n of t)
    if (!e.has(n))
      return !1;
  return !0;
}
function Fft() {
  let t, e;
  return { promise: new Promise((r, s) => {
    t = r, e = s;
  }), resolve: t, reject: e };
}
function Bft(t) {
  return { ...nge, ...t || {} };
}
function $x(t, { snapGrid: e = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: s }) {
  const { x: o, y: i } = Kc(t), a = ES({ x: o - ((s == null ? void 0 : s.left) ?? 0), y: i - ((s == null ? void 0 : s.top) ?? 0) }, r), { x: c, y: l } = n ? _S(a, e) : a;
  return {
    xSnapped: c,
    ySnapped: l,
    ...a
  };
}
const F4 = (t) => ({
  width: t.offsetWidth,
  height: t.offsetHeight
}), hge = (t) => {
  var e;
  return ((e = t == null ? void 0 : t.getRootNode) == null ? void 0 : e.call(t)) || (window == null ? void 0 : window.document);
}, zft = ["INPUT", "SELECT", "TEXTAREA"];
function pge(t) {
  var r, s;
  const e = ((s = (r = t.composedPath) == null ? void 0 : r.call(t)) == null ? void 0 : s[0]) || t.target;
  return (e == null ? void 0 : e.nodeType) !== 1 ? !1 : zft.includes(e.nodeName) || e.hasAttribute("contenteditable") || !!e.closest(".nokey");
}
const gge = (t) => "clientX" in t, Kc = (t, e) => {
  var o, i;
  const n = gge(t), r = n ? t.clientX : (o = t.touches) == null ? void 0 : o[0].clientX, s = n ? t.clientY : (i = t.touches) == null ? void 0 : i[0].clientY;
  return {
    x: r - ((e == null ? void 0 : e.left) ?? 0),
    y: s - ((e == null ? void 0 : e.top) ?? 0)
  };
}, iW = (t, e, n, r, s) => {
  const o = e.querySelectorAll(`.${t}`);
  return !o || !o.length ? null : Array.from(o).map((i) => {
    const a = i.getBoundingClientRect();
    return {
      id: i.getAttribute("data-handleid"),
      type: t,
      nodeId: s,
      position: i.getAttribute("data-handlepos"),
      x: (a.left - n.left) / r,
      y: (a.top - n.top) / r,
      ...F4(i)
    };
  });
};
function mge({ sourceX: t, sourceY: e, targetX: n, targetY: r, sourceControlX: s, sourceControlY: o, targetControlX: i, targetControlY: a }) {
  const c = t * 0.125 + s * 0.375 + i * 0.375 + n * 0.125, l = e * 0.125 + o * 0.375 + a * 0.375 + r * 0.125, d = Math.abs(c - t), u = Math.abs(l - e);
  return [c, l, d, u];
}
function vC(t, e) {
  return t >= 0 ? 0.5 * t : e * 25 * Math.sqrt(-t);
}
function aW({ pos: t, x1: e, y1: n, x2: r, y2: s, c: o }) {
  switch (t) {
    case lt.Left:
      return [e - vC(e - r, o), n];
    case lt.Right:
      return [e + vC(r - e, o), n];
    case lt.Top:
      return [e, n - vC(n - s, o)];
    case lt.Bottom:
      return [e, n + vC(s - n, o)];
  }
}
function yge({ sourceX: t, sourceY: e, sourcePosition: n = lt.Bottom, targetX: r, targetY: s, targetPosition: o = lt.Top, curvature: i = 0.25 }) {
  const [a, c] = aW({
    pos: n,
    x1: t,
    y1: e,
    x2: r,
    y2: s,
    c: i
  }), [l, d] = aW({
    pos: o,
    x1: r,
    y1: s,
    x2: t,
    y2: e,
    c: i
  }), [u, f, p, g] = mge({
    sourceX: t,
    sourceY: e,
    targetX: r,
    targetY: s,
    sourceControlX: a,
    sourceControlY: c,
    targetControlX: l,
    targetControlY: d
  });
  return [
    `M${t},${e} C${a},${c} ${l},${d} ${r},${s}`,
    u,
    f,
    p,
    g
  ];
}
function vge({ sourceX: t, sourceY: e, targetX: n, targetY: r }) {
  const s = Math.abs(n - t) / 2, o = n < t ? n + s : n - s, i = Math.abs(r - e) / 2, a = r < e ? r + i : r - i;
  return [o, a, s, i];
}
function Uft({ sourceNode: t, targetNode: e, selected: n = !1, zIndex: r = 0, elevateOnSelect: s = !1, zIndexMode: o = "basic" }) {
  if (o === "manual")
    return r;
  const i = s && n ? r + 1e3 : r, a = Math.max(t.parentId || s && t.selected ? t.internals.z : 0, e.parentId || s && e.selected ? e.internals.z : 0);
  return i + a;
}
function Hft({ sourceNode: t, targetNode: e, width: n, height: r, transform: s }) {
  const o = Zk(iP(t), iP(e));
  o.x === o.x2 && (o.x2 += 1), o.y === o.y2 && (o.y2 += 1);
  const i = {
    x: -s[0] / s[2],
    y: -s[1] / s[2],
    width: n / s[2],
    height: r / s[2]
  };
  return Hw(i, Qk(o)) > 0;
}
const Vft = ({ source: t, sourceHandle: e, target: n, targetHandle: r }) => `xy-edge__${t}${e || ""}-${n}${r || ""}`, Wft = (t, e) => e.some((n) => n.source === t.source && n.target === t.target && (n.sourceHandle === t.sourceHandle || !n.sourceHandle && !t.sourceHandle) && (n.targetHandle === t.targetHandle || !n.targetHandle && !t.targetHandle)), bge = (t, e, n = {}) => {
  if (!t.source || !t.target)
    return dge("006", Ia.error006()), e;
  const r = n.getEdgeId || Vft;
  let s;
  return oge(t) ? s = { ...t } : s = {
    ...t,
    id: r(t)
  }, Wft(s, e) ? e : (s.sourceHandle === null && delete s.sourceHandle, s.targetHandle === null && delete s.targetHandle, e.concat(s));
};
function xge({ sourceX: t, sourceY: e, targetX: n, targetY: r }) {
  const [s, o, i, a] = vge({
    sourceX: t,
    sourceY: e,
    targetX: n,
    targetY: r
  });
  return [`M ${t},${e}L ${n},${r}`, s, o, i, a];
}
const cW = {
  [lt.Left]: { x: -1, y: 0 },
  [lt.Right]: { x: 1, y: 0 },
  [lt.Top]: { x: 0, y: -1 },
  [lt.Bottom]: { x: 0, y: 1 }
}, Kft = ({ source: t, sourcePosition: e = lt.Bottom, target: n }) => e === lt.Left || e === lt.Right ? t.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : t.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, lW = (t, e) => Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
function Gft({ source: t, sourcePosition: e = lt.Bottom, target: n, targetPosition: r = lt.Top, center: s, offset: o, stepPosition: i }) {
  const a = cW[e], c = cW[r], l = { x: t.x + a.x * o, y: t.y + a.y * o }, d = { x: n.x + c.x * o, y: n.y + c.y * o }, u = Kft({
    source: l,
    sourcePosition: e,
    target: d
  }), f = u.x !== 0 ? "x" : "y", p = u[f];
  let g = [], y, m;
  const v = { x: 0, y: 0 }, b = { x: 0, y: 0 }, [, , x, w] = vge({
    sourceX: t.x,
    sourceY: t.y,
    targetX: n.x,
    targetY: n.y
  });
  if (a[f] * c[f] === -1) {
    f === "x" ? (y = s.x ?? l.x + (d.x - l.x) * i, m = s.y ?? (l.y + d.y) / 2) : (y = s.x ?? (l.x + d.x) / 2, m = s.y ?? l.y + (d.y - l.y) * i);
    const C = [
      { x: y, y: l.y },
      { x: y, y: d.y }
    ], _ = [
      { x: l.x, y: m },
      { x: d.x, y: m }
    ];
    a[f] === p ? g = f === "x" ? C : _ : g = f === "x" ? _ : C;
  } else {
    const C = [{ x: l.x, y: d.y }], _ = [{ x: d.x, y: l.y }];
    if (f === "x" ? g = a.x === p ? _ : C : g = a.y === p ? C : _, e === r) {
      const D = Math.abs(t[f] - n[f]);
      if (D <= o) {
        const k = Math.min(o - 1, o - D);
        a[f] === p ? v[f] = (l[f] > t[f] ? -1 : 1) * k : b[f] = (d[f] > n[f] ? -1 : 1) * k;
      }
    }
    if (e !== r) {
      const D = f === "x" ? "y" : "x", k = a[f] === c[D], A = l[D] > d[D], R = l[D] < d[D];
      (a[f] === 1 && (!k && A || k && R) || a[f] !== 1 && (!k && R || k && A)) && (g = f === "x" ? C : _);
    }
    const E = { x: l.x + v.x, y: l.y + v.y }, M = { x: d.x + b.x, y: d.y + b.y }, N = Math.max(Math.abs(E.x - g[0].x), Math.abs(M.x - g[0].x)), O = Math.max(Math.abs(E.y - g[0].y), Math.abs(M.y - g[0].y));
    N >= O ? (y = (E.x + M.x) / 2, m = g[0].y) : (y = g[0].x, m = (E.y + M.y) / 2);
  }
  return [[
    t,
    { x: l.x + v.x, y: l.y + v.y },
    ...g,
    { x: d.x + b.x, y: d.y + b.y },
    n
  ], y, m, x, w];
}
function Yft(t, e, n, r) {
  const s = Math.min(lW(t, e) / 2, lW(e, n) / 2, r), { x: o, y: i } = e;
  if (t.x === o && o === n.x || t.y === i && i === n.y)
    return `L${o} ${i}`;
  if (t.y === i) {
    const l = t.x < n.x ? -1 : 1, d = t.y < n.y ? 1 : -1;
    return `L ${o + s * l},${i}Q ${o},${i} ${o},${i + s * d}`;
  }
  const a = t.x < n.x ? 1 : -1, c = t.y < n.y ? -1 : 1;
  return `L ${o},${i + s * c}Q ${o},${i} ${o + s * a},${i}`;
}
function YR({ sourceX: t, sourceY: e, sourcePosition: n = lt.Bottom, targetX: r, targetY: s, targetPosition: o = lt.Top, borderRadius: i = 5, centerX: a, centerY: c, offset: l = 20, stepPosition: d = 0.5 }) {
  const [u, f, p, g, y] = Gft({
    source: { x: t, y: e },
    sourcePosition: n,
    target: { x: r, y: s },
    targetPosition: o,
    center: { x: a, y: c },
    offset: l,
    stepPosition: d
  });
  return [u.reduce((v, b, x) => {
    let w = "";
    return x > 0 && x < u.length - 1 ? w = Yft(u[x - 1], b, u[x + 1], i) : w = `${x === 0 ? "M" : "L"}${b.x} ${b.y}`, v += w, v;
  }, ""), f, p, g, y];
}
function dW(t) {
  var e;
  return t && !!(t.internals.handleBounds || (e = t.handles) != null && e.length) && !!(t.measured.width || t.width || t.initialWidth);
}
function qft(t) {
  var u;
  const { sourceNode: e, targetNode: n } = t;
  if (!dW(e) || !dW(n))
    return null;
  const r = e.internals.handleBounds || uW(e.handles), s = n.internals.handleBounds || uW(n.handles), o = fW((r == null ? void 0 : r.source) ?? [], t.sourceHandle), i = fW(
    // when connection type is loose we can define all handles as sources and connect source -> source
    t.connectionMode === Ty.Strict ? (s == null ? void 0 : s.target) ?? [] : ((s == null ? void 0 : s.target) ?? []).concat((s == null ? void 0 : s.source) ?? []),
    t.targetHandle
  );
  if (!o || !i)
    return (u = t.onError) == null || u.call(t, "008", Ia.error008(o ? "target" : "source", {
      id: t.id,
      sourceHandle: t.sourceHandle,
      targetHandle: t.targetHandle
    })), null;
  const a = (o == null ? void 0 : o.position) || lt.Bottom, c = (i == null ? void 0 : i.position) || lt.Top, l = Kp(e, o, a), d = Kp(n, i, c);
  return {
    sourceX: l.x,
    sourceY: l.y,
    targetX: d.x,
    targetY: d.y,
    sourcePosition: a,
    targetPosition: c
  };
}
function uW(t) {
  if (!t)
    return null;
  const e = [], n = [];
  for (const r of t)
    r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? e.push(r) : r.type === "target" && n.push(r);
  return {
    source: e,
    target: n
  };
}
function Kp(t, e, n = lt.Left, r = !1) {
  const s = ((e == null ? void 0 : e.x) ?? 0) + t.internals.positionAbsolute.x, o = ((e == null ? void 0 : e.y) ?? 0) + t.internals.positionAbsolute.y, { width: i, height: a } = e ?? Su(t);
  if (r)
    return { x: s + i / 2, y: o + a / 2 };
  switch ((e == null ? void 0 : e.position) ?? n) {
    case lt.Top:
      return { x: s + i / 2, y: o };
    case lt.Right:
      return { x: s + i, y: o + a / 2 };
    case lt.Bottom:
      return { x: s + i / 2, y: o + a };
    case lt.Left:
      return { x: s, y: o + a / 2 };
  }
}
function fW(t, e) {
  return t && (e ? t.find((n) => n.id === e) : t[0]) || null;
}
function qR(t, e) {
  return t ? typeof t == "string" ? t : `${e ? `${e}__` : ""}${Object.keys(t).sort().map((r) => `${r}=${t[r]}`).join("&")}` : "";
}
function Xft(t, { id: e, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: s }) {
  const o = /* @__PURE__ */ new Set();
  return t.reduce((i, a) => ([a.markerStart || r, a.markerEnd || s].forEach((c) => {
    if (c && typeof c == "object") {
      const l = qR(c, e);
      o.has(l) || (i.push({ id: l, color: c.color || n, ...c }), o.add(l));
    }
  }), i), []).sort((i, a) => i.id.localeCompare(a.id));
}
const wge = 1e3, Zft = 10, B4 = {
  nodeOrigin: [0, 0],
  nodeExtent: zw,
  elevateNodesOnSelect: !0,
  zIndexMode: "basic",
  defaults: {}
}, Qft = {
  ...B4,
  checkEquality: !0
};
function z4(t, e) {
  const n = { ...t };
  for (const r in e)
    e[r] !== void 0 && (n[r] = e[r]);
  return n;
}
function Jft(t, e, n) {
  const r = z4(B4, n);
  for (const s of t.values())
    if (s.parentId)
      H4(s, t, e, r);
    else {
      const o = SS(s, r.nodeOrigin), i = ky(s.extent) ? s.extent : r.nodeExtent, a = Wp(o, i, Su(s));
      s.internals.positionAbsolute = a;
    }
}
function eht(t, e) {
  if (!t.handles)
    return t.measured ? e == null ? void 0 : e.internals.handleBounds : void 0;
  const n = [], r = [];
  for (const s of t.handles) {
    const o = {
      id: s.id,
      width: s.width ?? 1,
      height: s.height ?? 1,
      nodeId: t.id,
      x: s.x,
      y: s.y,
      position: s.position,
      type: s.type
    };
    s.type === "source" ? n.push(o) : s.type === "target" && r.push(o);
  }
  return {
    source: n,
    target: r
  };
}
function U4(t) {
  return t === "manual";
}
function XR(t, e, n, r = {}) {
  var l, d;
  const s = z4(Qft, r), o = { i: 0 }, i = new Map(e), a = s != null && s.elevateNodesOnSelect && !U4(s.zIndexMode) ? wge : 0;
  let c = t.length > 0;
  e.clear(), n.clear();
  for (const u of t) {
    let f = i.get(u.id);
    if (s.checkEquality && u === (f == null ? void 0 : f.internals.userNode))
      e.set(u.id, f);
    else {
      const p = SS(u, s.nodeOrigin), g = ky(u.extent) ? u.extent : s.nodeExtent, y = Wp(p, g, Su(u));
      f = {
        ...s.defaults,
        ...u,
        measured: {
          width: (l = u.measured) == null ? void 0 : l.width,
          height: (d = u.measured) == null ? void 0 : d.height
        },
        internals: {
          positionAbsolute: y,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: eht(u, f),
          z: Sge(u, a, s.zIndexMode),
          userNode: u
        }
      }, e.set(u.id, f);
    }
    (f.measured === void 0 || f.measured.width === void 0 || f.measured.height === void 0) && !f.hidden && (c = !1), u.parentId && H4(f, e, n, r, o);
  }
  return c;
}
function tht(t, e) {
  if (!t.parentId)
    return;
  const n = e.get(t.parentId);
  n ? n.set(t.id, t) : e.set(t.parentId, /* @__PURE__ */ new Map([[t.id, t]]));
}
function H4(t, e, n, r, s) {
  const { elevateNodesOnSelect: o, nodeOrigin: i, nodeExtent: a, zIndexMode: c } = z4(B4, r), l = t.parentId, d = e.get(l);
  if (!d) {
    console.warn(`Parent node ${l} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  tht(t, n), s && !d.parentId && d.internals.rootParentIndex === void 0 && c === "auto" && (d.internals.rootParentIndex = ++s.i, d.internals.z = d.internals.z + s.i * Zft), s && d.internals.rootParentIndex !== void 0 && (s.i = d.internals.rootParentIndex);
  const u = o && !U4(c) ? wge : 0, { x: f, y: p, z: g } = nht(t, d, i, a, u, c), { positionAbsolute: y } = t.internals, m = f !== y.x || p !== y.y;
  (m || g !== t.internals.z) && e.set(t.id, {
    ...t,
    internals: {
      ...t.internals,
      positionAbsolute: m ? { x: f, y: p } : y,
      z: g
    }
  });
}
function Sge(t, e, n) {
  const r = Wc(t.zIndex) ? t.zIndex : 0;
  return U4(n) ? r : r + (t.selected ? e : 0);
}
function nht(t, e, n, r, s, o) {
  const { x: i, y: a } = e.internals.positionAbsolute, c = Su(t), l = SS(t, n), d = ky(t.extent) ? Wp(l, t.extent, c) : l;
  let u = Wp({ x: i + d.x, y: a + d.y }, r, c);
  t.extent === "parent" && (u = age(u, c, e));
  const f = Sge(t, s, o), p = e.internals.z ?? 0;
  return {
    x: u.x,
    y: u.y,
    z: p >= f ? p + 1 : f
  };
}
function V4(t, e, n, r = [0, 0]) {
  var i;
  const s = [], o = /* @__PURE__ */ new Map();
  for (const a of t) {
    const c = e.get(a.parentId);
    if (!c)
      continue;
    const l = ((i = o.get(a.parentId)) == null ? void 0 : i.expandedRect) ?? Iy(c), d = lge(l, a.rect);
    o.set(a.parentId, { expandedRect: d, parent: c });
  }
  return o.size > 0 && o.forEach(({ expandedRect: a, parent: c }, l) => {
    var x;
    const d = c.internals.positionAbsolute, u = Su(c), f = c.origin ?? r, p = a.x < d.x ? Math.round(Math.abs(d.x - a.x)) : 0, g = a.y < d.y ? Math.round(Math.abs(d.y - a.y)) : 0, y = Math.max(u.width, Math.round(a.width)), m = Math.max(u.height, Math.round(a.height)), v = (y - u.width) * f[0], b = (m - u.height) * f[1];
    (p > 0 || g > 0 || v || b) && (s.push({
      id: l,
      type: "position",
      position: {
        x: c.position.x - p + v,
        y: c.position.y - g + b
      }
    }), (x = n.get(l)) == null || x.forEach((w) => {
      t.some((S) => S.id === w.id) || s.push({
        id: w.id,
        type: "position",
        position: {
          x: w.position.x + p,
          y: w.position.y + g
        }
      });
    })), (u.width < a.width || u.height < a.height || p || g) && s.push({
      id: l,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: y + (p ? f[0] * p - v : 0),
        height: m + (g ? f[1] * g - b : 0)
      }
    });
  }), s;
}
function rht(t, e, n, r, s, o, i) {
  const a = r == null ? void 0 : r.querySelector(".xyflow__viewport");
  let c = !1;
  if (!a)
    return { changes: [], updatedInternals: c };
  const l = [], d = window.getComputedStyle(a), { m22: u } = new window.DOMMatrixReadOnly(d.transform), f = [];
  for (const p of t.values()) {
    const g = e.get(p.id);
    if (!g)
      continue;
    if (g.hidden) {
      e.set(g.id, {
        ...g,
        internals: {
          ...g.internals,
          handleBounds: void 0
        }
      }), c = !0;
      continue;
    }
    const y = F4(p.nodeElement), m = g.measured.width !== y.width || g.measured.height !== y.height;
    if (!!(y.width && y.height && (m || !g.internals.handleBounds || p.force))) {
      const b = p.nodeElement.getBoundingClientRect(), x = ky(g.extent) ? g.extent : o;
      let { positionAbsolute: w } = g.internals;
      g.parentId && g.extent === "parent" ? w = age(w, y, e.get(g.parentId)) : x && (w = Wp(w, x, y));
      const S = {
        ...g,
        measured: y,
        internals: {
          ...g.internals,
          positionAbsolute: w,
          handleBounds: {
            source: iW("source", p.nodeElement, b, u, g.id),
            target: iW("target", p.nodeElement, b, u, g.id)
          }
        }
      };
      e.set(g.id, S), g.parentId && H4(S, e, n, { nodeOrigin: s, zIndexMode: i }), c = !0, m && (l.push({
        id: g.id,
        type: "dimensions",
        dimensions: y
      }), g.expandParent && g.parentId && f.push({
        id: g.id,
        parentId: g.parentId,
        rect: Iy(S, s)
      }));
    }
  }
  if (f.length > 0) {
    const p = V4(f, e, n, s);
    l.push(...p);
  }
  return { changes: l, updatedInternals: c };
}
async function sht({ delta: t, panZoom: e, transform: n, translateExtent: r, width: s, height: o }) {
  if (!e || !t.x && !t.y)
    return Promise.resolve(!1);
  const i = await e.setViewportConstrained({
    x: n[0] + t.x,
    y: n[1] + t.y,
    zoom: n[2]
  }, [
    [0, 0],
    [s, o]
  ], r), a = !!i && (i.x !== n[0] || i.y !== n[1] || i.k !== n[2]);
  return Promise.resolve(a);
}
function hW(t, e, n, r, s, o) {
  let i = s;
  const a = r.get(i) || /* @__PURE__ */ new Map();
  r.set(i, a.set(n, e)), i = `${s}-${t}`;
  const c = r.get(i) || /* @__PURE__ */ new Map();
  if (r.set(i, c.set(n, e)), o) {
    i = `${s}-${t}-${o}`;
    const l = r.get(i) || /* @__PURE__ */ new Map();
    r.set(i, l.set(n, e));
  }
}
function Cge(t, e, n) {
  t.clear(), e.clear();
  for (const r of n) {
    const { source: s, target: o, sourceHandle: i = null, targetHandle: a = null } = r, c = { edgeId: r.id, source: s, target: o, sourceHandle: i, targetHandle: a }, l = `${s}-${i}--${o}-${a}`, d = `${o}-${a}--${s}-${i}`;
    hW("source", c, d, t, s, i), hW("target", c, l, t, o, a), e.set(r.id, r);
  }
}
function _ge(t, e) {
  if (!t.parentId)
    return !1;
  const n = e.get(t.parentId);
  return n ? n.selected ? !0 : _ge(n, e) : !1;
}
function pW(t, e, n) {
  var s;
  let r = t;
  do {
    if ((s = r == null ? void 0 : r.matches) != null && s.call(r, e))
      return !0;
    if (r === n)
      return !1;
    r = r == null ? void 0 : r.parentElement;
  } while (r);
  return !1;
}
function oht(t, e, n, r) {
  const s = /* @__PURE__ */ new Map();
  for (const [o, i] of t)
    if ((i.selected || i.id === r) && (!i.parentId || !_ge(i, t)) && (i.draggable || e && typeof i.draggable > "u")) {
      const a = t.get(o);
      a && s.set(o, {
        id: o,
        position: a.position || { x: 0, y: 0 },
        distance: {
          x: n.x - a.internals.positionAbsolute.x,
          y: n.y - a.internals.positionAbsolute.y
        },
        extent: a.extent,
        parentId: a.parentId,
        origin: a.origin,
        expandParent: a.expandParent,
        internals: {
          positionAbsolute: a.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: a.measured.width ?? 0,
          height: a.measured.height ?? 0
        }
      });
    }
  return s;
}
function d2({ nodeId: t, dragItems: e, nodeLookup: n, dragging: r = !0 }) {
  var i, a, c;
  const s = [];
  for (const [l, d] of e) {
    const u = (i = n.get(l)) == null ? void 0 : i.internals.userNode;
    u && s.push({
      ...u,
      position: d.position,
      dragging: r
    });
  }
  if (!t)
    return [s[0], s];
  const o = (a = n.get(t)) == null ? void 0 : a.internals.userNode;
  return [
    o ? {
      ...o,
      position: ((c = e.get(t)) == null ? void 0 : c.position) || o.position,
      dragging: r
    } : s[0],
    s
  ];
}
function iht({ dragItems: t, snapGrid: e, x: n, y: r }) {
  const s = t.values().next().value;
  if (!s)
    return null;
  const o = {
    x: n - s.distance.x,
    y: r - s.distance.y
  }, i = _S(o, e);
  return {
    x: i.x - o.x,
    y: i.y - o.y
  };
}
function aht({ onNodeMouseDown: t, getStoreItems: e, onDragStart: n, onDrag: r, onDragStop: s }) {
  let o = { x: null, y: null }, i = 0, a = /* @__PURE__ */ new Map(), c = !1, l = { x: 0, y: 0 }, d = null, u = !1, f = null, p = !1, g = !1, y = null;
  function m({ noDragClassName: b, handleSelector: x, domNode: w, isSelectable: S, nodeId: C, nodeClickDistance: _ = 0 }) {
    f = aa(w);
    function E({ x: D, y: k }) {
      const { nodeLookup: A, nodeExtent: R, snapGrid: j, snapToGrid: $, nodeOrigin: F, onNodeDrag: L, onSelectionDrag: z, onError: H, updateNodePositions: U } = e();
      o = { x: D, y: k };
      let W = !1;
      const Z = a.size > 1, K = Z && R ? GR(CS(a)) : null, oe = Z && $ ? iht({
        dragItems: a,
        snapGrid: j,
        x: D,
        y: k
      }) : null;
      for (const [Y, ee] of a) {
        if (!A.has(Y))
          continue;
        let ae = { x: D - ee.distance.x, y: k - ee.distance.y };
        $ && (ae = oe ? {
          x: Math.round(ae.x + oe.x),
          y: Math.round(ae.y + oe.y)
        } : _S(ae, j));
        let de = null;
        if (Z && R && !ee.extent && K) {
          const { positionAbsolute: xe } = ee.internals, ge = xe.x - K.x + R[0][0], ze = xe.x + ee.measured.width - K.x2 + R[1][0], Ge = xe.y - K.y + R[0][1], Ct = xe.y + ee.measured.height - K.y2 + R[1][1];
          de = [
            [ge, Ge],
            [ze, Ct]
          ];
        }
        const { position: ye, positionAbsolute: G } = ige({
          nodeId: Y,
          nextPosition: ae,
          nodeLookup: A,
          nodeExtent: de || R,
          nodeOrigin: F,
          onError: H
        });
        W = W || ee.position.x !== ye.x || ee.position.y !== ye.y, ee.position = ye, ee.internals.positionAbsolute = G;
      }
      if (g = g || W, !!W && (U(a, !0), y && (r || L || !C && z))) {
        const [Y, ee] = d2({
          nodeId: C,
          dragItems: a,
          nodeLookup: A
        });
        r == null || r(y, a, Y, ee), L == null || L(y, Y, ee), C || z == null || z(y, ee);
      }
    }
    async function M() {
      if (!d)
        return;
      const { transform: D, panBy: k, autoPanSpeed: A, autoPanOnNodeDrag: R } = e();
      if (!R) {
        c = !1, cancelAnimationFrame(i);
        return;
      }
      const [j, $] = cge(l, d, A);
      (j !== 0 || $ !== 0) && (o.x = (o.x ?? 0) - j / D[2], o.y = (o.y ?? 0) - $ / D[2], await k({ x: j, y: $ }) && E(o)), i = requestAnimationFrame(M);
    }
    function N(D) {
      var Z;
      const { nodeLookup: k, multiSelectionActive: A, nodesDraggable: R, transform: j, snapGrid: $, snapToGrid: F, selectNodesOnDrag: L, onNodeDragStart: z, onSelectionDragStart: H, unselectNodesAndEdges: U } = e();
      u = !0, (!L || !S) && !A && C && ((Z = k.get(C)) != null && Z.selected || U()), S && L && C && (t == null || t(C));
      const W = $x(D.sourceEvent, { transform: j, snapGrid: $, snapToGrid: F, containerBounds: d });
      if (o = W, a = oht(k, R, W, C), a.size > 0 && (n || z || !C && H)) {
        const [K, oe] = d2({
          nodeId: C,
          dragItems: a,
          nodeLookup: k
        });
        n == null || n(D.sourceEvent, a, K, oe), z == null || z(D.sourceEvent, K, oe), C || H == null || H(D.sourceEvent, oe);
      }
    }
    const O = Fpe().clickDistance(_).on("start", (D) => {
      const { domNode: k, nodeDragThreshold: A, transform: R, snapGrid: j, snapToGrid: $ } = e();
      d = (k == null ? void 0 : k.getBoundingClientRect()) || null, p = !1, g = !1, y = D.sourceEvent, A === 0 && N(D), o = $x(D.sourceEvent, { transform: R, snapGrid: j, snapToGrid: $, containerBounds: d }), l = Kc(D.sourceEvent, d);
    }).on("drag", (D) => {
      const { autoPanOnNodeDrag: k, transform: A, snapGrid: R, snapToGrid: j, nodeDragThreshold: $, nodeLookup: F } = e(), L = $x(D.sourceEvent, { transform: A, snapGrid: R, snapToGrid: j, containerBounds: d });
      if (y = D.sourceEvent, (D.sourceEvent.type === "touchmove" && D.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      C && !F.has(C)) && (p = !0), !p) {
        if (!c && k && u && (c = !0, M()), !u) {
          const z = Kc(D.sourceEvent, d), H = z.x - l.x, U = z.y - l.y;
          Math.sqrt(H * H + U * U) > $ && N(D);
        }
        (o.x !== L.xSnapped || o.y !== L.ySnapped) && a && u && (l = Kc(D.sourceEvent, d), E(L));
      }
    }).on("end", (D) => {
      if (!(!u || p) && (c = !1, u = !1, cancelAnimationFrame(i), a.size > 0)) {
        const { nodeLookup: k, updateNodePositions: A, onNodeDragStop: R, onSelectionDragStop: j } = e();
        if (g && (A(a, !1), g = !1), s || R || !C && j) {
          const [$, F] = d2({
            nodeId: C,
            dragItems: a,
            nodeLookup: k,
            dragging: !1
          });
          s == null || s(D.sourceEvent, a, $, F), R == null || R(D.sourceEvent, $, F), C || j == null || j(D.sourceEvent, F);
        }
      }
    }).filter((D) => {
      const k = D.target;
      return !D.button && (!b || !pW(k, `.${b}`, w)) && (!x || pW(k, x, w));
    });
    f.call(O);
  }
  function v() {
    f == null || f.on(".drag", null);
  }
  return {
    update: m,
    destroy: v
  };
}
function cht(t, e, n) {
  const r = [], s = {
    x: t.x - n,
    y: t.y - n,
    width: n * 2,
    height: n * 2
  };
  for (const o of e.values())
    Hw(s, Iy(o)) > 0 && r.push(o);
  return r;
}
const lht = 250;
function dht(t, e, n, r) {
  var a, c;
  let s = [], o = 1 / 0;
  const i = cht(t, n, e + lht);
  for (const l of i) {
    const d = [...((a = l.internals.handleBounds) == null ? void 0 : a.source) ?? [], ...((c = l.internals.handleBounds) == null ? void 0 : c.target) ?? []];
    for (const u of d) {
      if (r.nodeId === u.nodeId && r.type === u.type && r.id === u.id)
        continue;
      const { x: f, y: p } = Kp(l, u, u.position, !0), g = Math.sqrt(Math.pow(f - t.x, 2) + Math.pow(p - t.y, 2));
      g > e || (g < o ? (s = [{ ...u, x: f, y: p }], o = g) : g === o && s.push({ ...u, x: f, y: p }));
    }
  }
  if (!s.length)
    return null;
  if (s.length > 1) {
    const l = r.type === "source" ? "target" : "source";
    return s.find((d) => d.type === l) ?? s[0];
  }
  return s[0];
}
function Ege(t, e, n, r, s, o = !1) {
  var l, d, u;
  const i = r.get(t);
  if (!i)
    return null;
  const a = s === "strict" ? (l = i.internals.handleBounds) == null ? void 0 : l[e] : [...((d = i.internals.handleBounds) == null ? void 0 : d.source) ?? [], ...((u = i.internals.handleBounds) == null ? void 0 : u.target) ?? []], c = (n ? a == null ? void 0 : a.find((f) => f.id === n) : a == null ? void 0 : a[0]) ?? null;
  return c && o ? { ...c, ...Kp(i, c, c.position, !0) } : c;
}
function Tge(t, e) {
  return t || (e != null && e.classList.contains("target") ? "target" : e != null && e.classList.contains("source") ? "source" : null);
}
function uht(t, e) {
  let n = null;
  return e ? n = !0 : t && !e && (n = !1), n;
}
const Pge = () => !0;
function fht(t, { connectionMode: e, connectionRadius: n, handleId: r, nodeId: s, edgeUpdaterType: o, isTarget: i, domNode: a, nodeLookup: c, lib: l, autoPanOnConnect: d, flowId: u, panBy: f, cancelConnection: p, onConnectStart: g, onConnect: y, onConnectEnd: m, isValidConnection: v = Pge, onReconnectEnd: b, updateConnection: x, getTransform: w, getFromHandle: S, autoPanSpeed: C, dragThreshold: _ = 1, handleDomNode: E }) {
  const M = hge(t.target);
  let N = 0, O;
  const { x: D, y: k } = Kc(t), A = Tge(o, E), R = a == null ? void 0 : a.getBoundingClientRect();
  let j = !1;
  if (!R || !A)
    return;
  const $ = Ege(s, A, r, c, e);
  if (!$)
    return;
  let F = Kc(t, R), L = !1, z = null, H = !1, U = null;
  function W() {
    if (!d || !R)
      return;
    const [ye, G] = cge(F, R, C);
    f({ x: ye, y: G }), N = requestAnimationFrame(W);
  }
  const Z = {
    ...$,
    nodeId: s,
    type: A,
    position: $.position
  }, K = c.get(s);
  let Y = {
    inProgress: !0,
    isValid: null,
    from: Kp(K, Z, lt.Left, !0),
    fromHandle: Z,
    fromPosition: Z.position,
    fromNode: K,
    to: F,
    toHandle: null,
    toPosition: nW[Z.position],
    toNode: null,
    pointer: F
  };
  function ee() {
    j = !0, x(Y), g == null || g(t, { nodeId: s, handleId: r, handleType: A });
  }
  _ === 0 && ee();
  function ae(ye) {
    if (!j) {
      const { x: Ct, y: vn } = Kc(ye), Yt = Ct - D, X = vn - k;
      if (!(Yt * Yt + X * X > _ * _))
        return;
      ee();
    }
    if (!S() || !Z) {
      de(ye);
      return;
    }
    const G = w();
    F = Kc(ye, R), O = dht(ES(F, G, !1, [1, 1]), n, c, Z), L || (W(), L = !0);
    const xe = Ige(ye, {
      handle: O,
      connectionMode: e,
      fromNodeId: s,
      fromHandleId: r,
      fromType: i ? "target" : "source",
      isValidConnection: v,
      doc: M,
      lib: l,
      flowId: u,
      nodeLookup: c
    });
    U = xe.handleDomNode, z = xe.connection, H = uht(!!O, xe.isValid);
    const ge = c.get(s), ze = ge ? Kp(ge, Z, lt.Left, !0) : Y.from, Ge = {
      ...Y,
      from: ze,
      isValid: H,
      to: xe.toHandle && H ? aP({ x: xe.toHandle.x, y: xe.toHandle.y }, G) : F,
      toHandle: xe.toHandle,
      toPosition: H && xe.toHandle ? xe.toHandle.position : nW[Z.position],
      toNode: xe.toHandle ? c.get(xe.toHandle.nodeId) : null,
      pointer: F
    };
    x(Ge), Y = Ge;
  }
  function de(ye) {
    if (!("touches" in ye && ye.touches.length > 0)) {
      if (j) {
        (O || U) && z && H && (y == null || y(z));
        const { inProgress: G, ...xe } = Y, ge = {
          ...xe,
          toPosition: Y.toHandle ? Y.toPosition : null
        };
        m == null || m(ye, ge), o && (b == null || b(ye, ge));
      }
      p(), cancelAnimationFrame(N), L = !1, H = !1, z = null, U = null, M.removeEventListener("mousemove", ae), M.removeEventListener("mouseup", de), M.removeEventListener("touchmove", ae), M.removeEventListener("touchend", de);
    }
  }
  M.addEventListener("mousemove", ae), M.addEventListener("mouseup", de), M.addEventListener("touchmove", ae), M.addEventListener("touchend", de);
}
function Ige(t, { handle: e, connectionMode: n, fromNodeId: r, fromHandleId: s, fromType: o, doc: i, lib: a, flowId: c, isValidConnection: l = Pge, nodeLookup: d }) {
  const u = o === "target", f = e ? i.querySelector(`.${a}-flow__handle[data-id="${c}-${e == null ? void 0 : e.nodeId}-${e == null ? void 0 : e.id}-${e == null ? void 0 : e.type}"]`) : null, { x: p, y: g } = Kc(t), y = i.elementFromPoint(p, g), m = y != null && y.classList.contains(`${a}-flow__handle`) ? y : f, v = {
    handleDomNode: m,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (m) {
    const b = Tge(void 0, m), x = m.getAttribute("data-nodeid"), w = m.getAttribute("data-handleid"), S = m.classList.contains("connectable"), C = m.classList.contains("connectableend");
    if (!x || !b)
      return v;
    const _ = {
      source: u ? x : r,
      sourceHandle: u ? w : s,
      target: u ? r : x,
      targetHandle: u ? s : w
    };
    v.connection = _;
    const M = S && C && (n === Ty.Strict ? u && b === "source" || !u && b === "target" : x !== r || w !== s);
    v.isValid = M && l(_), v.toHandle = Ege(x, b, w, d, n, !0);
  }
  return v;
}
const ZR = {
  onPointerDown: fht,
  isValid: Ige
};
function hht({ domNode: t, panZoom: e, getTransform: n, getViewScale: r }) {
  const s = aa(t);
  function o({ translateExtent: a, width: c, height: l, zoomStep: d = 1, pannable: u = !0, zoomable: f = !0, inversePan: p = !1 }) {
    const g = (x) => {
      if (x.sourceEvent.type !== "wheel" || !e)
        return;
      const w = n(), S = x.sourceEvent.ctrlKey && Vw() ? 10 : 1, C = -x.sourceEvent.deltaY * (x.sourceEvent.deltaMode === 1 ? 0.05 : x.sourceEvent.deltaMode ? 1 : 2e-3) * d, _ = w[2] * Math.pow(2, C * S);
      e.scaleTo(_);
    };
    let y = [0, 0];
    const m = (x) => {
      (x.sourceEvent.type === "mousedown" || x.sourceEvent.type === "touchstart") && (y = [
        x.sourceEvent.clientX ?? x.sourceEvent.touches[0].clientX,
        x.sourceEvent.clientY ?? x.sourceEvent.touches[0].clientY
      ]);
    }, v = (x) => {
      const w = n();
      if (x.sourceEvent.type !== "mousemove" && x.sourceEvent.type !== "touchmove" || !e)
        return;
      const S = [
        x.sourceEvent.clientX ?? x.sourceEvent.touches[0].clientX,
        x.sourceEvent.clientY ?? x.sourceEvent.touches[0].clientY
      ], C = [S[0] - y[0], S[1] - y[1]];
      y = S;
      const _ = r() * Math.max(w[2], Math.log(w[2])) * (p ? -1 : 1), E = {
        x: w[0] - C[0] * _,
        y: w[1] - C[1] * _
      }, M = [
        [0, 0],
        [c, l]
      ];
      e.setViewportConstrained({
        x: E.x,
        y: E.y,
        zoom: w[2]
      }, M, a);
    }, b = ege().on("start", m).on("zoom", u ? v : null).on("zoom.wheel", f ? g : null);
    s.call(b, {});
  }
  function i() {
    s.on("zoom", null);
  }
  return {
    update: o,
    destroy: i,
    pointer: Oc
  };
}
const Jk = (t) => ({
  x: t.x,
  y: t.y,
  zoom: t.k
}), u2 = ({ x: t, y: e, zoom: n }) => Xk.translate(t, e).scale(n), ym = (t, e) => t.target.closest(`.${e}`), kge = (t, e) => e === 2 && Array.isArray(t) && t.includes(2), pht = (t) => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2, f2 = (t, e = 0, n = pht, r = () => {
}) => {
  const s = typeof e == "number" && e > 0;
  return s || r(), s ? t.transition().duration(e).ease(n).on("end", r) : t;
}, Age = (t) => {
  const e = t.ctrlKey && Vw() ? 10 : 1;
  return -t.deltaY * (t.deltaMode === 1 ? 0.05 : t.deltaMode ? 1 : 2e-3) * e;
};
function ght({ zoomPanValues: t, noWheelClassName: e, d3Selection: n, d3Zoom: r, panOnScrollMode: s, panOnScrollSpeed: o, zoomOnPinch: i, onPanZoomStart: a, onPanZoom: c, onPanZoomEnd: l }) {
  return (d) => {
    if (ym(d, e))
      return d.ctrlKey && d.preventDefault(), !1;
    d.preventDefault(), d.stopImmediatePropagation();
    const u = n.property("__zoom").k || 1;
    if (d.ctrlKey && i) {
      const m = Oc(d), v = Age(d), b = u * Math.pow(2, v);
      r.scaleTo(n, b, m, d);
      return;
    }
    const f = d.deltaMode === 1 ? 20 : 1;
    let p = s === pp.Vertical ? 0 : d.deltaX * f, g = s === pp.Horizontal ? 0 : d.deltaY * f;
    !Vw() && d.shiftKey && s !== pp.Vertical && (p = d.deltaY * f, g = 0), r.translateBy(
      n,
      -(p / u) * o,
      -(g / u) * o,
      // @ts-ignore
      { internal: !0 }
    );
    const y = Jk(n.property("__zoom"));
    clearTimeout(t.panScrollTimeout), t.isPanScrolling ? (c == null || c(d, y), t.panScrollTimeout = setTimeout(() => {
      l == null || l(d, y), t.isPanScrolling = !1;
    }, 150)) : (t.isPanScrolling = !0, a == null || a(d, y));
  };
}
function mht({ noWheelClassName: t, preventScrolling: e, d3ZoomHandler: n }) {
  return function(r, s) {
    const o = r.type === "wheel", i = !e && o && !r.ctrlKey, a = ym(r, t);
    if (r.ctrlKey && o && a && r.preventDefault(), i || a)
      return null;
    r.preventDefault(), n.call(this, r, s);
  };
}
function yht({ zoomPanValues: t, onDraggingChange: e, onPanZoomStart: n }) {
  return (r) => {
    var o, i, a;
    if ((o = r.sourceEvent) != null && o.internal)
      return;
    const s = Jk(r.transform);
    t.mouseButton = ((i = r.sourceEvent) == null ? void 0 : i.button) || 0, t.isZoomingOrPanning = !0, t.prevViewport = s, ((a = r.sourceEvent) == null ? void 0 : a.type) === "mousedown" && e(!0), n && (n == null || n(r.sourceEvent, s));
  };
}
function vht({ zoomPanValues: t, panOnDrag: e, onPaneContextMenu: n, onTransformChange: r, onPanZoom: s }) {
  return (o) => {
    var i, a;
    t.usedRightMouseButton = !!(n && kge(e, t.mouseButton ?? 0)), (i = o.sourceEvent) != null && i.sync || r([o.transform.x, o.transform.y, o.transform.k]), s && !((a = o.sourceEvent) != null && a.internal) && (s == null || s(o.sourceEvent, Jk(o.transform)));
  };
}
function bht({ zoomPanValues: t, panOnDrag: e, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: s, onPaneContextMenu: o }) {
  return (i) => {
    var a;
    if (!((a = i.sourceEvent) != null && a.internal) && (t.isZoomingOrPanning = !1, o && kge(e, t.mouseButton ?? 0) && !t.usedRightMouseButton && i.sourceEvent && o(i.sourceEvent), t.usedRightMouseButton = !1, r(!1), s)) {
      const c = Jk(i.transform);
      t.prevViewport = c, clearTimeout(t.timerId), t.timerId = setTimeout(
        () => {
          s == null || s(i.sourceEvent, c);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        n ? 150 : 0
      );
    }
  };
}
function xht({ zoomActivationKeyPressed: t, zoomOnScroll: e, zoomOnPinch: n, panOnDrag: r, panOnScroll: s, zoomOnDoubleClick: o, userSelectionActive: i, noWheelClassName: a, noPanClassName: c, lib: l, connectionInProgress: d }) {
  return (u) => {
    var m;
    const f = t || e, p = n && u.ctrlKey, g = u.type === "wheel";
    if (u.button === 1 && u.type === "mousedown" && (ym(u, `${l}-flow__node`) || ym(u, `${l}-flow__edge`)))
      return !0;
    if (!r && !f && !s && !o && !n || i || d && !g || ym(u, a) && g || ym(u, c) && (!g || s && g && !t) || !n && u.ctrlKey && g)
      return !1;
    if (!n && u.type === "touchstart" && ((m = u.touches) == null ? void 0 : m.length) > 1)
      return u.preventDefault(), !1;
    if (!f && !s && !p && g || !r && (u.type === "mousedown" || u.type === "touchstart") || Array.isArray(r) && !r.includes(u.button) && u.type === "mousedown")
      return !1;
    const y = Array.isArray(r) && r.includes(u.button) || !u.button || u.button <= 1;
    return (!u.ctrlKey || g) && y;
  };
}
function wht({ domNode: t, minZoom: e, maxZoom: n, translateExtent: r, viewport: s, onPanZoom: o, onPanZoomStart: i, onPanZoomEnd: a, onDraggingChange: c }) {
  const l = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, d = t.getBoundingClientRect(), u = ege().scaleExtent([e, n]).translateExtent(r), f = aa(t).call(u);
  b({
    x: s.x,
    y: s.y,
    zoom: Py(s.zoom, e, n)
  }, [
    [0, 0],
    [d.width, d.height]
  ], r);
  const p = f.on("wheel.zoom"), g = f.on("dblclick.zoom");
  u.wheelDelta(Age);
  function y(O, D) {
    return f ? new Promise((k) => {
      u == null || u.interpolate((D == null ? void 0 : D.interpolate) === "linear" ? Rx : O_).transform(f2(f, D == null ? void 0 : D.duration, D == null ? void 0 : D.ease, () => k(!0)), O);
    }) : Promise.resolve(!1);
  }
  function m({ noWheelClassName: O, noPanClassName: D, onPaneContextMenu: k, userSelectionActive: A, panOnScroll: R, panOnDrag: j, panOnScrollMode: $, panOnScrollSpeed: F, preventScrolling: L, zoomOnPinch: z, zoomOnScroll: H, zoomOnDoubleClick: U, zoomActivationKeyPressed: W, lib: Z, onTransformChange: K, connectionInProgress: oe, paneClickDistance: Y, selectionOnDrag: ee }) {
    A && !l.isZoomingOrPanning && v();
    const ae = R && !W && !A;
    u.clickDistance(ee ? 1 / 0 : !Wc(Y) || Y < 0 ? 0 : Y);
    const de = ae ? ght({
      zoomPanValues: l,
      noWheelClassName: O,
      d3Selection: f,
      d3Zoom: u,
      panOnScrollMode: $,
      panOnScrollSpeed: F,
      zoomOnPinch: z,
      onPanZoomStart: i,
      onPanZoom: o,
      onPanZoomEnd: a
    }) : mht({
      noWheelClassName: O,
      preventScrolling: L,
      d3ZoomHandler: p
    });
    if (f.on("wheel.zoom", de, { passive: !1 }), !A) {
      const G = yht({
        zoomPanValues: l,
        onDraggingChange: c,
        onPanZoomStart: i
      });
      u.on("start", G);
      const xe = vht({
        zoomPanValues: l,
        panOnDrag: j,
        onPaneContextMenu: !!k,
        onPanZoom: o,
        onTransformChange: K
      });
      u.on("zoom", xe);
      const ge = bht({
        zoomPanValues: l,
        panOnDrag: j,
        panOnScroll: R,
        onPaneContextMenu: k,
        onPanZoomEnd: a,
        onDraggingChange: c
      });
      u.on("end", ge);
    }
    const ye = xht({
      zoomActivationKeyPressed: W,
      panOnDrag: j,
      zoomOnScroll: H,
      panOnScroll: R,
      zoomOnDoubleClick: U,
      zoomOnPinch: z,
      userSelectionActive: A,
      noPanClassName: D,
      noWheelClassName: O,
      lib: Z,
      connectionInProgress: oe
    });
    u.filter(ye), U ? f.on("dblclick.zoom", g) : f.on("dblclick.zoom", null);
  }
  function v() {
    u.on("zoom", null);
  }
  async function b(O, D, k) {
    const A = u2(O), R = u == null ? void 0 : u.constrain()(A, D, k);
    return R && await y(R), new Promise((j) => j(R));
  }
  async function x(O, D) {
    const k = u2(O);
    return await y(k, D), new Promise((A) => A(k));
  }
  function w(O) {
    if (f) {
      const D = u2(O), k = f.property("__zoom");
      (k.k !== O.zoom || k.x !== O.x || k.y !== O.y) && (u == null || u.transform(f, D, null, { sync: !0 }));
    }
  }
  function S() {
    const O = f ? Jpe(f.node()) : { x: 0, y: 0, k: 1 };
    return { x: O.x, y: O.y, zoom: O.k };
  }
  function C(O, D) {
    return f ? new Promise((k) => {
      u == null || u.interpolate((D == null ? void 0 : D.interpolate) === "linear" ? Rx : O_).scaleTo(f2(f, D == null ? void 0 : D.duration, D == null ? void 0 : D.ease, () => k(!0)), O);
    }) : Promise.resolve(!1);
  }
  function _(O, D) {
    return f ? new Promise((k) => {
      u == null || u.interpolate((D == null ? void 0 : D.interpolate) === "linear" ? Rx : O_).scaleBy(f2(f, D == null ? void 0 : D.duration, D == null ? void 0 : D.ease, () => k(!0)), O);
    }) : Promise.resolve(!1);
  }
  function E(O) {
    u == null || u.scaleExtent(O);
  }
  function M(O) {
    u == null || u.translateExtent(O);
  }
  function N(O) {
    const D = !Wc(O) || O < 0 ? 0 : O;
    u == null || u.clickDistance(D);
  }
  return {
    update: m,
    destroy: v,
    setViewport: x,
    setViewportConstrained: b,
    getViewport: S,
    scaleTo: C,
    scaleBy: _,
    setScaleExtent: E,
    setTranslateExtent: M,
    syncViewport: w,
    setClickDistance: N
  };
}
var Ay;
(function(t) {
  t.Line = "line", t.Handle = "handle";
})(Ay || (Ay = {}));
function Sht({ width: t, prevWidth: e, height: n, prevHeight: r, affectsX: s, affectsY: o }) {
  const i = t - e, a = n - r, c = [i > 0 ? 1 : i < 0 ? -1 : 0, a > 0 ? 1 : a < 0 ? -1 : 0];
  return i && s && (c[0] = c[0] * -1), a && o && (c[1] = c[1] * -1), c;
}
function gW(t) {
  const e = t.includes("right") || t.includes("left"), n = t.includes("bottom") || t.includes("top"), r = t.includes("left"), s = t.includes("top");
  return {
    isHorizontal: e,
    isVertical: n,
    affectsX: r,
    affectsY: s
  };
}
function Ru(t, e) {
  return Math.max(0, e - t);
}
function $u(t, e) {
  return Math.max(0, t - e);
}
function bC(t, e, n) {
  return Math.max(0, e - t, t - n);
}
function mW(t, e) {
  return t ? !e : e;
}
function Cht(t, e, n, r, s, o, i, a) {
  let { affectsX: c, affectsY: l } = e;
  const { isHorizontal: d, isVertical: u } = e, f = d && u, { xSnapped: p, ySnapped: g } = n, { minWidth: y, maxWidth: m, minHeight: v, maxHeight: b } = r, { x, y: w, width: S, height: C, aspectRatio: _ } = t;
  let E = Math.floor(d ? p - t.pointerX : 0), M = Math.floor(u ? g - t.pointerY : 0);
  const N = S + (c ? -E : E), O = C + (l ? -M : M), D = -o[0] * S, k = -o[1] * C;
  let A = bC(N, y, m), R = bC(O, v, b);
  if (i) {
    let F = 0, L = 0;
    c && E < 0 ? F = Ru(x + E + D, i[0][0]) : !c && E > 0 && (F = $u(x + N + D, i[1][0])), l && M < 0 ? L = Ru(w + M + k, i[0][1]) : !l && M > 0 && (L = $u(w + O + k, i[1][1])), A = Math.max(A, F), R = Math.max(R, L);
  }
  if (a) {
    let F = 0, L = 0;
    c && E > 0 ? F = $u(x + E, a[0][0]) : !c && E < 0 && (F = Ru(x + N, a[1][0])), l && M > 0 ? L = $u(w + M, a[0][1]) : !l && M < 0 && (L = Ru(w + O, a[1][1])), A = Math.max(A, F), R = Math.max(R, L);
  }
  if (s) {
    if (d) {
      const F = bC(N / _, v, b) * _;
      if (A = Math.max(A, F), i) {
        let L = 0;
        !c && !l || c && !l && f ? L = $u(w + k + N / _, i[1][1]) * _ : L = Ru(w + k + (c ? E : -E) / _, i[0][1]) * _, A = Math.max(A, L);
      }
      if (a) {
        let L = 0;
        !c && !l || c && !l && f ? L = Ru(w + N / _, a[1][1]) * _ : L = $u(w + (c ? E : -E) / _, a[0][1]) * _, A = Math.max(A, L);
      }
    }
    if (u) {
      const F = bC(O * _, y, m) / _;
      if (R = Math.max(R, F), i) {
        let L = 0;
        !c && !l || l && !c && f ? L = $u(x + O * _ + D, i[1][0]) / _ : L = Ru(x + (l ? M : -M) * _ + D, i[0][0]) / _, R = Math.max(R, L);
      }
      if (a) {
        let L = 0;
        !c && !l || l && !c && f ? L = Ru(x + O * _, a[1][0]) / _ : L = $u(x + (l ? M : -M) * _, a[0][0]) / _, R = Math.max(R, L);
      }
    }
  }
  M = M + (M < 0 ? R : -R), E = E + (E < 0 ? A : -A), s && (f ? N > O * _ ? M = (mW(c, l) ? -E : E) / _ : E = (mW(c, l) ? -M : M) * _ : d ? (M = E / _, l = c) : (E = M * _, c = l));
  const j = c ? x + E : x, $ = l ? w + M : w;
  return {
    width: S + (c ? -E : E),
    height: C + (l ? -M : M),
    x: o[0] * E * (c ? -1 : 1) + j,
    y: o[1] * M * (l ? -1 : 1) + $
  };
}
const Mge = { width: 0, height: 0, x: 0, y: 0 }, _ht = {
  ...Mge,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function Eht(t) {
  return [
    [0, 0],
    [t.measured.width, t.measured.height]
  ];
}
function Tht(t, e, n) {
  const r = e.position.x + t.position.x, s = e.position.y + t.position.y, o = t.measured.width ?? 0, i = t.measured.height ?? 0, a = n[0] * o, c = n[1] * i;
  return [
    [r - a, s - c],
    [r + o - a, s + i - c]
  ];
}
function Pht({ domNode: t, nodeId: e, getStoreItems: n, onChange: r, onEnd: s }) {
  const o = aa(t);
  let i = {
    controlDirection: gW("bottom-right"),
    boundaries: {
      minWidth: 0,
      minHeight: 0,
      maxWidth: Number.MAX_VALUE,
      maxHeight: Number.MAX_VALUE
    },
    resizeDirection: void 0,
    keepAspectRatio: !1
  };
  function a({ controlPosition: l, boundaries: d, keepAspectRatio: u, resizeDirection: f, onResizeStart: p, onResize: g, onResizeEnd: y, shouldResize: m }) {
    let v = { ...Mge }, b = { ..._ht };
    i = {
      boundaries: d,
      resizeDirection: f,
      keepAspectRatio: u,
      controlDirection: gW(l)
    };
    let x, w = null, S = [], C, _, E, M = !1;
    const N = Fpe().on("start", (O) => {
      const { nodeLookup: D, transform: k, snapGrid: A, snapToGrid: R, nodeOrigin: j, paneDomNode: $ } = n();
      if (x = D.get(e), !x)
        return;
      w = ($ == null ? void 0 : $.getBoundingClientRect()) ?? null;
      const { xSnapped: F, ySnapped: L } = $x(O.sourceEvent, {
        transform: k,
        snapGrid: A,
        snapToGrid: R,
        containerBounds: w
      });
      v = {
        width: x.measured.width ?? 0,
        height: x.measured.height ?? 0,
        x: x.position.x ?? 0,
        y: x.position.y ?? 0
      }, b = {
        ...v,
        pointerX: F,
        pointerY: L,
        aspectRatio: v.width / v.height
      }, C = void 0, x.parentId && (x.extent === "parent" || x.expandParent) && (C = D.get(x.parentId), _ = C && x.extent === "parent" ? Eht(C) : void 0), S = [], E = void 0;
      for (const [z, H] of D)
        if (H.parentId === e && (S.push({
          id: z,
          position: { ...H.position },
          extent: H.extent
        }), H.extent === "parent" || H.expandParent)) {
          const U = Tht(H, x, H.origin ?? j);
          E ? E = [
            [Math.min(U[0][0], E[0][0]), Math.min(U[0][1], E[0][1])],
            [Math.max(U[1][0], E[1][0]), Math.max(U[1][1], E[1][1])]
          ] : E = U;
        }
      p == null || p(O, { ...v });
    }).on("drag", (O) => {
      const { transform: D, snapGrid: k, snapToGrid: A, nodeOrigin: R } = n(), j = $x(O.sourceEvent, {
        transform: D,
        snapGrid: k,
        snapToGrid: A,
        containerBounds: w
      }), $ = [];
      if (!x)
        return;
      const { x: F, y: L, width: z, height: H } = v, U = {}, W = x.origin ?? R, { width: Z, height: K, x: oe, y: Y } = Cht(b, i.controlDirection, j, i.boundaries, i.keepAspectRatio, W, _, E), ee = Z !== z, ae = K !== H, de = oe !== F && ee, ye = Y !== L && ae;
      if (!de && !ye && !ee && !ae)
        return;
      if ((de || ye || W[0] === 1 || W[1] === 1) && (U.x = de ? oe : v.x, U.y = ye ? Y : v.y, v.x = U.x, v.y = U.y, S.length > 0)) {
        const ze = oe - F, Ge = Y - L;
        for (const Ct of S)
          Ct.position = {
            x: Ct.position.x - ze + W[0] * (Z - z),
            y: Ct.position.y - Ge + W[1] * (K - H)
          }, $.push(Ct);
      }
      if ((ee || ae) && (U.width = ee && (!i.resizeDirection || i.resizeDirection === "horizontal") ? Z : v.width, U.height = ae && (!i.resizeDirection || i.resizeDirection === "vertical") ? K : v.height, v.width = U.width, v.height = U.height), C && x.expandParent) {
        const ze = W[0] * (U.width ?? 0);
        U.x && U.x < ze && (v.x = ze, b.x = b.x - (U.x - ze));
        const Ge = W[1] * (U.height ?? 0);
        U.y && U.y < Ge && (v.y = Ge, b.y = b.y - (U.y - Ge));
      }
      const G = Sht({
        width: v.width,
        prevWidth: z,
        height: v.height,
        prevHeight: H,
        affectsX: i.controlDirection.affectsX,
        affectsY: i.controlDirection.affectsY
      }), xe = { ...v, direction: G };
      (m == null ? void 0 : m(O, xe)) !== !1 && (M = !0, g == null || g(O, xe), r(U, $));
    }).on("end", (O) => {
      M && (y == null || y(O, { ...v }), s == null || s({ ...v }), M = !1);
    });
    o.call(N);
  }
  function c() {
    o.on(".drag", null);
  }
  return {
    update: a,
    destroy: c
  };
}
var QR = { exports: {} }, h2 = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yW;
function Iht() {
  if (yW) return h2;
  yW = 1;
  var t = B, e = r5();
  function n(l, d) {
    return l === d && (l !== 0 || 1 / l === 1 / d) || l !== l && d !== d;
  }
  var r = typeof Object.is == "function" ? Object.is : n, s = e.useSyncExternalStore, o = t.useRef, i = t.useEffect, a = t.useMemo, c = t.useDebugValue;
  return h2.useSyncExternalStoreWithSelector = function(l, d, u, f, p) {
    var g = o(null);
    if (g.current === null) {
      var y = { hasValue: !1, value: null };
      g.current = y;
    } else y = g.current;
    g = a(
      function() {
        function v(C) {
          if (!b) {
            if (b = !0, x = C, C = f(C), p !== void 0 && y.hasValue) {
              var _ = y.value;
              if (p(_, C))
                return w = _;
            }
            return w = C;
          }
          if (_ = w, r(x, C)) return _;
          var E = f(C);
          return p !== void 0 && p(_, E) ? (x = C, _) : (x = C, w = E);
        }
        var b = !1, x, w, S = u === void 0 ? null : u;
        return [
          function() {
            return v(d());
          },
          S === null ? void 0 : function() {
            return v(S());
          }
        ];
      },
      [d, u, f, p]
    );
    var m = s(l, g[0], g[1]);
    return i(
      function() {
        y.hasValue = !0, y.value = m;
      },
      [m]
    ), c(m), m;
  }, h2;
}
var p2 = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vW;
function kht() {
  return vW || (vW = 1, process.env.NODE_ENV !== "production" && function() {
    function t(l, d) {
      return l === d && (l !== 0 || 1 / l === 1 / d) || l !== l && d !== d;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var e = B, n = r5(), r = typeof Object.is == "function" ? Object.is : t, s = n.useSyncExternalStore, o = e.useRef, i = e.useEffect, a = e.useMemo, c = e.useDebugValue;
    p2.useSyncExternalStoreWithSelector = function(l, d, u, f, p) {
      var g = o(null);
      if (g.current === null) {
        var y = { hasValue: !1, value: null };
        g.current = y;
      } else y = g.current;
      g = a(
        function() {
          function v(C) {
            if (!b) {
              if (b = !0, x = C, C = f(C), p !== void 0 && y.hasValue) {
                var _ = y.value;
                if (p(_, C))
                  return w = _;
              }
              return w = C;
            }
            if (_ = w, r(x, C))
              return _;
            var E = f(C);
            return p !== void 0 && p(_, E) ? (x = C, _) : (x = C, w = E);
          }
          var b = !1, x, w, S = u === void 0 ? null : u;
          return [
            function() {
              return v(d());
            },
            S === null ? void 0 : function() {
              return v(S());
            }
          ];
        },
        [d, u, f, p]
      );
      var m = s(l, g[0], g[1]);
      return i(
        function() {
          y.hasValue = !0, y.value = m;
        },
        [m]
      ), c(m), m;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), p2;
}
process.env.NODE_ENV === "production" ? QR.exports = Iht() : QR.exports = kht();
var Aht = QR.exports;
const Mht = /* @__PURE__ */ Wr(Aht), Oht = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, bW = (t) => {
  let e;
  const n = /* @__PURE__ */ new Set(), r = (d, u) => {
    const f = typeof d == "function" ? d(e) : d;
    if (!Object.is(f, e)) {
      const p = e;
      e = u ?? (typeof f != "object" || f === null) ? f : Object.assign({}, e, f), n.forEach((g) => g(e, p));
    }
  }, s = () => e, c = { setState: r, getState: s, getInitialState: () => l, subscribe: (d) => (n.add(d), () => n.delete(d)), destroy: () => {
    (Oht ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, l = e = t(r, s, c);
  return c;
}, Dht = (t) => t ? bW(t) : bW, { useDebugValue: Nht } = B, { useSyncExternalStoreWithSelector: jht } = Mht, Rht = (t) => t;
function Oge(t, e = Rht, n) {
  const r = jht(
    t.subscribe,
    t.getState,
    t.getServerState || t.getInitialState,
    e,
    n
  );
  return Nht(r), r;
}
const xW = (t, e) => {
  const n = Dht(t), r = (s, o = e) => Oge(n, s, o);
  return Object.assign(r, n), r;
}, $ht = (t, e) => t ? xW(t, e) : xW;
function lr(t, e) {
  if (Object.is(t, e))
    return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  if (t instanceof Map && e instanceof Map) {
    if (t.size !== e.size) return !1;
    for (const [r, s] of t)
      if (!Object.is(s, e.get(r)))
        return !1;
    return !0;
  }
  if (t instanceof Set && e instanceof Set) {
    if (t.size !== e.size) return !1;
    for (const r of t)
      if (!e.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(t);
  if (n.length !== Object.keys(e).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(e, r) || !Object.is(t[r], e[r]))
      return !1;
  return !0;
}
const eA = zn(null), Lht = eA.Provider, Dge = Ia.error001();
function cn(t, e) {
  const n = tn(eA);
  if (n === null)
    throw new Error(Dge);
  return Oge(n, t, e);
}
function dr() {
  const t = tn(eA);
  if (t === null)
    throw new Error(Dge);
  return Ke(() => ({
    getState: t.getState,
    setState: t.setState,
    subscribe: t.subscribe
  }), [t]);
}
const wW = { display: "none" }, Fht = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, Nge = "react-flow__node-desc", jge = "react-flow__edge-desc", Bht = "react-flow__aria-live", zht = (t) => t.ariaLiveMessage, Uht = (t) => t.ariaLabelConfig;
function Hht({ rfId: t }) {
  const e = cn(zht);
  return h.jsx("div", { id: `${Bht}-${t}`, "aria-live": "assertive", "aria-atomic": "true", style: Fht, children: e });
}
function Vht({ rfId: t, disableKeyboardA11y: e }) {
  const n = cn(Uht);
  return h.jsxs(h.Fragment, { children: [h.jsx("div", { id: `${Nge}-${t}`, style: wW, children: e ? n["node.a11yDescription.default"] : n["node.a11yDescription.keyboardDisabled"] }), h.jsx("div", { id: `${jge}-${t}`, style: wW, children: n["edge.a11yDescription.default"] }), !e && h.jsx(Hht, { rfId: t })] });
}
const tA = du(({ position: t = "top-left", children: e, className: n, style: r, ...s }, o) => {
  const i = `${t}`.split("-");
  return h.jsx("div", { className: ds(["react-flow__panel", n, ...i]), style: r, ref: o, ...s, children: e });
});
tA.displayName = "Panel";
function Wht({ proOptions: t, position: e = "bottom-right" }) {
  return t != null && t.hideAttribution ? null : h.jsx(tA, { position: e, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: h.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const Kht = (t) => {
  const e = [], n = [];
  for (const [, r] of t.nodeLookup)
    r.selected && e.push(r.internals.userNode);
  for (const [, r] of t.edgeLookup)
    r.selected && n.push(r);
  return { selectedNodes: e, selectedEdges: n };
}, xC = (t) => t.id;
function Ght(t, e) {
  return lr(t.selectedNodes.map(xC), e.selectedNodes.map(xC)) && lr(t.selectedEdges.map(xC), e.selectedEdges.map(xC));
}
function Yht({ onSelectionChange: t }) {
  const e = dr(), { selectedNodes: n, selectedEdges: r } = cn(Kht, Ght);
  return me(() => {
    const s = { nodes: n, edges: r };
    t == null || t(s), e.getState().onSelectionChangeHandlers.forEach((o) => o(s));
  }, [n, r, t]), null;
}
const qht = (t) => !!t.onSelectionChangeHandlers;
function Xht({ onSelectionChange: t }) {
  const e = cn(qht);
  return t || e ? h.jsx(Yht, { onSelectionChange: t }) : null;
}
const Rge = [0, 0], Zht = { x: 0, y: 0, zoom: 1 }, Qht = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "autoPanOnNodeFocus",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "connectionDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "ariaLabelConfig",
  "zIndexMode"
], SW = [...Qht, "rfId"], Jht = (t) => ({
  setNodes: t.setNodes,
  setEdges: t.setEdges,
  setMinZoom: t.setMinZoom,
  setMaxZoom: t.setMaxZoom,
  setTranslateExtent: t.setTranslateExtent,
  setNodeExtent: t.setNodeExtent,
  reset: t.reset,
  setDefaultNodesAndEdges: t.setDefaultNodesAndEdges
}), CW = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: zw,
  nodeOrigin: Rge,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1"
};
function ept(t) {
  const { setNodes: e, setEdges: n, setMinZoom: r, setMaxZoom: s, setTranslateExtent: o, setNodeExtent: i, reset: a, setDefaultNodesAndEdges: c } = cn(Jht, lr), l = dr();
  me(() => (c(t.defaultNodes, t.defaultEdges), () => {
    d.current = CW, a();
  }), []);
  const d = fe(CW);
  return me(
    () => {
      for (const u of SW) {
        const f = t[u], p = d.current[u];
        f !== p && (typeof t[u] > "u" || (u === "nodes" ? e(f) : u === "edges" ? n(f) : u === "minZoom" ? r(f) : u === "maxZoom" ? s(f) : u === "translateExtent" ? o(f) : u === "nodeExtent" ? i(f) : u === "ariaLabelConfig" ? l.setState({ ariaLabelConfig: Bft(f) }) : u === "fitView" ? l.setState({ fitViewQueued: f }) : u === "fitViewOptions" ? l.setState({ fitViewOptions: f }) : l.setState({ [u]: f })));
      }
      d.current = t;
    },
    // Only re-run the effect if one of the fields we track changes
    SW.map((u) => t[u])
  ), null;
}
function _W() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function tpt(t) {
  var r;
  const [e, n] = he(t === "system" ? null : t);
  return me(() => {
    if (t !== "system") {
      n(t);
      return;
    }
    const s = _W(), o = () => n(s != null && s.matches ? "dark" : "light");
    return o(), s == null || s.addEventListener("change", o), () => {
      s == null || s.removeEventListener("change", o);
    };
  }, [t]), e !== null ? e : (r = _W()) != null && r.matches ? "dark" : "light";
}
const EW = typeof document < "u" ? document : null;
function Ww(t = null, e = { target: EW, actInsideInputWithModifier: !0 }) {
  const [n, r] = he(!1), s = fe(!1), o = fe(/* @__PURE__ */ new Set([])), [i, a] = Ke(() => {
    if (t !== null) {
      const l = (Array.isArray(t) ? t : [t]).filter((u) => typeof u == "string").map((u) => u.replace("+", `
`).replace(`

`, `
+`).split(`
`)), d = l.reduce((u, f) => u.concat(...f), []);
      return [l, d];
    }
    return [[], []];
  }, [t]);
  return me(() => {
    const c = (e == null ? void 0 : e.target) ?? EW, l = (e == null ? void 0 : e.actInsideInputWithModifier) ?? !0;
    if (t !== null) {
      const d = (p) => {
        var m, v;
        if (s.current = p.ctrlKey || p.metaKey || p.shiftKey || p.altKey, (!s.current || s.current && !l) && pge(p))
          return !1;
        const y = PW(p.code, a);
        if (o.current.add(p[y]), TW(i, o.current, !1)) {
          const b = ((v = (m = p.composedPath) == null ? void 0 : m.call(p)) == null ? void 0 : v[0]) || p.target, x = (b == null ? void 0 : b.nodeName) === "BUTTON" || (b == null ? void 0 : b.nodeName) === "A";
          e.preventDefault !== !1 && (s.current || !x) && p.preventDefault(), r(!0);
        }
      }, u = (p) => {
        const g = PW(p.code, a);
        TW(i, o.current, !0) ? (r(!1), o.current.clear()) : o.current.delete(p[g]), p.key === "Meta" && o.current.clear(), s.current = !1;
      }, f = () => {
        o.current.clear(), r(!1);
      };
      return c == null || c.addEventListener("keydown", d), c == null || c.addEventListener("keyup", u), window.addEventListener("blur", f), window.addEventListener("contextmenu", f), () => {
        c == null || c.removeEventListener("keydown", d), c == null || c.removeEventListener("keyup", u), window.removeEventListener("blur", f), window.removeEventListener("contextmenu", f);
      };
    }
  }, [t, r]), n;
}
function TW(t, e, n) {
  return t.filter((r) => n || r.length === e.size).some((r) => r.every((s) => e.has(s)));
}
function PW(t, e) {
  return e.includes(t) ? "code" : "key";
}
const npt = () => {
  const t = dr();
  return Ke(() => ({
    zoomIn: (e) => {
      const { panZoom: n } = t.getState();
      return n ? n.scaleBy(1.2, { duration: e == null ? void 0 : e.duration }) : Promise.resolve(!1);
    },
    zoomOut: (e) => {
      const { panZoom: n } = t.getState();
      return n ? n.scaleBy(1 / 1.2, { duration: e == null ? void 0 : e.duration }) : Promise.resolve(!1);
    },
    zoomTo: (e, n) => {
      const { panZoom: r } = t.getState();
      return r ? r.scaleTo(e, { duration: n == null ? void 0 : n.duration }) : Promise.resolve(!1);
    },
    getZoom: () => t.getState().transform[2],
    setViewport: async (e, n) => {
      const { transform: [r, s, o], panZoom: i } = t.getState();
      return i ? (await i.setViewport({
        x: e.x ?? r,
        y: e.y ?? s,
        zoom: e.zoom ?? o
      }, n), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [e, n, r] = t.getState().transform;
      return { x: e, y: n, zoom: r };
    },
    setCenter: async (e, n, r) => t.getState().setCenter(e, n, r),
    fitBounds: async (e, n) => {
      const { width: r, height: s, minZoom: o, maxZoom: i, panZoom: a } = t.getState(), c = L4(e, r, s, o, i, (n == null ? void 0 : n.padding) ?? 0.1);
      return a ? (await a.setViewport(c, {
        duration: n == null ? void 0 : n.duration,
        ease: n == null ? void 0 : n.ease,
        interpolate: n == null ? void 0 : n.interpolate
      }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (e, n = {}) => {
      const { transform: r, snapGrid: s, snapToGrid: o, domNode: i } = t.getState();
      if (!i)
        return e;
      const { x: a, y: c } = i.getBoundingClientRect(), l = {
        x: e.x - a,
        y: e.y - c
      }, d = n.snapGrid ?? s, u = n.snapToGrid ?? o;
      return ES(l, r, u, d);
    },
    flowToScreenPosition: (e) => {
      const { transform: n, domNode: r } = t.getState();
      if (!r)
        return e;
      const { x: s, y: o } = r.getBoundingClientRect(), i = aP(e, n);
      return {
        x: i.x + s,
        y: i.y + o
      };
    }
  }), []);
};
function $ge(t, e) {
  const n = [], r = /* @__PURE__ */ new Map(), s = [];
  for (const o of t)
    if (o.type === "add") {
      s.push(o);
      continue;
    } else if (o.type === "remove" || o.type === "replace")
      r.set(o.id, [o]);
    else {
      const i = r.get(o.id);
      i ? i.push(o) : r.set(o.id, [o]);
    }
  for (const o of e) {
    const i = r.get(o.id);
    if (!i) {
      n.push(o);
      continue;
    }
    if (i[0].type === "remove")
      continue;
    if (i[0].type === "replace") {
      n.push({ ...i[0].item });
      continue;
    }
    const a = { ...o };
    for (const c of i)
      rpt(c, a);
    n.push(a);
  }
  return s.length && s.forEach((o) => {
    o.index !== void 0 ? n.splice(o.index, 0, { ...o.item }) : n.push({ ...o.item });
  }), n;
}
function rpt(t, e) {
  switch (t.type) {
    case "select": {
      e.selected = t.selected;
      break;
    }
    case "position": {
      typeof t.position < "u" && (e.position = t.position), typeof t.dragging < "u" && (e.dragging = t.dragging);
      break;
    }
    case "dimensions": {
      typeof t.dimensions < "u" && (e.measured = {
        ...t.dimensions
      }, t.setAttributes && ((t.setAttributes === !0 || t.setAttributes === "width") && (e.width = t.dimensions.width), (t.setAttributes === !0 || t.setAttributes === "height") && (e.height = t.dimensions.height))), typeof t.resizing == "boolean" && (e.resizing = t.resizing);
      break;
    }
  }
}
function Lge(t, e) {
  return $ge(t, e);
}
function Fge(t, e) {
  return $ge(t, e);
}
function Ih(t, e) {
  return {
    id: t,
    type: "select",
    selected: e
  };
}
function vm(t, e = /* @__PURE__ */ new Set(), n = !1) {
  const r = [];
  for (const [s, o] of t) {
    const i = e.has(s);
    !(o.selected === void 0 && !i) && o.selected !== i && (n && (o.selected = i), r.push(Ih(o.id, i)));
  }
  return r;
}
function IW({ items: t = [], lookup: e }) {
  var s;
  const n = [], r = new Map(t.map((o) => [o.id, o]));
  for (const [o, i] of t.entries()) {
    const a = e.get(i.id), c = ((s = a == null ? void 0 : a.internals) == null ? void 0 : s.userNode) ?? a;
    c !== void 0 && c !== i && n.push({ id: i.id, item: i, type: "replace" }), c === void 0 && n.push({ item: i, type: "add", index: o });
  }
  for (const [o] of e)
    r.get(o) === void 0 && n.push({ id: o, type: "remove" });
  return n;
}
function kW(t) {
  return {
    id: t.id,
    type: "remove"
  };
}
const AW = (t) => Mft(t), spt = (t) => oge(t);
function Bge(t) {
  return du(t);
}
const opt = typeof window < "u" ? un : me;
function MW(t) {
  const [e, n] = he(BigInt(0)), [r] = he(() => ipt(() => n((s) => s + BigInt(1))));
  return opt(() => {
    const s = r.get();
    s.length && (t(s), r.reset());
  }, [e]), r;
}
function ipt(t) {
  let e = [];
  return {
    get: () => e,
    reset: () => {
      e = [];
    },
    push: (n) => {
      e.push(n), t();
    }
  };
}
const zge = zn(null);
function apt({ children: t }) {
  const e = dr(), n = re((a) => {
    const { nodes: c = [], setNodes: l, hasDefaultNodes: d, onNodesChange: u, nodeLookup: f, fitViewQueued: p, onNodesChangeMiddlewareMap: g } = e.getState();
    let y = c;
    for (const v of a)
      y = typeof v == "function" ? v(y) : v;
    let m = IW({
      items: y,
      lookup: f
    });
    for (const v of g.values())
      m = v(m);
    d && l(y), m.length > 0 ? u == null || u(m) : p && window.requestAnimationFrame(() => {
      const { fitViewQueued: v, nodes: b, setNodes: x } = e.getState();
      v && x(b);
    });
  }, []), r = MW(n), s = re((a) => {
    const { edges: c = [], setEdges: l, hasDefaultEdges: d, onEdgesChange: u, edgeLookup: f } = e.getState();
    let p = c;
    for (const g of a)
      p = typeof g == "function" ? g(p) : g;
    d ? l(p) : u && u(IW({
      items: p,
      lookup: f
    }));
  }, []), o = MW(s), i = Ke(() => ({ nodeQueue: r, edgeQueue: o }), []);
  return h.jsx(zge.Provider, { value: i, children: t });
}
function cpt() {
  const t = tn(zge);
  if (!t)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return t;
}
const lpt = (t) => !!t.panZoom;
function W4() {
  const t = npt(), e = dr(), n = cpt(), r = cn(lpt), s = Ke(() => {
    const o = (u) => e.getState().nodeLookup.get(u), i = (u) => {
      n.nodeQueue.push(u);
    }, a = (u) => {
      n.edgeQueue.push(u);
    }, c = (u) => {
      var v, b;
      const { nodeLookup: f, nodeOrigin: p } = e.getState(), g = AW(u) ? u : f.get(u.id), y = g.parentId ? fge(g.position, g.measured, g.parentId, f, p) : g.position, m = {
        ...g,
        position: y,
        width: ((v = g.measured) == null ? void 0 : v.width) ?? g.width,
        height: ((b = g.measured) == null ? void 0 : b.height) ?? g.height
      };
      return Iy(m);
    }, l = (u, f, p = { replace: !1 }) => {
      i((g) => g.map((y) => {
        if (y.id === u) {
          const m = typeof f == "function" ? f(y) : f;
          return p.replace && AW(m) ? m : { ...y, ...m };
        }
        return y;
      }));
    }, d = (u, f, p = { replace: !1 }) => {
      a((g) => g.map((y) => {
        if (y.id === u) {
          const m = typeof f == "function" ? f(y) : f;
          return p.replace && spt(m) ? m : { ...y, ...m };
        }
        return y;
      }));
    };
    return {
      getNodes: () => e.getState().nodes.map((u) => ({ ...u })),
      getNode: (u) => {
        var f;
        return (f = o(u)) == null ? void 0 : f.internals.userNode;
      },
      getInternalNode: o,
      getEdges: () => {
        const { edges: u = [] } = e.getState();
        return u.map((f) => ({ ...f }));
      },
      getEdge: (u) => e.getState().edgeLookup.get(u),
      setNodes: i,
      setEdges: a,
      addNodes: (u) => {
        const f = Array.isArray(u) ? u : [u];
        n.nodeQueue.push((p) => [...p, ...f]);
      },
      addEdges: (u) => {
        const f = Array.isArray(u) ? u : [u];
        n.edgeQueue.push((p) => [...p, ...f]);
      },
      toObject: () => {
        const { nodes: u = [], edges: f = [], transform: p } = e.getState(), [g, y, m] = p;
        return {
          nodes: u.map((v) => ({ ...v })),
          edges: f.map((v) => ({ ...v })),
          viewport: {
            x: g,
            y,
            zoom: m
          }
        };
      },
      deleteElements: async ({ nodes: u = [], edges: f = [] }) => {
        const { nodes: p, edges: g, onNodesDelete: y, onEdgesDelete: m, triggerNodeChanges: v, triggerEdgeChanges: b, onDelete: x, onBeforeDelete: w } = e.getState(), { nodes: S, edges: C } = await Rft({
          nodesToRemove: u,
          edgesToRemove: f,
          nodes: p,
          edges: g,
          onBeforeDelete: w
        }), _ = C.length > 0, E = S.length > 0;
        if (_) {
          const M = C.map(kW);
          m == null || m(C), b(M);
        }
        if (E) {
          const M = S.map(kW);
          y == null || y(S), v(M);
        }
        return (E || _) && (x == null || x({ nodes: S, edges: C })), { deletedNodes: S, deletedEdges: C };
      },
      /**
       * Partial is defined as "the 2 nodes/areas are intersecting partially".
       * If a is contained in b or b is contained in a, they are both
       * considered fully intersecting.
       */
      getIntersectingNodes: (u, f = !0, p) => {
        const g = sW(u), y = g ? u : c(u), m = p !== void 0;
        return y ? (p || e.getState().nodes).filter((v) => {
          const b = e.getState().nodeLookup.get(v.id);
          if (b && !g && (v.id === u.id || !b.internals.positionAbsolute))
            return !1;
          const x = Iy(m ? v : b), w = Hw(x, y);
          return f && w > 0 || w >= x.width * x.height || w >= y.width * y.height;
        }) : [];
      },
      isNodeIntersecting: (u, f, p = !0) => {
        const y = sW(u) ? u : c(u);
        if (!y)
          return !1;
        const m = Hw(y, f);
        return p && m > 0 || m >= f.width * f.height || m >= y.width * y.height;
      },
      updateNode: l,
      updateNodeData: (u, f, p = { replace: !1 }) => {
        l(u, (g) => {
          const y = typeof f == "function" ? f(g) : f;
          return p.replace ? { ...g, data: y } : { ...g, data: { ...g.data, ...y } };
        }, p);
      },
      updateEdge: d,
      updateEdgeData: (u, f, p = { replace: !1 }) => {
        d(u, (g) => {
          const y = typeof f == "function" ? f(g) : f;
          return p.replace ? { ...g, data: y } : { ...g, data: { ...g.data, ...y } };
        }, p);
      },
      getNodesBounds: (u) => {
        const { nodeLookup: f, nodeOrigin: p } = e.getState();
        return Oft(u, { nodeLookup: f, nodeOrigin: p });
      },
      getHandleConnections: ({ type: u, id: f, nodeId: p }) => {
        var g;
        return Array.from(((g = e.getState().connectionLookup.get(`${p}-${u}${f ? `-${f}` : ""}`)) == null ? void 0 : g.values()) ?? []);
      },
      getNodeConnections: ({ type: u, handleId: f, nodeId: p }) => {
        var g;
        return Array.from(((g = e.getState().connectionLookup.get(`${p}${u ? f ? `-${u}-${f}` : `-${u}` : ""}`)) == null ? void 0 : g.values()) ?? []);
      },
      fitView: async (u) => {
        const f = e.getState().fitViewResolver ?? Fft();
        return e.setState({ fitViewQueued: !0, fitViewOptions: u, fitViewResolver: f }), n.nodeQueue.push((p) => [...p]), f.promise;
      }
    };
  }, []);
  return Ke(() => ({
    ...s,
    ...t,
    viewportInitialized: r
  }), [r]);
}
const OW = (t) => t.selected, dpt = typeof window < "u" ? window : void 0;
function upt({ deleteKeyCode: t, multiSelectionKeyCode: e }) {
  const n = dr(), { deleteElements: r } = W4(), s = Ww(t, { actInsideInputWithModifier: !1 }), o = Ww(e, { target: dpt });
  me(() => {
    if (s) {
      const { edges: i, nodes: a } = n.getState();
      r({ nodes: a.filter(OW), edges: i.filter(OW) }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [s]), me(() => {
    n.setState({ multiSelectionActive: o });
  }, [o]);
}
function fpt(t) {
  const e = dr();
  me(() => {
    const n = () => {
      var s, o, i, a;
      if (!t.current || !(((o = (s = t.current).checkVisibility) == null ? void 0 : o.call(s)) ?? !0))
        return !1;
      const r = F4(t.current);
      (r.height === 0 || r.width === 0) && ((a = (i = e.getState()).onError) == null || a.call(i, "004", Ia.error004())), e.setState({ width: r.width || 500, height: r.height || 500 });
    };
    if (t.current) {
      n(), window.addEventListener("resize", n);
      const r = new ResizeObserver(() => n());
      return r.observe(t.current), () => {
        window.removeEventListener("resize", n), r && t.current && r.unobserve(t.current);
      };
    }
  }, []);
}
const nA = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, hpt = (t) => ({
  userSelectionActive: t.userSelectionActive,
  lib: t.lib,
  connectionInProgress: t.connection.inProgress
});
function ppt({ onPaneContextMenu: t, zoomOnScroll: e = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: s = 0.5, panOnScrollMode: o = pp.Free, zoomOnDoubleClick: i = !0, panOnDrag: a = !0, defaultViewport: c, translateExtent: l, minZoom: d, maxZoom: u, zoomActivationKeyCode: f, preventScrolling: p = !0, children: g, noWheelClassName: y, noPanClassName: m, onViewportChange: v, isControlledViewport: b, paneClickDistance: x, selectionOnDrag: w }) {
  const S = dr(), C = fe(null), { userSelectionActive: _, lib: E, connectionInProgress: M } = cn(hpt, lr), N = Ww(f), O = fe();
  fpt(C);
  const D = re((k) => {
    v == null || v({ x: k[0], y: k[1], zoom: k[2] }), b || S.setState({ transform: k });
  }, [v, b]);
  return me(() => {
    if (C.current) {
      O.current = wht({
        domNode: C.current,
        minZoom: d,
        maxZoom: u,
        translateExtent: l,
        viewport: c,
        onDraggingChange: (j) => S.setState({ paneDragging: j }),
        onPanZoomStart: (j, $) => {
          const { onViewportChangeStart: F, onMoveStart: L } = S.getState();
          L == null || L(j, $), F == null || F($);
        },
        onPanZoom: (j, $) => {
          const { onViewportChange: F, onMove: L } = S.getState();
          L == null || L(j, $), F == null || F($);
        },
        onPanZoomEnd: (j, $) => {
          const { onViewportChangeEnd: F, onMoveEnd: L } = S.getState();
          L == null || L(j, $), F == null || F($);
        }
      });
      const { x: k, y: A, zoom: R } = O.current.getViewport();
      return S.setState({
        panZoom: O.current,
        transform: [k, A, R],
        domNode: C.current.closest(".react-flow")
      }), () => {
        var j;
        (j = O.current) == null || j.destroy();
      };
    }
  }, []), me(() => {
    var k;
    (k = O.current) == null || k.update({
      onPaneContextMenu: t,
      zoomOnScroll: e,
      zoomOnPinch: n,
      panOnScroll: r,
      panOnScrollSpeed: s,
      panOnScrollMode: o,
      zoomOnDoubleClick: i,
      panOnDrag: a,
      zoomActivationKeyPressed: N,
      preventScrolling: p,
      noPanClassName: m,
      userSelectionActive: _,
      noWheelClassName: y,
      lib: E,
      onTransformChange: D,
      connectionInProgress: M,
      selectionOnDrag: w,
      paneClickDistance: x
    });
  }, [
    t,
    e,
    n,
    r,
    s,
    o,
    i,
    a,
    N,
    p,
    m,
    _,
    y,
    E,
    D,
    M,
    w,
    x
  ]), h.jsx("div", { className: "react-flow__renderer", ref: C, style: nA, children: g });
}
const gpt = (t) => ({
  userSelectionActive: t.userSelectionActive,
  userSelectionRect: t.userSelectionRect
});
function mpt() {
  const { userSelectionActive: t, userSelectionRect: e } = cn(gpt, lr);
  return t && e ? h.jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: e.width,
    height: e.height,
    transform: `translate(${e.x}px, ${e.y}px)`
  } }) : null;
}
const g2 = (t, e) => (n) => {
  n.target === e.current && (t == null || t(n));
}, ypt = (t) => ({
  userSelectionActive: t.userSelectionActive,
  elementsSelectable: t.elementsSelectable,
  connectionInProgress: t.connection.inProgress,
  dragging: t.paneDragging
});
function vpt({ isSelecting: t, selectionKeyPressed: e, selectionMode: n = Uw.Full, panOnDrag: r, paneClickDistance: s, selectionOnDrag: o, onSelectionStart: i, onSelectionEnd: a, onPaneClick: c, onPaneContextMenu: l, onPaneScroll: d, onPaneMouseEnter: u, onPaneMouseMove: f, onPaneMouseLeave: p, children: g }) {
  const y = dr(), { userSelectionActive: m, elementsSelectable: v, dragging: b, connectionInProgress: x } = cn(ypt, lr), w = v && (t || m), S = fe(null), C = fe(), _ = fe(/* @__PURE__ */ new Set()), E = fe(/* @__PURE__ */ new Set()), M = fe(!1), N = (F) => {
    if (M.current || x) {
      M.current = !1;
      return;
    }
    c == null || c(F), y.getState().resetSelectedElements(), y.setState({ nodesSelectionActive: !1 });
  }, O = (F) => {
    if (Array.isArray(r) && (r != null && r.includes(2))) {
      F.preventDefault();
      return;
    }
    l == null || l(F);
  }, D = d ? (F) => d(F) : void 0, k = (F) => {
    M.current && (F.stopPropagation(), M.current = !1);
  }, A = (F) => {
    var K, oe;
    const { domNode: L } = y.getState();
    if (C.current = L == null ? void 0 : L.getBoundingClientRect(), !C.current)
      return;
    const z = F.target === S.current;
    if (!z && !!F.target.closest(".nokey") || !t || !(o && z || e) || F.button !== 0 || !F.isPrimary)
      return;
    (oe = (K = F.target) == null ? void 0 : K.setPointerCapture) == null || oe.call(K, F.pointerId), M.current = !1;
    const { x: W, y: Z } = Kc(F.nativeEvent, C.current);
    y.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: W,
        startY: Z,
        x: W,
        y: Z
      }
    }), z || (F.stopPropagation(), F.preventDefault());
  }, R = (F) => {
    const { userSelectionRect: L, transform: z, nodeLookup: H, edgeLookup: U, connectionLookup: W, triggerNodeChanges: Z, triggerEdgeChanges: K, defaultEdgeOptions: oe, resetSelectedElements: Y } = y.getState();
    if (!C.current || !L)
      return;
    const { x: ee, y: ae } = Kc(F.nativeEvent, C.current), { startX: de, startY: ye } = L;
    if (!M.current) {
      const Ge = e ? 0 : s;
      if (Math.hypot(ee - de, ae - ye) <= Ge)
        return;
      Y(), i == null || i(F);
    }
    M.current = !0;
    const G = {
      startX: de,
      startY: ye,
      x: ee < de ? ee : de,
      y: ae < ye ? ae : ye,
      width: Math.abs(ee - de),
      height: Math.abs(ae - ye)
    }, xe = _.current, ge = E.current;
    _.current = new Set($4(H, G, z, n === Uw.Partial, !0).map((Ge) => Ge.id)), E.current = /* @__PURE__ */ new Set();
    const ze = (oe == null ? void 0 : oe.selectable) ?? !0;
    for (const Ge of _.current) {
      const Ct = W.get(Ge);
      if (Ct)
        for (const { edgeId: vn } of Ct.values()) {
          const Yt = U.get(vn);
          Yt && (Yt.selectable ?? ze) && E.current.add(vn);
        }
    }
    if (!oW(xe, _.current)) {
      const Ge = vm(H, _.current, !0);
      Z(Ge);
    }
    if (!oW(ge, E.current)) {
      const Ge = vm(U, E.current);
      K(Ge);
    }
    y.setState({
      userSelectionRect: G,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, j = (F) => {
    var L, z;
    F.button === 0 && ((z = (L = F.target) == null ? void 0 : L.releasePointerCapture) == null || z.call(L, F.pointerId), !m && F.target === S.current && y.getState().userSelectionRect && (N == null || N(F)), y.setState({
      userSelectionActive: !1,
      userSelectionRect: null
    }), M.current && (a == null || a(F), y.setState({
      nodesSelectionActive: _.current.size > 0
    })));
  }, $ = r === !0 || Array.isArray(r) && r.includes(0);
  return h.jsxs("div", { className: ds(["react-flow__pane", { draggable: $, dragging: b, selection: t }]), onClick: w ? void 0 : g2(N, S), onContextMenu: g2(O, S), onWheel: g2(D, S), onPointerEnter: w ? void 0 : u, onPointerMove: w ? R : f, onPointerUp: w ? j : void 0, onPointerDownCapture: w ? A : void 0, onClickCapture: w ? k : void 0, onPointerLeave: p, ref: S, style: nA, children: [g, h.jsx(mpt, {})] });
}
function JR({ id: t, store: e, unselect: n = !1, nodeRef: r }) {
  const { addSelectedNodes: s, unselectNodesAndEdges: o, multiSelectionActive: i, nodeLookup: a, onError: c } = e.getState(), l = a.get(t);
  if (!l) {
    c == null || c("012", Ia.error012(t));
    return;
  }
  e.setState({ nodesSelectionActive: !1 }), l.selected ? (n || l.selected && i) && (o({ nodes: [l], edges: [] }), requestAnimationFrame(() => {
    var d;
    return (d = r == null ? void 0 : r.current) == null ? void 0 : d.blur();
  })) : s([t]);
}
function Uge({ nodeRef: t, disabled: e = !1, noDragClassName: n, handleSelector: r, nodeId: s, isSelectable: o, nodeClickDistance: i }) {
  const a = dr(), [c, l] = he(!1), d = fe();
  return me(() => {
    d.current = aht({
      getStoreItems: () => a.getState(),
      onNodeMouseDown: (u) => {
        JR({
          id: u,
          store: a,
          nodeRef: t
        });
      },
      onDragStart: () => {
        l(!0);
      },
      onDragStop: () => {
        l(!1);
      }
    });
  }, []), me(() => {
    var u, f;
    if (e)
      (u = d.current) == null || u.destroy();
    else if (t.current)
      return (f = d.current) == null || f.update({
        noDragClassName: n,
        handleSelector: r,
        domNode: t.current,
        isSelectable: o,
        nodeId: s,
        nodeClickDistance: i
      }), () => {
        var p;
        (p = d.current) == null || p.destroy();
      };
  }, [n, r, e, o, t, s]), c;
}
const bpt = (t) => (e) => e.selected && (e.draggable || t && typeof e.draggable > "u");
function Hge() {
  const t = dr();
  return re((n) => {
    const { nodeExtent: r, snapToGrid: s, snapGrid: o, nodesDraggable: i, onError: a, updateNodePositions: c, nodeLookup: l, nodeOrigin: d } = t.getState(), u = /* @__PURE__ */ new Map(), f = bpt(i), p = s ? o[0] : 5, g = s ? o[1] : 5, y = n.direction.x * p * n.factor, m = n.direction.y * g * n.factor;
    for (const [, v] of l) {
      if (!f(v))
        continue;
      let b = {
        x: v.internals.positionAbsolute.x + y,
        y: v.internals.positionAbsolute.y + m
      };
      s && (b = _S(b, o));
      const { position: x, positionAbsolute: w } = ige({
        nodeId: v.id,
        nextPosition: b,
        nodeLookup: l,
        nodeExtent: r,
        nodeOrigin: d,
        onError: a
      });
      v.position = x, v.internals.positionAbsolute = w, u.set(v.id, v);
    }
    c(u);
  }, []);
}
const K4 = zn(null), xpt = K4.Provider;
K4.Consumer;
const Vge = () => tn(K4), wpt = (t) => ({
  connectOnClick: t.connectOnClick,
  noPanClassName: t.noPanClassName,
  rfId: t.rfId
}), Spt = (t, e, n) => (r) => {
  const { connectionClickStartHandle: s, connectionMode: o, connection: i } = r, { fromHandle: a, toHandle: c, isValid: l } = i, d = (c == null ? void 0 : c.nodeId) === t && (c == null ? void 0 : c.id) === e && (c == null ? void 0 : c.type) === n;
  return {
    connectingFrom: (a == null ? void 0 : a.nodeId) === t && (a == null ? void 0 : a.id) === e && (a == null ? void 0 : a.type) === n,
    connectingTo: d,
    clickConnecting: (s == null ? void 0 : s.nodeId) === t && (s == null ? void 0 : s.id) === e && (s == null ? void 0 : s.type) === n,
    isPossibleEndHandle: o === Ty.Strict ? (a == null ? void 0 : a.type) !== n : t !== (a == null ? void 0 : a.nodeId) || e !== (a == null ? void 0 : a.id),
    connectionInProcess: !!a,
    clickConnectionInProcess: !!s,
    valid: d && l
  };
};
function Cpt({ type: t = "source", position: e = lt.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: s = !0, isConnectableEnd: o = !0, id: i, onConnect: a, children: c, className: l, onMouseDown: d, onTouchStart: u, ...f }, p) {
  var R, j;
  const g = i || null, y = t === "target", m = dr(), v = Vge(), { connectOnClick: b, noPanClassName: x, rfId: w } = cn(wpt, lr), { connectingFrom: S, connectingTo: C, clickConnecting: _, isPossibleEndHandle: E, connectionInProcess: M, clickConnectionInProcess: N, valid: O } = cn(Spt(v, g, t), lr);
  v || (j = (R = m.getState()).onError) == null || j.call(R, "010", Ia.error010());
  const D = ($) => {
    const { defaultEdgeOptions: F, onConnect: L, hasDefaultEdges: z } = m.getState(), H = {
      ...F,
      ...$
    };
    if (z) {
      const { edges: U, setEdges: W } = m.getState();
      W(bge(H, U));
    }
    L == null || L(H), a == null || a(H);
  }, k = ($) => {
    if (!v)
      return;
    const F = gge($.nativeEvent);
    if (s && (F && $.button === 0 || !F)) {
      const L = m.getState();
      ZR.onPointerDown($.nativeEvent, {
        handleDomNode: $.currentTarget,
        autoPanOnConnect: L.autoPanOnConnect,
        connectionMode: L.connectionMode,
        connectionRadius: L.connectionRadius,
        domNode: L.domNode,
        nodeLookup: L.nodeLookup,
        lib: L.lib,
        isTarget: y,
        handleId: g,
        nodeId: v,
        flowId: L.rfId,
        panBy: L.panBy,
        cancelConnection: L.cancelConnection,
        onConnectStart: L.onConnectStart,
        onConnectEnd: L.onConnectEnd,
        updateConnection: L.updateConnection,
        onConnect: D,
        isValidConnection: n || L.isValidConnection,
        getTransform: () => m.getState().transform,
        getFromHandle: () => m.getState().connection.fromHandle,
        autoPanSpeed: L.autoPanSpeed,
        dragThreshold: L.connectionDragThreshold
      });
    }
    F ? d == null || d($) : u == null || u($);
  }, A = ($) => {
    const { onClickConnectStart: F, onClickConnectEnd: L, connectionClickStartHandle: z, connectionMode: H, isValidConnection: U, lib: W, rfId: Z, nodeLookup: K, connection: oe } = m.getState();
    if (!v || !z && !s)
      return;
    if (!z) {
      F == null || F($.nativeEvent, { nodeId: v, handleId: g, handleType: t }), m.setState({ connectionClickStartHandle: { nodeId: v, type: t, id: g } });
      return;
    }
    const Y = hge($.target), ee = n || U, { connection: ae, isValid: de } = ZR.isValid($.nativeEvent, {
      handle: {
        nodeId: v,
        id: g,
        type: t
      },
      connectionMode: H,
      fromNodeId: z.nodeId,
      fromHandleId: z.id || null,
      fromType: z.type,
      isValidConnection: ee,
      flowId: Z,
      doc: Y,
      lib: W,
      nodeLookup: K
    });
    de && ae && D(ae);
    const ye = structuredClone(oe);
    delete ye.inProgress, ye.toPosition = ye.toHandle ? ye.toHandle.position : null, L == null || L($, ye), m.setState({ connectionClickStartHandle: null });
  };
  return h.jsx("div", { "data-handleid": g, "data-nodeid": v, "data-handlepos": e, "data-id": `${w}-${v}-${g}-${t}`, className: ds([
    "react-flow__handle",
    `react-flow__handle-${e}`,
    "nodrag",
    x,
    l,
    {
      source: !y,
      target: y,
      connectable: r,
      connectablestart: s,
      connectableend: o,
      clickconnecting: _,
      connectingfrom: S,
      connectingto: C,
      valid: O,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: r && (!M || E) && (M || N ? o : s)
    }
  ]), onMouseDown: k, onTouchStart: k, onClick: b ? A : void 0, ref: p, ...f, children: c });
}
const cP = it(Bge(Cpt));
function _pt({ data: t, isConnectable: e, sourcePosition: n = lt.Bottom }) {
  return h.jsxs(h.Fragment, { children: [t == null ? void 0 : t.label, h.jsx(cP, { type: "source", position: n, isConnectable: e })] });
}
function Ept({ data: t, isConnectable: e, targetPosition: n = lt.Top, sourcePosition: r = lt.Bottom }) {
  return h.jsxs(h.Fragment, { children: [h.jsx(cP, { type: "target", position: n, isConnectable: e }), t == null ? void 0 : t.label, h.jsx(cP, { type: "source", position: r, isConnectable: e })] });
}
function Tpt() {
  return null;
}
function Ppt({ data: t, isConnectable: e, targetPosition: n = lt.Top }) {
  return h.jsxs(h.Fragment, { children: [h.jsx(cP, { type: "target", position: n, isConnectable: e }), t == null ? void 0 : t.label] });
}
const lP = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, DW = {
  input: _pt,
  default: Ept,
  output: Ppt,
  group: Tpt
};
function Ipt(t) {
  var e, n, r, s;
  return t.internals.handleBounds === void 0 ? {
    width: t.width ?? t.initialWidth ?? ((e = t.style) == null ? void 0 : e.width),
    height: t.height ?? t.initialHeight ?? ((n = t.style) == null ? void 0 : n.height)
  } : {
    width: t.width ?? ((r = t.style) == null ? void 0 : r.width),
    height: t.height ?? ((s = t.style) == null ? void 0 : s.height)
  };
}
const kpt = (t) => {
  const { width: e, height: n, x: r, y: s } = CS(t.nodeLookup, {
    filter: (o) => !!o.selected
  });
  return {
    width: Wc(e) ? e : null,
    height: Wc(n) ? n : null,
    userSelectionActive: t.userSelectionActive,
    transformString: `translate(${t.transform[0]}px,${t.transform[1]}px) scale(${t.transform[2]}) translate(${r}px,${s}px)`
  };
};
function Apt({ onSelectionContextMenu: t, noPanClassName: e, disableKeyboardA11y: n }) {
  const r = dr(), { width: s, height: o, transformString: i, userSelectionActive: a } = cn(kpt, lr), c = Hge(), l = fe(null);
  if (me(() => {
    var f;
    n || (f = l.current) == null || f.focus({
      preventScroll: !0
    });
  }, [n]), Uge({
    nodeRef: l
  }), a || !s || !o)
    return null;
  const d = t ? (f) => {
    const p = r.getState().nodes.filter((g) => g.selected);
    t(f, p);
  } : void 0, u = (f) => {
    Object.prototype.hasOwnProperty.call(lP, f.key) && (f.preventDefault(), c({
      direction: lP[f.key],
      factor: f.shiftKey ? 4 : 1
    }));
  };
  return h.jsx("div", { className: ds(["react-flow__nodesselection", "react-flow__container", e]), style: {
    transform: i
  }, children: h.jsx("div", { ref: l, className: "react-flow__nodesselection-rect", onContextMenu: d, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : u, style: {
    width: s,
    height: o
  } }) });
}
const NW = typeof window < "u" ? window : void 0, Mpt = (t) => ({ nodesSelectionActive: t.nodesSelectionActive, userSelectionActive: t.userSelectionActive });
function Wge({ children: t, onPaneClick: e, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: s, onPaneContextMenu: o, onPaneScroll: i, paneClickDistance: a, deleteKeyCode: c, selectionKeyCode: l, selectionOnDrag: d, selectionMode: u, onSelectionStart: f, onSelectionEnd: p, multiSelectionKeyCode: g, panActivationKeyCode: y, zoomActivationKeyCode: m, elementsSelectable: v, zoomOnScroll: b, zoomOnPinch: x, panOnScroll: w, panOnScrollSpeed: S, panOnScrollMode: C, zoomOnDoubleClick: _, panOnDrag: E, defaultViewport: M, translateExtent: N, minZoom: O, maxZoom: D, preventScrolling: k, onSelectionContextMenu: A, noWheelClassName: R, noPanClassName: j, disableKeyboardA11y: $, onViewportChange: F, isControlledViewport: L }) {
  const { nodesSelectionActive: z, userSelectionActive: H } = cn(Mpt, lr), U = Ww(l, { target: NW }), W = Ww(y, { target: NW }), Z = W || E, K = W || w, oe = d && Z !== !0, Y = U || H || oe;
  return upt({ deleteKeyCode: c, multiSelectionKeyCode: g }), h.jsx(ppt, { onPaneContextMenu: o, elementsSelectable: v, zoomOnScroll: b, zoomOnPinch: x, panOnScroll: K, panOnScrollSpeed: S, panOnScrollMode: C, zoomOnDoubleClick: _, panOnDrag: !U && Z, defaultViewport: M, translateExtent: N, minZoom: O, maxZoom: D, zoomActivationKeyCode: m, preventScrolling: k, noWheelClassName: R, noPanClassName: j, onViewportChange: F, isControlledViewport: L, paneClickDistance: a, selectionOnDrag: oe, children: h.jsxs(vpt, { onSelectionStart: f, onSelectionEnd: p, onPaneClick: e, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: s, onPaneContextMenu: o, onPaneScroll: i, panOnDrag: Z, isSelecting: !!Y, selectionMode: u, selectionKeyPressed: U, paneClickDistance: a, selectionOnDrag: oe, children: [t, z && h.jsx(Apt, { onSelectionContextMenu: A, noPanClassName: j, disableKeyboardA11y: $ })] }) });
}
Wge.displayName = "FlowRenderer";
const Opt = it(Wge), Dpt = (t) => (e) => t ? $4(e.nodeLookup, { x: 0, y: 0, width: e.width, height: e.height }, e.transform, !0).map((n) => n.id) : Array.from(e.nodeLookup.keys());
function Npt(t) {
  return cn(re(Dpt(t), [t]), lr);
}
const jpt = (t) => t.updateNodeInternals;
function Rpt() {
  const t = cn(jpt), [e] = he(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
    const r = /* @__PURE__ */ new Map();
    n.forEach((s) => {
      const o = s.target.getAttribute("data-id");
      r.set(o, {
        id: o,
        nodeElement: s.target,
        force: !0
      });
    }), t(r);
  }));
  return me(() => () => {
    e == null || e.disconnect();
  }, [e]), e;
}
function $pt({ node: t, nodeType: e, hasDimensions: n, resizeObserver: r }) {
  const s = dr(), o = fe(null), i = fe(null), a = fe(t.sourcePosition), c = fe(t.targetPosition), l = fe(e), d = n && !!t.internals.handleBounds;
  return me(() => {
    o.current && !t.hidden && (!d || i.current !== o.current) && (i.current && (r == null || r.unobserve(i.current)), r == null || r.observe(o.current), i.current = o.current);
  }, [d, t.hidden]), me(() => () => {
    i.current && (r == null || r.unobserve(i.current), i.current = null);
  }, []), me(() => {
    if (o.current) {
      const u = l.current !== e, f = a.current !== t.sourcePosition, p = c.current !== t.targetPosition;
      (u || f || p) && (l.current = e, a.current = t.sourcePosition, c.current = t.targetPosition, s.getState().updateNodeInternals(/* @__PURE__ */ new Map([[t.id, { id: t.id, nodeElement: o.current, force: !0 }]])));
    }
  }, [t.id, e, t.sourcePosition, t.targetPosition]), o;
}
function Lpt({ id: t, onClick: e, onMouseEnter: n, onMouseMove: r, onMouseLeave: s, onContextMenu: o, onDoubleClick: i, nodesDraggable: a, elementsSelectable: c, nodesConnectable: l, nodesFocusable: d, resizeObserver: u, noDragClassName: f, noPanClassName: p, disableKeyboardA11y: g, rfId: y, nodeTypes: m, nodeClickDistance: v, onError: b }) {
  const { node: x, internals: w, isParent: S } = cn((ee) => {
    const ae = ee.nodeLookup.get(t), de = ee.parentLookup.has(t);
    return {
      node: ae,
      internals: ae.internals,
      isParent: de
    };
  }, lr);
  let C = x.type || "default", _ = (m == null ? void 0 : m[C]) || DW[C];
  _ === void 0 && (b == null || b("003", Ia.error003(C)), C = "default", _ = (m == null ? void 0 : m.default) || DW.default);
  const E = !!(x.draggable || a && typeof x.draggable > "u"), M = !!(x.selectable || c && typeof x.selectable > "u"), N = !!(x.connectable || l && typeof x.connectable > "u"), O = !!(x.focusable || d && typeof x.focusable > "u"), D = dr(), k = uge(x), A = $pt({ node: x, nodeType: C, hasDimensions: k, resizeObserver: u }), R = Uge({
    nodeRef: A,
    disabled: x.hidden || !E,
    noDragClassName: f,
    handleSelector: x.dragHandle,
    nodeId: t,
    isSelectable: M,
    nodeClickDistance: v
  }), j = Hge();
  if (x.hidden)
    return null;
  const $ = Su(x), F = Ipt(x), L = M || E || e || n || r || s, z = n ? (ee) => n(ee, { ...w.userNode }) : void 0, H = r ? (ee) => r(ee, { ...w.userNode }) : void 0, U = s ? (ee) => s(ee, { ...w.userNode }) : void 0, W = o ? (ee) => o(ee, { ...w.userNode }) : void 0, Z = i ? (ee) => i(ee, { ...w.userNode }) : void 0, K = (ee) => {
    const { selectNodesOnDrag: ae, nodeDragThreshold: de } = D.getState();
    M && (!ae || !E || de > 0) && JR({
      id: t,
      store: D,
      nodeRef: A
    }), e && e(ee, { ...w.userNode });
  }, oe = (ee) => {
    if (!(pge(ee.nativeEvent) || g)) {
      if (tge.includes(ee.key) && M) {
        const ae = ee.key === "Escape";
        JR({
          id: t,
          store: D,
          unselect: ae,
          nodeRef: A
        });
      } else if (E && x.selected && Object.prototype.hasOwnProperty.call(lP, ee.key)) {
        ee.preventDefault();
        const { ariaLabelConfig: ae } = D.getState();
        D.setState({
          ariaLiveMessage: ae["node.a11yDescription.ariaLiveMessage"]({
            direction: ee.key.replace("Arrow", "").toLowerCase(),
            x: ~~w.positionAbsolute.x,
            y: ~~w.positionAbsolute.y
          })
        }), j({
          direction: lP[ee.key],
          factor: ee.shiftKey ? 4 : 1
        });
      }
    }
  }, Y = () => {
    var ge;
    if (g || !((ge = A.current) != null && ge.matches(":focus-visible")))
      return;
    const { transform: ee, width: ae, height: de, autoPanOnNodeFocus: ye, setCenter: G } = D.getState();
    if (!ye)
      return;
    $4(/* @__PURE__ */ new Map([[t, x]]), { x: 0, y: 0, width: ae, height: de }, ee, !0).length > 0 || G(x.position.x + $.width / 2, x.position.y + $.height / 2, {
      zoom: ee[2]
    });
  };
  return h.jsx("div", { className: ds([
    "react-flow__node",
    `react-flow__node-${C}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [p]: E
    },
    x.className,
    {
      selected: x.selected,
      selectable: M,
      parent: S,
      draggable: E,
      dragging: R
    }
  ]), ref: A, style: {
    zIndex: w.z,
    transform: `translate(${w.positionAbsolute.x}px,${w.positionAbsolute.y}px)`,
    pointerEvents: L ? "all" : "none",
    visibility: k ? "visible" : "hidden",
    ...x.style,
    ...F
  }, "data-id": t, "data-testid": `rf__node-${t}`, onMouseEnter: z, onMouseMove: H, onMouseLeave: U, onContextMenu: W, onClick: K, onDoubleClick: Z, onKeyDown: O ? oe : void 0, tabIndex: O ? 0 : void 0, onFocus: O ? Y : void 0, role: x.ariaRole ?? (O ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": g ? void 0 : `${Nge}-${y}`, "aria-label": x.ariaLabel, ...x.domAttributes, children: h.jsx(xpt, { value: t, children: h.jsx(_, { id: t, data: x.data, type: C, positionAbsoluteX: w.positionAbsolute.x, positionAbsoluteY: w.positionAbsolute.y, selected: x.selected ?? !1, selectable: M, draggable: E, deletable: x.deletable ?? !0, isConnectable: N, sourcePosition: x.sourcePosition, targetPosition: x.targetPosition, dragging: R, dragHandle: x.dragHandle, zIndex: w.z, parentId: x.parentId, ...$ }) }) });
}
var Fpt = it(Lpt);
const Bpt = (t) => ({
  nodesDraggable: t.nodesDraggable,
  nodesConnectable: t.nodesConnectable,
  nodesFocusable: t.nodesFocusable,
  elementsSelectable: t.elementsSelectable,
  onError: t.onError
});
function Kge(t) {
  const { nodesDraggable: e, nodesConnectable: n, nodesFocusable: r, elementsSelectable: s, onError: o } = cn(Bpt, lr), i = Npt(t.onlyRenderVisibleElements), a = Rpt();
  return h.jsx("div", { className: "react-flow__nodes", style: nA, children: i.map((c) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    h.jsx(Fpt, { id: c, nodeTypes: t.nodeTypes, nodeExtent: t.nodeExtent, onClick: t.onNodeClick, onMouseEnter: t.onNodeMouseEnter, onMouseMove: t.onNodeMouseMove, onMouseLeave: t.onNodeMouseLeave, onContextMenu: t.onNodeContextMenu, onDoubleClick: t.onNodeDoubleClick, noDragClassName: t.noDragClassName, noPanClassName: t.noPanClassName, rfId: t.rfId, disableKeyboardA11y: t.disableKeyboardA11y, resizeObserver: a, nodesDraggable: e, nodesConnectable: n, nodesFocusable: r, elementsSelectable: s, nodeClickDistance: t.nodeClickDistance, onError: o }, c)
  )) });
}
Kge.displayName = "NodeRenderer";
const zpt = it(Kge);
function Upt(t) {
  return cn(re((n) => {
    if (!t)
      return n.edges.map((s) => s.id);
    const r = [];
    if (n.width && n.height)
      for (const s of n.edges) {
        const o = n.nodeLookup.get(s.source), i = n.nodeLookup.get(s.target);
        o && i && Hft({
          sourceNode: o,
          targetNode: i,
          width: n.width,
          height: n.height,
          transform: n.transform
        }) && r.push(s.id);
      }
    return r;
  }, [t]), lr);
}
const Hpt = ({ color: t = "none", strokeWidth: e = 1 }) => {
  const n = {
    strokeWidth: e,
    ...t && { stroke: t }
  };
  return h.jsx("polyline", { className: "arrow", style: n, strokeLinecap: "round", fill: "none", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4" });
}, Vpt = ({ color: t = "none", strokeWidth: e = 1 }) => {
  const n = {
    strokeWidth: e,
    ...t && { stroke: t, fill: t }
  };
  return h.jsx("polyline", { className: "arrowclosed", style: n, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" });
}, jW = {
  [oP.Arrow]: Hpt,
  [oP.ArrowClosed]: Vpt
};
function Wpt(t) {
  const e = dr();
  return Ke(() => {
    var s, o;
    return Object.prototype.hasOwnProperty.call(jW, t) ? jW[t] : ((o = (s = e.getState()).onError) == null || o.call(s, "009", Ia.error009(t)), null);
  }, [t]);
}
const Kpt = ({ id: t, type: e, color: n, width: r = 12.5, height: s = 12.5, markerUnits: o = "strokeWidth", strokeWidth: i, orient: a = "auto-start-reverse" }) => {
  const c = Wpt(e);
  return c ? h.jsx("marker", { className: "react-flow__arrowhead", id: t, markerWidth: `${r}`, markerHeight: `${s}`, viewBox: "-10 -10 20 20", markerUnits: o, orient: a, refX: "0", refY: "0", children: h.jsx(c, { color: n, strokeWidth: i }) }) : null;
}, Gge = ({ defaultColor: t, rfId: e }) => {
  const n = cn((o) => o.edges), r = cn((o) => o.defaultEdgeOptions), s = Ke(() => Xft(n, {
    id: e,
    defaultColor: t,
    defaultMarkerStart: r == null ? void 0 : r.markerStart,
    defaultMarkerEnd: r == null ? void 0 : r.markerEnd
  }), [n, r, e, t]);
  return s.length ? h.jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: h.jsx("defs", { children: s.map((o) => h.jsx(Kpt, { id: o.id, type: o.type, color: o.color, width: o.width, height: o.height, markerUnits: o.markerUnits, strokeWidth: o.strokeWidth, orient: o.orient }, o.id)) }) }) : null;
};
Gge.displayName = "MarkerDefinitions";
var Gpt = it(Gge);
function Yge({ x: t, y: e, label: n, labelStyle: r, labelShowBg: s = !0, labelBgStyle: o, labelBgPadding: i = [2, 4], labelBgBorderRadius: a = 2, children: c, className: l, ...d }) {
  const [u, f] = he({ x: 1, y: 0, width: 0, height: 0 }), p = ds(["react-flow__edge-textwrapper", l]), g = fe(null);
  return me(() => {
    if (g.current) {
      const y = g.current.getBBox();
      f({
        x: y.x,
        y: y.y,
        width: y.width,
        height: y.height
      });
    }
  }, [n]), n ? h.jsxs("g", { transform: `translate(${t - u.width / 2} ${e - u.height / 2})`, className: p, visibility: u.width ? "visible" : "hidden", ...d, children: [s && h.jsx("rect", { width: u.width + 2 * i[0], x: -i[0], y: -i[1], height: u.height + 2 * i[1], className: "react-flow__edge-textbg", style: o, rx: a, ry: a }), h.jsx("text", { className: "react-flow__edge-text", y: u.height / 2, dy: "0.3em", ref: g, style: r, children: n }), c] }) : null;
}
Yge.displayName = "EdgeText";
const Ypt = it(Yge);
function rA({ path: t, labelX: e, labelY: n, label: r, labelStyle: s, labelShowBg: o, labelBgStyle: i, labelBgPadding: a, labelBgBorderRadius: c, interactionWidth: l = 20, ...d }) {
  return h.jsxs(h.Fragment, { children: [h.jsx("path", { ...d, d: t, fill: "none", className: ds(["react-flow__edge-path", d.className]) }), l ? h.jsx("path", { d: t, fill: "none", strokeOpacity: 0, strokeWidth: l, className: "react-flow__edge-interaction" }) : null, r && Wc(e) && Wc(n) ? h.jsx(Ypt, { x: e, y: n, label: r, labelStyle: s, labelShowBg: o, labelBgStyle: i, labelBgPadding: a, labelBgBorderRadius: c }) : null] });
}
function RW({ pos: t, x1: e, y1: n, x2: r, y2: s }) {
  return t === lt.Left || t === lt.Right ? [0.5 * (e + r), n] : [e, 0.5 * (n + s)];
}
function qge({ sourceX: t, sourceY: e, sourcePosition: n = lt.Bottom, targetX: r, targetY: s, targetPosition: o = lt.Top }) {
  const [i, a] = RW({
    pos: n,
    x1: t,
    y1: e,
    x2: r,
    y2: s
  }), [c, l] = RW({
    pos: o,
    x1: r,
    y1: s,
    x2: t,
    y2: e
  }), [d, u, f, p] = mge({
    sourceX: t,
    sourceY: e,
    targetX: r,
    targetY: s,
    sourceControlX: i,
    sourceControlY: a,
    targetControlX: c,
    targetControlY: l
  });
  return [
    `M${t},${e} C${i},${a} ${c},${l} ${r},${s}`,
    d,
    u,
    f,
    p
  ];
}
function Xge(t) {
  return it(({ id: e, sourceX: n, sourceY: r, targetX: s, targetY: o, sourcePosition: i, targetPosition: a, label: c, labelStyle: l, labelShowBg: d, labelBgStyle: u, labelBgPadding: f, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: m, interactionWidth: v }) => {
    const [b, x, w] = qge({
      sourceX: n,
      sourceY: r,
      sourcePosition: i,
      targetX: s,
      targetY: o,
      targetPosition: a
    }), S = t.isInternal ? void 0 : e;
    return h.jsx(rA, { id: S, path: b, labelX: x, labelY: w, label: c, labelStyle: l, labelShowBg: d, labelBgStyle: u, labelBgPadding: f, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: m, interactionWidth: v });
  });
}
const qpt = Xge({ isInternal: !1 }), Zge = Xge({ isInternal: !0 });
qpt.displayName = "SimpleBezierEdge";
Zge.displayName = "SimpleBezierEdgeInternal";
function Qge(t) {
  return it(({ id: e, sourceX: n, sourceY: r, targetX: s, targetY: o, label: i, labelStyle: a, labelShowBg: c, labelBgStyle: l, labelBgPadding: d, labelBgBorderRadius: u, style: f, sourcePosition: p = lt.Bottom, targetPosition: g = lt.Top, markerEnd: y, markerStart: m, pathOptions: v, interactionWidth: b }) => {
    const [x, w, S] = YR({
      sourceX: n,
      sourceY: r,
      sourcePosition: p,
      targetX: s,
      targetY: o,
      targetPosition: g,
      borderRadius: v == null ? void 0 : v.borderRadius,
      offset: v == null ? void 0 : v.offset,
      stepPosition: v == null ? void 0 : v.stepPosition
    }), C = t.isInternal ? void 0 : e;
    return h.jsx(rA, { id: C, path: x, labelX: w, labelY: S, label: i, labelStyle: a, labelShowBg: c, labelBgStyle: l, labelBgPadding: d, labelBgBorderRadius: u, style: f, markerEnd: y, markerStart: m, interactionWidth: b });
  });
}
const Jge = Qge({ isInternal: !1 }), eme = Qge({ isInternal: !0 });
Jge.displayName = "SmoothStepEdge";
eme.displayName = "SmoothStepEdgeInternal";
function tme(t) {
  return it(({ id: e, ...n }) => {
    var s;
    const r = t.isInternal ? void 0 : e;
    return h.jsx(Jge, { ...n, id: r, pathOptions: Ke(() => {
      var o;
      return { borderRadius: 0, offset: (o = n.pathOptions) == null ? void 0 : o.offset };
    }, [(s = n.pathOptions) == null ? void 0 : s.offset]) });
  });
}
const Xpt = tme({ isInternal: !1 }), nme = tme({ isInternal: !0 });
Xpt.displayName = "StepEdge";
nme.displayName = "StepEdgeInternal";
function rme(t) {
  return it(({ id: e, sourceX: n, sourceY: r, targetX: s, targetY: o, label: i, labelStyle: a, labelShowBg: c, labelBgStyle: l, labelBgPadding: d, labelBgBorderRadius: u, style: f, markerEnd: p, markerStart: g, interactionWidth: y }) => {
    const [m, v, b] = xge({ sourceX: n, sourceY: r, targetX: s, targetY: o }), x = t.isInternal ? void 0 : e;
    return h.jsx(rA, { id: x, path: m, labelX: v, labelY: b, label: i, labelStyle: a, labelShowBg: c, labelBgStyle: l, labelBgPadding: d, labelBgBorderRadius: u, style: f, markerEnd: p, markerStart: g, interactionWidth: y });
  });
}
const Zpt = rme({ isInternal: !1 }), sme = rme({ isInternal: !0 });
Zpt.displayName = "StraightEdge";
sme.displayName = "StraightEdgeInternal";
function ome(t) {
  return it(({ id: e, sourceX: n, sourceY: r, targetX: s, targetY: o, sourcePosition: i = lt.Bottom, targetPosition: a = lt.Top, label: c, labelStyle: l, labelShowBg: d, labelBgStyle: u, labelBgPadding: f, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: m, pathOptions: v, interactionWidth: b }) => {
    const [x, w, S] = yge({
      sourceX: n,
      sourceY: r,
      sourcePosition: i,
      targetX: s,
      targetY: o,
      targetPosition: a,
      curvature: v == null ? void 0 : v.curvature
    }), C = t.isInternal ? void 0 : e;
    return h.jsx(rA, { id: C, path: x, labelX: w, labelY: S, label: c, labelStyle: l, labelShowBg: d, labelBgStyle: u, labelBgPadding: f, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: m, interactionWidth: b });
  });
}
const Qpt = ome({ isInternal: !1 }), ime = ome({ isInternal: !0 });
Qpt.displayName = "BezierEdge";
ime.displayName = "BezierEdgeInternal";
const $W = {
  default: ime,
  straight: sme,
  step: nme,
  smoothstep: eme,
  simplebezier: Zge
}, LW = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, Jpt = (t, e, n) => n === lt.Left ? t - e : n === lt.Right ? t + e : t, egt = (t, e, n) => n === lt.Top ? t - e : n === lt.Bottom ? t + e : t, FW = "react-flow__edgeupdater";
function BW({ position: t, centerX: e, centerY: n, radius: r = 10, onMouseDown: s, onMouseEnter: o, onMouseOut: i, type: a }) {
  return h.jsx("circle", { onMouseDown: s, onMouseEnter: o, onMouseOut: i, className: ds([FW, `${FW}-${a}`]), cx: Jpt(e, r, t), cy: egt(n, r, t), r, stroke: "transparent", fill: "transparent" });
}
function tgt({ isReconnectable: t, reconnectRadius: e, edge: n, sourceX: r, sourceY: s, targetX: o, targetY: i, sourcePosition: a, targetPosition: c, onReconnect: l, onReconnectStart: d, onReconnectEnd: u, setReconnecting: f, setUpdateHover: p }) {
  const g = dr(), y = (w, S) => {
    if (w.button !== 0)
      return;
    const { autoPanOnConnect: C, domNode: _, isValidConnection: E, connectionMode: M, connectionRadius: N, lib: O, onConnectStart: D, onConnectEnd: k, cancelConnection: A, nodeLookup: R, rfId: j, panBy: $, updateConnection: F } = g.getState(), L = S.type === "target", z = (W, Z) => {
      f(!1), u == null || u(W, n, S.type, Z);
    }, H = (W) => l == null ? void 0 : l(n, W), U = (W, Z) => {
      f(!0), d == null || d(w, n, S.type), D == null || D(W, Z);
    };
    ZR.onPointerDown(w.nativeEvent, {
      autoPanOnConnect: C,
      connectionMode: M,
      connectionRadius: N,
      domNode: _,
      handleId: S.id,
      nodeId: S.nodeId,
      nodeLookup: R,
      isTarget: L,
      edgeUpdaterType: S.type,
      lib: O,
      flowId: j,
      cancelConnection: A,
      panBy: $,
      isValidConnection: E,
      onConnect: H,
      onConnectStart: U,
      onConnectEnd: k,
      onReconnectEnd: z,
      updateConnection: F,
      getTransform: () => g.getState().transform,
      getFromHandle: () => g.getState().connection.fromHandle,
      dragThreshold: g.getState().connectionDragThreshold,
      handleDomNode: w.currentTarget
    });
  }, m = (w) => y(w, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), v = (w) => y(w, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), b = () => p(!0), x = () => p(!1);
  return h.jsxs(h.Fragment, { children: [(t === !0 || t === "source") && h.jsx(BW, { position: a, centerX: r, centerY: s, radius: e, onMouseDown: m, onMouseEnter: b, onMouseOut: x, type: "source" }), (t === !0 || t === "target") && h.jsx(BW, { position: c, centerX: o, centerY: i, radius: e, onMouseDown: v, onMouseEnter: b, onMouseOut: x, type: "target" })] });
}
function ngt({ id: t, edgesFocusable: e, edgesReconnectable: n, elementsSelectable: r, onClick: s, onDoubleClick: o, onContextMenu: i, onMouseEnter: a, onMouseMove: c, onMouseLeave: l, reconnectRadius: d, onReconnect: u, onReconnectStart: f, onReconnectEnd: p, rfId: g, edgeTypes: y, noPanClassName: m, onError: v, disableKeyboardA11y: b }) {
  let x = cn((G) => G.edgeLookup.get(t));
  const w = cn((G) => G.defaultEdgeOptions);
  x = w ? { ...w, ...x } : x;
  let S = x.type || "default", C = (y == null ? void 0 : y[S]) || $W[S];
  C === void 0 && (v == null || v("011", Ia.error011(S)), S = "default", C = (y == null ? void 0 : y.default) || $W.default);
  const _ = !!(x.focusable || e && typeof x.focusable > "u"), E = typeof u < "u" && (x.reconnectable || n && typeof x.reconnectable > "u"), M = !!(x.selectable || r && typeof x.selectable > "u"), N = fe(null), [O, D] = he(!1), [k, A] = he(!1), R = dr(), { zIndex: j, sourceX: $, sourceY: F, targetX: L, targetY: z, sourcePosition: H, targetPosition: U } = cn(re((G) => {
    const xe = G.nodeLookup.get(x.source), ge = G.nodeLookup.get(x.target);
    if (!xe || !ge)
      return {
        zIndex: x.zIndex,
        ...LW
      };
    const ze = qft({
      id: t,
      sourceNode: xe,
      targetNode: ge,
      sourceHandle: x.sourceHandle || null,
      targetHandle: x.targetHandle || null,
      connectionMode: G.connectionMode,
      onError: v
    });
    return {
      zIndex: Uft({
        selected: x.selected,
        zIndex: x.zIndex,
        sourceNode: xe,
        targetNode: ge,
        elevateOnSelect: G.elevateEdgesOnSelect,
        zIndexMode: G.zIndexMode
      }),
      ...ze || LW
    };
  }, [x.source, x.target, x.sourceHandle, x.targetHandle, x.selected, x.zIndex]), lr), W = Ke(() => x.markerStart ? `url('#${qR(x.markerStart, g)}')` : void 0, [x.markerStart, g]), Z = Ke(() => x.markerEnd ? `url('#${qR(x.markerEnd, g)}')` : void 0, [x.markerEnd, g]);
  if (x.hidden || $ === null || F === null || L === null || z === null)
    return null;
  const K = (G) => {
    var Ge;
    const { addSelectedEdges: xe, unselectNodesAndEdges: ge, multiSelectionActive: ze } = R.getState();
    M && (R.setState({ nodesSelectionActive: !1 }), x.selected && ze ? (ge({ nodes: [], edges: [x] }), (Ge = N.current) == null || Ge.blur()) : xe([t])), s && s(G, x);
  }, oe = o ? (G) => {
    o(G, { ...x });
  } : void 0, Y = i ? (G) => {
    i(G, { ...x });
  } : void 0, ee = a ? (G) => {
    a(G, { ...x });
  } : void 0, ae = c ? (G) => {
    c(G, { ...x });
  } : void 0, de = l ? (G) => {
    l(G, { ...x });
  } : void 0, ye = (G) => {
    var xe;
    if (!b && tge.includes(G.key) && M) {
      const { unselectNodesAndEdges: ge, addSelectedEdges: ze } = R.getState();
      G.key === "Escape" ? ((xe = N.current) == null || xe.blur(), ge({ edges: [x] })) : ze([t]);
    }
  };
  return h.jsx("svg", { style: { zIndex: j }, children: h.jsxs("g", { className: ds([
    "react-flow__edge",
    `react-flow__edge-${S}`,
    x.className,
    m,
    {
      selected: x.selected,
      animated: x.animated,
      inactive: !M && !s,
      updating: O,
      selectable: M
    }
  ]), onClick: K, onDoubleClick: oe, onContextMenu: Y, onMouseEnter: ee, onMouseMove: ae, onMouseLeave: de, onKeyDown: _ ? ye : void 0, tabIndex: _ ? 0 : void 0, role: x.ariaRole ?? (_ ? "group" : "img"), "aria-roledescription": "edge", "data-id": t, "data-testid": `rf__edge-${t}`, "aria-label": x.ariaLabel === null ? void 0 : x.ariaLabel || `Edge from ${x.source} to ${x.target}`, "aria-describedby": _ ? `${jge}-${g}` : void 0, ref: N, ...x.domAttributes, children: [!k && h.jsx(C, { id: t, source: x.source, target: x.target, type: x.type, selected: x.selected, animated: x.animated, selectable: M, deletable: x.deletable ?? !0, label: x.label, labelStyle: x.labelStyle, labelShowBg: x.labelShowBg, labelBgStyle: x.labelBgStyle, labelBgPadding: x.labelBgPadding, labelBgBorderRadius: x.labelBgBorderRadius, sourceX: $, sourceY: F, targetX: L, targetY: z, sourcePosition: H, targetPosition: U, data: x.data, style: x.style, sourceHandleId: x.sourceHandle, targetHandleId: x.targetHandle, markerStart: W, markerEnd: Z, pathOptions: "pathOptions" in x ? x.pathOptions : void 0, interactionWidth: x.interactionWidth }), E && h.jsx(tgt, { edge: x, isReconnectable: E, reconnectRadius: d, onReconnect: u, onReconnectStart: f, onReconnectEnd: p, sourceX: $, sourceY: F, targetX: L, targetY: z, sourcePosition: H, targetPosition: U, setUpdateHover: D, setReconnecting: A })] }) });
}
var rgt = it(ngt);
const sgt = (t) => ({
  edgesFocusable: t.edgesFocusable,
  edgesReconnectable: t.edgesReconnectable,
  elementsSelectable: t.elementsSelectable,
  connectionMode: t.connectionMode,
  onError: t.onError
});
function ame({ defaultMarkerColor: t, onlyRenderVisibleElements: e, rfId: n, edgeTypes: r, noPanClassName: s, onReconnect: o, onEdgeContextMenu: i, onEdgeMouseEnter: a, onEdgeMouseMove: c, onEdgeMouseLeave: l, onEdgeClick: d, reconnectRadius: u, onEdgeDoubleClick: f, onReconnectStart: p, onReconnectEnd: g, disableKeyboardA11y: y }) {
  const { edgesFocusable: m, edgesReconnectable: v, elementsSelectable: b, onError: x } = cn(sgt, lr), w = Upt(e);
  return h.jsxs("div", { className: "react-flow__edges", children: [h.jsx(Gpt, { defaultColor: t, rfId: n }), w.map((S) => h.jsx(rgt, { id: S, edgesFocusable: m, edgesReconnectable: v, elementsSelectable: b, noPanClassName: s, onReconnect: o, onContextMenu: i, onMouseEnter: a, onMouseMove: c, onMouseLeave: l, onClick: d, reconnectRadius: u, onDoubleClick: f, onReconnectStart: p, onReconnectEnd: g, rfId: n, onError: x, edgeTypes: r, disableKeyboardA11y: y }, S))] });
}
ame.displayName = "EdgeRenderer";
const ogt = it(ame), igt = (t) => `translate(${t.transform[0]}px,${t.transform[1]}px) scale(${t.transform[2]})`;
function agt({ children: t }) {
  const e = cn(igt);
  return h.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: e }, children: t });
}
function cgt(t) {
  const e = W4(), n = fe(!1);
  me(() => {
    !n.current && e.viewportInitialized && t && (setTimeout(() => t(e), 1), n.current = !0);
  }, [t, e.viewportInitialized]);
}
const lgt = (t) => {
  var e;
  return (e = t.panZoom) == null ? void 0 : e.syncViewport;
};
function dgt(t) {
  const e = cn(lgt), n = dr();
  return me(() => {
    t && (e == null || e(t), n.setState({ transform: [t.x, t.y, t.zoom] }));
  }, [t, e]), null;
}
function ugt(t) {
  return t.connection.inProgress ? { ...t.connection, to: ES(t.connection.to, t.transform) } : { ...t.connection };
}
function fgt(t) {
  return ugt;
}
function hgt(t) {
  const e = fgt();
  return cn(e, lr);
}
const pgt = (t) => ({
  nodesConnectable: t.nodesConnectable,
  isValid: t.connection.isValid,
  inProgress: t.connection.inProgress,
  width: t.width,
  height: t.height
});
function ggt({ containerStyle: t, style: e, type: n, component: r }) {
  const { nodesConnectable: s, width: o, height: i, isValid: a, inProgress: c } = cn(pgt, lr);
  return !(o && s && c) ? null : h.jsx("svg", { style: t, width: o, height: i, className: "react-flow__connectionline react-flow__container", children: h.jsx("g", { className: ds(["react-flow__connection", sge(a)]), children: h.jsx(cme, { style: e, type: n, CustomComponent: r, isValid: a }) }) });
}
const cme = ({ style: t, type: e = Zu.Bezier, CustomComponent: n, isValid: r }) => {
  const { inProgress: s, from: o, fromNode: i, fromHandle: a, fromPosition: c, to: l, toNode: d, toHandle: u, toPosition: f, pointer: p } = hgt();
  if (!s)
    return;
  if (n)
    return h.jsx(n, { connectionLineType: e, connectionLineStyle: t, fromNode: i, fromHandle: a, fromX: o.x, fromY: o.y, toX: l.x, toY: l.y, fromPosition: c, toPosition: f, connectionStatus: sge(r), toNode: d, toHandle: u, pointer: p });
  let g = "";
  const y = {
    sourceX: o.x,
    sourceY: o.y,
    sourcePosition: c,
    targetX: l.x,
    targetY: l.y,
    targetPosition: f
  };
  switch (e) {
    case Zu.Bezier:
      [g] = yge(y);
      break;
    case Zu.SimpleBezier:
      [g] = qge(y);
      break;
    case Zu.Step:
      [g] = YR({
        ...y,
        borderRadius: 0
      });
      break;
    case Zu.SmoothStep:
      [g] = YR(y);
      break;
    default:
      [g] = xge(y);
  }
  return h.jsx("path", { d: g, fill: "none", className: "react-flow__connection-path", style: t });
};
cme.displayName = "ConnectionLine";
const mgt = {};
function zW(t = mgt) {
  const e = fe(t), n = dr();
  me(() => {
    var r, s;
    if (process.env.NODE_ENV === "development") {
      const o = /* @__PURE__ */ new Set([...Object.keys(e.current), ...Object.keys(t)]);
      for (const i of o)
        if (e.current[i] !== t[i]) {
          (s = (r = n.getState()).onError) == null || s.call(r, "002", Ia.error002());
          break;
        }
      e.current = t;
    }
  }, [t]);
}
function ygt() {
  const t = dr(), e = fe(!1);
  me(() => {
    var n, r;
    if (process.env.NODE_ENV === "development" && !e.current) {
      const s = document.querySelector(".react-flow__pane");
      s && window.getComputedStyle(s).zIndex !== "1" && ((r = (n = t.getState()).onError) == null || r.call(n, "013", Ia.error013("react"))), e.current = !0;
    }
  }, []);
}
function lme({ nodeTypes: t, edgeTypes: e, onInit: n, onNodeClick: r, onEdgeClick: s, onNodeDoubleClick: o, onEdgeDoubleClick: i, onNodeMouseEnter: a, onNodeMouseMove: c, onNodeMouseLeave: l, onNodeContextMenu: d, onSelectionContextMenu: u, onSelectionStart: f, onSelectionEnd: p, connectionLineType: g, connectionLineStyle: y, connectionLineComponent: m, connectionLineContainerStyle: v, selectionKeyCode: b, selectionOnDrag: x, selectionMode: w, multiSelectionKeyCode: S, panActivationKeyCode: C, zoomActivationKeyCode: _, deleteKeyCode: E, onlyRenderVisibleElements: M, elementsSelectable: N, defaultViewport: O, translateExtent: D, minZoom: k, maxZoom: A, preventScrolling: R, defaultMarkerColor: j, zoomOnScroll: $, zoomOnPinch: F, panOnScroll: L, panOnScrollSpeed: z, panOnScrollMode: H, zoomOnDoubleClick: U, panOnDrag: W, onPaneClick: Z, onPaneMouseEnter: K, onPaneMouseMove: oe, onPaneMouseLeave: Y, onPaneScroll: ee, onPaneContextMenu: ae, paneClickDistance: de, nodeClickDistance: ye, onEdgeContextMenu: G, onEdgeMouseEnter: xe, onEdgeMouseMove: ge, onEdgeMouseLeave: ze, reconnectRadius: Ge, onReconnect: Ct, onReconnectStart: vn, onReconnectEnd: Yt, noDragClassName: X, noWheelClassName: ce, noPanClassName: pe, disableKeyboardA11y: Ie, nodeExtent: ke, rfId: Ce, viewport: De, onViewportChange: ot }) {
  return zW(t), zW(e), ygt(), cgt(n), dgt(De), h.jsx(Opt, { onPaneClick: Z, onPaneMouseEnter: K, onPaneMouseMove: oe, onPaneMouseLeave: Y, onPaneContextMenu: ae, onPaneScroll: ee, paneClickDistance: de, deleteKeyCode: E, selectionKeyCode: b, selectionOnDrag: x, selectionMode: w, onSelectionStart: f, onSelectionEnd: p, multiSelectionKeyCode: S, panActivationKeyCode: C, zoomActivationKeyCode: _, elementsSelectable: N, zoomOnScroll: $, zoomOnPinch: F, zoomOnDoubleClick: U, panOnScroll: L, panOnScrollSpeed: z, panOnScrollMode: H, panOnDrag: W, defaultViewport: O, translateExtent: D, minZoom: k, maxZoom: A, onSelectionContextMenu: u, preventScrolling: R, noDragClassName: X, noWheelClassName: ce, noPanClassName: pe, disableKeyboardA11y: Ie, onViewportChange: ot, isControlledViewport: !!De, children: h.jsxs(agt, { children: [h.jsx(ogt, { edgeTypes: e, onEdgeClick: s, onEdgeDoubleClick: i, onReconnect: Ct, onReconnectStart: vn, onReconnectEnd: Yt, onlyRenderVisibleElements: M, onEdgeContextMenu: G, onEdgeMouseEnter: xe, onEdgeMouseMove: ge, onEdgeMouseLeave: ze, reconnectRadius: Ge, defaultMarkerColor: j, noPanClassName: pe, disableKeyboardA11y: Ie, rfId: Ce }), h.jsx(ggt, { style: y, type: g, component: m, containerStyle: v }), h.jsx("div", { className: "react-flow__edgelabel-renderer" }), h.jsx(zpt, { nodeTypes: t, onNodeClick: r, onNodeDoubleClick: o, onNodeMouseEnter: a, onNodeMouseMove: c, onNodeMouseLeave: l, onNodeContextMenu: d, nodeClickDistance: ye, onlyRenderVisibleElements: M, noPanClassName: pe, noDragClassName: X, disableKeyboardA11y: Ie, nodeExtent: ke, rfId: Ce }), h.jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
lme.displayName = "GraphView";
const vgt = it(lme), UW = ({ nodes: t, edges: e, defaultNodes: n, defaultEdges: r, width: s, height: o, fitView: i, fitViewOptions: a, minZoom: c = 0.5, maxZoom: l = 2, nodeOrigin: d, nodeExtent: u, zIndexMode: f = "basic" } = {}) => {
  const p = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), v = r ?? e ?? [], b = n ?? t ?? [], x = d ?? [0, 0], w = u ?? zw;
  Cge(y, m, v);
  const S = XR(b, p, g, {
    nodeOrigin: x,
    nodeExtent: w,
    zIndexMode: f
  });
  let C = [0, 0, 1];
  if (i && s && o) {
    const _ = CS(p, {
      filter: (O) => !!((O.width || O.initialWidth) && (O.height || O.initialHeight))
    }), { x: E, y: M, zoom: N } = L4(_, s, o, c, l, (a == null ? void 0 : a.padding) ?? 0.1);
    C = [E, M, N];
  }
  return {
    rfId: "1",
    width: s ?? 0,
    height: o ?? 0,
    transform: C,
    nodes: b,
    nodesInitialized: S,
    nodeLookup: p,
    parentLookup: g,
    edges: v,
    edgeLookup: m,
    connectionLookup: y,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: n !== void 0,
    hasDefaultEdges: r !== void 0,
    panZoom: null,
    minZoom: c,
    maxZoom: l,
    translateExtent: zw,
    nodeExtent: w,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: Ty.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: x,
    nodeDragThreshold: 1,
    connectionDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: i ?? !1,
    fitViewOptions: a,
    fitViewResolver: null,
    connection: { ...rge },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnNodeFocus: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: dge,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1,
    ariaLabelConfig: nge,
    zIndexMode: f,
    onNodesChangeMiddlewareMap: /* @__PURE__ */ new Map(),
    onEdgesChangeMiddlewareMap: /* @__PURE__ */ new Map()
  };
}, bgt = ({ nodes: t, edges: e, defaultNodes: n, defaultEdges: r, width: s, height: o, fitView: i, fitViewOptions: a, minZoom: c, maxZoom: l, nodeOrigin: d, nodeExtent: u, zIndexMode: f }) => $ht((p, g) => {
  async function y() {
    const { nodeLookup: m, panZoom: v, fitViewOptions: b, fitViewResolver: x, width: w, height: S, minZoom: C, maxZoom: _ } = g();
    v && (await jft({
      nodes: m,
      width: w,
      height: S,
      panZoom: v,
      minZoom: C,
      maxZoom: _
    }, b), x == null || x.resolve(!0), p({ fitViewResolver: null }));
  }
  return {
    ...UW({
      nodes: t,
      edges: e,
      width: s,
      height: o,
      fitView: i,
      fitViewOptions: a,
      minZoom: c,
      maxZoom: l,
      nodeOrigin: d,
      nodeExtent: u,
      defaultNodes: n,
      defaultEdges: r,
      zIndexMode: f
    }),
    setNodes: (m) => {
      const { nodeLookup: v, parentLookup: b, nodeOrigin: x, elevateNodesOnSelect: w, fitViewQueued: S, zIndexMode: C } = g(), _ = XR(m, v, b, {
        nodeOrigin: x,
        nodeExtent: u,
        elevateNodesOnSelect: w,
        checkEquality: !0,
        zIndexMode: C
      });
      S && _ ? (y(), p({ nodes: m, nodesInitialized: _, fitViewQueued: !1, fitViewOptions: void 0 })) : p({ nodes: m, nodesInitialized: _ });
    },
    setEdges: (m) => {
      const { connectionLookup: v, edgeLookup: b } = g();
      Cge(v, b, m), p({ edges: m });
    },
    setDefaultNodesAndEdges: (m, v) => {
      if (m) {
        const { setNodes: b } = g();
        b(m), p({ hasDefaultNodes: !0 });
      }
      if (v) {
        const { setEdges: b } = g();
        b(v), p({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (m) => {
      const { triggerNodeChanges: v, nodeLookup: b, parentLookup: x, domNode: w, nodeOrigin: S, nodeExtent: C, debug: _, fitViewQueued: E, zIndexMode: M } = g(), { changes: N, updatedInternals: O } = rht(m, b, x, w, S, C, M);
      O && (Jft(b, x, { nodeOrigin: S, nodeExtent: C, zIndexMode: M }), E ? (y(), p({ fitViewQueued: !1, fitViewOptions: void 0 })) : p({}), (N == null ? void 0 : N.length) > 0 && (_ && console.log("React Flow: trigger node changes", N), v == null || v(N)));
    },
    updateNodePositions: (m, v = !1) => {
      const b = [];
      let x = [];
      const { nodeLookup: w, triggerNodeChanges: S, connection: C, updateConnection: _, onNodesChangeMiddlewareMap: E } = g();
      for (const [M, N] of m) {
        const O = w.get(M), D = !!(O != null && O.expandParent && (O != null && O.parentId) && (N != null && N.position)), k = {
          id: M,
          type: "position",
          position: D ? {
            x: Math.max(0, N.position.x),
            y: Math.max(0, N.position.y)
          } : N.position,
          dragging: v
        };
        if (O && C.inProgress && C.fromNode.id === O.id) {
          const A = Kp(O, C.fromHandle, lt.Left, !0);
          _({ ...C, from: A });
        }
        D && O.parentId && b.push({
          id: M,
          parentId: O.parentId,
          rect: {
            ...N.internals.positionAbsolute,
            width: N.measured.width ?? 0,
            height: N.measured.height ?? 0
          }
        }), x.push(k);
      }
      if (b.length > 0) {
        const { parentLookup: M, nodeOrigin: N } = g(), O = V4(b, w, M, N);
        x.push(...O);
      }
      for (const M of E.values())
        x = M(x);
      S(x);
    },
    triggerNodeChanges: (m) => {
      const { onNodesChange: v, setNodes: b, nodes: x, hasDefaultNodes: w, debug: S } = g();
      if (m != null && m.length) {
        if (w) {
          const C = Lge(m, x);
          b(C);
        }
        S && console.log("React Flow: trigger node changes", m), v == null || v(m);
      }
    },
    triggerEdgeChanges: (m) => {
      const { onEdgesChange: v, setEdges: b, edges: x, hasDefaultEdges: w, debug: S } = g();
      if (m != null && m.length) {
        if (w) {
          const C = Fge(m, x);
          b(C);
        }
        S && console.log("React Flow: trigger edge changes", m), v == null || v(m);
      }
    },
    addSelectedNodes: (m) => {
      const { multiSelectionActive: v, edgeLookup: b, nodeLookup: x, triggerNodeChanges: w, triggerEdgeChanges: S } = g();
      if (v) {
        const C = m.map((_) => Ih(_, !0));
        w(C);
        return;
      }
      w(vm(x, /* @__PURE__ */ new Set([...m]), !0)), S(vm(b));
    },
    addSelectedEdges: (m) => {
      const { multiSelectionActive: v, edgeLookup: b, nodeLookup: x, triggerNodeChanges: w, triggerEdgeChanges: S } = g();
      if (v) {
        const C = m.map((_) => Ih(_, !0));
        S(C);
        return;
      }
      S(vm(b, /* @__PURE__ */ new Set([...m]))), w(vm(x, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: m, edges: v } = {}) => {
      const { edges: b, nodes: x, nodeLookup: w, triggerNodeChanges: S, triggerEdgeChanges: C } = g(), _ = m || x, E = v || b, M = _.map((O) => {
        const D = w.get(O.id);
        return D && (D.selected = !1), Ih(O.id, !1);
      }), N = E.map((O) => Ih(O.id, !1));
      S(M), C(N);
    },
    setMinZoom: (m) => {
      const { panZoom: v, maxZoom: b } = g();
      v == null || v.setScaleExtent([m, b]), p({ minZoom: m });
    },
    setMaxZoom: (m) => {
      const { panZoom: v, minZoom: b } = g();
      v == null || v.setScaleExtent([b, m]), p({ maxZoom: m });
    },
    setTranslateExtent: (m) => {
      var v;
      (v = g().panZoom) == null || v.setTranslateExtent(m), p({ translateExtent: m });
    },
    resetSelectedElements: () => {
      const { edges: m, nodes: v, triggerNodeChanges: b, triggerEdgeChanges: x, elementsSelectable: w } = g();
      if (!w)
        return;
      const S = v.reduce((_, E) => E.selected ? [..._, Ih(E.id, !1)] : _, []), C = m.reduce((_, E) => E.selected ? [..._, Ih(E.id, !1)] : _, []);
      b(S), x(C);
    },
    setNodeExtent: (m) => {
      const { nodes: v, nodeLookup: b, parentLookup: x, nodeOrigin: w, elevateNodesOnSelect: S, nodeExtent: C, zIndexMode: _ } = g();
      m[0][0] === C[0][0] && m[0][1] === C[0][1] && m[1][0] === C[1][0] && m[1][1] === C[1][1] || (XR(v, b, x, {
        nodeOrigin: w,
        nodeExtent: m,
        elevateNodesOnSelect: S,
        checkEquality: !1,
        zIndexMode: _
      }), p({ nodeExtent: m }));
    },
    panBy: (m) => {
      const { transform: v, width: b, height: x, panZoom: w, translateExtent: S } = g();
      return sht({ delta: m, panZoom: w, transform: v, translateExtent: S, width: b, height: x });
    },
    setCenter: async (m, v, b) => {
      const { width: x, height: w, maxZoom: S, panZoom: C } = g();
      if (!C)
        return Promise.resolve(!1);
      const _ = typeof (b == null ? void 0 : b.zoom) < "u" ? b.zoom : S;
      return await C.setViewport({
        x: x / 2 - m * _,
        y: w / 2 - v * _,
        zoom: _
      }, { duration: b == null ? void 0 : b.duration, ease: b == null ? void 0 : b.ease, interpolate: b == null ? void 0 : b.interpolate }), Promise.resolve(!0);
    },
    cancelConnection: () => {
      p({
        connection: { ...rge }
      });
    },
    updateConnection: (m) => {
      p({ connection: m });
    },
    reset: () => p({ ...UW() })
  };
}, Object.is);
function xgt({ initialNodes: t, initialEdges: e, defaultNodes: n, defaultEdges: r, initialWidth: s, initialHeight: o, initialMinZoom: i, initialMaxZoom: a, initialFitViewOptions: c, fitView: l, nodeOrigin: d, nodeExtent: u, zIndexMode: f, children: p }) {
  const [g] = he(() => bgt({
    nodes: t,
    edges: e,
    defaultNodes: n,
    defaultEdges: r,
    width: s,
    height: o,
    fitView: l,
    minZoom: i,
    maxZoom: a,
    fitViewOptions: c,
    nodeOrigin: d,
    nodeExtent: u,
    zIndexMode: f
  }));
  return h.jsx(Lht, { value: g, children: h.jsx(apt, { children: p }) });
}
function wgt({ children: t, nodes: e, edges: n, defaultNodes: r, defaultEdges: s, width: o, height: i, fitView: a, fitViewOptions: c, minZoom: l, maxZoom: d, nodeOrigin: u, nodeExtent: f, zIndexMode: p }) {
  return tn(eA) ? h.jsx(h.Fragment, { children: t }) : h.jsx(xgt, { initialNodes: e, initialEdges: n, defaultNodes: r, defaultEdges: s, initialWidth: o, initialHeight: i, fitView: a, initialFitViewOptions: c, initialMinZoom: l, initialMaxZoom: d, nodeOrigin: u, nodeExtent: f, zIndexMode: p, children: t });
}
const Sgt = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function Cgt({ nodes: t, edges: e, defaultNodes: n, defaultEdges: r, className: s, nodeTypes: o, edgeTypes: i, onNodeClick: a, onEdgeClick: c, onInit: l, onMove: d, onMoveStart: u, onMoveEnd: f, onConnect: p, onConnectStart: g, onConnectEnd: y, onClickConnectStart: m, onClickConnectEnd: v, onNodeMouseEnter: b, onNodeMouseMove: x, onNodeMouseLeave: w, onNodeContextMenu: S, onNodeDoubleClick: C, onNodeDragStart: _, onNodeDrag: E, onNodeDragStop: M, onNodesDelete: N, onEdgesDelete: O, onDelete: D, onSelectionChange: k, onSelectionDragStart: A, onSelectionDrag: R, onSelectionDragStop: j, onSelectionContextMenu: $, onSelectionStart: F, onSelectionEnd: L, onBeforeDelete: z, connectionMode: H, connectionLineType: U = Zu.Bezier, connectionLineStyle: W, connectionLineComponent: Z, connectionLineContainerStyle: K, deleteKeyCode: oe = "Backspace", selectionKeyCode: Y = "Shift", selectionOnDrag: ee = !1, selectionMode: ae = Uw.Full, panActivationKeyCode: de = "Space", multiSelectionKeyCode: ye = Vw() ? "Meta" : "Control", zoomActivationKeyCode: G = Vw() ? "Meta" : "Control", snapToGrid: xe, snapGrid: ge, onlyRenderVisibleElements: ze = !1, selectNodesOnDrag: Ge, nodesDraggable: Ct, autoPanOnNodeFocus: vn, nodesConnectable: Yt, nodesFocusable: X, nodeOrigin: ce = Rge, edgesFocusable: pe, edgesReconnectable: Ie, elementsSelectable: ke = !0, defaultViewport: Ce = Zht, minZoom: De = 0.5, maxZoom: ot = 2, translateExtent: Nt = zw, preventScrolling: Kn = !0, nodeExtent: In, defaultMarkerColor: Mr = "#b1b1b7", zoomOnScroll: qi = !0, zoomOnPinch: Us = !0, panOnScroll: ur = !1, panOnScrollSpeed: Hs = 0.5, panOnScrollMode: Yr = pp.Free, zoomOnDoubleClick: vi = !0, panOnDrag: ho = !0, onPaneClick: Ss, onPaneMouseEnter: ja, onPaneMouseMove: bi, onPaneMouseLeave: Xi, onPaneScroll: qr, onPaneContextMenu: Wo, paneClickDistance: ct = 1, nodeClickDistance: Pt = 0, children: sn, onReconnect: tr, onReconnectStart: Xr, onReconnectEnd: po, onEdgeContextMenu: Ko, onEdgeDoubleClick: Nn, onEdgeMouseEnter: Vs, onEdgeMouseMove: _u, onEdgeMouseLeave: dd, reconnectRadius: Zi = 10, onNodesChange: ph, onEdgesChange: Q, noDragClassName: Ee = "nodrag", noWheelClassName: $e = "nowheel", noPanClassName: ut = "nopan", fitView: It, fitViewOptions: on, connectOnClick: jt, attributionPosition: Rt, proOptions: Or, defaultEdgeOptions: an, elevateNodesOnSelect: hn = !0, elevateEdgesOnSelect: Cs = !1, disableKeyboardA11y: Qi = !1, autoPanOnConnect: Ji, autoPanOnNodeDrag: Zr, autoPanSpeed: ud, connectionRadius: ea, isValidConnection: gh, onError: Sg, style: Ra, id: Cg, nodeDragThreshold: Dv, connectionDragThreshold: Nv, viewport: _g, onViewportChange: jv, width: Rv, height: xc, colorMode: hl = "light", debug: go, onScroll: fd, ariaLabelConfig: Eg, zIndexMode: Tg = "basic", ...$v }, wc) {
  const Eu = Cg || "1", Pg = tpt(hl), mh = re((yh) => {
    yh.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), fd == null || fd(yh);
  }, [fd]);
  return h.jsx("div", { "data-testid": "rf__wrapper", ...$v, onScroll: mh, style: { ...Ra, ...Sgt }, ref: wc, className: ds(["react-flow", s, Pg]), id: Cg, role: "application", children: h.jsxs(wgt, { nodes: t, edges: e, width: Rv, height: xc, fitView: It, fitViewOptions: on, minZoom: De, maxZoom: ot, nodeOrigin: ce, nodeExtent: In, zIndexMode: Tg, children: [h.jsx(vgt, { onInit: l, onNodeClick: a, onEdgeClick: c, onNodeMouseEnter: b, onNodeMouseMove: x, onNodeMouseLeave: w, onNodeContextMenu: S, onNodeDoubleClick: C, nodeTypes: o, edgeTypes: i, connectionLineType: U, connectionLineStyle: W, connectionLineComponent: Z, connectionLineContainerStyle: K, selectionKeyCode: Y, selectionOnDrag: ee, selectionMode: ae, deleteKeyCode: oe, multiSelectionKeyCode: ye, panActivationKeyCode: de, zoomActivationKeyCode: G, onlyRenderVisibleElements: ze, defaultViewport: Ce, translateExtent: Nt, minZoom: De, maxZoom: ot, preventScrolling: Kn, zoomOnScroll: qi, zoomOnPinch: Us, zoomOnDoubleClick: vi, panOnScroll: ur, panOnScrollSpeed: Hs, panOnScrollMode: Yr, panOnDrag: ho, onPaneClick: Ss, onPaneMouseEnter: ja, onPaneMouseMove: bi, onPaneMouseLeave: Xi, onPaneScroll: qr, onPaneContextMenu: Wo, paneClickDistance: ct, nodeClickDistance: Pt, onSelectionContextMenu: $, onSelectionStart: F, onSelectionEnd: L, onReconnect: tr, onReconnectStart: Xr, onReconnectEnd: po, onEdgeContextMenu: Ko, onEdgeDoubleClick: Nn, onEdgeMouseEnter: Vs, onEdgeMouseMove: _u, onEdgeMouseLeave: dd, reconnectRadius: Zi, defaultMarkerColor: Mr, noDragClassName: Ee, noWheelClassName: $e, noPanClassName: ut, rfId: Eu, disableKeyboardA11y: Qi, nodeExtent: In, viewport: _g, onViewportChange: jv }), h.jsx(ept, { nodes: t, edges: e, defaultNodes: n, defaultEdges: r, onConnect: p, onConnectStart: g, onConnectEnd: y, onClickConnectStart: m, onClickConnectEnd: v, nodesDraggable: Ct, autoPanOnNodeFocus: vn, nodesConnectable: Yt, nodesFocusable: X, edgesFocusable: pe, edgesReconnectable: Ie, elementsSelectable: ke, elevateNodesOnSelect: hn, elevateEdgesOnSelect: Cs, minZoom: De, maxZoom: ot, nodeExtent: In, onNodesChange: ph, onEdgesChange: Q, snapToGrid: xe, snapGrid: ge, connectionMode: H, translateExtent: Nt, connectOnClick: jt, defaultEdgeOptions: an, fitView: It, fitViewOptions: on, onNodesDelete: N, onEdgesDelete: O, onDelete: D, onNodeDragStart: _, onNodeDrag: E, onNodeDragStop: M, onSelectionDrag: R, onSelectionDragStart: A, onSelectionDragStop: j, onMove: d, onMoveStart: u, onMoveEnd: f, noPanClassName: ut, nodeOrigin: ce, rfId: Eu, autoPanOnConnect: Ji, autoPanOnNodeDrag: Zr, autoPanSpeed: ud, onError: Sg, connectionRadius: ea, isValidConnection: gh, selectNodesOnDrag: Ge, nodeDragThreshold: Dv, connectionDragThreshold: Nv, onBeforeDelete: z, debug: go, ariaLabelConfig: Eg, zIndexMode: Tg }), h.jsx(Xht, { onSelectionChange: k }), sn, h.jsx(Wht, { proOptions: Or, position: Rt }), h.jsx(Vht, { rfId: Eu, disableKeyboardA11y: Qi })] }) });
}
var dme = Bge(Cgt);
function ume(t) {
  const [e, n] = he(t), r = re((s) => n((o) => Lge(s, o)), []);
  return [e, n, r];
}
function fme(t) {
  const [e, n] = he(t), r = re((s) => n((o) => Fge(s, o)), []);
  return [e, n, r];
}
function _gt({ dimensions: t, lineWidth: e, variant: n, className: r }) {
  return h.jsx("path", { strokeWidth: e, d: `M${t[0] / 2} 0 V${t[1]} M0 ${t[1] / 2} H${t[0]}`, className: ds(["react-flow__background-pattern", n, r]) });
}
function Egt({ radius: t, className: e }) {
  return h.jsx("circle", { cx: t, cy: t, r: t, className: ds(["react-flow__background-pattern", "dots", e]) });
}
var Kl;
(function(t) {
  t.Lines = "lines", t.Dots = "dots", t.Cross = "cross";
})(Kl || (Kl = {}));
const Tgt = {
  [Kl.Dots]: 1,
  [Kl.Lines]: 1,
  [Kl.Cross]: 6
}, Pgt = (t) => ({ transform: t.transform, patternId: `pattern-${t.rfId}` });
function hme({
  id: t,
  variant: e = Kl.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: r,
  lineWidth: s = 1,
  offset: o = 0,
  color: i,
  bgColor: a,
  style: c,
  className: l,
  patternClassName: d
}) {
  const u = fe(null), { transform: f, patternId: p } = cn(Pgt, lr), g = r || Tgt[e], y = e === Kl.Dots, m = e === Kl.Cross, v = Array.isArray(n) ? n : [n, n], b = [v[0] * f[2] || 1, v[1] * f[2] || 1], x = g * f[2], w = Array.isArray(o) ? o : [o, o], S = m ? [x, x] : b, C = [
    w[0] * f[2] || 1 + S[0] / 2,
    w[1] * f[2] || 1 + S[1] / 2
  ], _ = `${p}${t || ""}`;
  return h.jsxs("svg", { className: ds(["react-flow__background", l]), style: {
    ...c,
    ...nA,
    "--xy-background-color-props": a,
    "--xy-background-pattern-color-props": i
  }, ref: u, "data-testid": "rf__background", children: [h.jsx("pattern", { id: _, x: f[0] % b[0], y: f[1] % b[1], width: b[0], height: b[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${C[0]},-${C[1]})`, children: y ? h.jsx(Egt, { radius: x / 2, className: d }) : h.jsx(_gt, { dimensions: S, lineWidth: s, variant: e, className: d }) }), h.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${_})` })] });
}
hme.displayName = "Background";
const pme = it(hme);
function Igt() {
  return h.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: h.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function kgt() {
  return h.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: h.jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function Agt() {
  return h.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: h.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function Mgt() {
  return h.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: h.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function Ogt() {
  return h.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: h.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function wC({ children: t, className: e, ...n }) {
  return h.jsx("button", { type: "button", className: ds(["react-flow__controls-button", e]), ...n, children: t });
}
const Dgt = (t) => ({
  isInteractive: t.nodesDraggable || t.nodesConnectable || t.elementsSelectable,
  minZoomReached: t.transform[2] <= t.minZoom,
  maxZoomReached: t.transform[2] >= t.maxZoom,
  ariaLabelConfig: t.ariaLabelConfig
});
function gme({ style: t, showZoom: e = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: s, onZoomIn: o, onZoomOut: i, onFitView: a, onInteractiveChange: c, className: l, children: d, position: u = "bottom-left", orientation: f = "vertical", "aria-label": p }) {
  const g = dr(), { isInteractive: y, minZoomReached: m, maxZoomReached: v, ariaLabelConfig: b } = cn(Dgt, lr), { zoomIn: x, zoomOut: w, fitView: S } = W4(), C = () => {
    x(), o == null || o();
  }, _ = () => {
    w(), i == null || i();
  }, E = () => {
    S(s), a == null || a();
  }, M = () => {
    g.setState({
      nodesDraggable: !y,
      nodesConnectable: !y,
      elementsSelectable: !y
    }), c == null || c(!y);
  }, N = f === "horizontal" ? "horizontal" : "vertical";
  return h.jsxs(tA, { className: ds(["react-flow__controls", N, l]), position: u, style: t, "data-testid": "rf__controls", "aria-label": p ?? b["controls.ariaLabel"], children: [e && h.jsxs(h.Fragment, { children: [h.jsx(wC, { onClick: C, className: "react-flow__controls-zoomin", title: b["controls.zoomIn.ariaLabel"], "aria-label": b["controls.zoomIn.ariaLabel"], disabled: v, children: h.jsx(Igt, {}) }), h.jsx(wC, { onClick: _, className: "react-flow__controls-zoomout", title: b["controls.zoomOut.ariaLabel"], "aria-label": b["controls.zoomOut.ariaLabel"], disabled: m, children: h.jsx(kgt, {}) })] }), n && h.jsx(wC, { className: "react-flow__controls-fitview", onClick: E, title: b["controls.fitView.ariaLabel"], "aria-label": b["controls.fitView.ariaLabel"], children: h.jsx(Agt, {}) }), r && h.jsx(wC, { className: "react-flow__controls-interactive", onClick: M, title: b["controls.interactive.ariaLabel"], "aria-label": b["controls.interactive.ariaLabel"], children: y ? h.jsx(Ogt, {}) : h.jsx(Mgt, {}) }), d] });
}
gme.displayName = "Controls";
const mme = it(gme);
function Ngt({ id: t, x: e, y: n, width: r, height: s, style: o, color: i, strokeColor: a, strokeWidth: c, className: l, borderRadius: d, shapeRendering: u, selected: f, onClick: p }) {
  const { background: g, backgroundColor: y } = o || {}, m = i || g || y;
  return h.jsx("rect", { className: ds(["react-flow__minimap-node", { selected: f }, l]), x: e, y: n, rx: d, ry: d, width: r, height: s, style: {
    fill: m,
    stroke: a,
    strokeWidth: c
  }, shapeRendering: u, onClick: p ? (v) => p(v, t) : void 0 });
}
const jgt = it(Ngt), Rgt = (t) => t.nodes.map((e) => e.id), m2 = (t) => t instanceof Function ? t : () => t;
function $gt({
  nodeStrokeColor: t,
  nodeColor: e,
  nodeClassName: n = "",
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: s,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: o = jgt,
  onClick: i
}) {
  const a = cn(Rgt, lr), c = m2(e), l = m2(t), d = m2(n), u = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return h.jsx(h.Fragment, { children: a.map((f) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    h.jsx(Fgt, { id: f, nodeColorFunc: c, nodeStrokeColorFunc: l, nodeClassNameFunc: d, nodeBorderRadius: r, nodeStrokeWidth: s, NodeComponent: o, onClick: i, shapeRendering: u }, f)
  )) });
}
function Lgt({ id: t, nodeColorFunc: e, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: s, nodeStrokeWidth: o, shapeRendering: i, NodeComponent: a, onClick: c }) {
  const { node: l, x: d, y: u, width: f, height: p } = cn((g) => {
    const { internals: y } = g.nodeLookup.get(t), m = y.userNode, { x: v, y: b } = y.positionAbsolute, { width: x, height: w } = Su(m);
    return {
      node: m,
      x: v,
      y: b,
      width: x,
      height: w
    };
  }, lr);
  return !l || l.hidden || !uge(l) ? null : h.jsx(a, { x: d, y: u, width: f, height: p, style: l.style, selected: !!l.selected, className: r(l), color: e(l), borderRadius: s, strokeColor: n(l), strokeWidth: o, shapeRendering: i, onClick: c, id: l.id });
}
const Fgt = it(Lgt);
var Bgt = it($gt);
const zgt = 200, Ugt = 150, Hgt = (t) => !t.hidden, Vgt = (t) => {
  const e = {
    x: -t.transform[0] / t.transform[2],
    y: -t.transform[1] / t.transform[2],
    width: t.width / t.transform[2],
    height: t.height / t.transform[2]
  };
  return {
    viewBB: e,
    boundingRect: t.nodeLookup.size > 0 ? lge(CS(t.nodeLookup, { filter: Hgt }), e) : e,
    rfId: t.rfId,
    panZoom: t.panZoom,
    translateExtent: t.translateExtent,
    flowWidth: t.width,
    flowHeight: t.height,
    ariaLabelConfig: t.ariaLabelConfig
  };
}, Wgt = "react-flow__minimap-desc";
function yme({
  style: t,
  className: e,
  nodeStrokeColor: n,
  nodeColor: r,
  nodeClassName: s = "",
  nodeBorderRadius: o = 5,
  nodeStrokeWidth: i,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: a,
  bgColor: c,
  maskColor: l,
  maskStrokeColor: d,
  maskStrokeWidth: u,
  position: f = "bottom-right",
  onClick: p,
  onNodeClick: g,
  pannable: y = !1,
  zoomable: m = !1,
  ariaLabel: v,
  inversePan: b,
  zoomStep: x = 1,
  offsetScale: w = 5
}) {
  const S = dr(), C = fe(null), { boundingRect: _, viewBB: E, rfId: M, panZoom: N, translateExtent: O, flowWidth: D, flowHeight: k, ariaLabelConfig: A } = cn(Vgt, lr), R = (t == null ? void 0 : t.width) ?? zgt, j = (t == null ? void 0 : t.height) ?? Ugt, $ = _.width / R, F = _.height / j, L = Math.max($, F), z = L * R, H = L * j, U = w * L, W = _.x - (z - _.width) / 2 - U, Z = _.y - (H - _.height) / 2 - U, K = z + U * 2, oe = H + U * 2, Y = `${Wgt}-${M}`, ee = fe(0), ae = fe();
  ee.current = L, me(() => {
    if (C.current && N)
      return ae.current = hht({
        domNode: C.current,
        panZoom: N,
        getTransform: () => S.getState().transform,
        getViewScale: () => ee.current
      }), () => {
        var xe;
        (xe = ae.current) == null || xe.destroy();
      };
  }, [N]), me(() => {
    var xe;
    (xe = ae.current) == null || xe.update({
      translateExtent: O,
      width: D,
      height: k,
      inversePan: b,
      pannable: y,
      zoomStep: x,
      zoomable: m
    });
  }, [y, m, b, x, O, D, k]);
  const de = p ? (xe) => {
    var Ge;
    const [ge, ze] = ((Ge = ae.current) == null ? void 0 : Ge.pointer(xe)) || [0, 0];
    p(xe, { x: ge, y: ze });
  } : void 0, ye = g ? re((xe, ge) => {
    const ze = S.getState().nodeLookup.get(ge).internals.userNode;
    g(xe, ze);
  }, []) : void 0, G = v ?? A["minimap.ariaLabel"];
  return h.jsx(tA, { position: f, style: {
    ...t,
    "--xy-minimap-background-color-props": typeof c == "string" ? c : void 0,
    "--xy-minimap-mask-background-color-props": typeof l == "string" ? l : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof d == "string" ? d : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof u == "number" ? u * L : void 0,
    "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
    "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-node-stroke-width-props": typeof i == "number" ? i : void 0
  }, className: ds(["react-flow__minimap", e]), "data-testid": "rf__minimap", children: h.jsxs("svg", { width: R, height: j, viewBox: `${W} ${Z} ${K} ${oe}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": Y, ref: C, onClick: de, children: [G && h.jsx("title", { id: Y, children: G }), h.jsx(Bgt, { onClick: ye, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: o, nodeClassName: s, nodeStrokeWidth: i, nodeComponent: a }), h.jsx("path", { className: "react-flow__minimap-mask", d: `M${W - U},${Z - U}h${K + U * 2}v${oe + U * 2}h${-K - U * 2}z
        M${E.x},${E.y}h${E.width}v${E.height}h${-E.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
yme.displayName = "MiniMap";
const vme = it(yme), Kgt = (t) => (e) => t ? `${Math.max(1 / e.transform[2], 1)}` : void 0, Ggt = {
  [Ay.Line]: "right",
  [Ay.Handle]: "bottom-right"
};
function Ygt({ nodeId: t, position: e, variant: n = Ay.Handle, className: r, style: s = void 0, children: o, color: i, minWidth: a = 10, minHeight: c = 10, maxWidth: l = Number.MAX_VALUE, maxHeight: d = Number.MAX_VALUE, keepAspectRatio: u = !1, resizeDirection: f, autoScale: p = !0, shouldResize: g, onResizeStart: y, onResize: m, onResizeEnd: v }) {
  const b = Vge(), x = typeof t == "string" ? t : b, w = dr(), S = fe(null), C = n === Ay.Handle, _ = cn(re(Kgt(C && p), [C, p]), lr), E = fe(null), M = e ?? Ggt[n];
  me(() => {
    if (!(!S.current || !x))
      return E.current || (E.current = Pht({
        domNode: S.current,
        nodeId: x,
        getStoreItems: () => {
          const { nodeLookup: O, transform: D, snapGrid: k, snapToGrid: A, nodeOrigin: R, domNode: j } = w.getState();
          return {
            nodeLookup: O,
            transform: D,
            snapGrid: k,
            snapToGrid: A,
            nodeOrigin: R,
            paneDomNode: j
          };
        },
        onChange: (O, D) => {
          const { triggerNodeChanges: k, nodeLookup: A, parentLookup: R, nodeOrigin: j } = w.getState(), $ = [], F = { x: O.x, y: O.y }, L = A.get(x);
          if (L && L.expandParent && L.parentId) {
            const z = L.origin ?? j, H = O.width ?? L.measured.width ?? 0, U = O.height ?? L.measured.height ?? 0, W = {
              id: L.id,
              parentId: L.parentId,
              rect: {
                width: H,
                height: U,
                ...fge({
                  x: O.x ?? L.position.x,
                  y: O.y ?? L.position.y
                }, { width: H, height: U }, L.parentId, A, z)
              }
            }, Z = V4([W], A, R, j);
            $.push(...Z), F.x = O.x ? Math.max(z[0] * H, O.x) : void 0, F.y = O.y ? Math.max(z[1] * U, O.y) : void 0;
          }
          if (F.x !== void 0 && F.y !== void 0) {
            const z = {
              id: x,
              type: "position",
              position: { ...F }
            };
            $.push(z);
          }
          if (O.width !== void 0 && O.height !== void 0) {
            const H = {
              id: x,
              type: "dimensions",
              resizing: !0,
              setAttributes: f ? f === "horizontal" ? "width" : "height" : !0,
              dimensions: {
                width: O.width,
                height: O.height
              }
            };
            $.push(H);
          }
          for (const z of D) {
            const H = {
              ...z,
              type: "position"
            };
            $.push(H);
          }
          k($);
        },
        onEnd: ({ width: O, height: D }) => {
          const k = {
            id: x,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width: O,
              height: D
            }
          };
          w.getState().triggerNodeChanges([k]);
        }
      })), E.current.update({
        controlPosition: M,
        boundaries: {
          minWidth: a,
          minHeight: c,
          maxWidth: l,
          maxHeight: d
        },
        keepAspectRatio: u,
        resizeDirection: f,
        onResizeStart: y,
        onResize: m,
        onResizeEnd: v,
        shouldResize: g
      }), () => {
        var O;
        (O = E.current) == null || O.destroy();
      };
  }, [
    M,
    a,
    c,
    l,
    d,
    u,
    y,
    m,
    v,
    g
  ]);
  const N = M.split("-");
  return h.jsx("div", { className: ds(["react-flow__resize-control", "nodrag", ...N, n, r]), ref: S, style: {
    ...s,
    scale: _,
    ...i && { [C ? "backgroundColor" : "borderColor"]: i }
  }, children: o });
}
it(Ygt);
const HW = [
  {
    id: "1",
    type: "default",
    data: { label: "Start" },
    position: { x: 250, y: 50 }
  }
], VW = [];
function qgt({ initialData: t, onSave: e }) {
  const { resolvedTheme: n } = Yy(), r = n === "dark" ? "dark" : "light", s = Ke(() => {
    if (t && typeof t == "object") {
      const m = t;
      return {
        nodes: m.nodes || HW,
        edges: m.edges || VW
      };
    }
    return { nodes: HW, edges: VW };
  }, [t]), [o, i, a] = ume(s.nodes), [c, l, d] = fme(s.edges), u = re(() => {
    e && e({ nodes: o, edges: c });
  }, [o, c, e]), f = re(
    (m) => {
      l((v) => bge(m, v)), setTimeout(u, 0);
    },
    [l, u]
  ), p = re(
    (m) => {
      a(m), setTimeout(u, 0);
    },
    [a, u]
  ), g = re(
    (m) => {
      d(m), setTimeout(u, 0);
    },
    [d, u]
  ), y = re(() => {
    const m = {
      id: `node-${Date.now()}`,
      type: "default",
      data: { label: "New Node" },
      position: {
        x: Math.random() * 300 + 100,
        y: Math.random() * 300 + 100
      }
    };
    i((v) => [...v, m]), setTimeout(u, 0);
  }, [i, u]);
  return /* @__PURE__ */ h.jsxs("div", { className: "w-full h-full relative", children: [
    /* @__PURE__ */ h.jsx("div", { className: "absolute top-4 left-4 z-10", children: /* @__PURE__ */ h.jsxs(_t, { onClick: y, size: "sm", className: "gap-1", children: [
      /* @__PURE__ */ h.jsx(Jc, { className: "h-4 w-4" }),
      "Add Node"
    ] }) }),
    /* @__PURE__ */ h.jsxs(
      dme,
      {
        nodes: o,
        edges: c,
        onNodesChange: p,
        onEdgesChange: g,
        onConnect: f,
        colorMode: r,
        fitView: !0,
        children: [
          /* @__PURE__ */ h.jsx(mme, {}),
          /* @__PURE__ */ h.jsx(vme, {}),
          /* @__PURE__ */ h.jsx(pme, { variant: Kl.Dots, gap: 12, size: 1 })
        ]
      }
    )
  ] });
}
function Xgt({ open: t, onOpenChange: e }) {
  return /* @__PURE__ */ h.jsx(ig, { open: t, onOpenChange: e, children: /* @__PURE__ */ h.jsxs(Gf, { className: "max-w-md", children: [
    /* @__PURE__ */ h.jsx(ag, { children: /* @__PURE__ */ h.jsx(cg, { children: "Flow Tips" }) }),
    /* @__PURE__ */ h.jsxs("div", { className: "space-y-4 text-sm", children: [
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(Jc, { className: "h-4 w-4 text-primary" }),
          "Creating Nodes"
        ] }),
        /* @__PURE__ */ h.jsx("p", { className: "text-muted-foreground", children: "Double-click on empty space to create a new node. Drag from a node's handle to connect it to another node." })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(C0, { className: "h-4 w-4 text-primary" }),
          "Connections"
        ] }),
        /* @__PURE__ */ h.jsx("p", { className: "text-muted-foreground", children: "Drag from the small circles (handles) on nodes to create edges. Click on an edge to select and delete it." })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(Uq, { className: "h-4 w-4 text-primary" }),
          "Navigation"
        ] }),
        /* @__PURE__ */ h.jsxs("ul", { className: "text-muted-foreground space-y-1 ml-6 list-disc", children: [
          /* @__PURE__ */ h.jsx("li", { children: "Click and drag on empty space to pan" }),
          /* @__PURE__ */ h.jsx("li", { children: "Scroll to zoom in/out" }),
          /* @__PURE__ */ h.jsx("li", { children: "Click a node to select it" }),
          /* @__PURE__ */ h.jsx("li", { children: "Drag nodes to reposition them" })
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(K$, { className: "h-4 w-4 text-primary" }),
          "Keyboard Shortcuts"
        ] }),
        /* @__PURE__ */ h.jsxs("ul", { className: "text-muted-foreground space-y-1", children: [
          /* @__PURE__ */ h.jsxs("li", { className: "flex justify-between", children: [
            /* @__PURE__ */ h.jsx("span", { children: "Delete selected" }),
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 bg-muted rounded text-xs", children: "Delete" })
          ] }),
          /* @__PURE__ */ h.jsxs("li", { className: "flex justify-between", children: [
            /* @__PURE__ */ h.jsx("span", { children: "Undo" }),
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 bg-muted rounded text-xs", children: "Z" })
          ] }),
          /* @__PURE__ */ h.jsxs("li", { className: "flex justify-between", children: [
            /* @__PURE__ */ h.jsx("span", { children: "Redo" }),
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 bg-muted rounded text-xs", children: "Z" })
          ] })
        ] })
      ] })
    ] })
  ] }) });
}
const WW = er.diagram;
function KW() {
  const { id: t } = $P(), { artifact: e, loading: n, error: r, saving: s, save: o, rename: i, toggleFavorite: a, updateTags: c } = I4("diagram", t || "new"), [l, d] = he(!1), u = Ke(() => /* @__PURE__ */ h.jsx(
    _t,
    {
      variant: "ghost",
      size: "icon",
      className: "h-8 w-8",
      onClick: () => d(!0),
      title: "Help",
      children: /* @__PURE__ */ h.jsx(Vy, { className: "h-4 w-4" })
    }
  ), []);
  return /* @__PURE__ */ h.jsxs(
    rF,
    {
      title: WW.title,
      icon: WW.icon,
      artifact: e,
      loading: n,
      error: r,
      saving: s,
      onRename: i,
      onToggleFavorite: a,
      onUpdateTags: c,
      headerActions: u,
      children: [
        /* @__PURE__ */ h.jsx(qgt, { initialData: e == null ? void 0 : e.data, onSave: o }),
        /* @__PURE__ */ h.jsx(Xgt, { open: l, onOpenChange: d })
      ]
    }
  );
}
const SC = er.board;
function Zgt() {
  return /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(zl, { title: SC.title, icon: SC.icon }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 overflow-auto", children: /* @__PURE__ */ h.jsx(
      nF,
      {
        type: "board",
        newPath: "/board/new",
        emptyTitle: `No ${SC.typeLabel}s yet`,
        emptyDescription: "Create your first kanban board or task tracker",
        newButtonLabel: `New ${SC.title}`
      }
    ) })
  ] });
}
function cu(t) {
  "@babel/helpers - typeof";
  return cu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, cu(t);
}
function Qgt(t, e) {
  if (cu(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (cu(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function bme(t) {
  var e = Qgt(t, "string");
  return cu(e) == "symbol" ? e : e + "";
}
function $h(t, e, n) {
  return (e = bme(e)) in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function GW(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dn(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? GW(Object(n), !0).forEach(function(r) {
      $h(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : GW(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function Si(t) {
  return "Minified Redux error #" + t + "; visit https://redux.js.org/Errors?code=" + t + " for the full message or use the non-minified dev environment for full errors. ";
}
var YW = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}(), y2 = function() {
  return Math.random().toString(36).substring(7).split("").join(".");
}, qW = {
  INIT: "@@redux/INIT" + y2(),
  REPLACE: "@@redux/REPLACE" + y2(),
  PROBE_UNKNOWN_ACTION: function() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + y2();
  }
};
function Jgt(t) {
  if (typeof t != "object" || t === null) return !1;
  for (var e = t; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e;
}
function emt(t) {
  if (t === void 0) return "undefined";
  if (t === null) return "null";
  var e = typeof t;
  switch (e) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return e;
  }
  if (Array.isArray(t)) return "array";
  if (rmt(t)) return "date";
  if (nmt(t)) return "error";
  var n = tmt(t);
  switch (n) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return n;
  }
  return e.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function tmt(t) {
  return typeof t.constructor == "function" ? t.constructor.name : null;
}
function nmt(t) {
  return t instanceof Error || typeof t.message == "string" && t.constructor && typeof t.constructor.stackTraceLimit == "number";
}
function rmt(t) {
  return t instanceof Date ? !0 : typeof t.toDateString == "function" && typeof t.getDate == "function" && typeof t.setDate == "function";
}
function kh(t) {
  var e = typeof t;
  return process.env.NODE_ENV !== "production" && (e = emt(t)), e;
}
function xme(t, e, n) {
  var r;
  if (typeof e == "function" && typeof n == "function" || typeof n == "function" && typeof arguments[3] == "function")
    throw new Error(process.env.NODE_ENV === "production" ? Si(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if (typeof e == "function" && typeof n > "u" && (n = e, e = void 0), typeof n < "u") {
    if (typeof n != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Si(1) : "Expected the enhancer to be a function. Instead, received: '" + kh(n) + "'");
    return n(xme)(t, e);
  }
  if (typeof t != "function")
    throw new Error(process.env.NODE_ENV === "production" ? Si(2) : "Expected the root reducer to be a function. Instead, received: '" + kh(t) + "'");
  var s = t, o = e, i = [], a = i, c = !1;
  function l() {
    a === i && (a = i.slice());
  }
  function d() {
    if (c)
      throw new Error(process.env.NODE_ENV === "production" ? Si(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return o;
  }
  function u(y) {
    if (typeof y != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Si(4) : "Expected the listener to be a function. Instead, received: '" + kh(y) + "'");
    if (c)
      throw new Error(process.env.NODE_ENV === "production" ? Si(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    var m = !0;
    return l(), a.push(y), function() {
      if (m) {
        if (c)
          throw new Error(process.env.NODE_ENV === "production" ? Si(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        m = !1, l();
        var b = a.indexOf(y);
        a.splice(b, 1), i = null;
      }
    };
  }
  function f(y) {
    if (!Jgt(y))
      throw new Error(process.env.NODE_ENV === "production" ? Si(7) : "Actions must be plain objects. Instead, the actual type was: '" + kh(y) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    if (typeof y.type > "u")
      throw new Error(process.env.NODE_ENV === "production" ? Si(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (c)
      throw new Error(process.env.NODE_ENV === "production" ? Si(9) : "Reducers may not dispatch actions.");
    try {
      c = !0, o = s(o, y);
    } finally {
      c = !1;
    }
    for (var m = i = a, v = 0; v < m.length; v++) {
      var b = m[v];
      b();
    }
    return y;
  }
  function p(y) {
    if (typeof y != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Si(10) : "Expected the nextReducer to be a function. Instead, received: '" + kh(y));
    s = y, f({
      type: qW.REPLACE
    });
  }
  function g() {
    var y, m = u;
    return y = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function(b) {
        if (typeof b != "object" || b === null)
          throw new Error(process.env.NODE_ENV === "production" ? Si(11) : "Expected the observer to be an object. Instead, received: '" + kh(b) + "'");
        function x() {
          b.next && b.next(d());
        }
        x();
        var w = m(x);
        return {
          unsubscribe: w
        };
      }
    }, y[YW] = function() {
      return this;
    }, y;
  }
  return f({
    type: qW.INIT
  }), r = {
    dispatch: f,
    subscribe: u,
    getState: d,
    replaceReducer: p
  }, r[YW] = g, r;
}
function XW(t, e) {
  return function() {
    return e(t.apply(this, arguments));
  };
}
function ZW(t, e) {
  if (typeof t == "function")
    return XW(t, e);
  if (typeof t != "object" || t === null)
    throw new Error(process.env.NODE_ENV === "production" ? Si(16) : "bindActionCreators expected an object or a function, but instead received: '" + kh(t) + `'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
  var n = {};
  for (var r in t) {
    var s = t[r];
    typeof s == "function" && (n[r] = XW(s, e));
  }
  return n;
}
function wme() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return e.length === 0 ? function(r) {
    return r;
  } : e.length === 1 ? e[0] : e.reduce(function(r, s) {
    return function() {
      return r(s.apply(void 0, arguments));
    };
  });
}
function smt() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return function(r) {
    return function() {
      var s = r.apply(void 0, arguments), o = function() {
        throw new Error(process.env.NODE_ENV === "production" ? Si(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      }, i = {
        getState: s.getState,
        dispatch: function() {
          return o.apply(void 0, arguments);
        }
      }, a = e.map(function(c) {
        return c(i);
      });
      return o = wme.apply(void 0, a)(s.dispatch), Dn(Dn({}, s), {}, {
        dispatch: o
      });
    };
  };
}
function omt(t) {
  t();
}
let Sme = omt;
const imt = (t) => Sme = t, amt = () => Sme, QW = Symbol.for("react-redux-context"), JW = typeof globalThis < "u" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function cmt() {
  var t;
  if (!T.createContext) return {};
  const e = (t = JW[QW]) != null ? t : JW[QW] = /* @__PURE__ */ new Map();
  let n = e.get(T.createContext);
  return n || (n = T.createContext(null), process.env.NODE_ENV !== "production" && (n.displayName = "ReactRedux"), e.set(T.createContext, n)), n;
}
const Cme = /* @__PURE__ */ cmt(), lmt = () => {
  throw new Error("uSES not initialized!");
};
function Rn() {
  return Rn = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Rn.apply(null, arguments);
}
function bv(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t) if ({}.hasOwnProperty.call(t, r)) {
    if (e.indexOf(r) !== -1) continue;
    n[r] = t[r];
  }
  return n;
}
var e$ = { exports: {} }, wn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eK;
function dmt() {
  if (eK) return wn;
  eK = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, s = t ? Symbol.for("react.strict_mode") : 60108, o = t ? Symbol.for("react.profiler") : 60114, i = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, c = t ? Symbol.for("react.async_mode") : 60111, l = t ? Symbol.for("react.concurrent_mode") : 60111, d = t ? Symbol.for("react.forward_ref") : 60112, u = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, p = t ? Symbol.for("react.memo") : 60115, g = t ? Symbol.for("react.lazy") : 60116, y = t ? Symbol.for("react.block") : 60121, m = t ? Symbol.for("react.fundamental") : 60117, v = t ? Symbol.for("react.responder") : 60118, b = t ? Symbol.for("react.scope") : 60119;
  function x(S) {
    if (typeof S == "object" && S !== null) {
      var C = S.$$typeof;
      switch (C) {
        case e:
          switch (S = S.type, S) {
            case c:
            case l:
            case r:
            case o:
            case s:
            case u:
              return S;
            default:
              switch (S = S && S.$$typeof, S) {
                case a:
                case d:
                case g:
                case p:
                case i:
                  return S;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function w(S) {
    return x(S) === l;
  }
  return wn.AsyncMode = c, wn.ConcurrentMode = l, wn.ContextConsumer = a, wn.ContextProvider = i, wn.Element = e, wn.ForwardRef = d, wn.Fragment = r, wn.Lazy = g, wn.Memo = p, wn.Portal = n, wn.Profiler = o, wn.StrictMode = s, wn.Suspense = u, wn.isAsyncMode = function(S) {
    return w(S) || x(S) === c;
  }, wn.isConcurrentMode = w, wn.isContextConsumer = function(S) {
    return x(S) === a;
  }, wn.isContextProvider = function(S) {
    return x(S) === i;
  }, wn.isElement = function(S) {
    return typeof S == "object" && S !== null && S.$$typeof === e;
  }, wn.isForwardRef = function(S) {
    return x(S) === d;
  }, wn.isFragment = function(S) {
    return x(S) === r;
  }, wn.isLazy = function(S) {
    return x(S) === g;
  }, wn.isMemo = function(S) {
    return x(S) === p;
  }, wn.isPortal = function(S) {
    return x(S) === n;
  }, wn.isProfiler = function(S) {
    return x(S) === o;
  }, wn.isStrictMode = function(S) {
    return x(S) === s;
  }, wn.isSuspense = function(S) {
    return x(S) === u;
  }, wn.isValidElementType = function(S) {
    return typeof S == "string" || typeof S == "function" || S === r || S === l || S === o || S === s || S === u || S === f || typeof S == "object" && S !== null && (S.$$typeof === g || S.$$typeof === p || S.$$typeof === i || S.$$typeof === a || S.$$typeof === d || S.$$typeof === m || S.$$typeof === v || S.$$typeof === b || S.$$typeof === y);
  }, wn.typeOf = x, wn;
}
var Sn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tK;
function umt() {
  return tK || (tK = 1, process.env.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, s = t ? Symbol.for("react.strict_mode") : 60108, o = t ? Symbol.for("react.profiler") : 60114, i = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, c = t ? Symbol.for("react.async_mode") : 60111, l = t ? Symbol.for("react.concurrent_mode") : 60111, d = t ? Symbol.for("react.forward_ref") : 60112, u = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, p = t ? Symbol.for("react.memo") : 60115, g = t ? Symbol.for("react.lazy") : 60116, y = t ? Symbol.for("react.block") : 60121, m = t ? Symbol.for("react.fundamental") : 60117, v = t ? Symbol.for("react.responder") : 60118, b = t ? Symbol.for("react.scope") : 60119;
    function x(G) {
      return typeof G == "string" || typeof G == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      G === r || G === l || G === o || G === s || G === u || G === f || typeof G == "object" && G !== null && (G.$$typeof === g || G.$$typeof === p || G.$$typeof === i || G.$$typeof === a || G.$$typeof === d || G.$$typeof === m || G.$$typeof === v || G.$$typeof === b || G.$$typeof === y);
    }
    function w(G) {
      if (typeof G == "object" && G !== null) {
        var xe = G.$$typeof;
        switch (xe) {
          case e:
            var ge = G.type;
            switch (ge) {
              case c:
              case l:
              case r:
              case o:
              case s:
              case u:
                return ge;
              default:
                var ze = ge && ge.$$typeof;
                switch (ze) {
                  case a:
                  case d:
                  case g:
                  case p:
                  case i:
                    return ze;
                  default:
                    return xe;
                }
            }
          case n:
            return xe;
        }
      }
    }
    var S = c, C = l, _ = a, E = i, M = e, N = d, O = r, D = g, k = p, A = n, R = o, j = s, $ = u, F = !1;
    function L(G) {
      return F || (F = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), z(G) || w(G) === c;
    }
    function z(G) {
      return w(G) === l;
    }
    function H(G) {
      return w(G) === a;
    }
    function U(G) {
      return w(G) === i;
    }
    function W(G) {
      return typeof G == "object" && G !== null && G.$$typeof === e;
    }
    function Z(G) {
      return w(G) === d;
    }
    function K(G) {
      return w(G) === r;
    }
    function oe(G) {
      return w(G) === g;
    }
    function Y(G) {
      return w(G) === p;
    }
    function ee(G) {
      return w(G) === n;
    }
    function ae(G) {
      return w(G) === o;
    }
    function de(G) {
      return w(G) === s;
    }
    function ye(G) {
      return w(G) === u;
    }
    Sn.AsyncMode = S, Sn.ConcurrentMode = C, Sn.ContextConsumer = _, Sn.ContextProvider = E, Sn.Element = M, Sn.ForwardRef = N, Sn.Fragment = O, Sn.Lazy = D, Sn.Memo = k, Sn.Portal = A, Sn.Profiler = R, Sn.StrictMode = j, Sn.Suspense = $, Sn.isAsyncMode = L, Sn.isConcurrentMode = z, Sn.isContextConsumer = H, Sn.isContextProvider = U, Sn.isElement = W, Sn.isForwardRef = Z, Sn.isFragment = K, Sn.isLazy = oe, Sn.isMemo = Y, Sn.isPortal = ee, Sn.isProfiler = ae, Sn.isStrictMode = de, Sn.isSuspense = ye, Sn.isValidElementType = x, Sn.typeOf = w;
  }()), Sn;
}
process.env.NODE_ENV === "production" ? e$.exports = dmt() : e$.exports = umt();
var fmt = e$.exports, G4 = fmt, hmt = {
  childContextTypes: !0,
  contextType: !0,
  contextTypes: !0,
  defaultProps: !0,
  displayName: !0,
  getDefaultProps: !0,
  getDerivedStateFromError: !0,
  getDerivedStateFromProps: !0,
  mixins: !0,
  propTypes: !0,
  type: !0
}, pmt = {
  name: !0,
  length: !0,
  prototype: !0,
  caller: !0,
  callee: !0,
  arguments: !0,
  arity: !0
}, gmt = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, _me = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, Y4 = {};
Y4[G4.ForwardRef] = gmt;
Y4[G4.Memo] = _me;
function nK(t) {
  return G4.isMemo(t) ? _me : Y4[t.$$typeof] || hmt;
}
var mmt = Object.defineProperty, ymt = Object.getOwnPropertyNames, rK = Object.getOwnPropertySymbols, vmt = Object.getOwnPropertyDescriptor, bmt = Object.getPrototypeOf, sK = Object.prototype;
function Eme(t, e, n) {
  if (typeof e != "string") {
    if (sK) {
      var r = bmt(e);
      r && r !== sK && Eme(t, r, n);
    }
    var s = ymt(e);
    rK && (s = s.concat(rK(e)));
    for (var o = nK(t), i = nK(e), a = 0; a < s.length; ++a) {
      var c = s[a];
      if (!pmt[c] && !(n && n[c]) && !(i && i[c]) && !(o && o[c])) {
        var l = vmt(e, c);
        try {
          mmt(t, c, l);
        } catch {
        }
      }
    }
  }
  return t;
}
var xmt = Eme;
const oK = /* @__PURE__ */ Wr(xmt);
var t$ = { exports: {} }, Cn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iK;
function wmt() {
  if (iK) return Cn;
  iK = 1;
  var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), i = Symbol.for("react.context"), a = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), g;
  g = Symbol.for("react.module.reference");
  function y(m) {
    if (typeof m == "object" && m !== null) {
      var v = m.$$typeof;
      switch (v) {
        case t:
          switch (m = m.type, m) {
            case n:
            case s:
            case r:
            case l:
            case d:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case a:
                case i:
                case c:
                case f:
                case u:
                case o:
                  return m;
                default:
                  return v;
              }
          }
        case e:
          return v;
      }
    }
  }
  return Cn.ContextConsumer = i, Cn.ContextProvider = o, Cn.Element = t, Cn.ForwardRef = c, Cn.Fragment = n, Cn.Lazy = f, Cn.Memo = u, Cn.Portal = e, Cn.Profiler = s, Cn.StrictMode = r, Cn.Suspense = l, Cn.SuspenseList = d, Cn.isAsyncMode = function() {
    return !1;
  }, Cn.isConcurrentMode = function() {
    return !1;
  }, Cn.isContextConsumer = function(m) {
    return y(m) === i;
  }, Cn.isContextProvider = function(m) {
    return y(m) === o;
  }, Cn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Cn.isForwardRef = function(m) {
    return y(m) === c;
  }, Cn.isFragment = function(m) {
    return y(m) === n;
  }, Cn.isLazy = function(m) {
    return y(m) === f;
  }, Cn.isMemo = function(m) {
    return y(m) === u;
  }, Cn.isPortal = function(m) {
    return y(m) === e;
  }, Cn.isProfiler = function(m) {
    return y(m) === s;
  }, Cn.isStrictMode = function(m) {
    return y(m) === r;
  }, Cn.isSuspense = function(m) {
    return y(m) === l;
  }, Cn.isSuspenseList = function(m) {
    return y(m) === d;
  }, Cn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === n || m === s || m === r || m === l || m === d || m === p || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === u || m.$$typeof === o || m.$$typeof === i || m.$$typeof === c || m.$$typeof === g || m.getModuleId !== void 0);
  }, Cn.typeOf = y, Cn;
}
var _n = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aK;
function Smt() {
  return aK || (aK = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), i = Symbol.for("react.context"), a = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), g = !1, y = !1, m = !1, v = !1, b = !1, x;
    x = Symbol.for("react.module.reference");
    function w(ge) {
      return !!(typeof ge == "string" || typeof ge == "function" || ge === n || ge === s || b || ge === r || ge === l || ge === d || v || ge === p || g || y || m || typeof ge == "object" && ge !== null && (ge.$$typeof === f || ge.$$typeof === u || ge.$$typeof === o || ge.$$typeof === i || ge.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ge.$$typeof === x || ge.getModuleId !== void 0));
    }
    function S(ge) {
      if (typeof ge == "object" && ge !== null) {
        var ze = ge.$$typeof;
        switch (ze) {
          case t:
            var Ge = ge.type;
            switch (Ge) {
              case n:
              case s:
              case r:
              case l:
              case d:
                return Ge;
              default:
                var Ct = Ge && Ge.$$typeof;
                switch (Ct) {
                  case a:
                  case i:
                  case c:
                  case f:
                  case u:
                  case o:
                    return Ct;
                  default:
                    return ze;
                }
            }
          case e:
            return ze;
        }
      }
    }
    var C = i, _ = o, E = t, M = c, N = n, O = f, D = u, k = e, A = s, R = r, j = l, $ = d, F = !1, L = !1;
    function z(ge) {
      return F || (F = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function H(ge) {
      return L || (L = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function U(ge) {
      return S(ge) === i;
    }
    function W(ge) {
      return S(ge) === o;
    }
    function Z(ge) {
      return typeof ge == "object" && ge !== null && ge.$$typeof === t;
    }
    function K(ge) {
      return S(ge) === c;
    }
    function oe(ge) {
      return S(ge) === n;
    }
    function Y(ge) {
      return S(ge) === f;
    }
    function ee(ge) {
      return S(ge) === u;
    }
    function ae(ge) {
      return S(ge) === e;
    }
    function de(ge) {
      return S(ge) === s;
    }
    function ye(ge) {
      return S(ge) === r;
    }
    function G(ge) {
      return S(ge) === l;
    }
    function xe(ge) {
      return S(ge) === d;
    }
    _n.ContextConsumer = C, _n.ContextProvider = _, _n.Element = E, _n.ForwardRef = M, _n.Fragment = N, _n.Lazy = O, _n.Memo = D, _n.Portal = k, _n.Profiler = A, _n.StrictMode = R, _n.Suspense = j, _n.SuspenseList = $, _n.isAsyncMode = z, _n.isConcurrentMode = H, _n.isContextConsumer = U, _n.isContextProvider = W, _n.isElement = Z, _n.isForwardRef = K, _n.isFragment = oe, _n.isLazy = Y, _n.isMemo = ee, _n.isPortal = ae, _n.isProfiler = de, _n.isStrictMode = ye, _n.isSuspense = G, _n.isSuspenseList = xe, _n.isValidElementType = w, _n.typeOf = S;
  }()), _n;
}
process.env.NODE_ENV === "production" ? t$.exports = wmt() : t$.exports = Smt();
var cK = t$.exports;
function q4(t) {
  typeof console < "u" && typeof console.error == "function" && console.error(t);
  try {
    throw new Error(t);
  } catch {
  }
}
function v2(t, e) {
  if (t)
    (e === "mapStateToProps" || e === "mapDispatchToProps") && (Object.prototype.hasOwnProperty.call(t, "dependsOnOwnProps") || q4(`The selector for ${e} of connect did not specify a value for dependsOnOwnProps.`));
  else throw new Error(`Unexpected value for ${e} in connect.`);
}
function Cmt(t, e, n) {
  v2(t, "mapStateToProps"), v2(e, "mapDispatchToProps"), v2(n, "mergeProps");
}
const _mt = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
function Emt(t, e, n, r, {
  areStatesEqual: s,
  areOwnPropsEqual: o,
  areStatePropsEqual: i
}) {
  let a = !1, c, l, d, u, f;
  function p(b, x) {
    return c = b, l = x, d = t(c, l), u = e(r, l), f = n(d, u, l), a = !0, f;
  }
  function g() {
    return d = t(c, l), e.dependsOnOwnProps && (u = e(r, l)), f = n(d, u, l), f;
  }
  function y() {
    return t.dependsOnOwnProps && (d = t(c, l)), e.dependsOnOwnProps && (u = e(r, l)), f = n(d, u, l), f;
  }
  function m() {
    const b = t(c, l), x = !i(b, d);
    return d = b, x && (f = n(d, u, l)), f;
  }
  function v(b, x) {
    const w = !o(x, l), S = !s(b, c, x, l);
    return c = b, l = x, w && S ? g() : w ? y() : S ? m() : f;
  }
  return function(x, w) {
    return a ? v(x, w) : p(x, w);
  };
}
function Tmt(t, e) {
  let {
    initMapStateToProps: n,
    initMapDispatchToProps: r,
    initMergeProps: s
  } = e, o = bv(e, _mt);
  const i = n(t, o), a = r(t, o), c = s(t, o);
  return process.env.NODE_ENV !== "production" && Cmt(i, a, c), Emt(i, a, c, t, o);
}
function Pmt(t, e) {
  const n = {};
  for (const r in t) {
    const s = t[r];
    typeof s == "function" && (n[r] = (...o) => e(s(...o)));
  }
  return n;
}
function Imt(t) {
  if (typeof t != "object" || t === null) return !1;
  let e = Object.getPrototypeOf(t);
  if (e === null) return !0;
  let n = e;
  for (; Object.getPrototypeOf(n) !== null; )
    n = Object.getPrototypeOf(n);
  return e === n;
}
function Tme(t, e, n) {
  Imt(t) || q4(`${n}() in ${e} must return a plain object. Instead received ${t}.`);
}
function n$(t) {
  return function(n) {
    const r = t(n);
    function s() {
      return r;
    }
    return s.dependsOnOwnProps = !1, s;
  };
}
function lK(t) {
  return t.dependsOnOwnProps ? !!t.dependsOnOwnProps : t.length !== 1;
}
function Pme(t, e) {
  return function(r, {
    displayName: s
  }) {
    const o = function(a, c) {
      return o.dependsOnOwnProps ? o.mapToProps(a, c) : o.mapToProps(a, void 0);
    };
    return o.dependsOnOwnProps = !0, o.mapToProps = function(a, c) {
      o.mapToProps = t, o.dependsOnOwnProps = lK(t);
      let l = o(a, c);
      return typeof l == "function" && (o.mapToProps = l, o.dependsOnOwnProps = lK(l), l = o(a, c)), process.env.NODE_ENV !== "production" && Tme(l, s, e), l;
    }, o;
  };
}
function X4(t, e) {
  return (n, r) => {
    throw new Error(`Invalid value of type ${typeof t} for ${e} argument when connecting component ${r.wrappedComponentName}.`);
  };
}
function kmt(t) {
  return t && typeof t == "object" ? n$((e) => (
    // @ts-ignore
    Pmt(t, e)
  )) : t ? typeof t == "function" ? (
    // @ts-ignore
    Pme(t, "mapDispatchToProps")
  ) : X4(t, "mapDispatchToProps") : n$((e) => ({
    dispatch: e
  }));
}
function Amt(t) {
  return t ? typeof t == "function" ? (
    // @ts-ignore
    Pme(t, "mapStateToProps")
  ) : X4(t, "mapStateToProps") : n$(() => ({}));
}
function Mmt(t, e, n) {
  return Rn({}, n, t, e);
}
function Omt(t) {
  return function(n, {
    displayName: r,
    areMergedPropsEqual: s
  }) {
    let o = !1, i;
    return function(c, l, d) {
      const u = t(c, l, d);
      return o ? s(u, i) || (i = u) : (o = !0, i = u, process.env.NODE_ENV !== "production" && Tme(i, r, "mergeProps")), i;
    };
  };
}
function Dmt(t) {
  return t ? typeof t == "function" ? Omt(t) : X4(t, "mergeProps") : () => Mmt;
}
function Nmt() {
  const t = amt();
  let e = null, n = null;
  return {
    clear() {
      e = null, n = null;
    },
    notify() {
      t(() => {
        let r = e;
        for (; r; )
          r.callback(), r = r.next;
      });
    },
    get() {
      let r = [], s = e;
      for (; s; )
        r.push(s), s = s.next;
      return r;
    },
    subscribe(r) {
      let s = !0, o = n = {
        callback: r,
        next: null,
        prev: n
      };
      return o.prev ? o.prev.next = o : e = o, function() {
        !s || e === null || (s = !1, o.next ? o.next.prev = o.prev : n = o.prev, o.prev ? o.prev.next = o.next : e = o.next);
      };
    }
  };
}
const dK = {
  notify() {
  },
  get: () => []
};
function Ime(t, e) {
  let n, r = dK, s = 0, o = !1;
  function i(y) {
    d();
    const m = r.subscribe(y);
    let v = !1;
    return () => {
      v || (v = !0, m(), u());
    };
  }
  function a() {
    r.notify();
  }
  function c() {
    g.onStateChange && g.onStateChange();
  }
  function l() {
    return o;
  }
  function d() {
    s++, n || (n = e ? e.addNestedSub(c) : t.subscribe(c), r = Nmt());
  }
  function u() {
    s--, n && s === 0 && (n(), n = void 0, r.clear(), r = dK);
  }
  function f() {
    o || (o = !0, d());
  }
  function p() {
    o && (o = !1, u());
  }
  const g = {
    addNestedSub: i,
    notifyNestedSubs: a,
    handleChangeWrapper: c,
    isSubscribed: l,
    trySubscribe: f,
    tryUnsubscribe: p,
    getListeners: () => r
  };
  return g;
}
const jmt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", dP = jmt ? T.useLayoutEffect : T.useEffect;
function uK(t, e) {
  return t === e ? t !== 0 || e !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function b2(t, e) {
  if (uK(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  const n = Object.keys(t), r = Object.keys(e);
  if (n.length !== r.length) return !1;
  for (let s = 0; s < n.length; s++)
    if (!Object.prototype.hasOwnProperty.call(e, n[s]) || !uK(t[n[s]], e[n[s]]))
      return !1;
  return !0;
}
const Rmt = ["reactReduxForwardedRef"];
let kme = lmt;
const $mt = (t) => {
  kme = t;
}, Lmt = [null, null], Fmt = (t) => {
  try {
    return JSON.stringify(t);
  } catch {
    return String(t);
  }
};
function Bmt(t, e, n) {
  dP(() => t(...e), n);
}
function zmt(t, e, n, r, s, o) {
  t.current = r, n.current = !1, s.current && (s.current = null, o());
}
function Umt(t, e, n, r, s, o, i, a, c, l, d) {
  if (!t) return () => {
  };
  let u = !1, f = null;
  const p = () => {
    if (u || !a.current)
      return;
    const y = e.getState();
    let m, v;
    try {
      m = r(y, s.current);
    } catch (b) {
      v = b, f = b;
    }
    v || (f = null), m === o.current ? i.current || l() : (o.current = m, c.current = m, i.current = !0, d());
  };
  return n.onStateChange = p, n.trySubscribe(), p(), () => {
    if (u = !0, n.tryUnsubscribe(), n.onStateChange = null, f)
      throw f;
  };
}
function Hmt(t, e) {
  return t === e;
}
let fK = !1;
function Ame(t, e, n, {
  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
  // @ts-ignore
  pure: r,
  areStatesEqual: s = Hmt,
  areOwnPropsEqual: o = b2,
  areStatePropsEqual: i = b2,
  areMergedPropsEqual: a = b2,
  // use React's forwardRef to expose a ref of the wrapped component
  forwardRef: c = !1,
  // the context consumer to use
  context: l = Cme
} = {}) {
  process.env.NODE_ENV !== "production" && r !== void 0 && !fK && (fK = !0, q4('The `pure` option has been removed. `connect` is now always a "pure/memoized" component'));
  const d = l, u = Amt(t), f = kmt(e), p = Dmt(n), g = !!t;
  return (m) => {
    if (process.env.NODE_ENV !== "production" && !cK.isValidElementType(m))
      throw new Error(`You must pass a component to the function returned by connect. Instead received ${Fmt(m)}`);
    const v = m.displayName || m.name || "Component", b = `Connect(${v})`, x = {
      shouldHandleStateChanges: g,
      displayName: b,
      wrappedComponentName: v,
      WrappedComponent: m,
      // @ts-ignore
      initMapStateToProps: u,
      // @ts-ignore
      initMapDispatchToProps: f,
      initMergeProps: p,
      areStatesEqual: s,
      areStatePropsEqual: i,
      areOwnPropsEqual: o,
      areMergedPropsEqual: a
    };
    function w(_) {
      const [E, M, N] = T.useMemo(() => {
        const {
          reactReduxForwardedRef: G
        } = _, xe = bv(_, Rmt);
        return [_.context, G, xe];
      }, [_]), O = T.useMemo(() => E && E.Consumer && // @ts-ignore
      cK.isContextConsumer(/* @__PURE__ */ T.createElement(E.Consumer, null)) ? E : d, [E, d]), D = T.useContext(O), k = !!_.store && !!_.store.getState && !!_.store.dispatch, A = !!D && !!D.store;
      if (process.env.NODE_ENV !== "production" && !k && !A)
        throw new Error(`Could not find "store" in the context of "${b}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${b} in connect options.`);
      const R = k ? _.store : D.store, j = A ? D.getServerState : R.getState, $ = T.useMemo(() => Tmt(R.dispatch, x), [R]), [F, L] = T.useMemo(() => {
        if (!g) return Lmt;
        const G = Ime(R, k ? void 0 : D.subscription), xe = G.notifyNestedSubs.bind(G);
        return [G, xe];
      }, [R, k, D]), z = T.useMemo(() => k ? D : Rn({}, D, {
        subscription: F
      }), [k, D, F]), H = T.useRef(), U = T.useRef(N), W = T.useRef(), Z = T.useRef(!1);
      T.useRef(!1);
      const K = T.useRef(!1), oe = T.useRef();
      dP(() => (K.current = !0, () => {
        K.current = !1;
      }), []);
      const Y = T.useMemo(() => () => W.current && N === U.current ? W.current : $(R.getState(), N), [R, N]), ee = T.useMemo(() => (xe) => F ? Umt(
        g,
        R,
        F,
        // @ts-ignore
        $,
        U,
        H,
        Z,
        K,
        W,
        L,
        xe
      ) : () => {
      }, [F]);
      Bmt(zmt, [U, H, Z, N, W, L]);
      let ae;
      try {
        ae = kme(
          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
          ee,
          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
          Y,
          j ? () => $(j(), N) : Y
        );
      } catch (G) {
        throw oe.current && (G.message += `
The error may be correlated with this previous error:
${oe.current.stack}

`), G;
      }
      dP(() => {
        oe.current = void 0, W.current = void 0, H.current = ae;
      });
      const de = T.useMemo(() => (
        // @ts-ignore
        /* @__PURE__ */ T.createElement(m, Rn({}, ae, {
          ref: M
        }))
      ), [M, m, ae]);
      return T.useMemo(() => g ? /* @__PURE__ */ T.createElement(O.Provider, {
        value: z
      }, de) : de, [O, de, z]);
    }
    const C = T.memo(w);
    if (C.WrappedComponent = m, C.displayName = w.displayName = b, c) {
      const E = T.forwardRef(function(N, O) {
        return /* @__PURE__ */ T.createElement(C, Rn({}, N, {
          reactReduxForwardedRef: O
        }));
      });
      return E.displayName = b, E.WrappedComponent = m, oK(E, m);
    }
    return oK(C, m);
  };
}
function Vmt({
  store: t,
  context: e,
  children: n,
  serverState: r,
  stabilityCheck: s = "once",
  noopCheck: o = "once"
}) {
  const i = T.useMemo(() => {
    const l = Ime(t);
    return {
      store: t,
      subscription: l,
      getServerState: r ? () => r : void 0,
      stabilityCheck: s,
      noopCheck: o
    };
  }, [t, r, s, o]), a = T.useMemo(() => t.getState(), [t]);
  dP(() => {
    const {
      subscription: l
    } = i;
    return l.onStateChange = l.notifyNestedSubs, l.trySubscribe(), a !== t.getState() && l.notifyNestedSubs(), () => {
      l.tryUnsubscribe(), l.onStateChange = void 0;
    };
  }, [i, a]);
  const c = e || Cme;
  return /* @__PURE__ */ T.createElement(c.Provider, {
    value: i
  }, n);
}
$mt(IGe.useSyncExternalStore);
imt(Vbe);
function Wmt(t, e) {
  if (t.length !== e.length)
    return !1;
  for (var n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function Mme(t, e) {
  var n = he(function() {
    return {
      inputs: e,
      result: t()
    };
  })[0], r = fe(!0), s = fe(n), o = r.current || !!(e && s.current.inputs && Wmt(e, s.current.inputs)), i = o ? s.current : {
    inputs: e,
    result: t()
  };
  return me(function() {
    r.current = !1, s.current = i;
  }, [i]), i.result;
}
function Kmt(t, e) {
  return Mme(function() {
    return t;
  }, e);
}
var rn = Mme, at = Kmt, Gmt = process.env.NODE_ENV === "production", x2 = "Invariant failed";
function hK(t, e) {
  if (Gmt)
    throw new Error(x2);
  var n = typeof e == "function" ? e() : e, r = n ? "".concat(x2, ": ").concat(n) : x2;
  throw new Error(r);
}
var Gc = function(e) {
  var n = e.top, r = e.right, s = e.bottom, o = e.left, i = r - o, a = s - n, c = {
    top: n,
    right: r,
    bottom: s,
    left: o,
    width: i,
    height: a,
    x: o,
    y: n,
    center: {
      x: (r + o) / 2,
      y: (s + n) / 2
    }
  };
  return c;
}, Z4 = function(e, n) {
  return {
    top: e.top - n.top,
    left: e.left - n.left,
    bottom: e.bottom + n.bottom,
    right: e.right + n.right
  };
}, pK = function(e, n) {
  return {
    top: e.top + n.top,
    left: e.left + n.left,
    bottom: e.bottom - n.bottom,
    right: e.right - n.right
  };
}, Ymt = function(e, n) {
  return {
    top: e.top + n.y,
    left: e.left + n.x,
    bottom: e.bottom + n.y,
    right: e.right + n.x
  };
}, w2 = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
}, Q4 = function(e) {
  var n = e.borderBox, r = e.margin, s = r === void 0 ? w2 : r, o = e.border, i = o === void 0 ? w2 : o, a = e.padding, c = a === void 0 ? w2 : a, l = Gc(Z4(n, s)), d = Gc(pK(n, i)), u = Gc(pK(d, c));
  return {
    marginBox: l,
    borderBox: Gc(n),
    paddingBox: d,
    contentBox: u,
    margin: s,
    border: i,
    padding: c
  };
}, za = function(e) {
  var n = e.slice(0, -2), r = e.slice(-2);
  if (r !== "px")
    return 0;
  var s = Number(n);
  return isNaN(s) && (process.env.NODE_ENV !== "production" ? hK(!1, "Could not parse value [raw: " + e + ", without suffix: " + n + "]") : hK()), s;
}, qmt = function() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
}, uP = function(e, n) {
  var r = e.borderBox, s = e.border, o = e.margin, i = e.padding, a = Ymt(r, n);
  return Q4({
    borderBox: a,
    border: s,
    margin: o,
    padding: i
  });
}, fP = function(e, n) {
  return n === void 0 && (n = qmt()), uP(e, n);
}, Ome = function(e, n) {
  var r = {
    top: za(n.marginTop),
    right: za(n.marginRight),
    bottom: za(n.marginBottom),
    left: za(n.marginLeft)
  }, s = {
    top: za(n.paddingTop),
    right: za(n.paddingRight),
    bottom: za(n.paddingBottom),
    left: za(n.paddingLeft)
  }, o = {
    top: za(n.borderTopWidth),
    right: za(n.borderRightWidth),
    bottom: za(n.borderBottomWidth),
    left: za(n.borderLeftWidth)
  };
  return Q4({
    borderBox: e,
    margin: r,
    padding: s,
    border: o
  });
}, Dme = function(e) {
  var n = e.getBoundingClientRect(), r = window.getComputedStyle(e);
  return Ome(n, r);
}, gK = Number.isNaN || function(e) {
  return typeof e == "number" && e !== e;
};
function Xmt(t, e) {
  return !!(t === e || gK(t) && gK(e));
}
function Zmt(t, e) {
  if (t.length !== e.length)
    return !1;
  for (var n = 0; n < t.length; n++)
    if (!Xmt(t[n], e[n]))
      return !1;
  return !0;
}
function cs(t, e) {
  e === void 0 && (e = Zmt);
  var n = null;
  function r() {
    for (var s = [], o = 0; o < arguments.length; o++)
      s[o] = arguments[o];
    if (n && n.lastThis === this && e(s, n.lastArgs))
      return n.lastResult;
    var i = t.apply(this, s);
    return n = {
      lastResult: i,
      lastArgs: s,
      lastThis: this
    }, i;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
var Kw = function(e) {
  var n = [], r = null, s = function() {
    for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
      a[c] = arguments[c];
    n = a, !r && (r = requestAnimationFrame(function() {
      r = null, e.apply(void 0, n);
    }));
  };
  return s.cancel = function() {
    r && (cancelAnimationFrame(r), r = null);
  }, s;
};
const Qmt = process.env.NODE_ENV === "production", Jmt = /[ \t]{2,}/g, eyt = /^[ \t]*/gm, mK = (t) => t.replace(Jmt, " ").replace(eyt, "").trim(), tyt = (t) => mK(`
  %c@hello-pangea/dnd

  %c${mK(t)}

  %c This is a development only message. It will be removed in production builds.
`), nyt = (t) => [tyt(t), "color: #00C584; font-size: 1.2em; font-weight: bold;", "line-height: 1.5", "color: #723874;"], ryt = "__@hello-pangea/dnd-disable-dev-warnings";
function Nme(t, e) {
  Qmt || typeof window < "u" && window[ryt] || console[t](...nyt(e));
}
const Vn = Nme.bind(null, "warn"), r$ = Nme.bind(null, "error");
function Tf() {
}
function syt(t, e) {
  return {
    ...t,
    ...e
  };
}
function nc(t, e, n) {
  const r = e.map((s) => {
    const o = syt(n, s.options);
    return t.addEventListener(s.eventName, s.fn, o), function() {
      t.removeEventListener(s.eventName, s.fn, o);
    };
  });
  return function() {
    r.forEach((o) => {
      o();
    });
  };
}
const oyt = process.env.NODE_ENV === "production", yK = "Invariant failed";
class Gw extends Error {
}
Gw.prototype.toString = function() {
  return this.message;
};
function te(t, e) {
  throw oyt ? new Gw(yK) : new Gw(`${yK}: ${e || ""}`);
}
class iyt extends B.Component {
  constructor(...e) {
    super(...e), this.callbacks = null, this.unbind = Tf, this.onWindowError = (n) => {
      const r = this.getCallbacks();
      r.isDragging() && (r.tryAbort(), process.env.NODE_ENV !== "production" && Vn(`
        An error was caught by our window 'error' event listener while a drag was occurring.
        The active drag has been aborted.
      `));
      const s = n.error;
      s instanceof Gw && (n.preventDefault(), process.env.NODE_ENV !== "production" && r$(s.message));
    }, this.getCallbacks = () => {
      if (!this.callbacks)
        throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");
      return this.callbacks;
    }, this.setCallbacks = (n) => {
      this.callbacks = n;
    };
  }
  componentDidMount() {
    this.unbind = nc(window, [{
      eventName: "error",
      fn: this.onWindowError
    }]);
  }
  componentDidCatch(e) {
    if (e instanceof Gw) {
      process.env.NODE_ENV !== "production" && r$(e.message), this.setState({});
      return;
    }
    throw e;
  }
  componentWillUnmount() {
    this.unbind();
  }
  render() {
    return this.props.children(this.setCallbacks);
  }
}
const ayt = `
  Press space bar to start a drag.
  When dragging you can use the arrow keys to move the item around and escape to cancel.
  Some screen readers may require you to be in focus mode or to use your pass through key
`, hP = (t) => t + 1, cyt = (t) => `
  You have lifted an item in position ${hP(t.source.index)}
`, jme = (t, e) => {
  const n = t.droppableId === e.droppableId, r = hP(t.index), s = hP(e.index);
  return n ? `
      You have moved the item from position ${r}
      to position ${s}
    ` : `
    You have moved the item from position ${r}
    in list ${t.droppableId}
    to list ${e.droppableId}
    in position ${s}
  `;
}, Rme = (t, e, n) => e.droppableId === n.droppableId ? `
      The item ${t}
      has been combined with ${n.draggableId}` : `
      The item ${t}
      in list ${e.droppableId}
      has been combined with ${n.draggableId}
      in list ${n.droppableId}
    `, lyt = (t) => {
  const e = t.destination;
  if (e)
    return jme(t.source, e);
  const n = t.combine;
  return n ? Rme(t.draggableId, t.source, n) : "You are over an area that cannot be dropped on";
}, vK = (t) => `
  The item has returned to its starting position
  of ${hP(t.index)}
`, dyt = (t) => {
  if (t.reason === "CANCEL")
    return `
      Movement cancelled.
      ${vK(t.source)}
    `;
  const e = t.destination, n = t.combine;
  return e ? `
      You have dropped the item.
      ${jme(t.source, e)}
    ` : n ? `
      You have dropped the item.
      ${Rme(t.draggableId, t.source, n)}
    ` : `
    The item has been dropped while not over a drop area.
    ${vK(t.source)}
  `;
}, uyt = {
  dragHandleUsageInstructions: ayt,
  onDragStart: cyt,
  onDragUpdate: lyt,
  onDragEnd: dyt
};
var R_ = uyt;
const Ls = {
  x: 0,
  y: 0
}, oo = (t, e) => ({
  x: t.x + e.x,
  y: t.y + e.y
}), fa = (t, e) => ({
  x: t.x - e.x,
  y: t.y - e.y
}), Pf = (t, e) => t.x === e.x && t.y === e.y, xv = (t) => ({
  x: t.x !== 0 ? -t.x : 0,
  y: t.y !== 0 ? -t.y : 0
}), Gp = (t, e, n = 0) => t === "x" ? {
  x: e,
  y: n
} : {
  x: n,
  y: e
}, Yw = (t, e) => Math.sqrt((e.x - t.x) ** 2 + (e.y - t.y) ** 2), bK = (t, e) => Math.min(...e.map((n) => Yw(t, n))), $me = (t) => (e) => ({
  x: t(e.x),
  y: t(e.y)
});
var fyt = (t, e) => {
  const n = Gc({
    top: Math.max(e.top, t.top),
    right: Math.min(e.right, t.right),
    bottom: Math.min(e.bottom, t.bottom),
    left: Math.max(e.left, t.left)
  });
  return n.width <= 0 || n.height <= 0 ? null : n;
};
const TS = (t, e) => ({
  top: t.top + e.y,
  left: t.left + e.x,
  bottom: t.bottom + e.y,
  right: t.right + e.x
}), xK = (t) => [{
  x: t.left,
  y: t.top
}, {
  x: t.right,
  y: t.top
}, {
  x: t.left,
  y: t.bottom
}, {
  x: t.right,
  y: t.bottom
}], hyt = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
}, pyt = (t, e) => e ? TS(t, e.scroll.diff.displacement) : t, gyt = (t, e, n) => n && n.increasedBy ? {
  ...t,
  [e.end]: t[e.end] + n.increasedBy[e.line]
} : t, myt = (t, e) => e && e.shouldClipSubject ? fyt(e.pageMarginBox, t) : Gc(t);
var My = ({
  page: t,
  withPlaceholder: e,
  axis: n,
  frame: r
}) => {
  const s = pyt(t.marginBox, r), o = gyt(s, n, e), i = myt(o, r);
  return {
    page: t,
    withPlaceholder: e,
    active: i
  };
}, J4 = (t, e) => {
  t.frame || (process.env.NODE_ENV, te());
  const n = t.frame, r = fa(e, n.scroll.initial), s = xv(r), o = {
    ...n,
    scroll: {
      initial: n.scroll.initial,
      current: e,
      diff: {
        value: r,
        displacement: s
      },
      max: n.scroll.max
    }
  }, i = My({
    page: t.subject.page,
    withPlaceholder: t.subject.withPlaceholder,
    axis: t.axis,
    frame: o
  });
  return {
    ...t,
    frame: o,
    subject: i
  };
};
const Lme = cs((t) => t.reduce((e, n) => (e[n.descriptor.id] = n, e), {})), Fme = cs((t) => t.reduce((e, n) => (e[n.descriptor.id] = n, e), {})), sA = cs((t) => Object.values(t)), yyt = cs((t) => Object.values(t));
var xg = cs((t, e) => yyt(e).filter((r) => t === r.descriptor.droppableId).sort((r, s) => r.descriptor.index - s.descriptor.index));
function eB(t) {
  return t.at && t.at.type === "REORDER" ? t.at.destination : null;
}
function oA(t) {
  return t.at && t.at.type === "COMBINE" ? t.at.combine : null;
}
var iA = cs((t, e) => e.filter((n) => n.descriptor.id !== t.descriptor.id)), vyt = ({
  isMovingForward: t,
  draggable: e,
  destination: n,
  insideDestination: r,
  previousImpact: s
}) => {
  if (!n.isCombineEnabled || !eB(s))
    return null;
  function i(p) {
    const g = {
      type: "COMBINE",
      combine: {
        draggableId: p,
        droppableId: n.descriptor.id
      }
    };
    return {
      ...s,
      at: g
    };
  }
  const a = s.displaced.all, c = a.length ? a[0] : null;
  if (t)
    return c ? i(c) : null;
  const l = iA(e, r);
  if (!c) {
    if (!l.length)
      return null;
    const p = l[l.length - 1];
    return i(p.descriptor.id);
  }
  const d = l.findIndex((p) => p.descriptor.id === c);
  d === -1 && (process.env.NODE_ENV !== "production" ? te(!1, "Could not find displaced item in set") : te());
  const u = d - 1;
  if (u < 0)
    return null;
  const f = l[u];
  return i(f.descriptor.id);
}, wv = (t, e) => t.descriptor.droppableId === e.descriptor.id;
const Bme = {
  point: Ls,
  value: 0
}, qw = {
  invisible: {},
  visible: {},
  all: []
}, byt = {
  displaced: qw,
  displacedBy: Bme,
  at: null
};
var xyt = byt, lc = (t, e) => (n) => t <= n && n <= e, zme = (t) => {
  const e = lc(t.top, t.bottom), n = lc(t.left, t.right);
  return (r) => {
    if (e(r.top) && e(r.bottom) && n(r.left) && n(r.right))
      return !0;
    const o = e(r.top) || e(r.bottom), i = n(r.left) || n(r.right);
    if (o && i)
      return !0;
    const c = r.top < t.top && r.bottom > t.bottom, l = r.left < t.left && r.right > t.right;
    return c && l ? !0 : c && i || l && o;
  };
}, wyt = (t) => {
  const e = lc(t.top, t.bottom), n = lc(t.left, t.right);
  return (r) => e(r.top) && e(r.bottom) && n(r.left) && n(r.right);
};
const tB = {
  direction: "vertical",
  line: "y",
  crossAxisLine: "x",
  start: "top",
  end: "bottom",
  size: "height",
  crossAxisStart: "left",
  crossAxisEnd: "right",
  crossAxisSize: "width"
}, Ume = {
  direction: "horizontal",
  line: "x",
  crossAxisLine: "y",
  start: "left",
  end: "right",
  size: "width",
  crossAxisStart: "top",
  crossAxisEnd: "bottom",
  crossAxisSize: "height"
};
var Syt = (t) => (e) => {
  const n = lc(e.top, e.bottom), r = lc(e.left, e.right);
  return (s) => t === tB ? n(s.top) && n(s.bottom) : r(s.left) && r(s.right);
};
const Cyt = (t, e) => {
  const n = e.frame ? e.frame.scroll.diff.displacement : Ls;
  return TS(t, n);
}, _yt = (t, e, n) => e.subject.active ? n(e.subject.active)(t) : !1, Eyt = (t, e, n) => n(e)(t), nB = ({
  target: t,
  destination: e,
  viewport: n,
  withDroppableDisplacement: r,
  isVisibleThroughFrameFn: s
}) => {
  const o = r ? Cyt(t, e) : t;
  return _yt(o, e, s) && Eyt(o, n, s);
}, Tyt = (t) => nB({
  ...t,
  isVisibleThroughFrameFn: zme
}), Hme = (t) => nB({
  ...t,
  isVisibleThroughFrameFn: wyt
}), Pyt = (t) => nB({
  ...t,
  isVisibleThroughFrameFn: Syt(t.destination.axis)
}), Iyt = (t, e, n) => {
  if (typeof n == "boolean")
    return n;
  if (!e)
    return !0;
  const {
    invisible: r,
    visible: s
  } = e;
  if (r[t])
    return !1;
  const o = s[t];
  return o ? o.shouldAnimate : !0;
};
function kyt(t, e) {
  const n = t.page.marginBox, r = {
    top: e.point.y,
    right: 0,
    bottom: 0,
    left: e.point.x
  };
  return Gc(Z4(n, r));
}
function Xw({
  afterDragging: t,
  destination: e,
  displacedBy: n,
  viewport: r,
  forceShouldAnimate: s,
  last: o
}) {
  return t.reduce(function(a, c) {
    const l = kyt(c, n), d = c.descriptor.id;
    if (a.all.push(d), !Tyt({
      target: l,
      destination: e,
      viewport: r,
      withDroppableDisplacement: !0
    }))
      return a.invisible[c.descriptor.id] = !0, a;
    const f = Iyt(d, o, s), p = {
      draggableId: d,
      shouldAnimate: f
    };
    return a.visible[d] = p, a;
  }, {
    all: [],
    visible: {},
    invisible: {}
  });
}
function Ayt(t, e) {
  if (!t.length)
    return 0;
  const n = t[t.length - 1].descriptor.index;
  return e.inHomeList ? n : n + 1;
}
function wK({
  insideDestination: t,
  inHomeList: e,
  displacedBy: n,
  destination: r
}) {
  const s = Ayt(t, {
    inHomeList: e
  });
  return {
    displaced: qw,
    displacedBy: n,
    at: {
      type: "REORDER",
      destination: {
        droppableId: r.descriptor.id,
        index: s
      }
    }
  };
}
function pP({
  draggable: t,
  insideDestination: e,
  destination: n,
  viewport: r,
  displacedBy: s,
  last: o,
  index: i,
  forceShouldAnimate: a
}) {
  const c = wv(t, n);
  if (i == null)
    return wK({
      insideDestination: e,
      inHomeList: c,
      displacedBy: s,
      destination: n
    });
  const l = e.find((g) => g.descriptor.index === i);
  if (!l)
    return wK({
      insideDestination: e,
      inHomeList: c,
      displacedBy: s,
      destination: n
    });
  const d = iA(t, e), u = e.indexOf(l), f = d.slice(u);
  return {
    displaced: Xw({
      afterDragging: f,
      destination: n,
      displacedBy: s,
      last: o,
      viewport: r.frame,
      forceShouldAnimate: a
    }),
    displacedBy: s,
    at: {
      type: "REORDER",
      destination: {
        droppableId: n.descriptor.id,
        index: i
      }
    }
  };
}
function zf(t, e) {
  return !!e.effected[t];
}
var Myt = ({
  isMovingForward: t,
  destination: e,
  draggables: n,
  combine: r,
  afterCritical: s
}) => {
  if (!e.isCombineEnabled)
    return null;
  const o = r.draggableId, a = n[o].descriptor.index;
  return zf(o, s) ? t ? a : a - 1 : t ? a + 1 : a;
}, Oyt = ({
  isMovingForward: t,
  isInHomeList: e,
  insideDestination: n,
  location: r
}) => {
  if (!n.length)
    return null;
  const s = r.index, o = t ? s + 1 : s - 1, i = n[0].descriptor.index, a = n[n.length - 1].descriptor.index, c = e ? a : a + 1;
  return o < i || o > c ? null : o;
}, Dyt = ({
  isMovingForward: t,
  isInHomeList: e,
  draggable: n,
  draggables: r,
  destination: s,
  insideDestination: o,
  previousImpact: i,
  viewport: a,
  afterCritical: c
}) => {
  const l = i.at;
  if (l || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot move in direction without previous impact location") : te()), l.type === "REORDER") {
    const u = Oyt({
      isMovingForward: t,
      isInHomeList: e,
      location: l.destination,
      insideDestination: o
    });
    return u == null ? null : pP({
      draggable: n,
      insideDestination: o,
      destination: s,
      viewport: a,
      last: i.displaced,
      displacedBy: i.displacedBy,
      index: u
    });
  }
  const d = Myt({
    isMovingForward: t,
    destination: s,
    displaced: i.displaced,
    draggables: r,
    combine: l.combine,
    afterCritical: c
  });
  return d == null ? null : pP({
    draggable: n,
    insideDestination: o,
    destination: s,
    viewport: a,
    last: i.displaced,
    displacedBy: i.displacedBy,
    index: d
  });
}, Nyt = ({
  displaced: t,
  afterCritical: e,
  combineWith: n,
  displacedBy: r
}) => {
  const s = !!(t.visible[n] || t.invisible[n]);
  return zf(n, e) ? s ? Ls : xv(r.point) : s ? r.point : Ls;
}, jyt = ({
  afterCritical: t,
  impact: e,
  draggables: n
}) => {
  const r = oA(e);
  r || (process.env.NODE_ENV, te());
  const s = r.draggableId, o = n[s].page.borderBox.center, i = Nyt({
    displaced: e.displaced,
    afterCritical: t,
    combineWith: s,
    displacedBy: e.displacedBy
  });
  return oo(o, i);
};
const Vme = (t, e) => e.margin[t.start] + e.borderBox[t.size] / 2, Ryt = (t, e) => e.margin[t.end] + e.borderBox[t.size] / 2, rB = (t, e, n) => e[t.crossAxisStart] + n.margin[t.crossAxisStart] + n.borderBox[t.crossAxisSize] / 2, SK = ({
  axis: t,
  moveRelativeTo: e,
  isMoving: n
}) => Gp(t.line, e.marginBox[t.end] + Vme(t, n), rB(t, e.marginBox, n)), CK = ({
  axis: t,
  moveRelativeTo: e,
  isMoving: n
}) => Gp(t.line, e.marginBox[t.start] - Ryt(t, n), rB(t, e.marginBox, n)), $yt = ({
  axis: t,
  moveInto: e,
  isMoving: n
}) => Gp(t.line, e.contentBox[t.start] + Vme(t, n), rB(t, e.contentBox, n));
var Lyt = ({
  impact: t,
  draggable: e,
  draggables: n,
  droppable: r,
  afterCritical: s
}) => {
  const o = xg(r.descriptor.id, n), i = e.page, a = r.axis;
  if (!o.length)
    return $yt({
      axis: a,
      moveInto: r.page,
      isMoving: i
    });
  const {
    displaced: c,
    displacedBy: l
  } = t, d = c.all[0];
  if (d) {
    const f = n[d];
    if (zf(d, s))
      return CK({
        axis: a,
        moveRelativeTo: f.page,
        isMoving: i
      });
    const p = uP(f.page, l.point);
    return CK({
      axis: a,
      moveRelativeTo: p,
      isMoving: i
    });
  }
  const u = o[o.length - 1];
  if (u.descriptor.id === e.descriptor.id)
    return i.borderBox.center;
  if (zf(u.descriptor.id, s)) {
    const f = uP(u.page, xv(s.displacedBy.point));
    return SK({
      axis: a,
      moveRelativeTo: f,
      isMoving: i
    });
  }
  return SK({
    axis: a,
    moveRelativeTo: u.page,
    isMoving: i
  });
}, s$ = (t, e) => {
  const n = t.frame;
  return n ? oo(e, n.scroll.diff.displacement) : e;
};
const Fyt = ({
  impact: t,
  draggable: e,
  droppable: n,
  draggables: r,
  afterCritical: s
}) => {
  const o = e.page.borderBox.center, i = t.at;
  return !n || !i ? o : i.type === "REORDER" ? Lyt({
    impact: t,
    draggable: e,
    draggables: r,
    droppable: n,
    afterCritical: s
  }) : jyt({
    impact: t,
    draggables: r,
    afterCritical: s
  });
};
var aA = (t) => {
  const e = Fyt(t), n = t.droppable;
  return n ? s$(n, e) : e;
}, Wme = (t, e) => {
  const n = fa(e, t.scroll.initial), r = xv(n);
  return {
    frame: Gc({
      top: e.y,
      bottom: e.y + t.frame.height,
      left: e.x,
      right: e.x + t.frame.width
    }),
    scroll: {
      initial: t.scroll.initial,
      max: t.scroll.max,
      current: e,
      diff: {
        value: n,
        displacement: r
      }
    }
  };
};
function _K(t, e) {
  return t.map((n) => e[n]);
}
function Byt(t, e) {
  for (let n = 0; n < e.length; n++) {
    const r = e[n].visible[t];
    if (r)
      return r;
  }
  return null;
}
var zyt = ({
  impact: t,
  viewport: e,
  destination: n,
  draggables: r,
  maxScrollChange: s
}) => {
  const o = Wme(e, oo(e.scroll.current, s)), i = n.frame ? J4(n, oo(n.frame.scroll.current, s)) : n, a = t.displaced, c = Xw({
    afterDragging: _K(a.all, r),
    destination: n,
    displacedBy: t.displacedBy,
    viewport: o.frame,
    last: a,
    forceShouldAnimate: !1
  }), l = Xw({
    afterDragging: _K(a.all, r),
    destination: i,
    displacedBy: t.displacedBy,
    viewport: e.frame,
    last: a,
    forceShouldAnimate: !1
  }), d = {}, u = {}, f = [a, c, l];
  return a.all.forEach((g) => {
    const y = Byt(g, f);
    if (y) {
      u[g] = y;
      return;
    }
    d[g] = !0;
  }), {
    ...t,
    displaced: {
      all: a.all,
      invisible: d,
      visible: u
    }
  };
}, Uyt = (t, e) => oo(t.scroll.diff.displacement, e), sB = ({
  pageBorderBoxCenter: t,
  draggable: e,
  viewport: n
}) => {
  const r = Uyt(n, t), s = fa(r, e.page.borderBox.center);
  return oo(e.client.borderBox.center, s);
}, Kme = ({
  draggable: t,
  destination: e,
  newPageBorderBoxCenter: n,
  viewport: r,
  withDroppableDisplacement: s,
  onlyOnMainAxis: o = !1
}) => {
  const i = fa(n, t.page.borderBox.center), c = {
    target: TS(t.page.borderBox, i),
    destination: e,
    withDroppableDisplacement: s,
    viewport: r
  };
  return o ? Pyt(c) : Hme(c);
}, Hyt = ({
  isMovingForward: t,
  draggable: e,
  destination: n,
  draggables: r,
  previousImpact: s,
  viewport: o,
  previousPageBorderBoxCenter: i,
  previousClientSelection: a,
  afterCritical: c
}) => {
  if (!n.isEnabled)
    return null;
  const l = xg(n.descriptor.id, r), d = wv(e, n), u = vyt({
    isMovingForward: t,
    draggable: e,
    destination: n,
    insideDestination: l,
    previousImpact: s
  }) || Dyt({
    isMovingForward: t,
    isInHomeList: d,
    draggable: e,
    draggables: r,
    destination: n,
    insideDestination: l,
    previousImpact: s,
    viewport: o,
    afterCritical: c
  });
  if (!u)
    return null;
  const f = aA({
    impact: u,
    draggable: e,
    droppable: n,
    draggables: r,
    afterCritical: c
  });
  if (Kme({
    draggable: e,
    destination: n,
    newPageBorderBoxCenter: f,
    viewport: o.frame,
    withDroppableDisplacement: !1,
    onlyOnMainAxis: !0
  }))
    return {
      clientSelection: sB({
        pageBorderBoxCenter: f,
        draggable: e,
        viewport: o
      }),
      impact: u,
      scrollJumpRequest: null
    };
  const g = fa(f, i), y = zyt({
    impact: u,
    viewport: o,
    destination: n,
    draggables: r,
    maxScrollChange: g
  });
  return {
    clientSelection: a,
    impact: y,
    scrollJumpRequest: g
  };
};
const qo = (t) => {
  const e = t.subject.active;
  return e || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot get clipped area from droppable") : te()), e;
};
var Vyt = ({
  isMovingForward: t,
  pageBorderBoxCenter: e,
  source: n,
  droppables: r,
  viewport: s
}) => {
  const o = n.subject.active;
  if (!o)
    return null;
  const i = n.axis, a = lc(o[i.start], o[i.end]), c = sA(r).filter((d) => d !== n).filter((d) => d.isEnabled).filter((d) => !!d.subject.active).filter((d) => zme(s.frame)(qo(d))).filter((d) => {
    const u = qo(d);
    return t ? o[i.crossAxisEnd] < u[i.crossAxisEnd] : u[i.crossAxisStart] < o[i.crossAxisStart];
  }).filter((d) => {
    const u = qo(d), f = lc(u[i.start], u[i.end]);
    return a(u[i.start]) || a(u[i.end]) || f(o[i.start]) || f(o[i.end]);
  }).sort((d, u) => {
    const f = qo(d)[i.crossAxisStart], p = qo(u)[i.crossAxisStart];
    return t ? f - p : p - f;
  }).filter((d, u, f) => qo(d)[i.crossAxisStart] === qo(f[0])[i.crossAxisStart]);
  if (!c.length)
    return null;
  if (c.length === 1)
    return c[0];
  const l = c.filter((d) => lc(qo(d)[i.start], qo(d)[i.end])(e[i.line]));
  return l.length === 1 ? l[0] : l.length > 1 ? l.sort((d, u) => qo(d)[i.start] - qo(u)[i.start])[0] : c.sort((d, u) => {
    const f = bK(e, xK(qo(d))), p = bK(e, xK(qo(u)));
    return f !== p ? f - p : qo(d)[i.start] - qo(u)[i.start];
  })[0];
};
const EK = (t, e) => {
  const n = t.page.borderBox.center;
  return zf(t.descriptor.id, e) ? fa(n, e.displacedBy.point) : n;
}, Wyt = (t, e) => {
  const n = t.page.borderBox;
  return zf(t.descriptor.id, e) ? TS(n, xv(e.displacedBy.point)) : n;
};
var Kyt = ({
  pageBorderBoxCenter: t,
  viewport: e,
  destination: n,
  insideDestination: r,
  afterCritical: s
}) => r.filter((i) => Hme({
  target: Wyt(i, s),
  destination: n,
  viewport: e.frame,
  withDroppableDisplacement: !0
})).sort((i, a) => {
  const c = Yw(t, s$(n, EK(i, s))), l = Yw(t, s$(n, EK(a, s)));
  return c < l ? -1 : l < c ? 1 : i.descriptor.index - a.descriptor.index;
})[0] || null, PS = cs(function(e, n) {
  const r = n[e.line];
  return {
    value: r,
    point: Gp(e.line, r)
  };
});
const Gyt = (t, e, n) => {
  const r = t.axis;
  if (t.descriptor.mode === "virtual")
    return Gp(r.line, e[r.line]);
  const s = t.subject.page.contentBox[r.size], c = xg(t.descriptor.id, n).reduce((l, d) => l + d.client.marginBox[r.size], 0) + e[r.line] - s;
  return c <= 0 ? null : Gp(r.line, c);
}, Gme = (t, e) => ({
  ...t,
  scroll: {
    ...t.scroll,
    max: e
  }
}), Yme = (t, e, n) => {
  const r = t.frame;
  wv(e, t) && (process.env.NODE_ENV !== "production" ? te(!1, "Should not add placeholder space to home list") : te()), t.subject.withPlaceholder && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot add placeholder size to a subject when it already has one") : te());
  const s = PS(t.axis, e.displaceBy).point, o = Gyt(t, s, n), i = {
    placeholderSize: s,
    increasedBy: o,
    oldFrameMaxScroll: t.frame ? t.frame.scroll.max : null
  };
  if (!r) {
    const d = My({
      page: t.subject.page,
      withPlaceholder: i,
      axis: t.axis,
      frame: t.frame
    });
    return {
      ...t,
      subject: d
    };
  }
  const a = o ? oo(r.scroll.max, o) : r.scroll.max, c = Gme(r, a), l = My({
    page: t.subject.page,
    withPlaceholder: i,
    axis: t.axis,
    frame: c
  });
  return {
    ...t,
    subject: l,
    frame: c
  };
}, Yyt = (t) => {
  const e = t.subject.withPlaceholder;
  e || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot remove placeholder form subject when there was none") : te());
  const n = t.frame;
  if (!n) {
    const i = My({
      page: t.subject.page,
      axis: t.axis,
      frame: null,
      withPlaceholder: null
    });
    return {
      ...t,
      subject: i
    };
  }
  const r = e.oldFrameMaxScroll;
  r || (process.env.NODE_ENV !== "production" ? te(!1, "Expected droppable with frame to have old max frame scroll when removing placeholder") : te());
  const s = Gme(n, r), o = My({
    page: t.subject.page,
    axis: t.axis,
    frame: s,
    withPlaceholder: null
  });
  return {
    ...t,
    subject: o,
    frame: s
  };
};
var qyt = ({
  previousPageBorderBoxCenter: t,
  moveRelativeTo: e,
  insideDestination: n,
  draggable: r,
  draggables: s,
  destination: o,
  viewport: i,
  afterCritical: a
}) => {
  if (!e) {
    if (n.length)
      return null;
    const u = {
      displaced: qw,
      displacedBy: Bme,
      at: {
        type: "REORDER",
        destination: {
          droppableId: o.descriptor.id,
          index: 0
        }
      }
    }, f = aA({
      impact: u,
      draggable: r,
      droppable: o,
      draggables: s,
      afterCritical: a
    }), p = wv(r, o) ? o : Yme(o, r, s);
    return Kme({
      draggable: r,
      destination: p,
      newPageBorderBoxCenter: f,
      viewport: i.frame,
      withDroppableDisplacement: !1,
      onlyOnMainAxis: !0
    }) ? u : null;
  }
  const c = t[o.axis.line] <= e.page.borderBox.center[o.axis.line], l = (() => {
    const u = e.descriptor.index;
    return e.descriptor.id === r.descriptor.id || c ? u : u + 1;
  })(), d = PS(o.axis, r.displaceBy);
  return pP({
    draggable: r,
    insideDestination: n,
    destination: o,
    viewport: i,
    displacedBy: d,
    last: qw,
    index: l
  });
}, Xyt = ({
  isMovingForward: t,
  previousPageBorderBoxCenter: e,
  draggable: n,
  isOver: r,
  draggables: s,
  droppables: o,
  viewport: i,
  afterCritical: a
}) => {
  const c = Vyt({
    isMovingForward: t,
    pageBorderBoxCenter: e,
    source: r,
    droppables: o,
    viewport: i
  });
  if (!c)
    return null;
  const l = xg(c.descriptor.id, s), d = Kyt({
    pageBorderBoxCenter: e,
    viewport: i,
    destination: c,
    insideDestination: l,
    afterCritical: a
  }), u = qyt({
    previousPageBorderBoxCenter: e,
    destination: c,
    draggable: n,
    draggables: s,
    moveRelativeTo: d,
    insideDestination: l,
    viewport: i,
    afterCritical: a
  });
  if (!u)
    return null;
  const f = aA({
    impact: u,
    draggable: n,
    droppable: c,
    draggables: s,
    afterCritical: a
  });
  return {
    clientSelection: sB({
      pageBorderBoxCenter: f,
      draggable: n,
      viewport: i
    }),
    impact: u,
    scrollJumpRequest: null
  };
}, xa = (t) => {
  const e = t.at;
  return e ? e.type === "REORDER" ? e.destination.droppableId : e.combine.droppableId : null;
};
const Zyt = (t, e) => {
  const n = xa(t);
  return n ? e[n] : null;
};
var Qyt = ({
  state: t,
  type: e
}) => {
  const n = Zyt(t.impact, t.dimensions.droppables), r = !!n, s = t.dimensions.droppables[t.critical.droppable.id], o = n || s, i = o.axis.direction, a = i === "vertical" && (e === "MOVE_UP" || e === "MOVE_DOWN") || i === "horizontal" && (e === "MOVE_LEFT" || e === "MOVE_RIGHT");
  if (a && !r)
    return null;
  const c = e === "MOVE_DOWN" || e === "MOVE_RIGHT", l = t.dimensions.draggables[t.critical.draggable.id], d = t.current.page.borderBoxCenter, {
    draggables: u,
    droppables: f
  } = t.dimensions;
  return a ? Hyt({
    isMovingForward: c,
    previousPageBorderBoxCenter: d,
    draggable: l,
    destination: o,
    draggables: u,
    viewport: t.viewport,
    previousClientSelection: t.current.client.selection,
    previousImpact: t.impact,
    afterCritical: t.afterCritical
  }) : Xyt({
    isMovingForward: c,
    previousPageBorderBoxCenter: d,
    draggable: l,
    isOver: o,
    draggables: u,
    droppables: f,
    viewport: t.viewport,
    afterCritical: t.afterCritical
  });
};
function Ah(t) {
  return t.phase === "DRAGGING" || t.phase === "COLLECTING";
}
function qme(t) {
  const e = lc(t.top, t.bottom), n = lc(t.left, t.right);
  return function(s) {
    return e(s.y) && n(s.x);
  };
}
function Jyt(t, e) {
  return t.left < e.right && t.right > e.left && t.top < e.bottom && t.bottom > e.top;
}
function evt({
  pageBorderBox: t,
  draggable: e,
  candidates: n
}) {
  const r = e.page.borderBox.center, s = n.map((o) => {
    const i = o.axis, a = Gp(o.axis.line, t.center[i.line], o.page.borderBox.center[i.crossAxisLine]);
    return {
      id: o.descriptor.id,
      distance: Yw(r, a)
    };
  }).sort((o, i) => i.distance - o.distance);
  return s[0] ? s[0].id : null;
}
function tvt({
  pageBorderBox: t,
  draggable: e,
  droppables: n
}) {
  const r = sA(n).filter((s) => {
    if (!s.isEnabled)
      return !1;
    const o = s.subject.active;
    if (!o || !Jyt(t, o))
      return !1;
    if (qme(o)(t.center))
      return !0;
    const i = s.axis, a = o.center[i.crossAxisLine], c = t[i.crossAxisStart], l = t[i.crossAxisEnd], d = lc(o[i.crossAxisStart], o[i.crossAxisEnd]), u = d(c), f = d(l);
    return !u && !f ? !0 : u ? c < a : l > a;
  });
  return r.length ? r.length === 1 ? r[0].descriptor.id : evt({
    pageBorderBox: t,
    draggable: e,
    candidates: r
  }) : null;
}
const Xme = (t, e) => Gc(TS(t, e));
var nvt = (t, e) => {
  const n = t.frame;
  return n ? Xme(e, n.scroll.diff.value) : e;
};
function Zme({
  displaced: t,
  id: e
}) {
  return !!(t.visible[e] || t.invisible[e]);
}
function rvt({
  draggable: t,
  closest: e,
  inHomeList: n
}) {
  return e ? n && e.descriptor.index > t.descriptor.index ? e.descriptor.index - 1 : e.descriptor.index : null;
}
var svt = ({
  pageBorderBoxWithDroppableScroll: t,
  draggable: e,
  destination: n,
  insideDestination: r,
  last: s,
  viewport: o,
  afterCritical: i
}) => {
  const a = n.axis, c = PS(n.axis, e.displaceBy), l = c.value, d = t[a.start], u = t[a.end], p = iA(e, r).find((y) => {
    const m = y.descriptor.id, v = y.page.borderBox.center[a.line], b = zf(m, i), x = Zme({
      displaced: s,
      id: m
    });
    return b ? x ? u <= v : d < v - l : x ? u <= v + l : d < v;
  }) || null, g = rvt({
    draggable: e,
    closest: p,
    inHomeList: wv(e, n)
  });
  return pP({
    draggable: e,
    insideDestination: r,
    destination: n,
    viewport: o,
    last: s,
    displacedBy: c,
    index: g
  });
};
const ovt = 4;
var ivt = ({
  draggable: t,
  pageBorderBoxWithDroppableScroll: e,
  previousImpact: n,
  destination: r,
  insideDestination: s,
  afterCritical: o
}) => {
  if (!r.isCombineEnabled)
    return null;
  const i = r.axis, a = PS(r.axis, t.displaceBy), c = a.value, l = e[i.start], d = e[i.end], f = iA(t, s).find((g) => {
    const y = g.descriptor.id, m = g.page.borderBox, b = m[i.size] / ovt, x = zf(y, o), w = Zme({
      displaced: n.displaced,
      id: y
    });
    return x ? w ? d > m[i.start] + b && d < m[i.end] - b : l > m[i.start] - c + b && l < m[i.end] - c - b : w ? d > m[i.start] + c + b && d < m[i.end] + c - b : l > m[i.start] + b && l < m[i.end] - b;
  });
  return f ? {
    displacedBy: a,
    displaced: n.displaced,
    at: {
      type: "COMBINE",
      combine: {
        draggableId: f.descriptor.id,
        droppableId: r.descriptor.id
      }
    }
  } : null;
}, Qme = ({
  pageOffset: t,
  draggable: e,
  draggables: n,
  droppables: r,
  previousImpact: s,
  viewport: o,
  afterCritical: i
}) => {
  const a = Xme(e.page.borderBox, t), c = tvt({
    pageBorderBox: a,
    draggable: e,
    droppables: r
  });
  if (!c)
    return xyt;
  const l = r[c], d = xg(l.descriptor.id, n), u = nvt(l, a);
  return ivt({
    pageBorderBoxWithDroppableScroll: u,
    draggable: e,
    previousImpact: s,
    destination: l,
    insideDestination: d,
    afterCritical: i
  }) || svt({
    pageBorderBoxWithDroppableScroll: u,
    draggable: e,
    destination: l,
    insideDestination: d,
    last: s.displaced,
    viewport: o,
    afterCritical: i
  });
}, oB = (t, e) => ({
  ...t,
  [e.descriptor.id]: e
});
const avt = ({
  previousImpact: t,
  impact: e,
  droppables: n
}) => {
  const r = xa(t), s = xa(e);
  if (!r || r === s)
    return n;
  const o = n[r];
  if (!o.subject.withPlaceholder)
    return n;
  const i = Yyt(o);
  return oB(n, i);
};
var cvt = ({
  draggable: t,
  draggables: e,
  droppables: n,
  previousImpact: r,
  impact: s
}) => {
  const o = avt({
    previousImpact: r,
    impact: s,
    droppables: n
  }), i = xa(s);
  if (!i)
    return o;
  const a = n[i];
  if (wv(t, a) || a.subject.withPlaceholder)
    return o;
  const c = Yme(a, t, e);
  return oB(o, c);
}, Lx = ({
  state: t,
  clientSelection: e,
  dimensions: n,
  viewport: r,
  impact: s,
  scrollJumpRequest: o
}) => {
  const i = r || t.viewport, a = n || t.dimensions, c = e || t.current.client.selection, l = fa(c, t.initial.client.selection), d = {
    offset: l,
    selection: c,
    borderBoxCenter: oo(t.initial.client.borderBoxCenter, l)
  }, u = {
    selection: oo(d.selection, i.scroll.current),
    borderBoxCenter: oo(d.borderBoxCenter, i.scroll.current),
    offset: oo(d.offset, i.scroll.diff.value)
  }, f = {
    client: d,
    page: u
  };
  if (t.phase === "COLLECTING")
    return {
      ...t,
      dimensions: a,
      viewport: i,
      current: f
    };
  const p = a.draggables[t.critical.draggable.id], g = s || Qme({
    pageOffset: u.offset,
    draggable: p,
    draggables: a.draggables,
    droppables: a.droppables,
    previousImpact: t.impact,
    viewport: i,
    afterCritical: t.afterCritical
  }), y = cvt({
    draggable: p,
    impact: g,
    previousImpact: t.impact,
    draggables: a.draggables,
    droppables: a.droppables
  });
  return {
    ...t,
    current: f,
    dimensions: {
      draggables: a.draggables,
      droppables: y
    },
    impact: g,
    viewport: i,
    scrollJumpRequest: o || null,
    forceShouldAnimate: o ? !1 : null
  };
};
function lvt(t, e) {
  return t.map((n) => e[n]);
}
var Jme = ({
  impact: t,
  viewport: e,
  draggables: n,
  destination: r,
  forceShouldAnimate: s
}) => {
  const o = t.displaced, i = lvt(o.all, n), a = Xw({
    afterDragging: i,
    destination: r,
    displacedBy: t.displacedBy,
    viewport: e.frame,
    forceShouldAnimate: s,
    last: o
  });
  return {
    ...t,
    displaced: a
  };
}, eye = ({
  impact: t,
  draggable: e,
  droppable: n,
  draggables: r,
  viewport: s,
  afterCritical: o
}) => {
  const i = aA({
    impact: t,
    draggable: e,
    draggables: r,
    droppable: n,
    afterCritical: o
  });
  return sB({
    pageBorderBoxCenter: i,
    draggable: e,
    viewport: s
  });
}, tye = ({
  state: t,
  dimensions: e,
  viewport: n
}) => {
  t.movementMode !== "SNAP" && (process.env.NODE_ENV, te());
  const r = t.impact, s = n || t.viewport, o = e || t.dimensions, {
    draggables: i,
    droppables: a
  } = o, c = i[t.critical.draggable.id], l = xa(r);
  l || (process.env.NODE_ENV !== "production" ? te(!1, "Must be over a destination in SNAP movement mode") : te());
  const d = a[l], u = Jme({
    impact: r,
    viewport: s,
    destination: d,
    draggables: i
  }), f = eye({
    impact: u,
    draggable: c,
    droppable: d,
    draggables: i,
    viewport: s,
    afterCritical: t.afterCritical
  });
  return Lx({
    impact: u,
    clientSelection: f,
    state: t,
    dimensions: o,
    viewport: s
  });
}, dvt = (t) => ({
  index: t.index,
  droppableId: t.droppableId
}), nye = ({
  draggable: t,
  home: e,
  draggables: n,
  viewport: r
}) => {
  const s = PS(e.axis, t.displaceBy), o = xg(e.descriptor.id, n), i = o.indexOf(t);
  i === -1 && (process.env.NODE_ENV !== "production" ? te(!1, "Expected draggable to be inside home list") : te());
  const a = o.slice(i + 1), c = a.reduce((f, p) => (f[p.descriptor.id] = !0, f), {}), l = {
    inVirtualList: e.descriptor.mode === "virtual",
    displacedBy: s,
    effected: c
  };
  return {
    impact: {
      displaced: Xw({
        afterDragging: a,
        destination: e,
        displacedBy: s,
        last: null,
        viewport: r.frame,
        forceShouldAnimate: !1
      }),
      displacedBy: s,
      at: {
        type: "REORDER",
        destination: dvt(t.descriptor)
      }
    },
    afterCritical: l
  };
}, uvt = (t, e) => ({
  draggables: t.draggables,
  droppables: oB(t.droppables, e)
});
const IS = (t) => {
  process.env.NODE_ENV;
}, kS = (t) => {
  process.env.NODE_ENV;
};
var fvt = ({
  draggable: t,
  offset: e,
  initialWindowScroll: n
}) => {
  const r = uP(t.client, e), s = fP(r, n);
  return {
    ...t,
    placeholder: {
      ...t.placeholder,
      client: r
    },
    client: r,
    page: s
  };
}, hvt = (t) => {
  const e = t.frame;
  return e || (process.env.NODE_ENV !== "production" ? te(!1, "Expected Droppable to have a frame") : te()), e;
}, pvt = ({
  additions: t,
  updatedDroppables: e,
  viewport: n
}) => {
  const r = n.scroll.diff.value;
  return t.map((s) => {
    const o = s.descriptor.droppableId, i = e[o], c = hvt(i).scroll.diff.value, l = oo(r, c);
    return fvt({
      draggable: s,
      offset: l,
      initialWindowScroll: n.scroll.initial
    });
  });
}, gvt = ({
  state: t,
  published: e
}) => {
  IS();
  const n = e.modified.map((v) => {
    const b = t.dimensions.droppables[v.droppableId];
    return J4(b, v.scroll);
  }), r = {
    ...t.dimensions.droppables,
    ...Lme(n)
  }, s = Fme(pvt({
    additions: e.additions,
    updatedDroppables: r,
    viewport: t.viewport
  })), o = {
    ...t.dimensions.draggables,
    ...s
  };
  e.removals.forEach((v) => {
    delete o[v];
  });
  const i = {
    droppables: r,
    draggables: o
  }, a = xa(t.impact), c = a ? i.droppables[a] : null, l = i.draggables[t.critical.draggable.id], d = i.droppables[t.critical.droppable.id], {
    impact: u,
    afterCritical: f
  } = nye({
    draggable: l,
    home: d,
    draggables: o,
    viewport: t.viewport
  }), p = c && c.isCombineEnabled ? t.impact : u, g = Qme({
    pageOffset: t.current.page.offset,
    draggable: i.draggables[t.critical.draggable.id],
    draggables: i.draggables,
    droppables: i.droppables,
    previousImpact: p,
    viewport: t.viewport,
    afterCritical: f
  });
  kS();
  const y = {
    ...t,
    phase: "DRAGGING",
    impact: g,
    onLiftImpact: u,
    dimensions: i,
    afterCritical: f,
    forceShouldAnimate: !1
  };
  return t.phase === "COLLECTING" ? y : {
    ...y,
    phase: "DROP_PENDING",
    reason: t.reason,
    isWaiting: !1
  };
};
const o$ = (t) => t.movementMode === "SNAP", S2 = (t, e, n) => {
  const r = uvt(t.dimensions, e);
  return !o$(t) || n ? Lx({
    state: t,
    dimensions: r
  }) : tye({
    state: t,
    dimensions: r
  });
};
function C2(t) {
  return t.isDragging && t.movementMode === "SNAP" ? {
    ...t,
    scrollJumpRequest: null
  } : t;
}
const TK = {
  phase: "IDLE",
  completed: null,
  shouldFlush: !1
};
var mvt = (t = TK, e) => {
  if (e.type === "FLUSH")
    return {
      ...TK,
      shouldFlush: !0
    };
  if (e.type === "INITIAL_PUBLISH") {
    t.phase !== "IDLE" && (process.env.NODE_ENV !== "production" ? te(!1, "INITIAL_PUBLISH must come after a IDLE phase") : te());
    const {
      critical: n,
      clientSelection: r,
      viewport: s,
      dimensions: o,
      movementMode: i
    } = e.payload, a = o.draggables[n.draggable.id], c = o.droppables[n.droppable.id], l = {
      selection: r,
      borderBoxCenter: a.client.borderBox.center,
      offset: Ls
    }, d = {
      client: l,
      page: {
        selection: oo(l.selection, s.scroll.initial),
        borderBoxCenter: oo(l.selection, s.scroll.initial),
        offset: oo(l.selection, s.scroll.diff.value)
      }
    }, u = sA(o.droppables).every((y) => !y.isFixedOnPage), {
      impact: f,
      afterCritical: p
    } = nye({
      draggable: a,
      home: c,
      draggables: o.draggables,
      viewport: s
    });
    return {
      phase: "DRAGGING",
      isDragging: !0,
      critical: n,
      movementMode: i,
      dimensions: o,
      initial: d,
      current: d,
      isWindowScrollAllowed: u,
      impact: f,
      afterCritical: p,
      onLiftImpact: f,
      viewport: s,
      scrollJumpRequest: null,
      forceShouldAnimate: null
    };
  }
  if (e.type === "COLLECTION_STARTING")
    return t.phase === "COLLECTING" || t.phase === "DROP_PENDING" ? t : (t.phase !== "DRAGGING" && (process.env.NODE_ENV !== "production" ? te(!1, `Collection cannot start from phase ${t.phase}`) : te()), {
      ...t,
      phase: "COLLECTING"
    });
  if (e.type === "PUBLISH_WHILE_DRAGGING")
    return t.phase === "COLLECTING" || t.phase === "DROP_PENDING" || (process.env.NODE_ENV !== "production" ? te(!1, `Unexpected ${e.type} received in phase ${t.phase}`) : te()), gvt({
      state: t,
      published: e.payload
    });
  if (e.type === "MOVE") {
    if (t.phase === "DROP_PENDING")
      return t;
    Ah(t) || (process.env.NODE_ENV !== "production" ? te(!1, `${e.type} not permitted in phase ${t.phase}`) : te());
    const {
      client: n
    } = e.payload;
    return Pf(n, t.current.client.selection) ? t : Lx({
      state: t,
      clientSelection: n,
      impact: o$(t) ? t.impact : null
    });
  }
  if (e.type === "UPDATE_DROPPABLE_SCROLL") {
    if (t.phase === "DROP_PENDING" || t.phase === "COLLECTING")
      return C2(t);
    Ah(t) || (process.env.NODE_ENV !== "production" ? te(!1, `${e.type} not permitted in phase ${t.phase}`) : te());
    const {
      id: n,
      newScroll: r
    } = e.payload, s = t.dimensions.droppables[n];
    if (!s)
      return t;
    const o = J4(s, r);
    return S2(t, o, !1);
  }
  if (e.type === "UPDATE_DROPPABLE_IS_ENABLED") {
    if (t.phase === "DROP_PENDING")
      return t;
    Ah(t) || (process.env.NODE_ENV !== "production" ? te(!1, `Attempting to move in an unsupported phase ${t.phase}`) : te());
    const {
      id: n,
      isEnabled: r
    } = e.payload, s = t.dimensions.droppables[n];
    s || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot find Droppable[id: ${n}] to toggle its enabled state`) : te()), s.isEnabled === r && (process.env.NODE_ENV !== "production" ? te(!1, `Trying to set droppable isEnabled to ${String(r)}
      but it is already ${String(s.isEnabled)}`) : te());
    const o = {
      ...s,
      isEnabled: r
    };
    return S2(t, o, !0);
  }
  if (e.type === "UPDATE_DROPPABLE_IS_COMBINE_ENABLED") {
    if (t.phase === "DROP_PENDING")
      return t;
    Ah(t) || (process.env.NODE_ENV !== "production" ? te(!1, `Attempting to move in an unsupported phase ${t.phase}`) : te());
    const {
      id: n,
      isCombineEnabled: r
    } = e.payload, s = t.dimensions.droppables[n];
    s || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot find Droppable[id: ${n}] to toggle its isCombineEnabled state`) : te()), s.isCombineEnabled === r && (process.env.NODE_ENV !== "production" ? te(!1, `Trying to set droppable isCombineEnabled to ${String(r)}
      but it is already ${String(s.isCombineEnabled)}`) : te());
    const o = {
      ...s,
      isCombineEnabled: r
    };
    return S2(t, o, !0);
  }
  if (e.type === "MOVE_BY_WINDOW_SCROLL") {
    if (t.phase === "DROP_PENDING" || t.phase === "DROP_ANIMATING")
      return t;
    Ah(t) || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot move by window in phase ${t.phase}`) : te()), t.isWindowScrollAllowed || (process.env.NODE_ENV !== "production" ? te(!1, "Window scrolling is currently not supported for fixed lists") : te());
    const n = e.payload.newScroll;
    if (Pf(t.viewport.scroll.current, n))
      return C2(t);
    const r = Wme(t.viewport, n);
    return o$(t) ? tye({
      state: t,
      viewport: r
    }) : Lx({
      state: t,
      viewport: r
    });
  }
  if (e.type === "UPDATE_VIEWPORT_MAX_SCROLL") {
    if (!Ah(t))
      return t;
    const n = e.payload.maxScroll;
    if (Pf(n, t.viewport.scroll.max))
      return t;
    const r = {
      ...t.viewport,
      scroll: {
        ...t.viewport.scroll,
        max: n
      }
    };
    return {
      ...t,
      viewport: r
    };
  }
  if (e.type === "MOVE_UP" || e.type === "MOVE_DOWN" || e.type === "MOVE_LEFT" || e.type === "MOVE_RIGHT") {
    if (t.phase === "COLLECTING" || t.phase === "DROP_PENDING")
      return t;
    t.phase !== "DRAGGING" && (process.env.NODE_ENV !== "production" ? te(!1, `${e.type} received while not in DRAGGING phase`) : te());
    const n = Qyt({
      state: t,
      type: e.type
    });
    return n ? Lx({
      state: t,
      impact: n.impact,
      clientSelection: n.clientSelection,
      scrollJumpRequest: n.scrollJumpRequest
    }) : t;
  }
  if (e.type === "DROP_PENDING") {
    const n = e.payload.reason;
    return t.phase !== "COLLECTING" && (process.env.NODE_ENV !== "production" ? te(!1, "Can only move into the DROP_PENDING phase from the COLLECTING phase") : te()), {
      ...t,
      phase: "DROP_PENDING",
      isWaiting: !0,
      reason: n
    };
  }
  if (e.type === "DROP_ANIMATE") {
    const {
      completed: n,
      dropDuration: r,
      newHomeClientOffset: s
    } = e.payload;
    return t.phase === "DRAGGING" || t.phase === "DROP_PENDING" || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot animate drop from phase ${t.phase}`) : te()), {
      phase: "DROP_ANIMATING",
      completed: n,
      dropDuration: r,
      newHomeClientOffset: s,
      dimensions: t.dimensions
    };
  }
  if (e.type === "DROP_COMPLETE") {
    const {
      completed: n
    } = e.payload;
    return {
      phase: "IDLE",
      completed: n,
      shouldFlush: !1
    };
  }
  return t;
};
const yvt = (t) => ({
  type: "BEFORE_INITIAL_CAPTURE",
  payload: t
}), vvt = (t) => ({
  type: "LIFT",
  payload: t
}), bvt = (t) => ({
  type: "INITIAL_PUBLISH",
  payload: t
}), xvt = (t) => ({
  type: "PUBLISH_WHILE_DRAGGING",
  payload: t
}), wvt = () => ({
  type: "COLLECTION_STARTING",
  payload: null
}), Svt = (t) => ({
  type: "UPDATE_DROPPABLE_SCROLL",
  payload: t
}), Cvt = (t) => ({
  type: "UPDATE_DROPPABLE_IS_ENABLED",
  payload: t
}), _vt = (t) => ({
  type: "UPDATE_DROPPABLE_IS_COMBINE_ENABLED",
  payload: t
}), rye = (t) => ({
  type: "MOVE",
  payload: t
}), Evt = (t) => ({
  type: "MOVE_BY_WINDOW_SCROLL",
  payload: t
}), Tvt = (t) => ({
  type: "UPDATE_VIEWPORT_MAX_SCROLL",
  payload: t
}), Pvt = () => ({
  type: "MOVE_UP",
  payload: null
}), Ivt = () => ({
  type: "MOVE_DOWN",
  payload: null
}), kvt = () => ({
  type: "MOVE_RIGHT",
  payload: null
}), Avt = () => ({
  type: "MOVE_LEFT",
  payload: null
}), iB = () => ({
  type: "FLUSH",
  payload: null
}), Mvt = (t) => ({
  type: "DROP_ANIMATE",
  payload: t
}), aB = (t) => ({
  type: "DROP_COMPLETE",
  payload: t
}), sye = (t) => ({
  type: "DROP",
  payload: t
}), Ovt = (t) => ({
  type: "DROP_PENDING",
  payload: t
}), oye = () => ({
  type: "DROP_ANIMATION_FINISHED",
  payload: null
});
function Dvt(t) {
  if (t.length <= 1)
    return;
  const e = t.map((s) => s.descriptor.index), n = {};
  for (let s = 1; s < e.length; s++) {
    const o = e[s], i = e[s - 1];
    o !== i + 1 && (n[o] = !0);
  }
  if (!Object.keys(n).length)
    return;
  const r = e.map((s) => !!n[s] ? `[${s}]` : `${s}`).join(", ");
  process.env.NODE_ENV !== "production" && Vn(`
    Detected non-consecutive <Draggable /> indexes.

    (This can cause unexpected bugs)

    ${r}
  `);
}
function Nvt(t, e) {
  if (process.env.NODE_ENV !== "production") {
    const n = xg(t.droppable.id, e.draggables);
    Dvt(n);
  }
}
var jvt = (t) => ({
  getState: e,
  dispatch: n
}) => (r) => (s) => {
  if (s.type !== "LIFT") {
    r(s);
    return;
  }
  const {
    id: o,
    clientSelection: i,
    movementMode: a
  } = s.payload, c = e();
  c.phase === "DROP_ANIMATING" && n(aB({
    completed: c.completed
  })), e().phase !== "IDLE" && (process.env.NODE_ENV !== "production" ? te(!1, "Unexpected phase to start a drag") : te()), n(iB()), n(yvt({
    draggableId: o,
    movementMode: a
  }));
  const d = {
    draggableId: o,
    scrollOptions: {
      shouldPublishImmediately: a === "SNAP"
    }
  }, {
    critical: u,
    dimensions: f,
    viewport: p
  } = t.startPublishing(d);
  Nvt(u, f), n(bvt({
    critical: u,
    dimensions: f,
    clientSelection: i,
    movementMode: a,
    viewport: p
  }));
}, Rvt = (t) => () => (e) => (n) => {
  n.type === "INITIAL_PUBLISH" && t.dragging(), n.type === "DROP_ANIMATE" && t.dropping(n.payload.completed.result.reason), (n.type === "FLUSH" || n.type === "DROP_COMPLETE") && t.resting(), e(n);
};
const cB = {
  outOfTheWay: "cubic-bezier(0.2, 0, 0, 1)",
  drop: "cubic-bezier(.2,1,.1,1)"
}, Zw = {
  opacity: {
    drop: 0,
    combining: 0.7
  },
  scale: {
    drop: 0.75
  }
}, iye = {
  outOfTheWay: 0.2,
  minDropTime: 0.33,
  maxDropTime: 0.55
}, Ch = `${iye.outOfTheWay}s ${cB.outOfTheWay}`, Fx = {
  fluid: `opacity ${Ch}`,
  snap: `transform ${Ch}, opacity ${Ch}`,
  drop: (t) => {
    const e = `${t}s ${cB.drop}`;
    return `transform ${e}, opacity ${e}`;
  },
  outOfTheWay: `transform ${Ch}`,
  placeholder: `height ${Ch}, width ${Ch}, margin ${Ch}`
}, PK = (t) => Pf(t, Ls) ? void 0 : `translate(${t.x}px, ${t.y}px)`, i$ = {
  moveTo: PK,
  drop: (t, e) => {
    const n = PK(t);
    if (n)
      return e ? `${n} scale(${Zw.scale.drop})` : n;
  }
}, {
  minDropTime: a$,
  maxDropTime: aye
} = iye, $vt = aye - a$, IK = 1500, Lvt = 0.6;
var Fvt = ({
  current: t,
  destination: e,
  reason: n
}) => {
  const r = Yw(t, e);
  if (r <= 0)
    return a$;
  if (r >= IK)
    return aye;
  const s = r / IK, o = a$ + $vt * s, i = n === "CANCEL" ? o * Lvt : o;
  return Number(i.toFixed(2));
}, Bvt = ({
  impact: t,
  draggable: e,
  dimensions: n,
  viewport: r,
  afterCritical: s
}) => {
  const {
    draggables: o,
    droppables: i
  } = n, a = xa(t), c = a ? i[a] : null, l = i[e.descriptor.droppableId], d = eye({
    impact: t,
    draggable: e,
    draggables: o,
    afterCritical: s,
    droppable: c || l,
    viewport: r
  });
  return fa(d, e.client.borderBox.center);
}, zvt = ({
  draggables: t,
  reason: e,
  lastImpact: n,
  home: r,
  viewport: s,
  onLiftImpact: o
}) => !n.at || e !== "DROP" ? {
  impact: Jme({
    draggables: t,
    impact: o,
    destination: r,
    viewport: s,
    forceShouldAnimate: !0
  }),
  didDropInsideDroppable: !1
} : n.at.type === "REORDER" ? {
  impact: n,
  didDropInsideDroppable: !0
} : {
  impact: {
    ...n,
    displaced: qw
  },
  didDropInsideDroppable: !0
};
const Uvt = ({
  getState: t,
  dispatch: e
}) => (n) => (r) => {
  if (r.type !== "DROP") {
    n(r);
    return;
  }
  const s = t(), o = r.payload.reason;
  if (s.phase === "COLLECTING") {
    e(Ovt({
      reason: o
    }));
    return;
  }
  if (s.phase === "IDLE")
    return;
  s.phase === "DROP_PENDING" && s.isWaiting && (process.env.NODE_ENV !== "production" ? te(!1, "A DROP action occurred while DROP_PENDING and still waiting") : te()), s.phase === "DRAGGING" || s.phase === "DROP_PENDING" || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot drop in phase: ${s.phase}`) : te());
  const a = s.critical, c = s.dimensions, l = c.draggables[s.critical.draggable.id], {
    impact: d,
    didDropInsideDroppable: u
  } = zvt({
    reason: o,
    lastImpact: s.impact,
    afterCritical: s.afterCritical,
    onLiftImpact: s.onLiftImpact,
    home: s.dimensions.droppables[s.critical.droppable.id],
    viewport: s.viewport,
    draggables: s.dimensions.draggables
  }), f = u ? eB(d) : null, p = u ? oA(d) : null, g = {
    index: a.draggable.index,
    droppableId: a.droppable.id
  }, y = {
    draggableId: l.descriptor.id,
    type: l.descriptor.type,
    source: g,
    reason: o,
    mode: s.movementMode,
    destination: f,
    combine: p
  }, m = Bvt({
    impact: d,
    draggable: l,
    dimensions: c,
    viewport: s.viewport,
    afterCritical: s.afterCritical
  }), v = {
    critical: s.critical,
    afterCritical: s.afterCritical,
    result: y,
    impact: d
  };
  if (!(!Pf(s.current.client.offset, m) || !!y.combine)) {
    e(aB({
      completed: v
    }));
    return;
  }
  const x = Fvt({
    current: s.current.client.offset,
    destination: m,
    reason: o
  });
  e(Mvt({
    newHomeClientOffset: m,
    dropDuration: x,
    completed: v
  }));
};
var Hvt = Uvt, cye = () => ({
  x: window.pageXOffset,
  y: window.pageYOffset
});
function Vvt(t) {
  return {
    eventName: "scroll",
    options: {
      passive: !0,
      capture: !1
    },
    fn: (e) => {
      e.target !== window && e.target !== window.document || t();
    }
  };
}
function Wvt({
  onWindowScroll: t
}) {
  function e() {
    t(cye());
  }
  const n = Kw(e), r = Vvt(n);
  let s = Tf;
  function o() {
    return s !== Tf;
  }
  function i() {
    o() && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot start scroll listener when already active") : te()), s = nc(window, [r]);
  }
  function a() {
    o() || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot stop scroll listener when not active") : te()), n.cancel(), s(), s = Tf;
  }
  return {
    start: i,
    stop: a,
    isActive: o
  };
}
const Kvt = (t) => t.type === "DROP_COMPLETE" || t.type === "DROP_ANIMATE" || t.type === "FLUSH", Gvt = (t) => {
  const e = Wvt({
    onWindowScroll: (n) => {
      t.dispatch(Evt({
        newScroll: n
      }));
    }
  });
  return (n) => (r) => {
    !e.isActive() && r.type === "INITIAL_PUBLISH" && e.start(), e.isActive() && Kvt(r) && e.stop(), n(r);
  };
};
var Yvt = Gvt, qvt = (t) => {
  let e = !1, n = !1;
  const r = setTimeout(() => {
    n = !0;
  }), s = (o) => {
    if (e) {
      process.env.NODE_ENV !== "production" && Vn("Announcement already made. Not making a second announcement");
      return;
    }
    if (n) {
      process.env.NODE_ENV !== "production" && Vn(`
        Announcements cannot be made asynchronously.
        Default message has already been announced.
      `);
      return;
    }
    e = !0, t(o), clearTimeout(r);
  };
  return s.wasCalled = () => e, s;
}, Xvt = () => {
  const t = [], e = (s) => {
    const o = t.findIndex((a) => a.timerId === s);
    o === -1 && (process.env.NODE_ENV !== "production" ? te(!1, "Could not find timer") : te());
    const [i] = t.splice(o, 1);
    i.callback();
  };
  return {
    add: (s) => {
      const o = setTimeout(() => e(o)), i = {
        timerId: o,
        callback: s
      };
      t.push(i);
    },
    flush: () => {
      if (!t.length)
        return;
      const s = [...t];
      t.length = 0, s.forEach((o) => {
        clearTimeout(o.timerId), o.callback();
      });
    }
  };
};
const Zvt = (t, e) => t == null && e == null ? !0 : t == null || e == null ? !1 : t.droppableId === e.droppableId && t.index === e.index, Qvt = (t, e) => t == null && e == null ? !0 : t == null || e == null ? !1 : t.draggableId === e.draggableId && t.droppableId === e.droppableId, Jvt = (t, e) => {
  if (t === e)
    return !0;
  const n = t.draggable.id === e.draggable.id && t.draggable.droppableId === e.draggable.droppableId && t.draggable.type === e.draggable.type && t.draggable.index === e.draggable.index, r = t.droppable.id === e.droppable.id && t.droppable.type === e.droppable.type;
  return n && r;
}, mb = (t, e) => {
  IS(), e(), kS();
}, CC = (t, e) => ({
  draggableId: t.draggable.id,
  type: t.droppable.type,
  source: {
    droppableId: t.droppable.id,
    index: t.draggable.index
  },
  mode: e
});
function _2(t, e, n, r) {
  if (!t) {
    n(r(e));
    return;
  }
  const s = qvt(n);
  t(e, {
    announce: s
  }), s.wasCalled() || n(r(e));
}
var ebt = (t, e) => {
  const n = Xvt();
  let r = null;
  const s = (u, f) => {
    r && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot fire onBeforeCapture as a drag start has already been published") : te()), mb("onBeforeCapture", () => {
      const p = t().onBeforeCapture;
      p && p({
        draggableId: u,
        mode: f
      });
    });
  }, o = (u, f) => {
    r && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot fire onBeforeDragStart as a drag start has already been published") : te()), mb("onBeforeDragStart", () => {
      const p = t().onBeforeDragStart;
      p && p(CC(u, f));
    });
  }, i = (u, f) => {
    r && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot fire onBeforeDragStart as a drag start has already been published") : te());
    const p = CC(u, f);
    r = {
      mode: f,
      lastCritical: u,
      lastLocation: p.source,
      lastCombine: null
    }, n.add(() => {
      mb("onDragStart", () => _2(t().onDragStart, p, e, R_.onDragStart));
    });
  }, a = (u, f) => {
    const p = eB(f), g = oA(f);
    r || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot fire onDragMove when onDragStart has not been called") : te());
    const y = !Jvt(u, r.lastCritical);
    y && (r.lastCritical = u);
    const m = !Zvt(r.lastLocation, p);
    m && (r.lastLocation = p);
    const v = !Qvt(r.lastCombine, g);
    if (v && (r.lastCombine = g), !y && !m && !v)
      return;
    const b = {
      ...CC(u, r.mode),
      combine: g,
      destination: p
    };
    n.add(() => {
      mb("onDragUpdate", () => _2(t().onDragUpdate, b, e, R_.onDragUpdate));
    });
  }, c = () => {
    r || (process.env.NODE_ENV !== "production" ? te(!1, "Can only flush responders while dragging") : te()), n.flush();
  }, l = (u) => {
    r || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot fire onDragEnd when there is no matching onDragStart") : te()), r = null, mb("onDragEnd", () => _2(t().onDragEnd, u, e, R_.onDragEnd));
  };
  return {
    beforeCapture: s,
    beforeStart: o,
    start: i,
    update: a,
    flush: c,
    drop: l,
    abort: () => {
      if (!r)
        return;
      const u = {
        ...CC(r.lastCritical, r.mode),
        combine: null,
        destination: null,
        reason: "CANCEL"
      };
      l(u);
    }
  };
}, tbt = (t, e) => {
  const n = ebt(t, e);
  return (r) => (s) => (o) => {
    if (o.type === "BEFORE_INITIAL_CAPTURE") {
      n.beforeCapture(o.payload.draggableId, o.payload.movementMode);
      return;
    }
    if (o.type === "INITIAL_PUBLISH") {
      const a = o.payload.critical;
      n.beforeStart(a, o.payload.movementMode), s(o), n.start(a, o.payload.movementMode);
      return;
    }
    if (o.type === "DROP_COMPLETE") {
      const a = o.payload.completed.result;
      n.flush(), s(o), n.drop(a);
      return;
    }
    if (s(o), o.type === "FLUSH") {
      n.abort();
      return;
    }
    const i = r.getState();
    i.phase === "DRAGGING" && n.update(i.critical, i.impact);
  };
};
const nbt = (t) => (e) => (n) => {
  if (n.type !== "DROP_ANIMATION_FINISHED") {
    e(n);
    return;
  }
  const r = t.getState();
  r.phase !== "DROP_ANIMATING" && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot finish a drop animating when no drop is occurring") : te()), t.dispatch(aB({
    completed: r.completed
  }));
};
var rbt = nbt;
const sbt = (t) => {
  let e = null, n = null;
  function r() {
    n && (cancelAnimationFrame(n), n = null), e && (e(), e = null);
  }
  return (s) => (o) => {
    if ((o.type === "FLUSH" || o.type === "DROP_COMPLETE" || o.type === "DROP_ANIMATION_FINISHED") && r(), s(o), o.type !== "DROP_ANIMATE")
      return;
    const i = {
      eventName: "scroll",
      options: {
        capture: !0,
        passive: !1,
        once: !0
      },
      fn: function() {
        t.getState().phase === "DROP_ANIMATING" && t.dispatch(oye());
      }
    };
    n = requestAnimationFrame(() => {
      n = null, e = nc(window, [i]);
    });
  };
};
var obt = sbt, ibt = (t) => () => (e) => (n) => {
  (n.type === "DROP_COMPLETE" || n.type === "FLUSH" || n.type === "DROP_ANIMATE") && t.stopPublishing(), e(n);
}, abt = (t) => {
  let e = !1;
  return () => (n) => (r) => {
    if (r.type === "INITIAL_PUBLISH") {
      e = !0, t.tryRecordFocus(r.payload.critical.draggable.id), n(r), t.tryRestoreFocusRecorded();
      return;
    }
    if (n(r), !!e) {
      if (r.type === "FLUSH") {
        e = !1, t.tryRestoreFocusRecorded();
        return;
      }
      if (r.type === "DROP_COMPLETE") {
        e = !1;
        const s = r.payload.completed.result;
        s.combine && t.tryShiftRecord(s.draggableId, s.combine.draggableId), t.tryRestoreFocusRecorded();
      }
    }
  };
};
const cbt = (t) => t.type === "DROP_COMPLETE" || t.type === "DROP_ANIMATE" || t.type === "FLUSH";
var lbt = (t) => (e) => (n) => (r) => {
  if (cbt(r)) {
    t.stop(), n(r);
    return;
  }
  if (r.type === "INITIAL_PUBLISH") {
    n(r);
    const s = e.getState();
    s.phase !== "DRAGGING" && (process.env.NODE_ENV !== "production" ? te(!1, "Expected phase to be DRAGGING after INITIAL_PUBLISH") : te()), t.start(s);
    return;
  }
  n(r), t.scroll(e.getState());
};
const dbt = (t) => (e) => (n) => {
  if (e(n), n.type !== "PUBLISH_WHILE_DRAGGING")
    return;
  const r = t.getState();
  r.phase === "DROP_PENDING" && (r.isWaiting || t.dispatch(sye({
    reason: r.reason
  })));
};
var ubt = dbt;
const fbt = process.env.NODE_ENV !== "production" && typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
  name: "@hello-pangea/dnd"
}) : wme;
var hbt = ({
  dimensionMarshal: t,
  focusMarshal: e,
  styleMarshal: n,
  getResponders: r,
  announce: s,
  autoScroller: o
}) => xme(mvt, fbt(smt(Rvt(n), ibt(t), jvt(t), Hvt, rbt, obt, ubt, lbt(o), Yvt, abt(e), tbt(r, s))));
const E2 = () => ({
  additions: {},
  removals: {},
  modified: {}
});
function pbt({
  registry: t,
  callbacks: e
}) {
  let n = E2(), r = null;
  const s = () => {
    r || (e.collectionStarting(), r = requestAnimationFrame(() => {
      r = null, IS();
      const {
        additions: c,
        removals: l,
        modified: d
      } = n, u = Object.keys(c).map((g) => t.draggable.getById(g).getDimension(Ls)).sort((g, y) => g.descriptor.index - y.descriptor.index), f = Object.keys(d).map((g) => {
        const m = t.droppable.getById(g).callbacks.getScrollWhileDragging();
        return {
          droppableId: g,
          scroll: m
        };
      }), p = {
        additions: u,
        removals: Object.keys(l),
        modified: f
      };
      n = E2(), kS(), e.publish(p);
    }));
  };
  return {
    add: (c) => {
      const l = c.descriptor.id;
      n.additions[l] = c, n.modified[c.descriptor.droppableId] = !0, n.removals[l] && delete n.removals[l], s();
    },
    remove: (c) => {
      const l = c.descriptor;
      n.removals[l.id] = !0, n.modified[l.droppableId] = !0, n.additions[l.id] && delete n.additions[l.id], s();
    },
    stop: () => {
      r && (cancelAnimationFrame(r), r = null, n = E2());
    }
  };
}
var lye = ({
  scrollHeight: t,
  scrollWidth: e,
  height: n,
  width: r
}) => {
  const s = fa({
    x: e,
    y: t
  }, {
    x: r,
    y: n
  });
  return {
    x: Math.max(0, s.x),
    y: Math.max(0, s.y)
  };
}, dye = () => {
  const t = document.documentElement;
  return t || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot find document.documentElement") : te()), t;
}, uye = () => {
  const t = dye();
  return lye({
    scrollHeight: t.scrollHeight,
    scrollWidth: t.scrollWidth,
    width: t.clientWidth,
    height: t.clientHeight
  });
}, gbt = () => {
  const t = cye(), e = uye(), n = t.y, r = t.x, s = dye(), o = s.clientWidth, i = s.clientHeight, a = r + o, c = n + i;
  return {
    frame: Gc({
      top: n,
      left: r,
      right: a,
      bottom: c
    }),
    scroll: {
      initial: t,
      current: t,
      max: e,
      diff: {
        value: Ls,
        displacement: Ls
      }
    }
  };
}, mbt = ({
  critical: t,
  scrollOptions: e,
  registry: n
}) => {
  IS();
  const r = gbt(), s = r.scroll.current, o = t.droppable, i = n.droppable.getAllByType(o.type).map((d) => d.callbacks.getDimensionAndWatchScroll(s, e)), a = n.draggable.getAllByType(t.draggable.type).map((d) => d.getDimension(s)), c = {
    draggables: Fme(a),
    droppables: Lme(i)
  };
  return kS(), {
    dimensions: c,
    critical: t,
    viewport: r
  };
};
function kK(t, e, n) {
  return n.descriptor.id === e.id || n.descriptor.type !== e.type ? !1 : t.droppable.getById(n.descriptor.droppableId).descriptor.mode !== "virtual" ? (process.env.NODE_ENV !== "production" && Vn(`
      You are attempting to add or remove a Draggable [id: ${n.descriptor.id}]
      while a drag is occurring. This is only supported for virtual lists.

      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md
    `), !1) : !0;
}
var ybt = (t, e) => {
  let n = null;
  const r = pbt({
    callbacks: {
      publish: e.publishWhileDragging,
      collectionStarting: e.collectionStarting
    },
    registry: t
  }), s = (f, p) => {
    t.droppable.exists(f) || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot update is enabled flag of Droppable ${f} as it is not registered`) : te()), n && e.updateDroppableIsEnabled({
      id: f,
      isEnabled: p
    });
  }, o = (f, p) => {
    n && (t.droppable.exists(f) || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot update isCombineEnabled flag of Droppable ${f} as it is not registered`) : te()), e.updateDroppableIsCombineEnabled({
      id: f,
      isCombineEnabled: p
    }));
  }, i = (f, p) => {
    n && (t.droppable.exists(f) || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot update the scroll on Droppable ${f} as it is not registered`) : te()), e.updateDroppableScroll({
      id: f,
      newScroll: p
    }));
  }, a = (f, p) => {
    n && t.droppable.getById(f).callbacks.scroll(p);
  }, c = () => {
    if (!n)
      return;
    r.stop();
    const f = n.critical.droppable;
    t.droppable.getAllByType(f.type).forEach((p) => p.callbacks.dragStopped()), n.unsubscribe(), n = null;
  }, l = (f) => {
    n || (process.env.NODE_ENV !== "production" ? te(!1, "Should only be subscribed when a collection is occurring") : te());
    const p = n.critical.draggable;
    f.type === "ADDITION" && kK(t, p, f.value) && r.add(f.value), f.type === "REMOVAL" && kK(t, p, f.value) && r.remove(f.value);
  };
  return {
    updateDroppableIsEnabled: s,
    updateDroppableIsCombineEnabled: o,
    scrollDroppable: a,
    updateDroppableScroll: i,
    startPublishing: (f) => {
      n && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot start capturing critical dimensions as there is already a collection") : te());
      const p = t.draggable.getById(f.draggableId), g = t.droppable.getById(p.descriptor.droppableId), y = {
        draggable: p.descriptor,
        droppable: g.descriptor
      }, m = t.subscribe(l);
      return n = {
        critical: y,
        unsubscribe: m
      }, mbt({
        critical: y,
        registry: t,
        scrollOptions: f.scrollOptions
      });
    },
    stopPublishing: c
  };
}, fye = (t, e) => t.phase === "IDLE" ? !0 : t.phase !== "DROP_ANIMATING" || t.completed.result.draggableId === e ? !1 : t.completed.result.reason === "DROP", vbt = (t) => {
  window.scrollBy(t.x, t.y);
};
const bbt = cs((t) => sA(t).filter((e) => !(!e.isEnabled || !e.frame))), xbt = (t, e) => bbt(e).find((r) => (r.frame || (process.env.NODE_ENV !== "production" ? te(!1, "Invalid result") : te()), qme(r.frame.pageMarginBox)(t))) || null;
var wbt = ({
  center: t,
  destination: e,
  droppables: n
}) => {
  if (e) {
    const s = n[e];
    return s.frame ? s : null;
  }
  return xbt(t, n);
};
const Qw = {
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  maxPixelScroll: 28,
  ease: (t) => t ** 2,
  durationDampening: {
    stopDampeningAt: 1200,
    accelerateAt: 360
  },
  disabled: !1
};
var Sbt = (t, e, n = () => Qw) => {
  const r = n(), s = t[e.size] * r.startFromPercentage, o = t[e.size] * r.maxScrollAtPercentage;
  return {
    startScrollingFrom: s,
    maxScrollValueAt: o
  };
}, hye = ({
  startOfRange: t,
  endOfRange: e,
  current: n
}) => {
  const r = e - t;
  return r === 0 ? (process.env.NODE_ENV !== "production" && Vn(`
      Detected distance range of 0 in the fluid auto scroller
      This is unexpected and would cause a divide by 0 issue.
      Not allowing an auto scroll
    `), 0) : (n - t) / r;
}, lB = 1, Cbt = (t, e, n = () => Qw) => {
  const r = n();
  if (t > e.startScrollingFrom)
    return 0;
  if (t <= e.maxScrollValueAt)
    return r.maxPixelScroll;
  if (t === e.startScrollingFrom)
    return lB;
  const o = 1 - hye({
    startOfRange: e.maxScrollValueAt,
    endOfRange: e.startScrollingFrom,
    current: t
  }), i = r.maxPixelScroll * r.ease(o);
  return Math.ceil(i);
}, _bt = (t, e, n) => {
  const r = n(), s = r.durationDampening.accelerateAt, o = r.durationDampening.stopDampeningAt, i = e, a = o, l = Date.now() - i;
  if (l >= o)
    return t;
  if (l < s)
    return lB;
  const d = hye({
    startOfRange: s,
    endOfRange: a,
    current: l
  }), u = t * r.ease(d);
  return Math.ceil(u);
}, AK = ({
  distanceToEdge: t,
  thresholds: e,
  dragStartTime: n,
  shouldUseTimeDampening: r,
  getAutoScrollerOptions: s
}) => {
  const o = Cbt(t, e, s);
  return o === 0 ? 0 : r ? Math.max(_bt(o, n, s), lB) : o;
}, MK = ({
  container: t,
  distanceToEdges: e,
  dragStartTime: n,
  axis: r,
  shouldUseTimeDampening: s,
  getAutoScrollerOptions: o
}) => {
  const i = Sbt(t, r, o);
  return e[r.end] < e[r.start] ? AK({
    distanceToEdge: e[r.end],
    thresholds: i,
    dragStartTime: n,
    shouldUseTimeDampening: s,
    getAutoScrollerOptions: o
  }) : -1 * AK({
    distanceToEdge: e[r.start],
    thresholds: i,
    dragStartTime: n,
    shouldUseTimeDampening: s,
    getAutoScrollerOptions: o
  });
}, Ebt = ({
  container: t,
  subject: e,
  proposedScroll: n
}) => {
  const r = e.height > t.height, s = e.width > t.width;
  return !s && !r ? n : s && r ? null : {
    x: s ? 0 : n.x,
    y: r ? 0 : n.y
  };
};
const Tbt = $me((t) => t === 0 ? 0 : t);
var pye = ({
  dragStartTime: t,
  container: e,
  subject: n,
  center: r,
  shouldUseTimeDampening: s,
  getAutoScrollerOptions: o
}) => {
  const i = {
    top: r.y - e.top,
    right: e.right - r.x,
    bottom: e.bottom - r.y,
    left: r.x - e.left
  }, a = MK({
    container: e,
    distanceToEdges: i,
    dragStartTime: t,
    axis: tB,
    shouldUseTimeDampening: s,
    getAutoScrollerOptions: o
  }), c = MK({
    container: e,
    distanceToEdges: i,
    dragStartTime: t,
    axis: Ume,
    shouldUseTimeDampening: s,
    getAutoScrollerOptions: o
  }), l = Tbt({
    x: c,
    y: a
  });
  if (Pf(l, Ls))
    return null;
  const d = Ebt({
    container: e,
    subject: n,
    proposedScroll: l
  });
  return d ? Pf(d, Ls) ? null : d : null;
};
const Pbt = $me((t) => t === 0 ? 0 : t > 0 ? 1 : -1), dB = /* @__PURE__ */ (() => {
  const t = (e, n) => e < 0 ? e : e > n ? e - n : 0;
  return ({
    current: e,
    max: n,
    change: r
  }) => {
    const s = oo(e, r), o = {
      x: t(s.x, n.x),
      y: t(s.y, n.y)
    };
    return Pf(o, Ls) ? null : o;
  };
})(), gye = ({
  max: t,
  current: e,
  change: n
}) => {
  const r = {
    x: Math.max(e.x, t.x),
    y: Math.max(e.y, t.y)
  }, s = Pbt(n), o = dB({
    max: r,
    current: e,
    change: s
  });
  return !o || s.x !== 0 && o.x === 0 || s.y !== 0 && o.y === 0;
}, uB = (t, e) => gye({
  current: t.scroll.current,
  max: t.scroll.max,
  change: e
}), Ibt = (t, e) => {
  if (!uB(t, e))
    return null;
  const n = t.scroll.max, r = t.scroll.current;
  return dB({
    current: r,
    max: n,
    change: e
  });
}, fB = (t, e) => {
  const n = t.frame;
  return n ? gye({
    current: n.scroll.current,
    max: n.scroll.max,
    change: e
  }) : !1;
}, kbt = (t, e) => {
  const n = t.frame;
  return !n || !fB(t, e) ? null : dB({
    current: n.scroll.current,
    max: n.scroll.max,
    change: e
  });
};
var Abt = ({
  viewport: t,
  subject: e,
  center: n,
  dragStartTime: r,
  shouldUseTimeDampening: s,
  getAutoScrollerOptions: o
}) => {
  const i = pye({
    dragStartTime: r,
    container: t.frame,
    subject: e,
    center: n,
    shouldUseTimeDampening: s,
    getAutoScrollerOptions: o
  });
  return i && uB(t, i) ? i : null;
}, Mbt = ({
  droppable: t,
  subject: e,
  center: n,
  dragStartTime: r,
  shouldUseTimeDampening: s,
  getAutoScrollerOptions: o
}) => {
  const i = t.frame;
  if (!i)
    return null;
  const a = pye({
    dragStartTime: r,
    container: i.pageMarginBox,
    subject: e,
    center: n,
    shouldUseTimeDampening: s,
    getAutoScrollerOptions: o
  });
  return a && fB(t, a) ? a : null;
}, OK = ({
  state: t,
  dragStartTime: e,
  shouldUseTimeDampening: n,
  scrollWindow: r,
  scrollDroppable: s,
  getAutoScrollerOptions: o
}) => {
  const i = t.current.page.borderBoxCenter, c = t.dimensions.draggables[t.critical.draggable.id].page.marginBox;
  if (t.isWindowScrollAllowed) {
    const u = t.viewport, f = Abt({
      dragStartTime: e,
      viewport: u,
      subject: c,
      center: i,
      shouldUseTimeDampening: n,
      getAutoScrollerOptions: o
    });
    if (f) {
      r(f);
      return;
    }
  }
  const l = wbt({
    center: i,
    destination: xa(t.impact),
    droppables: t.dimensions.droppables
  });
  if (!l)
    return;
  const d = Mbt({
    dragStartTime: e,
    droppable: l,
    subject: c,
    center: i,
    shouldUseTimeDampening: n,
    getAutoScrollerOptions: o
  });
  d && s(l.descriptor.id, d);
}, Obt = ({
  scrollWindow: t,
  scrollDroppable: e,
  getAutoScrollerOptions: n = () => Qw
}) => {
  const r = Kw(t), s = Kw(e);
  let o = null;
  const i = (l) => {
    o || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot fluid scroll if not dragging") : te());
    const {
      shouldUseTimeDampening: d,
      dragStartTime: u
    } = o;
    OK({
      state: l,
      scrollWindow: r,
      scrollDroppable: s,
      dragStartTime: u,
      shouldUseTimeDampening: d,
      getAutoScrollerOptions: n
    });
  };
  return {
    start: (l) => {
      IS(), o && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot start auto scrolling when already started") : te());
      const d = Date.now();
      let u = !1;
      const f = () => {
        u = !0;
      };
      OK({
        state: l,
        dragStartTime: 0,
        shouldUseTimeDampening: !1,
        scrollWindow: f,
        scrollDroppable: f,
        getAutoScrollerOptions: n
      }), o = {
        dragStartTime: d,
        shouldUseTimeDampening: u
      }, kS(), u && i(l);
    },
    stop: () => {
      o && (r.cancel(), s.cancel(), o = null);
    },
    scroll: i
  };
}, Dbt = ({
  move: t,
  scrollDroppable: e,
  scrollWindow: n
}) => {
  const r = (a, c) => {
    const l = oo(a.current.client.selection, c);
    t({
      client: l
    });
  }, s = (a, c) => {
    if (!fB(a, c))
      return c;
    const l = kbt(a, c);
    if (!l)
      return e(a.descriptor.id, c), null;
    const d = fa(c, l);
    return e(a.descriptor.id, d), fa(c, d);
  }, o = (a, c, l) => {
    if (!a || !uB(c, l))
      return l;
    const d = Ibt(c, l);
    if (!d)
      return n(l), null;
    const u = fa(l, d);
    return n(u), fa(l, u);
  };
  return (a) => {
    const c = a.scrollJumpRequest;
    if (!c)
      return;
    const l = xa(a.impact);
    l || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot perform a jump scroll when there is no destination") : te());
    const d = s(a.dimensions.droppables[l], c);
    if (!d)
      return;
    const u = a.viewport, f = o(a.isWindowScrollAllowed, u, d);
    f && r(a, f);
  };
}, Nbt = ({
  scrollDroppable: t,
  scrollWindow: e,
  move: n,
  getAutoScrollerOptions: r
}) => {
  const s = Obt({
    scrollWindow: e,
    scrollDroppable: t,
    getAutoScrollerOptions: r
  }), o = Dbt({
    move: n,
    scrollWindow: e,
    scrollDroppable: t
  });
  return {
    scroll: (c) => {
      if (!(r().disabled || c.phase !== "DRAGGING")) {
        if (c.movementMode === "FLUID") {
          s.scroll(c);
          return;
        }
        c.scrollJumpRequest && o(c);
      }
    },
    start: s.start,
    stop: s.stop
  };
};
const Oy = "data-rfd", Dy = (() => {
  const t = `${Oy}-drag-handle`;
  return {
    base: t,
    draggableId: `${t}-draggable-id`,
    contextId: `${t}-context-id`
  };
})(), c$ = (() => {
  const t = `${Oy}-draggable`;
  return {
    base: t,
    contextId: `${t}-context-id`,
    id: `${t}-id`
  };
})(), jbt = (() => {
  const t = `${Oy}-droppable`;
  return {
    base: t,
    contextId: `${t}-context-id`,
    id: `${t}-id`
  };
})(), DK = {
  contextId: `${Oy}-scroll-container-context-id`
}, Rbt = (t) => (e) => `[${e}="${t}"]`, yb = (t, e) => t.map((n) => {
  const r = n.styles[e];
  return r ? `${n.selector} { ${r} }` : "";
}).join(" "), $bt = "pointer-events: none;";
var Lbt = (t) => {
  const e = Rbt(t), n = (() => {
    const a = `
      cursor: -webkit-grab;
      cursor: grab;
    `;
    return {
      selector: e(Dy.contextId),
      styles: {
        always: `
          -webkit-touch-callout: none;
          -webkit-tap-highlight-color: rgba(0,0,0,0);
          touch-action: manipulation;
        `,
        resting: a,
        dragging: $bt,
        dropAnimating: a
      }
    };
  })(), r = (() => {
    const a = `
      transition: ${Fx.outOfTheWay};
    `;
    return {
      selector: e(c$.contextId),
      styles: {
        dragging: a,
        dropAnimating: a,
        userCancel: a
      }
    };
  })(), s = {
    selector: e(jbt.contextId),
    styles: {
      always: "overflow-anchor: none;"
    }
  }, i = [r, n, s, {
    selector: "body",
    styles: {
      dragging: `
        cursor: grabbing;
        cursor: -webkit-grabbing;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        overflow-anchor: none;
      `
    }
  }];
  return {
    always: yb(i, "always"),
    resting: yb(i, "resting"),
    dragging: yb(i, "dragging"),
    dropAnimating: yb(i, "dropAnimating"),
    userCancel: yb(i, "userCancel")
  };
};
const Fbt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? un : me;
var wa = Fbt;
const T2 = () => {
  const t = document.querySelector("head");
  return t || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot find the head to append a style to") : te()), t;
}, NK = (t) => {
  const e = document.createElement("style");
  return t && e.setAttribute("nonce", t), e.type = "text/css", e;
};
function Bbt(t, e) {
  const n = rn(() => Lbt(t), [t]), r = fe(null), s = fe(null), o = at(cs((u) => {
    const f = s.current;
    f || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot set dynamic style element if it is not set") : te()), f.textContent = u;
  }), []), i = at((u) => {
    const f = r.current;
    f || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot set dynamic style element if it is not set") : te()), f.textContent = u;
  }, []);
  wa(() => {
    !r.current && !s.current || (process.env.NODE_ENV !== "production" ? te(!1, "style elements already mounted") : te());
    const u = NK(e), f = NK(e);
    return r.current = u, s.current = f, u.setAttribute(`${Oy}-always`, t), f.setAttribute(`${Oy}-dynamic`, t), T2().appendChild(u), T2().appendChild(f), i(n.always), o(n.resting), () => {
      const p = (g) => {
        const y = g.current;
        y || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot unmount ref as it is not set") : te()), T2().removeChild(y), g.current = null;
      };
      p(r), p(s);
    };
  }, [e, i, o, n.always, n.resting, t]);
  const a = at(() => o(n.dragging), [o, n.dragging]), c = at((u) => {
    if (u === "DROP") {
      o(n.dropAnimating);
      return;
    }
    o(n.userCancel);
  }, [o, n.dropAnimating, n.userCancel]), l = at(() => {
    s.current && o(n.resting);
  }, [o, n.resting]);
  return rn(() => ({
    dragging: a,
    dropping: c,
    resting: l
  }), [a, c, l]);
}
function mye(t, e) {
  return Array.from(t.querySelectorAll(e));
}
var yye = (t) => t && t.ownerDocument && t.ownerDocument.defaultView ? t.ownerDocument.defaultView : window;
function AS(t) {
  return t instanceof yye(t).HTMLElement;
}
function vye(t, e) {
  const n = `[${Dy.contextId}="${t}"]`, r = mye(document, n);
  if (!r.length)
    return process.env.NODE_ENV !== "production" && Vn(`Unable to find any drag handles in the context "${t}"`), null;
  const s = r.find((o) => o.getAttribute(Dy.draggableId) === e);
  return s ? AS(s) ? s : (process.env.NODE_ENV !== "production" && Vn("drag handle needs to be a HTMLElement"), null) : (process.env.NODE_ENV !== "production" && Vn(`Unable to find drag handle with id "${e}" as no handle with a matching id was found`), null);
}
function zbt(t) {
  const e = fe({}), n = fe(null), r = fe(null), s = fe(!1), o = at(function(f, p) {
    const g = {
      id: f,
      focus: p
    };
    return e.current[f] = g, function() {
      const m = e.current;
      m[f] !== g && delete m[f];
    };
  }, []), i = at(function(f) {
    const p = vye(t, f);
    p && p !== document.activeElement && p.focus();
  }, [t]), a = at(function(f, p) {
    n.current === f && (n.current = p);
  }, []), c = at(function() {
    r.current || s.current && (r.current = requestAnimationFrame(() => {
      r.current = null;
      const f = n.current;
      f && i(f);
    }));
  }, [i]), l = at(function(f) {
    n.current = null;
    const p = document.activeElement;
    p && p.getAttribute(Dy.draggableId) === f && (n.current = f);
  }, []);
  return wa(() => (s.current = !0, function() {
    s.current = !1;
    const f = r.current;
    f && cancelAnimationFrame(f);
  }), []), rn(() => ({
    register: o,
    tryRecordFocus: l,
    tryRestoreFocusRecorded: c,
    tryShiftRecord: a
  }), [o, l, c, a]);
}
function Ubt() {
  const t = {
    draggables: {},
    droppables: {}
  }, e = [];
  function n(u) {
    return e.push(u), function() {
      const p = e.indexOf(u);
      p !== -1 && e.splice(p, 1);
    };
  }
  function r(u) {
    e.length && e.forEach((f) => f(u));
  }
  function s(u) {
    return t.draggables[u] || null;
  }
  function o(u) {
    const f = s(u);
    return f || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot find draggable entry with id [${u}]`) : te()), f;
  }
  const i = {
    register: (u) => {
      t.draggables[u.descriptor.id] = u, r({
        type: "ADDITION",
        value: u
      });
    },
    update: (u, f) => {
      const p = t.draggables[f.descriptor.id];
      p && p.uniqueId === u.uniqueId && (delete t.draggables[f.descriptor.id], t.draggables[u.descriptor.id] = u);
    },
    unregister: (u) => {
      const f = u.descriptor.id, p = s(f);
      p && u.uniqueId === p.uniqueId && (delete t.draggables[f], t.droppables[u.descriptor.droppableId] && r({
        type: "REMOVAL",
        value: u
      }));
    },
    getById: o,
    findById: s,
    exists: (u) => !!s(u),
    getAllByType: (u) => Object.values(t.draggables).filter((f) => f.descriptor.type === u)
  };
  function a(u) {
    return t.droppables[u] || null;
  }
  function c(u) {
    const f = a(u);
    return f || (process.env.NODE_ENV !== "production" ? te(!1, `Cannot find droppable entry with id [${u}]`) : te()), f;
  }
  const l = {
    register: (u) => {
      t.droppables[u.descriptor.id] = u;
    },
    unregister: (u) => {
      const f = a(u.descriptor.id);
      f && u.uniqueId === f.uniqueId && delete t.droppables[u.descriptor.id];
    },
    getById: c,
    findById: a,
    exists: (u) => !!a(u),
    getAllByType: (u) => Object.values(t.droppables).filter((f) => f.descriptor.type === u)
  };
  function d() {
    t.draggables = {}, t.droppables = {}, e.length = 0;
  }
  return {
    draggable: i,
    droppable: l,
    subscribe: n,
    clean: d
  };
}
function Hbt() {
  const t = rn(Ubt, []);
  return me(() => function() {
    B.version.startsWith("16") || B.version.startsWith("17") ? requestAnimationFrame(t.clean) : t.clean();
  }, [t]), t;
}
var hB = B.createContext(null), Jw = () => {
  const t = document.body;
  return t || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot find document.body") : te()), t;
};
const Vbt = {
  position: "absolute",
  width: "1px",
  height: "1px",
  margin: "-1px",
  border: "0",
  padding: "0",
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  "clip-path": "inset(100%)"
};
var Wbt = Vbt;
const Kbt = (t) => `rfd-announcement-${t}`;
function Gbt(t) {
  const e = rn(() => Kbt(t), [t]), n = fe(null);
  return me(function() {
    const o = document.createElement("div");
    return n.current = o, o.id = e, o.setAttribute("aria-live", "assertive"), o.setAttribute("aria-atomic", "true"), Rn(o.style, Wbt), Jw().appendChild(o), function() {
      setTimeout(function() {
        const c = Jw();
        c.contains(o) && c.removeChild(o), o === n.current && (n.current = null);
      });
    };
  }, [e]), at((s) => {
    const o = n.current;
    if (o) {
      o.textContent = s;
      return;
    }
    process.env.NODE_ENV !== "production" && Vn(`
      A screen reader message was trying to be announced but it was unable to do so.
      This can occur if you unmount your <DragDropContext /> in your onDragEnd.
      Consider calling provided.announce() before the unmount so that the instruction will
      not be lost for users relying on a screen reader.

      Message not passed to screen reader:

      "${s}"
    `);
  }, []);
}
let Ybt = 0;
const bye = {
  separator: "::"
};
function qbt(t, e = bye) {
  return rn(() => `${t}${e.separator}${Ybt++}`, [e.separator, t]);
}
function Xbt(t, e = bye) {
  const n = B.useId();
  return rn(() => `${t}${e.separator}${n}`, [e.separator, t, n]);
}
var pB = "useId" in B ? Xbt : qbt;
function Zbt({
  contextId: t,
  uniqueId: e
}) {
  return `rfd-hidden-text-${t}-${e}`;
}
function Qbt({
  contextId: t,
  text: e
}) {
  const n = pB("hidden-text", {
    separator: "-"
  }), r = rn(() => Zbt({
    contextId: t,
    uniqueId: n
  }), [n, t]);
  return me(function() {
    const o = document.createElement("div");
    return o.id = r, o.textContent = e, o.style.display = "none", Jw().appendChild(o), function() {
      const a = Jw();
      a.contains(o) && a.removeChild(o);
    };
  }, [r, e]), r;
}
var cA = B.createContext(null), Jbt = {
  react: "^16.8.5 || ^17.0.0 || ^18.0.0",
  "react-dom": "^16.8.5 || ^17.0.0 || ^18.0.0"
};
const ext = /(\d+)\.(\d+)\.(\d+)/, jK = (t) => {
  const e = ext.exec(t);
  e == null && (process.env.NODE_ENV !== "production" ? te(!1, `Unable to parse React version ${t}`) : te());
  const n = Number(e[1]), r = Number(e[2]), s = Number(e[3]);
  return {
    major: n,
    minor: r,
    patch: s,
    raw: t
  };
}, txt = (t, e) => e.major > t.major ? !0 : e.major < t.major ? !1 : e.minor > t.minor ? !0 : e.minor < t.minor ? !1 : e.patch >= t.patch;
var nxt = (t, e) => {
  const n = jK(t), r = jK(e);
  txt(n, r) || process.env.NODE_ENV !== "production" && Vn(`
    React version: [${r.raw}]
    does not satisfy expected peer dependency version: [${n.raw}]

    This can result in run time bugs, and even fatal crashes
  `);
};
const P2 = `
  We expect a html5 doctype: <!doctype html>
  This is to ensure consistent browser layout and measurement

  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md
`;
var rxt = (t) => {
  const e = t.doctype;
  if (!e) {
    process.env.NODE_ENV !== "production" && Vn(`
      No <!doctype html> found.

      ${P2}
    `);
    return;
  }
  e.name.toLowerCase() !== "html" && process.env.NODE_ENV !== "production" && Vn(`
      Unexpected <!doctype> found: (${e.name})

      ${P2}
    `), e.publicId !== "" && process.env.NODE_ENV !== "production" && Vn(`
      Unexpected <!doctype> publicId found: (${e.publicId})
      A html5 doctype does not have a publicId

      ${P2}
    `);
};
function gB(t) {
  process.env.NODE_ENV !== "production" && t();
}
function MS(t, e) {
  gB(() => {
    me(() => {
      try {
        t();
      } catch (n) {
        r$(`
          A setup problem was encountered.

          > ${n.message}
        `);
      }
    }, e);
  });
}
function sxt() {
  MS(() => {
    nxt(Jbt.react, B.version), rxt(document);
  }, []);
}
function mB(t) {
  const e = fe(t);
  return me(() => {
    e.current = t;
  }), e;
}
function oxt() {
  let t = null;
  function e() {
    return !!t;
  }
  function n(i) {
    return i === t;
  }
  function r(i) {
    t && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot claim lock as it is already claimed") : te());
    const a = {
      abandon: i
    };
    return t = a, a;
  }
  function s() {
    t || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot release lock when there is no lock") : te()), t = null;
  }
  function o() {
    t && (t.abandon(), s());
  }
  return {
    isClaimed: e,
    isActive: n,
    claim: r,
    release: s,
    tryAbandon: o
  };
}
function e0(t) {
  return t.phase === "IDLE" || t.phase === "DROP_ANIMATING" ? !1 : t.isDragging;
}
const ixt = 9, axt = 13, yB = 27, xye = 32, cxt = 33, lxt = 34, dxt = 35, uxt = 36, fxt = 37, hxt = 38, pxt = 39, gxt = 40, mxt = {
  [axt]: !0,
  [ixt]: !0
};
var wye = (t) => {
  mxt[t.keyCode] && t.preventDefault();
};
const yxt = (() => {
  const t = "visibilitychange";
  return typeof document > "u" ? t : [t, `ms${t}`, `webkit${t}`, `moz${t}`, `o${t}`].find((r) => `on${r}` in document) || t;
})();
var lA = yxt;
const Sye = 0, RK = 5;
function vxt(t, e) {
  return Math.abs(e.x - t.x) >= RK || Math.abs(e.y - t.y) >= RK;
}
const $K = {
  type: "IDLE"
};
function bxt({
  cancel: t,
  completed: e,
  getPhase: n,
  setPhase: r
}) {
  return [{
    eventName: "mousemove",
    fn: (s) => {
      const {
        button: o,
        clientX: i,
        clientY: a
      } = s;
      if (o !== Sye)
        return;
      const c = {
        x: i,
        y: a
      }, l = n();
      if (l.type === "DRAGGING") {
        s.preventDefault(), l.actions.move(c);
        return;
      }
      l.type !== "PENDING" && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot be IDLE") : te());
      const d = l.point;
      if (!vxt(d, c))
        return;
      s.preventDefault();
      const u = l.actions.fluidLift(c);
      r({
        type: "DRAGGING",
        actions: u
      });
    }
  }, {
    eventName: "mouseup",
    fn: (s) => {
      const o = n();
      if (o.type !== "DRAGGING") {
        t();
        return;
      }
      s.preventDefault(), o.actions.drop({
        shouldBlockNextClick: !0
      }), e();
    }
  }, {
    eventName: "mousedown",
    fn: (s) => {
      n().type === "DRAGGING" && s.preventDefault(), t();
    }
  }, {
    eventName: "keydown",
    fn: (s) => {
      if (n().type === "PENDING") {
        t();
        return;
      }
      if (s.keyCode === yB) {
        s.preventDefault(), t();
        return;
      }
      wye(s);
    }
  }, {
    eventName: "resize",
    fn: t
  }, {
    eventName: "scroll",
    options: {
      passive: !0,
      capture: !1
    },
    fn: () => {
      n().type === "PENDING" && t();
    }
  }, {
    eventName: "webkitmouseforcedown",
    fn: (s) => {
      const o = n();
      if (o.type === "IDLE" && (process.env.NODE_ENV !== "production" ? te(!1, "Unexpected phase") : te()), o.actions.shouldRespectForcePress()) {
        t();
        return;
      }
      s.preventDefault();
    }
  }, {
    eventName: lA,
    fn: t
  }];
}
function xxt(t) {
  const e = fe($K), n = fe(Tf), r = rn(() => ({
    eventName: "mousedown",
    fn: function(u) {
      if (u.defaultPrevented || u.button !== Sye || u.ctrlKey || u.metaKey || u.shiftKey || u.altKey)
        return;
      const f = t.findClosestDraggableId(u);
      if (!f)
        return;
      const p = t.tryGetLock(f, i, {
        sourceEvent: u
      });
      if (!p)
        return;
      u.preventDefault();
      const g = {
        x: u.clientX,
        y: u.clientY
      };
      n.current(), l(p, g);
    }
  }), [t]), s = rn(() => ({
    eventName: "webkitmouseforcewillbegin",
    fn: (d) => {
      if (d.defaultPrevented)
        return;
      const u = t.findClosestDraggableId(d);
      if (!u)
        return;
      const f = t.findOptionsForDraggable(u);
      f && (f.shouldRespectForcePress || t.canGetLock(u) && d.preventDefault());
    }
  }), [t]), o = at(function() {
    const u = {
      passive: !1,
      capture: !0
    };
    n.current = nc(window, [s, r], u);
  }, [s, r]), i = at(() => {
    e.current.type !== "IDLE" && (e.current = $K, n.current(), o());
  }, [o]), a = at(() => {
    const d = e.current;
    i(), d.type === "DRAGGING" && d.actions.cancel({
      shouldBlockNextClick: !0
    }), d.type === "PENDING" && d.actions.abort();
  }, [i]), c = at(function() {
    const u = {
      capture: !0,
      passive: !1
    }, f = bxt({
      cancel: a,
      completed: i,
      getPhase: () => e.current,
      setPhase: (p) => {
        e.current = p;
      }
    });
    n.current = nc(window, f, u);
  }, [a, i]), l = at(function(u, f) {
    e.current.type !== "IDLE" && (process.env.NODE_ENV !== "production" ? te(!1, "Expected to move from IDLE to PENDING drag") : te()), e.current = {
      type: "PENDING",
      point: f,
      actions: u
    }, c();
  }, [c]);
  wa(function() {
    return o(), function() {
      n.current();
    };
  }, [o]);
}
function wxt() {
}
const Sxt = {
  [lxt]: !0,
  [cxt]: !0,
  [uxt]: !0,
  [dxt]: !0
};
function Cxt(t, e) {
  function n() {
    e(), t.cancel();
  }
  function r() {
    e(), t.drop();
  }
  return [{
    eventName: "keydown",
    fn: (s) => {
      if (s.keyCode === yB) {
        s.preventDefault(), n();
        return;
      }
      if (s.keyCode === xye) {
        s.preventDefault(), r();
        return;
      }
      if (s.keyCode === gxt) {
        s.preventDefault(), t.moveDown();
        return;
      }
      if (s.keyCode === hxt) {
        s.preventDefault(), t.moveUp();
        return;
      }
      if (s.keyCode === pxt) {
        s.preventDefault(), t.moveRight();
        return;
      }
      if (s.keyCode === fxt) {
        s.preventDefault(), t.moveLeft();
        return;
      }
      if (Sxt[s.keyCode]) {
        s.preventDefault();
        return;
      }
      wye(s);
    }
  }, {
    eventName: "mousedown",
    fn: n
  }, {
    eventName: "mouseup",
    fn: n
  }, {
    eventName: "click",
    fn: n
  }, {
    eventName: "touchstart",
    fn: n
  }, {
    eventName: "resize",
    fn: n
  }, {
    eventName: "wheel",
    fn: n,
    options: {
      passive: !0
    }
  }, {
    eventName: lA,
    fn: n
  }];
}
function _xt(t) {
  const e = fe(wxt), n = rn(() => ({
    eventName: "keydown",
    fn: function(o) {
      if (o.defaultPrevented || o.keyCode !== xye)
        return;
      const i = t.findClosestDraggableId(o);
      if (!i)
        return;
      const a = t.tryGetLock(i, d, {
        sourceEvent: o
      });
      if (!a)
        return;
      o.preventDefault();
      let c = !0;
      const l = a.snapLift();
      e.current();
      function d() {
        c || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot stop capturing a keyboard drag when not capturing") : te()), c = !1, e.current(), r();
      }
      e.current = nc(window, Cxt(l, d), {
        capture: !0,
        passive: !1
      });
    }
  }), [t]), r = at(function() {
    const o = {
      passive: !1,
      capture: !0
    };
    e.current = nc(window, [n], o);
  }, [n]);
  wa(function() {
    return r(), function() {
      e.current();
    };
  }, [r]);
}
const I2 = {
  type: "IDLE"
}, Ext = 120, Txt = 0.15;
function Pxt({
  cancel: t,
  getPhase: e
}) {
  return [{
    eventName: "orientationchange",
    fn: t
  }, {
    eventName: "resize",
    fn: t
  }, {
    eventName: "contextmenu",
    fn: (n) => {
      n.preventDefault();
    }
  }, {
    eventName: "keydown",
    fn: (n) => {
      if (e().type !== "DRAGGING") {
        t();
        return;
      }
      n.keyCode === yB && n.preventDefault(), t();
    }
  }, {
    eventName: lA,
    fn: t
  }];
}
function Ixt({
  cancel: t,
  completed: e,
  getPhase: n
}) {
  return [{
    eventName: "touchmove",
    options: {
      capture: !1
    },
    fn: (r) => {
      const s = n();
      if (s.type !== "DRAGGING") {
        t();
        return;
      }
      s.hasMoved = !0;
      const {
        clientX: o,
        clientY: i
      } = r.touches[0], a = {
        x: o,
        y: i
      };
      r.preventDefault(), s.actions.move(a);
    }
  }, {
    eventName: "touchend",
    fn: (r) => {
      const s = n();
      if (s.type !== "DRAGGING") {
        t();
        return;
      }
      r.preventDefault(), s.actions.drop({
        shouldBlockNextClick: !0
      }), e();
    }
  }, {
    eventName: "touchcancel",
    fn: (r) => {
      if (n().type !== "DRAGGING") {
        t();
        return;
      }
      r.preventDefault(), t();
    }
  }, {
    eventName: "touchforcechange",
    fn: (r) => {
      const s = n();
      s.type === "IDLE" && (process.env.NODE_ENV, te());
      const o = r.touches[0];
      if (!o || !(o.force >= Txt))
        return;
      const a = s.actions.shouldRespectForcePress();
      if (s.type === "PENDING") {
        a && t();
        return;
      }
      if (a) {
        if (s.hasMoved) {
          r.preventDefault();
          return;
        }
        t();
        return;
      }
      r.preventDefault();
    }
  }, {
    eventName: lA,
    fn: t
  }];
}
function kxt(t) {
  const e = fe(I2), n = fe(Tf), r = at(function() {
    return e.current;
  }, []), s = at(function(p) {
    e.current = p;
  }, []), o = rn(() => ({
    eventName: "touchstart",
    fn: function(p) {
      if (p.defaultPrevented)
        return;
      const g = t.findClosestDraggableId(p);
      if (!g)
        return;
      const y = t.tryGetLock(g, a, {
        sourceEvent: p
      });
      if (!y)
        return;
      const m = p.touches[0], {
        clientX: v,
        clientY: b
      } = m, x = {
        x: v,
        y: b
      };
      n.current(), u(y, x);
    }
  }), [t]), i = at(function() {
    const p = {
      capture: !0,
      passive: !1
    };
    n.current = nc(window, [o], p);
  }, [o]), a = at(() => {
    const f = e.current;
    f.type !== "IDLE" && (f.type === "PENDING" && clearTimeout(f.longPressTimerId), s(I2), n.current(), i());
  }, [i, s]), c = at(() => {
    const f = e.current;
    a(), f.type === "DRAGGING" && f.actions.cancel({
      shouldBlockNextClick: !0
    }), f.type === "PENDING" && f.actions.abort();
  }, [a]), l = at(function() {
    const p = {
      capture: !0,
      passive: !1
    }, g = {
      cancel: c,
      completed: a,
      getPhase: r
    }, y = nc(window, Ixt(g), p), m = nc(window, Pxt(g), p);
    n.current = function() {
      y(), m();
    };
  }, [c, r, a]), d = at(function() {
    const p = r();
    p.type !== "PENDING" && (process.env.NODE_ENV !== "production" ? te(!1, `Cannot start dragging from phase ${p.type}`) : te());
    const g = p.actions.fluidLift(p.point);
    s({
      type: "DRAGGING",
      actions: g,
      hasMoved: !1
    });
  }, [r, s]), u = at(function(p, g) {
    r().type !== "IDLE" && (process.env.NODE_ENV !== "production" ? te(!1, "Expected to move from IDLE to PENDING drag") : te());
    const y = setTimeout(d, Ext);
    s({
      type: "PENDING",
      point: g,
      actions: p,
      longPressTimerId: y
    }), l();
  }, [l, r, s, d]);
  wa(function() {
    return i(), function() {
      n.current();
      const g = r();
      g.type === "PENDING" && (clearTimeout(g.longPressTimerId), s(I2));
    };
  }, [r, i, s]), wa(function() {
    return nc(window, [{
      eventName: "touchmove",
      fn: () => {
      },
      options: {
        capture: !1,
        passive: !1
      }
    }]);
  }, []);
}
function Axt(t) {
  gB(() => {
    const e = mB(t);
    MS(() => {
      e.current.length !== t.length && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot change the amount of sensor hooks after mounting") : te(!1));
    });
  });
}
const Mxt = ["input", "button", "textarea", "select", "option", "optgroup", "video", "audio"];
function Cye(t, e) {
  if (e == null)
    return !1;
  if (Mxt.includes(e.tagName.toLowerCase()))
    return !0;
  const r = e.getAttribute("contenteditable");
  return r === "true" || r === "" ? !0 : e === t ? !1 : Cye(t, e.parentElement);
}
function Oxt(t, e) {
  const n = e.target;
  return AS(n) ? Cye(t, n) : !1;
}
var Dxt = (t) => Gc(t.getBoundingClientRect()).center;
function Nxt(t) {
  return t instanceof yye(t).Element;
}
const jxt = (() => {
  const t = "matches";
  return typeof document > "u" ? t : [t, "msMatchesSelector", "webkitMatchesSelector"].find((r) => r in Element.prototype) || t;
})();
function _ye(t, e) {
  return t == null ? null : t[jxt](e) ? t : _ye(t.parentElement, e);
}
function Rxt(t, e) {
  return t.closest ? t.closest(e) : _ye(t, e);
}
function $xt(t) {
  return `[${Dy.contextId}="${t}"]`;
}
function Lxt(t, e) {
  const n = e.target;
  if (!Nxt(n))
    return process.env.NODE_ENV !== "production" && Vn("event.target must be a Element"), null;
  const r = $xt(t), s = Rxt(n, r);
  return s ? AS(s) ? s : (process.env.NODE_ENV !== "production" && Vn("drag handle must be a HTMLElement"), null) : null;
}
function Fxt(t, e) {
  const n = Lxt(t, e);
  return n ? n.getAttribute(Dy.draggableId) : null;
}
function Bxt(t, e) {
  const n = `[${c$.contextId}="${t}"]`, s = mye(document, n).find((o) => o.getAttribute(c$.id) === e);
  return s ? AS(s) ? s : (process.env.NODE_ENV !== "production" && Vn("Draggable element is not a HTMLElement"), null) : null;
}
function zxt(t) {
  t.preventDefault();
}
function _C({
  expected: t,
  phase: e,
  isLockActive: n,
  shouldWarn: r
}) {
  return n() ? t !== e ? (r && process.env.NODE_ENV !== "production" && Vn(`
        Cannot perform action.
        The actions you used belong to an outdated phase

        Current phase: ${t}
        You called an action from outdated phase: ${e}

        Tips:

        - Do not use preDragActions actions after calling preDragActions.lift()
      `), !1) : !0 : (r && process.env.NODE_ENV !== "production" && Vn(`
        Cannot perform action.
        The sensor no longer has an action lock.

        Tips:

        - Throw away your action handlers when forceStop() is called
        - Check actions.isActive() if you really need to
      `), !1);
}
function Eye({
  lockAPI: t,
  store: e,
  registry: n,
  draggableId: r
}) {
  if (t.isClaimed())
    return !1;
  const s = n.draggable.findById(r);
  return s ? !(!s.options.isEnabled || !fye(e.getState(), r)) : (process.env.NODE_ENV !== "production" && Vn(`Unable to find draggable with id: ${r}`), !1);
}
function Uxt({
  lockAPI: t,
  contextId: e,
  store: n,
  registry: r,
  draggableId: s,
  forceSensorStop: o,
  sourceEvent: i
}) {
  if (!Eye({
    lockAPI: t,
    store: n,
    registry: r,
    draggableId: s
  }))
    return null;
  const c = r.draggable.getById(s), l = Bxt(e, c.descriptor.id);
  if (!l)
    return process.env.NODE_ENV !== "production" && Vn(`Unable to find draggable element with id: ${s}`), null;
  if (i && !c.options.canDragInteractiveElements && Oxt(l, i))
    return null;
  const d = t.claim(o || Tf);
  let u = "PRE_DRAG";
  function f() {
    return c.options.shouldRespectForcePress;
  }
  function p() {
    return t.isActive(d);
  }
  function g(S, C) {
    _C({
      expected: S,
      phase: u,
      isLockActive: p,
      shouldWarn: !0
    }) && n.dispatch(C());
  }
  const y = g.bind(null, "DRAGGING");
  function m(S) {
    function C() {
      t.release(), u = "COMPLETED";
    }
    u !== "PRE_DRAG" && (C(), process.env.NODE_ENV !== "production" ? te(!1, `Cannot lift in phase ${u}`) : te()), n.dispatch(vvt(S.liftActionArgs)), u = "DRAGGING";
    function _(E, M = {
      shouldBlockNextClick: !1
    }) {
      if (S.cleanup(), M.shouldBlockNextClick) {
        const N = nc(window, [{
          eventName: "click",
          fn: zxt,
          options: {
            once: !0,
            passive: !1,
            capture: !0
          }
        }]);
        setTimeout(N);
      }
      C(), n.dispatch(sye({
        reason: E
      }));
    }
    return {
      isActive: () => _C({
        expected: "DRAGGING",
        phase: u,
        isLockActive: p,
        shouldWarn: !1
      }),
      shouldRespectForcePress: f,
      drop: (E) => _("DROP", E),
      cancel: (E) => _("CANCEL", E),
      ...S.actions
    };
  }
  function v(S) {
    const C = Kw((E) => {
      y(() => rye({
        client: E
      }));
    });
    return {
      ...m({
        liftActionArgs: {
          id: s,
          clientSelection: S,
          movementMode: "FLUID"
        },
        cleanup: () => C.cancel(),
        actions: {
          move: C
        }
      }),
      move: C
    };
  }
  function b() {
    const S = {
      moveUp: () => y(Pvt),
      moveRight: () => y(kvt),
      moveDown: () => y(Ivt),
      moveLeft: () => y(Avt)
    };
    return m({
      liftActionArgs: {
        id: s,
        clientSelection: Dxt(l),
        movementMode: "SNAP"
      },
      cleanup: Tf,
      actions: S
    });
  }
  function x() {
    _C({
      expected: "PRE_DRAG",
      phase: u,
      isLockActive: p,
      shouldWarn: !0
    }) && t.release();
  }
  return {
    isActive: () => _C({
      expected: "PRE_DRAG",
      phase: u,
      isLockActive: p,
      shouldWarn: !1
    }),
    shouldRespectForcePress: f,
    fluidLift: v,
    snapLift: b,
    abort: x
  };
}
const Hxt = [xxt, _xt, kxt];
function Vxt({
  contextId: t,
  store: e,
  registry: n,
  customSensors: r,
  enableDefaultSensors: s
}) {
  const o = [...s ? Hxt : [], ...r || []], i = he(() => oxt())[0], a = at(function(m, v) {
    e0(m) && !e0(v) && i.tryAbandon();
  }, [i]);
  wa(function() {
    let m = e.getState();
    return e.subscribe(() => {
      const b = e.getState();
      a(m, b), m = b;
    });
  }, [i, e, a]), wa(() => i.tryAbandon, [i.tryAbandon]);
  const c = at((y) => Eye({
    lockAPI: i,
    registry: n,
    store: e,
    draggableId: y
  }), [i, n, e]), l = at((y, m, v) => Uxt({
    lockAPI: i,
    registry: n,
    contextId: t,
    store: e,
    draggableId: y,
    forceSensorStop: m || null,
    sourceEvent: v && v.sourceEvent ? v.sourceEvent : null
  }), [t, i, n, e]), d = at((y) => Fxt(t, y), [t]), u = at((y) => {
    const m = n.draggable.findById(y);
    return m ? m.options : null;
  }, [n.draggable]), f = at(function() {
    i.isClaimed() && (i.tryAbandon(), e.getState().phase !== "IDLE" && e.dispatch(iB()));
  }, [i, e]), p = at(() => i.isClaimed(), [i]), g = rn(() => ({
    canGetLock: c,
    tryGetLock: l,
    findClosestDraggableId: d,
    findOptionsForDraggable: u,
    tryReleaseLock: f,
    isLockClaimed: p
  }), [c, l, d, u, f, p]);
  Axt(o);
  for (let y = 0; y < o.length; y++)
    o[y](g);
}
const Wxt = (t) => ({
  onBeforeCapture: (e) => {
    const n = () => {
      t.onBeforeCapture && t.onBeforeCapture(e);
    };
    B.version.startsWith("16") || B.version.startsWith("17") ? n() : x0(n);
  },
  onBeforeDragStart: t.onBeforeDragStart,
  onDragStart: t.onDragStart,
  onDragEnd: t.onDragEnd,
  onDragUpdate: t.onDragUpdate
}), Kxt = (t) => ({
  ...Qw,
  ...t.autoScrollerOptions,
  durationDampening: {
    ...Qw.durationDampening,
    ...t.autoScrollerOptions
  }
});
function vb(t) {
  return t.current || (process.env.NODE_ENV !== "production" ? te(!1, "Could not find store from lazy ref") : te()), t.current;
}
function Gxt(t) {
  const {
    contextId: e,
    setCallbacks: n,
    sensors: r,
    nonce: s,
    dragHandleUsageInstructions: o
  } = t, i = fe(null);
  sxt();
  const a = mB(t), c = at(() => Wxt(a.current), [a]), l = at(() => Kxt(a.current), [a]), d = Gbt(e), u = Qbt({
    contextId: e,
    text: o
  }), f = Bbt(e, s), p = at((N) => {
    vb(i).dispatch(N);
  }, []), g = rn(() => ZW({
    publishWhileDragging: xvt,
    updateDroppableScroll: Svt,
    updateDroppableIsEnabled: Cvt,
    updateDroppableIsCombineEnabled: _vt,
    collectionStarting: wvt
  }, p), [p]), y = Hbt(), m = rn(() => ybt(y, g), [y, g]), v = rn(() => Nbt({
    scrollWindow: vbt,
    scrollDroppable: m.scrollDroppable,
    getAutoScrollerOptions: l,
    ...ZW({
      move: rye
    }, p)
  }), [m.scrollDroppable, p, l]), b = zbt(e), x = rn(() => hbt({
    announce: d,
    autoScroller: v,
    dimensionMarshal: m,
    focusMarshal: b,
    getResponders: c,
    styleMarshal: f
  }), [d, v, m, b, c, f]);
  process.env.NODE_ENV !== "production" && i.current && i.current !== x && process.env.NODE_ENV !== "production" && Vn("unexpected store change"), i.current = x;
  const w = at(() => {
    const N = vb(i);
    N.getState().phase !== "IDLE" && N.dispatch(iB());
  }, []), S = at(() => {
    const N = vb(i).getState();
    return N.phase === "DROP_ANIMATING" ? !0 : N.phase === "IDLE" ? !1 : N.isDragging;
  }, []), C = rn(() => ({
    isDragging: S,
    tryAbort: w
  }), [S, w]);
  n(C);
  const _ = at((N) => fye(vb(i).getState(), N), []), E = at(() => Ah(vb(i).getState()), []), M = rn(() => ({
    marshal: m,
    focus: b,
    contextId: e,
    canLift: _,
    isMovementAllowed: E,
    dragHandleUsageInstructionsId: u,
    registry: y
  }), [e, m, u, b, _, E, y]);
  return Vxt({
    contextId: e,
    store: x,
    registry: y,
    customSensors: r || null,
    enableDefaultSensors: t.enableDefaultSensors !== !1
  }), me(() => w, [w]), B.createElement(cA.Provider, {
    value: M
  }, B.createElement(Vmt, {
    context: hB,
    store: x
  }, t.children));
}
let Yxt = 0;
function qxt() {
  return rn(() => `${Yxt++}`, []);
}
function Xxt() {
  return B.useId();
}
var Zxt = "useId" in B ? Xxt : qxt;
function Qxt(t) {
  const e = Zxt(), n = t.dragHandleUsageInstructions || R_.dragHandleUsageInstructions;
  return B.createElement(iyt, null, (r) => B.createElement(Gxt, {
    nonce: t.nonce,
    contextId: e,
    setCallbacks: r,
    dragHandleUsageInstructions: n,
    enableDefaultSensors: t.enableDefaultSensors,
    sensors: t.sensors,
    onBeforeCapture: t.onBeforeCapture,
    onBeforeDragStart: t.onBeforeDragStart,
    onDragStart: t.onDragStart,
    onDragUpdate: t.onDragUpdate,
    onDragEnd: t.onDragEnd,
    autoScrollerOptions: t.autoScrollerOptions
  }, t.children));
}
const LK = {
  dragging: 5e3,
  dropAnimating: 4500
}, Jxt = (t, e) => e ? Fx.drop(e.duration) : t ? Fx.snap : Fx.fluid, ewt = (t, e) => {
  if (t)
    return e ? Zw.opacity.drop : Zw.opacity.combining;
}, twt = (t) => t.forceShouldAnimate != null ? t.forceShouldAnimate : t.mode === "SNAP";
function nwt(t) {
  const n = t.dimension.client, {
    offset: r,
    combineWith: s,
    dropping: o
  } = t, i = !!s, a = twt(t), c = !!o, l = c ? i$.drop(r, i) : i$.moveTo(r);
  return {
    position: "fixed",
    top: n.marginBox.top,
    left: n.marginBox.left,
    boxSizing: "border-box",
    width: n.borderBox.width,
    height: n.borderBox.height,
    transition: Jxt(a, o),
    transform: l,
    opacity: ewt(i, c),
    zIndex: c ? LK.dropAnimating : LK.dragging,
    pointerEvents: "none"
  };
}
function rwt(t) {
  return {
    transform: i$.moveTo(t.offset),
    transition: t.shouldAnimateDisplacement ? void 0 : "none"
  };
}
function swt(t) {
  return t.type === "DRAGGING" ? nwt(t) : rwt(t);
}
function owt(t, e, n = Ls) {
  const r = window.getComputedStyle(e), s = e.getBoundingClientRect(), o = Ome(s, r), i = fP(o, n), a = {
    client: o,
    tagName: e.tagName.toLowerCase(),
    display: r.display
  }, c = {
    x: o.marginBox.width,
    y: o.marginBox.height
  };
  return {
    descriptor: t,
    placeholder: a,
    displaceBy: c,
    client: o,
    page: i
  };
}
function iwt(t) {
  const e = pB("draggable"), {
    descriptor: n,
    registry: r,
    getDraggableRef: s,
    canDragInteractiveElements: o,
    shouldRespectForcePress: i,
    isEnabled: a
  } = t, c = rn(() => ({
    canDragInteractiveElements: o,
    shouldRespectForcePress: i,
    isEnabled: a
  }), [o, a, i]), l = at((p) => {
    const g = s();
    return g || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot get dimension when no ref is set") : te()), owt(n, g, p);
  }, [n, s]), d = rn(() => ({
    uniqueId: e,
    descriptor: n,
    options: c,
    getDimension: l
  }), [n, l, c, e]), u = fe(d), f = fe(!0);
  wa(() => (r.draggable.register(u.current), () => r.draggable.unregister(u.current)), [r.draggable]), wa(() => {
    if (f.current) {
      f.current = !1;
      return;
    }
    const p = u.current;
    u.current = d, r.draggable.update(d, p);
  }, [d, r.draggable]);
}
var vB = B.createContext(null);
function Tye(t) {
  t && AS(t) || (process.env.NODE_ENV !== "production" ? te(!1, `
    provided.innerRef has not been provided with a HTMLElement.

    You can find a guide on using the innerRef callback functions at:
    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md
  `) : te());
}
function awt(t, e, n) {
  MS(() => {
    function r(o) {
      return `Draggable[id: ${o}]: `;
    }
    const s = t.draggableId;
    s || (process.env.NODE_ENV !== "production" ? te(!1, "Draggable requires a draggableId") : te(!1)), typeof s != "string" && (process.env.NODE_ENV !== "production" ? te(!1, `Draggable requires a [string] draggableId.
      Provided: [type: ${typeof s}] (value: ${s})`) : te(!1)), Number.isInteger(t.index) || (process.env.NODE_ENV !== "production" ? te(!1, `${r(s)} requires an integer index prop`) : te(!1)), t.mapped.type !== "DRAGGING" && (Tye(n()), t.isEnabled && (vye(e, s) || (process.env.NODE_ENV !== "production" ? te(!1, `${r(s)} Unable to find drag handle`) : te(!1))));
  });
}
function cwt(t) {
  gB(() => {
    const e = fe(t);
    MS(() => {
      t !== e.current && (process.env.NODE_ENV !== "production" ? te(!1, "Draggable isClone prop value changed during component life") : te(!1));
    }, [t]);
  });
}
function gP(t) {
  const e = tn(t);
  return e || (process.env.NODE_ENV !== "production" ? te(!1, "Could not find required context") : te()), e;
}
function lwt(t) {
  t.preventDefault();
}
const dwt = (t) => {
  const e = fe(null), n = at((C = null) => {
    e.current = C;
  }, []), r = at(() => e.current, []), {
    contextId: s,
    dragHandleUsageInstructionsId: o,
    registry: i
  } = gP(cA), {
    type: a,
    droppableId: c
  } = gP(vB), l = rn(() => ({
    id: t.draggableId,
    index: t.index,
    type: a,
    droppableId: c
  }), [t.draggableId, t.index, a, c]), {
    children: d,
    draggableId: u,
    isEnabled: f,
    shouldRespectForcePress: p,
    canDragInteractiveElements: g,
    isClone: y,
    mapped: m,
    dropAnimationFinished: v
  } = t;
  if (awt(t, s, r), cwt(y), !y) {
    const C = rn(() => ({
      descriptor: l,
      registry: i,
      getDraggableRef: r,
      canDragInteractiveElements: g,
      shouldRespectForcePress: p,
      isEnabled: f
    }), [l, i, r, g, p, f]);
    iwt(C);
  }
  const b = rn(() => f ? {
    tabIndex: 0,
    role: "button",
    "aria-describedby": o,
    "data-rfd-drag-handle-draggable-id": u,
    "data-rfd-drag-handle-context-id": s,
    draggable: !1,
    onDragStart: lwt
  } : null, [s, o, u, f]), x = at((C) => {
    m.type === "DRAGGING" && m.dropping && C.propertyName === "transform" && (B.version.startsWith("16") || B.version.startsWith("17") ? v() : x0(v));
  }, [v, m]), w = rn(() => {
    const C = swt(m), _ = m.type === "DRAGGING" && m.dropping ? x : void 0;
    return {
      innerRef: n,
      draggableProps: {
        "data-rfd-draggable-context-id": s,
        "data-rfd-draggable-id": u,
        style: C,
        onTransitionEnd: _
      },
      dragHandleProps: b
    };
  }, [s, b, u, m, x, n]), S = rn(() => ({
    draggableId: l.id,
    type: l.type,
    source: {
      index: l.index,
      droppableId: l.droppableId
    }
  }), [l.droppableId, l.id, l.index, l.type]);
  return B.createElement(B.Fragment, null, d(w, m.snapshot, S));
};
var uwt = dwt, Pye = (t, e) => t === e, Iye = (t) => {
  const {
    combine: e,
    destination: n
  } = t;
  return n ? n.droppableId : e ? e.droppableId : null;
};
const fwt = (t) => t.combine ? t.combine.draggableId : null, hwt = (t) => t.at && t.at.type === "COMBINE" ? t.at.combine.draggableId : null;
function pwt() {
  const t = cs((s, o) => ({
    x: s,
    y: o
  })), e = cs((s, o, i = null, a = null, c = null) => ({
    isDragging: !0,
    isClone: o,
    isDropAnimating: !!c,
    dropAnimation: c,
    mode: s,
    draggingOver: i,
    combineWith: a,
    combineTargetFor: null
  })), n = cs((s, o, i, a, c = null, l = null, d = null) => ({
    mapped: {
      type: "DRAGGING",
      dropping: null,
      draggingOver: c,
      combineWith: l,
      mode: o,
      offset: s,
      dimension: i,
      forceShouldAnimate: d,
      snapshot: e(o, a, c, l, null)
    }
  }));
  return (s, o) => {
    if (e0(s)) {
      if (s.critical.draggable.id !== o.draggableId)
        return null;
      const i = s.current.client.offset, a = s.dimensions.draggables[o.draggableId], c = xa(s.impact), l = hwt(s.impact), d = s.forceShouldAnimate;
      return n(t(i.x, i.y), s.movementMode, a, o.isClone, c, l, d);
    }
    if (s.phase === "DROP_ANIMATING") {
      const i = s.completed;
      if (i.result.draggableId !== o.draggableId)
        return null;
      const a = o.isClone, c = s.dimensions.draggables[o.draggableId], l = i.result, d = l.mode, u = Iye(l), f = fwt(l), g = {
        duration: s.dropDuration,
        curve: cB.drop,
        moveTo: s.newHomeClientOffset,
        opacity: f ? Zw.opacity.drop : null,
        scale: f ? Zw.scale.drop : null
      };
      return {
        mapped: {
          type: "DRAGGING",
          offset: s.newHomeClientOffset,
          dimension: c,
          dropping: g,
          draggingOver: u,
          combineWith: f,
          mode: d,
          forceShouldAnimate: null,
          snapshot: e(d, a, u, f, g)
        }
      };
    }
    return null;
  };
}
function kye(t = null) {
  return {
    isDragging: !1,
    isDropAnimating: !1,
    isClone: !1,
    dropAnimation: null,
    mode: null,
    draggingOver: null,
    combineTargetFor: t,
    combineWith: null
  };
}
const gwt = {
  mapped: {
    type: "SECONDARY",
    offset: Ls,
    combineTargetFor: null,
    shouldAnimateDisplacement: !0,
    snapshot: kye(null)
  }
};
function mwt() {
  const t = cs((i, a) => ({
    x: i,
    y: a
  })), e = cs(kye), n = cs((i, a = null, c) => ({
    mapped: {
      type: "SECONDARY",
      offset: i,
      combineTargetFor: a,
      shouldAnimateDisplacement: c,
      snapshot: e(a)
    }
  })), r = (i) => i ? n(Ls, i, !0) : null, s = (i, a, c, l) => {
    const d = c.displaced.visible[i], u = !!(l.inVirtualList && l.effected[i]), f = oA(c), p = f && f.draggableId === i ? a : null;
    if (!d) {
      if (!u)
        return r(p);
      if (c.displaced.invisible[i])
        return null;
      const m = xv(l.displacedBy.point), v = t(m.x, m.y);
      return n(v, p, !0);
    }
    if (u)
      return r(p);
    const g = c.displacedBy.point, y = t(g.x, g.y);
    return n(y, p, d.shouldAnimate);
  };
  return (i, a) => {
    if (e0(i))
      return i.critical.draggable.id === a.draggableId ? null : s(a.draggableId, i.critical.draggable.id, i.impact, i.afterCritical);
    if (i.phase === "DROP_ANIMATING") {
      const c = i.completed;
      return c.result.draggableId === a.draggableId ? null : s(a.draggableId, c.result.draggableId, c.impact, c.afterCritical);
    }
    return null;
  };
}
const ywt = () => {
  const t = pwt(), e = mwt();
  return (r, s) => t(r, s) || e(r, s) || gwt;
}, vwt = {
  dropAnimationFinished: oye
}, bwt = Ame(ywt, vwt, null, {
  context: hB,
  areStatePropsEqual: Pye
})(uwt);
var xwt = bwt;
function Aye(t) {
  return gP(vB).isUsingCloneFor === t.draggableId && !t.isClone ? null : B.createElement(xwt, t);
}
function wwt(t) {
  const e = typeof t.isDragDisabled == "boolean" ? !t.isDragDisabled : !0, n = !!t.disableInteractiveElementBlocking, r = !!t.shouldRespectForcePress;
  return B.createElement(Aye, Rn({}, t, {
    isClone: !1,
    isEnabled: e,
    canDragInteractiveElements: n,
    shouldRespectForcePress: r
  }));
}
const bB = (t) => (e) => t === e, Swt = bB("scroll"), Cwt = bB("auto"), _wt = bB("visible"), FK = (t, e) => e(t.overflowX) || e(t.overflowY), Ewt = (t, e) => e(t.overflowX) && e(t.overflowY), Mye = (t) => {
  const e = window.getComputedStyle(t), n = {
    overflowX: e.overflowX,
    overflowY: e.overflowY
  };
  return FK(n, Swt) || FK(n, Cwt);
}, Twt = () => {
  if (process.env.NODE_ENV === "production")
    return !1;
  const t = Jw(), e = document.documentElement;
  if (e || (process.env.NODE_ENV, te()), !Mye(t))
    return !1;
  const n = window.getComputedStyle(e), r = {
    overflowX: n.overflowX,
    overflowY: n.overflowY
  };
  return Ewt(r, _wt) || process.env.NODE_ENV !== "production" && Vn(`
    We have detected that your <body> element might be a scroll container.
    We have found no reliable way of detecting whether the <body> element is a scroll container.
    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)

    Because we cannot determine if the <body> is a scroll container, and generally it is not one,
    we will be treating the <body> as *not* a scroll container

    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md
  `), !1;
}, xB = (t) => t == null ? null : t === document.body ? Twt() ? t : null : t === document.documentElement ? null : Mye(t) ? t : xB(t.parentElement);
var Pwt = (t) => {
  !t || !xB(t.parentElement) || process.env.NODE_ENV !== "production" && Vn(`
    Droppable: unsupported nested scroll container detected.
    A Droppable can only have one scroll parent (which can be itself)
    Nested scroll containers are currently not supported.

    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131
  `);
}, l$ = (t) => ({
  x: t.scrollLeft,
  y: t.scrollTop
});
const Oye = (t) => t ? window.getComputedStyle(t).position === "fixed" ? !0 : Oye(t.parentElement) : !1;
var Iwt = (t) => {
  const e = xB(t), n = Oye(t);
  return {
    closestScrollable: e,
    isFixedOnPage: n
  };
}, kwt = ({
  descriptor: t,
  isEnabled: e,
  isCombineEnabled: n,
  isFixedOnPage: r,
  direction: s,
  client: o,
  page: i,
  closest: a
}) => {
  const c = (() => {
    if (!a)
      return null;
    const {
      scrollSize: f,
      client: p
    } = a, g = lye({
      scrollHeight: f.scrollHeight,
      scrollWidth: f.scrollWidth,
      height: p.paddingBox.height,
      width: p.paddingBox.width
    });
    return {
      pageMarginBox: a.page.marginBox,
      frameClient: p,
      scrollSize: f,
      shouldClipSubject: a.shouldClipSubject,
      scroll: {
        initial: a.scroll,
        current: a.scroll,
        max: g,
        diff: {
          value: Ls,
          displacement: Ls
        }
      }
    };
  })(), l = s === "vertical" ? tB : Ume, d = My({
    page: i,
    withPlaceholder: null,
    axis: l,
    frame: c
  });
  return {
    descriptor: t,
    isCombineEnabled: n,
    isFixedOnPage: r,
    axis: l,
    isEnabled: e,
    client: o,
    page: i,
    frame: c,
    subject: d
  };
};
const Awt = (t, e) => {
  const n = Dme(t);
  if (!e || t !== e)
    return n;
  const r = n.paddingBox.top - e.scrollTop, s = n.paddingBox.left - e.scrollLeft, o = r + e.scrollHeight, i = s + e.scrollWidth, c = Z4({
    top: r,
    right: i,
    bottom: o,
    left: s
  }, n.border);
  return Q4({
    borderBox: c,
    margin: n.margin,
    border: n.border,
    padding: n.padding
  });
};
var Mwt = ({
  ref: t,
  descriptor: e,
  env: n,
  windowScroll: r,
  direction: s,
  isDropDisabled: o,
  isCombineEnabled: i,
  shouldClipSubject: a
}) => {
  const c = n.closestScrollable, l = Awt(t, c), d = fP(l, r), u = (() => {
    if (!c)
      return null;
    const p = Dme(c), g = {
      scrollHeight: c.scrollHeight,
      scrollWidth: c.scrollWidth
    };
    return {
      client: p,
      page: fP(p, r),
      scroll: l$(c),
      scrollSize: g,
      shouldClipSubject: a
    };
  })();
  return kwt({
    descriptor: e,
    isEnabled: !o,
    isCombineEnabled: i,
    isFixedOnPage: n.isFixedOnPage,
    direction: s,
    client: l,
    page: d,
    closest: u
  });
};
const Owt = {
  passive: !1
}, Dwt = {
  passive: !0
};
var BK = (t) => t.shouldPublishImmediately ? Owt : Dwt;
const EC = (t) => t && t.env.closestScrollable || null;
function Nwt(t) {
  const e = fe(null), n = gP(cA), r = pB("droppable"), {
    registry: s,
    marshal: o
  } = n, i = mB(t), a = rn(() => ({
    id: t.droppableId,
    type: t.type,
    mode: t.mode
  }), [t.droppableId, t.mode, t.type]), c = fe(a), l = rn(() => cs((w, S) => {
    e.current || (process.env.NODE_ENV !== "production" ? te(!1, "Can only update scroll when dragging") : te());
    const C = {
      x: w,
      y: S
    };
    o.updateDroppableScroll(a.id, C);
  }), [a.id, o]), d = at(() => {
    const w = e.current;
    return !w || !w.env.closestScrollable ? Ls : l$(w.env.closestScrollable);
  }, []), u = at(() => {
    const w = d();
    l(w.x, w.y);
  }, [d, l]), f = rn(() => Kw(u), [u]), p = at(() => {
    const w = e.current, S = EC(w);
    if (w && S || (process.env.NODE_ENV !== "production" ? te(!1, "Could not find scroll options while scrolling") : te()), w.scrollOptions.shouldPublishImmediately) {
      u();
      return;
    }
    f();
  }, [f, u]), g = at((w, S) => {
    e.current && (process.env.NODE_ENV !== "production" ? te(!1, "Cannot collect a droppable while a drag is occurring") : te());
    const C = i.current, _ = C.getDroppableRef();
    _ || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot collect without a droppable ref") : te());
    const E = Iwt(_), M = {
      ref: _,
      descriptor: a,
      env: E,
      scrollOptions: S
    };
    e.current = M;
    const N = Mwt({
      ref: _,
      descriptor: a,
      env: E,
      windowScroll: w,
      direction: C.direction,
      isDropDisabled: C.isDropDisabled,
      isCombineEnabled: C.isCombineEnabled,
      shouldClipSubject: !C.ignoreContainerClipping
    }), O = E.closestScrollable;
    return O && (O.setAttribute(DK.contextId, n.contextId), O.addEventListener("scroll", p, BK(M.scrollOptions)), process.env.NODE_ENV !== "production" && Pwt(O)), N;
  }, [n.contextId, a, p, i]), y = at(() => {
    const w = e.current, S = EC(w);
    return w && S || (process.env.NODE_ENV !== "production" ? te(!1, "Can only recollect Droppable client for Droppables that have a scroll container") : te()), l$(S);
  }, []), m = at(() => {
    const w = e.current;
    w || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot stop drag when no active drag") : te());
    const S = EC(w);
    e.current = null, S && (f.cancel(), S.removeAttribute(DK.contextId), S.removeEventListener("scroll", p, BK(w.scrollOptions)));
  }, [p, f]), v = at((w) => {
    const S = e.current;
    S || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot scroll when there is no drag") : te());
    const C = EC(S);
    C || (process.env.NODE_ENV !== "production" ? te(!1, "Cannot scroll a droppable with no closest scrollable") : te()), C.scrollTop += w.y, C.scrollLeft += w.x;
  }, []), b = rn(() => ({
    getDimensionAndWatchScroll: g,
    getScrollWhileDragging: y,
    dragStopped: m,
    scroll: v
  }), [m, g, y, v]), x = rn(() => ({
    uniqueId: r,
    descriptor: a,
    callbacks: b
  }), [b, a, r]);
  wa(() => (c.current = x.descriptor, s.droppable.register(x), () => {
    e.current && (process.env.NODE_ENV !== "production" && Vn("Unsupported: changing the droppableId or type of a Droppable during a drag"), m()), s.droppable.unregister(x);
  }), [b, a, m, x, o, s.droppable]), wa(() => {
    e.current && o.updateDroppableIsEnabled(c.current.id, !t.isDropDisabled);
  }, [t.isDropDisabled, o]), wa(() => {
    e.current && o.updateDroppableIsCombineEnabled(c.current.id, t.isCombineEnabled);
  }, [t.isCombineEnabled, o]);
}
function k2() {
}
const zK = {
  width: 0,
  height: 0,
  margin: hyt
}, jwt = ({
  isAnimatingOpenOnMount: t,
  placeholder: e,
  animate: n
}) => t || n === "close" ? zK : {
  height: e.client.borderBox.height,
  width: e.client.borderBox.width,
  margin: e.client.margin
}, Rwt = ({
  isAnimatingOpenOnMount: t,
  placeholder: e,
  animate: n
}) => {
  const r = jwt({
    isAnimatingOpenOnMount: t,
    placeholder: e,
    animate: n
  });
  return {
    display: e.display,
    boxSizing: "border-box",
    width: r.width,
    height: r.height,
    marginTop: r.margin.top,
    marginRight: r.margin.right,
    marginBottom: r.margin.bottom,
    marginLeft: r.margin.left,
    flexShrink: "0",
    flexGrow: "0",
    pointerEvents: "none",
    transition: n !== "none" ? Fx.placeholder : null
  };
}, $wt = (t) => {
  const e = fe(null), n = at(() => {
    e.current && (clearTimeout(e.current), e.current = null);
  }, []), {
    animate: r,
    onTransitionEnd: s,
    onClose: o,
    contextId: i
  } = t, [a, c] = he(t.animate === "open");
  me(() => a ? r !== "open" ? (n(), c(!1), k2) : e.current ? k2 : (e.current = setTimeout(() => {
    e.current = null, c(!1);
  }), n) : k2, [r, a, n]);
  const l = at((u) => {
    u.propertyName === "height" && (s(), r === "close" && o());
  }, [r, o, s]), d = Rwt({
    isAnimatingOpenOnMount: a,
    animate: t.animate,
    placeholder: t.placeholder
  });
  return B.createElement(t.placeholder.tagName, {
    style: d,
    "data-rfd-placeholder-context-id": i,
    onTransitionEnd: l,
    ref: t.innerRef
  });
};
var Lwt = B.memo($wt);
function A2(t) {
  return typeof t == "boolean";
}
function M2(t, e) {
  e.forEach((n) => n(t));
}
const Fwt = [function({
  props: e
}) {
  e.droppableId || (process.env.NODE_ENV !== "production" ? te(!1, "A Droppable requires a droppableId prop") : te()), typeof e.droppableId != "string" && (process.env.NODE_ENV !== "production" ? te(!1, `A Droppable requires a [string] droppableId. Provided: [${typeof e.droppableId}]`) : te());
}, function({
  props: e
}) {
  A2(e.isDropDisabled) || (process.env.NODE_ENV !== "production" ? te(!1, "isDropDisabled must be a boolean") : te()), A2(e.isCombineEnabled) || (process.env.NODE_ENV !== "production" ? te(!1, "isCombineEnabled must be a boolean") : te()), A2(e.ignoreContainerClipping) || (process.env.NODE_ENV !== "production" ? te(!1, "ignoreContainerClipping must be a boolean") : te());
}, function({
  getDroppableRef: e
}) {
  Tye(e());
}], Bwt = [function({
  props: e,
  getPlaceholderRef: n
}) {
  !e.placeholder || n() || process.env.NODE_ENV !== "production" && Vn(`
      Droppable setup issue [droppableId: "${e.droppableId}"]:
      DroppableProvided > placeholder could not be found.

      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.
      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md
    `);
}], zwt = [function({
  props: e
}) {
  e.renderClone || (process.env.NODE_ENV !== "production" ? te(!1, "Must provide a clone render function (renderClone) for virtual lists") : te());
}, function({
  getPlaceholderRef: e
}) {
  e() && (process.env.NODE_ENV !== "production" ? te(!1, "Expected virtual list to not have a placeholder") : te());
}];
function Uwt(t) {
  MS(() => {
    M2(t, Fwt), t.props.mode === "standard" && M2(t, Bwt), t.props.mode === "virtual" && M2(t, zwt);
  });
}
class Hwt extends B.PureComponent {
  constructor(...e) {
    super(...e), this.state = {
      isVisible: !!this.props.on,
      data: this.props.on,
      animate: this.props.shouldAnimate && this.props.on ? "open" : "none"
    }, this.onClose = () => {
      this.state.animate === "close" && this.setState({
        isVisible: !1
      });
    };
  }
  static getDerivedStateFromProps(e, n) {
    return e.shouldAnimate ? e.on ? {
      isVisible: !0,
      data: e.on,
      animate: "open"
    } : n.isVisible ? {
      isVisible: !0,
      data: n.data,
      animate: "close"
    } : {
      isVisible: !1,
      animate: "close",
      data: null
    } : {
      isVisible: !!e.on,
      data: e.on,
      animate: "none"
    };
  }
  render() {
    if (!this.state.isVisible)
      return null;
    const e = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate
    };
    return this.props.children(e);
  }
}
const Vwt = (t) => {
  const e = tn(cA);
  e || (process.env.NODE_ENV !== "production" ? te(!1, "Could not find app context") : te());
  const {
    contextId: n,
    isMovementAllowed: r
  } = e, s = fe(null), o = fe(null), {
    children: i,
    droppableId: a,
    type: c,
    mode: l,
    direction: d,
    ignoreContainerClipping: u,
    isDropDisabled: f,
    isCombineEnabled: p,
    snapshot: g,
    useClone: y,
    updateViewportMaxScroll: m,
    getContainerForClone: v
  } = t, b = at(() => s.current, []), x = at((D = null) => {
    s.current = D;
  }, []), w = at(() => o.current, []), S = at((D = null) => {
    o.current = D;
  }, []);
  Uwt({
    props: t,
    getDroppableRef: b,
    getPlaceholderRef: w
  });
  const C = at(() => {
    r() && m({
      maxScroll: uye()
    });
  }, [r, m]);
  Nwt({
    droppableId: a,
    type: c,
    mode: l,
    direction: d,
    isDropDisabled: f,
    isCombineEnabled: p,
    ignoreContainerClipping: u,
    getDroppableRef: b
  });
  const _ = rn(() => B.createElement(Hwt, {
    on: t.placeholder,
    shouldAnimate: t.shouldAnimatePlaceholder
  }, ({
    onClose: D,
    data: k,
    animate: A
  }) => B.createElement(Lwt, {
    placeholder: k,
    onClose: D,
    innerRef: S,
    animate: A,
    contextId: n,
    onTransitionEnd: C
  })), [n, C, t.placeholder, t.shouldAnimatePlaceholder, S]), E = rn(() => ({
    innerRef: x,
    placeholder: _,
    droppableProps: {
      "data-rfd-droppable-id": a,
      "data-rfd-droppable-context-id": n
    }
  }), [n, a, _, x]), M = y ? y.dragging.draggableId : null, N = rn(() => ({
    droppableId: a,
    type: c,
    isUsingCloneFor: M
  }), [a, M, c]);
  function O() {
    if (!y)
      return null;
    const {
      dragging: D,
      render: k
    } = y, A = B.createElement(Aye, {
      draggableId: D.draggableId,
      index: D.source.index,
      isClone: !0,
      isEnabled: !0,
      shouldRespectForcePress: !1,
      canDragInteractiveElements: !0
    }, (R, j) => k(R, j, D));
    return By.createPortal(A, v());
  }
  return B.createElement(vB.Provider, {
    value: N
  }, i(E, g), O());
};
var Wwt = Vwt;
function Kwt() {
  return document.body || (process.env.NODE_ENV !== "production" ? te(!1, "document.body is not ready") : te()), document.body;
}
const UK = {
  mode: "standard",
  type: "DEFAULT",
  direction: "vertical",
  isDropDisabled: !1,
  isCombineEnabled: !1,
  ignoreContainerClipping: !1,
  renderClone: null,
  getContainerForClone: Kwt
}, Dye = (t) => {
  let e = {
    ...t
  }, n;
  for (n in UK)
    t[n] === void 0 && (e = {
      ...e,
      [n]: UK[n]
    });
  return e;
}, O2 = (t, e) => t === e.droppable.type, HK = (t, e) => e.draggables[t.draggable.id], Gwt = () => {
  const t = {
    placeholder: null,
    shouldAnimatePlaceholder: !0,
    snapshot: {
      isDraggingOver: !1,
      draggingOverWith: null,
      draggingFromThisWith: null,
      isUsingPlaceholder: !1
    },
    useClone: null
  }, e = {
    ...t,
    shouldAnimatePlaceholder: !1
  }, n = cs((o) => ({
    draggableId: o.id,
    type: o.type,
    source: {
      index: o.index,
      droppableId: o.droppableId
    }
  })), r = cs((o, i, a, c, l, d) => {
    const u = l.descriptor.id;
    if (l.descriptor.droppableId === o) {
      const g = d ? {
        render: d,
        dragging: n(l.descriptor)
      } : null, y = {
        isDraggingOver: a,
        draggingOverWith: a ? u : null,
        draggingFromThisWith: u,
        isUsingPlaceholder: !0
      };
      return {
        placeholder: l.placeholder,
        shouldAnimatePlaceholder: !1,
        snapshot: y,
        useClone: g
      };
    }
    if (!i)
      return e;
    if (!c)
      return t;
    const p = {
      isDraggingOver: a,
      draggingOverWith: u,
      draggingFromThisWith: null,
      isUsingPlaceholder: !0
    };
    return {
      placeholder: l.placeholder,
      shouldAnimatePlaceholder: !0,
      snapshot: p,
      useClone: null
    };
  });
  return (o, i) => {
    const a = Dye(i), c = a.droppableId, l = a.type, d = !a.isDropDisabled, u = a.renderClone;
    if (e0(o)) {
      const f = o.critical;
      if (!O2(l, f))
        return e;
      const p = HK(f, o.dimensions), g = xa(o.impact) === c;
      return r(c, d, g, g, p, u);
    }
    if (o.phase === "DROP_ANIMATING") {
      const f = o.completed;
      if (!O2(l, f.critical))
        return e;
      const p = HK(f.critical, o.dimensions);
      return r(c, d, Iye(f.result) === c, xa(f.impact) === c, p, u);
    }
    if (o.phase === "IDLE" && o.completed && !o.shouldFlush) {
      const f = o.completed;
      if (!O2(l, f.critical))
        return e;
      const p = xa(f.impact) === c, g = !!(f.impact.at && f.impact.at.type === "COMBINE"), y = f.critical.droppable.id === c;
      return p ? g ? t : e : y ? t : e;
    }
    return e;
  };
}, Ywt = {
  updateViewportMaxScroll: Tvt
}, qwt = Ame(Gwt, Ywt, (t, e, n) => ({
  ...Dye(n),
  ...t,
  ...e
}), {
  context: hB,
  areStatePropsEqual: Pye
})(Wwt);
var Xwt = qwt;
function Zwt({ card: t, index: e, onCardClick: n, onDelete: r }) {
  var l, d, u;
  const s = ((l = t.todos) == null ? void 0 : l.filter((f) => f.completed).length) || 0, o = ((d = t.todos) == null ? void 0 : d.length) || 0, i = ((u = t.comments) == null ? void 0 : u.length) || 0, a = t.labels && t.labels.length > 0, c = !!t.dueDate;
  return /* @__PURE__ */ h.jsx(wwt, { draggableId: t.id, index: e, children: (f) => /* @__PURE__ */ h.jsxs(
    "div",
    {
      ref: f.innerRef,
      ...f.draggableProps,
      ...f.dragHandleProps,
      className: "mb-2 p-3 bg-muted rounded-md group cursor-pointer hover:ring-2 hover:ring-primary/20 transition-all",
      onClick: () => n(t),
      children: [
        a && /* @__PURE__ */ h.jsx("div", { className: "flex flex-wrap gap-1 mb-2", children: t.labels.map((p) => /* @__PURE__ */ h.jsx(
          "span",
          {
            className: "h-2 w-8 rounded-full",
            style: { backgroundColor: p.color },
            title: p.name
          },
          p.id
        )) }),
        /* @__PURE__ */ h.jsxs("div", { className: "flex items-start justify-between gap-2", children: [
          /* @__PURE__ */ h.jsx("span", { className: "text-sm font-medium", children: t.title }),
          /* @__PURE__ */ h.jsx(
            _t,
            {
              variant: "ghost",
              size: "icon",
              className: "h-6 w-6 opacity-0 group-hover:opacity-100 transition-opacity shrink-0",
              onClick: (p) => {
                p.stopPropagation(), r();
              },
              children: /* @__PURE__ */ h.jsx(Ky, { className: "h-3 w-3" })
            }
          )
        ] }),
        (c || o > 0 || i > 0) && /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-3 mt-2 text-xs text-muted-foreground", children: [
          c && /* @__PURE__ */ h.jsxs("span", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ h.jsx(mp, { className: "h-3 w-3" }),
            Rr(new Date(t.dueDate), "MMM d")
          ] }),
          o > 0 && /* @__PURE__ */ h.jsxs("span", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ h.jsx(Yq, { className: "h-3 w-3" }),
            s,
            "/",
            o
          ] }),
          i > 0 && /* @__PURE__ */ h.jsxs("span", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ h.jsx(zq, { className: "h-3 w-3" }),
            i
          ] })
        ] })
      ]
    }
  ) });
}
function Qwt({ column: t, onAddCard: e, onCardClick: n, onDeleteCard: r }) {
  const [s, o] = he(""), i = () => {
    const a = s.trim();
    a && (e(t.id, a), o(""));
  };
  return /* @__PURE__ */ h.jsx("div", { className: "w-72 flex-shrink-0", children: /* @__PURE__ */ h.jsxs(uI, { className: "h-full flex flex-col", children: [
    /* @__PURE__ */ h.jsx(BL, { className: "pb-2", children: /* @__PURE__ */ h.jsx(zL, { className: "text-sm font-medium", children: t.title }) }),
    /* @__PURE__ */ h.jsxs(UL, { className: "flex-1 flex flex-col gap-2", children: [
      /* @__PURE__ */ h.jsx(Xwt, { droppableId: t.id, children: (a) => /* @__PURE__ */ h.jsxs(
        "div",
        {
          ref: a.innerRef,
          ...a.droppableProps,
          className: "flex-1 min-h-[100px]",
          children: [
            t.cards.map((c, l) => /* @__PURE__ */ h.jsx(
              Zwt,
              {
                card: c,
                index: l,
                onCardClick: n,
                onDelete: () => r(t.id, c.id)
              },
              c.id
            )),
            a.placeholder
          ]
        }
      ) }),
      /* @__PURE__ */ h.jsxs("div", { className: "flex gap-2", children: [
        /* @__PURE__ */ h.jsx(
          pa,
          {
            placeholder: "Add a card...",
            value: s,
            onChange: (a) => o(a.target.value),
            onKeyDown: (a) => {
              a.key === "Enter" && i();
            },
            className: "text-sm"
          }
        ),
        /* @__PURE__ */ h.jsx(_t, { size: "icon", variant: "outline", onClick: i, children: /* @__PURE__ */ h.jsx(Jc, { className: "h-4 w-4" }) })
      ] })
    ] })
  ] }) });
}
const dA = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  "textarea",
  {
    className: Oe(
      "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      t
    ),
    ref: n,
    ...e
  }
));
dA.displayName = "Textarea";
function Jwt({ description: t, onChange: e }) {
  const [n, r] = he(!1), [s, o] = he(t || ""), i = () => {
    e(s), r(!1);
  }, a = () => {
    o(t || ""), r(!1);
  };
  return /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 text-sm font-medium text-muted-foreground", children: [
      /* @__PURE__ */ h.jsx(yp, { className: "h-4 w-4" }),
      "Description"
    ] }),
    n ? /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ h.jsx(
        dA,
        {
          value: s,
          onChange: (c) => o(c.target.value),
          placeholder: "Add a more detailed description...",
          className: "min-h-[100px]",
          autoFocus: !0
        }
      ),
      /* @__PURE__ */ h.jsxs("div", { className: "flex gap-2", children: [
        /* @__PURE__ */ h.jsx(_t, { size: "sm", onClick: i, children: "Save" }),
        /* @__PURE__ */ h.jsx(_t, { size: "sm", variant: "ghost", onClick: a, children: "Cancel" })
      ] })
    ] }) : /* @__PURE__ */ h.jsx(
      "div",
      {
        className: "p-3 bg-muted rounded-md text-sm cursor-pointer hover:bg-muted/80 min-h-[60px]",
        onClick: () => r(!0),
        children: t || /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Add a more detailed description..." })
      }
    )
  ] });
}
const Nye = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  o5,
  {
    ref: n,
    className: Oe(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      t
    ),
    ...e,
    children: /* @__PURE__ */ h.jsx(rce, { className: Oe("flex items-center justify-center text-current"), children: /* @__PURE__ */ h.jsx(W$, { className: "h-4 w-4" }) })
  }
));
Nye.displayName = o5.displayName;
const jye = T.forwardRef(({ className: t, value: e, ...n }, r) => /* @__PURE__ */ h.jsx(
  kle,
  {
    ref: r,
    className: Oe("relative h-4 w-full overflow-hidden rounded-full bg-secondary", t),
    ...n,
    children: /* @__PURE__ */ h.jsx(
      Sqe,
      {
        className: "h-full w-full flex-1 bg-primary transition-all",
        style: { transform: `translateX(-${100 - (e || 0)}%)` }
      }
    )
  }
));
jye.displayName = kle.displayName;
function e0t({ todos: t, onChange: e }) {
  const [n, r] = he(""), s = t.filter((l) => l.completed).length, o = t.length > 0 ? s / t.length * 100 : 0, i = () => {
    const l = n.trim();
    if (!l) return;
    const d = {
      id: `todo-${Date.now()}`,
      text: l,
      completed: !1
    };
    e([...t, d]), r("");
  }, a = (l) => {
    e(
      t.map(
        (d) => d.id === l ? { ...d, completed: !d.completed } : d
      )
    );
  }, c = (l) => {
    e(t.filter((d) => d.id !== l));
  };
  return /* @__PURE__ */ h.jsxs("div", { className: "space-y-3", children: [
    /* @__PURE__ */ h.jsx("div", { className: "flex items-center justify-between", children: /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 text-sm font-medium text-muted-foreground", children: [
      /* @__PURE__ */ h.jsx(Yq, { className: "h-4 w-4" }),
      "Checklist",
      t.length > 0 && /* @__PURE__ */ h.jsxs("span", { className: "text-xs", children: [
        "(",
        s,
        "/",
        t.length,
        ")"
      ] })
    ] }) }),
    t.length > 0 && /* @__PURE__ */ h.jsx(jye, { value: o, className: "h-2" }),
    /* @__PURE__ */ h.jsx("div", { className: "space-y-1", children: t.map((l) => /* @__PURE__ */ h.jsxs(
      "div",
      {
        className: "flex items-center gap-2 p-2 rounded-md hover:bg-muted/50 group",
        children: [
          /* @__PURE__ */ h.jsx(
            Nye,
            {
              checked: l.completed,
              onCheckedChange: () => a(l.id)
            }
          ),
          /* @__PURE__ */ h.jsx(
            "span",
            {
              className: `flex-1 text-sm ${l.completed ? "line-through text-muted-foreground" : ""}`,
              children: l.text
            }
          ),
          /* @__PURE__ */ h.jsx(
            _t,
            {
              variant: "ghost",
              size: "icon",
              className: "h-6 w-6 opacity-0 group-hover:opacity-100",
              onClick: () => c(l.id),
              children: /* @__PURE__ */ h.jsx(Ky, { className: "h-3 w-3" })
            }
          )
        ]
      },
      l.id
    )) }),
    /* @__PURE__ */ h.jsxs("div", { className: "flex gap-2", children: [
      /* @__PURE__ */ h.jsx(
        pa,
        {
          placeholder: "Add an item...",
          value: n,
          onChange: (l) => r(l.target.value),
          onKeyDown: (l) => {
            l.key === "Enter" && i();
          },
          className: "text-sm"
        }
      ),
      /* @__PURE__ */ h.jsx(_t, { size: "icon", variant: "outline", onClick: i, children: /* @__PURE__ */ h.jsx(Jc, { className: "h-4 w-4" }) })
    ] })
  ] });
}
function t0t({ comments: t, onChange: e }) {
  const [n, r] = he(""), s = () => {
    const i = n.trim();
    if (!i) return;
    const a = {
      id: `comment-${Date.now()}`,
      text: i,
      authorName: "You",
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    e([a, ...t]), r("");
  }, o = (i) => {
    e(t.filter((a) => a.id !== i));
  };
  return /* @__PURE__ */ h.jsxs("div", { className: "space-y-3", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 text-sm font-medium text-muted-foreground", children: [
      /* @__PURE__ */ h.jsx(zq, { className: "h-4 w-4" }),
      "Comments"
    ] }),
    /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ h.jsx(
        dA,
        {
          placeholder: "Write a comment...",
          value: n,
          onChange: (i) => r(i.target.value),
          className: "min-h-[60px]"
        }
      ),
      /* @__PURE__ */ h.jsx(_t, { size: "sm", onClick: s, disabled: !n.trim(), children: "Add Comment" })
    ] }),
    t.length > 0 && /* @__PURE__ */ h.jsx("div", { className: "space-y-3 pt-2", children: t.map((i) => /* @__PURE__ */ h.jsxs("div", { className: "group", children: [
      /* @__PURE__ */ h.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx("span", { className: "text-sm font-medium", children: i.authorName }),
          /* @__PURE__ */ h.jsx("span", { className: "text-xs text-muted-foreground", children: Qx(i.createdAt) })
        ] }),
        /* @__PURE__ */ h.jsx(
          _t,
          {
            variant: "ghost",
            size: "icon",
            className: "h-6 w-6 opacity-0 group-hover:opacity-100",
            onClick: () => o(i.id),
            children: /* @__PURE__ */ h.jsx(Ky, { className: "h-3 w-3" })
          }
        )
      ] }),
      /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground mt-1 pl-0", children: i.text })
    ] }, i.id)) })
  ] });
}
const n0t = [
  { id: "bug", name: "Bug", color: "hsl(0, 84%, 60%)" },
  { id: "feature", name: "Feature", color: "hsl(142, 76%, 36%)" },
  { id: "urgent", name: "Urgent", color: "hsl(25, 95%, 53%)" },
  { id: "blocked", name: "Blocked", color: "hsl(262, 83%, 58%)" },
  { id: "review", name: "Review", color: "hsl(199, 89%, 48%)" }
];
function r0t(t) {
  const e = (/* @__PURE__ */ new Date()).toISOString();
  return {
    id: t.id,
    title: t.title || t.content || "Untitled",
    description: t.description,
    todos: t.todos || [],
    comments: t.comments || [],
    labels: t.labels || [],
    dueDate: t.dueDate,
    createdAt: t.createdAt || e,
    updatedAt: t.updatedAt || e
  };
}
function s0t({ labels: t, onChange: e }) {
  const n = (o) => t.some((i) => i.id === o), r = (o) => {
    n(o.id) ? e(t.filter((i) => i.id !== o.id)) : e([...t, o]);
  }, s = (o) => {
    e(t.filter((i) => i.id !== o));
  };
  return /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 text-sm font-medium text-muted-foreground", children: [
      /* @__PURE__ */ h.jsx(E0, { className: "h-4 w-4" }),
      "Labels"
    ] }),
    /* @__PURE__ */ h.jsxs("div", { className: "flex flex-wrap items-center gap-2", children: [
      t.map((o) => /* @__PURE__ */ h.jsxs(
        "span",
        {
          className: "inline-flex items-center gap-1 px-2 py-1 rounded text-xs font-medium text-white",
          style: { backgroundColor: o.color },
          children: [
            o.name,
            /* @__PURE__ */ h.jsx(
              "button",
              {
                className: "hover:bg-white/20 rounded",
                onClick: () => s(o.id),
                children: /* @__PURE__ */ h.jsx(rg, { className: "h-3 w-3" })
              }
            )
          ]
        },
        o.id
      )),
      /* @__PURE__ */ h.jsxs(Jx, { children: [
        /* @__PURE__ */ h.jsx(ew, { asChild: !0, children: /* @__PURE__ */ h.jsx(_t, { variant: "outline", size: "sm", className: "h-7", children: "+ Add Label" }) }),
        /* @__PURE__ */ h.jsx(ty, { className: "w-48 p-2", align: "start", children: /* @__PURE__ */ h.jsx("div", { className: "space-y-1", children: n0t.map((o) => /* @__PURE__ */ h.jsxs(
          "button",
          {
            className: `w-full flex items-center gap-2 p-2 rounded text-sm hover:bg-muted ${n(o.id) ? "ring-2 ring-primary" : ""}`,
            onClick: () => r(o),
            children: [
              /* @__PURE__ */ h.jsx(
                "span",
                {
                  className: "h-4 w-4 rounded",
                  style: { backgroundColor: o.color }
                }
              ),
              o.name
            ]
          },
          o.id
        )) }) })
      ] })
    ] })
  ] });
}
var St = function() {
  return St = Object.assign || function(e) {
    for (var n, r = 1, s = arguments.length; r < s; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, St.apply(this, arguments);
};
function o0t(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, r = Object.getOwnPropertySymbols(t); s < r.length; s++)
      e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[s]) && (n[r[s]] = t[r[s]]);
  return n;
}
function Rye(t, e, n) {
  for (var r = 0, s = e.length, o; r < s; r++)
    (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}
function OS(t) {
  return t.mode === "multiple";
}
function DS(t) {
  return t.mode === "range";
}
function uA(t) {
  return t.mode === "single";
}
var i0t = {
  root: "rdp",
  multiple_months: "rdp-multiple_months",
  with_weeknumber: "rdp-with_weeknumber",
  vhidden: "rdp-vhidden",
  button_reset: "rdp-button_reset",
  button: "rdp-button",
  caption: "rdp-caption",
  caption_start: "rdp-caption_start",
  caption_end: "rdp-caption_end",
  caption_between: "rdp-caption_between",
  caption_label: "rdp-caption_label",
  caption_dropdowns: "rdp-caption_dropdowns",
  dropdown: "rdp-dropdown",
  dropdown_month: "rdp-dropdown_month",
  dropdown_year: "rdp-dropdown_year",
  dropdown_icon: "rdp-dropdown_icon",
  months: "rdp-months",
  month: "rdp-month",
  table: "rdp-table",
  tbody: "rdp-tbody",
  tfoot: "rdp-tfoot",
  head: "rdp-head",
  head_row: "rdp-head_row",
  head_cell: "rdp-head_cell",
  nav: "rdp-nav",
  nav_button: "rdp-nav_button",
  nav_button_previous: "rdp-nav_button_previous",
  nav_button_next: "rdp-nav_button_next",
  nav_icon: "rdp-nav_icon",
  row: "rdp-row",
  weeknumber: "rdp-weeknumber",
  cell: "rdp-cell",
  day: "rdp-day",
  day_today: "rdp-day_today",
  day_outside: "rdp-day_outside",
  day_selected: "rdp-day_selected",
  day_disabled: "rdp-day_disabled",
  day_hidden: "rdp-day_hidden",
  day_range_start: "rdp-day_range_start",
  day_range_end: "rdp-day_range_end",
  day_range_middle: "rdp-day_range_middle"
};
function a0t(t, e) {
  return Rr(t, "LLLL y", e);
}
function c0t(t, e) {
  return Rr(t, "d", e);
}
function l0t(t, e) {
  return Rr(t, "LLLL", e);
}
function d0t(t) {
  return "".concat(t);
}
function u0t(t, e) {
  return Rr(t, "cccccc", e);
}
function f0t(t, e) {
  return Rr(t, "yyyy", e);
}
var h0t = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  formatCaption: a0t,
  formatDay: c0t,
  formatMonthCaption: l0t,
  formatWeekNumber: d0t,
  formatWeekdayName: u0t,
  formatYearCaption: f0t
}), p0t = function(t, e, n) {
  return Rr(t, "do MMMM (EEEE)", n);
}, g0t = function() {
  return "Month: ";
}, m0t = function() {
  return "Go to next month";
}, y0t = function() {
  return "Go to previous month";
}, v0t = function(t, e) {
  return Rr(t, "cccc", e);
}, b0t = function(t) {
  return "Week n. ".concat(t);
}, x0t = function() {
  return "Year: ";
}, w0t = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  labelDay: p0t,
  labelMonthDropdown: g0t,
  labelNext: m0t,
  labelPrevious: y0t,
  labelWeekNumber: b0t,
  labelWeekday: v0t,
  labelYearDropdown: x0t
});
function S0t() {
  var t = "buttons", e = i0t, n = F0, r = {}, s = {}, o = 1, i = {}, a = /* @__PURE__ */ new Date();
  return {
    captionLayout: t,
    classNames: e,
    formatters: h0t,
    labels: w0t,
    locale: n,
    modifiersClassNames: r,
    modifiers: s,
    numberOfMonths: o,
    styles: i,
    today: a,
    mode: "default"
  };
}
function C0t(t) {
  var e = t.fromYear, n = t.toYear, r = t.fromMonth, s = t.toMonth, o = t.fromDate, i = t.toDate;
  return r ? o = ii(r) : e && (o = new Date(e, 0, 1)), s ? i = L0(s) : n && (i = new Date(n, 11, 31)), {
    fromDate: o ? ny(o) : void 0,
    toDate: i ? ny(i) : void 0
  };
}
var $ye = zn(void 0);
function _0t(t) {
  var e, n = t.initialProps, r = S0t(), s = C0t(n), o = s.fromDate, i = s.toDate, a = (e = n.captionLayout) !== null && e !== void 0 ? e : r.captionLayout;
  a !== "buttons" && (!o || !i) && (a = "buttons");
  var c;
  (uA(n) || OS(n) || DS(n)) && (c = n.onSelect);
  var l = St(St(St({}, r), n), { captionLayout: a, classNames: St(St({}, r.classNames), n.classNames), components: St({}, n.components), formatters: St(St({}, r.formatters), n.formatters), fromDate: o, labels: St(St({}, r.labels), n.labels), mode: n.mode || r.mode, modifiers: St(St({}, r.modifiers), n.modifiers), modifiersClassNames: St(St({}, r.modifiersClassNames), n.modifiersClassNames), onSelect: c, styles: St(St({}, r.styles), n.styles), toDate: i });
  return h.jsx($ye.Provider, { value: l, children: t.children });
}
function Wn() {
  var t = tn($ye);
  if (!t)
    throw new Error("useDayPicker must be used within a DayPickerProvider.");
  return t;
}
function Lye(t) {
  var e = Wn(), n = e.locale, r = e.classNames, s = e.styles, o = e.formatters.formatCaption;
  return h.jsx("div", { className: r.caption_label, style: s.caption_label, "aria-live": "polite", role: "presentation", id: t.id, children: o(t.displayMonth, { locale: n }) });
}
function E0t(t) {
  return h.jsx("svg", St({ width: "8px", height: "8px", viewBox: "0 0 120 120", "data-testid": "iconDropdown" }, t, { children: h.jsx("path", { d: "M4.22182541,48.2218254 C8.44222828,44.0014225 15.2388494,43.9273804 19.5496459,47.9996989 L19.7781746,48.2218254 L60,88.443 L100.221825,48.2218254 C104.442228,44.0014225 111.238849,43.9273804 115.549646,47.9996989 L115.778175,48.2218254 C119.998577,52.4422283 120.07262,59.2388494 116.000301,63.5496459 L115.778175,63.7781746 L67.7781746,111.778175 C63.5577717,115.998577 56.7611506,116.07262 52.4503541,112.000301 L52.2218254,111.778175 L4.22182541,63.7781746 C-0.0739418023,59.4824074 -0.0739418023,52.5175926 4.22182541,48.2218254 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function Fye(t) {
  var e, n, r = t.onChange, s = t.value, o = t.children, i = t.caption, a = t.className, c = t.style, l = Wn(), d = (n = (e = l.components) === null || e === void 0 ? void 0 : e.IconDropdown) !== null && n !== void 0 ? n : E0t;
  return h.jsxs("div", { className: a, style: c, children: [h.jsx("span", { className: l.classNames.vhidden, children: t["aria-label"] }), h.jsx("select", { name: t.name, "aria-label": t["aria-label"], className: l.classNames.dropdown, style: l.styles.dropdown, value: s, onChange: r, children: o }), h.jsxs("div", { className: l.classNames.caption_label, style: l.styles.caption_label, "aria-hidden": "true", children: [i, h.jsx(d, { className: l.classNames.dropdown_icon, style: l.styles.dropdown_icon })] })] });
}
function T0t(t) {
  var e, n = Wn(), r = n.fromDate, s = n.toDate, o = n.styles, i = n.locale, a = n.formatters.formatMonthCaption, c = n.classNames, l = n.components, d = n.labels.labelMonthDropdown;
  if (!r)
    return h.jsx(h.Fragment, {});
  if (!s)
    return h.jsx(h.Fragment, {});
  var u = [];
  if (KMe(r, s))
    for (var f = ii(r), p = r.getMonth(); p <= s.getMonth(); p++)
      u.push(pM(f, p));
  else
    for (var f = ii(/* @__PURE__ */ new Date()), p = 0; p <= 11; p++)
      u.push(pM(f, p));
  var g = function(m) {
    var v = Number(m.target.value), b = pM(ii(t.displayMonth), v);
    t.onChange(b);
  }, y = (e = l == null ? void 0 : l.Dropdown) !== null && e !== void 0 ? e : Fye;
  return h.jsx(y, { name: "months", "aria-label": d(), className: c.dropdown_month, style: o.dropdown_month, onChange: g, value: t.displayMonth.getMonth(), caption: a(t.displayMonth, { locale: i }), children: u.map(function(m) {
    return h.jsx("option", { value: m.getMonth(), children: a(m, { locale: i }) }, m.getMonth());
  }) });
}
function P0t(t) {
  var e, n = t.displayMonth, r = Wn(), s = r.fromDate, o = r.toDate, i = r.locale, a = r.styles, c = r.classNames, l = r.components, d = r.formatters.formatYearCaption, u = r.labels.labelYearDropdown, f = [];
  if (!s)
    return h.jsx(h.Fragment, {});
  if (!o)
    return h.jsx(h.Fragment, {});
  for (var p = s.getFullYear(), g = o.getFullYear(), y = p; y <= g; y++)
    f.push(gU(GL(/* @__PURE__ */ new Date()), y));
  var m = function(b) {
    var x = gU(ii(n), Number(b.target.value));
    t.onChange(x);
  }, v = (e = l == null ? void 0 : l.Dropdown) !== null && e !== void 0 ? e : Fye;
  return h.jsx(v, { name: "years", "aria-label": u(), className: c.dropdown_year, style: a.dropdown_year, onChange: m, value: n.getFullYear(), caption: d(n, { locale: i }), children: f.map(function(b) {
    return h.jsx("option", { value: b.getFullYear(), children: d(b, { locale: i }) }, b.getFullYear());
  }) });
}
function I0t(t, e) {
  var n = he(t), r = n[0], s = n[1], o = e === void 0 ? r : e;
  return [o, s];
}
function k0t(t) {
  var e = t.month, n = t.defaultMonth, r = t.today, s = e || n || r || /* @__PURE__ */ new Date(), o = t.toDate, i = t.fromDate, a = t.numberOfMonths, c = a === void 0 ? 1 : a;
  if (o && ry(o, s) < 0) {
    var l = -1 * (c - 1);
    s = Ca(o, l);
  }
  return i && ry(s, i) < 0 && (s = i), ii(s);
}
function A0t() {
  var t = Wn(), e = k0t(t), n = I0t(e, t.month), r = n[0], s = n[1], o = function(i) {
    var a;
    if (!t.disableNavigation) {
      var c = ii(i);
      s(c), (a = t.onMonthChange) === null || a === void 0 || a.call(t, c);
    }
  };
  return [r, o];
}
function M0t(t, e) {
  for (var n = e.reverseMonths, r = e.numberOfMonths, s = ii(t), o = ii(Ca(s, r)), i = ry(o, s), a = [], c = 0; c < i; c++) {
    var l = Ca(s, c);
    a.push(l);
  }
  return n && (a = a.reverse()), a;
}
function O0t(t, e) {
  if (!e.disableNavigation) {
    var n = e.toDate, r = e.pagedNavigation, s = e.numberOfMonths, o = s === void 0 ? 1 : s, i = r ? o : 1, a = ii(t);
    if (!n)
      return Ca(a, i);
    var c = ry(n, t);
    if (!(c < o))
      return Ca(a, i);
  }
}
function D0t(t, e) {
  if (!e.disableNavigation) {
    var n = e.fromDate, r = e.pagedNavigation, s = e.numberOfMonths, o = s === void 0 ? 1 : s, i = r ? o : 1, a = ii(t);
    if (!n)
      return Ca(a, -i);
    var c = ry(a, n);
    if (!(c <= 0))
      return Ca(a, -i);
  }
}
var Bye = zn(void 0);
function N0t(t) {
  var e = Wn(), n = A0t(), r = n[0], s = n[1], o = M0t(r, e), i = O0t(r, e), a = D0t(r, e), c = function(u) {
    return o.some(function(f) {
      return eF(u, f);
    });
  }, l = function(u, f) {
    c(u) || (f && dJ(u, f) ? s(Ca(u, 1 + e.numberOfMonths * -1)) : s(u));
  }, d = {
    currentMonth: r,
    displayMonths: o,
    goToMonth: s,
    goToDate: l,
    previousMonth: a,
    nextMonth: i,
    isDateDisplayed: c
  };
  return h.jsx(Bye.Provider, { value: d, children: t.children });
}
function NS() {
  var t = tn(Bye);
  if (!t)
    throw new Error("useNavigation must be used within a NavigationProvider");
  return t;
}
function VK(t) {
  var e, n = Wn(), r = n.classNames, s = n.styles, o = n.components, i = NS().goToMonth, a = function(d) {
    i(Ca(d, t.displayIndex ? -t.displayIndex : 0));
  }, c = (e = o == null ? void 0 : o.CaptionLabel) !== null && e !== void 0 ? e : Lye, l = h.jsx(c, { id: t.id, displayMonth: t.displayMonth });
  return h.jsxs("div", { className: r.caption_dropdowns, style: s.caption_dropdowns, children: [h.jsx("div", { className: r.vhidden, children: l }), h.jsx(T0t, { onChange: a, displayMonth: t.displayMonth }), h.jsx(P0t, { onChange: a, displayMonth: t.displayMonth })] });
}
function j0t(t) {
  return h.jsx("svg", St({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, t, { children: h.jsx("path", { d: "M69.490332,3.34314575 C72.6145263,0.218951416 77.6798462,0.218951416 80.8040405,3.34314575 C83.8617626,6.40086786 83.9268205,11.3179931 80.9992143,14.4548388 L80.8040405,14.6568542 L35.461,60 L80.8040405,105.343146 C83.8617626,108.400868 83.9268205,113.317993 80.9992143,116.454839 L80.8040405,116.656854 C77.7463184,119.714576 72.8291931,119.779634 69.6923475,116.852028 L69.490332,116.656854 L18.490332,65.6568542 C15.4326099,62.5991321 15.367552,57.6820069 18.2951583,54.5451612 L18.490332,54.3431458 L69.490332,3.34314575 Z", fill: "currentColor", fillRule: "nonzero" }) }));
}
function R0t(t) {
  return h.jsx("svg", St({ width: "16px", height: "16px", viewBox: "0 0 120 120" }, t, { children: h.jsx("path", { d: "M49.8040405,3.34314575 C46.6798462,0.218951416 41.6145263,0.218951416 38.490332,3.34314575 C35.4326099,6.40086786 35.367552,11.3179931 38.2951583,14.4548388 L38.490332,14.6568542 L83.8333725,60 L38.490332,105.343146 C35.4326099,108.400868 35.367552,113.317993 38.2951583,116.454839 L38.490332,116.656854 C41.5480541,119.714576 46.4651794,119.779634 49.602025,116.852028 L49.8040405,116.656854 L100.804041,65.6568542 C103.861763,62.5991321 103.926821,57.6820069 100.999214,54.5451612 L100.804041,54.3431458 L49.8040405,3.34314575 Z", fill: "currentColor" }) }));
}
var mP = du(function(t, e) {
  var n = Wn(), r = n.classNames, s = n.styles, o = [r.button_reset, r.button];
  t.className && o.push(t.className);
  var i = o.join(" "), a = St(St({}, s.button_reset), s.button);
  return t.style && Object.assign(a, t.style), h.jsx("button", St({}, t, { ref: e, type: "button", className: i, style: a }));
});
function $0t(t) {
  var e, n, r = Wn(), s = r.dir, o = r.locale, i = r.classNames, a = r.styles, c = r.labels, l = c.labelPrevious, d = c.labelNext, u = r.components;
  if (!t.nextMonth && !t.previousMonth)
    return h.jsx(h.Fragment, {});
  var f = l(t.previousMonth, { locale: o }), p = [
    i.nav_button,
    i.nav_button_previous
  ].join(" "), g = d(t.nextMonth, { locale: o }), y = [
    i.nav_button,
    i.nav_button_next
  ].join(" "), m = (e = u == null ? void 0 : u.IconRight) !== null && e !== void 0 ? e : R0t, v = (n = u == null ? void 0 : u.IconLeft) !== null && n !== void 0 ? n : j0t;
  return h.jsxs("div", { className: i.nav, style: a.nav, children: [!t.hidePrevious && h.jsx(mP, { name: "previous-month", "aria-label": f, className: p, style: a.nav_button_previous, disabled: !t.previousMonth, onClick: t.onPreviousClick, children: s === "rtl" ? h.jsx(m, { className: i.nav_icon, style: a.nav_icon }) : h.jsx(v, { className: i.nav_icon, style: a.nav_icon }) }), !t.hideNext && h.jsx(mP, { name: "next-month", "aria-label": g, className: y, style: a.nav_button_next, disabled: !t.nextMonth, onClick: t.onNextClick, children: s === "rtl" ? h.jsx(v, { className: i.nav_icon, style: a.nav_icon }) : h.jsx(m, { className: i.nav_icon, style: a.nav_icon }) })] });
}
function WK(t) {
  var e = Wn().numberOfMonths, n = NS(), r = n.previousMonth, s = n.nextMonth, o = n.goToMonth, i = n.displayMonths, a = i.findIndex(function(g) {
    return eF(t.displayMonth, g);
  }), c = a === 0, l = a === i.length - 1, d = e > 1 && (c || !l), u = e > 1 && (l || !c), f = function() {
    r && o(r);
  }, p = function() {
    s && o(s);
  };
  return h.jsx($0t, { displayMonth: t.displayMonth, hideNext: d, hidePrevious: u, nextMonth: s, previousMonth: r, onPreviousClick: f, onNextClick: p });
}
function L0t(t) {
  var e, n = Wn(), r = n.classNames, s = n.disableNavigation, o = n.styles, i = n.captionLayout, a = n.components, c = (e = a == null ? void 0 : a.CaptionLabel) !== null && e !== void 0 ? e : Lye, l;
  return s ? l = h.jsx(c, { id: t.id, displayMonth: t.displayMonth }) : i === "dropdown" ? l = h.jsx(VK, { displayMonth: t.displayMonth, id: t.id }) : i === "dropdown-buttons" ? l = h.jsxs(h.Fragment, { children: [h.jsx(VK, { displayMonth: t.displayMonth, displayIndex: t.displayIndex, id: t.id }), h.jsx(WK, { displayMonth: t.displayMonth, displayIndex: t.displayIndex, id: t.id })] }) : l = h.jsxs(h.Fragment, { children: [h.jsx(c, { id: t.id, displayMonth: t.displayMonth, displayIndex: t.displayIndex }), h.jsx(WK, { displayMonth: t.displayMonth, id: t.id })] }), h.jsx("div", { className: r.caption, style: o.caption, children: l });
}
function F0t(t) {
  var e = Wn(), n = e.footer, r = e.styles, s = e.classNames.tfoot;
  return n ? h.jsx("tfoot", { className: s, style: r.tfoot, children: h.jsx("tr", { children: h.jsx("td", { colSpan: 8, children: n }) }) }) : h.jsx(h.Fragment, {});
}
function B0t(t, e, n) {
  for (var r = n ? ru(/* @__PURE__ */ new Date()) : Wi(/* @__PURE__ */ new Date(), { locale: t, weekStartsOn: e }), s = [], o = 0; o < 7; o++) {
    var i = Xs(r, o);
    s.push(i);
  }
  return s;
}
function z0t() {
  var t = Wn(), e = t.classNames, n = t.styles, r = t.showWeekNumber, s = t.locale, o = t.weekStartsOn, i = t.ISOWeek, a = t.formatters.formatWeekdayName, c = t.labels.labelWeekday, l = B0t(s, o, i);
  return h.jsxs("tr", { style: n.head_row, className: e.head_row, children: [r && h.jsx("td", { style: n.head_cell, className: e.head_cell }), l.map(function(d, u) {
    return h.jsx("th", { scope: "col", className: e.head_cell, style: n.head_cell, "aria-label": c(d, { locale: s }), children: a(d, { locale: s }) }, u);
  })] });
}
function U0t() {
  var t, e = Wn(), n = e.classNames, r = e.styles, s = e.components, o = (t = s == null ? void 0 : s.HeadRow) !== null && t !== void 0 ? t : z0t;
  return h.jsx("thead", { style: r.head, className: n.head, children: h.jsx(o, {}) });
}
function H0t(t) {
  var e = Wn(), n = e.locale, r = e.formatters.formatDay;
  return h.jsx(h.Fragment, { children: r(t.date, { locale: n }) });
}
var wB = zn(void 0);
function V0t(t) {
  if (!OS(t.initialProps)) {
    var e = {
      selected: void 0,
      modifiers: {
        disabled: []
      }
    };
    return h.jsx(wB.Provider, { value: e, children: t.children });
  }
  return h.jsx(W0t, { initialProps: t.initialProps, children: t.children });
}
function W0t(t) {
  var e = t.initialProps, n = t.children, r = e.selected, s = e.min, o = e.max, i = function(l, d, u) {
    var f, p;
    (f = e.onDayClick) === null || f === void 0 || f.call(e, l, d, u);
    var g = !!(d.selected && s && (r == null ? void 0 : r.length) === s);
    if (!g) {
      var y = !!(!d.selected && o && (r == null ? void 0 : r.length) === o);
      if (!y) {
        var m = r ? Rye([], r) : [];
        if (d.selected) {
          var v = m.findIndex(function(b) {
            return Ao(l, b);
          });
          m.splice(v, 1);
        } else
          m.push(l);
        (p = e.onSelect) === null || p === void 0 || p.call(e, m, l, d, u);
      }
    }
  }, a = {
    disabled: []
  };
  r && a.disabled.push(function(l) {
    var d = o && r.length > o - 1, u = r.some(function(f) {
      return Ao(f, l);
    });
    return !!(d && !u);
  });
  var c = {
    selected: r,
    onDayClick: i,
    modifiers: a
  };
  return h.jsx(wB.Provider, { value: c, children: n });
}
function SB() {
  var t = tn(wB);
  if (!t)
    throw new Error("useSelectMultiple must be used within a SelectMultipleProvider");
  return t;
}
function K0t(t, e) {
  var n = e || {}, r = n.from, s = n.to;
  return r && s ? Ao(s, t) && Ao(r, t) ? void 0 : Ao(s, t) ? { from: s, to: void 0 } : Ao(r, t) ? void 0 : ON(r, t) ? { from: t, to: s } : { from: r, to: t } : s ? ON(t, s) ? { from: s, to: t } : { from: t, to: s } : r ? dJ(t, r) ? { from: t, to: r } : { from: r, to: t } : { from: t, to: void 0 };
}
var CB = zn(void 0);
function G0t(t) {
  if (!DS(t.initialProps)) {
    var e = {
      selected: void 0,
      modifiers: {
        range_start: [],
        range_end: [],
        range_middle: [],
        disabled: []
      }
    };
    return h.jsx(CB.Provider, { value: e, children: t.children });
  }
  return h.jsx(Y0t, { initialProps: t.initialProps, children: t.children });
}
function Y0t(t) {
  var e = t.initialProps, n = t.children, r = e.selected, s = r || {}, o = s.from, i = s.to, a = e.min, c = e.max, l = function(p, g, y) {
    var m, v;
    (m = e.onDayClick) === null || m === void 0 || m.call(e, p, g, y);
    var b = K0t(p, r);
    (v = e.onSelect) === null || v === void 0 || v.call(e, b, p, g, y);
  }, d = {
    range_start: [],
    range_end: [],
    range_middle: [],
    disabled: []
  };
  if (o ? (d.range_start = [o], i ? (d.range_end = [i], Ao(o, i) || (d.range_middle = [
    {
      after: o,
      before: i
    }
  ])) : d.range_end = [o]) : i && (d.range_start = [i], d.range_end = [i]), a && (o && !i && d.disabled.push({
    after: hM(o, a - 1),
    before: Xs(o, a - 1)
  }), o && i && d.disabled.push({
    after: o,
    before: Xs(o, a - 1)
  }), !o && i && d.disabled.push({
    after: hM(i, a - 1),
    before: Xs(i, a - 1)
  })), c) {
    if (o && !i && (d.disabled.push({
      before: Xs(o, -c + 1)
    }), d.disabled.push({
      after: Xs(o, c - 1)
    })), o && i) {
      var u = jl(i, o) + 1, f = c - u;
      d.disabled.push({
        before: hM(o, f)
      }), d.disabled.push({
        after: Xs(i, f)
      });
    }
    !o && i && (d.disabled.push({
      before: Xs(i, -c + 1)
    }), d.disabled.push({
      after: Xs(i, c - 1)
    }));
  }
  return h.jsx(CB.Provider, { value: { selected: r, onDayClick: l, modifiers: d }, children: n });
}
function _B() {
  var t = tn(CB);
  if (!t)
    throw new Error("useSelectRange must be used within a SelectRangeProvider");
  return t;
}
function $_(t) {
  return Array.isArray(t) ? Rye([], t) : t !== void 0 ? [t] : [];
}
function q0t(t) {
  var e = {};
  return Object.entries(t).forEach(function(n) {
    var r = n[0], s = n[1];
    e[r] = $_(s);
  }), e;
}
var al;
(function(t) {
  t.Outside = "outside", t.Disabled = "disabled", t.Selected = "selected", t.Hidden = "hidden", t.Today = "today", t.RangeStart = "range_start", t.RangeEnd = "range_end", t.RangeMiddle = "range_middle";
})(al || (al = {}));
var X0t = al.Selected, Td = al.Disabled, Z0t = al.Hidden, Q0t = al.Today, D2 = al.RangeEnd, N2 = al.RangeMiddle, j2 = al.RangeStart, J0t = al.Outside;
function eSt(t, e, n) {
  var r, s = (r = {}, r[X0t] = $_(t.selected), r[Td] = $_(t.disabled), r[Z0t] = $_(t.hidden), r[Q0t] = [t.today], r[D2] = [], r[N2] = [], r[j2] = [], r[J0t] = [], r);
  return t.fromDate && s[Td].push({ before: t.fromDate }), t.toDate && s[Td].push({ after: t.toDate }), OS(t) ? s[Td] = s[Td].concat(e.modifiers[Td]) : DS(t) && (s[Td] = s[Td].concat(n.modifiers[Td]), s[j2] = n.modifiers[j2], s[N2] = n.modifiers[N2], s[D2] = n.modifiers[D2]), s;
}
var zye = zn(void 0);
function tSt(t) {
  var e = Wn(), n = SB(), r = _B(), s = eSt(e, n, r), o = q0t(e.modifiers), i = St(St({}, s), o);
  return h.jsx(zye.Provider, { value: i, children: t.children });
}
function Uye() {
  var t = tn(zye);
  if (!t)
    throw new Error("useModifiers must be used within a ModifiersProvider");
  return t;
}
function nSt(t) {
  return !!(t && typeof t == "object" && "before" in t && "after" in t);
}
function rSt(t) {
  return !!(t && typeof t == "object" && "from" in t);
}
function sSt(t) {
  return !!(t && typeof t == "object" && "after" in t);
}
function oSt(t) {
  return !!(t && typeof t == "object" && "before" in t);
}
function iSt(t) {
  return !!(t && typeof t == "object" && "dayOfWeek" in t);
}
function aSt(t, e) {
  var n, r = e.from, s = e.to;
  if (r && s) {
    var o = jl(s, r) < 0;
    o && (n = [s, r], r = n[0], s = n[1]);
    var i = jl(t, r) >= 0 && jl(s, t) >= 0;
    return i;
  }
  return s ? Ao(s, t) : r ? Ao(r, t) : !1;
}
function cSt(t) {
  return KL(t);
}
function lSt(t) {
  return Array.isArray(t) && t.every(KL);
}
function dSt(t, e) {
  return e.some(function(n) {
    if (typeof n == "boolean")
      return n;
    if (cSt(n))
      return Ao(t, n);
    if (lSt(n))
      return n.includes(t);
    if (rSt(n))
      return aSt(t, n);
    if (iSt(n))
      return n.dayOfWeek.includes(t.getDay());
    if (nSt(n)) {
      var r = jl(n.before, t), s = jl(n.after, t), o = r > 0, i = s < 0, a = ON(n.before, n.after);
      return a ? i && o : o || i;
    }
    return sSt(n) ? jl(t, n.after) > 0 : oSt(n) ? jl(n.before, t) > 0 : typeof n == "function" ? n(t) : !1;
  });
}
function EB(t, e, n) {
  var r = Object.keys(e).reduce(function(o, i) {
    var a = e[i];
    return dSt(t, a) && o.push(i), o;
  }, []), s = {};
  return r.forEach(function(o) {
    return s[o] = !0;
  }), n && !eF(t, n) && (s.outside = !0), s;
}
function uSt(t, e) {
  for (var n = ii(t[0]), r = L0(t[t.length - 1]), s, o, i = n; i <= r; ) {
    var a = EB(i, e), c = !a.disabled && !a.hidden;
    if (!c) {
      i = Xs(i, 1);
      continue;
    }
    if (a.selected)
      return i;
    a.today && !o && (o = i), s || (s = i), i = Xs(i, 1);
  }
  return o || s;
}
var fSt = 365;
function Hye(t, e) {
  var n = e.moveBy, r = e.direction, s = e.context, o = e.modifiers, i = e.retry, a = i === void 0 ? { count: 0, lastFocused: t } : i, c = s.weekStartsOn, l = s.fromDate, d = s.toDate, u = s.locale, f = {
    day: Xs,
    week: kN,
    month: Ca,
    year: WL,
    startOfWeek: function(m) {
      return s.ISOWeek ? ru(m) : Wi(m, { locale: u, weekStartsOn: c });
    },
    endOfWeek: function(m) {
      return s.ISOWeek ? iJ(m) : YL(m, { locale: u, weekStartsOn: c });
    }
  }, p = f[n](t, r === "after" ? 1 : -1);
  r === "before" && l ? p = Lke([l, p]) : r === "after" && d && (p = Fke([d, p]));
  var g = !0;
  if (o) {
    var y = EB(p, o);
    g = !y.disabled && !y.hidden;
  }
  return g ? p : a.count > fSt ? a.lastFocused : Hye(p, {
    moveBy: n,
    direction: r,
    context: s,
    modifiers: o,
    retry: St(St({}, a), { count: a.count + 1 })
  });
}
var Vye = zn(void 0);
function hSt(t) {
  var e = NS(), n = Uye(), r = he(), s = r[0], o = r[1], i = he(), a = i[0], c = i[1], l = uSt(e.displayMonths, n), d = s ?? (a && e.isDateDisplayed(a)) ? a : l, u = function() {
    c(s), o(void 0);
  }, f = function(m) {
    o(m);
  }, p = Wn(), g = function(m, v) {
    if (s) {
      var b = Hye(s, {
        moveBy: m,
        direction: v,
        context: p,
        modifiers: n
      });
      Ao(s, b) || (e.goToDate(b, s), f(b));
    }
  }, y = {
    focusedDay: s,
    focusTarget: d,
    blur: u,
    focus: f,
    focusDayAfter: function() {
      return g("day", "after");
    },
    focusDayBefore: function() {
      return g("day", "before");
    },
    focusWeekAfter: function() {
      return g("week", "after");
    },
    focusWeekBefore: function() {
      return g("week", "before");
    },
    focusMonthBefore: function() {
      return g("month", "before");
    },
    focusMonthAfter: function() {
      return g("month", "after");
    },
    focusYearBefore: function() {
      return g("year", "before");
    },
    focusYearAfter: function() {
      return g("year", "after");
    },
    focusStartOfWeek: function() {
      return g("startOfWeek", "before");
    },
    focusEndOfWeek: function() {
      return g("endOfWeek", "after");
    }
  };
  return h.jsx(Vye.Provider, { value: y, children: t.children });
}
function TB() {
  var t = tn(Vye);
  if (!t)
    throw new Error("useFocusContext must be used within a FocusProvider");
  return t;
}
function pSt(t, e) {
  var n = Uye(), r = EB(t, n, e);
  return r;
}
var PB = zn(void 0);
function gSt(t) {
  if (!uA(t.initialProps)) {
    var e = {
      selected: void 0
    };
    return h.jsx(PB.Provider, { value: e, children: t.children });
  }
  return h.jsx(mSt, { initialProps: t.initialProps, children: t.children });
}
function mSt(t) {
  var e = t.initialProps, n = t.children, r = function(o, i, a) {
    var c, l, d;
    if ((c = e.onDayClick) === null || c === void 0 || c.call(e, o, i, a), i.selected && !e.required) {
      (l = e.onSelect) === null || l === void 0 || l.call(e, void 0, o, i, a);
      return;
    }
    (d = e.onSelect) === null || d === void 0 || d.call(e, o, o, i, a);
  }, s = {
    selected: e.selected,
    onDayClick: r
  };
  return h.jsx(PB.Provider, { value: s, children: n });
}
function Wye() {
  var t = tn(PB);
  if (!t)
    throw new Error("useSelectSingle must be used within a SelectSingleProvider");
  return t;
}
function ySt(t, e) {
  var n = Wn(), r = Wye(), s = SB(), o = _B(), i = TB(), a = i.focusDayAfter, c = i.focusDayBefore, l = i.focusWeekAfter, d = i.focusWeekBefore, u = i.blur, f = i.focus, p = i.focusMonthBefore, g = i.focusMonthAfter, y = i.focusYearBefore, m = i.focusYearAfter, v = i.focusStartOfWeek, b = i.focusEndOfWeek, x = function($) {
    var F, L, z, H;
    uA(n) ? (F = r.onDayClick) === null || F === void 0 || F.call(r, t, e, $) : OS(n) ? (L = s.onDayClick) === null || L === void 0 || L.call(s, t, e, $) : DS(n) ? (z = o.onDayClick) === null || z === void 0 || z.call(o, t, e, $) : (H = n.onDayClick) === null || H === void 0 || H.call(n, t, e, $);
  }, w = function($) {
    var F;
    f(t), (F = n.onDayFocus) === null || F === void 0 || F.call(n, t, e, $);
  }, S = function($) {
    var F;
    u(), (F = n.onDayBlur) === null || F === void 0 || F.call(n, t, e, $);
  }, C = function($) {
    var F;
    (F = n.onDayMouseEnter) === null || F === void 0 || F.call(n, t, e, $);
  }, _ = function($) {
    var F;
    (F = n.onDayMouseLeave) === null || F === void 0 || F.call(n, t, e, $);
  }, E = function($) {
    var F;
    (F = n.onDayPointerEnter) === null || F === void 0 || F.call(n, t, e, $);
  }, M = function($) {
    var F;
    (F = n.onDayPointerLeave) === null || F === void 0 || F.call(n, t, e, $);
  }, N = function($) {
    var F;
    (F = n.onDayTouchCancel) === null || F === void 0 || F.call(n, t, e, $);
  }, O = function($) {
    var F;
    (F = n.onDayTouchEnd) === null || F === void 0 || F.call(n, t, e, $);
  }, D = function($) {
    var F;
    (F = n.onDayTouchMove) === null || F === void 0 || F.call(n, t, e, $);
  }, k = function($) {
    var F;
    (F = n.onDayTouchStart) === null || F === void 0 || F.call(n, t, e, $);
  }, A = function($) {
    var F;
    (F = n.onDayKeyUp) === null || F === void 0 || F.call(n, t, e, $);
  }, R = function($) {
    var F;
    switch ($.key) {
      case "ArrowLeft":
        $.preventDefault(), $.stopPropagation(), n.dir === "rtl" ? a() : c();
        break;
      case "ArrowRight":
        $.preventDefault(), $.stopPropagation(), n.dir === "rtl" ? c() : a();
        break;
      case "ArrowDown":
        $.preventDefault(), $.stopPropagation(), l();
        break;
      case "ArrowUp":
        $.preventDefault(), $.stopPropagation(), d();
        break;
      case "PageUp":
        $.preventDefault(), $.stopPropagation(), $.shiftKey ? y() : p();
        break;
      case "PageDown":
        $.preventDefault(), $.stopPropagation(), $.shiftKey ? m() : g();
        break;
      case "Home":
        $.preventDefault(), $.stopPropagation(), v();
        break;
      case "End":
        $.preventDefault(), $.stopPropagation(), b();
        break;
    }
    (F = n.onDayKeyDown) === null || F === void 0 || F.call(n, t, e, $);
  }, j = {
    onClick: x,
    onFocus: w,
    onBlur: S,
    onKeyDown: R,
    onKeyUp: A,
    onMouseEnter: C,
    onMouseLeave: _,
    onPointerEnter: E,
    onPointerLeave: M,
    onTouchCancel: N,
    onTouchEnd: O,
    onTouchMove: D,
    onTouchStart: k
  };
  return j;
}
function vSt() {
  var t = Wn(), e = Wye(), n = SB(), r = _B(), s = uA(t) ? e.selected : OS(t) ? n.selected : DS(t) ? r.selected : void 0;
  return s;
}
function bSt(t) {
  return Object.values(al).includes(t);
}
function xSt(t, e) {
  var n = [t.classNames.day];
  return Object.keys(e).forEach(function(r) {
    var s = t.modifiersClassNames[r];
    if (s)
      n.push(s);
    else if (bSt(r)) {
      var o = t.classNames["day_".concat(r)];
      o && n.push(o);
    }
  }), n;
}
function wSt(t, e) {
  var n = St({}, t.styles.day);
  return Object.keys(e).forEach(function(r) {
    var s;
    n = St(St({}, n), (s = t.modifiersStyles) === null || s === void 0 ? void 0 : s[r]);
  }), n;
}
function SSt(t, e, n) {
  var r, s, o, i = Wn(), a = TB(), c = pSt(t, e), l = ySt(t, c), d = vSt(), u = !!(i.onDayClick || i.mode !== "default");
  me(function() {
    var C;
    c.outside || a.focusedDay && u && Ao(a.focusedDay, t) && ((C = n.current) === null || C === void 0 || C.focus());
  }, [
    a.focusedDay,
    t,
    n,
    u,
    c.outside
  ]);
  var f = xSt(i, c).join(" "), p = wSt(i, c), g = !!(c.outside && !i.showOutsideDays || c.hidden), y = (o = (s = i.components) === null || s === void 0 ? void 0 : s.DayContent) !== null && o !== void 0 ? o : H0t, m = h.jsx(y, { date: t, displayMonth: e, activeModifiers: c }), v = {
    style: p,
    className: f,
    children: m,
    role: "gridcell"
  }, b = a.focusTarget && Ao(a.focusTarget, t) && !c.outside, x = a.focusedDay && Ao(a.focusedDay, t), w = St(St(St({}, v), (r = { disabled: c.disabled, role: "gridcell" }, r["aria-selected"] = c.selected, r.tabIndex = x || b ? 0 : -1, r)), l), S = {
    isButton: u,
    isHidden: g,
    activeModifiers: c,
    selectedDays: d,
    buttonProps: w,
    divProps: v
  };
  return S;
}
function CSt(t) {
  var e = fe(null), n = SSt(t.date, t.displayMonth, e);
  return n.isHidden ? h.jsx("div", { role: "gridcell" }) : n.isButton ? h.jsx(mP, St({ name: "day", ref: e }, n.buttonProps)) : h.jsx("div", St({}, n.divProps));
}
function _St(t) {
  var e = t.number, n = t.dates, r = Wn(), s = r.onWeekNumberClick, o = r.styles, i = r.classNames, a = r.locale, c = r.labels.labelWeekNumber, l = r.formatters.formatWeekNumber, d = l(Number(e), { locale: a });
  if (!s)
    return h.jsx("span", { className: i.weeknumber, style: o.weeknumber, children: d });
  var u = c(Number(e), { locale: a }), f = function(p) {
    s(e, n, p);
  };
  return h.jsx(mP, { name: "week-number", "aria-label": u, className: i.weeknumber, style: o.weeknumber, onClick: f, children: d });
}
function ESt(t) {
  var e, n, r = Wn(), s = r.styles, o = r.classNames, i = r.showWeekNumber, a = r.components, c = (e = a == null ? void 0 : a.Day) !== null && e !== void 0 ? e : CSt, l = (n = a == null ? void 0 : a.WeekNumber) !== null && n !== void 0 ? n : _St, d;
  return i && (d = h.jsx("td", { className: o.cell, style: s.cell, children: h.jsx(l, { number: t.weekNumber, dates: t.dates }) })), h.jsxs("tr", { className: o.row, style: s.row, children: [d, t.dates.map(function(u) {
    return h.jsx("td", { className: o.cell, style: s.cell, role: "presentation", children: h.jsx(c, { displayMonth: t.displayMonth, date: u }) }, YAe(u));
  })] });
}
function KK(t, e, n) {
  for (var r = n != null && n.ISOWeek ? iJ(e) : YL(e, n), s = n != null && n.ISOWeek ? ru(t) : Wi(t, n), o = jl(r, s), i = [], a = 0; a <= o; a++)
    i.push(Xs(s, a));
  var c = i.reduce(function(l, d) {
    var u = n != null && n.ISOWeek ? qL(d) : ZL(d, n), f = l.find(function(p) {
      return p.weekNumber === u;
    });
    return f ? (f.dates.push(d), l) : (l.push({
      weekNumber: u,
      dates: [d]
    }), l);
  }, []);
  return c;
}
function TSt(t, e) {
  var n = KK(ii(t), L0(t), e);
  if (e != null && e.useFixedWeeks) {
    var r = XAe(t, e);
    if (r < 6) {
      var s = n[n.length - 1], o = s.dates[s.dates.length - 1], i = kN(o, 6 - r), a = KK(kN(o, 1), i, e);
      n.push.apply(n, a);
    }
  }
  return n;
}
function PSt(t) {
  var e, n, r, s = Wn(), o = s.locale, i = s.classNames, a = s.styles, c = s.hideHead, l = s.fixedWeeks, d = s.components, u = s.weekStartsOn, f = s.firstWeekContainsDate, p = s.ISOWeek, g = TSt(t.displayMonth, {
    useFixedWeeks: !!l,
    ISOWeek: p,
    locale: o,
    weekStartsOn: u,
    firstWeekContainsDate: f
  }), y = (e = d == null ? void 0 : d.Head) !== null && e !== void 0 ? e : U0t, m = (n = d == null ? void 0 : d.Row) !== null && n !== void 0 ? n : ESt, v = (r = d == null ? void 0 : d.Footer) !== null && r !== void 0 ? r : F0t;
  return h.jsxs("table", { id: t.id, className: i.table, style: a.table, role: "grid", "aria-labelledby": t["aria-labelledby"], children: [!c && h.jsx(y, {}), h.jsx("tbody", { className: i.tbody, style: a.tbody, children: g.map(function(b) {
    return h.jsx(m, { displayMonth: t.displayMonth, dates: b.dates, weekNumber: b.weekNumber }, b.weekNumber);
  }) }), h.jsx(v, { displayMonth: t.displayMonth })] });
}
function ISt() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
var kSt = ISt() ? un : me, R2 = !1, ASt = 0;
function GK() {
  return "react-day-picker-".concat(++ASt);
}
function MSt(t) {
  var e, n = t ?? (R2 ? GK() : null), r = he(n), s = r[0], o = r[1];
  return kSt(function() {
    s === null && o(GK());
  }, []), me(function() {
    R2 === !1 && (R2 = !0);
  }, []), (e = t ?? s) !== null && e !== void 0 ? e : void 0;
}
function OSt(t) {
  var e, n, r = Wn(), s = r.dir, o = r.classNames, i = r.styles, a = r.components, c = NS().displayMonths, l = MSt(r.id ? "".concat(r.id, "-").concat(t.displayIndex) : void 0), d = r.id ? "".concat(r.id, "-grid-").concat(t.displayIndex) : void 0, u = [o.month], f = i.month, p = t.displayIndex === 0, g = t.displayIndex === c.length - 1, y = !p && !g;
  s === "rtl" && (e = [p, g], g = e[0], p = e[1]), p && (u.push(o.caption_start), f = St(St({}, f), i.caption_start)), g && (u.push(o.caption_end), f = St(St({}, f), i.caption_end)), y && (u.push(o.caption_between), f = St(St({}, f), i.caption_between));
  var m = (n = a == null ? void 0 : a.Caption) !== null && n !== void 0 ? n : L0t;
  return h.jsxs("div", { className: u.join(" "), style: f, children: [h.jsx(m, { id: l, displayMonth: t.displayMonth, displayIndex: t.displayIndex }), h.jsx(PSt, { id: d, "aria-labelledby": l, displayMonth: t.displayMonth })] }, t.displayIndex);
}
function DSt(t) {
  var e = Wn(), n = e.classNames, r = e.styles;
  return h.jsx("div", { className: n.months, style: r.months, children: t.children });
}
function NSt(t) {
  var e, n, r = t.initialProps, s = Wn(), o = TB(), i = NS(), a = he(!1), c = a[0], l = a[1];
  me(function() {
    s.initialFocus && o.focusTarget && (c || (o.focus(o.focusTarget), l(!0)));
  }, [
    s.initialFocus,
    c,
    o.focus,
    o.focusTarget,
    o
  ]);
  var d = [s.classNames.root, s.className];
  s.numberOfMonths > 1 && d.push(s.classNames.multiple_months), s.showWeekNumber && d.push(s.classNames.with_weeknumber);
  var u = St(St({}, s.styles.root), s.style), f = Object.keys(r).filter(function(g) {
    return g.startsWith("data-");
  }).reduce(function(g, y) {
    var m;
    return St(St({}, g), (m = {}, m[y] = r[y], m));
  }, {}), p = (n = (e = r.components) === null || e === void 0 ? void 0 : e.Months) !== null && n !== void 0 ? n : DSt;
  return h.jsx("div", St({ className: d.join(" "), style: u, dir: s.dir, id: s.id, nonce: r.nonce, title: r.title, lang: r.lang }, f, { children: h.jsx(p, { children: i.displayMonths.map(function(g, y) {
    return h.jsx(OSt, { displayIndex: y, displayMonth: g }, y);
  }) }) }));
}
function jSt(t) {
  var e = t.children, n = o0t(t, ["children"]);
  return h.jsx(_0t, { initialProps: n, children: h.jsx(N0t, { children: h.jsx(gSt, { initialProps: n, children: h.jsx(V0t, { initialProps: n, children: h.jsx(G0t, { initialProps: n, children: h.jsx(tSt, { children: h.jsx(hSt, { children: e }) }) }) }) }) }) });
}
function RSt(t) {
  return h.jsx(jSt, St({}, t, { children: h.jsx(NSt, { initialProps: t }) }));
}
function yP({ className: t, classNames: e, showOutsideDays: n = !0, ...r }) {
  return /* @__PURE__ */ h.jsx(
    RSt,
    {
      showOutsideDays: n,
      className: Oe("p-3", t),
      classNames: {
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: Oe(
          JD({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: Oe(JD({ variant: "ghost" }), "h-9 w-9 p-0 font-normal aria-selected:opacity-100"),
        day_range_end: "day-range-end",
        day_selected: "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside: "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...e
      },
      components: {
        IconLeft: ({ ...s }) => /* @__PURE__ */ h.jsx(BP, { className: "h-4 w-4" }),
        IconRight: ({ ...s }) => /* @__PURE__ */ h.jsx(Lq, { className: "h-4 w-4" })
      },
      ...r
    }
  );
}
yP.displayName = "Calendar";
function $St({ dueDate: t, onChange: e }) {
  const [n, r] = he(!1), s = t ? new Date(t) : void 0, o = (a) => {
    e(a == null ? void 0 : a.toISOString()), r(!1);
  }, i = (a) => {
    a.stopPropagation(), e(void 0);
  };
  return /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 text-sm font-medium text-muted-foreground", children: [
      /* @__PURE__ */ h.jsx(mp, { className: "h-4 w-4" }),
      "Due Date"
    ] }),
    /* @__PURE__ */ h.jsxs(Jx, { open: n, onOpenChange: r, children: [
      /* @__PURE__ */ h.jsx(ew, { asChild: !0, children: /* @__PURE__ */ h.jsxs(
        _t,
        {
          variant: "outline",
          className: Oe(
            "w-full justify-start text-left font-normal",
            !s && "text-muted-foreground"
          ),
          children: [
            /* @__PURE__ */ h.jsx(mp, { className: "mr-2 h-4 w-4" }),
            s ? Rr(s, "PPP") : "Set due date",
            s && /* @__PURE__ */ h.jsx(
              rg,
              {
                className: "ml-auto h-4 w-4 hover:text-destructive",
                onClick: i
              }
            )
          ]
        }
      ) }),
      /* @__PURE__ */ h.jsx(ty, { className: "w-auto p-0", align: "start", children: /* @__PURE__ */ h.jsx(
        yP,
        {
          mode: "single",
          selected: s,
          onSelect: o,
          initialFocus: !0,
          className: Oe("p-3 pointer-events-auto")
        }
      ) })
    ] })
  ] });
}
function Kye({
  card: t,
  open: e,
  onOpenChange: n,
  onSave: r,
  onDelete: s
}) {
  const [o, i] = he(t ? { ...t } : null), [a, c] = he(!1), [l, d] = he(t);
  t !== l && (d(t), i(t ? { ...t } : null));
  const u = re(
    (y) => {
      if (!o) return;
      const m = {
        ...o,
        ...y,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      i(m), r(m);
    },
    [o, r]
  ), f = (y) => {
    o && i({ ...o, title: y.target.value });
  }, p = () => {
    c(!1), o && u({ title: o.title });
  }, g = (y) => {
    y.key === "Enter" && (c(!1), o && u({ title: o.title }));
  };
  return o ? /* @__PURE__ */ h.jsx(ig, { open: e, onOpenChange: n, children: /* @__PURE__ */ h.jsxs(Gf, { className: "max-w-2xl max-h-[90vh] flex flex-col p-0", children: [
    /* @__PURE__ */ h.jsx(ag, { className: "p-6 pb-0", children: a ? /* @__PURE__ */ h.jsx(
      pa,
      {
        value: o.title,
        onChange: f,
        onBlur: p,
        onKeyDown: g,
        className: "text-lg font-semibold",
        autoFocus: !0
      }
    ) : /* @__PURE__ */ h.jsx(
      cg,
      {
        className: "cursor-pointer hover:bg-muted/50 p-2 -m-2 rounded",
        onClick: () => c(!0),
        children: o.title
      }
    ) }),
    /* @__PURE__ */ h.jsx(P4, { className: "flex-1 px-6", children: /* @__PURE__ */ h.jsxs("div", { className: "space-y-6 py-4", children: [
      /* @__PURE__ */ h.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ h.jsx(
          s0t,
          {
            labels: o.labels || [],
            onChange: (y) => u({ labels: y })
          }
        ),
        /* @__PURE__ */ h.jsx(
          $St,
          {
            dueDate: o.dueDate,
            onChange: (y) => u({ dueDate: y })
          }
        )
      ] }),
      /* @__PURE__ */ h.jsx(ix, {}),
      /* @__PURE__ */ h.jsx(
        Jwt,
        {
          description: o.description,
          onChange: (y) => u({ description: y })
        }
      ),
      /* @__PURE__ */ h.jsx(ix, {}),
      /* @__PURE__ */ h.jsx(
        e0t,
        {
          todos: o.todos || [],
          onChange: (y) => u({ todos: y })
        }
      ),
      /* @__PURE__ */ h.jsx(ix, {}),
      /* @__PURE__ */ h.jsx(
        t0t,
        {
          comments: o.comments || [],
          onChange: (y) => u({ comments: y })
        }
      )
    ] }) }),
    /* @__PURE__ */ h.jsx(FL, { className: "p-6 pt-4 border-t", children: /* @__PURE__ */ h.jsxs(_t, { variant: "destructive", size: "sm", onClick: s, children: [
      /* @__PURE__ */ h.jsx(Ky, { className: "h-4 w-4 mr-2" }),
      "Delete Card"
    ] }) })
  ] }) }) : null;
}
const YK = [
  { id: "todo", title: "To Do", cards: [] },
  { id: "in-progress", title: "In Progress", cards: [] },
  { id: "done", title: "Done", cards: [] }
];
function LSt({ initialData: t, onSave: e }) {
  const n = Ke(() => {
    if (t && typeof t == "object") {
      const v = t;
      return v.columns ? v.columns.map((b) => ({
        ...b,
        cards: b.cards.map((x) => r0t(x))
      })) : YK;
    }
    return YK;
  }, [t]), [r, s] = he(n), [o, i] = he(null), [a, c] = he(null), [l, d] = he(!1), u = re((v) => {
    e && e({ columns: v });
  }, [e]), f = re((v) => {
    const { source: b, destination: x } = v;
    x && s((w) => {
      const S = [...w], C = S.findIndex((N) => N.id === b.droppableId), _ = S.findIndex((N) => N.id === x.droppableId);
      if (C === -1 || _ === -1) return w;
      const E = { ...S[C], cards: [...S[C].cards] }, [M] = E.cards.splice(b.index, 1);
      if (b.droppableId === x.droppableId)
        E.cards.splice(x.index, 0, M), S[C] = E;
      else {
        const N = { ...S[_], cards: [...S[_].cards] };
        N.cards.splice(x.index, 0, M), S[C] = E, S[_] = N;
      }
      return u(S), S;
    });
  }, [u]), p = re((v, b) => {
    const x = (/* @__PURE__ */ new Date()).toISOString(), w = {
      id: `card-${Date.now()}`,
      title: b,
      todos: [],
      comments: [],
      labels: [],
      createdAt: x,
      updatedAt: x
    };
    s((S) => {
      const C = S.map((_) => _.id === v ? { ..._, cards: [..._.cards, w] } : _);
      return u(C), C;
    });
  }, [u]), g = re((v, b) => {
    s((x) => {
      const w = x.map((S) => S.id === v ? { ...S, cards: S.cards.filter((C) => C.id !== b) } : S);
      return u(w), w;
    }), d(!1), i(null), c(null);
  }, [u]), y = re((v, b) => {
    i(v), c(b), d(!0);
  }, []), m = re((v) => {
    s((b) => {
      const x = b.map((w) => ({
        ...w,
        cards: w.cards.map(
          (S) => S.id === v.id ? v : S
        )
      }));
      return u(x), x;
    }), i(v);
  }, [u]);
  return /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
    /* @__PURE__ */ h.jsx("div", { className: "w-full h-full p-4 overflow-x-auto", children: /* @__PURE__ */ h.jsx(Qxt, { onDragEnd: f, children: /* @__PURE__ */ h.jsx("div", { className: "flex gap-4 h-full min-w-max", children: r.map((v) => /* @__PURE__ */ h.jsx(
      Qwt,
      {
        column: v,
        onAddCard: p,
        onCardClick: (b) => y(b, v.id),
        onDeleteCard: g
      },
      v.id
    )) }) }) }),
    /* @__PURE__ */ h.jsx(
      Kye,
      {
        card: o,
        open: l,
        onOpenChange: d,
        onSave: m,
        onDelete: () => {
          a && o && g(a, o.id);
        }
      }
    )
  ] });
}
function FSt({ open: t, onOpenChange: e }) {
  return /* @__PURE__ */ h.jsx(ig, { open: t, onOpenChange: e, children: /* @__PURE__ */ h.jsxs(Gf, { className: "max-w-md", children: [
    /* @__PURE__ */ h.jsx(ag, { children: /* @__PURE__ */ h.jsx(cg, { children: "Tasks Tips" }) }),
    /* @__PURE__ */ h.jsxs("div", { className: "space-y-4 text-sm", children: [
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(Jc, { className: "h-4 w-4 text-primary" }),
          "Creating Cards"
        ] }),
        /* @__PURE__ */ h.jsxs("p", { className: "text-muted-foreground", children: [
          "Click the ",
          /* @__PURE__ */ h.jsx(Jc, { className: "inline h-3 w-3" }),
          " button at the bottom of any column to add a new card. Type a title and press Enter."
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(rwe, { className: "h-4 w-4 text-primary" }),
          "Drag & Drop"
        ] }),
        /* @__PURE__ */ h.jsx("p", { className: "text-muted-foreground", children: "Drag cards between columns to change their status. Drag columns by their header to reorder them." })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(G$, { className: "h-4 w-4 text-primary" }),
          "Card Details"
        ] }),
        /* @__PURE__ */ h.jsx("p", { className: "text-muted-foreground", children: "Click on any card to open its detail view. Add descriptions, labels, due dates, checklists, and comments." })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(mp, { className: "h-4 w-4 text-primary" }),
          "Due Dates"
        ] }),
        /* @__PURE__ */ h.jsx("p", { className: "text-muted-foreground", children: "Cards with due dates automatically appear in the Calendar tool, keeping all your deadlines in one place." })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsxs("h4", { className: "font-medium flex items-center gap-2", children: [
          /* @__PURE__ */ h.jsx(K$, { className: "h-4 w-4 text-primary" }),
          "Quick Actions"
        ] }),
        /* @__PURE__ */ h.jsxs("ul", { className: "text-muted-foreground space-y-1 ml-6 list-disc", children: [
          /* @__PURE__ */ h.jsx("li", { children: "Click column header to rename it" }),
          /* @__PURE__ */ h.jsx("li", { children: "Use labels to categorize cards" }),
          /* @__PURE__ */ h.jsx("li", { children: "Add checklists for sub-tasks" })
        ] })
      ] })
    ] })
  ] }) });
}
const qK = er.board;
function XK() {
  const { id: t } = $P(), { artifact: e, loading: n, error: r, saving: s, save: o, rename: i, toggleFavorite: a, updateTags: c } = I4("board", t || "new"), [l, d] = he(!1), u = Ke(() => /* @__PURE__ */ h.jsx(
    _t,
    {
      variant: "ghost",
      size: "icon",
      className: "h-8 w-8",
      onClick: () => d(!0),
      title: "Help",
      children: /* @__PURE__ */ h.jsx(Vy, { className: "h-4 w-4" })
    }
  ), []);
  return /* @__PURE__ */ h.jsxs(
    rF,
    {
      title: qK.title,
      icon: qK.icon,
      artifact: e,
      loading: n,
      error: r,
      saving: s,
      onRename: i,
      onToggleFavorite: a,
      onUpdateTags: c,
      headerActions: u,
      children: [
        /* @__PURE__ */ h.jsx(LSt, { initialData: e == null ? void 0 : e.data, onSave: o }),
        /* @__PURE__ */ h.jsx(FSt, { open: l, onOpenChange: d })
      ]
    }
  );
}
function td(t, e) {
  if (t == null) return {};
  var n, r, s = bv(t, e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    for (r = 0; r < o.length; r++) n = o[r], e.indexOf(n) === -1 && {}.propertyIsEnumerable.call(t, n) && (s[n] = t[n]);
  }
  return s;
}
function xs(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function ZK(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, bme(r.key), r);
  }
}
function ws(t, e, n) {
  return e && ZK(t.prototype, e), n && ZK(t, n), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function vP(t) {
  return vP = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, vP(t);
}
function Gye() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (Gye = function() {
    return !!t;
  })();
}
function BSt(t) {
  if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function zSt(t, e) {
  if (e && (cu(e) == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return BSt(t);
}
function Ho(t, e, n) {
  return e = vP(e), zSt(t, Gye() ? Reflect.construct(e, n || [], vP(t).constructor) : e.apply(t, n));
}
function bP(t, e) {
  return bP = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, bP(t, e);
}
function Vo(t, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && bP(t, e);
}
function Yye(t) {
  if (Array.isArray(t)) return t;
}
function USt(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var r, s, o, i, a = [], c = !0, l = !1;
    try {
      if (o = (n = n.call(t)).next, e !== 0) for (; !(c = (r = o.call(n)).done) && (a.push(r.value), a.length !== e); c = !0) ;
    } catch (d) {
      l = !0, s = d;
    } finally {
      try {
        if (!c && n.return != null && (i = n.return(), Object(i) !== i)) return;
      } finally {
        if (l) throw s;
      }
    }
    return a;
  }
}
function d$(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function IB(t, e) {
  if (t) {
    if (typeof t == "string") return d$(t, e);
    var n = {}.toString.call(t).slice(8, -1);
    return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? d$(t, e) : void 0;
  }
}
function qye() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Yp(t, e) {
  return Yye(t) || USt(t, e) || IB(t, e) || qye();
}
function Xye(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) for (e = 0; e < t.length; e++) t[e] && (n = Xye(t[e])) && (r && (r += " "), r += n);
  else for (e in t) t[e] && (r && (r += " "), r += e);
  return r;
}
function kr() {
  for (var t, e, n = 0, r = ""; n < arguments.length; ) (t = arguments[n++]) && (e = Xye(t)) && (r && (r += " "), r += e);
  return r;
}
var HSt = function(t, e, n, r, s, o, i, a) {
  if (process.env.NODE_ENV !== "production" && e === void 0)
    throw new Error("invariant requires an error message argument");
  if (!t) {
    var c;
    if (e === void 0)
      c = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var l = [n, r, s, o, i, a], d = 0;
      c = new Error(
        e.replace(/%s/g, function() {
          return l[d++];
        })
      ), c.name = "Invariant Violation";
    }
    throw c.framesToPop = 1, c;
  }
}, VSt = HSt;
const Uf = /* @__PURE__ */ Wr(VSt);
var WSt = function() {
};
function KSt(t, e) {
  return function(n, r) {
    if (n[r] !== void 0 && !n[t])
      return new Error("You have provided a `" + r + "` prop to `" + e + "` " + ("without an `" + t + "` handler prop. This will render a read-only field. ") + ("If the field should be mutable use `" + Bx(r) + "`. ") + ("Otherwise, set `" + t + "`."));
  };
}
function GSt(t, e) {
  var n = {};
  return Object.keys(t).forEach(function(r) {
    if (n[Bx(r)] = WSt, process.env.NODE_ENV !== "production") {
      var s = t[r];
      typeof s == "string" && s.trim().length || (process.env.NODE_ENV !== "production" ? Uf(!1, "Uncontrollable - [%s]: the prop `%s` needs a valid handler key name in order to make it uncontrollable", e, r) : Uf(!1)), n[r] = KSt(s, e);
    }
  }), n;
}
function QK(t, e) {
  return t[e] !== void 0;
}
function Bx(t) {
  return "default" + t.charAt(0).toUpperCase() + t.substr(1);
}
function YSt(t) {
  return !!t && (typeof t != "function" || t.prototype && t.prototype.isReactComponent);
}
function qSt(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, bP(t, e);
}
function Zye() {
  var t = this.constructor.getDerivedStateFromProps(this.props, this.state);
  t != null && this.setState(t);
}
function Qye(t) {
  function e(n) {
    var r = this.constructor.getDerivedStateFromProps(t, n);
    return r ?? null;
  }
  this.setState(e.bind(this));
}
function Jye(t, e) {
  try {
    var n = this.props, r = this.state;
    this.props = t, this.state = e, this.__reactInternalSnapshotFlag = !0, this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      n,
      r
    );
  } finally {
    this.props = n, this.state = r;
  }
}
Zye.__suppressDeprecationWarning = !0;
Qye.__suppressDeprecationWarning = !0;
Jye.__suppressDeprecationWarning = !0;
function XSt(t) {
  var e = t.prototype;
  if (!e || !e.isReactComponent)
    throw new Error("Can only polyfill class components");
  if (typeof t.getDerivedStateFromProps != "function" && typeof e.getSnapshotBeforeUpdate != "function")
    return t;
  var n = null, r = null, s = null;
  if (typeof e.componentWillMount == "function" ? n = "componentWillMount" : typeof e.UNSAFE_componentWillMount == "function" && (n = "UNSAFE_componentWillMount"), typeof e.componentWillReceiveProps == "function" ? r = "componentWillReceiveProps" : typeof e.UNSAFE_componentWillReceiveProps == "function" && (r = "UNSAFE_componentWillReceiveProps"), typeof e.componentWillUpdate == "function" ? s = "componentWillUpdate" : typeof e.UNSAFE_componentWillUpdate == "function" && (s = "UNSAFE_componentWillUpdate"), n !== null || r !== null || s !== null) {
    var o = t.displayName || t.name, i = typeof t.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
    throw Error(
      `Unsafe legacy lifecycles will not be called for components using new component APIs.

` + o + " uses " + i + " but also contains the following legacy lifecycles:" + (n !== null ? `
  ` + n : "") + (r !== null ? `
  ` + r : "") + (s !== null ? `
  ` + s : "") + `

The above lifecycles should be removed. Learn more about this warning here:
https://fb.me/react-async-component-lifecycle-hooks`
    );
  }
  if (typeof t.getDerivedStateFromProps == "function" && (e.componentWillMount = Zye, e.componentWillReceiveProps = Qye), typeof e.getSnapshotBeforeUpdate == "function") {
    if (typeof e.componentDidUpdate != "function")
      throw new Error(
        "Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype"
      );
    e.componentWillUpdate = Jye;
    var a = e.componentDidUpdate;
    e.componentDidUpdate = function(l, d, u) {
      var f = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : u;
      a.call(this, l, d, f);
    };
  }
  return t;
}
var ZSt = "/Users/jquense/src/uncontrollable/src/uncontrollable.js";
function eve(t, e, n) {
  n === void 0 && (n = []);
  var r = t.displayName || t.name || "Component", s = YSt(t), o = Object.keys(e), i = o.map(Bx);
  s || !n.length || (process.env.NODE_ENV !== "production" ? Uf(!1, "[uncontrollable] stateless function components cannot pass through methods because they have no associated instances. Check component: " + r + ", attempting to pass through methods: " + n.join(", ")) : Uf(!1));
  var a = /* @__PURE__ */ function(l) {
    qSt(d, l);
    function d() {
      for (var f, p = arguments.length, g = new Array(p), y = 0; y < p; y++)
        g[y] = arguments[y];
      f = l.call.apply(l, [this].concat(g)) || this, f.handlers = /* @__PURE__ */ Object.create(null), o.forEach(function(v) {
        var b = e[v], x = function(S) {
          if (f.props[b]) {
            var C;
            f._notifying = !0;
            for (var _ = arguments.length, E = new Array(_ > 1 ? _ - 1 : 0), M = 1; M < _; M++)
              E[M - 1] = arguments[M];
            (C = f.props)[b].apply(C, [S].concat(E)), f._notifying = !1;
          }
          f.unmounted || f.setState(function(N) {
            var O, D = N.values;
            return {
              values: Rn(/* @__PURE__ */ Object.create(null), D, (O = {}, O[v] = S, O))
            };
          });
        };
        f.handlers[b] = x;
      }), n.length && (f.attachRef = function(v) {
        f.inner = v;
      });
      var m = /* @__PURE__ */ Object.create(null);
      return o.forEach(function(v) {
        m[v] = f.props[Bx(v)];
      }), f.state = {
        values: m,
        prevProps: {}
      }, f;
    }
    var u = d.prototype;
    return u.shouldComponentUpdate = function() {
      return !this._notifying;
    }, d.getDerivedStateFromProps = function(p, g) {
      var y = g.values, m = g.prevProps, v = {
        values: Rn(/* @__PURE__ */ Object.create(null), y),
        prevProps: {}
      };
      return o.forEach(function(b) {
        v.prevProps[b] = p[b], !QK(p, b) && QK(m, b) && (v.values[b] = p[Bx(b)]);
      }), v;
    }, u.componentWillUnmount = function() {
      this.unmounted = !0;
    }, u.render = function() {
      var p = this, g = this.props, y = g.innerRef, m = bv(g, ["innerRef"]);
      i.forEach(function(b) {
        delete m[b];
      });
      var v = {};
      return o.forEach(function(b) {
        var x = p.props[b];
        v[b] = x !== void 0 ? x : p.state.values[b];
      }), B.createElement(t, Rn({}, m, v, this.handlers, {
        ref: y || this.attachRef
      }));
    }, d;
  }(B.Component);
  XSt(a), a.displayName = "Uncontrolled(" + r + ")", a.propTypes = Rn({
    innerRef: function() {
    }
  }, GSt(e, r)), n.forEach(function(l) {
    a.prototype[l] = function() {
      var u;
      return (u = this.inner)[l].apply(u, arguments);
    };
  });
  var c = a;
  return B.forwardRef && (c = B.forwardRef(function(l, d) {
    return B.createElement(a, Rn({}, l, {
      innerRef: d,
      __source: {
        fileName: ZSt,
        lineNumber: 128
      },
      __self: this
    }));
  }), c.propTypes = a.propTypes), c.ControlledComponent = t, c.deferControlTo = function(l, d, u) {
    return d === void 0 && (d = {}), eve(l, Rn({}, e, d), u);
  }, c;
}
var u$ = { exports: {} }, TC = { exports: {} }, En = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JK;
function QSt() {
  if (JK) return En;
  JK = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, s = t ? Symbol.for("react.strict_mode") : 60108, o = t ? Symbol.for("react.profiler") : 60114, i = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, c = t ? Symbol.for("react.async_mode") : 60111, l = t ? Symbol.for("react.concurrent_mode") : 60111, d = t ? Symbol.for("react.forward_ref") : 60112, u = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, p = t ? Symbol.for("react.memo") : 60115, g = t ? Symbol.for("react.lazy") : 60116, y = t ? Symbol.for("react.block") : 60121, m = t ? Symbol.for("react.fundamental") : 60117, v = t ? Symbol.for("react.responder") : 60118, b = t ? Symbol.for("react.scope") : 60119;
  function x(S) {
    if (typeof S == "object" && S !== null) {
      var C = S.$$typeof;
      switch (C) {
        case e:
          switch (S = S.type, S) {
            case c:
            case l:
            case r:
            case o:
            case s:
            case u:
              return S;
            default:
              switch (S = S && S.$$typeof, S) {
                case a:
                case d:
                case g:
                case p:
                case i:
                  return S;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function w(S) {
    return x(S) === l;
  }
  return En.AsyncMode = c, En.ConcurrentMode = l, En.ContextConsumer = a, En.ContextProvider = i, En.Element = e, En.ForwardRef = d, En.Fragment = r, En.Lazy = g, En.Memo = p, En.Portal = n, En.Profiler = o, En.StrictMode = s, En.Suspense = u, En.isAsyncMode = function(S) {
    return w(S) || x(S) === c;
  }, En.isConcurrentMode = w, En.isContextConsumer = function(S) {
    return x(S) === a;
  }, En.isContextProvider = function(S) {
    return x(S) === i;
  }, En.isElement = function(S) {
    return typeof S == "object" && S !== null && S.$$typeof === e;
  }, En.isForwardRef = function(S) {
    return x(S) === d;
  }, En.isFragment = function(S) {
    return x(S) === r;
  }, En.isLazy = function(S) {
    return x(S) === g;
  }, En.isMemo = function(S) {
    return x(S) === p;
  }, En.isPortal = function(S) {
    return x(S) === n;
  }, En.isProfiler = function(S) {
    return x(S) === o;
  }, En.isStrictMode = function(S) {
    return x(S) === s;
  }, En.isSuspense = function(S) {
    return x(S) === u;
  }, En.isValidElementType = function(S) {
    return typeof S == "string" || typeof S == "function" || S === r || S === l || S === o || S === s || S === u || S === f || typeof S == "object" && S !== null && (S.$$typeof === g || S.$$typeof === p || S.$$typeof === i || S.$$typeof === a || S.$$typeof === d || S.$$typeof === m || S.$$typeof === v || S.$$typeof === b || S.$$typeof === y);
  }, En.typeOf = x, En;
}
var Tn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eG;
function JSt() {
  return eG || (eG = 1, process.env.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, s = t ? Symbol.for("react.strict_mode") : 60108, o = t ? Symbol.for("react.profiler") : 60114, i = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, c = t ? Symbol.for("react.async_mode") : 60111, l = t ? Symbol.for("react.concurrent_mode") : 60111, d = t ? Symbol.for("react.forward_ref") : 60112, u = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, p = t ? Symbol.for("react.memo") : 60115, g = t ? Symbol.for("react.lazy") : 60116, y = t ? Symbol.for("react.block") : 60121, m = t ? Symbol.for("react.fundamental") : 60117, v = t ? Symbol.for("react.responder") : 60118, b = t ? Symbol.for("react.scope") : 60119;
    function x(G) {
      return typeof G == "string" || typeof G == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      G === r || G === l || G === o || G === s || G === u || G === f || typeof G == "object" && G !== null && (G.$$typeof === g || G.$$typeof === p || G.$$typeof === i || G.$$typeof === a || G.$$typeof === d || G.$$typeof === m || G.$$typeof === v || G.$$typeof === b || G.$$typeof === y);
    }
    function w(G) {
      if (typeof G == "object" && G !== null) {
        var xe = G.$$typeof;
        switch (xe) {
          case e:
            var ge = G.type;
            switch (ge) {
              case c:
              case l:
              case r:
              case o:
              case s:
              case u:
                return ge;
              default:
                var ze = ge && ge.$$typeof;
                switch (ze) {
                  case a:
                  case d:
                  case g:
                  case p:
                  case i:
                    return ze;
                  default:
                    return xe;
                }
            }
          case n:
            return xe;
        }
      }
    }
    var S = c, C = l, _ = a, E = i, M = e, N = d, O = r, D = g, k = p, A = n, R = o, j = s, $ = u, F = !1;
    function L(G) {
      return F || (F = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), z(G) || w(G) === c;
    }
    function z(G) {
      return w(G) === l;
    }
    function H(G) {
      return w(G) === a;
    }
    function U(G) {
      return w(G) === i;
    }
    function W(G) {
      return typeof G == "object" && G !== null && G.$$typeof === e;
    }
    function Z(G) {
      return w(G) === d;
    }
    function K(G) {
      return w(G) === r;
    }
    function oe(G) {
      return w(G) === g;
    }
    function Y(G) {
      return w(G) === p;
    }
    function ee(G) {
      return w(G) === n;
    }
    function ae(G) {
      return w(G) === o;
    }
    function de(G) {
      return w(G) === s;
    }
    function ye(G) {
      return w(G) === u;
    }
    Tn.AsyncMode = S, Tn.ConcurrentMode = C, Tn.ContextConsumer = _, Tn.ContextProvider = E, Tn.Element = M, Tn.ForwardRef = N, Tn.Fragment = O, Tn.Lazy = D, Tn.Memo = k, Tn.Portal = A, Tn.Profiler = R, Tn.StrictMode = j, Tn.Suspense = $, Tn.isAsyncMode = L, Tn.isConcurrentMode = z, Tn.isContextConsumer = H, Tn.isContextProvider = U, Tn.isElement = W, Tn.isForwardRef = Z, Tn.isFragment = K, Tn.isLazy = oe, Tn.isMemo = Y, Tn.isPortal = ee, Tn.isProfiler = ae, Tn.isStrictMode = de, Tn.isSuspense = ye, Tn.isValidElementType = x, Tn.typeOf = w;
  }()), Tn;
}
var tG;
function tve() {
  return tG || (tG = 1, process.env.NODE_ENV === "production" ? TC.exports = QSt() : TC.exports = JSt()), TC.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var $2, nG;
function e1t() {
  if (nG) return $2;
  nG = 1;
  var t = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function s() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var i = {}, a = 0; a < 10; a++)
        i["_" + String.fromCharCode(a)] = a;
      var c = Object.getOwnPropertyNames(i).map(function(d) {
        return i[d];
      });
      if (c.join("") !== "0123456789")
        return !1;
      var l = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(d) {
        l[d] = d;
      }), Object.keys(Object.assign({}, l)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return $2 = s() ? Object.assign : function(o, i) {
    for (var a, c = r(o), l, d = 1; d < arguments.length; d++) {
      a = Object(arguments[d]);
      for (var u in a)
        e.call(a, u) && (c[u] = a[u]);
      if (t) {
        l = t(a);
        for (var f = 0; f < l.length; f++)
          n.call(a, l[f]) && (c[l[f]] = a[l[f]]);
      }
    }
    return c;
  }, $2;
}
var L2, rG;
function kB() {
  if (rG) return L2;
  rG = 1;
  var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return L2 = t, L2;
}
var F2, sG;
function nve() {
  return sG || (sG = 1, F2 = Function.call.bind(Object.prototype.hasOwnProperty)), F2;
}
var B2, oG;
function t1t() {
  if (oG) return B2;
  oG = 1;
  var t = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = kB(), n = {}, r = nve();
    t = function(o) {
      var i = "Warning: " + o;
      typeof console < "u" && console.error(i);
      try {
        throw new Error(i);
      } catch {
      }
    };
  }
  function s(o, i, a, c, l) {
    if (process.env.NODE_ENV !== "production") {
      for (var d in o)
        if (r(o, d)) {
          var u;
          try {
            if (typeof o[d] != "function") {
              var f = Error(
                (c || "React class") + ": " + a + " type `" + d + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[d] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw f.name = "Invariant Violation", f;
            }
            u = o[d](i, d, c, a, null, e);
          } catch (g) {
            u = g;
          }
          if (u && !(u instanceof Error) && t(
            (c || "React class") + ": type specification of " + a + " `" + d + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof u + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), u instanceof Error && !(u.message in n)) {
            n[u.message] = !0;
            var p = l ? l() : "";
            t(
              "Failed " + a + " type: " + u.message + (p ?? "")
            );
          }
        }
    }
  }
  return s.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, B2 = s, B2;
}
var z2, iG;
function n1t() {
  if (iG) return z2;
  iG = 1;
  var t = tve(), e = e1t(), n = kB(), r = nve(), s = t1t(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(a) {
    var c = "Warning: " + a;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  });
  function i() {
    return null;
  }
  return z2 = function(a, c) {
    var l = typeof Symbol == "function" && Symbol.iterator, d = "@@iterator";
    function u(z) {
      var H = z && (l && z[l] || z[d]);
      if (typeof H == "function")
        return H;
    }
    var f = "<<anonymous>>", p = {
      array: v("array"),
      bigint: v("bigint"),
      bool: v("boolean"),
      func: v("function"),
      number: v("number"),
      object: v("object"),
      string: v("string"),
      symbol: v("symbol"),
      any: b(),
      arrayOf: x,
      element: w(),
      elementType: S(),
      instanceOf: C,
      node: N(),
      objectOf: E,
      oneOf: _,
      oneOfType: M,
      shape: D,
      exact: k
    };
    function g(z, H) {
      return z === H ? z !== 0 || 1 / z === 1 / H : z !== z && H !== H;
    }
    function y(z, H) {
      this.message = z, this.data = H && typeof H == "object" ? H : {}, this.stack = "";
    }
    y.prototype = Error.prototype;
    function m(z) {
      if (process.env.NODE_ENV !== "production")
        var H = {}, U = 0;
      function W(K, oe, Y, ee, ae, de, ye) {
        if (ee = ee || f, de = de || Y, ye !== n) {
          if (c) {
            var G = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw G.name = "Invariant Violation", G;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var xe = ee + ":" + Y;
            !H[xe] && // Avoid spamming the console because they are often not actionable except for lib authors
            U < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + de + "` prop on `" + ee + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), H[xe] = !0, U++);
          }
        }
        return oe[Y] == null ? K ? oe[Y] === null ? new y("The " + ae + " `" + de + "` is marked as required " + ("in `" + ee + "`, but its value is `null`.")) : new y("The " + ae + " `" + de + "` is marked as required in " + ("`" + ee + "`, but its value is `undefined`.")) : null : z(oe, Y, ee, ae, de);
      }
      var Z = W.bind(null, !1);
      return Z.isRequired = W.bind(null, !0), Z;
    }
    function v(z) {
      function H(U, W, Z, K, oe, Y) {
        var ee = U[W], ae = j(ee);
        if (ae !== z) {
          var de = $(ee);
          return new y(
            "Invalid " + K + " `" + oe + "` of type " + ("`" + de + "` supplied to `" + Z + "`, expected ") + ("`" + z + "`."),
            { expectedType: z }
          );
        }
        return null;
      }
      return m(H);
    }
    function b() {
      return m(i);
    }
    function x(z) {
      function H(U, W, Z, K, oe) {
        if (typeof z != "function")
          return new y("Property `" + oe + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var Y = U[W];
        if (!Array.isArray(Y)) {
          var ee = j(Y);
          return new y("Invalid " + K + " `" + oe + "` of type " + ("`" + ee + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var ae = 0; ae < Y.length; ae++) {
          var de = z(Y, ae, Z, K, oe + "[" + ae + "]", n);
          if (de instanceof Error)
            return de;
        }
        return null;
      }
      return m(H);
    }
    function w() {
      function z(H, U, W, Z, K) {
        var oe = H[U];
        if (!a(oe)) {
          var Y = j(oe);
          return new y("Invalid " + Z + " `" + K + "` of type " + ("`" + Y + "` supplied to `" + W + "`, expected a single ReactElement."));
        }
        return null;
      }
      return m(z);
    }
    function S() {
      function z(H, U, W, Z, K) {
        var oe = H[U];
        if (!t.isValidElementType(oe)) {
          var Y = j(oe);
          return new y("Invalid " + Z + " `" + K + "` of type " + ("`" + Y + "` supplied to `" + W + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return m(z);
    }
    function C(z) {
      function H(U, W, Z, K, oe) {
        if (!(U[W] instanceof z)) {
          var Y = z.name || f, ee = L(U[W]);
          return new y("Invalid " + K + " `" + oe + "` of type " + ("`" + ee + "` supplied to `" + Z + "`, expected ") + ("instance of `" + Y + "`."));
        }
        return null;
      }
      return m(H);
    }
    function _(z) {
      if (!Array.isArray(z))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), i;
      function H(U, W, Z, K, oe) {
        for (var Y = U[W], ee = 0; ee < z.length; ee++)
          if (g(Y, z[ee]))
            return null;
        var ae = JSON.stringify(z, function(ye, G) {
          var xe = $(G);
          return xe === "symbol" ? String(G) : G;
        });
        return new y("Invalid " + K + " `" + oe + "` of value `" + String(Y) + "` " + ("supplied to `" + Z + "`, expected one of " + ae + "."));
      }
      return m(H);
    }
    function E(z) {
      function H(U, W, Z, K, oe) {
        if (typeof z != "function")
          return new y("Property `" + oe + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var Y = U[W], ee = j(Y);
        if (ee !== "object")
          return new y("Invalid " + K + " `" + oe + "` of type " + ("`" + ee + "` supplied to `" + Z + "`, expected an object."));
        for (var ae in Y)
          if (r(Y, ae)) {
            var de = z(Y, ae, Z, K, oe + "." + ae, n);
            if (de instanceof Error)
              return de;
          }
        return null;
      }
      return m(H);
    }
    function M(z) {
      if (!Array.isArray(z))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), i;
      for (var H = 0; H < z.length; H++) {
        var U = z[H];
        if (typeof U != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + F(U) + " at index " + H + "."
          ), i;
      }
      function W(Z, K, oe, Y, ee) {
        for (var ae = [], de = 0; de < z.length; de++) {
          var ye = z[de], G = ye(Z, K, oe, Y, ee, n);
          if (G == null)
            return null;
          G.data && r(G.data, "expectedType") && ae.push(G.data.expectedType);
        }
        var xe = ae.length > 0 ? ", expected one of type [" + ae.join(", ") + "]" : "";
        return new y("Invalid " + Y + " `" + ee + "` supplied to " + ("`" + oe + "`" + xe + "."));
      }
      return m(W);
    }
    function N() {
      function z(H, U, W, Z, K) {
        return A(H[U]) ? null : new y("Invalid " + Z + " `" + K + "` supplied to " + ("`" + W + "`, expected a ReactNode."));
      }
      return m(z);
    }
    function O(z, H, U, W, Z) {
      return new y(
        (z || "React class") + ": " + H + " type `" + U + "." + W + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function D(z) {
      function H(U, W, Z, K, oe) {
        var Y = U[W], ee = j(Y);
        if (ee !== "object")
          return new y("Invalid " + K + " `" + oe + "` of type `" + ee + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var ae in z) {
          var de = z[ae];
          if (typeof de != "function")
            return O(Z, K, oe, ae, $(de));
          var ye = de(Y, ae, Z, K, oe + "." + ae, n);
          if (ye)
            return ye;
        }
        return null;
      }
      return m(H);
    }
    function k(z) {
      function H(U, W, Z, K, oe) {
        var Y = U[W], ee = j(Y);
        if (ee !== "object")
          return new y("Invalid " + K + " `" + oe + "` of type `" + ee + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var ae = e({}, U[W], z);
        for (var de in ae) {
          var ye = z[de];
          if (r(z, de) && typeof ye != "function")
            return O(Z, K, oe, de, $(ye));
          if (!ye)
            return new y(
              "Invalid " + K + " `" + oe + "` key `" + de + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(U[W], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(z), null, "  ")
            );
          var G = ye(Y, de, Z, K, oe + "." + de, n);
          if (G)
            return G;
        }
        return null;
      }
      return m(H);
    }
    function A(z) {
      switch (typeof z) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !z;
        case "object":
          if (Array.isArray(z))
            return z.every(A);
          if (z === null || a(z))
            return !0;
          var H = u(z);
          if (H) {
            var U = H.call(z), W;
            if (H !== z.entries) {
              for (; !(W = U.next()).done; )
                if (!A(W.value))
                  return !1;
            } else
              for (; !(W = U.next()).done; ) {
                var Z = W.value;
                if (Z && !A(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function R(z, H) {
      return z === "symbol" ? !0 : H ? H["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && H instanceof Symbol : !1;
    }
    function j(z) {
      var H = typeof z;
      return Array.isArray(z) ? "array" : z instanceof RegExp ? "object" : R(H, z) ? "symbol" : H;
    }
    function $(z) {
      if (typeof z > "u" || z === null)
        return "" + z;
      var H = j(z);
      if (H === "object") {
        if (z instanceof Date)
          return "date";
        if (z instanceof RegExp)
          return "regexp";
      }
      return H;
    }
    function F(z) {
      var H = $(z);
      switch (H) {
        case "array":
        case "object":
          return "an " + H;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + H;
        default:
          return H;
      }
    }
    function L(z) {
      return !z.constructor || !z.constructor.name ? f : z.constructor.name;
    }
    return p.checkPropTypes = s, p.resetWarningCache = s.resetWarningCache, p.PropTypes = p, p;
  }, z2;
}
var U2, aG;
function r1t() {
  if (aG) return U2;
  aG = 1;
  var t = kB();
  function e() {
  }
  function n() {
  }
  return n.resetWarningCache = e, U2 = function() {
    function r(i, a, c, l, d, u) {
      if (u !== t) {
        var f = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw f.name = "Invariant Violation", f;
      }
    }
    r.isRequired = r;
    function s() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: s,
      element: r,
      elementType: r,
      instanceOf: s,
      node: r,
      objectOf: s,
      oneOf: s,
      oneOfType: s,
      shape: s,
      exact: s,
      checkPropTypes: n,
      resetWarningCache: e
    };
    return o.PropTypes = o, o;
  }, U2;
}
if (process.env.NODE_ENV !== "production") {
  var s1t = tve(), o1t = !0;
  u$.exports = n1t()(s1t.isElement, o1t);
} else
  u$.exports = r1t()();
var i1t = u$.exports;
const je = /* @__PURE__ */ Wr(i1t);
var xP = "milliseconds", t0 = "seconds", n0 = "minutes", r0 = "hours", qp = "day", Ny = "week", s0 = "month", Xp = "year", Zp = "decade", Qp = "century", rve = {
  milliseconds: 1,
  seconds: 1e3,
  minutes: 60 * 1e3,
  hours: 60 * 60 * 1e3,
  day: 24 * 60 * 60 * 1e3,
  week: 7 * 24 * 60 * 60 * 1e3
}, a1t = {
  month: 1,
  year: 12,
  decade: 10 * 12,
  century: 100 * 12
};
function c1t(t) {
  return [31, l1t(t), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
}
function l1t(t) {
  return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0 ? 29 : 28;
}
function cl(t, e, n) {
  switch (t = new Date(t), n) {
    case xP:
    case t0:
    case n0:
    case r0:
    case qp:
    case Ny:
      return d1t(t, e * rve[n]);
    case s0:
    case Xp:
    case Zp:
    case Qp:
      return u1t(t, e * a1t[n]);
  }
  throw new TypeError('Invalid units: "' + n + '"');
}
function d1t(t, e) {
  var n = new Date(+t + e);
  return f1t(t, n);
}
function u1t(t, e) {
  var n = t.getFullYear(), r = t.getMonth(), s = t.getDate(), o = n * 12 + r + e, i = Math.trunc(o / 12), a = o % 12, c = Math.min(s, c1t(i)[a]), l = new Date(t);
  return l.setFullYear(i), l.setDate(1), l.setMonth(a), l.setDate(c), l;
}
function f1t(t, e) {
  var n = t.getTimezoneOffset(), r = e.getTimezoneOffset(), s = r - n;
  return new Date(+e + s * rve.minutes);
}
function o0(t, e, n) {
  return cl(t, -e, n);
}
function lo(t, e, n) {
  switch (t = new Date(t), e) {
    case Qp:
    case Zp:
    case Xp:
      t = SP(t, 0);
    case s0:
      t = cve(t, 1);
    case Ny:
    case qp:
      t = c0(t, 0);
    case r0:
      t = jy(t, 0);
    case n0:
      t = a0(t, 0);
    case t0:
      t = i0(t, 0);
  }
  return e === Zp && (t = o0(t, Jp(t) % 10, "year")), e === Qp && (t = o0(t, Jp(t) % 100, "year")), e === Ny && (t = lve(t, 0, n)), t;
}
function wP(t, e, n) {
  switch (t = new Date(t), t = lo(t, e, n), e) {
    case Qp:
    case Zp:
    case Xp:
    case s0:
    case Ny:
      t = cl(t, 1, e), t = o0(t, 1, qp), t.setHours(23, 59, 59, 999);
      break;
    case qp:
      t.setHours(23, 59, 59, 999);
      break;
    case r0:
    case n0:
    case t0:
      t = cl(t, 1, e), t = o0(t, 1, xP);
  }
  return t;
}
var Sv = _v(function(t, e) {
  return t === e;
}), AB = _v(function(t, e) {
  return t !== e;
}), fA = _v(function(t, e) {
  return t > e;
}), jS = _v(function(t, e) {
  return t >= e;
}), MB = _v(function(t, e) {
  return t < e;
}), Cv = _v(function(t, e) {
  return t <= e;
});
function sve() {
  return new Date(Math.min.apply(Math, arguments));
}
function ove() {
  return new Date(Math.max.apply(Math, arguments));
}
function ive(t, e, n, r) {
  return r = r || "day", (!e || jS(t, e, r)) && (!n || Cv(t, n, r));
}
var i0 = fh("Milliseconds"), a0 = fh("Seconds"), jy = fh("Minutes"), c0 = fh("Hours"), ave = fh("Day"), cve = fh("Date"), SP = fh("Month"), Jp = fh("FullYear");
function h1t(t, e) {
  return e === void 0 ? Jp(lo(t, Zp)) : cl(t, e + 10, Xp);
}
function p1t(t, e) {
  return e === void 0 ? Jp(lo(t, Qp)) : cl(t, e + 100, Xp);
}
function lve(t, e, n) {
  var r = (ave(t) + 7 - (n || 0)) % 7;
  return e === void 0 ? r : cl(t, e - r, qp);
}
function g1t(t, e, n, r) {
  var s, o, i;
  switch (n) {
    case xP:
    case t0:
    case n0:
    case r0:
    case qp:
    case Ny:
      s = e.getTime() - t.getTime();
      break;
    case s0:
    case Xp:
    case Zp:
    case Qp:
      s = (Jp(e) - Jp(t)) * 12 + SP(e) - SP(t);
      break;
    default:
      throw new TypeError('Invalid units: "' + n + '"');
  }
  switch (n) {
    case xP:
      o = 1;
      break;
    case t0:
      o = 1e3;
      break;
    case n0:
      o = 1e3 * 60;
      break;
    case r0:
      o = 1e3 * 60 * 60;
      break;
    case qp:
      o = 1e3 * 60 * 60 * 24;
      break;
    case Ny:
      o = 1e3 * 60 * 60 * 24 * 7;
      break;
    case s0:
      o = 1;
      break;
    case Xp:
      o = 12;
      break;
    case Zp:
      o = 120;
      break;
    case Qp:
      o = 1200;
      break;
    default:
      throw new TypeError('Invalid units: "' + n + '"');
  }
  return i = s / o, r ? i : Math.round(i);
}
function fh(t) {
  var e = function(n) {
    switch (n) {
      case "Milliseconds":
        return 36e5;
      case "Seconds":
        return 3600;
      case "Minutes":
        return 60;
      case "Hours":
        return 1;
      default:
        return null;
    }
  }(t);
  return function(n, r) {
    if (r === void 0)
      return n["get" + t]();
    var s = new Date(n);
    return s["set" + t](r), e && s["get" + t]() != r && (t === "Hours" || r >= e && s.getHours() - n.getHours() < Math.floor(r / e)) && s["set" + t](r + e), s;
  };
}
function _v(t) {
  return function(e, n, r) {
    return t(+lo(e, r), +lo(n, r));
  };
}
const cG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: cl,
  century: p1t,
  date: cve,
  day: ave,
  decade: h1t,
  diff: g1t,
  endOf: wP,
  eq: Sv,
  gt: fA,
  gte: jS,
  hours: c0,
  inRange: ive,
  lt: MB,
  lte: Cv,
  max: ove,
  milliseconds: i0,
  min: sve,
  minutes: jy,
  month: SP,
  neq: AB,
  seconds: a0,
  startOf: lo,
  subtract: o0,
  weekday: lve,
  year: Jp
}, Symbol.toStringTag, { value: "Module" }));
function m1t(t) {
  if (Array.isArray(t)) return d$(t);
}
function dve(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function y1t() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function L_(t) {
  return m1t(t) || dve(t) || IB(t) || y1t();
}
function v1t(t, e, n) {
  var r = -1, s = t.length;
  e < 0 && (e = -e > s ? 0 : s + e), n = n > s ? s : n, n < 0 && (n += s), s = e > n ? 0 : n - e >>> 0, e >>>= 0;
  for (var o = Array(s); ++r < s; )
    o[r] = t[r + e];
  return o;
}
var uve = v1t;
function b1t(t, e) {
  return t === e || t !== t && e !== e;
}
var RS = b1t, x1t = typeof yn == "object" && yn && yn.Object === Object && yn, fve = x1t, w1t = fve, S1t = typeof self == "object" && self && self.Object === Object && self, C1t = w1t || S1t || Function("return this")(), ld = C1t, _1t = ld, E1t = _1t.Symbol, Ev = E1t, lG = Ev, hve = Object.prototype, T1t = hve.hasOwnProperty, P1t = hve.toString, bb = lG ? lG.toStringTag : void 0;
function I1t(t) {
  var e = T1t.call(t, bb), n = t[bb];
  try {
    t[bb] = void 0;
    var r = !0;
  } catch {
  }
  var s = P1t.call(t);
  return r && (e ? t[bb] = n : delete t[bb]), s;
}
var k1t = I1t, A1t = Object.prototype, M1t = A1t.toString;
function O1t(t) {
  return M1t.call(t);
}
var D1t = O1t, dG = Ev, N1t = k1t, j1t = D1t, R1t = "[object Null]", $1t = "[object Undefined]", uG = dG ? dG.toStringTag : void 0;
function L1t(t) {
  return t == null ? t === void 0 ? $1t : R1t : uG && uG in Object(t) ? N1t(t) : j1t(t);
}
var Tv = L1t;
function F1t(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Cu = F1t, B1t = Tv, z1t = Cu, U1t = "[object AsyncFunction]", H1t = "[object Function]", V1t = "[object GeneratorFunction]", W1t = "[object Proxy]";
function K1t(t) {
  if (!z1t(t))
    return !1;
  var e = B1t(t);
  return e == H1t || e == V1t || e == U1t || e == W1t;
}
var OB = K1t, G1t = 9007199254740991;
function Y1t(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= G1t;
}
var DB = Y1t, q1t = OB, X1t = DB;
function Z1t(t) {
  return t != null && X1t(t.length) && !q1t(t);
}
var $S = Z1t, Q1t = 9007199254740991, J1t = /^(?:0|[1-9]\d*)$/;
function eCt(t, e) {
  var n = typeof t;
  return e = e ?? Q1t, !!e && (n == "number" || n != "symbol" && J1t.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
var NB = eCt, tCt = RS, nCt = $S, rCt = NB, sCt = Cu;
function oCt(t, e, n) {
  if (!sCt(n))
    return !1;
  var r = typeof e;
  return (r == "number" ? nCt(n) && rCt(e, n.length) : r == "string" && e in n) ? tCt(n[e], t) : !1;
}
var hA = oCt, iCt = /\s/;
function aCt(t) {
  for (var e = t.length; e-- && iCt.test(t.charAt(e)); )
    ;
  return e;
}
var cCt = aCt, lCt = cCt, dCt = /^\s+/;
function uCt(t) {
  return t && t.slice(0, lCt(t) + 1).replace(dCt, "");
}
var fCt = uCt;
function hCt(t) {
  return t != null && typeof t == "object";
}
var hh = hCt, pCt = Tv, gCt = hh, mCt = "[object Symbol]";
function yCt(t) {
  return typeof t == "symbol" || gCt(t) && pCt(t) == mCt;
}
var LS = yCt, vCt = fCt, fG = Cu, bCt = LS, hG = NaN, xCt = /^[-+]0x[0-9a-f]+$/i, wCt = /^0b[01]+$/i, SCt = /^0o[0-7]+$/i, CCt = parseInt;
function _Ct(t) {
  if (typeof t == "number")
    return t;
  if (bCt(t))
    return hG;
  if (fG(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = fG(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = vCt(t);
  var n = wCt.test(t);
  return n || SCt.test(t) ? CCt(t.slice(2), n ? 2 : 8) : xCt.test(t) ? hG : +t;
}
var ECt = _Ct, TCt = ECt, pG = 1 / 0, PCt = 17976931348623157e292;
function ICt(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = TCt(t), t === pG || t === -pG) {
    var e = t < 0 ? -1 : 1;
    return e * PCt;
  }
  return t === t ? t : 0;
}
var pve = ICt, kCt = pve;
function ACt(t) {
  var e = kCt(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
var gve = ACt, MCt = uve, OCt = hA, DCt = gve, NCt = Math.ceil, jCt = Math.max;
function RCt(t, e, n) {
  (n ? OCt(t, e, n) : e === void 0) ? e = 1 : e = jCt(DCt(e), 0);
  var r = t == null ? 0 : t.length;
  if (!r || e < 1)
    return [];
  for (var s = 0, o = 0, i = Array(NCt(r / e)); s < r; )
    i[o++] = MCt(t, s, s += e);
  return i;
}
var $Ct = RCt;
const LCt = /* @__PURE__ */ Wr($Ct);
function FS(t) {
  return t && t.ownerDocument || document;
}
function FCt(t) {
  var e = FS(t);
  return e && e.defaultView || window;
}
function BCt(t, e) {
  return FCt(t).getComputedStyle(t, e);
}
var zCt = /([A-Z])/g;
function UCt(t) {
  return t.replace(zCt, "-$1").toLowerCase();
}
var HCt = /^ms-/;
function PC(t) {
  return UCt(t).replace(HCt, "-ms-");
}
var VCt = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;
function WCt(t) {
  return !!(t && VCt.test(t));
}
function om(t, e) {
  var n = "", r = "";
  if (typeof e == "string")
    return t.style.getPropertyValue(PC(e)) || BCt(t).getPropertyValue(PC(e));
  Object.keys(e).forEach(function(s) {
    var o = e[s];
    !o && o !== 0 ? t.style.removeProperty(PC(s)) : WCt(s) ? r += s + "(" + o + ") " : n += PC(s) + ": " + o + ";";
  }), r && (n += "transform: " + r + ";"), t.style.cssText += ";" + n;
}
function l0(t, e) {
  if (t.contains) return t.contains(e);
  if (t.compareDocumentPosition) return t === e || !!(t.compareDocumentPosition(e) & 16);
}
function KCt(t) {
  return "nodeType" in t && t.nodeType === document.DOCUMENT_NODE;
}
function jB(t) {
  return "window" in t && t.window === t ? t : KCt(t) && t.defaultView || !1;
}
function mve(t) {
  var e = t === "pageXOffset" ? "scrollLeft" : "scrollTop";
  function n(r, s) {
    var o = jB(r);
    if (s === void 0)
      return o ? o[t] : r[e];
    o ? o.scrollTo(o[t], s) : r[e] = s;
  }
  return n;
}
const yve = mve("pageXOffset"), vve = mve("pageYOffset");
function gp(t) {
  var e = FS(t), n = {
    top: 0,
    left: 0,
    height: 0,
    width: 0
  }, r = e && e.documentElement;
  return !r || !l0(r, t) || (t.getBoundingClientRect !== void 0 && (n = t.getBoundingClientRect()), n = {
    top: n.top + vve(r) - (r.clientTop || 0),
    left: n.left + yve(r) - (r.clientLeft || 0),
    width: n.width,
    height: n.height
  }), n;
}
var GCt = function(e) {
  return !!e && "offsetParent" in e;
};
function YCt(t) {
  for (var e = FS(t), n = t && t.offsetParent; GCt(n) && n.nodeName !== "HTML" && om(n, "position") === "static"; )
    n = n.offsetParent;
  return n || e.documentElement;
}
var qCt = function(e) {
  return e.nodeName && e.nodeName.toLowerCase();
};
function bve(t, e) {
  var n = {
    top: 0,
    left: 0
  }, r;
  if (om(t, "position") === "fixed")
    r = t.getBoundingClientRect();
  else {
    var s = e || YCt(t);
    r = gp(t), qCt(s) !== "html" && (n = gp(s));
    var o = String(om(s, "borderTopWidth") || 0);
    n.top += parseInt(o, 10) - vve(s) || 0;
    var i = String(om(s, "borderLeftWidth") || 0);
    n.left += parseInt(i, 10) - yve(s) || 0;
  }
  var a = String(om(t, "marginTop") || 0), c = String(om(t, "marginLeft") || 0);
  return Rn({}, r, {
    top: r.top - n.top - (parseInt(a, 10) || 0),
    left: r.left - n.left - (parseInt(c, 10) || 0)
  });
}
const RB = !!(typeof window < "u" && window.document && window.document.createElement);
var gG = (/* @__PURE__ */ new Date()).getTime();
function XCt(t) {
  var e = (/* @__PURE__ */ new Date()).getTime(), n = Math.max(0, 16 - (e - gG)), r = setTimeout(t, n);
  return gG = e, r;
}
var ZCt = ["", "webkit", "moz", "o", "ms"], f$ = "clearTimeout", h$ = XCt, mG = function(e, n) {
  return e + (e ? n[0].toUpperCase() + n.substr(1) : n) + "AnimationFrame";
};
RB && ZCt.some(function(t) {
  var e = mG(t, "request");
  return e in window && (f$ = mG(t, "cancel"), h$ = function(r) {
    return window[e](r);
  }), !!h$;
});
var yG = function(e) {
  typeof window[f$] == "function" && window[f$](e);
}, xve = h$, H2;
function QCt(t, e) {
  if (!H2) {
    var n = document.body, r = n.matches || n.matchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector || n.msMatchesSelector;
    H2 = function(o, i) {
      return r.call(o, i);
    };
  }
  return H2(t, e);
}
var JCt = Function.prototype.bind.call(Function.prototype.call, [].slice);
function e_t(t, e) {
  return JCt(t.querySelectorAll(e));
}
var p$ = !1, g$ = !1;
try {
  var V2 = {
    get passive() {
      return p$ = !0;
    },
    get once() {
      return g$ = p$ = !0;
    }
  };
  RB && (window.addEventListener("test", V2, V2), window.removeEventListener("test", V2, !0));
} catch {
}
function t_t(t, e, n, r) {
  if (r && typeof r != "boolean" && !g$) {
    var s = r.once, o = r.capture, i = n;
    !g$ && s && (i = n.__once || function a(c) {
      this.removeEventListener(e, a, o), n.call(this, c);
    }, n.__once = i), t.addEventListener(e, i, p$ ? r : o);
  }
  t.addEventListener(e, n, r);
}
function n_t(t) {
  const e = fe(t);
  return me(() => {
    e.current = t;
  }, [t]), e;
}
function vG(t) {
  const e = n_t(t);
  return re(function(...n) {
    return e.current && e.current(...n);
  }, [e]);
}
function bG() {
  return he(null);
}
function r_t() {
  const t = fe(!0), e = fe(() => t.current);
  return me(() => (t.current = !0, () => {
    t.current = !1;
  }), []), e.current;
}
function s_t(t) {
  const e = r_t();
  return [t[0], re((n) => {
    if (e())
      return t[1](n);
  }, [e, t[1]])];
}
var o_t = jrt({
  defaultModifiers: [vrt, Crt, rrt, ort, wrt, mrt, Trt, Jnt]
}), xG = function(e) {
  return {
    position: e,
    top: "0",
    left: "0",
    opacity: "0",
    pointerEvents: "none"
  };
}, i_t = {
  name: "applyStyles",
  enabled: !1
}, a_t = {
  name: "ariaDescribedBy",
  enabled: !0,
  phase: "afterWrite",
  effect: function(e) {
    var n = e.state;
    return function() {
      var r = n.elements, s = r.reference, o = r.popper;
      if ("removeAttribute" in s) {
        var i = (s.getAttribute("aria-describedby") || "").split(",").filter(function(a) {
          return a.trim() !== o.id;
        });
        i.length ? s.setAttribute("aria-describedby", i.join(",")) : s.removeAttribute("aria-describedby");
      }
    };
  },
  fn: function(e) {
    var n, r = e.state, s = r.elements, o = s.popper, i = s.reference, a = (n = o.getAttribute("role")) == null ? void 0 : n.toLowerCase();
    if (o.id && a === "tooltip" && "setAttribute" in i) {
      var c = i.getAttribute("aria-describedby");
      if (c && c.split(",").indexOf(o.id) !== -1)
        return;
      i.setAttribute("aria-describedby", c ? c + "," + o.id : o.id);
    }
  }
}, c_t = [];
function l_t(t, e, n) {
  var r = n === void 0 ? {} : n, s = r.enabled, o = s === void 0 ? !0 : s, i = r.placement, a = i === void 0 ? "bottom" : i, c = r.strategy, l = c === void 0 ? "absolute" : c, d = r.modifiers, u = d === void 0 ? c_t : d, f = bv(r, ["enabled", "placement", "strategy", "modifiers"]), p = fe(), g = re(function() {
    var w;
    (w = p.current) == null || w.update();
  }, []), y = re(function() {
    var w;
    (w = p.current) == null || w.forceUpdate();
  }, []), m = s_t(he({
    placement: a,
    update: g,
    forceUpdate: y,
    attributes: {},
    styles: {
      popper: xG(l),
      arrow: {}
    }
  })), v = m[0], b = m[1], x = Ke(function() {
    return {
      name: "updateStateModifier",
      enabled: !0,
      phase: "write",
      requires: ["computeStyles"],
      fn: function(S) {
        var C = S.state, _ = {}, E = {};
        Object.keys(C.elements).forEach(function(M) {
          _[M] = C.styles[M], E[M] = C.attributes[M];
        }), b({
          state: C,
          styles: _,
          attributes: E,
          update: g,
          forceUpdate: y,
          placement: C.placement
        });
      }
    };
  }, [g, y, b]);
  return me(function() {
    !p.current || !o || p.current.setOptions({
      placement: a,
      strategy: l,
      modifiers: [].concat(u, [x, i_t])
    });
  }, [l, a, x, o]), me(function() {
    if (!(!o || t == null || e == null))
      return p.current = o_t(t, e, Rn({}, f, {
        placement: a,
        strategy: l,
        modifiers: [].concat(u, [a_t, x])
      })), function() {
        p.current != null && (p.current.destroy(), p.current = void 0, b(function(w) {
          return Rn({}, w, {
            attributes: {},
            styles: {
              popper: xG(l)
            }
          });
        }));
      };
  }, [o, t, e]), v;
}
function d_t(t, e, n, r) {
  var s = r && typeof r != "boolean" ? r.capture : r;
  t.removeEventListener(e, n, s), n.__once && t.removeEventListener(e, n.__once, s);
}
function rx(t, e, n, r) {
  return t_t(t, e, n, r), function() {
    d_t(t, e, n, r);
  };
}
var u_t = process.env.NODE_ENV !== "production", wve = function() {
};
if (u_t) {
  var f_t = function(e, n) {
    var r = arguments.length;
    n = new Array(r > 1 ? r - 1 : 0);
    for (var s = 1; s < r; s++)
      n[s - 1] = arguments[s];
    var o = 0, i = "Warning: " + e.replace(/%s/g, function() {
      return n[o++];
    });
    typeof console < "u" && console.error(i);
    try {
      throw new Error(i);
    } catch {
    }
  };
  wve = function(t, e, n) {
    var r = arguments.length;
    n = new Array(r > 2 ? r - 2 : 0);
    for (var s = 2; s < r; s++)
      n[s - 2] = arguments[s];
    if (e === void 0)
      throw new Error(
        "`warning(condition, format, ...args)` requires a warning message argument"
      );
    t || f_t.apply(null, [e].concat(n));
  };
}
var h_t = wve;
const p_t = /* @__PURE__ */ Wr(h_t);
function g_t(t) {
  return t && "setState" in t ? By.findDOMNode(t) : t ?? null;
}
const m_t = function(t) {
  return FS(g_t(t));
};
var y_t = 27, wG = function() {
};
function v_t(t) {
  return t.button === 0;
}
function b_t(t) {
  return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
}
var SG = function(e) {
  return e && ("current" in e ? e.current : e);
};
function x_t(t, e, n) {
  var r = n === void 0 ? {} : n, s = r.disabled, o = r.clickTrigger, i = o === void 0 ? "click" : o, a = fe(!1), c = e || wG, l = re(function(f) {
    var p, g = SG(t);
    p_t(!!g, "RootClose captured a close event but does not have a ref to compare it to. useRootClose(), should be passed a ref that resolves to a DOM node"), a.current = !g || b_t(f) || !v_t(f) || !!l0(g, (p = f.composedPath == null ? void 0 : f.composedPath()[0]) != null ? p : f.target);
  }, [t]), d = vG(function(f) {
    a.current || c(f);
  }), u = vG(function(f) {
    f.keyCode === y_t && c(f);
  });
  me(function() {
    if (!(s || t == null)) {
      var f = window.event, p = m_t(SG(t)), g = rx(p, i, l, !0), y = rx(p, i, function(b) {
        if (b === f) {
          f = void 0;
          return;
        }
        d(b);
      }), m = rx(p, "keyup", function(b) {
        if (b === f) {
          f = void 0;
          return;
        }
        u(b);
      }), v = [];
      return "ontouchstart" in p.documentElement && (v = [].slice.call(p.body.children).map(function(b) {
        return rx(b, "mousemove", wG);
      })), function() {
        g(), y(), m(), v.forEach(function(b) {
          return b();
        });
      };
    }
  }, [t, s, i, l, d, u]);
}
function w_t(t) {
  var e = {};
  return Array.isArray(t) ? (t == null || t.forEach(function(n) {
    e[n.name] = n;
  }), e) : t || e;
}
function S_t(t) {
  return t === void 0 && (t = {}), Array.isArray(t) ? t : Object.keys(t).map(function(e) {
    return t[e].name = e, t[e];
  });
}
function C_t(t) {
  var e, n, r, s, o = t.enabled, i = t.enableEvents, a = t.placement, c = t.flip, l = t.offset, d = t.fixed, u = t.containerPadding, f = t.arrowElement, p = t.popperConfig, g = p === void 0 ? {} : p, y = w_t(g.modifiers);
  return Rn({}, g, {
    placement: a,
    enabled: o,
    strategy: d ? "fixed" : g.strategy,
    modifiers: S_t(Rn({}, y, {
      eventListeners: {
        enabled: i
      },
      preventOverflow: Rn({}, y.preventOverflow, {
        options: u ? Rn({
          padding: u
        }, (e = y.preventOverflow) == null ? void 0 : e.options) : (n = y.preventOverflow) == null ? void 0 : n.options
      }),
      offset: {
        options: Rn({
          offset: l
        }, (r = y.offset) == null ? void 0 : r.options)
      },
      arrow: Rn({}, y.arrow, {
        enabled: !!f,
        options: Rn({}, (s = y.arrow) == null ? void 0 : s.options, {
          element: f
        })
      }),
      flip: Rn({
        enabled: !!c
      }, y.flip)
    }))
  });
}
function __t(t, e) {
  return t.classList ? t.classList.contains(e) : (" " + (t.className.baseVal || t.className) + " ").indexOf(" " + e + " ") !== -1;
}
function E_t(t, e) {
  t.classList ? t.classList.add(e) : __t(t, e) || (typeof t.className == "string" ? t.className = t.className + " " + e : t.setAttribute("class", (t.className && t.className.baseVal || "") + " " + e));
}
function CG(t, e) {
  return t.replace(new RegExp("(^|\\s)" + e + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function T_t(t, e) {
  t.classList ? t.classList.remove(e) : typeof t.className == "string" ? t.className = CG(t.className, e) : t.setAttribute("class", CG(t.className && t.className.baseVal || "", e));
}
var IC;
function $B(t) {
  if ((!IC && IC !== 0 || t) && RB) {
    var e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "-9999px", e.style.width = "50px", e.style.height = "50px", e.style.overflow = "scroll", document.body.appendChild(e), IC = e.offsetWidth - e.clientWidth, document.body.removeChild(e);
  }
  return IC;
}
var W2 = function(e) {
  var n;
  return typeof document > "u" ? null : e == null ? FS().body : (typeof e == "function" && (e = e()), e && "current" in e && (e = e.current), (n = e) != null && n.nodeType && e || null);
};
function _G(t, e) {
  var n = he(function() {
    return W2(t);
  }), r = n[0], s = n[1];
  if (!r) {
    var o = W2(t);
    o && s(o);
  }
  return me(function() {
  }, [e, r]), me(function() {
    var i = W2(t);
    i !== r && s(i);
  }, [t, r]), r;
}
const EG = (t) => !t || typeof t == "function" ? t : (e) => {
  t.current = e;
};
function P_t(t, e) {
  const n = EG(t), r = EG(e);
  return (s) => {
    n && n(s), r && r(s);
  };
}
function I_t(t, e) {
  return Ke(() => P_t(t, e), [t, e]);
}
var LB = /* @__PURE__ */ B.forwardRef(function(t, e) {
  var n = t.flip, r = t.offset, s = t.placement, o = t.containerPadding, i = o === void 0 ? 5 : o, a = t.popperConfig, c = a === void 0 ? {} : a, l = t.transition, d = bG(), u = d[0], f = d[1], p = bG(), g = p[0], y = p[1], m = I_t(f, e), v = _G(t.container), b = _G(t.target), x = he(!t.show), w = x[0], S = x[1], C = l_t(b, u, C_t({
    placement: s,
    enableEvents: !!t.show,
    containerPadding: i || 5,
    flip: n,
    offset: r,
    arrowElement: g,
    popperConfig: c
  })), _ = C.styles, E = C.attributes, M = bv(C, ["styles", "attributes"]);
  t.show ? w && S(!1) : !t.transition && !w && S(!0);
  var N = function() {
    S(!0), t.onExited && t.onExited.apply(t, arguments);
  }, O = t.show || l && !w;
  if (x_t(u, t.onHide, {
    disabled: !t.rootClose || t.rootCloseDisabled,
    clickTrigger: t.rootCloseEvent
  }), !O)
    return null;
  var D = t.children(Rn({}, M, {
    show: !!t.show,
    props: Rn({}, E.popper, {
      style: _.popper,
      ref: m
    }),
    arrowProps: Rn({}, E.arrow, {
      style: _.arrow,
      ref: y
    })
  }));
  if (l) {
    var k = t.onExit, A = t.onExiting, R = t.onEnter, j = t.onEntering, $ = t.onEntered;
    D = /* @__PURE__ */ B.createElement(l, {
      in: t.show,
      appear: !0,
      onExit: k,
      onExiting: A,
      onExited: N,
      onEnter: R,
      onEntering: j,
      onEntered: $
    }, D);
  }
  return v ? /* @__PURE__ */ By.createPortal(D, v) : null;
});
LB.displayName = "Overlay";
LB.propTypes = {
  /**
   * Set the visibility of the Overlay
   */
  show: je.bool,
  /** Specify where the overlay element is positioned in relation to the target element */
  placement: je.oneOf(u4),
  /**
   * A DOM Element, Ref to an element, or function that returns either. The `target` element is where
   * the overlay is positioned relative to.
   */
  target: je.any,
  /**
   * A DOM Element, Ref to an element, or function that returns either. The `container` will have the Portal children
   * appended to it.
   */
  container: je.any,
  /**
   * Enables the Popper.js `flip` modifier, allowing the Overlay to
   * automatically adjust it's placement in case of overlap with the viewport or toggle.
   * Refer to the [flip docs](https://popper.js.org/popper-documentation.html#modifiers..flip.enabled) for more info
   */
  flip: je.bool,
  /**
   * A render prop that returns an element to overlay and position. See
   * the [react-popper documentation](https://github.com/FezVrasta/react-popper#children) for more info.
   *
   * @type {Function ({
   *   show: boolean,
   *   placement: Placement,
   *   update: () => void,
   *   forceUpdate: () => void,
   *   props: {
   *     ref: (?HTMLElement) => void,
   *     style: { [string]: string | number },
   *     aria-labelledby: ?string
   *     [string]: string | number,
   *   },
   *   arrowProps: {
   *     ref: (?HTMLElement) => void,
   *     style: { [string]: string | number },
   *     [string]: string | number,
   *   },
   * }) => React.Element}
   */
  children: je.func.isRequired,
  /**
   * Control how much space there is between the edge of the boundary element and overlay.
   * A convenience shortcut to setting `popperConfig.modfiers.preventOverflow.padding`
   */
  containerPadding: je.number,
  /**
   * A set of popper options and props passed directly to react-popper's Popper component.
   */
  popperConfig: je.object,
  /**
   * Specify whether the overlay should trigger `onHide` when the user clicks outside the overlay
   */
  rootClose: je.bool,
  /**
   * Specify event for toggling overlay
   */
  rootCloseEvent: je.oneOf(["click", "mousedown"]),
  /**
   * Specify disabled for disable RootCloseWrapper
   */
  rootCloseDisabled: je.bool,
  /**
   * A Callback fired by the Overlay when it wishes to be hidden.
   *
   * __required__ when `rootClose` is `true`.
   *
   * @type func
   */
  onHide: function(e) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      r[s - 1] = arguments[s];
    if (e.rootClose) {
      var o;
      return (o = je.func).isRequired.apply(o, [e].concat(r));
    }
    return je.func.apply(je, [e].concat(r));
  },
  /**
   * A `react-transition-group@2.0.0` `<Transition/>` component
   * used to animate the overlay as it changes visibility.
   */
  // @ts-ignore
  transition: je.elementType,
  /**
   * Callback fired before the Overlay transitions in
   */
  onEnter: je.func,
  /**
   * Callback fired as the Overlay begins to transition in
   */
  onEntering: je.func,
  /**
   * Callback fired after the Overlay finishes transitioning in
   */
  onEntered: je.func,
  /**
   * Callback fired right before the Overlay transitions out
   */
  onExit: je.func,
  /**
   * Callback fired as the Overlay begins to transition out
   */
  onExiting: je.func,
  /**
   * Callback fired after the Overlay finishes transitioning out
   */
  onExited: je.func
};
function k_t() {
  this.__data__ = [], this.size = 0;
}
var A_t = k_t, M_t = RS;
function O_t(t, e) {
  for (var n = t.length; n--; )
    if (M_t(t[n][0], e))
      return n;
  return -1;
}
var pA = O_t, D_t = pA, N_t = Array.prototype, j_t = N_t.splice;
function R_t(t) {
  var e = this.__data__, n = D_t(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : j_t.call(e, n, 1), --this.size, !0;
}
var $_t = R_t, L_t = pA;
function F_t(t) {
  var e = this.__data__, n = L_t(e, t);
  return n < 0 ? void 0 : e[n][1];
}
var B_t = F_t, z_t = pA;
function U_t(t) {
  return z_t(this.__data__, t) > -1;
}
var H_t = U_t, V_t = pA;
function W_t(t, e) {
  var n = this.__data__, r = V_t(n, t);
  return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
}
var K_t = W_t, G_t = A_t, Y_t = $_t, q_t = B_t, X_t = H_t, Z_t = K_t;
function Pv(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Pv.prototype.clear = G_t;
Pv.prototype.delete = Y_t;
Pv.prototype.get = q_t;
Pv.prototype.has = X_t;
Pv.prototype.set = Z_t;
var gA = Pv, Q_t = gA;
function J_t() {
  this.__data__ = new Q_t(), this.size = 0;
}
var eEt = J_t;
function tEt(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
var nEt = tEt;
function rEt(t) {
  return this.__data__.get(t);
}
var sEt = rEt;
function oEt(t) {
  return this.__data__.has(t);
}
var iEt = oEt, aEt = ld, cEt = aEt["__core-js_shared__"], lEt = cEt, K2 = lEt, TG = function() {
  var t = /[^.]+$/.exec(K2 && K2.keys && K2.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function dEt(t) {
  return !!TG && TG in t;
}
var uEt = dEt, fEt = Function.prototype, hEt = fEt.toString;
function pEt(t) {
  if (t != null) {
    try {
      return hEt.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var Sve = pEt, gEt = OB, mEt = uEt, yEt = Cu, vEt = Sve, bEt = /[\\^$.*+?()[\]{}|]/g, xEt = /^\[object .+?Constructor\]$/, wEt = Function.prototype, SEt = Object.prototype, CEt = wEt.toString, _Et = SEt.hasOwnProperty, EEt = RegExp(
  "^" + CEt.call(_Et).replace(bEt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function TEt(t) {
  if (!yEt(t) || mEt(t))
    return !1;
  var e = gEt(t) ? EEt : xEt;
  return e.test(vEt(t));
}
var PEt = TEt;
function IEt(t, e) {
  return t == null ? void 0 : t[e];
}
var kEt = IEt, AEt = PEt, MEt = kEt;
function OEt(t, e) {
  var n = MEt(t, e);
  return AEt(n) ? n : void 0;
}
var wg = OEt, DEt = wg, NEt = ld, jEt = DEt(NEt, "Map"), FB = jEt, REt = wg, $Et = REt(Object, "create"), mA = $Et, PG = mA;
function LEt() {
  this.__data__ = PG ? PG(null) : {}, this.size = 0;
}
var FEt = LEt;
function BEt(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var zEt = BEt, UEt = mA, HEt = "__lodash_hash_undefined__", VEt = Object.prototype, WEt = VEt.hasOwnProperty;
function KEt(t) {
  var e = this.__data__;
  if (UEt) {
    var n = e[t];
    return n === HEt ? void 0 : n;
  }
  return WEt.call(e, t) ? e[t] : void 0;
}
var GEt = KEt, YEt = mA, qEt = Object.prototype, XEt = qEt.hasOwnProperty;
function ZEt(t) {
  var e = this.__data__;
  return YEt ? e[t] !== void 0 : XEt.call(e, t);
}
var QEt = ZEt, JEt = mA, eTt = "__lodash_hash_undefined__";
function tTt(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = JEt && e === void 0 ? eTt : e, this;
}
var nTt = tTt, rTt = FEt, sTt = zEt, oTt = GEt, iTt = QEt, aTt = nTt;
function Iv(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Iv.prototype.clear = rTt;
Iv.prototype.delete = sTt;
Iv.prototype.get = oTt;
Iv.prototype.has = iTt;
Iv.prototype.set = aTt;
var cTt = Iv, IG = cTt, lTt = gA, dTt = FB;
function uTt() {
  this.size = 0, this.__data__ = {
    hash: new IG(),
    map: new (dTt || lTt)(),
    string: new IG()
  };
}
var fTt = uTt;
function hTt(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
var pTt = hTt, gTt = pTt;
function mTt(t, e) {
  var n = t.__data__;
  return gTt(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
var yA = mTt, yTt = yA;
function vTt(t) {
  var e = yTt(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
var bTt = vTt, xTt = yA;
function wTt(t) {
  return xTt(this, t).get(t);
}
var STt = wTt, CTt = yA;
function _Tt(t) {
  return CTt(this, t).has(t);
}
var ETt = _Tt, TTt = yA;
function PTt(t, e) {
  var n = TTt(this, t), r = n.size;
  return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
}
var ITt = PTt, kTt = fTt, ATt = bTt, MTt = STt, OTt = ETt, DTt = ITt;
function kv(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
kv.prototype.clear = kTt;
kv.prototype.delete = ATt;
kv.prototype.get = MTt;
kv.prototype.has = OTt;
kv.prototype.set = DTt;
var BB = kv, NTt = gA, jTt = FB, RTt = BB, $Tt = 200;
function LTt(t, e) {
  var n = this.__data__;
  if (n instanceof NTt) {
    var r = n.__data__;
    if (!jTt || r.length < $Tt - 1)
      return r.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new RTt(r);
  }
  return n.set(t, e), this.size = n.size, this;
}
var FTt = LTt, BTt = gA, zTt = eEt, UTt = nEt, HTt = sEt, VTt = iEt, WTt = FTt;
function Av(t) {
  var e = this.__data__ = new BTt(t);
  this.size = e.size;
}
Av.prototype.clear = zTt;
Av.prototype.delete = UTt;
Av.prototype.get = HTt;
Av.prototype.has = VTt;
Av.prototype.set = WTt;
var zB = Av, KTt = "__lodash_hash_undefined__";
function GTt(t) {
  return this.__data__.set(t, KTt), this;
}
var YTt = GTt;
function qTt(t) {
  return this.__data__.has(t);
}
var XTt = qTt, ZTt = BB, QTt = YTt, JTt = XTt;
function CP(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new ZTt(); ++e < n; )
    this.add(t[e]);
}
CP.prototype.add = CP.prototype.push = QTt;
CP.prototype.has = JTt;
var ePt = CP;
function tPt(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
var nPt = tPt;
function rPt(t, e) {
  return t.has(e);
}
var sPt = rPt, oPt = ePt, iPt = nPt, aPt = sPt, cPt = 1, lPt = 2;
function dPt(t, e, n, r, s, o) {
  var i = n & cPt, a = t.length, c = e.length;
  if (a != c && !(i && c > a))
    return !1;
  var l = o.get(t), d = o.get(e);
  if (l && d)
    return l == e && d == t;
  var u = -1, f = !0, p = n & lPt ? new oPt() : void 0;
  for (o.set(t, e), o.set(e, t); ++u < a; ) {
    var g = t[u], y = e[u];
    if (r)
      var m = i ? r(y, g, u, e, t, o) : r(g, y, u, t, e, o);
    if (m !== void 0) {
      if (m)
        continue;
      f = !1;
      break;
    }
    if (p) {
      if (!iPt(e, function(v, b) {
        if (!aPt(p, b) && (g === v || s(g, v, n, r, o)))
          return p.push(b);
      })) {
        f = !1;
        break;
      }
    } else if (!(g === y || s(g, y, n, r, o))) {
      f = !1;
      break;
    }
  }
  return o.delete(t), o.delete(e), f;
}
var Cve = dPt, uPt = ld, fPt = uPt.Uint8Array, _ve = fPt;
function hPt(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r, s) {
    n[++e] = [s, r];
  }), n;
}
var pPt = hPt;
function gPt(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var mPt = gPt, kG = Ev, AG = _ve, yPt = RS, vPt = Cve, bPt = pPt, xPt = mPt, wPt = 1, SPt = 2, CPt = "[object Boolean]", _Pt = "[object Date]", EPt = "[object Error]", TPt = "[object Map]", PPt = "[object Number]", IPt = "[object RegExp]", kPt = "[object Set]", APt = "[object String]", MPt = "[object Symbol]", OPt = "[object ArrayBuffer]", DPt = "[object DataView]", MG = kG ? kG.prototype : void 0, G2 = MG ? MG.valueOf : void 0;
function NPt(t, e, n, r, s, o, i) {
  switch (n) {
    case DPt:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case OPt:
      return !(t.byteLength != e.byteLength || !o(new AG(t), new AG(e)));
    case CPt:
    case _Pt:
    case PPt:
      return yPt(+t, +e);
    case EPt:
      return t.name == e.name && t.message == e.message;
    case IPt:
    case APt:
      return t == e + "";
    case TPt:
      var a = bPt;
    case kPt:
      var c = r & wPt;
      if (a || (a = xPt), t.size != e.size && !c)
        return !1;
      var l = i.get(t);
      if (l)
        return l == e;
      r |= SPt, i.set(t, e);
      var d = vPt(a(t), a(e), r, s, o, i);
      return i.delete(t), d;
    case MPt:
      if (G2)
        return G2.call(t) == G2.call(e);
  }
  return !1;
}
var jPt = NPt;
function RPt(t, e) {
  for (var n = -1, r = e.length, s = t.length; ++n < r; )
    t[s + n] = e[n];
  return t;
}
var UB = RPt, $Pt = Array.isArray, vc = $Pt, LPt = UB, FPt = vc;
function BPt(t, e, n) {
  var r = e(t);
  return FPt(t) ? r : LPt(r, n(t));
}
var Eve = BPt;
function zPt(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, s = 0, o = []; ++n < r; ) {
    var i = t[n];
    e(i, n, t) && (o[s++] = i);
  }
  return o;
}
var UPt = zPt;
function HPt() {
  return [];
}
var Tve = HPt, VPt = UPt, WPt = Tve, KPt = Object.prototype, GPt = KPt.propertyIsEnumerable, OG = Object.getOwnPropertySymbols, YPt = OG ? function(t) {
  return t == null ? [] : (t = Object(t), VPt(OG(t), function(e) {
    return GPt.call(t, e);
  }));
} : WPt, HB = YPt;
function qPt(t, e) {
  for (var n = -1, r = Array(t); ++n < t; )
    r[n] = e(n);
  return r;
}
var XPt = qPt, ZPt = Tv, QPt = hh, JPt = "[object Arguments]";
function eIt(t) {
  return QPt(t) && ZPt(t) == JPt;
}
var tIt = eIt, DG = tIt, nIt = hh, Pve = Object.prototype, rIt = Pve.hasOwnProperty, sIt = Pve.propertyIsEnumerable, oIt = DG(/* @__PURE__ */ function() {
  return arguments;
}()) ? DG : function(t) {
  return nIt(t) && rIt.call(t, "callee") && !sIt.call(t, "callee");
}, VB = oIt, _P = { exports: {} };
function iIt() {
  return !1;
}
var aIt = iIt;
_P.exports;
(function(t, e) {
  var n = ld, r = aIt, s = e && !e.nodeType && e, o = s && !0 && t && !t.nodeType && t, i = o && o.exports === s, a = i ? n.Buffer : void 0, c = a ? a.isBuffer : void 0, l = c || r;
  t.exports = l;
})(_P, _P.exports);
var vA = _P.exports, cIt = Tv, lIt = DB, dIt = hh, uIt = "[object Arguments]", fIt = "[object Array]", hIt = "[object Boolean]", pIt = "[object Date]", gIt = "[object Error]", mIt = "[object Function]", yIt = "[object Map]", vIt = "[object Number]", bIt = "[object Object]", xIt = "[object RegExp]", wIt = "[object Set]", SIt = "[object String]", CIt = "[object WeakMap]", _It = "[object ArrayBuffer]", EIt = "[object DataView]", TIt = "[object Float32Array]", PIt = "[object Float64Array]", IIt = "[object Int8Array]", kIt = "[object Int16Array]", AIt = "[object Int32Array]", MIt = "[object Uint8Array]", OIt = "[object Uint8ClampedArray]", DIt = "[object Uint16Array]", NIt = "[object Uint32Array]", Xn = {};
Xn[TIt] = Xn[PIt] = Xn[IIt] = Xn[kIt] = Xn[AIt] = Xn[MIt] = Xn[OIt] = Xn[DIt] = Xn[NIt] = !0;
Xn[uIt] = Xn[fIt] = Xn[_It] = Xn[hIt] = Xn[EIt] = Xn[pIt] = Xn[gIt] = Xn[mIt] = Xn[yIt] = Xn[vIt] = Xn[bIt] = Xn[xIt] = Xn[wIt] = Xn[SIt] = Xn[CIt] = !1;
function jIt(t) {
  return dIt(t) && lIt(t.length) && !!Xn[cIt(t)];
}
var RIt = jIt;
function $It(t) {
  return function(e) {
    return t(e);
  };
}
var bA = $It, EP = { exports: {} };
EP.exports;
(function(t, e) {
  var n = fve, r = e && !e.nodeType && e, s = r && !0 && t && !t.nodeType && t, o = s && s.exports === r, i = o && n.process, a = function() {
    try {
      var c = s && s.require && s.require("util").types;
      return c || i && i.binding && i.binding("util");
    } catch {
    }
  }();
  t.exports = a;
})(EP, EP.exports);
var WB = EP.exports, LIt = RIt, FIt = bA, NG = WB, jG = NG && NG.isTypedArray, BIt = jG ? FIt(jG) : LIt, KB = BIt, zIt = XPt, UIt = VB, HIt = vc, VIt = vA, WIt = NB, KIt = KB, GIt = Object.prototype, YIt = GIt.hasOwnProperty;
function qIt(t, e) {
  var n = HIt(t), r = !n && UIt(t), s = !n && !r && VIt(t), o = !n && !r && !s && KIt(t), i = n || r || s || o, a = i ? zIt(t.length, String) : [], c = a.length;
  for (var l in t)
    (e || YIt.call(t, l)) && !(i && // Safari 9 has enumerable `arguments.length` in strict mode.
    (l == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    s && (l == "offset" || l == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o && (l == "buffer" || l == "byteLength" || l == "byteOffset") || // Skip index properties.
    WIt(l, c))) && a.push(l);
  return a;
}
var Ive = qIt, XIt = Object.prototype;
function ZIt(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || XIt;
  return t === n;
}
var GB = ZIt;
function QIt(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var kve = QIt, JIt = kve, ekt = JIt(Object.keys, Object), tkt = ekt, nkt = GB, rkt = tkt, skt = Object.prototype, okt = skt.hasOwnProperty;
function ikt(t) {
  if (!nkt(t))
    return rkt(t);
  var e = [];
  for (var n in Object(t))
    okt.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
var akt = ikt, ckt = Ive, lkt = akt, dkt = $S;
function ukt(t) {
  return dkt(t) ? ckt(t) : lkt(t);
}
var BS = ukt, fkt = Eve, hkt = HB, pkt = BS;
function gkt(t) {
  return fkt(t, pkt, hkt);
}
var Ave = gkt, RG = Ave, mkt = 1, ykt = Object.prototype, vkt = ykt.hasOwnProperty;
function bkt(t, e, n, r, s, o) {
  var i = n & mkt, a = RG(t), c = a.length, l = RG(e), d = l.length;
  if (c != d && !i)
    return !1;
  for (var u = c; u--; ) {
    var f = a[u];
    if (!(i ? f in e : vkt.call(e, f)))
      return !1;
  }
  var p = o.get(t), g = o.get(e);
  if (p && g)
    return p == e && g == t;
  var y = !0;
  o.set(t, e), o.set(e, t);
  for (var m = i; ++u < c; ) {
    f = a[u];
    var v = t[f], b = e[f];
    if (r)
      var x = i ? r(b, v, f, e, t, o) : r(v, b, f, t, e, o);
    if (!(x === void 0 ? v === b || s(v, b, n, r, o) : x)) {
      y = !1;
      break;
    }
    m || (m = f == "constructor");
  }
  if (y && !m) {
    var w = t.constructor, S = e.constructor;
    w != S && "constructor" in t && "constructor" in e && !(typeof w == "function" && w instanceof w && typeof S == "function" && S instanceof S) && (y = !1);
  }
  return o.delete(t), o.delete(e), y;
}
var xkt = bkt, wkt = wg, Skt = ld, Ckt = wkt(Skt, "DataView"), _kt = Ckt, Ekt = wg, Tkt = ld, Pkt = Ekt(Tkt, "Promise"), Ikt = Pkt, kkt = wg, Akt = ld, Mkt = kkt(Akt, "Set"), Okt = Mkt, Dkt = wg, Nkt = ld, jkt = Dkt(Nkt, "WeakMap"), Rkt = jkt, m$ = _kt, y$ = FB, v$ = Ikt, b$ = Okt, x$ = Rkt, Mve = Tv, Mv = Sve, $G = "[object Map]", $kt = "[object Object]", LG = "[object Promise]", FG = "[object Set]", BG = "[object WeakMap]", zG = "[object DataView]", Lkt = Mv(m$), Fkt = Mv(y$), Bkt = Mv(v$), zkt = Mv(b$), Ukt = Mv(x$), Mh = Mve;
(m$ && Mh(new m$(new ArrayBuffer(1))) != zG || y$ && Mh(new y$()) != $G || v$ && Mh(v$.resolve()) != LG || b$ && Mh(new b$()) != FG || x$ && Mh(new x$()) != BG) && (Mh = function(t) {
  var e = Mve(t), n = e == $kt ? t.constructor : void 0, r = n ? Mv(n) : "";
  if (r)
    switch (r) {
      case Lkt:
        return zG;
      case Fkt:
        return $G;
      case Bkt:
        return LG;
      case zkt:
        return FG;
      case Ukt:
        return BG;
    }
  return e;
});
var xA = Mh, Y2 = zB, Hkt = Cve, Vkt = jPt, Wkt = xkt, UG = xA, HG = vc, VG = vA, Kkt = KB, Gkt = 1, WG = "[object Arguments]", KG = "[object Array]", kC = "[object Object]", Ykt = Object.prototype, GG = Ykt.hasOwnProperty;
function qkt(t, e, n, r, s, o) {
  var i = HG(t), a = HG(e), c = i ? KG : UG(t), l = a ? KG : UG(e);
  c = c == WG ? kC : c, l = l == WG ? kC : l;
  var d = c == kC, u = l == kC, f = c == l;
  if (f && VG(t)) {
    if (!VG(e))
      return !1;
    i = !0, d = !1;
  }
  if (f && !d)
    return o || (o = new Y2()), i || Kkt(t) ? Hkt(t, e, n, r, s, o) : Vkt(t, e, c, n, r, s, o);
  if (!(n & Gkt)) {
    var p = d && GG.call(t, "__wrapped__"), g = u && GG.call(e, "__wrapped__");
    if (p || g) {
      var y = p ? t.value() : t, m = g ? e.value() : e;
      return o || (o = new Y2()), s(y, m, n, r, o);
    }
  }
  return f ? (o || (o = new Y2()), Wkt(t, e, n, r, s, o)) : !1;
}
var Xkt = qkt, Zkt = Xkt, YG = hh;
function Ove(t, e, n, r, s) {
  return t === e ? !0 : t == null || e == null || !YG(t) && !YG(e) ? t !== t && e !== e : Zkt(t, e, n, r, Ove, s);
}
var YB = Ove, Qkt = YB;
function Jkt(t, e) {
  return Qkt(t, e);
}
var eAt = Jkt;
const tAt = /* @__PURE__ */ Wr(eAt);
function q2(t, e) {
  var n = jB(t);
  return n ? n.innerHeight : gp(t).height;
}
function Dve(t, e, n) {
  t.closest && !n && t.closest(e);
  var r = t;
  do {
    if (QCt(r, e)) return r;
    r = r.parentElement;
  } while (r && r !== n && r.nodeType === document.ELEMENT_NODE);
  return null;
}
function nAt(t, e, n, r) {
  for (var s = t.length, o = n + (r ? 1 : -1); r ? o-- : ++o < s; )
    if (e(t[o], o, t))
      return o;
  return -1;
}
var rAt = nAt, sAt = zB, oAt = YB, iAt = 1, aAt = 2;
function cAt(t, e, n, r) {
  var s = n.length, o = s, i = !r;
  if (t == null)
    return !o;
  for (t = Object(t); s--; ) {
    var a = n[s];
    if (i && a[2] ? a[1] !== t[a[0]] : !(a[0] in t))
      return !1;
  }
  for (; ++s < o; ) {
    a = n[s];
    var c = a[0], l = t[c], d = a[1];
    if (i && a[2]) {
      if (l === void 0 && !(c in t))
        return !1;
    } else {
      var u = new sAt();
      if (r)
        var f = r(l, d, c, t, e, u);
      if (!(f === void 0 ? oAt(d, l, iAt | aAt, r, u) : f))
        return !1;
    }
  }
  return !0;
}
var lAt = cAt, dAt = Cu;
function uAt(t) {
  return t === t && !dAt(t);
}
var Nve = uAt, fAt = Nve, hAt = BS;
function pAt(t) {
  for (var e = hAt(t), n = e.length; n--; ) {
    var r = e[n], s = t[r];
    e[n] = [r, s, fAt(s)];
  }
  return e;
}
var gAt = pAt;
function mAt(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
var jve = mAt, yAt = lAt, vAt = gAt, bAt = jve;
function xAt(t) {
  var e = vAt(t);
  return e.length == 1 && e[0][2] ? bAt(e[0][0], e[0][1]) : function(n) {
    return n === t || yAt(n, t, e);
  };
}
var wAt = xAt, SAt = vc, CAt = LS, _At = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, EAt = /^\w*$/;
function TAt(t, e) {
  if (SAt(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || CAt(t) ? !0 : EAt.test(t) || !_At.test(t) || e != null && t in Object(e);
}
var qB = TAt, Rve = BB, PAt = "Expected a function";
function XB(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(PAt);
  var n = function() {
    var r = arguments, s = e ? e.apply(this, r) : r[0], o = n.cache;
    if (o.has(s))
      return o.get(s);
    var i = t.apply(this, r);
    return n.cache = o.set(s, i) || o, i;
  };
  return n.cache = new (XB.Cache || Rve)(), n;
}
XB.Cache = Rve;
var IAt = XB, kAt = IAt, AAt = 500;
function MAt(t) {
  var e = kAt(t, function(r) {
    return n.size === AAt && n.clear(), r;
  }), n = e.cache;
  return e;
}
var OAt = MAt, DAt = OAt, NAt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, jAt = /\\(\\)?/g, RAt = DAt(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(NAt, function(n, r, s, o) {
    e.push(s ? o.replace(jAt, "$1") : r || n);
  }), e;
}), $At = RAt;
function LAt(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, s = Array(r); ++n < r; )
    s[n] = e(t[n], n, t);
  return s;
}
var ZB = LAt, qG = Ev, FAt = ZB, BAt = vc, zAt = LS, UAt = 1 / 0, XG = qG ? qG.prototype : void 0, ZG = XG ? XG.toString : void 0;
function $ve(t) {
  if (typeof t == "string")
    return t;
  if (BAt(t))
    return FAt(t, $ve) + "";
  if (zAt(t))
    return ZG ? ZG.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -UAt ? "-0" : e;
}
var HAt = $ve, VAt = HAt;
function WAt(t) {
  return t == null ? "" : VAt(t);
}
var KAt = WAt, GAt = vc, YAt = qB, qAt = $At, XAt = KAt;
function ZAt(t, e) {
  return GAt(t) ? t : YAt(t, e) ? [t] : qAt(XAt(t));
}
var wA = ZAt, QAt = LS, JAt = 1 / 0;
function eMt(t) {
  if (typeof t == "string" || QAt(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -JAt ? "-0" : e;
}
var zS = eMt, tMt = wA, nMt = zS;
function rMt(t, e) {
  e = tMt(e, t);
  for (var n = 0, r = e.length; t != null && n < r; )
    t = t[nMt(e[n++])];
  return n && n == r ? t : void 0;
}
var SA = rMt, sMt = SA;
function oMt(t, e, n) {
  var r = t == null ? void 0 : sMt(t, e);
  return r === void 0 ? n : r;
}
var iMt = oMt;
function aMt(t, e) {
  return t != null && e in Object(t);
}
var cMt = aMt, lMt = wA, dMt = VB, uMt = vc, fMt = NB, hMt = DB, pMt = zS;
function gMt(t, e, n) {
  e = lMt(e, t);
  for (var r = -1, s = e.length, o = !1; ++r < s; ) {
    var i = pMt(e[r]);
    if (!(o = t != null && n(t, i)))
      break;
    t = t[i];
  }
  return o || ++r != s ? o : (s = t == null ? 0 : t.length, !!s && hMt(s) && fMt(i, s) && (uMt(t) || dMt(t)));
}
var mMt = gMt, yMt = cMt, vMt = mMt;
function bMt(t, e) {
  return t != null && vMt(t, e, yMt);
}
var xMt = bMt, wMt = YB, SMt = iMt, CMt = xMt, _Mt = qB, EMt = Nve, TMt = jve, PMt = zS, IMt = 1, kMt = 2;
function AMt(t, e) {
  return _Mt(t) && EMt(e) ? TMt(PMt(t), e) : function(n) {
    var r = SMt(n, t);
    return r === void 0 && r === e ? CMt(n, t) : wMt(e, r, IMt | kMt);
  };
}
var MMt = AMt;
function OMt(t) {
  return t;
}
var CA = OMt;
function DMt(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
var NMt = DMt, jMt = SA;
function RMt(t) {
  return function(e) {
    return jMt(e, t);
  };
}
var $Mt = RMt, LMt = NMt, FMt = $Mt, BMt = qB, zMt = zS;
function UMt(t) {
  return BMt(t) ? LMt(zMt(t)) : FMt(t);
}
var HMt = UMt, VMt = wAt, WMt = MMt, KMt = CA, GMt = vc, YMt = HMt;
function qMt(t) {
  return typeof t == "function" ? t : t == null ? KMt : typeof t == "object" ? GMt(t) ? WMt(t[0], t[1]) : VMt(t) : YMt(t);
}
var _A = qMt, XMt = rAt, ZMt = _A, QMt = gve, JMt = Math.max;
function eOt(t, e, n) {
  var r = t == null ? 0 : t.length;
  if (!r)
    return -1;
  var s = n == null ? 0 : QMt(n);
  return s < 0 && (s = JMt(r + s, 0)), XMt(t, ZMt(e), s);
}
var tOt = eOt;
const nOt = /* @__PURE__ */ Wr(tOt);
var rOt = Math.ceil, sOt = Math.max;
function oOt(t, e, n, r) {
  for (var s = -1, o = sOt(rOt((e - t) / (n || 1)), 0), i = Array(o); o--; )
    i[r ? o : ++s] = t, t += n;
  return i;
}
var iOt = oOt, aOt = iOt, cOt = hA, X2 = pve;
function lOt(t) {
  return function(e, n, r) {
    return r && typeof r != "number" && cOt(e, n, r) && (n = r = void 0), e = X2(e), n === void 0 ? (n = e, e = 0) : n = X2(n), r = r === void 0 ? e < n ? 1 : -1 : X2(r), aOt(e, n, r, t);
  };
}
var dOt = lOt, uOt = dOt, fOt = uOt(), hOt = fOt;
const pOt = /* @__PURE__ */ Wr(hOt);
function w$(t, e) {
  var n = jB(t);
  return n ? n.innerWidth : gp(t).width;
}
var QG = Ev, gOt = VB, mOt = vc, JG = QG ? QG.isConcatSpreadable : void 0;
function yOt(t) {
  return mOt(t) || gOt(t) || !!(JG && t && t[JG]);
}
var vOt = yOt, bOt = UB, xOt = vOt;
function Lve(t, e, n, r, s) {
  var o = -1, i = t.length;
  for (n || (n = xOt), s || (s = []); ++o < i; ) {
    var a = t[o];
    e > 0 && n(a) ? e > 1 ? Lve(a, e - 1, n, r, s) : bOt(s, a) : r || (s[s.length] = a);
  }
  return s;
}
var Fve = Lve;
function wOt(t) {
  return function(e, n, r) {
    for (var s = -1, o = Object(e), i = r(e), a = i.length; a--; ) {
      var c = i[t ? a : ++s];
      if (n(o[c], c, o) === !1)
        break;
    }
    return e;
  };
}
var SOt = wOt, COt = SOt, _Ot = COt(), EOt = _Ot, TOt = EOt, POt = BS;
function IOt(t, e) {
  return t && TOt(t, e, POt);
}
var QB = IOt, kOt = $S;
function AOt(t, e) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!kOt(n))
      return t(n, r);
    for (var s = n.length, o = e ? s : -1, i = Object(n); (e ? o-- : ++o < s) && r(i[o], o, i) !== !1; )
      ;
    return n;
  };
}
var MOt = AOt, OOt = QB, DOt = MOt, NOt = DOt(OOt), jOt = NOt, ROt = jOt, $Ot = $S;
function LOt(t, e) {
  var n = -1, r = $Ot(t) ? Array(t.length) : [];
  return ROt(t, function(s, o, i) {
    r[++n] = e(s, o, i);
  }), r;
}
var FOt = LOt;
function BOt(t, e) {
  var n = t.length;
  for (t.sort(e); n--; )
    t[n] = t[n].value;
  return t;
}
var zOt = BOt, eY = LS;
function UOt(t, e) {
  if (t !== e) {
    var n = t !== void 0, r = t === null, s = t === t, o = eY(t), i = e !== void 0, a = e === null, c = e === e, l = eY(e);
    if (!a && !l && !o && t > e || o && i && c && !a && !l || r && i && c || !n && c || !s)
      return 1;
    if (!r && !o && !l && t < e || l && n && s && !r && !o || a && n && s || !i && s || !c)
      return -1;
  }
  return 0;
}
var HOt = UOt, VOt = HOt;
function WOt(t, e, n) {
  for (var r = -1, s = t.criteria, o = e.criteria, i = s.length, a = n.length; ++r < i; ) {
    var c = VOt(s[r], o[r]);
    if (c) {
      if (r >= a)
        return c;
      var l = n[r];
      return c * (l == "desc" ? -1 : 1);
    }
  }
  return t.index - e.index;
}
var KOt = WOt, Z2 = ZB, GOt = SA, YOt = _A, qOt = FOt, XOt = zOt, ZOt = bA, QOt = KOt, JOt = CA, e2t = vc;
function t2t(t, e, n) {
  e.length ? e = Z2(e, function(o) {
    return e2t(o) ? function(i) {
      return GOt(i, o.length === 1 ? o[0] : o);
    } : o;
  }) : e = [JOt];
  var r = -1;
  e = Z2(e, ZOt(YOt));
  var s = qOt(t, function(o, i, a) {
    var c = Z2(e, function(l) {
      return l(o);
    });
    return { criteria: c, index: ++r, value: o };
  });
  return XOt(s, function(o, i) {
    return QOt(o, i, n);
  });
}
var n2t = t2t;
function r2t(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
var s2t = r2t, o2t = s2t, tY = Math.max;
function i2t(t, e, n) {
  return e = tY(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var r = arguments, s = -1, o = tY(r.length - e, 0), i = Array(o); ++s < o; )
      i[s] = r[e + s];
    s = -1;
    for (var a = Array(e + 1); ++s < e; )
      a[s] = r[s];
    return a[e] = n(i), o2t(t, this, a);
  };
}
var Bve = i2t;
function a2t(t) {
  return function() {
    return t;
  };
}
var c2t = a2t, l2t = wg, d2t = function() {
  try {
    var t = l2t(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}(), zve = d2t, u2t = c2t, nY = zve, f2t = CA, h2t = nY ? function(t, e) {
  return nY(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: u2t(e),
    writable: !0
  });
} : f2t, p2t = h2t, g2t = 800, m2t = 16, y2t = Date.now;
function v2t(t) {
  var e = 0, n = 0;
  return function() {
    var r = y2t(), s = m2t - (r - n);
    if (n = r, s > 0) {
      if (++e >= g2t)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
var b2t = v2t, x2t = p2t, w2t = b2t, S2t = w2t(x2t), Uve = S2t, C2t = CA, _2t = Bve, E2t = Uve;
function T2t(t, e) {
  return E2t(_2t(t, e, C2t), t + "");
}
var Hve = T2t, P2t = Fve, I2t = n2t, k2t = Hve, rY = hA, A2t = k2t(function(t, e) {
  if (t == null)
    return [];
  var n = e.length;
  return n > 1 && rY(t, e[0], e[1]) ? e = [] : n > 2 && rY(e[0], e[1], e[2]) && (e = [e[0]]), I2t(t, P2t(e, 1), []);
}), M2t = A2t;
const O2t = /* @__PURE__ */ Wr(M2t);
function Vve(t) {
  return Yye(t) || dve(t) || IB(t) || qye();
}
function D2t(t) {
  var e = [];
  if (t != null)
    for (var n in Object(t))
      e.push(n);
  return e;
}
var N2t = D2t, j2t = Cu, R2t = GB, $2t = N2t, L2t = Object.prototype, F2t = L2t.hasOwnProperty;
function B2t(t) {
  if (!j2t(t))
    return $2t(t);
  var e = R2t(t), n = [];
  for (var r in t)
    r == "constructor" && (e || !F2t.call(t, r)) || n.push(r);
  return n;
}
var z2t = B2t, U2t = Ive, H2t = z2t, V2t = $S;
function W2t(t) {
  return V2t(t) ? U2t(t, !0) : H2t(t);
}
var EA = W2t, K2t = Hve, G2t = RS, Y2t = hA, q2t = EA, Wve = Object.prototype, X2t = Wve.hasOwnProperty, Z2t = K2t(function(t, e) {
  t = Object(t);
  var n = -1, r = e.length, s = r > 2 ? e[2] : void 0;
  for (s && Y2t(e[0], e[1], s) && (r = 1); ++n < r; )
    for (var o = e[n], i = q2t(o), a = -1, c = i.length; ++a < c; ) {
      var l = i[a], d = t[l];
      (d === void 0 || G2t(d, Wve[l]) && !X2t.call(t, l)) && (t[l] = o[l]);
    }
  return t;
}), Q2t = Z2t;
const J2t = /* @__PURE__ */ Wr(Q2t);
var sY = zve;
function eDt(t, e, n) {
  e == "__proto__" && sY ? sY(t, e, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : t[e] = n;
}
var JB = eDt, tDt = JB, nDt = QB, rDt = _A;
function sDt(t, e) {
  var n = {};
  return e = rDt(e), nDt(t, function(r, s, o) {
    tDt(n, s, e(r, s, o));
  }), n;
}
var oDt = sDt;
const iDt = /* @__PURE__ */ Wr(oDt);
function aDt(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1; )
    ;
  return t;
}
var Kve = aDt, cDt = JB, lDt = RS, dDt = Object.prototype, uDt = dDt.hasOwnProperty;
function fDt(t, e, n) {
  var r = t[e];
  (!(uDt.call(t, e) && lDt(r, n)) || n === void 0 && !(e in t)) && cDt(t, e, n);
}
var Gve = fDt, hDt = Gve, pDt = JB;
function gDt(t, e, n, r) {
  var s = !n;
  n || (n = {});
  for (var o = -1, i = e.length; ++o < i; ) {
    var a = e[o], c = r ? r(n[a], t[a], a, n, t) : void 0;
    c === void 0 && (c = t[a]), s ? pDt(n, a, c) : hDt(n, a, c);
  }
  return n;
}
var US = gDt, mDt = US, yDt = BS;
function vDt(t, e) {
  return t && mDt(e, yDt(e), t);
}
var bDt = vDt, xDt = US, wDt = EA;
function SDt(t, e) {
  return t && xDt(e, wDt(e), t);
}
var CDt = SDt, TP = { exports: {} };
TP.exports;
(function(t, e) {
  var n = ld, r = e && !e.nodeType && e, s = r && !0 && t && !t.nodeType && t, o = s && s.exports === r, i = o ? n.Buffer : void 0, a = i ? i.allocUnsafe : void 0;
  function c(l, d) {
    if (d)
      return l.slice();
    var u = l.length, f = a ? a(u) : new l.constructor(u);
    return l.copy(f), f;
  }
  t.exports = c;
})(TP, TP.exports);
var _Dt = TP.exports;
function EDt(t, e) {
  var n = -1, r = t.length;
  for (e || (e = Array(r)); ++n < r; )
    e[n] = t[n];
  return e;
}
var TDt = EDt, PDt = US, IDt = HB;
function kDt(t, e) {
  return PDt(t, IDt(t), e);
}
var ADt = kDt, MDt = kve, ODt = MDt(Object.getPrototypeOf, Object), TA = ODt, DDt = UB, NDt = TA, jDt = HB, RDt = Tve, $Dt = Object.getOwnPropertySymbols, LDt = $Dt ? function(t) {
  for (var e = []; t; )
    DDt(e, jDt(t)), t = NDt(t);
  return e;
} : RDt, Yve = LDt, FDt = US, BDt = Yve;
function zDt(t, e) {
  return FDt(t, BDt(t), e);
}
var UDt = zDt, HDt = Eve, VDt = Yve, WDt = EA;
function KDt(t) {
  return HDt(t, WDt, VDt);
}
var qve = KDt, GDt = Object.prototype, YDt = GDt.hasOwnProperty;
function qDt(t) {
  var e = t.length, n = new t.constructor(e);
  return e && typeof t[0] == "string" && YDt.call(t, "index") && (n.index = t.index, n.input = t.input), n;
}
var XDt = qDt, oY = _ve;
function ZDt(t) {
  var e = new t.constructor(t.byteLength);
  return new oY(e).set(new oY(t)), e;
}
var ez = ZDt, QDt = ez;
function JDt(t, e) {
  var n = e ? QDt(t.buffer) : t.buffer;
  return new t.constructor(n, t.byteOffset, t.byteLength);
}
var eNt = JDt, tNt = /\w*$/;
function nNt(t) {
  var e = new t.constructor(t.source, tNt.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var rNt = nNt, iY = Ev, aY = iY ? iY.prototype : void 0, cY = aY ? aY.valueOf : void 0;
function sNt(t) {
  return cY ? Object(cY.call(t)) : {};
}
var oNt = sNt, iNt = ez;
function aNt(t, e) {
  var n = e ? iNt(t.buffer) : t.buffer;
  return new t.constructor(n, t.byteOffset, t.length);
}
var cNt = aNt, lNt = ez, dNt = eNt, uNt = rNt, fNt = oNt, hNt = cNt, pNt = "[object Boolean]", gNt = "[object Date]", mNt = "[object Map]", yNt = "[object Number]", vNt = "[object RegExp]", bNt = "[object Set]", xNt = "[object String]", wNt = "[object Symbol]", SNt = "[object ArrayBuffer]", CNt = "[object DataView]", _Nt = "[object Float32Array]", ENt = "[object Float64Array]", TNt = "[object Int8Array]", PNt = "[object Int16Array]", INt = "[object Int32Array]", kNt = "[object Uint8Array]", ANt = "[object Uint8ClampedArray]", MNt = "[object Uint16Array]", ONt = "[object Uint32Array]";
function DNt(t, e, n) {
  var r = t.constructor;
  switch (e) {
    case SNt:
      return lNt(t);
    case pNt:
    case gNt:
      return new r(+t);
    case CNt:
      return dNt(t, n);
    case _Nt:
    case ENt:
    case TNt:
    case PNt:
    case INt:
    case kNt:
    case ANt:
    case MNt:
    case ONt:
      return hNt(t, n);
    case mNt:
      return new r();
    case yNt:
    case xNt:
      return new r(t);
    case vNt:
      return uNt(t);
    case bNt:
      return new r();
    case wNt:
      return fNt(t);
  }
}
var NNt = DNt, jNt = Cu, lY = Object.create, RNt = /* @__PURE__ */ function() {
  function t() {
  }
  return function(e) {
    if (!jNt(e))
      return {};
    if (lY)
      return lY(e);
    t.prototype = e;
    var n = new t();
    return t.prototype = void 0, n;
  };
}(), Xve = RNt, $Nt = Xve, LNt = TA, FNt = GB;
function BNt(t) {
  return typeof t.constructor == "function" && !FNt(t) ? $Nt(LNt(t)) : {};
}
var zNt = BNt, UNt = xA, HNt = hh, VNt = "[object Map]";
function WNt(t) {
  return HNt(t) && UNt(t) == VNt;
}
var KNt = WNt, GNt = KNt, YNt = bA, dY = WB, uY = dY && dY.isMap, qNt = uY ? YNt(uY) : GNt, XNt = qNt, ZNt = xA, QNt = hh, JNt = "[object Set]";
function ejt(t) {
  return QNt(t) && ZNt(t) == JNt;
}
var tjt = ejt, njt = tjt, rjt = bA, fY = WB, hY = fY && fY.isSet, sjt = hY ? rjt(hY) : njt, ojt = sjt, ijt = zB, ajt = Kve, cjt = Gve, ljt = bDt, djt = CDt, ujt = _Dt, fjt = TDt, hjt = ADt, pjt = UDt, gjt = Ave, mjt = qve, yjt = xA, vjt = XDt, bjt = NNt, xjt = zNt, wjt = vc, Sjt = vA, Cjt = XNt, _jt = Cu, Ejt = ojt, Tjt = BS, Pjt = EA, Ijt = 1, kjt = 2, Ajt = 4, Zve = "[object Arguments]", Mjt = "[object Array]", Ojt = "[object Boolean]", Djt = "[object Date]", Njt = "[object Error]", Qve = "[object Function]", jjt = "[object GeneratorFunction]", Rjt = "[object Map]", $jt = "[object Number]", Jve = "[object Object]", Ljt = "[object RegExp]", Fjt = "[object Set]", Bjt = "[object String]", zjt = "[object Symbol]", Ujt = "[object WeakMap]", Hjt = "[object ArrayBuffer]", Vjt = "[object DataView]", Wjt = "[object Float32Array]", Kjt = "[object Float64Array]", Gjt = "[object Int8Array]", Yjt = "[object Int16Array]", qjt = "[object Int32Array]", Xjt = "[object Uint8Array]", Zjt = "[object Uint8ClampedArray]", Qjt = "[object Uint16Array]", Jjt = "[object Uint32Array]", Hn = {};
Hn[Zve] = Hn[Mjt] = Hn[Hjt] = Hn[Vjt] = Hn[Ojt] = Hn[Djt] = Hn[Wjt] = Hn[Kjt] = Hn[Gjt] = Hn[Yjt] = Hn[qjt] = Hn[Rjt] = Hn[$jt] = Hn[Jve] = Hn[Ljt] = Hn[Fjt] = Hn[Bjt] = Hn[zjt] = Hn[Xjt] = Hn[Zjt] = Hn[Qjt] = Hn[Jjt] = !0;
Hn[Njt] = Hn[Qve] = Hn[Ujt] = !1;
function F_(t, e, n, r, s, o) {
  var i, a = e & Ijt, c = e & kjt, l = e & Ajt;
  if (n && (i = s ? n(t, r, s, o) : n(t)), i !== void 0)
    return i;
  if (!_jt(t))
    return t;
  var d = wjt(t);
  if (d) {
    if (i = vjt(t), !a)
      return fjt(t, i);
  } else {
    var u = yjt(t), f = u == Qve || u == jjt;
    if (Sjt(t))
      return ujt(t, a);
    if (u == Jve || u == Zve || f && !s) {
      if (i = c || f ? {} : xjt(t), !a)
        return c ? pjt(t, djt(i, t)) : hjt(t, ljt(i, t));
    } else {
      if (!Hn[u])
        return s ? t : {};
      i = bjt(t, u, a);
    }
  }
  o || (o = new ijt());
  var p = o.get(t);
  if (p)
    return p;
  o.set(t, i), Ejt(t) ? t.forEach(function(m) {
    i.add(F_(m, e, n, m, t, o));
  }) : Cjt(t) && t.forEach(function(m, v) {
    i.set(v, F_(m, e, n, v, t, o));
  });
  var g = l ? c ? mjt : gjt : c ? Pjt : Tjt, y = d ? void 0 : g(t);
  return ajt(y || t, function(m, v) {
    y && (v = m, m = t[v]), cjt(i, v, F_(m, e, n, v, t, o));
  }), i;
}
var eRt = F_;
function tRt(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
var nRt = tRt, rRt = SA, sRt = uve;
function oRt(t, e) {
  return e.length < 2 ? t : rRt(t, sRt(e, 0, -1));
}
var iRt = oRt, aRt = wA, cRt = nRt, lRt = iRt, dRt = zS;
function uRt(t, e) {
  return e = aRt(e, t), t = lRt(t, e), t == null || delete t[dRt(cRt(e))];
}
var fRt = uRt, hRt = Tv, pRt = TA, gRt = hh, mRt = "[object Object]", yRt = Function.prototype, vRt = Object.prototype, ebe = yRt.toString, bRt = vRt.hasOwnProperty, xRt = ebe.call(Object);
function wRt(t) {
  if (!gRt(t) || hRt(t) != mRt)
    return !1;
  var e = pRt(t);
  if (e === null)
    return !0;
  var n = bRt.call(e, "constructor") && e.constructor;
  return typeof n == "function" && n instanceof n && ebe.call(n) == xRt;
}
var SRt = wRt, CRt = SRt;
function _Rt(t) {
  return CRt(t) ? void 0 : t;
}
var ERt = _Rt, TRt = Fve;
function PRt(t) {
  var e = t == null ? 0 : t.length;
  return e ? TRt(t, 1) : [];
}
var IRt = PRt, kRt = IRt, ARt = Bve, MRt = Uve;
function ORt(t) {
  return MRt(ARt(t, void 0, kRt), t + "");
}
var DRt = ORt, NRt = ZB, jRt = eRt, RRt = fRt, $Rt = wA, LRt = US, FRt = ERt, BRt = DRt, zRt = qve, URt = 1, HRt = 2, VRt = 4, WRt = BRt(function(t, e) {
  var n = {};
  if (t == null)
    return n;
  var r = !1;
  e = NRt(e, function(o) {
    return o = $Rt(o, t), r || (r = o.length > 1), o;
  }), LRt(t, zRt(t), n), r && (n = jRt(n, URt | HRt | VRt, FRt));
  for (var s = e.length; s--; )
    RRt(n, e[s]);
  return n;
}), KRt = WRt;
const GRt = /* @__PURE__ */ Wr(KRt);
var YRt = Kve, qRt = Xve, XRt = QB, ZRt = _A, QRt = TA, JRt = vc, e$t = vA, t$t = OB, n$t = Cu, r$t = KB;
function s$t(t, e, n) {
  var r = JRt(t), s = r || e$t(t) || r$t(t);
  if (e = ZRt(e), n == null) {
    var o = t && t.constructor;
    s ? n = r ? new o() : [] : n$t(t) ? n = t$t(o) ? qRt(QRt(t)) : {} : n = {};
  }
  return (s ? YRt : XRt)(t, function(i, a, c) {
    return e(n, i, a, c);
  }), n;
}
var o$t = s$t;
const i$t = /* @__PURE__ */ Wr(o$t);
var a$t = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(yn, function() {
    return function(n, r, s) {
      r.prototype.isBetween = function(o, i, a, c) {
        var l = s(o), d = s(i), u = (c = c || "()")[0] === "(", f = c[1] === ")";
        return (u ? this.isAfter(l, a) : !this.isBefore(l, a)) && (f ? this.isBefore(d, a) : !this.isAfter(d, a)) || (u ? this.isBefore(l, a) : !this.isAfter(l, a)) && (f ? this.isAfter(d, a) : !this.isBefore(d, a));
      };
    };
  });
})(a$t);
var c$t = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(yn, function() {
    return function(n, r) {
      r.prototype.isSameOrAfter = function(s, o) {
        return this.isSame(s, o) || this.isAfter(s, o);
      };
    };
  });
})(c$t);
var l$t = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(yn, function() {
    return function(n, r) {
      r.prototype.isSameOrBefore = function(s, o) {
        return this.isSame(s, o) || this.isBefore(s, o);
      };
    };
  });
})(l$t);
var d$t = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(yn, function() {
    return function(n, r, s) {
      var o = r.prototype, i = function(u) {
        return u && (u.indexOf ? u : u.s);
      }, a = function(u, f, p, g, y) {
        var m = u.name ? u : u.$locale(), v = i(m[f]), b = i(m[p]), x = v || b.map(function(S) {
          return S.slice(0, g);
        });
        if (!y) return x;
        var w = m.weekStart;
        return x.map(function(S, C) {
          return x[(C + (w || 0)) % 7];
        });
      }, c = function() {
        return s.Ls[s.locale()];
      }, l = function(u, f) {
        return u.formats[f] || function(p) {
          return p.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(g, y, m) {
            return y || m.slice(1);
          });
        }(u.formats[f.toUpperCase()]);
      }, d = function() {
        var u = this;
        return { months: function(f) {
          return f ? f.format("MMMM") : a(u, "months");
        }, monthsShort: function(f) {
          return f ? f.format("MMM") : a(u, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return u.$locale().weekStart || 0;
        }, weekdays: function(f) {
          return f ? f.format("dddd") : a(u, "weekdays");
        }, weekdaysMin: function(f) {
          return f ? f.format("dd") : a(u, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(f) {
          return f ? f.format("ddd") : a(u, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(f) {
          return l(u.$locale(), f);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      o.localeData = function() {
        return d.bind(this)();
      }, s.localeData = function() {
        var u = c();
        return { firstDayOfWeek: function() {
          return u.weekStart || 0;
        }, weekdays: function() {
          return s.weekdays();
        }, weekdaysShort: function() {
          return s.weekdaysShort();
        }, weekdaysMin: function() {
          return s.weekdaysMin();
        }, months: function() {
          return s.months();
        }, monthsShort: function() {
          return s.monthsShort();
        }, longDateFormat: function(f) {
          return l(u, f);
        }, meridiem: u.meridiem, ordinal: u.ordinal };
      }, s.months = function() {
        return a(c(), "months");
      }, s.monthsShort = function() {
        return a(c(), "monthsShort", "months", 3);
      }, s.weekdays = function(u) {
        return a(c(), "weekdays", null, null, u);
      }, s.weekdaysShort = function(u) {
        return a(c(), "weekdaysShort", "weekdays", 3, u);
      }, s.weekdaysMin = function(u) {
        return a(c(), "weekdaysMin", "weekdays", 2, u);
      };
    };
  });
})(d$t);
var u$t = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(yn, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(r, s, o) {
      var i = s.prototype, a = i.format;
      o.en.formats = n, i.format = function(c) {
        c === void 0 && (c = "YYYY-MM-DDTHH:mm:ssZ");
        var l = this.$locale().formats, d = function(u, f) {
          return u.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(p, g, y) {
            var m = y && y.toUpperCase();
            return g || f[y] || n[y] || f[m].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(v, b, x) {
              return b || x.slice(1);
            });
          });
        }(c, l === void 0 ? {} : l);
        return a.call(this, d);
      };
    };
  });
})(u$t);
var f$t = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(yn, function() {
    return function(n, r, s) {
      var o = function(i, a) {
        if (!a || !a.length || a.length === 1 && !a[0] || a.length === 1 && Array.isArray(a[0]) && !a[0].length) return null;
        var c;
        a.length === 1 && a[0].length > 0 && (a = a[0]), c = (a = a.filter(function(d) {
          return d;
        }))[0];
        for (var l = 1; l < a.length; l += 1) a[l].isValid() && !a[l][i](c) || (c = a[l]);
        return c;
      };
      s.max = function() {
        var i = [].slice.call(arguments, 0);
        return o("isAfter", i);
      }, s.min = function() {
        var i = [].slice.call(arguments, 0);
        return o("isBefore", i);
      };
    };
  });
})(f$t);
var h$t = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(yn, function() {
    var n = "minute", r = /[+-]\d\d(?::?\d\d)?/g, s = /([+-]|\d\d)/g;
    return function(o, i, a) {
      var c = i.prototype;
      a.utc = function(y) {
        var m = { date: y, utc: !0, args: arguments };
        return new i(m);
      }, c.utc = function(y) {
        var m = a(this.toDate(), { locale: this.$L, utc: !0 });
        return y ? m.add(this.utcOffset(), n) : m;
      }, c.local = function() {
        return a(this.toDate(), { locale: this.$L, utc: !1 });
      };
      var l = c.parse;
      c.parse = function(y) {
        y.utc && (this.$u = !0), this.$utils().u(y.$offset) || (this.$offset = y.$offset), l.call(this, y);
      };
      var d = c.init;
      c.init = function() {
        if (this.$u) {
          var y = this.$d;
          this.$y = y.getUTCFullYear(), this.$M = y.getUTCMonth(), this.$D = y.getUTCDate(), this.$W = y.getUTCDay(), this.$H = y.getUTCHours(), this.$m = y.getUTCMinutes(), this.$s = y.getUTCSeconds(), this.$ms = y.getUTCMilliseconds();
        } else d.call(this);
      };
      var u = c.utcOffset;
      c.utcOffset = function(y, m) {
        var v = this.$utils().u;
        if (v(y)) return this.$u ? 0 : v(this.$offset) ? u.call(this) : this.$offset;
        if (typeof y == "string" && (y = function(S) {
          S === void 0 && (S = "");
          var C = S.match(r);
          if (!C) return null;
          var _ = ("" + C[0]).match(s) || ["-", 0, 0], E = _[0], M = 60 * +_[1] + +_[2];
          return M === 0 ? 0 : E === "+" ? M : -M;
        }(y), y === null)) return this;
        var b = Math.abs(y) <= 16 ? 60 * y : y;
        if (b === 0) return this.utc(m);
        var x = this.clone();
        if (m) return x.$offset = b, x.$u = !1, x;
        var w = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
        return (x = this.local().add(b + w, n)).$offset = b, x.$x.$localOffset = w, x;
      };
      var f = c.format;
      c.format = function(y) {
        var m = y || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return f.call(this, m);
      }, c.valueOf = function() {
        var y = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * y;
      }, c.isUTC = function() {
        return !!this.$u;
      }, c.toISOString = function() {
        return this.toDate().toISOString();
      }, c.toString = function() {
        return this.toDate().toUTCString();
      };
      var p = c.toDate;
      c.toDate = function(y) {
        return y === "s" && this.$offset ? a(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : p.call(this);
      };
      var g = c.diff;
      c.diff = function(y, m, v) {
        if (y && this.$u === y.$u) return g.call(this, y, m, v);
        var b = this.local(), x = a(y).local();
        return g.call(b, x, m, v);
      };
    };
  });
})(h$t);
var p$t = { exports: {} };
(function(t, e) {
  (function(n, r) {
    t.exports = r();
  })(yn, function() {
    return function(n, r) {
      r.prototype.isLeapYear = function() {
        return this.$y % 4 == 0 && this.$y % 100 != 0 || this.$y % 400 == 0;
      };
    };
  });
})(p$t);
function El(t) {
  return t.children;
}
var Vi = {
  PREVIOUS: "PREV",
  NEXT: "NEXT",
  TODAY: "TODAY",
  DATE: "DATE"
}, gs = {
  MONTH: "month",
  WEEK: "week",
  WORK_WEEK: "work_week",
  DAY: "day",
  AGENDA: "agenda"
}, pY = Object.keys(gs).map(function(t) {
  return gs[t];
});
je.oneOfType([je.string, je.func]);
je.any;
je.func;
je.oneOfType([je.arrayOf(je.oneOf(pY)), je.objectOf(function(t, e) {
  var n = pY.indexOf(e) !== -1 && typeof t[e] == "boolean";
  if (n)
    return null;
  for (var r = arguments.length, s = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
    s[o - 2] = arguments[o];
  return je.elementType.apply(je, [t, e].concat(s));
})]);
je.oneOfType([je.oneOf(["overlap", "no-overlap"]), je.func]);
var gY = {
  seconds: 1e3,
  minutes: 1e3 * 60,
  hours: 1e3 * 60 * 60,
  day: 1e3 * 60 * 60 * 24
};
function tbe(t, e) {
  var n = lo(t, "month");
  return lo(n, "week", e.startOfWeek());
}
function nbe(t, e) {
  var n = wP(t, "month");
  return wP(n, "week", e.startOfWeek());
}
function g$t(t, e) {
  for (var n = tbe(t, e), r = nbe(t, e), s = []; Cv(n, r, "day"); )
    s.push(n), n = cl(n, 1, "day");
  return s;
}
function m$t(t, e) {
  var n = lo(t, e);
  return Sv(n, t) ? n : cl(n, 1, e);
}
function y$t(t, e) {
  for (var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "day", r = t, s = []; Cv(r, e, n); )
    s.push(r), r = cl(r, 1, n);
  return s;
}
function v$t(t, e) {
  return e == null && t == null ? null : (e == null && (e = /* @__PURE__ */ new Date()), t == null && (t = /* @__PURE__ */ new Date()), t = lo(t, "day"), t = c0(t, c0(e)), t = jy(t, jy(e)), t = a0(t, a0(e)), i0(t, i0(e)));
}
function mY(t) {
  return c0(t) === 0 && jy(t) === 0 && a0(t) === 0 && i0(t) === 0;
}
function b$t(t, e, n, r) {
  return n === "day" && (n = "date"), Math.abs(
    // eslint-disable-next-line import/namespace
    cG[n](t, void 0, r) - // eslint-disable-next-line import/namespace
    cG[n](e, void 0, r)
  );
}
function tz(t, e, n) {
  return !n || n === "milliseconds" ? Math.abs(+t - +e) : Math.round(Math.abs(+lo(t, n) / gY[n] - +lo(e, n) / gY[n]));
}
var x$t = je.oneOfType([je.string, je.func]);
function w$t(t, e, n, r, s) {
  var o = typeof r == "function" ? r(n, s, t) : e.call(t, n, r, s);
  return Uf(o == null || typeof o == "string", "`localizer format(..)` must return a string, null, or undefined"), o;
}
function S$t(t, e, n) {
  return new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, e + n, 0, 0);
}
function nz(t, e) {
  return t.getTimezoneOffset() - e.getTimezoneOffset();
}
function C$t(t, e) {
  return tz(t, e, "minutes") + nz(t, e);
}
function _$t(t) {
  var e = lo(t, "day");
  return tz(e, t, "minutes") + nz(e, t);
}
function E$t(t, e) {
  return MB(t, e, "day");
}
function T$t(t, e, n) {
  var r = Sv(t, e, "minutes");
  return r ? jS(e, n, "minutes") : fA(e, n, "minutes");
}
function S$(t, e) {
  return b$t(t, e, "day");
}
function P$t(t) {
  var e = t.evtA, n = e.start, r = e.end, s = e.allDay, o = t.evtB, i = o.start, a = o.end, c = o.allDay, l = +lo(n, "day") - +lo(i, "day"), d = S$(n, r), u = S$(i, a);
  return l || // sort by start Day first
  u - d || // events spanning multiple days go first
  !!c - !!s || // then allDay single day events
  +n - +i || // then sort by start time
  +r - +a;
}
function I$t(t) {
  var e = t.event, n = e.start, r = e.end, s = t.range, o = s.start, i = s.end, a = lo(n, "day"), c = Cv(a, i, "day"), l = AB(a, r, "minutes"), d = l ? fA(r, o, "minutes") : jS(r, o, "minutes");
  return c && d;
}
function k$t(t, e) {
  return Sv(t, e, "day");
}
function A$t(t, e) {
  return mY(t) && mY(e);
}
var M$t = /* @__PURE__ */ ws(function t(e) {
  var n = this;
  xs(this, t), Uf(typeof e.format == "function", "date localizer `format(..)` must be a function"), Uf(typeof e.firstOfWeek == "function", "date localizer `firstOfWeek(..)` must be a function"), this.propType = e.propType || x$t, this.formats = e.formats, this.format = function() {
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
      s[o] = arguments[o];
    return w$t.apply(void 0, [n, e.format].concat(s));
  }, this.startOfWeek = e.firstOfWeek, this.merge = e.merge || v$t, this.inRange = e.inRange || ive, this.lt = e.lt || MB, this.lte = e.lte || Cv, this.gt = e.gt || fA, this.gte = e.gte || jS, this.eq = e.eq || Sv, this.neq = e.neq || AB, this.startOf = e.startOf || lo, this.endOf = e.endOf || wP, this.add = e.add || cl, this.range = e.range || y$t, this.diff = e.diff || tz, this.ceil = e.ceil || m$t, this.min = e.min || sve, this.max = e.max || ove, this.minutes = e.minutes || jy, this.daySpan = e.daySpan || S$, this.firstVisibleDay = e.firstVisibleDay || tbe, this.lastVisibleDay = e.lastVisibleDay || nbe, this.visibleDays = e.visibleDays || g$t, this.getSlotDate = e.getSlotDate || S$t, this.getTimezoneOffset = e.getTimezoneOffset || function(r) {
    return r.getTimezoneOffset();
  }, this.getDstOffset = e.getDstOffset || nz, this.getTotalMin = e.getTotalMin || C$t, this.getMinutesFromMidnight = e.getMinutesFromMidnight || _$t, this.continuesPrior = e.continuesPrior || E$t, this.continuesAfter = e.continuesAfter || T$t, this.sortEvents = e.sortEvents || P$t, this.inEventRange = e.inEventRange || I$t, this.isSameDate = e.isSameDate || k$t, this.startAndEndAreDateOnly = e.startAndEndAreDateOnly || A$t, this.segmentOffset = e.browserTZOffset ? e.browserTZOffset() : 0;
});
function O$t(t, e, n, r) {
  var s = Dn(Dn({}, t.formats), n);
  return Dn(Dn({}, t), {}, {
    messages: r,
    startOfWeek: function() {
      return t.startOfWeek(e);
    },
    format: function(i, a) {
      return t.format(i, s[a] || a, e);
    }
  });
}
var D$t = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    xs(this, e);
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
      s[o] = arguments[o];
    return n = Ho(this, e, [].concat(s)), n.navigate = function(i) {
      n.props.onNavigate(i);
    }, n.view = function(i) {
      n.props.onView(i);
    }, n;
  }
  return Vo(e, t), ws(e, [{
    key: "render",
    value: function() {
      var r = this.props, s = r.localizer.messages, o = r.label;
      return /* @__PURE__ */ B.createElement("div", {
        className: "rbc-toolbar"
      }, /* @__PURE__ */ B.createElement("span", {
        className: "rbc-btn-group"
      }, /* @__PURE__ */ B.createElement("button", {
        type: "button",
        onClick: this.navigate.bind(null, Vi.TODAY)
      }, s.today), /* @__PURE__ */ B.createElement("button", {
        type: "button",
        onClick: this.navigate.bind(null, Vi.PREVIOUS)
      }, s.previous), /* @__PURE__ */ B.createElement("button", {
        type: "button",
        onClick: this.navigate.bind(null, Vi.NEXT)
      }, s.next)), /* @__PURE__ */ B.createElement("span", {
        className: "rbc-toolbar-label"
      }, o), /* @__PURE__ */ B.createElement("span", {
        className: "rbc-btn-group"
      }, this.viewNamesGroup(s)));
    }
  }, {
    key: "viewNamesGroup",
    value: function(r) {
      var s = this, o = this.props.views, i = this.props.view;
      if (o.length > 1)
        return o.map(function(a) {
          return /* @__PURE__ */ B.createElement("button", {
            type: "button",
            key: a,
            className: kr({
              "rbc-active": i === a
            }),
            onClick: s.view.bind(null, a)
          }, r[a]);
        });
    }
  }]);
}(B.Component);
function Jn(t, e) {
  t && t.apply(null, [].concat(e));
}
var N$t = {
  date: "Date",
  time: "Time",
  event: "Event",
  allDay: "All Day",
  week: "Week",
  work_week: "Work Week",
  day: "Day",
  month: "Month",
  previous: "Back",
  next: "Next",
  yesterday: "Yesterday",
  tomorrow: "Tomorrow",
  today: "Today",
  agenda: "Agenda",
  noEventsInRange: "There are no events in this range.",
  showMore: function(e) {
    return "+".concat(e, " more");
  }
};
function j$t(t) {
  return Dn(Dn({}, N$t), t);
}
function R$t(t) {
  var e = t.ref, n = t.callback;
  me(function() {
    var r = function(o) {
      e.current && !e.current.contains(o.target) && n();
    };
    return document.addEventListener("mousedown", r), function() {
      document.removeEventListener("mousedown", r);
    };
  }, [e, n]);
}
var $$t = ["style", "className", "event", "selected", "isAllDay", "onSelect", "onDoubleClick", "onKeyPress", "localizer", "continuesPrior", "continuesAfter", "accessors", "getters", "children", "components", "slotStart", "slotEnd"], rbe = /* @__PURE__ */ function(t) {
  function e() {
    return xs(this, e), Ho(this, e, arguments);
  }
  return Vo(e, t), ws(e, [{
    key: "render",
    value: function() {
      var r = this.props, s = r.style, o = r.className, i = r.event, a = r.selected, c = r.isAllDay, l = r.onSelect, d = r.onDoubleClick, u = r.onKeyPress, f = r.localizer, p = r.continuesPrior, g = r.continuesAfter, y = r.accessors, m = r.getters, v = r.children, b = r.components, x = b.event, w = b.eventWrapper, S = r.slotStart, C = r.slotEnd, _ = td(r, $$t);
      delete _.resizable;
      var E = y.title(i), M = y.tooltip(i), N = y.end(i), O = y.start(i), D = y.allDay(i), k = c || D || f.diff(O, f.ceil(N, "day"), "day") > 1, A = m.eventProp(i, O, N, a), R = /* @__PURE__ */ B.createElement("div", {
        className: "rbc-event-content",
        title: M || void 0
      }, x ? /* @__PURE__ */ B.createElement(x, {
        event: i,
        continuesPrior: p,
        continuesAfter: g,
        title: E,
        isAllDay: D,
        localizer: f,
        slotStart: S,
        slotEnd: C
      }) : E);
      return /* @__PURE__ */ B.createElement(w, Object.assign({}, this.props, {
        type: "date"
      }), /* @__PURE__ */ B.createElement("div", Object.assign({}, _, {
        style: Dn(Dn({}, A.style), s),
        className: kr("rbc-event", o, A.className, {
          "rbc-selected": a,
          "rbc-event-allday": k,
          "rbc-event-continues-prior": p,
          "rbc-event-continues-after": g
        }),
        onClick: function($) {
          return l && l(i, $);
        },
        onDoubleClick: function($) {
          return d && d(i, $);
        },
        onKeyDown: function($) {
          return u && u(i, $);
        }
      }), typeof v == "function" ? v(R) : R));
    }
  }]);
}(B.Component);
function PA(t, e) {
  return !t || e == null ? !1 : tAt(t, e);
}
function sbe(t, e) {
  var n = t.right - t.left, r = n / e;
  return r;
}
function obe(t, e, n, r) {
  var s = sbe(t, r);
  return n ? r - 1 - Math.floor((e - t.left) / s) : Math.floor((e - t.left) / s);
}
function L$t(t, e) {
  var n = e.x, r = e.y;
  return r >= t.top && r <= t.bottom && n >= t.left && n <= t.right;
}
function F$t(t, e, n, r, s) {
  var o = -1, i = -1, a = r - 1, c = sbe(e, r), l = obe(e, n.x, s, r), d = e.top < n.y && e.bottom > n.y, u = e.top < t.y && e.bottom > t.y, f = t.y > e.bottom, p = e.top > t.y, g = n.top < e.top && n.bottom > e.bottom;
  return g && (o = 0, i = a), d && (p ? (o = 0, i = l) : f && (o = l, i = a)), u && (o = i = s ? a - Math.floor((t.x - e.left) / c) : Math.floor((t.x - e.left) / c), d ? l < o ? o = l : i = l : t.y < n.y ? i = a : o = 0), {
    startIdx: o,
    endIdx: i
  };
}
function B$t(t) {
  var e = t.target, n = t.offset, r = t.container, s = t.box, o = gp(e), i = o.top, a = o.left, c = o.width, l = o.height, d = gp(r), u = d.top, f = d.left, p = d.width, g = d.height, y = gp(s), m = y.width, v = y.height, b = u + g, x = f + p, w = i + v, S = a + m, C = n.x, _ = n.y, E = w > b ? i - v - _ : i + _ + l, M = S > x ? a + C - m + c : a + C;
  return {
    topOffset: E,
    leftOffset: M
  };
}
function z$t(t) {
  var e = t.containerRef, n = t.accessors, r = t.getters, s = t.selected, o = t.components, i = t.localizer, a = t.position, c = t.show, l = t.events, d = t.slotStart, u = t.slotEnd, f = t.onSelect, p = t.onDoubleClick, g = t.onKeyPress, y = t.handleDragStart, m = t.popperRef, v = t.target, b = t.offset;
  R$t({
    ref: m,
    callback: c
  }), un(function() {
    var S = B$t({
      target: v,
      offset: b,
      container: e.current,
      box: m.current
    }), C = S.topOffset, _ = S.leftOffset;
    m.current.style.top = "".concat(C, "px"), m.current.style.left = "".concat(_, "px");
  }, [b.x, b.y, v]);
  var x = a.width, w = {
    minWidth: x + x / 2
  };
  return /* @__PURE__ */ B.createElement("div", {
    style: w,
    className: "rbc-overlay",
    ref: m
  }, /* @__PURE__ */ B.createElement("div", {
    className: "rbc-overlay-header"
  }, i.format(d, "dayHeaderFormat")), l.map(function(S, C) {
    return /* @__PURE__ */ B.createElement(rbe, {
      key: C,
      type: "popup",
      localizer: i,
      event: S,
      getters: r,
      onSelect: f,
      accessors: n,
      components: o,
      onDoubleClick: p,
      onKeyPress: g,
      continuesPrior: i.lt(n.end(S), d, "day"),
      continuesAfter: i.gte(n.start(S), u, "day"),
      slotStart: d,
      slotEnd: u,
      selected: PA(S, s),
      draggable: !0,
      onDragStart: function() {
        return y(S);
      },
      onDragEnd: function() {
        return c();
      }
    });
  }));
}
var ibe = /* @__PURE__ */ B.forwardRef(function(t, e) {
  return /* @__PURE__ */ B.createElement(z$t, Object.assign({}, t, {
    popperRef: e
  }));
});
ibe.propTypes = {
  accessors: je.object.isRequired,
  getters: je.object.isRequired,
  selected: je.object,
  components: je.object.isRequired,
  localizer: je.object.isRequired,
  position: je.object.isRequired,
  show: je.func.isRequired,
  events: je.array.isRequired,
  slotStart: je.instanceOf(Date).isRequired,
  slotEnd: je.instanceOf(Date),
  onSelect: je.func,
  onDoubleClick: je.func,
  onKeyPress: je.func,
  handleDragStart: je.func,
  style: je.object,
  offset: je.shape({
    x: je.number,
    y: je.number
  })
};
function U$t(t) {
  var e = t.containerRef, n = t.popupOffset, r = n === void 0 ? 5 : n, s = t.overlay, o = t.accessors, i = t.localizer, a = t.components, c = t.getters, l = t.selected, d = t.handleSelectEvent, u = t.handleDoubleClickEvent, f = t.handleKeyPressEvent, p = t.handleDragStart, g = t.onHide, y = t.overlayDisplay, m = fe(null);
  if (!s.position) return null;
  var v = r;
  isNaN(r) || (v = {
    x: r,
    y: r
  });
  var b = s.position, x = s.events, w = s.date, S = s.end;
  return /* @__PURE__ */ B.createElement(LB, {
    rootClose: !0,
    flip: !0,
    show: !0,
    placement: "bottom",
    onHide: g,
    target: s.target
  }, function(C) {
    var _ = C.props;
    return /* @__PURE__ */ B.createElement(ibe, Object.assign({}, _, {
      containerRef: e,
      ref: m,
      target: s.target,
      offset: v,
      accessors: o,
      getters: c,
      selected: l,
      components: a,
      localizer: i,
      position: b,
      show: y,
      events: x,
      slotStart: w,
      slotEnd: S,
      onSelect: d,
      onDoubleClick: u,
      onKeyPress: f,
      handleDragStart: p
    }));
  });
}
var rz = /* @__PURE__ */ B.forwardRef(function(t, e) {
  return /* @__PURE__ */ B.createElement(U$t, Object.assign({}, t, {
    containerRef: e
  }));
});
rz.propTypes = {
  popupOffset: je.oneOfType([je.number, je.shape({
    x: je.number,
    y: je.number
  })]),
  overlay: je.shape({
    position: je.object,
    events: je.array,
    date: je.instanceOf(Date),
    end: je.instanceOf(Date)
  }),
  accessors: je.object.isRequired,
  localizer: je.object.isRequired,
  components: je.object.isRequired,
  getters: je.object.isRequired,
  selected: je.object,
  handleSelectEvent: je.func,
  handleDoubleClickEvent: je.func,
  handleKeyPressEvent: je.func,
  handleDragStart: je.func,
  onHide: je.func,
  overlayDisplay: je.func
};
function xo(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : document;
  return rx(n, t, e, {
    passive: !1
  });
}
function H$t(t, e, n) {
  return !t || l0(t, document.elementFromPoint(e, n));
}
function V$t(t, e) {
  var n = e.clientX, r = e.clientY, s = document.elementFromPoint(n, r);
  return Dve(s, ".rbc-event", t);
}
function W$t(t, e) {
  var n = e.clientX, r = e.clientY, s = document.elementFromPoint(n, r);
  return Dve(s, ".rbc-show-more", t);
}
function PP(t, e) {
  return !!V$t(t, e);
}
function K$t(t, e) {
  return !!W$t(t, e);
}
function xb(t) {
  var e = t;
  return t.touches && t.touches.length && (e = t.touches[0]), {
    clientX: e.clientX,
    clientY: e.clientY,
    pageX: e.pageX,
    pageY: e.pageY
  };
}
var yY = 5, G$t = 250, abe = /* @__PURE__ */ function() {
  function t(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = n.global, s = r === void 0 ? !1 : r, o = n.longPressThreshold, i = o === void 0 ? 250 : o, a = n.validContainers, c = a === void 0 ? [] : a;
    xs(this, t), this._initialEvent = null, this.selecting = !1, this.isDetached = !1, this.container = e, this.globalMouse = !e || s, this.longPressThreshold = i, this.validContainers = c, this._listeners = /* @__PURE__ */ Object.create(null), this._handleInitialEvent = this._handleInitialEvent.bind(this), this._handleMoveEvent = this._handleMoveEvent.bind(this), this._handleTerminatingEvent = this._handleTerminatingEvent.bind(this), this._keyListener = this._keyListener.bind(this), this._dropFromOutsideListener = this._dropFromOutsideListener.bind(this), this._dragOverFromOutsideListener = this._dragOverFromOutsideListener.bind(this), this._removeTouchMoveWindowListener = xo("touchmove", function() {
    }, window), this._removeKeyDownListener = xo("keydown", this._keyListener), this._removeKeyUpListener = xo("keyup", this._keyListener), this._removeDropFromOutsideListener = xo("drop", this._dropFromOutsideListener), this._removeDragOverFromOutsideListener = xo("dragover", this._dragOverFromOutsideListener), this._addInitialEventListener();
  }
  return ws(t, [{
    key: "on",
    value: function(n, r) {
      var s = this._listeners[n] || (this._listeners[n] = []);
      return s.push(r), {
        remove: function() {
          var i = s.indexOf(r);
          i !== -1 && s.splice(i, 1);
        }
      };
    }
  }, {
    key: "emit",
    value: function(n) {
      for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
        s[o - 1] = arguments[o];
      var i, a = this._listeners[n] || [];
      return a.forEach(function(c) {
        i === void 0 && (i = c.apply(void 0, s));
      }), i;
    }
  }, {
    key: "teardown",
    value: function() {
      this._initialEvent = null, this._initialEventData = null, this._selectRect = null, this.selecting = !1, this._lastClickData = null, this.isDetached = !0, this._listeners = /* @__PURE__ */ Object.create(null), this._removeTouchMoveWindowListener && this._removeTouchMoveWindowListener(), this._removeInitialEventListener && this._removeInitialEventListener(), this._removeEndListener && this._removeEndListener(), this._onEscListener && this._onEscListener(), this._removeMoveListener && this._removeMoveListener(), this._removeKeyUpListener && this._removeKeyUpListener(), this._removeKeyDownListener && this._removeKeyDownListener(), this._removeDropFromOutsideListener && this._removeDropFromOutsideListener(), this._removeDragOverFromOutsideListener && this._removeDragOverFromOutsideListener();
    }
  }, {
    key: "isSelected",
    value: function(n) {
      var r = this._selectRect;
      return !r || !this.selecting ? !1 : vY(r, eg(n));
    }
  }, {
    key: "filter",
    value: function(n) {
      var r = this._selectRect;
      return !r || !this.selecting ? [] : n.filter(this.isSelected, this);
    }
    // Adds a listener that will call the handler only after the user has pressed on the screen
    // without moving their finger for 250ms.
  }, {
    key: "_addLongPressListener",
    value: function(n, r) {
      var s = this, o = null, i = null, a = null, c = function(f) {
        o = setTimeout(function() {
          d(), n(f);
        }, s.longPressThreshold), i = xo("touchmove", function() {
          return d();
        }), a = xo("touchend", function() {
          return d();
        });
      }, l = xo("touchstart", c), d = function() {
        o && clearTimeout(o), i && i(), a && a(), o = null, i = null, a = null;
      };
      return r && c(r), function() {
        d(), l();
      };
    }
    // Listen for mousedown and touchstart events. When one is received, disable the other and setup
    // future event handling based on the type of event.
  }, {
    key: "_addInitialEventListener",
    value: function() {
      var n = this, r = xo("mousedown", function(o) {
        n._removeInitialEventListener(), n._handleInitialEvent(o), n._removeInitialEventListener = xo("mousedown", n._handleInitialEvent);
      }), s = xo("touchstart", function(o) {
        n._removeInitialEventListener(), n._removeInitialEventListener = n._addLongPressListener(n._handleInitialEvent, o);
      });
      this._removeInitialEventListener = function() {
        r(), s();
      };
    }
  }, {
    key: "_dropFromOutsideListener",
    value: function(n) {
      var r = xb(n), s = r.pageX, o = r.pageY, i = r.clientX, a = r.clientY;
      this.emit("dropFromOutside", {
        x: s,
        y: o,
        clientX: i,
        clientY: a
      }), n.preventDefault();
    }
  }, {
    key: "_dragOverFromOutsideListener",
    value: function(n) {
      var r = xb(n), s = r.pageX, o = r.pageY, i = r.clientX, a = r.clientY;
      this.emit("dragOverFromOutside", {
        x: s,
        y: o,
        clientX: i,
        clientY: a
      }), n.preventDefault();
    }
  }, {
    key: "_handleInitialEvent",
    value: function(n) {
      if (this._initialEvent = n, !this.isDetached) {
        var r = xb(n), s = r.clientX, o = r.clientY, i = r.pageX, a = r.pageY, c = this.container(), l, d;
        if (!(n.which === 3 || n.button === 2 || !H$t(c, s, o))) {
          if (!this.globalMouse && c && !l0(c, n.target)) {
            var u = Y$t(0), f = u.top, p = u.left, g = u.bottom, y = u.right;
            if (d = eg(c), l = vY({
              top: d.top - f,
              left: d.left - p,
              bottom: d.bottom + g,
              right: d.right + y
            }, {
              top: a,
              left: i
            }), !l) return;
          }
          var m = this.emit("beforeSelect", this._initialEventData = {
            isTouch: /^touch/.test(n.type),
            x: i,
            y: a,
            clientX: s,
            clientY: o
          });
          if (m !== !1)
            switch (n.type) {
              case "mousedown":
                this._removeEndListener = xo("mouseup", this._handleTerminatingEvent), this._onEscListener = xo("keydown", this._handleTerminatingEvent), this._removeMoveListener = xo("mousemove", this._handleMoveEvent);
                break;
              case "touchstart":
                this._handleMoveEvent(n), this._removeEndListener = xo("touchend", this._handleTerminatingEvent), this._removeMoveListener = xo("touchmove", this._handleMoveEvent);
                break;
            }
        }
      }
    }
    // Check whether provided event target element
    // - is contained within a valid container
  }, {
    key: "_isWithinValidContainer",
    value: function(n) {
      var r = n.target, s = this.validContainers;
      return !s || !s.length || !r ? !0 : s.some(function(o) {
        return !!r.closest(o);
      });
    }
  }, {
    key: "_handleTerminatingEvent",
    value: function(n) {
      var r = this.selecting, s = this._selectRect;
      if (!r && n.type.includes("key") && (n = this._initialEvent), this.selecting = !1, this._removeEndListener && this._removeEndListener(), this._removeMoveListener && this._removeMoveListener(), this._selectRect = null, this._initialEvent = null, this._initialEventData = null, !!n) {
        var o = !this.container || l0(this.container(), n.target), i = this._isWithinValidContainer(n);
        return n.key === "Escape" || !i ? this.emit("reset") : !r && o ? this._handleClickEvent(n) : r ? this.emit("select", s) : this.emit("reset");
      }
    }
  }, {
    key: "_handleClickEvent",
    value: function(n) {
      var r = xb(n), s = r.pageX, o = r.pageY, i = r.clientX, a = r.clientY, c = (/* @__PURE__ */ new Date()).getTime();
      return this._lastClickData && c - this._lastClickData.timestamp < G$t ? (this._lastClickData = null, this.emit("doubleClick", {
        x: s,
        y: o,
        clientX: i,
        clientY: a
      })) : (this._lastClickData = {
        timestamp: c
      }, this.emit("click", {
        x: s,
        y: o,
        clientX: i,
        clientY: a
      }));
    }
  }, {
    key: "_handleMoveEvent",
    value: function(n) {
      if (!(this._initialEventData === null || this.isDetached)) {
        var r = this._initialEventData, s = r.x, o = r.y, i = xb(n), a = i.pageX, c = i.pageY, l = Math.abs(s - a), d = Math.abs(o - c), u = Math.min(a, s), f = Math.min(c, o), p = this.selecting, g = this.isClick(a, c);
        g && !p && !(l || d) || (!p && !g && this.emit("selectStart", this._initialEventData), g || (this.selecting = !0, this._selectRect = {
          top: f,
          left: u,
          x: a,
          y: c,
          right: u + l,
          bottom: f + d
        }, this.emit("selecting", this._selectRect)), n.preventDefault());
      }
    }
  }, {
    key: "_keyListener",
    value: function(n) {
      this.ctrl = n.metaKey || n.ctrlKey;
    }
  }, {
    key: "isClick",
    value: function(n, r) {
      var s = this._initialEventData, o = s.x, i = s.y, a = s.isTouch;
      return !a && Math.abs(n - o) <= yY && Math.abs(r - i) <= yY;
    }
  }]);
}();
function Y$t() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return cu(t) !== "object" && (t = {
    top: t,
    left: t,
    right: t,
    bottom: t
  }), t;
}
function vY(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = eg(t), s = r.top, o = r.left, i = r.right, a = i === void 0 ? o : i, c = r.bottom, l = c === void 0 ? s : c, d = eg(e), u = d.top, f = d.left, p = d.right, g = p === void 0 ? f : p, y = d.bottom, m = y === void 0 ? u : y;
  return !// 'a' bottom doesn't touch 'b' top
  (l - n < u || // 'a' top doesn't touch 'b' bottom
  s + n > m || // 'a' right doesn't touch 'b' left
  a - n < f || // 'a' left doesn't touch 'b' right
  o + n > g);
}
function eg(t) {
  if (!t.getBoundingClientRect) return t;
  var e = t.getBoundingClientRect(), n = e.left + bY("left"), r = e.top + bY("top");
  return {
    top: r,
    left: n,
    right: (t.offsetWidth || 0) + n,
    bottom: (t.offsetHeight || 0) + r
  };
}
function bY(t) {
  if (t === "left") return window.pageXOffset || document.body.scrollLeft || 0;
  if (t === "top") return window.pageYOffset || document.body.scrollTop || 0;
}
var q$t = /* @__PURE__ */ function(t) {
  function e(n, r) {
    var s;
    return xs(this, e), s = Ho(this, e, [n, r]), s.state = {
      selecting: !1
    }, s.containerRef = /* @__PURE__ */ mf(), s;
  }
  return Vo(e, t), ws(e, [{
    key: "componentDidMount",
    value: function() {
      this.props.selectable && this._selectable();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this._teardownSelectable();
    }
  }, {
    key: "componentDidUpdate",
    value: function(r) {
      !r.selectable && this.props.selectable && this._selectable(), r.selectable && !this.props.selectable && this._teardownSelectable();
    }
  }, {
    key: "render",
    value: function() {
      var r = this.props, s = r.range, o = r.getNow, i = r.getters, a = r.date, c = r.components.dateCellWrapper, l = r.localizer, d = this.state, u = d.selecting, f = d.startIdx, p = d.endIdx, g = o();
      return /* @__PURE__ */ B.createElement("div", {
        className: "rbc-row-bg",
        ref: this.containerRef
      }, s.map(function(y, m) {
        var v = u && m >= f && m <= p, b = i.dayProp(y), x = b.className, w = b.style;
        return /* @__PURE__ */ B.createElement(c, {
          key: m,
          value: y,
          range: s
        }, /* @__PURE__ */ B.createElement("div", {
          style: w,
          className: kr("rbc-day-bg", x, v && "rbc-selected-cell", l.isSameDate(y, g) && "rbc-today", a && l.neq(a, y, "month") && "rbc-off-range-bg")
        }));
      }));
    }
  }, {
    key: "_selectable",
    value: function() {
      var r = this, s = this.containerRef.current, o = this._selector = new abe(this.props.container, {
        longPressThreshold: this.props.longPressThreshold
      }), i = function(c, l) {
        if (!PP(s, c) && !K$t(s, c)) {
          var d = eg(s), u = r.props, f = u.range, p = u.rtl;
          if (L$t(d, c)) {
            var g = obe(d, c.x, p, f.length);
            r._selectSlot({
              startIdx: g,
              endIdx: g,
              action: l,
              box: c
            });
          }
        }
        r._initial = {}, r.setState({
          selecting: !1
        });
      };
      o.on("selecting", function(a) {
        var c = r.props, l = c.range, d = c.rtl, u = -1, f = -1;
        if (r.state.selecting || (Jn(r.props.onSelectStart, [a]), r._initial = {
          x: a.x,
          y: a.y
        }), o.isSelected(s)) {
          var p = eg(s), g = F$t(r._initial, p, a, l.length, d);
          u = g.startIdx, f = g.endIdx;
        }
        r.setState({
          selecting: !0,
          startIdx: u,
          endIdx: f
        });
      }), o.on("beforeSelect", function(a) {
        if (r.props.selectable === "ignoreEvents")
          return !PP(r.containerRef.current, a);
      }), o.on("click", function(a) {
        return i(a, "click");
      }), o.on("doubleClick", function(a) {
        return i(a, "doubleClick");
      }), o.on("select", function(a) {
        r._selectSlot(Dn(Dn({}, r.state), {}, {
          action: "select",
          bounds: a
        })), r._initial = {}, r.setState({
          selecting: !1
        }), Jn(r.props.onSelectEnd, [r.state]);
      });
    }
  }, {
    key: "_teardownSelectable",
    value: function() {
      this._selector && (this._selector.teardown(), this._selector = null);
    }
  }, {
    key: "_selectSlot",
    value: function(r) {
      var s = r.endIdx, o = r.startIdx, i = r.action, a = r.bounds, c = r.box;
      s !== -1 && o !== -1 && this.props.onSelectSlot && this.props.onSelectSlot({
        start: o,
        end: s,
        action: i,
        bounds: a,
        box: c,
        resourceId: this.props.resourceId
      });
    }
  }]);
}(B.Component), Ya = {
  propTypes: {
    slotMetrics: je.object.isRequired,
    selected: je.object,
    isAllDay: je.bool,
    accessors: je.object.isRequired,
    localizer: je.object.isRequired,
    components: je.object.isRequired,
    getters: je.object.isRequired,
    onSelect: je.func,
    onDoubleClick: je.func,
    onKeyPress: je.func
  },
  defaultProps: {
    segments: [],
    selected: {}
  },
  renderEvent: function(e, n) {
    var r = e.selected;
    e.isAllDay;
    var s = e.accessors, o = e.getters, i = e.onSelect, a = e.onDoubleClick, c = e.onKeyPress, l = e.localizer, d = e.slotMetrics, u = e.components, f = e.resizable, p = d.continuesPrior(n), g = d.continuesAfter(n);
    return /* @__PURE__ */ B.createElement(rbe, {
      event: n,
      getters: o,
      localizer: l,
      accessors: s,
      components: u,
      onSelect: i,
      onDoubleClick: a,
      onKeyPress: c,
      continuesPrior: p,
      continuesAfter: g,
      slotStart: d.first,
      slotEnd: d.last,
      selected: PA(n, r),
      resizable: f
    });
  },
  renderSpan: function(e, n, r) {
    var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : " ", o = Math.abs(n) / e * 100 + "%";
    return /* @__PURE__ */ B.createElement("div", {
      key: r,
      className: "rbc-row-segment",
      style: {
        WebkitFlexBasis: o,
        flexBasis: o,
        maxWidth: o
      }
    }, s);
  }
}, cbe = /* @__PURE__ */ function(t) {
  function e() {
    return xs(this, e), Ho(this, e, arguments);
  }
  return Vo(e, t), ws(e, [{
    key: "render",
    value: function() {
      var r = this, s = this.props, o = s.segments, i = s.slotMetrics.slots, a = s.className, c = 1;
      return /* @__PURE__ */ B.createElement("div", {
        className: kr(a, "rbc-row")
      }, o.reduce(function(l, d, u) {
        var f = d.event, p = d.left, g = d.right, y = d.span, m = "_lvl_" + u, v = p - c, b = Ya.renderEvent(r.props, f);
        return v && l.push(Ya.renderSpan(i, v, "".concat(m, "_gap"))), l.push(Ya.renderSpan(i, y, m, b)), c = g + 1, l;
      }, []));
    }
  }]);
}(B.Component);
cbe.defaultProps = Dn({}, Ya.defaultProps);
function lbe(t) {
  var e = t.dateRange, n = t.unit, r = n === void 0 ? "day" : n, s = t.localizer;
  return {
    first: e[0],
    last: s.add(e[e.length - 1], 1, r)
  };
}
function X$t(t, e, n, r) {
  var s = lbe({
    dateRange: e,
    localizer: r
  }), o = s.first, i = s.last, a = r.diff(o, i, "day"), c = r.max(r.startOf(n.start(t), "day"), o), l = r.min(r.ceil(n.end(t), "day"), i), d = nOt(e, function(f) {
    return r.isSameDate(f, c);
  }), u = r.diff(c, l, "day");
  return u = Math.min(u, a), u = Math.max(u - r.segmentOffset, 1), {
    event: t,
    span: u,
    left: d + 1,
    right: Math.max(d + u, 1)
  };
}
function C$(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1 / 0, n, r, s, o = [], i = [];
  for (n = 0; n < t.length; n++) {
    for (s = t[n], r = 0; r < o.length && Z$t(s, o[r]); r++) ;
    r >= e ? i.push(s) : (o[r] || (o[r] = [])).push(s);
  }
  for (n = 0; n < o.length; n++)
    o[n].sort(function(a, c) {
      return a.left - c.left;
    });
  return {
    levels: o,
    extra: i
  };
}
function d0(t, e, n, r, s) {
  var o = {
    start: r.start(t),
    end: r.end(t)
  }, i = {
    start: e,
    end: n
  };
  return s.inEventRange({
    event: o,
    range: i
  });
}
function Z$t(t, e) {
  return e.some(function(n) {
    return n.left <= t.right && n.right >= t.left;
  });
}
function Q$t(t, e, n) {
  var r = L_(t), s = [], o = [];
  r.forEach(function(c) {
    var l = e.start(c), d = e.end(c);
    n.daySpan(l, d) > 1 ? s.push(c) : o.push(c);
  });
  var i = s.sort(function(c, l) {
    return _$(c, l, e, n);
  }), a = o.sort(function(c, l) {
    return _$(c, l, e, n);
  });
  return [].concat(L_(i), L_(a));
}
function _$(t, e, n, r) {
  var s = {
    start: n.start(t),
    end: n.end(t),
    allDay: n.allDay(t)
  }, o = {
    start: n.start(e),
    end: n.end(e),
    allDay: n.allDay(e)
  };
  return r.sortEvents({
    evtA: s,
    evtB: o
  });
}
var E$ = function(e, n) {
  return e.left <= n && e.right >= n;
}, Q2 = function(e, n) {
  return e.filter(function(r) {
    return E$(r, n);
  }).map(function(r) {
    return r.event;
  });
}, dbe = /* @__PURE__ */ function(t) {
  function e() {
    return xs(this, e), Ho(this, e, arguments);
  }
  return Vo(e, t), ws(e, [{
    key: "render",
    value: function() {
      for (var r = this.props, s = r.segments, o = r.slotMetrics.slots, i = C$(s).levels[0], a = 1, c = 1, l = []; a <= o; ) {
        var d = "_lvl_" + a, u = i.filter(function(w) {
          return E$(w, a);
        })[0] || {}, f = u.event, p = u.left, g = u.right, y = u.span;
        if (!f) {
          var m = this.getHiddenEventsForSlot(s, a);
          if (m.length > 0) {
            var v = a - c;
            v && l.push(Ya.renderSpan(o, v, d + "_gap")), l.push(Ya.renderSpan(o, 1, d, this.renderShowMore(s, a))), c = a = a + 1;
            continue;
          }
          a++;
          continue;
        }
        var b = Math.max(0, p - c);
        if (this.canRenderSlotEvent(p, y)) {
          var x = Ya.renderEvent(this.props, f);
          b && l.push(Ya.renderSpan(o, b, d + "_gap")), l.push(Ya.renderSpan(o, y, d, x)), c = a = g + 1;
        } else
          b && l.push(Ya.renderSpan(o, b, d + "_gap")), l.push(Ya.renderSpan(o, 1, d, this.renderShowMore(s, a))), c = a = a + 1;
      }
      return /* @__PURE__ */ B.createElement("div", {
        className: "rbc-row"
      }, l);
    }
    // New helper method to find hidden events for a slot
  }, {
    key: "getHiddenEventsForSlot",
    value: function(r, s) {
      var o = Q2(r, s), i = C$(r).levels[0], a = i.filter(function(c) {
        return E$(c, s);
      }).map(function(c) {
        return c.event;
      });
      return o.filter(function(c) {
        return !a.some(function(l) {
          return l === c;
        });
      });
    }
  }, {
    key: "canRenderSlotEvent",
    value: function(r, s) {
      var o = this.props.segments;
      return pOt(r, r + s).every(function(i) {
        var a = Q2(o, i).length;
        return a === 1;
      });
    }
  }, {
    key: "renderShowMore",
    value: function(r, s) {
      var o = this, i = this.props, a = i.localizer, c = i.slotMetrics, l = i.components, d = c.getEventsForSlot(s), u = Q2(r, s), f = u.length;
      if (l != null && l.showMore) {
        var p = l.showMore, g = c.getDateForSlot(s - 1);
        return f ? /* @__PURE__ */ B.createElement(p, {
          localizer: a,
          slotDate: g,
          slot: s,
          count: f,
          events: d,
          remainingEvents: u
        }) : !1;
      }
      return f ? /* @__PURE__ */ B.createElement("button", {
        type: "button",
        key: "sm_" + s,
        className: kr("rbc-button-link", "rbc-show-more"),
        onClick: function(m) {
          return o.showMore(s, m);
        }
      }, a.messages.showMore(f, u, d)) : !1;
    }
  }, {
    key: "showMore",
    value: function(r, s) {
      s.preventDefault(), s.stopPropagation(), this.props.onShowMore(r, s.target);
    }
  }]);
}(B.Component);
dbe.defaultProps = Dn({}, Ya.defaultProps);
var J$t = function(e) {
  var n = e.children;
  return /* @__PURE__ */ B.createElement("div", {
    className: "rbc-row-content-scroll-container"
  }, n);
}, eLt = function(e, n) {
  return e.left <= n && e.right >= n;
}, tLt = function(e, n) {
  return e[0].range === n[0].range && e[0].events === n[0].events;
};
function ube() {
  return cs(function(t) {
    for (var e = t.range, n = t.events, r = t.maxRows, s = t.minRows, o = t.accessors, i = t.localizer, a = lbe({
      dateRange: e,
      localizer: i
    }), c = a.first, l = a.last, d = n.map(function(y) {
      return X$t(y, e, o, i);
    }), u = C$(d, Math.max(r - 1, 1)), f = u.levels, p = u.extra, g = p.length > 0 ? s - 1 : s; f.length < g; ) f.push([]);
    return {
      first: c,
      last: l,
      levels: f,
      extra: p,
      range: e,
      slots: e.length,
      clone: function(m) {
        var v = ube();
        return v(Dn(Dn({}, t), m));
      },
      getDateForSlot: function(m) {
        return e[m];
      },
      getSlotForDate: function(m) {
        return e.find(function(v) {
          return i.isSameDate(v, m);
        });
      },
      getEventsForSlot: function(m) {
        return d.filter(function(v) {
          return eLt(v, m);
        }).map(function(v) {
          return v.event;
        });
      },
      continuesPrior: function(m) {
        return i.continuesPrior(o.start(m), c);
      },
      continuesAfter: function(m) {
        var v = o.start(m), b = o.end(m);
        return i.continuesAfter(v, b, l);
      }
    };
  }, tLt);
}
var u0 = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    xs(this, e);
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
      s[o] = arguments[o];
    return n = Ho(this, e, [].concat(s)), n.handleSelectSlot = function(i) {
      var a = n.props, c = a.range, l = a.onSelectSlot;
      l(c.slice(i.start, i.end + 1), i);
    }, n.handleShowMore = function(i, a) {
      var c = n.props, l = c.range, d = c.onShowMore, u = n.slotMetrics(n.props), f = e_t(n.containerRef.current, ".rbc-row-bg")[0], p;
      f && (p = f.children[i - 1]);
      var g = u.getEventsForSlot(i);
      d(g, l[i - 1], p, i, a);
    }, n.getContainer = function() {
      var i = n.props.container;
      return i ? i() : n.containerRef.current;
    }, n.renderHeadingCell = function(i, a) {
      var c = n.props, l = c.renderHeader, d = c.getNow, u = c.localizer;
      return l({
        date: i,
        key: "header_".concat(a),
        className: kr("rbc-date-cell", u.isSameDate(i, d()) && "rbc-now")
      });
    }, n.renderDummy = function() {
      var i = n.props, a = i.className, c = i.range, l = i.renderHeader, d = i.showAllEvents;
      return /* @__PURE__ */ B.createElement("div", {
        className: a,
        ref: n.containerRef
      }, /* @__PURE__ */ B.createElement("div", {
        className: kr("rbc-row-content", d && "rbc-row-content-scrollable")
      }, l && /* @__PURE__ */ B.createElement("div", {
        className: "rbc-row",
        ref: n.headingRowRef
      }, c.map(n.renderHeadingCell)), /* @__PURE__ */ B.createElement("div", {
        className: "rbc-row",
        ref: n.eventRowRef
      }, /* @__PURE__ */ B.createElement("div", {
        className: "rbc-row-segment"
      }, /* @__PURE__ */ B.createElement("div", {
        className: "rbc-event"
      }, /* @__PURE__ */ B.createElement("div", {
        className: "rbc-event-content"
      }, ""))))));
    }, n.containerRef = /* @__PURE__ */ mf(), n.headingRowRef = /* @__PURE__ */ mf(), n.eventRowRef = /* @__PURE__ */ mf(), n.slotMetrics = ube(), n;
  }
  return Vo(e, t), ws(e, [{
    key: "getRowLimit",
    value: function() {
      var r, s = q2(this.eventRowRef.current), o = (r = this.headingRowRef) !== null && r !== void 0 && r.current ? q2(this.headingRowRef.current) : 0, i = q2(this.containerRef.current) - o;
      return Math.max(Math.floor(i / s), 1);
    }
  }, {
    key: "render",
    value: function() {
      var r = this.props, s = r.date, o = r.rtl, i = r.range, a = r.className, c = r.selected, l = r.selectable, d = r.renderForMeasure, u = r.accessors, f = r.getters, p = r.components, g = r.getNow, y = r.renderHeader, m = r.onSelect, v = r.localizer, b = r.onSelectStart, x = r.onSelectEnd, w = r.onDoubleClick, S = r.onKeyPress, C = r.resourceId, _ = r.longPressThreshold, E = r.isAllDay, M = r.resizable, N = r.showAllEvents;
      if (d) return this.renderDummy();
      var O = this.slotMetrics(this.props), D = O.levels, k = O.extra, A = N ? J$t : El, R = p.weekWrapper, j = {
        selected: c,
        accessors: u,
        getters: f,
        localizer: v,
        components: p,
        onSelect: m,
        onDoubleClick: w,
        onKeyPress: S,
        resourceId: C,
        slotMetrics: O,
        resizable: M
      };
      return /* @__PURE__ */ B.createElement("div", {
        className: a,
        role: "rowgroup",
        ref: this.containerRef
      }, /* @__PURE__ */ B.createElement(q$t, {
        localizer: v,
        date: s,
        getNow: g,
        rtl: o,
        range: i,
        selectable: l,
        container: this.getContainer,
        getters: f,
        onSelectStart: b,
        onSelectEnd: x,
        onSelectSlot: this.handleSelectSlot,
        components: p,
        longPressThreshold: _,
        resourceId: C
      }), /* @__PURE__ */ B.createElement("div", {
        className: kr("rbc-row-content", N && "rbc-row-content-scrollable"),
        role: "row"
      }, y && /* @__PURE__ */ B.createElement("div", {
        className: "rbc-row ",
        ref: this.headingRowRef
      }, i.map(this.renderHeadingCell)), /* @__PURE__ */ B.createElement(A, null, /* @__PURE__ */ B.createElement(R, Object.assign({
        isAllDay: E
      }, j, {
        rtl: this.props.rtl
      }), D.map(function($, F) {
        return /* @__PURE__ */ B.createElement(cbe, Object.assign({
          key: F,
          segments: $
        }, j));
      }), !!k.length && /* @__PURE__ */ B.createElement(dbe, Object.assign({
        segments: k,
        onShowMore: this.handleShowMore
      }, j))))));
    }
  }]);
}(B.Component);
u0.defaultProps = {
  minRows: 0,
  maxRows: 1 / 0
};
var sz = function(e) {
  var n = e.label;
  return /* @__PURE__ */ B.createElement("span", {
    role: "columnheader",
    "aria-sort": "none"
  }, n);
}, nLt = function(e) {
  var n = e.label, r = e.drilldownView, s = e.onDrillDown;
  return r ? /* @__PURE__ */ B.createElement("button", {
    type: "button",
    className: "rbc-button-link",
    onClick: s
  }, n) : /* @__PURE__ */ B.createElement("span", null, n);
}, rLt = ["date", "className"], sLt = function(e, n, r, s, o) {
  return e.filter(function(i) {
    return d0(i, n, r, s, o);
  });
}, IA = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    xs(this, e);
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
      s[o] = arguments[o];
    return n = Ho(this, e, [].concat(s)), n.getContainer = function() {
      return n.containerRef.current;
    }, n.renderWeek = function(i, a) {
      var c = n.props, l = c.events, d = c.components, u = c.selectable, f = c.getNow, p = c.selected, g = c.date, y = c.localizer, m = c.longPressThreshold, v = c.accessors, b = c.getters, x = c.showAllEvents, w = n.state, S = w.needLimitMeasure, C = w.rowLimit, _ = sLt(L_(l), i[0], i[i.length - 1], v, y), E = Q$t(_, v, y);
      return /* @__PURE__ */ B.createElement(u0, {
        key: a,
        ref: a === 0 ? n.slotRowRef : void 0,
        container: n.getContainer,
        className: "rbc-month-row",
        getNow: f,
        date: g,
        range: i,
        events: E,
        maxRows: x ? 1 / 0 : C,
        selected: p,
        selectable: u,
        components: d,
        accessors: v,
        getters: b,
        localizer: y,
        renderHeader: n.readerDateHeading,
        renderForMeasure: S,
        onShowMore: n.handleShowMore,
        onSelect: n.handleSelectEvent,
        onDoubleClick: n.handleDoubleClickEvent,
        onKeyPress: n.handleKeyPressEvent,
        onSelectSlot: n.handleSelectSlot,
        longPressThreshold: m,
        rtl: n.props.rtl,
        resizable: n.props.resizable,
        showAllEvents: x
      });
    }, n.readerDateHeading = function(i) {
      var a = i.date, c = i.className, l = td(i, rLt), d = n.props, u = d.date, f = d.getDrilldownView, p = d.localizer, g = p.neq(u, a, "month"), y = p.isSameDate(a, u), m = f(a), v = p.format(a, "dateFormat"), b = n.props.components.dateHeader || nLt;
      return /* @__PURE__ */ B.createElement("div", Object.assign({}, l, {
        className: kr(c, g && "rbc-off-range", y && "rbc-current"),
        role: "cell"
      }), /* @__PURE__ */ B.createElement(b, {
        label: v,
        date: a,
        drilldownView: m,
        isOffRange: g,
        onDrillDown: function(w) {
          return n.handleHeadingClick(a, m, w);
        }
      }));
    }, n.handleSelectSlot = function(i, a) {
      n._pendingSelection = n._pendingSelection.concat(i), clearTimeout(n._selectTimer), n._selectTimer = setTimeout(function() {
        return n.selectDates(a);
      });
    }, n.handleHeadingClick = function(i, a, c) {
      c.preventDefault(), n.clearSelection(), Jn(n.props.onDrillDown, [i, a]);
    }, n.handleSelectEvent = function() {
      n.clearSelection();
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
        a[c] = arguments[c];
      Jn(n.props.onSelectEvent, a);
    }, n.handleDoubleClickEvent = function() {
      n.clearSelection();
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
        a[c] = arguments[c];
      Jn(n.props.onDoubleClickEvent, a);
    }, n.handleKeyPressEvent = function() {
      n.clearSelection();
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
        a[c] = arguments[c];
      Jn(n.props.onKeyPressEvent, a);
    }, n.handleShowMore = function(i, a, c, l, d) {
      var u = n.props, f = u.popup, p = u.onDrillDown, g = u.onShowMore, y = u.getDrilldownView, m = u.doShowMoreDrillDown;
      if (n.clearSelection(), f) {
        var v = bve(c, n.containerRef.current);
        n.setState({
          overlay: {
            date: a,
            events: i,
            position: v,
            target: d
          }
        });
      } else m && Jn(p, [a, y(a) || gs.DAY]);
      Jn(g, [i, a, l]);
    }, n.overlayDisplay = function() {
      n.setState({
        overlay: null
      });
    }, n.state = {
      rowLimit: 5,
      needLimitMeasure: !0,
      date: null
    }, n.containerRef = /* @__PURE__ */ mf(), n.slotRowRef = /* @__PURE__ */ mf(), n._bgRows = [], n._pendingSelection = [], n;
  }
  return Vo(e, t), ws(e, [{
    key: "componentDidMount",
    value: function() {
      var r = this, s;
      this.state.needLimitMeasure && this.measureRowLimit(this.props), window.addEventListener("resize", this._resizeListener = function() {
        s || xve(function() {
          s = !1, r.setState({
            needLimitMeasure: !0
          });
        });
      }, !1);
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      this.state.needLimitMeasure && this.measureRowLimit(this.props);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      window.removeEventListener("resize", this._resizeListener, !1);
    }
  }, {
    key: "render",
    value: function() {
      var r = this.props, s = r.date, o = r.localizer, i = r.className, a = o.visibleDays(s, o), c = LCt(a, 7);
      return this._weekCount = c.length, /* @__PURE__ */ B.createElement("div", {
        className: kr("rbc-month-view", i),
        role: "table",
        "aria-label": "Month View",
        ref: this.containerRef
      }, /* @__PURE__ */ B.createElement("div", {
        className: "rbc-row rbc-month-header",
        role: "row"
      }, this.renderHeaders(c[0])), c.map(this.renderWeek), this.props.popup && this.renderOverlay());
    }
  }, {
    key: "renderHeaders",
    value: function(r) {
      var s = this.props, o = s.localizer, i = s.components, a = r[0], c = r[r.length - 1], l = i.header || sz;
      return o.range(a, c, "day").map(function(d, u) {
        return /* @__PURE__ */ B.createElement("div", {
          key: "header_" + u,
          className: "rbc-header"
        }, /* @__PURE__ */ B.createElement(l, {
          date: d,
          localizer: o,
          label: o.format(d, "weekdayFormat")
        }));
      });
    }
  }, {
    key: "renderOverlay",
    value: function() {
      var r, s, o = this, i = (r = (s = this.state) === null || s === void 0 ? void 0 : s.overlay) !== null && r !== void 0 ? r : {}, a = this.props, c = a.accessors, l = a.localizer, d = a.components, u = a.getters, f = a.selected, p = a.popupOffset, g = a.handleDragStart, y = function() {
        return o.setState({
          overlay: null
        });
      };
      return /* @__PURE__ */ B.createElement(rz, {
        overlay: i,
        accessors: c,
        localizer: l,
        components: d,
        getters: u,
        selected: f,
        popupOffset: p,
        ref: this.containerRef,
        handleKeyPressEvent: this.handleKeyPressEvent,
        handleSelectEvent: this.handleSelectEvent,
        handleDoubleClickEvent: this.handleDoubleClickEvent,
        handleDragStart: g,
        show: !!i.position,
        overlayDisplay: this.overlayDisplay,
        onHide: y
      });
    }
  }, {
    key: "measureRowLimit",
    value: function() {
      this.setState({
        needLimitMeasure: !1,
        rowLimit: this.slotRowRef.current.getRowLimit()
      });
    }
  }, {
    key: "selectDates",
    value: function(r) {
      var s = this._pendingSelection.slice();
      this._pendingSelection = [], s.sort(function(a, c) {
        return +a - +c;
      });
      var o = new Date(s[0]), i = new Date(s[s.length - 1]);
      i.setDate(s[s.length - 1].getDate() + 1), Jn(this.props.onSelectSlot, {
        slots: s,
        start: o,
        end: i,
        action: r.action,
        bounds: r.bounds,
        box: r.box
      });
    }
  }, {
    key: "clearSelection",
    value: function() {
      clearTimeout(this._selectTimer), this._pendingSelection = [];
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(r, s) {
      var o = r.date, i = r.localizer;
      return {
        date: o,
        needLimitMeasure: i.neq(o, s.date, "month")
      };
    }
  }]);
}(B.Component);
IA.range = function(t, e) {
  var n = e.localizer, r = n.firstVisibleDay(t, n), s = n.lastVisibleDay(t, n);
  return {
    start: r,
    end: s
  };
};
IA.navigate = function(t, e, n) {
  var r = n.localizer;
  switch (e) {
    case Vi.PREVIOUS:
      return r.add(t, -1, "month");
    case Vi.NEXT:
      return r.add(t, 1, "month");
    default:
      return t;
  }
};
IA.title = function(t, e) {
  var n = e.localizer;
  return n.format(t, "monthHeaderFormat");
};
var xY = function(e) {
  var n = e.min, r = e.max, s = e.step, o = e.slots, i = e.localizer;
  return "".concat(+i.startOf(n, "minutes")) + "".concat(+i.startOf(r, "minutes")) + "".concat(s, "-").concat(o);
};
function oz(t) {
  for (var e = t.min, n = t.max, r = t.step, s = t.timeslots, o = t.localizer, i = xY({
    start: e,
    end: n,
    step: r,
    timeslots: s,
    localizer: o
  }), a = 1 + o.getTotalMin(e, n), c = o.getMinutesFromMidnight(e), l = Math.ceil((a - 1) / (r * s)), d = l * s, u = new Array(l), f = new Array(d), p = 0; p < l; p++) {
    u[p] = new Array(s);
    for (var g = 0; g < s; g++) {
      var y = p * s + g, m = y * r;
      f[y] = u[p][g] = o.getSlotDate(e, c, m);
    }
  }
  var v = f.length * r;
  f.push(o.getSlotDate(e, c, v));
  function b(x) {
    var w = o.diff(e, x, "minutes") + o.getDstOffset(e, x);
    return Math.min(w, a);
  }
  return {
    groups: u,
    update: function(w) {
      return xY(w) !== i ? oz(w) : this;
    },
    dateIsInGroup: function(w, S) {
      var C = u[S + 1];
      return o.inRange(w, u[S][0], C ? C[0] : n, "minutes");
    },
    nextSlot: function(w) {
      var S = f[Math.min(f.findIndex(function(C) {
        return C === w || o.eq(C, w);
      }) + 1, f.length - 1)];
      return o.eq(S, w) && (S = o.add(w, r, "minutes")), S;
    },
    closestSlotToPosition: function(w) {
      var S = Math.min(f.length - 1, Math.max(0, Math.floor(w * d)));
      return f[S];
    },
    closestSlotFromPoint: function(w, S) {
      var C = Math.abs(S.top - S.bottom);
      return this.closestSlotToPosition((w.y - S.top) / C);
    },
    closestSlotFromDate: function(w) {
      var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (o.lt(w, e, "minutes")) return f[0];
      if (o.gt(w, n, "minutes")) return f[f.length - 1];
      var C = o.diff(e, w, "minutes");
      return f[(C - C % r) / r + S];
    },
    startsBeforeDay: function(w) {
      return o.lt(w, e, "day");
    },
    startsAfterDay: function(w) {
      return o.gt(w, n, "day");
    },
    startsBefore: function(w) {
      return o.lt(o.merge(e, w), e, "minutes");
    },
    startsAfter: function(w) {
      return o.gt(o.merge(n, w), n, "minutes");
    },
    getRange: function(w, S, C, _) {
      C || (w = o.min(n, o.max(e, w))), _ || (S = o.min(n, o.max(e, S)));
      var E = b(w), M = b(S), N = M > r * d && !o.eq(n, S) ? (E - r) / (r * d) * 100 : E / (r * d) * 100;
      return {
        top: N,
        height: M / (r * d) * 100 - N,
        start: b(w),
        startDate: w,
        end: b(S),
        endDate: S
      };
    },
    getCurrentTimePosition: function(w) {
      var S = b(w), C = S / (r * d) * 100;
      return C;
    }
  };
}
var oLt = /* @__PURE__ */ function() {
  function t(e, n) {
    var r = n.accessors, s = n.slotMetrics;
    xs(this, t);
    var o = s.getRange(r.start(e), r.end(e)), i = o.start, a = o.startDate, c = o.end, l = o.endDate, d = o.top, u = o.height;
    this.start = i, this.end = c, this.startMs = +a, this.endMs = +l, this.top = d, this.height = u, this.data = e;
  }
  return ws(t, [{
    key: "_width",
    get: function() {
      if (this.rows) {
        var n = this.rows.reduce(
          function(s, o) {
            return Math.max(s, o.leaves.length + 1);
          },
          // add itself
          0
        ) + 1;
        return 100 / n;
      }
      if (this.leaves) {
        var r = 100 - this.container._width;
        return r / (this.leaves.length + 1);
      }
      return this.row._width;
    }
    /**
     * The event's calculated width, possibly with extra width added for
     * overlapping effect.
     */
  }, {
    key: "width",
    get: function() {
      var n = this._width, r = Math.min(100, this._width * 1.7);
      if (this.rows)
        return r;
      if (this.leaves)
        return this.leaves.length > 0 ? r : n;
      var s = this.row.leaves, o = s.indexOf(this);
      return o === s.length - 1 ? n : r;
    }
  }, {
    key: "xOffset",
    get: function() {
      if (this.rows) return 0;
      if (this.leaves) return this.container._width;
      var n = this.row, r = n.leaves, s = n.xOffset, o = n._width, i = r.indexOf(this) + 1;
      return s + i * o;
    }
  }]);
}();
function iLt(t, e, n) {
  return (
    // Occupies the same start slot.
    Math.abs(e.start - t.start) < n || // A's start slot overlaps with b's end slot.
    e.start > t.start && e.start < t.end
  );
}
function aLt(t) {
  for (var e = O2t(t, ["startMs", function(a) {
    return -a.endMs;
  }]), n = []; e.length > 0; ) {
    var r = e.shift();
    n.push(r);
    for (var s = 0; s < e.length; s++) {
      var o = e[s];
      if (!(r.endMs > o.startMs)) {
        if (s > 0) {
          var i = e.splice(s, 1)[0];
          n.push(i);
        }
        break;
      }
    }
  }
  return n;
}
function fbe(t) {
  for (var e = t.events, n = t.minimumStartDifference, r = t.slotMetrics, s = t.accessors, o = e.map(function(d) {
    return new oLt(d, {
      slotMetrics: r,
      accessors: s
    });
  }), i = aLt(o), a = [], c = function() {
    var u = i[l], f = a.find(function(y) {
      return y.end > u.start || Math.abs(u.start - y.start) < n;
    });
    if (!f)
      return u.rows = [], a.push(u), 1;
    u.container = f;
    for (var p = null, g = f.rows.length - 1; !p && g >= 0; g--)
      iLt(f.rows[g], u, n) && (p = f.rows[g]);
    p ? (p.leaves.push(u), u.row = p) : (u.leaves = [], f.rows.push(u));
  }, l = 0; l < i.length; l++)
    c();
  return i.map(function(d) {
    return {
      event: d.data,
      style: {
        top: d.top,
        height: d.height,
        width: d.width,
        xOffset: Math.max(0, d.xOffset)
      }
    };
  });
}
function hbe(t, e, n) {
  for (var r = 0; r < t.friends.length; ++r)
    if (!(n.indexOf(t.friends[r]) > -1)) {
      e = e > t.friends[r].idx ? e : t.friends[r].idx, n.push(t.friends[r]);
      var s = hbe(t.friends[r], e, n);
      e = e > s ? e : s;
    }
  return e;
}
function cLt(t) {
  var e = t.events, n = t.minimumStartDifference, r = t.slotMetrics, s = t.accessors, o = fbe({
    events: e,
    minimumStartDifference: n,
    slotMetrics: r,
    accessors: s
  });
  o.sort(function(R, j) {
    return R = R.style, j = j.style, R.top !== j.top ? R.top > j.top ? 1 : -1 : R.height !== j.height ? R.top + R.height < j.top + j.height ? 1 : -1 : 0;
  });
  for (var i = 0; i < o.length; ++i)
    o[i].friends = [], delete o[i].style.left, delete o[i].style.left, delete o[i].idx, delete o[i].size;
  for (var a = 0; a < o.length - 1; ++a)
    for (var c = o[a], l = c.style.top, d = c.style.top + c.style.height, u = a + 1; u < o.length; ++u) {
      var f = o[u], p = f.style.top, g = f.style.top + f.style.height;
      (p >= l && g <= d || g > l && g <= d || p >= l && p < d) && (c.friends.push(f), f.friends.push(c));
    }
  for (var y = 0; y < o.length; ++y) {
    for (var m = o[y], v = [], b = 0; b < 100; ++b) v.push(1);
    for (var x = 0; x < m.friends.length; ++x) m.friends[x].idx !== void 0 && (v[m.friends[x].idx] = 0);
    m.idx = v.indexOf(1);
  }
  for (var w = 0; w < o.length; ++w) {
    var S = 0;
    if (!o[w].size) {
      var C = [], _ = hbe(o[w], 0, C);
      S = 100 / (_ + 1), o[w].size = S;
      for (var E = 0; E < C.length; ++E) C[E].size = S;
    }
  }
  for (var M = 0; M < o.length; ++M) {
    var N = o[M];
    N.style.left = N.idx * N.size;
    for (var O = 0, D = 0; D < N.friends.length; ++D) {
      var k = N.friends[D].idx;
      O = O > k ? O : k;
    }
    O <= N.idx && (N.size = 100 - N.idx * N.size);
    var A = N.idx === 0 ? 0 : 3;
    N.style.width = "calc(".concat(N.size, "% - ").concat(A, "px)"), N.style.height = "calc(".concat(N.style.height, "% - 2px)"), N.style.xOffset = "calc(".concat(N.style.left, "% + ").concat(A, "px)");
  }
  return o;
}
var wY = {
  overlap: fbe,
  "no-overlap": cLt
};
function lLt(t) {
  return !!(t && t.constructor && t.call && t.apply);
}
function dLt(t) {
  t.events, t.minimumStartDifference, t.slotMetrics, t.accessors;
  var e = t.dayLayoutAlgorithm, n = e;
  return e in wY && (n = wY[e]), lLt(n) ? n.apply(this, arguments) : [];
}
var pbe = /* @__PURE__ */ function(t) {
  function e() {
    return xs(this, e), Ho(this, e, arguments);
  }
  return Vo(e, t), ws(e, [{
    key: "render",
    value: function() {
      var r = this.props, s = r.renderSlot, o = r.resource, i = r.group, a = r.getters, c = r.components, l = c === void 0 ? {} : c, d = l.timeSlotWrapper, u = d === void 0 ? El : d, f = a ? a.slotGroupProp(i) : {};
      return /* @__PURE__ */ B.createElement("div", Object.assign({
        className: "rbc-timeslot-group"
      }, f), i.map(function(p, g) {
        var y = a ? a.slotProp(p, o) : {};
        return /* @__PURE__ */ B.createElement(u, {
          key: g,
          value: p,
          resource: o
        }, /* @__PURE__ */ B.createElement("div", Object.assign({}, y, {
          className: kr("rbc-time-slot", y.className)
        }), s && s(p, g)));
      }));
    }
  }]);
}(hq);
function AC(t) {
  return typeof t == "string" ? t : t + "%";
}
function uLt(t) {
  var e = t.style, n = t.className, r = t.event, s = t.accessors, o = t.rtl, i = t.selected, a = t.label, c = t.continuesPrior, l = t.continuesAfter, d = t.getters, u = t.onClick, f = t.onDoubleClick, p = t.isBackgroundEvent, g = t.onKeyPress, y = t.components, m = y.event, v = y.eventWrapper, b = s.title(r), x = s.tooltip(r), w = s.end(r), S = s.start(r), C = d.eventProp(r, S, w, i), _ = [/* @__PURE__ */ B.createElement("div", {
    key: "1",
    className: "rbc-event-label"
  }, a), /* @__PURE__ */ B.createElement("div", {
    key: "2",
    className: "rbc-event-content"
  }, m ? /* @__PURE__ */ B.createElement(m, {
    event: r,
    title: b
  }) : b)], E = e.height, M = e.top, N = e.width, O = e.xOffset, D = Dn(Dn({}, C.style), {}, $h({
    top: AC(M),
    height: AC(E),
    width: AC(N)
  }, o ? "right" : "left", AC(O)));
  return /* @__PURE__ */ B.createElement(v, Object.assign({
    type: "time"
  }, t), /* @__PURE__ */ B.createElement("div", {
    role: "button",
    tabIndex: 0,
    onClick: u,
    onDoubleClick: f,
    style: D,
    onKeyDown: g,
    title: x ? (typeof a == "string" ? a + ": " : "") + x : void 0,
    className: kr(p ? "rbc-background-event" : "rbc-event", n, C.className, {
      "rbc-selected": i,
      "rbc-event-continues-earlier": c,
      "rbc-event-continues-later": l
    })
  }, _));
}
var fLt = function(e) {
  var n = e.children, r = e.className, s = e.style, o = e.innerRef;
  return /* @__PURE__ */ B.createElement("div", {
    className: r,
    style: s,
    ref: o
  }, n);
}, hLt = /* @__PURE__ */ B.forwardRef(function(t, e) {
  return /* @__PURE__ */ B.createElement(fLt, Object.assign({}, t, {
    innerRef: e
  }));
}), pLt = ["dayProp"], gLt = ["eventContainerWrapper", "timeIndicatorWrapper"], gbe = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    xs(this, e);
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
      s[o] = arguments[o];
    return n = Ho(this, e, [].concat(s)), n.state = {
      selecting: !1,
      timeIndicatorPosition: null
    }, n.intervalTriggered = !1, n.renderEvents = function(i) {
      var a = i.events, c = i.isBackgroundEvent, l = n.props, d = l.rtl, u = l.selected, f = l.accessors, p = l.localizer, g = l.getters, y = l.components, m = l.step, v = l.timeslots, b = l.dayLayoutAlgorithm, x = l.resizable, w = n, S = w.slotMetrics, C = p.messages, _ = dLt({
        events: a,
        accessors: f,
        slotMetrics: S,
        minimumStartDifference: Math.ceil(m * v / 2),
        dayLayoutAlgorithm: b
      });
      return _.map(function(E, M) {
        var N, O = E.event, D = E.style, k = f.end(O), A = f.start(O), R = (N = f.eventId(O)) !== null && N !== void 0 ? N : "evt_" + M, j = "eventTimeRangeFormat", $, F = S.startsBeforeDay(A), L = S.startsAfterDay(k);
        F ? j = "eventTimeRangeEndFormat" : L && (j = "eventTimeRangeStartFormat"), F && L ? $ = C.allDay : $ = p.format({
          start: A,
          end: k
        }, j);
        var z = F || S.startsBefore(A), H = L || S.startsAfter(k);
        return /* @__PURE__ */ B.createElement(uLt, {
          style: D,
          event: O,
          label: $,
          key: R,
          getters: g,
          rtl: d,
          components: y,
          continuesPrior: z,
          continuesAfter: H,
          accessors: f,
          resource: n.props.resource,
          selected: PA(O, u),
          onClick: function(W) {
            return n._select(Dn(Dn(Dn({}, O), n.props.resource && {
              sourceResource: n.props.resource
            }), c && {
              isBackgroundEvent: !0
            }), W);
          },
          onDoubleClick: function(W) {
            return n._doubleClick(O, W);
          },
          isBackgroundEvent: c,
          onKeyPress: function(W) {
            return n._keyPress(O, W);
          },
          resizable: x
        });
      });
    }, n._selectable = function() {
      var i = n.containerRef.current, a = n.props, c = a.longPressThreshold, l = a.localizer, d = n._selector = new abe(function() {
        return i;
      }, {
        longPressThreshold: c
      }), u = function(y) {
        var m = n.props.onSelecting, v = n.state || {}, b = f(y), x = b.startDate, w = b.endDate;
        m && (l.eq(v.startDate, x, "minutes") && l.eq(v.endDate, w, "minutes") || m({
          start: x,
          end: w,
          resourceId: n.props.resource
        }) === !1) || (n.state.start !== b.start || n.state.end !== b.end || n.state.selecting !== b.selecting) && n.setState(b);
      }, f = function(y) {
        var m = n.slotMetrics.closestSlotFromPoint(y, eg(i));
        n.state.selecting || (n._initialSlot = m);
        var v = n._initialSlot;
        l.lte(v, m) ? m = n.slotMetrics.nextSlot(m) : l.gt(v, m) && (v = n.slotMetrics.nextSlot(v));
        var b = n.slotMetrics.getRange(l.min(v, m), l.max(v, m));
        return Dn(Dn({}, b), {}, {
          selecting: !0,
          top: "".concat(b.top, "%"),
          height: "".concat(b.height, "%")
        });
      }, p = function(y, m) {
        if (!PP(n.containerRef.current, y)) {
          var v = f(y), b = v.startDate, x = v.endDate;
          n._selectSlot({
            startDate: b,
            endDate: x,
            action: m,
            box: y
          });
        }
        n.setState({
          selecting: !1
        });
      };
      d.on("selecting", u), d.on("selectStart", u), d.on("beforeSelect", function(g) {
        if (n.props.selectable === "ignoreEvents")
          return !PP(n.containerRef.current, g);
      }), d.on("click", function(g) {
        return p(g, "click");
      }), d.on("doubleClick", function(g) {
        return p(g, "doubleClick");
      }), d.on("select", function(g) {
        n.state.selecting && (n._selectSlot(Dn(Dn({}, n.state), {}, {
          action: "select",
          bounds: g
        })), n.setState({
          selecting: !1
        }));
      }), d.on("reset", function() {
        n.state.selecting && n.setState({
          selecting: !1
        });
      });
    }, n._teardownSelectable = function() {
      n._selector && (n._selector.teardown(), n._selector = null);
    }, n._selectSlot = function(i) {
      for (var a = i.startDate, c = i.endDate, l = i.action, d = i.bounds, u = i.box, f = a, p = []; n.props.localizer.lte(f, c); )
        p.push(f), f = new Date(+f + n.props.step * 60 * 1e3);
      Jn(n.props.onSelectSlot, {
        slots: p,
        start: a,
        end: c,
        resourceId: n.props.resource,
        action: l,
        bounds: d,
        box: u
      });
    }, n._select = function() {
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
        a[c] = arguments[c];
      Jn(n.props.onSelectEvent, a);
    }, n._doubleClick = function() {
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
        a[c] = arguments[c];
      Jn(n.props.onDoubleClickEvent, a);
    }, n._keyPress = function() {
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
        a[c] = arguments[c];
      Jn(n.props.onKeyPressEvent, a);
    }, n.slotMetrics = oz(n.props), n.containerRef = /* @__PURE__ */ mf(), n;
  }
  return Vo(e, t), ws(e, [{
    key: "componentDidMount",
    value: function() {
      this.props.selectable && this._selectable(), this.props.isNow && this.setTimeIndicatorPositionUpdateInterval();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this._teardownSelectable(), this.clearTimeIndicatorInterval();
    }
  }, {
    key: "componentDidUpdate",
    value: function(r, s) {
      this.props.selectable && !r.selectable && this._selectable(), !this.props.selectable && r.selectable && this._teardownSelectable();
      var o = this.props, i = o.getNow, a = o.isNow, c = o.localizer, l = o.date, d = o.min, u = o.max, f = c.neq(r.getNow(), i(), "minutes");
      if (r.isNow !== a || f) {
        if (this.clearTimeIndicatorInterval(), a) {
          var p = !f && c.eq(r.date, l, "minutes") && s.timeIndicatorPosition === this.state.timeIndicatorPosition;
          this.setTimeIndicatorPositionUpdateInterval(p);
        }
      } else a && (c.neq(r.min, d, "minutes") || c.neq(r.max, u, "minutes")) && this.positionTimeIndicator();
    }
    /**
     * @param tail {Boolean} - whether `positionTimeIndicator` call should be
     *   deferred or called upon setting interval (`true` - if deferred);
     */
  }, {
    key: "setTimeIndicatorPositionUpdateInterval",
    value: function() {
      var r = this, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
      !this.intervalTriggered && !s && this.positionTimeIndicator(), this._timeIndicatorTimeout = window.setTimeout(function() {
        r.intervalTriggered = !0, r.positionTimeIndicator(), r.setTimeIndicatorPositionUpdateInterval();
      }, 6e4);
    }
  }, {
    key: "clearTimeIndicatorInterval",
    value: function() {
      this.intervalTriggered = !1, window.clearTimeout(this._timeIndicatorTimeout);
    }
  }, {
    key: "positionTimeIndicator",
    value: function() {
      var r = this.props, s = r.min, o = r.max, i = r.getNow, a = i();
      if (a >= s && a <= o) {
        var c = this.slotMetrics.getCurrentTimePosition(a);
        this.intervalTriggered = !0, this.setState({
          timeIndicatorPosition: c
        });
      } else
        this.clearTimeIndicatorInterval();
    }
  }, {
    key: "render",
    value: function() {
      var r = this.props, s = r.date, o = r.max, i = r.rtl, a = r.isNow, c = r.resource, l = r.accessors, d = r.localizer, u = r.getters, f = u.dayProp, p = td(u, pLt), g = r.components, y = g.eventContainerWrapper, m = g.timeIndicatorWrapper, v = td(g, gLt);
      this.slotMetrics = this.slotMetrics.update(this.props);
      var b = this.slotMetrics, x = this.state, w = x.selecting, S = x.top, C = x.height, _ = x.startDate, E = x.endDate, M = {
        start: _,
        end: E
      }, N = f(o, c), O = N.className, D = N.style, k = {
        className: "rbc-current-time-indicator",
        style: {
          top: "".concat(this.state.timeIndicatorPosition, "%")
        }
      }, A = v.dayColumnWrapper || hLt;
      return /* @__PURE__ */ B.createElement(A, {
        ref: this.containerRef,
        date: s,
        style: D,
        className: kr(
          O,
          "rbc-day-slot",
          "rbc-time-column",
          a && "rbc-now",
          a && "rbc-today",
          // WHY
          w && "rbc-slot-selecting"
        ),
        slotMetrics: b,
        resource: c
      }, b.groups.map(function(R, j) {
        return /* @__PURE__ */ B.createElement(pbe, {
          key: j,
          group: R,
          resource: c,
          getters: p,
          components: v
        });
      }), /* @__PURE__ */ B.createElement(y, {
        localizer: d,
        resource: c,
        accessors: l,
        getters: p,
        components: v,
        slotMetrics: b
      }, /* @__PURE__ */ B.createElement("div", {
        className: kr("rbc-events-container", i && "rtl")
      }, this.renderEvents({
        events: this.props.backgroundEvents,
        isBackgroundEvent: !0
      }), this.renderEvents({
        events: this.props.events
      }))), w && /* @__PURE__ */ B.createElement("div", {
        className: "rbc-slot-selection",
        style: {
          top: S,
          height: C
        }
      }, /* @__PURE__ */ B.createElement("span", null, d.format(M, "selectRangeFormat"))), a && this.intervalTriggered && /* @__PURE__ */ B.createElement(m, k, /* @__PURE__ */ B.createElement("div", k)));
    }
  }]);
}(B.Component);
gbe.defaultProps = {
  dragThroughEvents: !0,
  timeslots: 2
};
var mbe = function(e) {
  var n = e.label;
  return /* @__PURE__ */ B.createElement(B.Fragment, null, n);
}, mLt = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    xs(this, e);
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
      s[o] = arguments[o];
    return n = Ho(this, e, [].concat(s)), n.handleHeaderClick = function(i, a, c) {
      c.preventDefault(), Jn(n.props.onDrillDown, [i, a]);
    }, n.renderRow = function(i) {
      var a = n.props, c = a.events, l = a.rtl, d = a.selectable, u = a.getNow, f = a.range, p = a.getters, g = a.localizer, y = a.accessors, m = a.components, v = a.resizable, b = y.resourceId(i), x = i ? c.filter(function(w) {
        return y.resource(w) === b;
      }) : c;
      return /* @__PURE__ */ B.createElement(u0, {
        isAllDay: !0,
        rtl: l,
        getNow: u,
        minRows: 2,
        maxRows: n.props.allDayMaxRows + 1,
        range: f,
        events: x,
        resourceId: b,
        className: "rbc-allday-cell",
        selectable: d,
        selected: n.props.selected,
        components: m,
        accessors: y,
        getters: p,
        localizer: g,
        onSelect: n.props.onSelectEvent,
        onShowMore: n.props.onShowMore,
        onDoubleClick: n.props.onDoubleClickEvent,
        onKeyPress: n.props.onKeyPressEvent,
        onSelectSlot: n.props.onSelectSlot,
        longPressThreshold: n.props.longPressThreshold,
        resizable: v
      });
    }, n;
  }
  return Vo(e, t), ws(e, [{
    key: "renderHeaderCells",
    value: function(r) {
      var s = this, o = this.props, i = o.localizer, a = o.getDrilldownView, c = o.getNow, l = o.getters.dayProp, d = o.components.header, u = d === void 0 ? sz : d, f = c();
      return r.map(function(p, g) {
        var y = a(p), m = i.format(p, "dayFormat"), v = l(p), b = v.className, x = v.style, w = /* @__PURE__ */ B.createElement(u, {
          date: p,
          label: m,
          localizer: i
        });
        return /* @__PURE__ */ B.createElement("div", {
          key: g,
          style: x,
          className: kr("rbc-header", b, i.isSameDate(p, f) && "rbc-today")
        }, y ? /* @__PURE__ */ B.createElement("button", {
          type: "button",
          className: "rbc-button-link",
          onClick: function(C) {
            return s.handleHeaderClick(p, y, C);
          }
        }, w) : /* @__PURE__ */ B.createElement("span", null, w));
      });
    }
  }, {
    key: "render",
    value: function() {
      var r = this, s = this.props, o = s.width, i = s.rtl, a = s.resources, c = s.range, l = s.events, d = s.getNow, u = s.accessors, f = s.selectable, p = s.components, g = s.getters, y = s.scrollRef, m = s.localizer, v = s.isOverflowing, b = s.components, x = b.timeGutterHeader, w = b.resourceHeader, S = w === void 0 ? mbe : w, C = s.resizable, _ = {};
      v && (_[i ? "marginLeft" : "marginRight"] = "".concat($B() - 1, "px"));
      var E = a.groupEvents(l);
      return /* @__PURE__ */ B.createElement("div", {
        style: _,
        ref: y,
        className: kr("rbc-time-header", v && "rbc-overflowing")
      }, /* @__PURE__ */ B.createElement("div", {
        className: "rbc-label rbc-time-header-gutter",
        style: {
          width: o,
          minWidth: o,
          maxWidth: o
        }
      }, x && /* @__PURE__ */ B.createElement(x, null)), a.map(function(M, N) {
        var O = Yp(M, 2), D = O[0], k = O[1];
        return /* @__PURE__ */ B.createElement("div", {
          className: "rbc-time-header-content",
          key: D || N
        }, k && /* @__PURE__ */ B.createElement("div", {
          className: "rbc-row rbc-row-resource",
          key: "resource_".concat(N)
        }, /* @__PURE__ */ B.createElement("div", {
          className: "rbc-header"
        }, /* @__PURE__ */ B.createElement(S, {
          index: N,
          label: u.resourceTitle(k),
          resource: k
        }))), /* @__PURE__ */ B.createElement("div", {
          className: "rbc-row rbc-time-header-cell".concat(c.length <= 1 ? " rbc-time-header-cell-single-day" : "")
        }, r.renderHeaderCells(c)), /* @__PURE__ */ B.createElement(u0, {
          isAllDay: !0,
          rtl: i,
          getNow: d,
          minRows: 2,
          maxRows: r.props.allDayMaxRows + 1,
          range: c,
          events: E.get(D) || [],
          resourceId: k && D,
          className: "rbc-allday-cell",
          selectable: f,
          selected: r.props.selected,
          components: p,
          accessors: u,
          getters: g,
          localizer: m,
          onSelect: r.props.onSelectEvent,
          onShowMore: r.props.onShowMore,
          onDoubleClick: r.props.onDoubleClickEvent,
          onKeyDown: r.props.onKeyPressEvent,
          onSelectSlot: r.props.onSelectSlot,
          longPressThreshold: r.props.longPressThreshold,
          resizable: C
        }));
      }));
    }
  }]);
}(B.Component), yLt = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    xs(this, e);
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
      s[o] = arguments[o];
    return n = Ho(this, e, [].concat(s)), n.handleHeaderClick = function(i, a, c) {
      c.preventDefault(), Jn(n.props.onDrillDown, [i, a]);
    }, n;
  }
  return Vo(e, t), ws(e, [{
    key: "renderHeaderCells",
    value: function(r) {
      var s = this, o = this.props, i = o.localizer, a = o.getDrilldownView, c = o.getNow, l = o.getters.dayProp, d = o.components, u = d.header, f = u === void 0 ? sz : u, p = d.resourceHeader, g = p === void 0 ? mbe : p, y = o.resources, m = o.accessors, v = o.events, b = o.rtl, x = o.selectable, w = o.components, S = o.getters, C = o.resizable, _ = c(), E = y.groupEvents(v);
      return r.map(function(M, N) {
        var O = a(M), D = i.format(M, "dayFormat"), k = l(M), A = k.className, R = k.style, j = /* @__PURE__ */ B.createElement(f, {
          date: M,
          label: D,
          localizer: i
        });
        return /* @__PURE__ */ B.createElement("div", {
          key: N,
          className: "rbc-time-header-content rbc-resource-grouping"
        }, /* @__PURE__ */ B.createElement("div", {
          className: "rbc-row rbc-time-header-cell".concat(r.length <= 1 ? " rbc-time-header-cell-single-day" : "")
        }, /* @__PURE__ */ B.createElement("div", {
          style: R,
          className: kr("rbc-header", A, i.isSameDate(M, _) && "rbc-today")
        }, O ? /* @__PURE__ */ B.createElement("button", {
          type: "button",
          className: "rbc-button-link",
          onClick: function(F) {
            return s.handleHeaderClick(M, O, F);
          }
        }, j) : /* @__PURE__ */ B.createElement("span", null, j))), /* @__PURE__ */ B.createElement("div", {
          className: "rbc-row"
        }, y.map(function($, F) {
          var L = Yp($, 2), z = L[0], H = L[1];
          return /* @__PURE__ */ B.createElement("div", {
            key: "resource_".concat(z, "_").concat(F),
            className: kr("rbc-header", A, i.isSameDate(M, _) && "rbc-today")
          }, /* @__PURE__ */ B.createElement(g, {
            index: F,
            label: m.resourceTitle(H),
            resource: H
          }));
        })), /* @__PURE__ */ B.createElement("div", {
          className: "rbc-row rbc-m-b-negative-3 rbc-h-full"
        }, y.map(function($, F) {
          var L = Yp($, 2), z = L[0], H = L[1], U = (E.get(z) || []).filter(function(W) {
            return i.isSameDate(W.start, M) || i.isSameDate(W.end, M);
          });
          return /* @__PURE__ */ B.createElement(u0, {
            key: "resource_".concat(z, "_").concat(F),
            isAllDay: !0,
            rtl: b,
            getNow: c,
            minRows: 2,
            maxRows: s.props.allDayMaxRows + 1,
            range: [M],
            events: U,
            resourceId: H && z,
            className: "rbc-allday-cell",
            selectable: x,
            selected: s.props.selected,
            components: w,
            accessors: m,
            getters: S,
            localizer: i,
            onSelect: s.props.onSelectEvent,
            onShowMore: s.props.onShowMore,
            onDoubleClick: s.props.onDoubleClickEvent,
            onKeyDown: s.props.onKeyPressEvent,
            onSelectSlot: s.props.onSelectSlot,
            longPressThreshold: s.props.longPressThreshold,
            resizable: C
          });
        })));
      });
    }
  }, {
    key: "render",
    value: function() {
      var r = this.props, s = r.width, o = r.rtl, i = r.range, a = r.scrollRef, c = r.isOverflowing, l = r.components.timeGutterHeader, d = {};
      return c && (d[o ? "marginLeft" : "marginRight"] = "".concat($B() - 1, "px")), /* @__PURE__ */ B.createElement("div", {
        style: d,
        ref: a,
        className: kr("rbc-time-header", c && "rbc-overflowing")
      }, /* @__PURE__ */ B.createElement("div", {
        className: "rbc-label rbc-time-header-gutter",
        style: {
          width: s,
          minWidth: s,
          maxWidth: s
        }
      }, l && /* @__PURE__ */ B.createElement(l, null)), this.renderHeaderCells(i));
    }
  }]);
}(B.Component);
function vLt(t) {
  var e = t.min, n = t.max, r = t.localizer;
  return r.getTimezoneOffset(e) !== r.getTimezoneOffset(n) ? {
    start: r.add(e, -1, "day"),
    end: r.add(n, -1, "day")
  } : {
    start: e,
    end: n
  };
}
var bLt = function(e) {
  var n = e.min, r = e.max, s = e.timeslots, o = e.step, i = e.localizer, a = e.getNow, c = e.resource, l = e.components, d = e.getters, u = e.gutterRef, f = l.timeGutterWrapper, p = Ke(
    function() {
      return vLt({
        min: n,
        max: r,
        localizer: i
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n == null ? void 0 : n.toISOString(), r == null ? void 0 : r.toISOString(), i]
  ), g = p.start, y = p.end, m = he(oz({
    min: g,
    max: y,
    timeslots: s,
    step: o,
    localizer: i
  })), v = Yp(m, 2), b = v[0], x = v[1];
  me(function() {
    b && x(b.update({
      min: g,
      max: y,
      timeslots: s,
      step: o,
      localizer: i
    }));
  }, [g == null ? void 0 : g.toISOString(), y == null ? void 0 : y.toISOString(), s, o]);
  var w = re(function(S, C) {
    if (C) return null;
    var _ = b.dateIsInGroup(a(), C);
    return /* @__PURE__ */ B.createElement("span", {
      className: kr("rbc-label", _ && "rbc-now")
    }, i.format(S, "timeGutterFormat"));
  }, [b, i, a]);
  return /* @__PURE__ */ B.createElement(f, {
    slotMetrics: b
  }, /* @__PURE__ */ B.createElement("div", {
    className: "rbc-time-gutter rbc-time-column",
    ref: u
  }, b.groups.map(function(S, C) {
    return /* @__PURE__ */ B.createElement(pbe, {
      key: C,
      group: S,
      resource: c,
      components: l,
      renderSlot: w,
      getters: d
    });
  })));
}, xLt = /* @__PURE__ */ B.forwardRef(function(t, e) {
  return /* @__PURE__ */ B.createElement(bLt, Object.assign({
    gutterRef: e
  }, t));
}), J2 = {};
function wLt(t, e) {
  return {
    map: function(r) {
      return t ? t.map(function(s, o) {
        return r([e.resourceId(s), s], o);
      }) : [r([J2, null], 0)];
    },
    groupEvents: function(r) {
      var s = /* @__PURE__ */ new Map();
      return t ? (r.forEach(function(o) {
        var i = e.resource(o) || J2;
        if (Array.isArray(i))
          i.forEach(function(c) {
            var l = s.get(c) || [];
            l.push(o), s.set(c, l);
          });
        else {
          var a = s.get(i) || [];
          a.push(o), s.set(i, a);
        }
      }), s) : (s.set(J2, r), s);
    }
  };
}
var Ov = /* @__PURE__ */ function(t) {
  function e(n) {
    var r;
    return xs(this, e), r = Ho(this, e, [n]), r.handleScroll = function(s) {
      r.scrollRef.current && (r.scrollRef.current.scrollLeft = s.target.scrollLeft);
    }, r.handleResize = function() {
      yG(r.rafHandle), r.rafHandle = xve(r.checkOverflow);
    }, r.handleKeyPressEvent = function() {
      r.clearSelection();
      for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++)
        o[i] = arguments[i];
      Jn(r.props.onKeyPressEvent, o);
    }, r.handleSelectEvent = function() {
      r.clearSelection();
      for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++)
        o[i] = arguments[i];
      Jn(r.props.onSelectEvent, o);
    }, r.handleDoubleClickEvent = function() {
      r.clearSelection();
      for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++)
        o[i] = arguments[i];
      Jn(r.props.onDoubleClickEvent, o);
    }, r.handleShowMore = function(s, o, i, a, c) {
      var l = r.props, d = l.popup, u = l.onDrillDown, f = l.onShowMore, p = l.getDrilldownView, g = l.doShowMoreDrillDown;
      if (r.clearSelection(), d) {
        var y = bve(i, r.containerRef.current);
        r.setState({
          overlay: {
            date: o,
            events: s,
            position: Dn(Dn({}, y), {}, {
              width: "200px"
            }),
            target: c
          }
        });
      } else g && Jn(u, [o, p(o) || gs.DAY]);
      Jn(f, [s, o, a]);
    }, r.handleSelectAllDaySlot = function(s, o) {
      var i = r.props.onSelectSlot, a = new Date(s[0]), c = new Date(s[s.length - 1]);
      c.setDate(s[s.length - 1].getDate() + 1), Jn(i, {
        slots: s,
        start: a,
        end: c,
        action: o.action,
        resourceId: o.resourceId
      });
    }, r.overlayDisplay = function() {
      r.setState({
        overlay: null
      });
    }, r.checkOverflow = function() {
      if (!r._updatingOverflow) {
        var s = r.contentRef.current;
        if (s != null && s.scrollHeight) {
          var o = s.scrollHeight > s.clientHeight;
          r.state.isOverflowing !== o && (r._updatingOverflow = !0, r.setState({
            isOverflowing: o
          }, function() {
            r._updatingOverflow = !1;
          }));
        }
      }
    }, r.memoizedResources = cs(function(s, o) {
      return wLt(s, o);
    }), r.state = {
      gutterWidth: void 0,
      isOverflowing: null
    }, r.scrollRef = /* @__PURE__ */ B.createRef(), r.contentRef = /* @__PURE__ */ B.createRef(), r.containerRef = /* @__PURE__ */ B.createRef(), r._scrollRatio = null, r.gutterRef = /* @__PURE__ */ mf(), r;
  }
  return Vo(e, t), ws(e, [{
    key: "getSnapshotBeforeUpdate",
    value: function() {
      return this.checkOverflow(), null;
    }
  }, {
    key: "componentDidMount",
    value: function() {
      this.props.width == null && this.measureGutter(), this.calculateScroll(), this.applyScroll(), window.addEventListener("resize", this.handleResize);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      window.removeEventListener("resize", this.handleResize), yG(this.rafHandle), this.measureGutterAnimationFrameRequest && window.cancelAnimationFrame(this.measureGutterAnimationFrameRequest);
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      this.applyScroll();
    }
  }, {
    key: "renderDayColumn",
    value: function(r, s, o, i, a, c, l, d, u, f) {
      var p = this.props, g = p.min, y = p.max, m = (i.get(s) || []).filter(function(b) {
        return c.inRange(r, l.start(b), l.end(b), "day");
      }), v = (a.get(s) || []).filter(function(b) {
        return c.inRange(r, l.start(b), l.end(b), "day");
      });
      return /* @__PURE__ */ B.createElement(gbe, Object.assign({}, this.props, {
        localizer: c,
        min: c.merge(r, g),
        max: c.merge(r, y),
        resource: o && s,
        components: d,
        isNow: c.isSameDate(r, f),
        key: "".concat(s, "-").concat(r),
        date: r,
        events: m,
        backgroundEvents: v,
        dayLayoutAlgorithm: u
      }));
    }
  }, {
    key: "renderResourcesFirst",
    value: function(r, s, o, i, a, c, l, d, u) {
      var f = this;
      return s.map(function(p) {
        var g = Yp(p, 2), y = g[0], m = g[1];
        return r.map(function(v) {
          return f.renderDayColumn(v, y, m, o, i, a, c, d, u, l);
        });
      });
    }
  }, {
    key: "renderRangeFirst",
    value: function(r, s, o, i, a, c, l, d, u) {
      var f = this;
      return r.map(function(p) {
        return /* @__PURE__ */ B.createElement("div", {
          style: {
            display: "flex",
            minHeight: "100%",
            flex: 1
          },
          key: p
        }, s.map(function(g) {
          var y = Yp(g, 2), m = y[0], v = y[1];
          return /* @__PURE__ */ B.createElement("div", {
            style: {
              flex: 1
            },
            key: c.resourceId(v)
          }, f.renderDayColumn(p, m, v, o, i, a, c, d, u, l));
        }));
      });
    }
  }, {
    key: "renderEvents",
    value: function(r, s, o, i) {
      var a = this.props, c = a.accessors, l = a.localizer, d = a.resourceGroupingLayout, u = a.components, f = a.dayLayoutAlgorithm, p = this.memoizedResources(this.props.resources, c), g = p.groupEvents(s), y = p.groupEvents(o);
      return d ? this.renderRangeFirst(r, p, g, y, l, c, i, u, f) : this.renderResourcesFirst(r, p, g, y, l, c, i, u, f);
    }
  }, {
    key: "render",
    value: function() {
      var r, s = this.props, o = s.events, i = s.backgroundEvents, a = s.range, c = s.width, l = s.rtl, d = s.selected, u = s.getNow, f = s.resources, p = s.components, g = s.accessors, y = s.getters, m = s.localizer, v = s.min, b = s.max, x = s.showMultiDayTimes, w = s.longPressThreshold, S = s.resizable, C = s.resourceGroupingLayout;
      c = c || this.state.gutterWidth;
      var _ = a[0], E = a[a.length - 1];
      this.slots = a.length;
      var M = [], N = [], O = [];
      o.forEach(function(k) {
        if (d0(k, _, E, g, m)) {
          var A = g.start(k), R = g.end(k);
          g.allDay(k) || m.startAndEndAreDateOnly(A, R) || !x && !m.isSameDate(A, R) ? M.push(k) : N.push(k);
        }
      }), i.forEach(function(k) {
        d0(k, _, E, g, m) && O.push(k);
      }), M.sort(function(k, A) {
        return _$(k, A, g, m);
      });
      var D = {
        range: a,
        events: M,
        width: c,
        rtl: l,
        getNow: u,
        localizer: m,
        selected: d,
        allDayMaxRows: this.props.showAllEvents ? 1 / 0 : (r = this.props.allDayMaxRows) !== null && r !== void 0 ? r : 1 / 0,
        resources: this.memoizedResources(f, g),
        selectable: this.props.selectable,
        accessors: g,
        getters: y,
        components: p,
        scrollRef: this.scrollRef,
        isOverflowing: this.state.isOverflowing,
        longPressThreshold: w,
        onSelectSlot: this.handleSelectAllDaySlot,
        onSelectEvent: this.handleSelectEvent,
        onShowMore: this.handleShowMore,
        onDoubleClickEvent: this.props.onDoubleClickEvent,
        onKeyPressEvent: this.props.onKeyPressEvent,
        onDrillDown: this.props.onDrillDown,
        getDrilldownView: this.props.getDrilldownView,
        resizable: S
      };
      return /* @__PURE__ */ B.createElement("div", {
        className: kr("rbc-time-view", f && "rbc-time-view-resources"),
        ref: this.containerRef
      }, f && f.length > 1 && C ? /* @__PURE__ */ B.createElement(yLt, D) : /* @__PURE__ */ B.createElement(mLt, D), this.props.popup && this.renderOverlay(), /* @__PURE__ */ B.createElement("div", {
        ref: this.contentRef,
        className: "rbc-time-content",
        onScroll: this.handleScroll
      }, /* @__PURE__ */ B.createElement(xLt, {
        date: _,
        ref: this.gutterRef,
        localizer: m,
        min: m.merge(_, v),
        max: m.merge(_, b),
        step: this.props.step,
        getNow: this.props.getNow,
        timeslots: this.props.timeslots,
        components: p,
        className: "rbc-time-gutter",
        getters: y
      }), this.renderEvents(a, N, O, u())));
    }
  }, {
    key: "renderOverlay",
    value: function() {
      var r, s, o = this, i = (r = (s = this.state) === null || s === void 0 ? void 0 : s.overlay) !== null && r !== void 0 ? r : {}, a = this.props, c = a.accessors, l = a.localizer, d = a.components, u = a.getters, f = a.selected, p = a.popupOffset, g = a.handleDragStart, y = function() {
        return o.setState({
          overlay: null
        });
      };
      return /* @__PURE__ */ B.createElement(rz, {
        overlay: i,
        accessors: c,
        localizer: l,
        components: d,
        getters: u,
        selected: f,
        popupOffset: p,
        ref: this.containerRef,
        handleKeyPressEvent: this.handleKeyPressEvent,
        handleSelectEvent: this.handleSelectEvent,
        handleDoubleClickEvent: this.handleDoubleClickEvent,
        handleDragStart: g,
        show: !!i.position,
        overlayDisplay: this.overlayDisplay,
        onHide: y
      });
    }
  }, {
    key: "clearSelection",
    value: function() {
      clearTimeout(this._selectTimer), this._pendingSelection = [];
    }
  }, {
    key: "measureGutter",
    value: function() {
      var r = this;
      this.measureGutterAnimationFrameRequest && window.cancelAnimationFrame(this.measureGutterAnimationFrameRequest), this.measureGutterAnimationFrameRequest = window.requestAnimationFrame(function() {
        var s, o = (s = r.gutterRef) !== null && s !== void 0 && s.current ? w$(r.gutterRef.current) : void 0;
        o && r.state.gutterWidth !== o && r.setState({
          gutterWidth: o
        });
      });
    }
  }, {
    key: "applyScroll",
    value: function() {
      if (this._scrollRatio != null && this.props.enableAutoScroll === !0) {
        var r = this.contentRef.current;
        r.scrollTop = r.scrollHeight * this._scrollRatio, this._scrollRatio = null;
      }
    }
  }, {
    key: "calculateScroll",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props, s = r.min, o = r.max, i = r.scrollToTime, a = r.localizer, c = a.diff(a.merge(i, s), i, "milliseconds"), l = a.diff(s, o, "milliseconds");
      this._scrollRatio = c / l;
    }
  }]);
}(hq);
Ov.defaultProps = {
  step: 30,
  timeslots: 2,
  // To be compatible with old versions, default as `false`.
  resourceGroupingLayout: !1
};
var SLt = ["date", "localizer", "min", "max", "scrollToTime", "enableAutoScroll"], kA = /* @__PURE__ */ function(t) {
  function e() {
    return xs(this, e), Ho(this, e, arguments);
  }
  return Vo(e, t), ws(e, [{
    key: "render",
    value: function() {
      var r = this.props, s = r.date, o = r.localizer, i = r.min, a = i === void 0 ? o.startOf(/* @__PURE__ */ new Date(), "day") : i, c = r.max, l = c === void 0 ? o.endOf(/* @__PURE__ */ new Date(), "day") : c, d = r.scrollToTime, u = d === void 0 ? o.startOf(/* @__PURE__ */ new Date(), "day") : d, f = r.enableAutoScroll, p = f === void 0 ? !0 : f, g = td(r, SLt), y = e.range(s, {
        localizer: o
      });
      return /* @__PURE__ */ B.createElement(Ov, Object.assign({}, g, {
        range: y,
        eventOffset: 10,
        localizer: o,
        min: a,
        max: l,
        scrollToTime: u,
        enableAutoScroll: p
      }));
    }
  }]);
}(B.Component);
kA.range = function(t, e) {
  var n = e.localizer;
  return [n.startOf(t, "day")];
};
kA.navigate = function(t, e, n) {
  var r = n.localizer;
  switch (e) {
    case Vi.PREVIOUS:
      return r.add(t, -1, "day");
    case Vi.NEXT:
      return r.add(t, 1, "day");
    default:
      return t;
  }
};
kA.title = function(t, e) {
  var n = e.localizer;
  return n.format(t, "dayHeaderFormat");
};
var CLt = ["date", "localizer", "min", "max", "scrollToTime", "enableAutoScroll"], Hf = /* @__PURE__ */ function(t) {
  function e() {
    return xs(this, e), Ho(this, e, arguments);
  }
  return Vo(e, t), ws(e, [{
    key: "render",
    value: function() {
      var r = this.props, s = r.date, o = r.localizer, i = r.min, a = i === void 0 ? o.startOf(/* @__PURE__ */ new Date(), "day") : i, c = r.max, l = c === void 0 ? o.endOf(/* @__PURE__ */ new Date(), "day") : c, d = r.scrollToTime, u = d === void 0 ? o.startOf(/* @__PURE__ */ new Date(), "day") : d, f = r.enableAutoScroll, p = f === void 0 ? !0 : f, g = td(r, CLt), y = e.range(s, this.props);
      return /* @__PURE__ */ B.createElement(Ov, Object.assign({}, g, {
        range: y,
        eventOffset: 15,
        localizer: o,
        min: a,
        max: l,
        scrollToTime: u,
        enableAutoScroll: p
      }));
    }
  }]);
}(B.Component);
Hf.defaultProps = Ov.defaultProps;
Hf.navigate = function(t, e, n) {
  var r = n.localizer;
  switch (e) {
    case Vi.PREVIOUS:
      return r.add(t, -1, "week");
    case Vi.NEXT:
      return r.add(t, 1, "week");
    default:
      return t;
  }
};
Hf.range = function(t, e) {
  var n = e.localizer, r = n.startOfWeek(), s = n.startOf(t, "week", r), o = n.endOf(t, "week", r);
  return n.range(s, o);
};
Hf.title = function(t, e) {
  var n = e.localizer, r = Hf.range(t, {
    localizer: n
  }), s = Vve(r), o = s[0], i = s.slice(1);
  return n.format({
    start: o,
    end: i.pop()
  }, "dayRangeHeaderFormat");
};
var _Lt = ["date", "localizer", "min", "max", "scrollToTime", "enableAutoScroll"];
function iz(t, e) {
  return Hf.range(t, e).filter(function(n) {
    return [6, 0].indexOf(n.getDay()) === -1;
  });
}
var HS = /* @__PURE__ */ function(t) {
  function e() {
    return xs(this, e), Ho(this, e, arguments);
  }
  return Vo(e, t), ws(e, [{
    key: "render",
    value: function() {
      var r = this.props, s = r.date, o = r.localizer, i = r.min, a = i === void 0 ? o.startOf(/* @__PURE__ */ new Date(), "day") : i, c = r.max, l = c === void 0 ? o.endOf(/* @__PURE__ */ new Date(), "day") : c, d = r.scrollToTime, u = d === void 0 ? o.startOf(/* @__PURE__ */ new Date(), "day") : d, f = r.enableAutoScroll, p = f === void 0 ? !0 : f, g = td(r, _Lt), y = iz(s, this.props);
      return /* @__PURE__ */ B.createElement(Ov, Object.assign({}, g, {
        range: y,
        eventOffset: 15,
        localizer: o,
        min: a,
        max: l,
        scrollToTime: u,
        enableAutoScroll: p
      }));
    }
  }]);
}(B.Component);
HS.defaultProps = Ov.defaultProps;
HS.range = iz;
HS.navigate = Hf.navigate;
HS.title = function(t, e) {
  var n = e.localizer, r = iz(t, {
    localizer: n
  }), s = Vve(r), o = s[0], i = s.slice(1);
  return n.format({
    start: o,
    end: i.pop()
  }, "dayRangeHeaderFormat");
};
var AA = 30;
function MA(t) {
  var e = t.accessors, n = t.components, r = t.date, s = t.events, o = t.getters, i = t.length, a = i === void 0 ? AA : i, c = t.localizer, l = t.onDoubleClickEvent, d = t.onSelectEvent, u = t.selected, f = fe(null), p = fe(null), g = fe(null), y = fe(null), m = fe(null);
  me(function() {
    x();
  });
  var v = function(E, M, N) {
    var O = n.event, D = n.date;
    return M = M.filter(function(k) {
      return d0(k, c.startOf(E, "day"), c.endOf(E, "day"), e, c);
    }), M.map(function(k, A) {
      var R = e.title(k), j = e.end(k), $ = e.start(k), F = o.eventProp(k, $, j, PA(k, u)), L = A === 0 && c.format(E, "agendaDateFormat"), z = A === 0 ? /* @__PURE__ */ B.createElement("td", {
        rowSpan: M.length,
        className: "rbc-agenda-date-cell"
      }, D ? /* @__PURE__ */ B.createElement(D, {
        day: E,
        label: L
      }) : L) : !1;
      return /* @__PURE__ */ B.createElement("tr", {
        key: N + "_" + A,
        className: F.className,
        style: F.style
      }, z, /* @__PURE__ */ B.createElement("td", {
        className: "rbc-agenda-time-cell"
      }, b(E, k)), /* @__PURE__ */ B.createElement("td", {
        className: "rbc-agenda-event-cell",
        onClick: function(U) {
          return d && d(k, U);
        },
        onDoubleClick: function(U) {
          return l && l(k, U);
        }
      }, O ? /* @__PURE__ */ B.createElement(O, {
        event: k,
        title: R
      }) : R));
    }, []);
  }, b = function(E, M) {
    var N = "", O = n.time, D = c.messages.allDay, k = e.end(M), A = e.start(M);
    return e.allDay(M) || (c.eq(A, k) ? D = c.format(A, "agendaTimeFormat") : c.isSameDate(A, k) ? D = c.format({
      start: A,
      end: k
    }, "agendaTimeRangeFormat") : c.isSameDate(E, A) ? D = c.format(A, "agendaTimeFormat") : c.isSameDate(E, k) && (D = c.format(k, "agendaTimeFormat"))), c.gt(E, A, "day") && (N = "rbc-continues-prior"), c.lt(E, k, "day") && (N += " rbc-continues-after"), /* @__PURE__ */ B.createElement("span", {
      className: N.trim()
    }, O ? /* @__PURE__ */ B.createElement(O, {
      event: M,
      day: E,
      label: D
    }) : D);
  }, x = function() {
    if (m.current) {
      var E = f.current, M = m.current.firstChild;
      if (M) {
        var N = y.current.scrollHeight > y.current.clientHeight, O = [], D = O;
        O = [w$(M.children[0]), w$(M.children[1])], (D[0] !== O[0] || D[1] !== O[1]) && (p.current.style.width = O[0] + "px", g.current.style.width = O[1] + "px"), N ? (E_t(E, "rbc-header-overflowing"), E.style.marginRight = $B() + "px") : T_t(E, "rbc-header-overflowing");
      }
    }
  }, w = c.messages, S = c.add(r, a, "day"), C = c.range(r, S, "day");
  return s = s.filter(function(_) {
    return d0(_, c.startOf(r, "day"), c.endOf(S, "day"), e, c);
  }), s.sort(function(_, E) {
    return +e.start(_) - +e.start(E);
  }), /* @__PURE__ */ B.createElement("div", {
    className: "rbc-agenda-view"
  }, s.length !== 0 ? /* @__PURE__ */ B.createElement(B.Fragment, null, /* @__PURE__ */ B.createElement("table", {
    ref: f,
    className: "rbc-agenda-table"
  }, /* @__PURE__ */ B.createElement("thead", null, /* @__PURE__ */ B.createElement("tr", null, /* @__PURE__ */ B.createElement("th", {
    className: "rbc-header",
    ref: p
  }, w.date), /* @__PURE__ */ B.createElement("th", {
    className: "rbc-header",
    ref: g
  }, w.time), /* @__PURE__ */ B.createElement("th", {
    className: "rbc-header"
  }, w.event)))), /* @__PURE__ */ B.createElement("div", {
    className: "rbc-agenda-content",
    ref: y
  }, /* @__PURE__ */ B.createElement("table", {
    className: "rbc-agenda-table"
  }, /* @__PURE__ */ B.createElement("tbody", {
    ref: m
  }, C.map(function(_, E) {
    return v(_, s, E);
  }))))) : /* @__PURE__ */ B.createElement("span", {
    className: "rbc-agenda-empty"
  }, w.noEventsInRange));
}
MA.range = function(t, e) {
  var n = e.length, r = n === void 0 ? AA : n, s = e.localizer, o = s.add(t, r, "day");
  return {
    start: t,
    end: o
  };
};
MA.navigate = function(t, e, n) {
  var r = n.length, s = r === void 0 ? AA : r, o = n.localizer;
  switch (e) {
    case Vi.PREVIOUS:
      return o.add(t, -s, "day");
    case Vi.NEXT:
      return o.add(t, s, "day");
    default:
      return t;
  }
};
MA.title = function(t, e) {
  var n = e.length, r = n === void 0 ? AA : n, s = e.localizer, o = s.add(t, r, "day");
  return s.format({
    start: t,
    end: o
  }, "agendaHeaderFormat");
};
var B_ = $h($h($h($h($h({}, gs.MONTH, IA), gs.WEEK, Hf), gs.WORK_WEEK, HS), gs.DAY, kA), gs.AGENDA, MA), ELt = ["action", "date", "today"];
function TLt(t, e) {
  var n = e.action, r = e.date, s = e.today, o = td(e, ELt);
  switch (t = typeof t == "string" ? B_[t] : t, n) {
    case Vi.TODAY:
      r = s || /* @__PURE__ */ new Date();
      break;
    case Vi.DATE:
      break;
    default:
      Uf(t && typeof t.navigate == "function", "Calendar View components must implement a static `.navigate(date, action)` method.s"), r = t.navigate(r, n, o);
  }
  return r;
}
function PLt(t, e) {
  var n = null;
  return typeof e == "function" ? n = e(t) : typeof e == "string" && cu(t) === "object" && t != null && e in t && (n = t[e]), n;
}
var Pd = function(e) {
  return function(n) {
    return PLt(n, e);
  };
}, ILt = ["view", "date", "getNow", "onNavigate"], kLt = ["view", "toolbar", "events", "backgroundEvents", "resourceGroupingLayout", "style", "className", "elementProps", "date", "getNow", "length", "showMultiDayTimes", "onShowMore", "doShowMoreDrillDown", "components", "formats", "messages", "culture"];
function ybe(t) {
  if (Array.isArray(t))
    return t;
  for (var e = [], n = 0, r = Object.entries(t); n < r.length; n++) {
    var s = Yp(r[n], 2), o = s[0], i = s[1];
    i && e.push(o);
  }
  return e;
}
function ALt(t, e) {
  var n = e.views, r = ybe(n);
  return r.indexOf(t) !== -1;
}
var vbe = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    xs(this, e);
    for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)
      s[o] = arguments[o];
    return n = Ho(this, e, [].concat(s)), n.getViews = function() {
      var i = n.props.views;
      return Array.isArray(i) ? i$t(i, function(a, c) {
        return a[c] = B_[c];
      }, {}) : cu(i) === "object" ? iDt(i, function(a, c) {
        return a === !0 ? B_[c] : a;
      }) : B_;
    }, n.getView = function() {
      var i = n.getViews();
      return i[n.props.view];
    }, n.getDrilldownView = function(i) {
      var a = n.props, c = a.view, l = a.drilldownView, d = a.getDrilldownView;
      return d ? d(i, c, Object.keys(n.getViews())) : l;
    }, n.handleRangeChange = function(i, a, c) {
      var l = n.props, d = l.onRangeChange, u = l.localizer;
      d && (a.range ? d(a.range(i, {
        localizer: u
      }), c) : process.env.NODE_ENV !== "production" && console.error("onRangeChange prop not supported for this view"));
    }, n.handleNavigate = function(i, a) {
      var c = n.props, l = c.view, d = c.date, u = c.getNow, f = c.onNavigate, p = td(c, ILt), g = n.getView(), y = u();
      d = TLt(g, Dn(Dn({}, p), {}, {
        action: i,
        date: a || d || y,
        today: y
      })), f(d, l, i), n.handleRangeChange(d, g);
    }, n.handleViewChange = function(i) {
      i !== n.props.view && ALt(i, n.props) && n.props.onView(i);
      var a = n.getViews();
      n.handleRangeChange(n.props.date || n.props.getNow(), a[i], i);
    }, n.handleSelectEvent = function() {
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
        a[c] = arguments[c];
      Jn(n.props.onSelectEvent, a);
    }, n.handleDoubleClickEvent = function() {
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
        a[c] = arguments[c];
      Jn(n.props.onDoubleClickEvent, a);
    }, n.handleKeyPressEvent = function() {
      for (var i = arguments.length, a = new Array(i), c = 0; c < i; c++)
        a[c] = arguments[c];
      Jn(n.props.onKeyPressEvent, a);
    }, n.handleSelectSlot = function(i) {
      Jn(n.props.onSelectSlot, i);
    }, n.handleDrillDown = function(i, a) {
      var c = n.props.onDrillDown;
      if (c) {
        c(i, a, n.drilldownView);
        return;
      }
      a && n.handleViewChange(a), n.handleNavigate(Vi.DATE, i);
    }, n.state = {
      context: e.getContext(n.props)
    }, n;
  }
  return Vo(e, t), ws(e, [{
    key: "render",
    value: function() {
      var r = this.props, s = r.view, o = r.toolbar, i = r.events, a = r.backgroundEvents, c = r.resourceGroupingLayout, l = r.style, d = r.className, u = r.elementProps, f = r.date, p = r.getNow, g = r.length, y = r.showMultiDayTimes, m = r.onShowMore, v = r.doShowMoreDrillDown;
      r.components, r.formats, r.messages, r.culture;
      var b = td(r, kLt);
      f = f || p();
      var x = this.getView(), w = this.state.context, S = w.accessors, C = w.components, _ = w.getters, E = w.localizer, M = w.viewNames, N = C.toolbar || D$t, O = x.title(f, {
        localizer: E,
        length: g
      });
      return /* @__PURE__ */ B.createElement("div", Object.assign({}, u, {
        className: kr(d, "rbc-calendar", b.rtl && "rbc-rtl"),
        style: l
      }), o && /* @__PURE__ */ B.createElement(N, {
        date: f,
        view: s,
        views: M,
        label: O,
        onView: this.handleViewChange,
        onNavigate: this.handleNavigate,
        localizer: E
      }), /* @__PURE__ */ B.createElement(x, Object.assign({}, b, {
        events: i,
        backgroundEvents: a,
        date: f,
        getNow: p,
        length: g,
        localizer: E,
        getters: _,
        components: C,
        accessors: S,
        showMultiDayTimes: y,
        getDrilldownView: this.getDrilldownView,
        onNavigate: this.handleNavigate,
        onDrillDown: this.handleDrillDown,
        onSelectEvent: this.handleSelectEvent,
        onDoubleClickEvent: this.handleDoubleClickEvent,
        onKeyPressEvent: this.handleKeyPressEvent,
        onSelectSlot: this.handleSelectSlot,
        onShowMore: m,
        doShowMoreDrillDown: v,
        resourceGroupingLayout: c
      })));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(r) {
      return {
        context: e.getContext(r)
      };
    }
  }, {
    key: "getContext",
    value: function(r) {
      var s = r.startAccessor, o = r.endAccessor, i = r.allDayAccessor, a = r.tooltipAccessor, c = r.titleAccessor, l = r.resourceAccessor, d = r.resourceIdAccessor, u = r.resourceTitleAccessor, f = r.eventIdAccessor, p = r.eventPropGetter, g = r.backgroundEventPropGetter, y = r.slotPropGetter, m = r.slotGroupPropGetter, v = r.dayPropGetter, b = r.view, x = r.views, w = r.localizer, S = r.culture, C = r.messages, _ = C === void 0 ? {} : C, E = r.components, M = E === void 0 ? {} : E, N = r.formats, O = N === void 0 ? {} : N, D = ybe(x), k = j$t(_);
      return {
        viewNames: D,
        localizer: O$t(w, S, O, k),
        getters: {
          eventProp: function() {
            return p && p.apply(void 0, arguments) || {};
          },
          backgroundEventProp: function() {
            return g && g.apply(void 0, arguments) || {};
          },
          slotProp: function() {
            return y && y.apply(void 0, arguments) || {};
          },
          slotGroupProp: function() {
            return m && m.apply(void 0, arguments) || {};
          },
          dayProp: function() {
            return v && v.apply(void 0, arguments) || {};
          }
        },
        components: J2t(M[b] || {}, GRt(M, D), {
          eventWrapper: El,
          backgroundEventWrapper: El,
          eventContainerWrapper: El,
          dateCellWrapper: El,
          weekWrapper: El,
          timeSlotWrapper: El,
          timeGutterWrapper: El,
          timeIndicatorWrapper: El
        }),
        accessors: {
          start: Pd(s),
          end: Pd(o),
          allDay: Pd(i),
          tooltip: Pd(a),
          title: Pd(c),
          resource: Pd(l),
          resourceId: Pd(d),
          resourceTitle: Pd(u),
          eventId: Pd(f)
        }
      };
    }
  }]);
}(B.Component);
vbe.defaultProps = {
  events: [],
  backgroundEvents: [],
  elementProps: {},
  popup: !1,
  toolbar: !0,
  view: gs.MONTH,
  views: [gs.MONTH, gs.WEEK, gs.DAY, gs.AGENDA],
  step: 30,
  length: 30,
  allDayMaxRows: 1 / 0,
  doShowMoreDrillDown: !0,
  drilldownView: gs.DAY,
  titleAccessor: "title",
  tooltipAccessor: "title",
  allDayAccessor: "allDay",
  startAccessor: "start",
  endAccessor: "end",
  resourceAccessor: "resourceId",
  resourceIdAccessor: "id",
  resourceTitleAccessor: "title",
  eventIdAccessor: "id",
  longPressThreshold: 250,
  getNow: function() {
    return /* @__PURE__ */ new Date();
  },
  dayLayoutAlgorithm: "overlap"
};
var MLt = eve(vbe, {
  view: "onView",
  date: "onNavigate",
  selected: "onSelectEvent"
}), OLt = function(e, n, r) {
  var s = e.start, o = e.end;
  return "".concat(r.format(s, "P", n), "  ").concat(r.format(o, "P", n));
}, eD = function(e, n, r) {
  var s = e.start, o = e.end;
  return "".concat(r.format(s, "p", n), "  ").concat(r.format(o, "p", n));
}, DLt = function(e, n, r) {
  var s = e.start;
  return "".concat(r.format(s, "h:mma", n), "  ");
}, NLt = function(e, n, r) {
  var s = e.end;
  return "  ".concat(r.format(s, "h:mma", n));
}, jLt = function(e, n, r) {
  var s = e.start, o = e.end;
  return "".concat(r.format(s, "MMMM dd", n), "  ").concat(r.format(o, Sv(s, o, "month") ? "dd" : "MMMM dd", n));
}, RLt = {
  dateFormat: "dd",
  dayFormat: "dd eee",
  weekdayFormat: "ccc",
  selectRangeFormat: eD,
  eventTimeRangeFormat: eD,
  eventTimeRangeStartFormat: DLt,
  eventTimeRangeEndFormat: NLt,
  timeGutterFormat: "p",
  monthHeaderFormat: "MMMM yyyy",
  dayHeaderFormat: "cccc MMM dd",
  dayRangeHeaderFormat: jLt,
  agendaHeaderFormat: OLt,
  agendaDateFormat: "ccc MMM dd",
  agendaTimeFormat: "p",
  agendaTimeRangeFormat: eD
}, $Lt = function(e) {
  var n = e.startOfWeek, r = e.getDay, s = e.format, o = e.locales;
  return new M$t({
    formats: RLt,
    firstOfWeek: function(a) {
      return r(n(/* @__PURE__ */ new Date(), {
        locale: o[a]
      }));
    },
    format: function(a, c, l) {
      return s(new Date(a), c, {
        locale: o[l]
      });
    }
  });
};
const LLt = Hy("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"), Po = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(_le, { ref: n, className: Oe(LLt(), t), ...e }));
Po.displayName = _le.displayName;
const az = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  Hde,
  {
    className: Oe(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50",
      t
    ),
    ...e,
    ref: n,
    children: /* @__PURE__ */ h.jsx(
      DXe,
      {
        className: Oe(
          "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
        )
      }
    )
  }
));
az.displayName = Hde.displayName;
const T$ = [
  { id: "blue", name: "Blue", color: "hsl(199, 89%, 48%)" },
  { id: "green", name: "Green", color: "hsl(142, 76%, 36%)" },
  { id: "purple", name: "Purple", color: "hsl(262, 83%, 58%)" },
  { id: "orange", name: "Orange", color: "hsl(25, 95%, 53%)" },
  { id: "red", name: "Red", color: "hsl(0, 84%, 60%)" },
  { id: "teal", name: "Teal", color: "hsl(174, 72%, 40%)" }
];
function SY(t) {
  if (t)
    return {
      title: t.title,
      description: t.description || "",
      startDate: t.start,
      endDate: t.end,
      startTime: Rr(t.start, "HH:mm"),
      endTime: Rr(t.end, "HH:mm"),
      allDay: t.allDay ?? !0,
      color: t.color || T$[0].color,
      tags: t.tags || []
    };
  const e = /* @__PURE__ */ new Date();
  return {
    title: "",
    description: "",
    startDate: e,
    endDate: e,
    startTime: Rr(e, "HH:mm"),
    endTime: Rr(new Date(e.getTime() + 60 * 60 * 1e3), "HH:mm"),
    allDay: !0,
    color: T$[0].color,
    tags: []
  };
}
function FLt({
  event: t,
  open: e,
  onOpenChange: n,
  onSave: r,
  onDelete: s,
  isNew: o = !1
}) {
  const [i, a] = he(() => SY(t)), [c, l] = he(t), [d, u] = he(e);
  (t !== c || e !== d) && (l(t), u(e), a(SY(t)));
  const f = (v) => a((b) => ({ ...b, ...v })), p = (v, b) => {
    const [x, w] = b.split(":").map(Number);
    return YMe(GMe(new Date(v), x), w);
  }, g = () => {
    if (!i.title.trim()) return;
    const v = i.allDay ? i.startDate : p(i.startDate, i.startTime), b = i.allDay ? i.endDate : p(i.endDate, i.endTime);
    r({
      id: (t == null ? void 0 : t.id) || _pe(),
      title: i.title.trim(),
      description: i.description.trim() || void 0,
      start: v,
      end: b,
      allDay: i.allDay,
      color: i.color,
      tags: i.tags.length > 0 ? i.tags : void 0,
      sourceType: (t == null ? void 0 : t.sourceType) || "manual",
      sourceId: t == null ? void 0 : t.sourceId
    }), n(!1);
  }, y = () => {
    t && (s(t.id), n(!1));
  }, m = (t == null ? void 0 : t.sourceType) && t.sourceType !== "manual";
  return /* @__PURE__ */ h.jsx(ig, { open: e, onOpenChange: n, children: /* @__PURE__ */ h.jsxs(Gf, { className: "max-w-md", children: [
    /* @__PURE__ */ h.jsx(ag, { children: /* @__PURE__ */ h.jsx(cg, { children: o ? "New Event" : "Edit Event" }) }),
    /* @__PURE__ */ h.jsxs("div", { className: "space-y-4 py-4", children: [
      m && /* @__PURE__ */ h.jsxs("div", { className: "text-xs text-muted-foreground bg-muted p-2 rounded", children: [
        "This event is linked to a ",
        (t == null ? void 0 : t.sourceType) === "task" ? "task" : "document"
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsx(Po, { children: "Title" }),
        /* @__PURE__ */ h.jsx(
          pa,
          {
            value: i.title,
            onChange: (v) => f({ title: v.target.value }),
            placeholder: "Event title",
            autoFocus: !0
          }
        )
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsx(Po, { children: "Description" }),
        /* @__PURE__ */ h.jsx(
          dA,
          {
            value: i.description,
            onChange: (v) => f({ description: v.target.value }),
            placeholder: "Add description...",
            className: "min-h-[80px]"
          }
        )
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsx(Po, { children: "Tags" }),
        /* @__PURE__ */ h.jsx(
          KQ,
          {
            tags: i.tags,
            onTagsChange: (v) => f({ tags: v }),
            placeholder: "Add tag..."
          }
        )
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ h.jsx(Po, { children: "All day" }),
        /* @__PURE__ */ h.jsx(az, { checked: i.allDay, onCheckedChange: (v) => f({ allDay: v }) })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
        /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx(Po, { children: "Start Date" }),
          /* @__PURE__ */ h.jsxs(Jx, { children: [
            /* @__PURE__ */ h.jsx(ew, { asChild: !0, children: /* @__PURE__ */ h.jsxs(_t, { variant: "outline", className: "w-full justify-start overflow-hidden", children: [
              /* @__PURE__ */ h.jsx(mp, { className: "mr-2 h-4 w-4 shrink-0" }),
              /* @__PURE__ */ h.jsx("span", { className: "truncate", children: Rr(i.startDate, "MMM d, yyyy") })
            ] }) }),
            /* @__PURE__ */ h.jsx(ty, { className: "w-auto p-0", align: "start", children: /* @__PURE__ */ h.jsx(
              yP,
              {
                mode: "single",
                selected: i.startDate,
                onSelect: (v) => v && f({ startDate: v }),
                className: Oe("p-3 pointer-events-auto")
              }
            ) })
          ] })
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx(Po, { children: "End Date" }),
          /* @__PURE__ */ h.jsxs(Jx, { children: [
            /* @__PURE__ */ h.jsx(ew, { asChild: !0, children: /* @__PURE__ */ h.jsxs(_t, { variant: "outline", className: "w-full justify-start overflow-hidden", children: [
              /* @__PURE__ */ h.jsx(mp, { className: "mr-2 h-4 w-4 shrink-0" }),
              /* @__PURE__ */ h.jsx("span", { className: "truncate", children: Rr(i.endDate, "MMM d, yyyy") })
            ] }) }),
            /* @__PURE__ */ h.jsx(ty, { className: "w-auto p-0", align: "start", children: /* @__PURE__ */ h.jsx(
              yP,
              {
                mode: "single",
                selected: i.endDate,
                onSelect: (v) => v && f({ endDate: v }),
                className: Oe("p-3 pointer-events-auto")
              }
            ) })
          ] })
        ] }),
        !i.allDay && /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
          /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ h.jsx(Po, { children: "Start Time" }),
            /* @__PURE__ */ h.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ h.jsx(Iz, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground pointer-events-none" }),
              /* @__PURE__ */ h.jsx(
                pa,
                {
                  type: "time",
                  value: i.startTime,
                  onChange: (v) => f({ startTime: v.target.value }),
                  className: "pl-9"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ h.jsx(Po, { children: "End Time" }),
            /* @__PURE__ */ h.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ h.jsx(Iz, { className: "absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground pointer-events-none" }),
              /* @__PURE__ */ h.jsx(
                pa,
                {
                  type: "time",
                  value: i.endTime,
                  onChange: (v) => f({ endTime: v.target.value }),
                  className: "pl-9"
                }
              )
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsx(Po, { children: "Color" }),
        /* @__PURE__ */ h.jsx("div", { className: "flex gap-2", children: T$.map((v) => /* @__PURE__ */ h.jsx(
          "button",
          {
            className: Oe(
              "h-6 w-6 rounded-full transition-transform",
              i.color === v.color && "ring-2 ring-offset-2 ring-primary scale-110"
            ),
            style: { backgroundColor: v.color },
            onClick: () => f({ color: v.color }),
            title: v.name
          },
          v.id
        )) })
      ] })
    ] }),
    /* @__PURE__ */ h.jsxs(FL, { className: "flex justify-between", children: [
      !o && !m && /* @__PURE__ */ h.jsxs(_t, { variant: "destructive", size: "sm", onClick: y, children: [
        /* @__PURE__ */ h.jsx(Ky, { className: "h-4 w-4 mr-2" }),
        "Delete"
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "flex gap-2 ml-auto", children: [
        /* @__PURE__ */ h.jsx(_t, { variant: "outline", onClick: () => n(!1), children: "Cancel" }),
        /* @__PURE__ */ h.jsx(_t, { onClick: g, disabled: !i.title.trim(), children: "Save" })
      ] })
    ] })
  ] }) });
}
function BLt({ date: t, events: e, onSelectEvent: n, onNavigate: r, weekStartsOn: s }) {
  const o = GL(t), i = Xke(t), a = qke({ start: o, end: i }), c = s === 1 ? ["M", "T", "W", "T", "F", "S", "S"] : ["S", "M", "T", "W", "T", "F", "S"], l = (u) => e.filter((f) => Ao(f.start, u)), d = (u) => {
    const f = u.getDay();
    return s === 1 ? f === 0 ? 6 : f - 1 : f;
  };
  return /* @__PURE__ */ h.jsxs("div", { className: "h-full flex flex-col", children: [
    /* @__PURE__ */ h.jsx("div", { className: "text-center py-3 border-b border-border", children: /* @__PURE__ */ h.jsx("h2", { className: "text-lg font-semibold", children: Rr(t, "yyyy") }) }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 grid grid-cols-3 lg:grid-cols-4 gap-4 p-4 overflow-auto", children: a.map((u) => {
      const f = ii(u), p = L0(u), g = Yke({ start: f, end: p }), y = d(f), m = Array(y).fill(null);
      return /* @__PURE__ */ h.jsxs("div", { className: "border border-border rounded-lg overflow-hidden", children: [
        /* @__PURE__ */ h.jsx("div", { className: "bg-muted px-3 py-2 text-center font-medium text-sm", children: Rr(u, "MMMM") }),
        /* @__PURE__ */ h.jsx("div", { className: "grid grid-cols-7 text-center text-[10px] text-muted-foreground border-b border-border", children: c.map((v, b) => /* @__PURE__ */ h.jsx("div", { className: "py-1", children: v }, b)) }),
        /* @__PURE__ */ h.jsxs("div", { className: "grid grid-cols-7", children: [
          m.map((v, b) => /* @__PURE__ */ h.jsx("div", { className: "aspect-square" }, `pad-${b}`)),
          g.map((v) => {
            const b = l(v), x = b.length > 0, w = Ake(v) || Mke(v);
            return /* @__PURE__ */ h.jsxs(
              "div",
              {
                className: Oe(
                  "aspect-square flex flex-col items-center justify-center text-xs cursor-pointer hover:bg-accent transition-colors relative",
                  pU(v) && "bg-primary text-primary-foreground font-bold",
                  w && !pU(v) && "bg-muted/50"
                ),
                onClick: () => r(v),
                children: [
                  /* @__PURE__ */ h.jsx("span", { children: Rr(v, "d") }),
                  x && /* @__PURE__ */ h.jsx("div", { className: "absolute bottom-0.5 flex gap-0.5", children: b.slice(0, 3).map((S, C) => /* @__PURE__ */ h.jsx(
                    "div",
                    {
                      className: "w-1 h-1 rounded-full",
                      style: { backgroundColor: S.color || "hsl(var(--primary))" },
                      onClick: (_) => {
                        _.stopPropagation(), n(S);
                      }
                    },
                    C
                  )) })
                ]
              },
              v.toISOString()
            );
          })
        ] })
      ] }, u.toISOString());
    }) })
  ] });
}
const z_ = rXe, U_ = sXe, zx = T.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ h.jsxs(
  yde,
  {
    ref: r,
    className: Oe(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      t
    ),
    ...n,
    children: [
      e,
      /* @__PURE__ */ h.jsx(oXe, { asChild: !0, children: /* @__PURE__ */ h.jsx($q, { className: "h-4 w-4 opacity-50" }) })
    ]
  }
));
zx.displayName = yde.displayName;
const bbe = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  wde,
  {
    ref: n,
    className: Oe("flex cursor-default items-center justify-center py-1", t),
    ...e,
    children: /* @__PURE__ */ h.jsx(qxe, { className: "h-4 w-4" })
  }
));
bbe.displayName = wde.displayName;
const xbe = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(
  Sde,
  {
    ref: n,
    className: Oe("flex cursor-default items-center justify-center py-1", t),
    ...e,
    children: /* @__PURE__ */ h.jsx($q, { className: "h-4 w-4" })
  }
));
xbe.displayName = Sde.displayName;
const Ux = T.forwardRef(({ className: t, children: e, position: n = "popper", ...r }, s) => /* @__PURE__ */ h.jsx(iXe, { children: /* @__PURE__ */ h.jsxs(
  vde,
  {
    ref: s,
    className: Oe(
      "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      t
    ),
    position: n,
    ...r,
    children: [
      /* @__PURE__ */ h.jsx(bbe, {}),
      /* @__PURE__ */ h.jsx(
        aXe,
        {
          className: Oe(
            "p-1",
            n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children: e
        }
      ),
      /* @__PURE__ */ h.jsx(xbe, {})
    ]
  }
) }));
Ux.displayName = vde.displayName;
const zLt = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(bde, { ref: n, className: Oe("py-1.5 pl-8 pr-2 text-sm font-semibold", t), ...e }));
zLt.displayName = bde.displayName;
const Gh = T.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ h.jsxs(
  xde,
  {
    ref: r,
    className: Oe(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      t
    ),
    ...n,
    children: [
      /* @__PURE__ */ h.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ h.jsx(lXe, { children: /* @__PURE__ */ h.jsx(W$, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ h.jsx(cXe, { children: e })
    ]
  }
));
Gh.displayName = xde.displayName;
const ULt = T.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ h.jsx(Cde, { ref: n, className: Oe("-mx-1 my-1 h-px bg-muted", t), ...e }));
ULt.displayName = Cde.displayName;
function HLt({ config: t, onConfigChange: e }) {
  const n = Array.from({ length: 24 }, (r, s) => s);
  return /* @__PURE__ */ h.jsxs(wZ, { children: [
    /* @__PURE__ */ h.jsx(t_e, { asChild: !0, children: /* @__PURE__ */ h.jsx(_t, { variant: "ghost", size: "icon", className: "h-8 w-8", children: /* @__PURE__ */ h.jsx(_0, { className: "h-4 w-4" }) }) }),
    /* @__PURE__ */ h.jsxs(mL, { children: [
      /* @__PURE__ */ h.jsxs(CZ, { children: [
        /* @__PURE__ */ h.jsx(_Z, { children: "Calendar Settings" }),
        /* @__PURE__ */ h.jsx(EZ, { children: "Configure how the calendar displays" })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-6 py-6", children: [
        /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx(Po, { children: "Week starts on" }),
          /* @__PURE__ */ h.jsxs(
            z_,
            {
              value: t.weekStartsOn.toString(),
              onValueChange: (r) => e({ ...t, weekStartsOn: parseInt(r) }),
              children: [
                /* @__PURE__ */ h.jsx(zx, { children: /* @__PURE__ */ h.jsx(U_, {}) }),
                /* @__PURE__ */ h.jsxs(Ux, { children: [
                  /* @__PURE__ */ h.jsx(Gh, { value: "0", children: "Sunday" }),
                  /* @__PURE__ */ h.jsx(Gh, { value: "1", children: "Monday" })
                ] })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx(Po, { children: "Day starts at" }),
          /* @__PURE__ */ h.jsxs(
            z_,
            {
              value: t.dayStartHour.toString(),
              onValueChange: (r) => e({ ...t, dayStartHour: parseInt(r) }),
              children: [
                /* @__PURE__ */ h.jsx(zx, { children: /* @__PURE__ */ h.jsx(U_, {}) }),
                /* @__PURE__ */ h.jsx(Ux, { children: n.slice(0, 12).map((r) => /* @__PURE__ */ h.jsx(Gh, { value: r.toString(), children: r === 0 ? "12 AM" : r < 12 ? `${r} AM` : "12 PM" }, r)) })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx(Po, { children: "Day ends at" }),
          /* @__PURE__ */ h.jsxs(
            z_,
            {
              value: t.dayEndHour.toString(),
              onValueChange: (r) => e({ ...t, dayEndHour: parseInt(r) }),
              children: [
                /* @__PURE__ */ h.jsx(zx, { children: /* @__PURE__ */ h.jsx(U_, {}) }),
                /* @__PURE__ */ h.jsx(Ux, { children: n.slice(12, 24).map((r) => /* @__PURE__ */ h.jsx(Gh, { value: r.toString(), children: r === 12 ? "12 PM" : r < 12 ? `${r} AM` : `${r - 12} PM` }, r)) })
              ]
            }
          )
        ] })
      ] })
    ] })
  ] });
}
const VLt = {
  day: "Day",
  week: "Week",
  month: "Month",
  year: "Year",
  agenda: "Agenda"
};
function WLt({
  currentDate: t,
  currentView: e,
  config: n,
  onNavigate: r,
  onViewChange: s,
  onConfigChange: o,
  onAddEvent: i
}) {
  const a = () => e === "year" ? Rr(t, "yyyy") : Rr(t, "MMMM yyyy");
  return /* @__PURE__ */ h.jsxs("div", { className: "flex justify-between items-center p-4 pb-2", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ h.jsx(_t, { variant: "outline", size: "sm", onClick: () => r("today"), children: "Today" }),
      /* @__PURE__ */ h.jsx(_t, { variant: "ghost", size: "icon", className: "h-8 w-8", onClick: () => r("prev"), children: /* @__PURE__ */ h.jsx(BP, { className: "h-4 w-4" }) }),
      /* @__PURE__ */ h.jsx(_t, { variant: "ghost", size: "icon", className: "h-8 w-8", onClick: () => r("next"), children: /* @__PURE__ */ h.jsx(Lq, { className: "h-4 w-4" }) }),
      /* @__PURE__ */ h.jsx("span", { className: "font-medium ml-2", children: a() })
    ] }),
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ h.jsx("div", { className: "flex border rounded-md overflow-hidden", children: ["day", "week", "month", "year", "agenda"].map((c) => /* @__PURE__ */ h.jsx(
        _t,
        {
          variant: e === c ? "default" : "ghost",
          size: "sm",
          className: "rounded-none border-0",
          onClick: () => s(c),
          children: VLt[c]
        },
        c
      )) }),
      /* @__PURE__ */ h.jsx(HLt, { config: n, onConfigChange: o }),
      /* @__PURE__ */ h.jsxs(_t, { onClick: i, size: "sm", children: [
        /* @__PURE__ */ h.jsx(Jc, { className: "h-4 w-4 mr-2" }),
        "Add Event"
      ] })
    ] })
  ] });
}
function KLt(t = "month") {
  const [e, n] = he(t), [r, s] = he(/* @__PURE__ */ new Date()), o = re((i) => {
    if (i === "today")
      s(/* @__PURE__ */ new Date());
    else if (i instanceof Date)
      s(i), e === "year" && n("day");
    else {
      const a = i === "prev" ? -1 : 1;
      s(e === "year" ? (c) => a > 0 ? WL(c, 1) : XMe(c, 1) : (c) => e === "day" ? new Date(c.setDate(c.getDate() + a)) : e === "week" ? new Date(c.setDate(c.getDate() + a * 7)) : e === "month" ? a > 0 ? Ca(c, 1) : qMe(c, 1) : c);
    }
  }, [e]);
  return {
    currentView: e,
    setCurrentView: n,
    currentDate: r,
    setCurrentDate: s,
    navigate: o
  };
}
const CY = "blueprint:calendar:settings", GLt = {
  weekStartsOn: 1,
  // Monday
  dayStartHour: 6,
  dayEndHour: 21
};
function YLt() {
  const [t, e] = he(GLt);
  me(() => {
    try {
      const r = localStorage.getItem(CY);
      r && e(JSON.parse(r));
    } catch (r) {
      console.error("Failed to load calendar settings:", r);
    }
  }, []);
  const n = re((r) => {
    e(r), localStorage.setItem(CY, JSON.stringify(r));
  }, []);
  return { config: t, updateConfig: n };
}
const qLt = { "en-US": F0 }, XLt = [];
function ZLt({
  events: t,
  onSaveEvent: e,
  onDeleteEvent: n,
  linkedEvents: r = XLt,
  onSaveCard: s,
  onDeleteCard: o
}) {
  const [i, a] = he(null), [c, l] = he(!1), [d, u] = he(!1), [f, p] = he(null), [g, y] = he(!1), { config: m, updateConfig: v } = YLt(), { currentView: b, setCurrentView: x, currentDate: w, setCurrentDate: S, navigate: C } = KLt(), _ = Ke(() => $Lt({
    format: Rr,
    parse: VMe,
    startOfWeek: () => Wi(/* @__PURE__ */ new Date(), { weekStartsOn: m.weekStartsOn }),
    getDay: VAe,
    locales: qLt
  }), [m.weekStartsOn]), E = Ke(() => [...t, ...r], [t, r]), M = re(($) => {
    "cardData" in $ && $.sourceType === "task" ? (p($), y(!0)) : (a($), u(!1), l(!0));
  }, []), N = re(($) => {
    f && s && s(f.sourceId, $);
  }, [f, s]), O = re(() => {
    f && o && (o(f.sourceId, f.cardId), y(!1));
  }, [f, o]), D = re(($) => {
    const F = $.start, L = $.end || lU(F, 1);
    a({
      id: "",
      title: "",
      start: F,
      end: L,
      allDay: $.action === "click"
    }), u(!0), l(!0);
  }, []), k = re(($) => {
    $.sourceType && $.sourceType !== "manual" || e($);
  }, [e]), A = re(() => {
    const $ = /* @__PURE__ */ new Date();
    a({
      id: "",
      title: "",
      start: $,
      end: lU($, 1),
      allDay: !1
    }), u(!0), l(!0);
  }, []), R = re(($) => {
    const F = $.sourceType && $.sourceType !== "manual";
    return {
      style: {
        backgroundColor: $.color || "hsl(var(--primary))",
        borderRadius: "4px",
        opacity: F ? 0.8 : 1,
        color: "white",
        border: "none",
        fontSize: "12px"
      }
    };
  }, []), j = re(($) => {
    C($);
  }, [C]);
  return /* @__PURE__ */ h.jsxs("div", { className: "w-full h-full flex flex-col", children: [
    /* @__PURE__ */ h.jsx(
      WLt,
      {
        currentDate: w,
        currentView: b,
        config: m,
        onNavigate: j,
        onViewChange: x,
        onConfigChange: v,
        onAddEvent: A
      }
    ),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 px-4 pb-4 calendar-container", children: b === "year" ? /* @__PURE__ */ h.jsx(
      BLt,
      {
        date: w,
        events: E,
        onSelectEvent: M,
        onNavigate: j,
        weekStartsOn: m.weekStartsOn
      }
    ) : /* @__PURE__ */ h.jsx(
      MLt,
      {
        localizer: _,
        events: E,
        startAccessor: "start",
        endAccessor: "end",
        view: b,
        onView: x,
        date: w,
        onNavigate: S,
        onSelectEvent: M,
        onSelectSlot: D,
        selectable: !0,
        eventPropGetter: R,
        views: [gs.DAY, gs.WEEK, gs.MONTH, gs.AGENDA],
        toolbar: !1,
        min: new Date(1970, 0, 1, m.dayStartHour, 0, 0),
        max: new Date(1970, 0, 1, m.dayEndHour, 0, 0),
        className: "rounded-lg border bg-background",
        style: { height: "100%" }
      }
    ) }),
    /* @__PURE__ */ h.jsx(
      FLt,
      {
        event: i,
        open: c,
        onOpenChange: l,
        onSave: k,
        onDelete: n,
        isNew: d
      }
    ),
    /* @__PURE__ */ h.jsx(
      Kye,
      {
        card: (f == null ? void 0 : f.cardData) ?? null,
        open: g,
        onOpenChange: y,
        onSave: N,
        onDelete: O
      }
    )
  ] });
}
function QLt(t) {
  return {
    id: t.id,
    title: t.title,
    start: t.start.toISOString(),
    end: t.end.toISOString(),
    allDay: t.allDay,
    description: t.description,
    color: t.color,
    tags: t.tags,
    sourceType: t.sourceType,
    sourceId: t.sourceId
  };
}
function JLt(t) {
  return {
    id: t.id,
    title: t.title,
    start: new Date(t.start),
    end: new Date(t.end),
    allDay: t.allDay,
    description: t.description,
    color: t.color,
    tags: t.tags,
    sourceType: t.sourceType,
    sourceId: t.sourceId
  };
}
const Ec = ["calendar-events"];
function eFt() {
  const t = dL(), e = Ke(() => nu(), []), { data: n = [], isLoading: r } = G1e({
    queryKey: Ec,
    queryFn: async () => (await e.listCalendarEvents()).map(JLt),
    // Keep data fresh, especially if multiple tabs are open
    staleTime: 1e3 * 30
    // 30 seconds
  }), s = s6({
    mutationFn: (c) => e.saveCalendarEvent(QLt(c)),
    // Optimistic Update: update UI immediately before server confirms
    onMutate: async (c) => {
      await t.cancelQueries({ queryKey: Ec });
      const l = t.getQueryData(Ec);
      return t.setQueryData(Ec, (d = []) => d.some((f) => f.id === c.id) ? d.map((f) => f.id === c.id ? c : f) : [...d, c]), { previousEvents: l };
    },
    // If it fails, roll back to previous state
    onError: (c, l, d) => {
      t.setQueryData(Ec, d == null ? void 0 : d.previousEvents), console.error("Failed to save calendar event:", c);
    },
    // Always refetch after success or error to stay in sync
    onSettled: () => {
      t.invalidateQueries({ queryKey: Ec });
    }
  }), o = s6({
    mutationFn: (c) => e.deleteCalendarEvent(c),
    onMutate: async (c) => {
      await t.cancelQueries({ queryKey: Ec });
      const l = t.getQueryData(Ec);
      return t.setQueryData(
        Ec,
        (d = []) => d.filter((u) => u.id !== c)
      ), { previousEvents: l };
    },
    onError: (c, l, d) => {
      t.setQueryData(Ec, d == null ? void 0 : d.previousEvents), console.error("Failed to delete calendar event:", c);
    },
    onSettled: () => {
      t.invalidateQueries({ queryKey: Ec });
    }
  }), i = re(
    async (c) => {
      s.mutate(c);
    },
    [s]
  ), a = re(
    async (c) => {
      o.mutate(c);
    },
    [o]
  );
  return {
    events: n,
    loading: r,
    saveEvent: i,
    deleteEvent: a
  };
}
function tFt() {
  const { artifacts: t, refresh: e } = uu(), n = Ke(() => {
    const o = [], i = t.filter((a) => a.type === "board");
    for (const a of i) {
      const c = a.data;
      if (c != null && c.columns) {
        for (const l of c.columns)
          for (const d of l.cards)
            if (d.dueDate) {
              const u = new Date(d.dueDate);
              o.push({
                id: `task-${d.id}`,
                title: ` ${d.title}`,
                start: u,
                end: u,
                allDay: !0,
                description: d.description,
                color: "hsl(25, 95%, 53%)",
                sourceType: "task",
                sourceId: a.id,
                cardId: d.id,
                cardData: d,
                boardName: a.name,
                tags: [`board:${a.name}`]
              });
            }
      }
    }
    return o;
  }, [t]), r = re(async (o, i) => {
    const a = t.find((u) => u.id === o);
    if (!a) return;
    const l = a.data.columns.map((u) => ({
      ...u,
      cards: u.cards.map((f) => f.id === i.id ? i : f)
    }));
    await nu().saveArtifact({
      ...a,
      data: { columns: l },
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    }), e();
  }, [t, e]), s = re(async (o, i) => {
    const a = t.find((u) => u.id === o);
    if (!a) return;
    const l = a.data.columns.map((u) => ({
      ...u,
      cards: u.cards.filter((f) => f.id !== i)
    }));
    await nu().saveArtifact({
      ...a,
      data: { columns: l },
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    }), e();
  }, [t, e]);
  return { events: n, saveCard: r, deleteCard: s };
}
const nFt = er.calendar;
function rFt() {
  const { events: t, loading: e, saveEvent: n, deleteEvent: r } = eFt(), { events: s, saveCard: o, deleteCard: i } = tFt();
  return e ? /* @__PURE__ */ h.jsx("div", { className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ h.jsx(Wy, { className: "h-8 w-8 animate-spin text-muted-foreground" }) }) : /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 border-b border-border bg-background px-4 py-3", children: [
      /* @__PURE__ */ h.jsx(nFt.icon, { className: "h-5 w-5 text-muted-foreground" }),
      /* @__PURE__ */ h.jsx("h1", { className: "text-lg font-semibold text-foreground", children: "Calendar" }),
      s.length > 0 && /* @__PURE__ */ h.jsxs("span", { className: "text-xs text-muted-foreground bg-muted px-2 py-0.5 rounded-full", children: [
        s.length,
        " task",
        s.length !== 1 ? "s" : "",
        " linked"
      ] })
    ] }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 overflow-hidden", children: /* @__PURE__ */ h.jsx(
      ZLt,
      {
        events: t,
        onSaveEvent: n,
        onDeleteEvent: r,
        linkedEvents: s,
        onSaveCard: o,
        onDeleteCard: i
      }
    ) })
  ] });
}
function sFt() {
  const [t, e] = he([]), [n, r] = he(!0), s = nu(), o = re(async () => {
    r(!0);
    try {
      const l = await s.listFavorites();
      e(bf(l));
    } catch (l) {
      console.error("Failed to load favorites:", l);
    } finally {
      r(!1);
    }
  }, [s]);
  me(() => {
    o();
  }, [o]);
  const i = re(async (l) => {
    await s.deleteArtifact(l), e((d) => d.filter((u) => u.id !== l));
  }, [s]), a = re(async (l) => {
    const d = t.find((u) => u.id === l);
    if (d) {
      const u = {
        ...d,
        favorite: !d.favorite,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        schemaVersion: d.schemaVersion ?? ss
      };
      await s.saveArtifact(u), e((f) => f.filter((p) => p.id !== l));
    }
  }, [t, s]), c = re(async (l) => {
    const d = t.find((u) => u.id === l);
    if (d) {
      const u = {
        ...d,
        pinned: !d.pinned,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        schemaVersion: d.schemaVersion ?? ss
      };
      await s.saveArtifact(u), e((f) => bf(f.map((p) => p.id === l ? u : p)));
    }
  }, [t, s]);
  return n ? /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(zl, { title: "Favorites", icon: yf }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ h.jsx(Wy, { className: "h-8 w-8 animate-spin text-muted-foreground" }) })
  ] }) : /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(zl, { title: "Favorites", icon: yf }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 p-6 overflow-auto", children: t.length === 0 ? /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col items-center justify-center h-full text-center", children: [
      /* @__PURE__ */ h.jsx(yf, { className: "h-12 w-12 text-muted-foreground mb-4" }),
      /* @__PURE__ */ h.jsx("h3", { className: "text-lg font-medium text-foreground mb-1", children: "No favorites yet" }),
      /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground max-w-sm", children: "Star your important artifacts to find them quickly here" })
    ] }) : /* @__PURE__ */ h.jsx("div", { className: "grid gap-4 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4", children: t.map((l) => /* @__PURE__ */ h.jsx(
      tF,
      {
        artifact: l,
        onDelete: i,
        onToggleFavorite: a,
        onTogglePinned: c
      },
      l.id
    )) }) })
  ] });
}
var VS = (t) => t.type === "checkbox", Yh = (t) => t instanceof Date, Jo = (t) => t == null;
const wbe = (t) => typeof t == "object";
var Vr = (t) => !Jo(t) && !Array.isArray(t) && wbe(t) && !Yh(t), Sbe = (t) => Vr(t) && t.target ? VS(t.target) ? t.target.checked : t.target.value : t, oFt = (t) => t.substring(0, t.search(/\.\d+(\.|$)/)) || t, Cbe = (t, e) => t.has(oFt(e)), iFt = (t) => {
  const e = t.constructor && t.constructor.prototype;
  return Vr(e) && e.hasOwnProperty("isPrototypeOf");
}, cz = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function fs(t) {
  let e;
  const n = Array.isArray(t), r = typeof FileList < "u" ? t instanceof FileList : !1;
  if (t instanceof Date)
    e = new Date(t);
  else if (!(cz && (t instanceof Blob || r)) && (n || Vr(t)))
    if (e = n ? [] : {}, !n && !iFt(t))
      e = t;
    else
      for (const s in t)
        t.hasOwnProperty(s) && (e[s] = fs(t[s]));
  else
    return t;
  return e;
}
var OA = (t) => /^\w*$/.test(t), jr = (t) => t === void 0, lz = (t) => Array.isArray(t) ? t.filter(Boolean) : [], dz = (t) => lz(t.replace(/["|']|\]/g, "").split(/\.|\[/)), Fe = (t, e, n) => {
  if (!e || !Vr(t))
    return n;
  const r = (OA(e) ? [e] : dz(e)).reduce((s, o) => Jo(s) ? s : s[o], t);
  return jr(r) || r === t ? jr(t[e]) ? n : t[e] : r;
}, sa = (t) => typeof t == "boolean", kn = (t, e, n) => {
  let r = -1;
  const s = OA(e) ? [e] : dz(e), o = s.length, i = o - 1;
  for (; ++r < o; ) {
    const a = s[r];
    let c = n;
    if (r !== i) {
      const l = t[a];
      c = Vr(l) || Array.isArray(l) ? l : isNaN(+s[r + 1]) ? {} : [];
    }
    if (a === "__proto__" || a === "constructor" || a === "prototype")
      return;
    t[a] = c, t = t[a];
  }
};
const IP = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, $c = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, Id = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
}, _be = B.createContext(null);
_be.displayName = "HookFormContext";
const uz = () => B.useContext(_be);
var Ebe = (t, e, n, r = !0) => {
  const s = {
    defaultValues: e._defaultValues
  };
  for (const o in t)
    Object.defineProperty(s, o, {
      get: () => {
        const i = o;
        return e._proxyFormState[i] !== $c.all && (e._proxyFormState[i] = !r || $c.all), n && (n[i] = !0), t[i];
      }
    });
  return s;
};
const fz = typeof window < "u" ? B.useLayoutEffect : B.useEffect;
function aFt(t) {
  const e = uz(), { control: n = e.control, disabled: r, name: s, exact: o } = t || {}, [i, a] = B.useState(n._formState), c = B.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    validatingFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  });
  return fz(() => n._subscribe({
    name: s,
    formState: c.current,
    exact: o,
    callback: (l) => {
      !r && a({
        ...n._formState,
        ...l
      });
    }
  }), [s, r, o]), B.useEffect(() => {
    c.current.isValid && n._setValid(!0);
  }, [n]), B.useMemo(() => Ebe(i, n, c.current, !1), [i, n]);
}
var Ll = (t) => typeof t == "string", Tbe = (t, e, n, r, s) => Ll(t) ? (r && e.watch.add(t), Fe(n, t, s)) : Array.isArray(t) ? t.map((o) => (r && e.watch.add(o), Fe(n, o))) : (r && (e.watchAll = !0), n), P$ = (t) => Jo(t) || !wbe(t);
function Hd(t, e, n = /* @__PURE__ */ new WeakSet()) {
  if (P$(t) || P$(e))
    return t === e;
  if (Yh(t) && Yh(e))
    return t.getTime() === e.getTime();
  const r = Object.keys(t), s = Object.keys(e);
  if (r.length !== s.length)
    return !1;
  if (n.has(t) || n.has(e))
    return !0;
  n.add(t), n.add(e);
  for (const o of r) {
    const i = t[o];
    if (!s.includes(o))
      return !1;
    if (o !== "ref") {
      const a = e[o];
      if (Yh(i) && Yh(a) || Vr(i) && Vr(a) || Array.isArray(i) && Array.isArray(a) ? !Hd(i, a, n) : i !== a)
        return !1;
    }
  }
  return !0;
}
function cFt(t) {
  const e = uz(), { control: n = e.control, name: r, defaultValue: s, disabled: o, exact: i, compute: a } = t || {}, c = B.useRef(s), l = B.useRef(a), d = B.useRef(void 0);
  l.current = a;
  const u = B.useMemo(() => n._getWatch(r, c.current), [n, r]), [f, p] = B.useState(l.current ? l.current(u) : u);
  return fz(() => n._subscribe({
    name: r,
    formState: {
      values: !0
    },
    exact: i,
    callback: (g) => {
      if (!o) {
        const y = Tbe(r, n._names, g.values || n._formValues, !1, c.current);
        if (l.current) {
          const m = l.current(y);
          Hd(m, d.current) || (p(m), d.current = m);
        } else
          p(y);
      }
    }
  }), [n, o, r, i]), B.useEffect(() => n._removeUnmounted()), f;
}
function lFt(t) {
  const e = uz(), { name: n, disabled: r, control: s = e.control, shouldUnregister: o, defaultValue: i } = t, a = Cbe(s._names.array, n), c = B.useMemo(() => Fe(s._formValues, n, Fe(s._defaultValues, n, i)), [s, n, i]), l = cFt({
    control: s,
    name: n,
    defaultValue: c,
    exact: !0
  }), d = aFt({
    control: s,
    name: n,
    exact: !0
  }), u = B.useRef(t), f = B.useRef(s.register(n, {
    ...t.rules,
    value: l,
    ...sa(t.disabled) ? { disabled: t.disabled } : {}
  }));
  u.current = t;
  const p = B.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: !0,
      get: () => !!Fe(d.errors, n)
    },
    isDirty: {
      enumerable: !0,
      get: () => !!Fe(d.dirtyFields, n)
    },
    isTouched: {
      enumerable: !0,
      get: () => !!Fe(d.touchedFields, n)
    },
    isValidating: {
      enumerable: !0,
      get: () => !!Fe(d.validatingFields, n)
    },
    error: {
      enumerable: !0,
      get: () => Fe(d.errors, n)
    }
  }), [d, n]), g = B.useCallback((b) => f.current.onChange({
    target: {
      value: Sbe(b),
      name: n
    },
    type: IP.CHANGE
  }), [n]), y = B.useCallback(() => f.current.onBlur({
    target: {
      value: Fe(s._formValues, n),
      name: n
    },
    type: IP.BLUR
  }), [n, s._formValues]), m = B.useCallback((b) => {
    const x = Fe(s._fields, n);
    x && b && (x._f.ref = {
      focus: () => b.focus && b.focus(),
      select: () => b.select && b.select(),
      setCustomValidity: (w) => b.setCustomValidity(w),
      reportValidity: () => b.reportValidity()
    });
  }, [s._fields, n]), v = B.useMemo(() => ({
    name: n,
    value: l,
    ...sa(r) || d.disabled ? { disabled: d.disabled || r } : {},
    onChange: g,
    onBlur: y,
    ref: m
  }), [n, r, d.disabled, g, y, m, l]);
  return B.useEffect(() => {
    const b = s._options.shouldUnregister || o;
    s.register(n, {
      ...u.current.rules,
      ...sa(u.current.disabled) ? { disabled: u.current.disabled } : {}
    });
    const x = (w, S) => {
      const C = Fe(s._fields, w);
      C && C._f && (C._f.mount = S);
    };
    if (x(n, !0), b) {
      const w = fs(Fe(s._options.defaultValues, n));
      kn(s._defaultValues, n, w), jr(Fe(s._formValues, n)) && kn(s._formValues, n, w);
    }
    return !a && s.register(n), () => {
      (a ? b && !s._state.action : b) ? s.unregister(n) : x(n, !1);
    };
  }, [n, s, a, o]), B.useEffect(() => {
    s._setDisabledField({
      disabled: r,
      name: n
    });
  }, [r, n, s]), B.useMemo(() => ({
    field: v,
    formState: d,
    fieldState: p
  }), [v, d, p]);
}
const _Y = (t) => t.render(lFt(t));
var Pbe = (t, e, n, r, s) => e ? {
  ...n[t],
  types: {
    ...n[t] && n[t].types ? n[t].types : {},
    [r]: s || !0
  }
} : {}, Hx = (t) => Array.isArray(t) ? t : [t], EY = () => {
  let t = [];
  return {
    get observers() {
      return t;
    },
    next: (s) => {
      for (const o of t)
        o.next && o.next(s);
    },
    subscribe: (s) => (t.push(s), {
      unsubscribe: () => {
        t = t.filter((o) => o !== s);
      }
    }),
    unsubscribe: () => {
      t = [];
    }
  };
}, Ei = (t) => Vr(t) && !Object.keys(t).length, hz = (t) => t.type === "file", Lc = (t) => typeof t == "function", kP = (t) => {
  if (!cz)
    return !1;
  const e = t ? t.ownerDocument : 0;
  return t instanceof (e && e.defaultView ? e.defaultView.HTMLElement : HTMLElement);
}, Ibe = (t) => t.type === "select-multiple", pz = (t) => t.type === "radio", dFt = (t) => pz(t) || VS(t), tD = (t) => kP(t) && t.isConnected;
function uFt(t, e) {
  const n = e.slice(0, -1).length;
  let r = 0;
  for (; r < n; )
    t = jr(t) ? r++ : t[e[r++]];
  return t;
}
function fFt(t) {
  for (const e in t)
    if (t.hasOwnProperty(e) && !jr(t[e]))
      return !1;
  return !0;
}
function es(t, e) {
  const n = Array.isArray(e) ? e : OA(e) ? [e] : dz(e), r = n.length === 1 ? t : uFt(t, n), s = n.length - 1, o = n[s];
  return r && delete r[o], s !== 0 && (Vr(r) && Ei(r) || Array.isArray(r) && fFt(r)) && es(t, n.slice(0, -1)), t;
}
var kbe = (t) => {
  for (const e in t)
    if (Lc(t[e]))
      return !0;
  return !1;
};
function AP(t, e = {}) {
  const n = Array.isArray(t);
  if (Vr(t) || n)
    for (const r in t)
      Array.isArray(t[r]) || Vr(t[r]) && !kbe(t[r]) ? (e[r] = Array.isArray(t[r]) ? [] : {}, AP(t[r], e[r])) : Jo(t[r]) || (e[r] = !0);
  return e;
}
function Abe(t, e, n) {
  const r = Array.isArray(t);
  if (Vr(t) || r)
    for (const s in t)
      Array.isArray(t[s]) || Vr(t[s]) && !kbe(t[s]) ? jr(e) || P$(n[s]) ? n[s] = Array.isArray(t[s]) ? AP(t[s], []) : { ...AP(t[s]) } : Abe(t[s], Jo(e) ? {} : e[s], n[s]) : n[s] = !Hd(t[s], e[s]);
  return n;
}
var wb = (t, e) => Abe(t, e, AP(e));
const TY = {
  value: !1,
  isValid: !1
}, PY = { value: !0, isValid: !0 };
var Mbe = (t) => {
  if (Array.isArray(t)) {
    if (t.length > 1) {
      const e = t.filter((n) => n && n.checked && !n.disabled).map((n) => n.value);
      return { value: e, isValid: !!e.length };
    }
    return t[0].checked && !t[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      t[0].attributes && !jr(t[0].attributes.value) ? jr(t[0].value) || t[0].value === "" ? PY : { value: t[0].value, isValid: !0 } : PY
    ) : TY;
  }
  return TY;
}, Obe = (t, { valueAsNumber: e, valueAsDate: n, setValueAs: r }) => jr(t) ? t : e ? t === "" ? NaN : t && +t : n && Ll(t) ? new Date(t) : r ? r(t) : t;
const IY = {
  isValid: !1,
  value: null
};
var Dbe = (t) => Array.isArray(t) ? t.reduce((e, n) => n && n.checked && !n.disabled ? {
  isValid: !0,
  value: n.value
} : e, IY) : IY;
function kY(t) {
  const e = t.ref;
  return hz(e) ? e.files : pz(e) ? Dbe(t.refs).value : Ibe(e) ? [...e.selectedOptions].map(({ value: n }) => n) : VS(e) ? Mbe(t.refs).value : Obe(jr(e.value) ? t.ref.value : e.value, t);
}
var hFt = (t, e, n, r) => {
  const s = {};
  for (const o of t) {
    const i = Fe(e, o);
    i && kn(s, o, i._f);
  }
  return {
    criteriaMode: n,
    names: [...t],
    fields: s,
    shouldUseNativeValidation: r
  };
}, MP = (t) => t instanceof RegExp, Sb = (t) => jr(t) ? t : MP(t) ? t.source : Vr(t) ? MP(t.value) ? t.value.source : t.value : t, AY = (t) => ({
  isOnSubmit: !t || t === $c.onSubmit,
  isOnBlur: t === $c.onBlur,
  isOnChange: t === $c.onChange,
  isOnAll: t === $c.all,
  isOnTouch: t === $c.onTouched
});
const MY = "AsyncFunction";
var pFt = (t) => !!t && !!t.validate && !!(Lc(t.validate) && t.validate.constructor.name === MY || Vr(t.validate) && Object.values(t.validate).find((e) => e.constructor.name === MY)), gFt = (t) => t.mount && (t.required || t.min || t.max || t.maxLength || t.minLength || t.pattern || t.validate), OY = (t, e, n) => !n && (e.watchAll || e.watch.has(t) || [...e.watch].some((r) => t.startsWith(r) && /^\.\w+/.test(t.slice(r.length))));
const Vx = (t, e, n, r) => {
  for (const s of n || Object.keys(t)) {
    const o = Fe(t, s);
    if (o) {
      const { _f: i, ...a } = o;
      if (i) {
        if (i.refs && i.refs[0] && e(i.refs[0], s) && !r)
          return !0;
        if (i.ref && e(i.ref, i.name) && !r)
          return !0;
        if (Vx(a, e))
          break;
      } else if (Vr(a) && Vx(a, e))
        break;
    }
  }
};
function DY(t, e, n) {
  const r = Fe(t, n);
  if (r || OA(n))
    return {
      error: r,
      name: n
    };
  const s = n.split(".");
  for (; s.length; ) {
    const o = s.join("."), i = Fe(e, o), a = Fe(t, o);
    if (i && !Array.isArray(i) && n !== o)
      return { name: n };
    if (a && a.type)
      return {
        name: o,
        error: a
      };
    if (a && a.root && a.root.type)
      return {
        name: `${o}.root`,
        error: a.root
      };
    s.pop();
  }
  return {
    name: n
  };
}
var mFt = (t, e, n, r) => {
  n(t);
  const { name: s, ...o } = t;
  return Ei(o) || Object.keys(o).length >= Object.keys(e).length || Object.keys(o).find((i) => e[i] === (!r || $c.all));
}, yFt = (t, e, n) => !t || !e || t === e || Hx(t).some((r) => r && (n ? r === e : r.startsWith(e) || e.startsWith(r))), vFt = (t, e, n, r, s) => s.isOnAll ? !1 : !n && s.isOnTouch ? !(e || t) : (n ? r.isOnBlur : s.isOnBlur) ? !t : (n ? r.isOnChange : s.isOnChange) ? t : !0, bFt = (t, e) => !lz(Fe(t, e)).length && es(t, e), xFt = (t, e, n) => {
  const r = Hx(Fe(t, n));
  return kn(r, "root", e[n]), kn(t, n, r), t;
}, H_ = (t) => Ll(t);
function NY(t, e, n = "validate") {
  if (H_(t) || Array.isArray(t) && t.every(H_) || sa(t) && !t)
    return {
      type: n,
      message: H_(t) ? t : "",
      ref: e
    };
}
var Gg = (t) => Vr(t) && !MP(t) ? t : {
  value: t,
  message: ""
}, jY = async (t, e, n, r, s, o) => {
  const { ref: i, refs: a, required: c, maxLength: l, minLength: d, min: u, max: f, pattern: p, validate: g, name: y, valueAsNumber: m, mount: v } = t._f, b = Fe(n, y);
  if (!v || e.has(y))
    return {};
  const x = a ? a[0] : i, w = (D) => {
    s && x.reportValidity && (x.setCustomValidity(sa(D) ? "" : D || ""), x.reportValidity());
  }, S = {}, C = pz(i), _ = VS(i), E = C || _, M = (m || hz(i)) && jr(i.value) && jr(b) || kP(i) && i.value === "" || b === "" || Array.isArray(b) && !b.length, N = Pbe.bind(null, y, r, S), O = (D, k, A, R = Id.maxLength, j = Id.minLength) => {
    const $ = D ? k : A;
    S[y] = {
      type: D ? R : j,
      message: $,
      ref: i,
      ...N(D ? R : j, $)
    };
  };
  if (o ? !Array.isArray(b) || !b.length : c && (!E && (M || Jo(b)) || sa(b) && !b || _ && !Mbe(a).isValid || C && !Dbe(a).isValid)) {
    const { value: D, message: k } = H_(c) ? { value: !!c, message: c } : Gg(c);
    if (D && (S[y] = {
      type: Id.required,
      message: k,
      ref: x,
      ...N(Id.required, k)
    }, !r))
      return w(k), S;
  }
  if (!M && (!Jo(u) || !Jo(f))) {
    let D, k;
    const A = Gg(f), R = Gg(u);
    if (!Jo(b) && !isNaN(b)) {
      const j = i.valueAsNumber || b && +b;
      Jo(A.value) || (D = j > A.value), Jo(R.value) || (k = j < R.value);
    } else {
      const j = i.valueAsDate || new Date(b), $ = (z) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + z), F = i.type == "time", L = i.type == "week";
      Ll(A.value) && b && (D = F ? $(b) > $(A.value) : L ? b > A.value : j > new Date(A.value)), Ll(R.value) && b && (k = F ? $(b) < $(R.value) : L ? b < R.value : j < new Date(R.value));
    }
    if ((D || k) && (O(!!D, A.message, R.message, Id.max, Id.min), !r))
      return w(S[y].message), S;
  }
  if ((l || d) && !M && (Ll(b) || o && Array.isArray(b))) {
    const D = Gg(l), k = Gg(d), A = !Jo(D.value) && b.length > +D.value, R = !Jo(k.value) && b.length < +k.value;
    if ((A || R) && (O(A, D.message, k.message), !r))
      return w(S[y].message), S;
  }
  if (p && !M && Ll(b)) {
    const { value: D, message: k } = Gg(p);
    if (MP(D) && !b.match(D) && (S[y] = {
      type: Id.pattern,
      message: k,
      ref: i,
      ...N(Id.pattern, k)
    }, !r))
      return w(k), S;
  }
  if (g) {
    if (Lc(g)) {
      const D = await g(b, n), k = NY(D, x);
      if (k && (S[y] = {
        ...k,
        ...N(Id.validate, k.message)
      }, !r))
        return w(k.message), S;
    } else if (Vr(g)) {
      let D = {};
      for (const k in g) {
        if (!Ei(D) && !r)
          break;
        const A = NY(await g[k](b, n), x, k);
        A && (D = {
          ...A,
          ...N(k, A.message)
        }, w(A.message), r && (S[y] = D));
      }
      if (!Ei(D) && (S[y] = {
        ref: x,
        ...D
      }, !r))
        return S;
    }
  }
  return w(!0), S;
};
const wFt = {
  mode: $c.onSubmit,
  reValidateMode: $c.onChange,
  shouldFocusError: !0
};
function SFt(t = {}) {
  let e = {
    ...wFt,
    ...t
  }, n = {
    submitCount: 0,
    isDirty: !1,
    isReady: !1,
    isLoading: Lc(e.defaultValues),
    isValidating: !1,
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: e.errors || {},
    disabled: e.disabled || !1
  }, r = {}, s = Vr(e.defaultValues) || Vr(e.values) ? fs(e.defaultValues || e.values) || {} : {}, o = e.shouldUnregister ? {} : fs(s), i = {
    action: !1,
    mount: !1,
    watch: !1
  }, a = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  }, c, l = 0;
  const d = {
    isDirty: !1,
    dirtyFields: !1,
    validatingFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  };
  let u = {
    ...d
  };
  const f = {
    array: EY(),
    state: EY()
  }, p = e.criteriaMode === $c.all, g = (X) => (ce) => {
    clearTimeout(l), l = setTimeout(X, ce);
  }, y = async (X) => {
    if (!e.disabled && (d.isValid || u.isValid || X)) {
      const ce = e.resolver ? Ei((await _()).errors) : await M(r, !0);
      ce !== n.isValid && f.state.next({
        isValid: ce
      });
    }
  }, m = (X, ce) => {
    !e.disabled && (d.isValidating || d.validatingFields || u.isValidating || u.validatingFields) && ((X || Array.from(a.mount)).forEach((pe) => {
      pe && (ce ? kn(n.validatingFields, pe, ce) : es(n.validatingFields, pe));
    }), f.state.next({
      validatingFields: n.validatingFields,
      isValidating: !Ei(n.validatingFields)
    }));
  }, v = (X, ce = [], pe, Ie, ke = !0, Ce = !0) => {
    if (Ie && pe && !e.disabled) {
      if (i.action = !0, Ce && Array.isArray(Fe(r, X))) {
        const De = pe(Fe(r, X), Ie.argA, Ie.argB);
        ke && kn(r, X, De);
      }
      if (Ce && Array.isArray(Fe(n.errors, X))) {
        const De = pe(Fe(n.errors, X), Ie.argA, Ie.argB);
        ke && kn(n.errors, X, De), bFt(n.errors, X);
      }
      if ((d.touchedFields || u.touchedFields) && Ce && Array.isArray(Fe(n.touchedFields, X))) {
        const De = pe(Fe(n.touchedFields, X), Ie.argA, Ie.argB);
        ke && kn(n.touchedFields, X, De);
      }
      (d.dirtyFields || u.dirtyFields) && (n.dirtyFields = wb(s, o)), f.state.next({
        name: X,
        isDirty: O(X, ce),
        dirtyFields: n.dirtyFields,
        errors: n.errors,
        isValid: n.isValid
      });
    } else
      kn(o, X, ce);
  }, b = (X, ce) => {
    kn(n.errors, X, ce), f.state.next({
      errors: n.errors
    });
  }, x = (X) => {
    n.errors = X, f.state.next({
      errors: n.errors,
      isValid: !1
    });
  }, w = (X, ce, pe, Ie) => {
    const ke = Fe(r, X);
    if (ke) {
      const Ce = Fe(o, X, jr(pe) ? Fe(s, X) : pe);
      jr(Ce) || Ie && Ie.defaultChecked || ce ? kn(o, X, ce ? Ce : kY(ke._f)) : A(X, Ce), i.mount && y();
    }
  }, S = (X, ce, pe, Ie, ke) => {
    let Ce = !1, De = !1;
    const ot = {
      name: X
    };
    if (!e.disabled) {
      if (!pe || Ie) {
        (d.isDirty || u.isDirty) && (De = n.isDirty, n.isDirty = ot.isDirty = O(), Ce = De !== ot.isDirty);
        const Nt = Hd(Fe(s, X), ce);
        De = !!Fe(n.dirtyFields, X), Nt ? es(n.dirtyFields, X) : kn(n.dirtyFields, X, !0), ot.dirtyFields = n.dirtyFields, Ce = Ce || (d.dirtyFields || u.dirtyFields) && De !== !Nt;
      }
      if (pe) {
        const Nt = Fe(n.touchedFields, X);
        Nt || (kn(n.touchedFields, X, pe), ot.touchedFields = n.touchedFields, Ce = Ce || (d.touchedFields || u.touchedFields) && Nt !== pe);
      }
      Ce && ke && f.state.next(ot);
    }
    return Ce ? ot : {};
  }, C = (X, ce, pe, Ie) => {
    const ke = Fe(n.errors, X), Ce = (d.isValid || u.isValid) && sa(ce) && n.isValid !== ce;
    if (e.delayError && pe ? (c = g(() => b(X, pe)), c(e.delayError)) : (clearTimeout(l), c = null, pe ? kn(n.errors, X, pe) : es(n.errors, X)), (pe ? !Hd(ke, pe) : ke) || !Ei(Ie) || Ce) {
      const De = {
        ...Ie,
        ...Ce && sa(ce) ? { isValid: ce } : {},
        errors: n.errors,
        name: X
      };
      n = {
        ...n,
        ...De
      }, f.state.next(De);
    }
  }, _ = async (X) => {
    m(X, !0);
    const ce = await e.resolver(o, e.context, hFt(X || a.mount, r, e.criteriaMode, e.shouldUseNativeValidation));
    return m(X), ce;
  }, E = async (X) => {
    const { errors: ce } = await _(X);
    if (X)
      for (const pe of X) {
        const Ie = Fe(ce, pe);
        Ie ? kn(n.errors, pe, Ie) : es(n.errors, pe);
      }
    else
      n.errors = ce;
    return ce;
  }, M = async (X, ce, pe = {
    valid: !0
  }) => {
    for (const Ie in X) {
      const ke = X[Ie];
      if (ke) {
        const { _f: Ce, ...De } = ke;
        if (Ce) {
          const ot = a.array.has(Ce.name), Nt = ke._f && pFt(ke._f);
          Nt && d.validatingFields && m([Ie], !0);
          const Kn = await jY(ke, a.disabled, o, p, e.shouldUseNativeValidation && !ce, ot);
          if (Nt && d.validatingFields && m([Ie]), Kn[Ce.name] && (pe.valid = !1, ce))
            break;
          !ce && (Fe(Kn, Ce.name) ? ot ? xFt(n.errors, Kn, Ce.name) : kn(n.errors, Ce.name, Kn[Ce.name]) : es(n.errors, Ce.name));
        }
        !Ei(De) && await M(De, ce, pe);
      }
    }
    return pe.valid;
  }, N = () => {
    for (const X of a.unMount) {
      const ce = Fe(r, X);
      ce && (ce._f.refs ? ce._f.refs.every((pe) => !tD(pe)) : !tD(ce._f.ref)) && Y(X);
    }
    a.unMount = /* @__PURE__ */ new Set();
  }, O = (X, ce) => !e.disabled && (X && ce && kn(o, X, ce), !Hd(z(), s)), D = (X, ce, pe) => Tbe(X, a, {
    ...i.mount ? o : jr(ce) ? s : Ll(X) ? { [X]: ce } : ce
  }, pe, ce), k = (X) => lz(Fe(i.mount ? o : s, X, e.shouldUnregister ? Fe(s, X, []) : [])), A = (X, ce, pe = {}) => {
    const Ie = Fe(r, X);
    let ke = ce;
    if (Ie) {
      const Ce = Ie._f;
      Ce && (!Ce.disabled && kn(o, X, Obe(ce, Ce)), ke = kP(Ce.ref) && Jo(ce) ? "" : ce, Ibe(Ce.ref) ? [...Ce.ref.options].forEach((De) => De.selected = ke.includes(De.value)) : Ce.refs ? VS(Ce.ref) ? Ce.refs.forEach((De) => {
        (!De.defaultChecked || !De.disabled) && (Array.isArray(ke) ? De.checked = !!ke.find((ot) => ot === De.value) : De.checked = ke === De.value || !!ke);
      }) : Ce.refs.forEach((De) => De.checked = De.value === ke) : hz(Ce.ref) ? Ce.ref.value = "" : (Ce.ref.value = ke, Ce.ref.type || f.state.next({
        name: X,
        values: fs(o)
      })));
    }
    (pe.shouldDirty || pe.shouldTouch) && S(X, ke, pe.shouldTouch, pe.shouldDirty, !0), pe.shouldValidate && L(X);
  }, R = (X, ce, pe) => {
    for (const Ie in ce) {
      if (!ce.hasOwnProperty(Ie))
        return;
      const ke = ce[Ie], Ce = X + "." + Ie, De = Fe(r, Ce);
      (a.array.has(X) || Vr(ke) || De && !De._f) && !Yh(ke) ? R(Ce, ke, pe) : A(Ce, ke, pe);
    }
  }, j = (X, ce, pe = {}) => {
    const Ie = Fe(r, X), ke = a.array.has(X), Ce = fs(ce);
    kn(o, X, Ce), ke ? (f.array.next({
      name: X,
      values: fs(o)
    }), (d.isDirty || d.dirtyFields || u.isDirty || u.dirtyFields) && pe.shouldDirty && f.state.next({
      name: X,
      dirtyFields: wb(s, o),
      isDirty: O(X, Ce)
    })) : Ie && !Ie._f && !Jo(Ce) ? R(X, Ce, pe) : A(X, Ce, pe), OY(X, a) && f.state.next({ ...n, name: X }), f.state.next({
      name: i.mount ? X : void 0,
      values: fs(o)
    });
  }, $ = async (X) => {
    i.mount = !0;
    const ce = X.target;
    let pe = ce.name, Ie = !0;
    const ke = Fe(r, pe), Ce = (Nt) => {
      Ie = Number.isNaN(Nt) || Yh(Nt) && isNaN(Nt.getTime()) || Hd(Nt, Fe(o, pe, Nt));
    }, De = AY(e.mode), ot = AY(e.reValidateMode);
    if (ke) {
      let Nt, Kn;
      const In = ce.type ? kY(ke._f) : Sbe(X), Mr = X.type === IP.BLUR || X.type === IP.FOCUS_OUT, qi = !gFt(ke._f) && !e.resolver && !Fe(n.errors, pe) && !ke._f.deps || vFt(Mr, Fe(n.touchedFields, pe), n.isSubmitted, ot, De), Us = OY(pe, a, Mr);
      kn(o, pe, In), Mr ? (ke._f.onBlur && ke._f.onBlur(X), c && c(0)) : ke._f.onChange && ke._f.onChange(X);
      const ur = S(pe, In, Mr), Hs = !Ei(ur) || Us;
      if (!Mr && f.state.next({
        name: pe,
        type: X.type,
        values: fs(o)
      }), qi)
        return (d.isValid || u.isValid) && (e.mode === "onBlur" ? Mr && y() : Mr || y()), Hs && f.state.next({ name: pe, ...Us ? {} : ur });
      if (!Mr && Us && f.state.next({ ...n }), e.resolver) {
        const { errors: Yr } = await _([pe]);
        if (Ce(In), Ie) {
          const vi = DY(n.errors, r, pe), ho = DY(Yr, r, vi.name || pe);
          Nt = ho.error, pe = ho.name, Kn = Ei(Yr);
        }
      } else
        m([pe], !0), Nt = (await jY(ke, a.disabled, o, p, e.shouldUseNativeValidation))[pe], m([pe]), Ce(In), Ie && (Nt ? Kn = !1 : (d.isValid || u.isValid) && (Kn = await M(r, !0)));
      Ie && (ke._f.deps && L(ke._f.deps), C(pe, Kn, Nt, ur));
    }
  }, F = (X, ce) => {
    if (Fe(n.errors, ce) && X.focus)
      return X.focus(), 1;
  }, L = async (X, ce = {}) => {
    let pe, Ie;
    const ke = Hx(X);
    if (e.resolver) {
      const Ce = await E(jr(X) ? X : ke);
      pe = Ei(Ce), Ie = X ? !ke.some((De) => Fe(Ce, De)) : pe;
    } else X ? (Ie = (await Promise.all(ke.map(async (Ce) => {
      const De = Fe(r, Ce);
      return await M(De && De._f ? { [Ce]: De } : De);
    }))).every(Boolean), !(!Ie && !n.isValid) && y()) : Ie = pe = await M(r);
    return f.state.next({
      ...!Ll(X) || (d.isValid || u.isValid) && pe !== n.isValid ? {} : { name: X },
      ...e.resolver || !X ? { isValid: pe } : {},
      errors: n.errors
    }), ce.shouldFocus && !Ie && Vx(r, F, X ? ke : a.mount), Ie;
  }, z = (X) => {
    const ce = {
      ...i.mount ? o : s
    };
    return jr(X) ? ce : Ll(X) ? Fe(ce, X) : X.map((pe) => Fe(ce, pe));
  }, H = (X, ce) => ({
    invalid: !!Fe((ce || n).errors, X),
    isDirty: !!Fe((ce || n).dirtyFields, X),
    error: Fe((ce || n).errors, X),
    isValidating: !!Fe(n.validatingFields, X),
    isTouched: !!Fe((ce || n).touchedFields, X)
  }), U = (X) => {
    X && Hx(X).forEach((ce) => es(n.errors, ce)), f.state.next({
      errors: X ? n.errors : {}
    });
  }, W = (X, ce, pe) => {
    const Ie = (Fe(r, X, { _f: {} })._f || {}).ref, ke = Fe(n.errors, X) || {}, { ref: Ce, message: De, type: ot, ...Nt } = ke;
    kn(n.errors, X, {
      ...Nt,
      ...ce,
      ref: Ie
    }), f.state.next({
      name: X,
      errors: n.errors,
      isValid: !1
    }), pe && pe.shouldFocus && Ie && Ie.focus && Ie.focus();
  }, Z = (X, ce) => Lc(X) ? f.state.subscribe({
    next: (pe) => "values" in pe && X(D(void 0, ce), pe)
  }) : D(X, ce, !0), K = (X) => f.state.subscribe({
    next: (ce) => {
      yFt(X.name, ce.name, X.exact) && mFt(ce, X.formState || d, Ct, X.reRenderRoot) && X.callback({
        values: { ...o },
        ...n,
        ...ce,
        defaultValues: s
      });
    }
  }).unsubscribe, oe = (X) => (i.mount = !0, u = {
    ...u,
    ...X.formState
  }, K({
    ...X,
    formState: u
  })), Y = (X, ce = {}) => {
    for (const pe of X ? Hx(X) : a.mount)
      a.mount.delete(pe), a.array.delete(pe), ce.keepValue || (es(r, pe), es(o, pe)), !ce.keepError && es(n.errors, pe), !ce.keepDirty && es(n.dirtyFields, pe), !ce.keepTouched && es(n.touchedFields, pe), !ce.keepIsValidating && es(n.validatingFields, pe), !e.shouldUnregister && !ce.keepDefaultValue && es(s, pe);
    f.state.next({
      values: fs(o)
    }), f.state.next({
      ...n,
      ...ce.keepDirty ? { isDirty: O() } : {}
    }), !ce.keepIsValid && y();
  }, ee = ({ disabled: X, name: ce }) => {
    (sa(X) && i.mount || X || a.disabled.has(ce)) && (X ? a.disabled.add(ce) : a.disabled.delete(ce));
  }, ae = (X, ce = {}) => {
    let pe = Fe(r, X);
    const Ie = sa(ce.disabled) || sa(e.disabled);
    return kn(r, X, {
      ...pe || {},
      _f: {
        ...pe && pe._f ? pe._f : { ref: { name: X } },
        name: X,
        mount: !0,
        ...ce
      }
    }), a.mount.add(X), pe ? ee({
      disabled: sa(ce.disabled) ? ce.disabled : e.disabled,
      name: X
    }) : w(X, !0, ce.value), {
      ...Ie ? { disabled: ce.disabled || e.disabled } : {},
      ...e.progressive ? {
        required: !!ce.required,
        min: Sb(ce.min),
        max: Sb(ce.max),
        minLength: Sb(ce.minLength),
        maxLength: Sb(ce.maxLength),
        pattern: Sb(ce.pattern)
      } : {},
      name: X,
      onChange: $,
      onBlur: $,
      ref: (ke) => {
        if (ke) {
          ae(X, ce), pe = Fe(r, X);
          const Ce = jr(ke.value) && ke.querySelectorAll && ke.querySelectorAll("input,select,textarea")[0] || ke, De = dFt(Ce), ot = pe._f.refs || [];
          if (De ? ot.find((Nt) => Nt === Ce) : Ce === pe._f.ref)
            return;
          kn(r, X, {
            _f: {
              ...pe._f,
              ...De ? {
                refs: [
                  ...ot.filter(tD),
                  Ce,
                  ...Array.isArray(Fe(s, X)) ? [{}] : []
                ],
                ref: { type: Ce.type, name: X }
              } : { ref: Ce }
            }
          }), w(X, !1, void 0, Ce);
        } else
          pe = Fe(r, X, {}), pe._f && (pe._f.mount = !1), (e.shouldUnregister || ce.shouldUnregister) && !(Cbe(a.array, X) && i.action) && a.unMount.add(X);
      }
    };
  }, de = () => e.shouldFocusError && Vx(r, F, a.mount), ye = (X) => {
    sa(X) && (f.state.next({ disabled: X }), Vx(r, (ce, pe) => {
      const Ie = Fe(r, pe);
      Ie && (ce.disabled = Ie._f.disabled || X, Array.isArray(Ie._f.refs) && Ie._f.refs.forEach((ke) => {
        ke.disabled = Ie._f.disabled || X;
      }));
    }, 0, !1));
  }, G = (X, ce) => async (pe) => {
    let Ie;
    pe && (pe.preventDefault && pe.preventDefault(), pe.persist && pe.persist());
    let ke = fs(o);
    if (f.state.next({
      isSubmitting: !0
    }), e.resolver) {
      const { errors: Ce, values: De } = await _();
      n.errors = Ce, ke = fs(De);
    } else
      await M(r);
    if (a.disabled.size)
      for (const Ce of a.disabled)
        es(ke, Ce);
    if (es(n.errors, "root"), Ei(n.errors)) {
      f.state.next({
        errors: {}
      });
      try {
        await X(ke, pe);
      } catch (Ce) {
        Ie = Ce;
      }
    } else
      ce && await ce({ ...n.errors }, pe), de(), setTimeout(de);
    if (f.state.next({
      isSubmitted: !0,
      isSubmitting: !1,
      isSubmitSuccessful: Ei(n.errors) && !Ie,
      submitCount: n.submitCount + 1,
      errors: n.errors
    }), Ie)
      throw Ie;
  }, xe = (X, ce = {}) => {
    Fe(r, X) && (jr(ce.defaultValue) ? j(X, fs(Fe(s, X))) : (j(X, ce.defaultValue), kn(s, X, fs(ce.defaultValue))), ce.keepTouched || es(n.touchedFields, X), ce.keepDirty || (es(n.dirtyFields, X), n.isDirty = ce.defaultValue ? O(X, fs(Fe(s, X))) : O()), ce.keepError || (es(n.errors, X), d.isValid && y()), f.state.next({ ...n }));
  }, ge = (X, ce = {}) => {
    const pe = X ? fs(X) : s, Ie = fs(pe), ke = Ei(X), Ce = ke ? s : Ie;
    if (ce.keepDefaultValues || (s = pe), !ce.keepValues) {
      if (ce.keepDirtyValues) {
        const De = /* @__PURE__ */ new Set([
          ...a.mount,
          ...Object.keys(wb(s, o))
        ]);
        for (const ot of Array.from(De))
          Fe(n.dirtyFields, ot) ? kn(Ce, ot, Fe(o, ot)) : j(ot, Fe(Ce, ot));
      } else {
        if (cz && jr(X))
          for (const De of a.mount) {
            const ot = Fe(r, De);
            if (ot && ot._f) {
              const Nt = Array.isArray(ot._f.refs) ? ot._f.refs[0] : ot._f.ref;
              if (kP(Nt)) {
                const Kn = Nt.closest("form");
                if (Kn) {
                  Kn.reset();
                  break;
                }
              }
            }
          }
        if (ce.keepFieldsRef)
          for (const De of a.mount)
            j(De, Fe(Ce, De));
        else
          r = {};
      }
      o = e.shouldUnregister ? ce.keepDefaultValues ? fs(s) : {} : fs(Ce), f.array.next({
        values: { ...Ce }
      }), f.state.next({
        values: { ...Ce }
      });
    }
    a = {
      mount: ce.keepDirtyValues ? a.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: !1,
      focus: ""
    }, i.mount = !d.isValid || !!ce.keepIsValid || !!ce.keepDirtyValues, i.watch = !!e.shouldUnregister, f.state.next({
      submitCount: ce.keepSubmitCount ? n.submitCount : 0,
      isDirty: ke ? !1 : ce.keepDirty ? n.isDirty : !!(ce.keepDefaultValues && !Hd(X, s)),
      isSubmitted: ce.keepIsSubmitted ? n.isSubmitted : !1,
      dirtyFields: ke ? {} : ce.keepDirtyValues ? ce.keepDefaultValues && o ? wb(s, o) : n.dirtyFields : ce.keepDefaultValues && X ? wb(s, X) : ce.keepDirty ? n.dirtyFields : {},
      touchedFields: ce.keepTouched ? n.touchedFields : {},
      errors: ce.keepErrors ? n.errors : {},
      isSubmitSuccessful: ce.keepIsSubmitSuccessful ? n.isSubmitSuccessful : !1,
      isSubmitting: !1
    });
  }, ze = (X, ce) => ge(Lc(X) ? X(o) : X, ce), Ge = (X, ce = {}) => {
    const pe = Fe(r, X), Ie = pe && pe._f;
    if (Ie) {
      const ke = Ie.refs ? Ie.refs[0] : Ie.ref;
      ke.focus && (ke.focus(), ce.shouldSelect && Lc(ke.select) && ke.select());
    }
  }, Ct = (X) => {
    n = {
      ...n,
      ...X
    };
  }, Yt = {
    control: {
      register: ae,
      unregister: Y,
      getFieldState: H,
      handleSubmit: G,
      setError: W,
      _subscribe: K,
      _runSchema: _,
      _focusError: de,
      _getWatch: D,
      _getDirty: O,
      _setValid: y,
      _setFieldArray: v,
      _setDisabledField: ee,
      _setErrors: x,
      _getFieldArray: k,
      _reset: ge,
      _resetDefaultValues: () => Lc(e.defaultValues) && e.defaultValues().then((X) => {
        ze(X, e.resetOptions), f.state.next({
          isLoading: !1
        });
      }),
      _removeUnmounted: N,
      _disableForm: ye,
      _subjects: f,
      _proxyFormState: d,
      get _fields() {
        return r;
      },
      get _formValues() {
        return o;
      },
      get _state() {
        return i;
      },
      set _state(X) {
        i = X;
      },
      get _defaultValues() {
        return s;
      },
      get _names() {
        return a;
      },
      set _names(X) {
        a = X;
      },
      get _formState() {
        return n;
      },
      get _options() {
        return e;
      },
      set _options(X) {
        e = {
          ...e,
          ...X
        };
      }
    },
    subscribe: oe,
    trigger: L,
    register: ae,
    handleSubmit: G,
    watch: Z,
    setValue: j,
    getValues: z,
    reset: ze,
    resetField: xe,
    clearErrors: U,
    unregister: Y,
    setError: W,
    setFocus: Ge,
    getFieldState: H
  };
  return {
    ...Yt,
    formControl: Yt
  };
}
function CFt(t = {}) {
  const e = B.useRef(void 0), n = B.useRef(void 0), [r, s] = B.useState({
    isDirty: !1,
    isValidating: !1,
    isLoading: Lc(t.defaultValues),
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: t.errors || {},
    disabled: t.disabled || !1,
    isReady: !1,
    defaultValues: Lc(t.defaultValues) ? void 0 : t.defaultValues
  });
  if (!e.current)
    if (t.formControl)
      e.current = {
        ...t.formControl,
        formState: r
      }, t.defaultValues && !Lc(t.defaultValues) && t.formControl.reset(t.defaultValues, t.resetOptions);
    else {
      const { formControl: i, ...a } = SFt(t);
      e.current = {
        ...a,
        formState: r
      };
    }
  const o = e.current.control;
  return o._options = t, fz(() => {
    const i = o._subscribe({
      formState: o._proxyFormState,
      callback: () => s({ ...o._formState }),
      reRenderRoot: !0
    });
    return s((a) => ({
      ...a,
      isReady: !0
    })), o._formState.isReady = !0, i;
  }, [o]), B.useEffect(() => o._disableForm(t.disabled), [o, t.disabled]), B.useEffect(() => {
    t.mode && (o._options.mode = t.mode), t.reValidateMode && (o._options.reValidateMode = t.reValidateMode);
  }, [o, t.mode, t.reValidateMode]), B.useEffect(() => {
    t.errors && (o._setErrors(t.errors), o._focusError());
  }, [o, t.errors]), B.useEffect(() => {
    t.shouldUnregister && o._subjects.state.next({
      values: o._getWatch()
    });
  }, [o, t.shouldUnregister]), B.useEffect(() => {
    if (o._proxyFormState.isDirty) {
      const i = o._getDirty();
      i !== r.isDirty && o._subjects.state.next({
        isDirty: i
      });
    }
  }, [o, r.isDirty]), B.useEffect(() => {
    t.values && !Hd(t.values, n.current) ? (o._reset(t.values, {
      keepFieldsRef: !0,
      ...o._options.resetOptions
    }), n.current = t.values, s((i) => ({ ...i }))) : o._resetDefaultValues();
  }, [o, t.values]), B.useEffect(() => {
    o._state.mount || (o._setValid(), o._state.mount = !0), o._state.watch && (o._state.watch = !1, o._subjects.state.next({ ...o._formState })), o._removeUnmounted();
  }), e.current.formState = Ebe(r, o), e.current;
}
var gn;
(function(t) {
  t.assertEqual = (s) => {
  };
  function e(s) {
  }
  t.assertIs = e;
  function n(s) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (s) => {
    const o = {};
    for (const i of s)
      o[i] = i;
    return o;
  }, t.getValidEnumValues = (s) => {
    const o = t.objectKeys(s).filter((a) => typeof s[s[a]] != "number"), i = {};
    for (const a of o)
      i[a] = s[a];
    return t.objectValues(i);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(o) {
    return s[o];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const o = [];
    for (const i in s)
      Object.prototype.hasOwnProperty.call(s, i) && o.push(i);
    return o;
  }, t.find = (s, o) => {
    for (const i of s)
      if (o(i))
        return i;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && Number.isFinite(s) && Math.floor(s) === s;
  function r(s, o = " | ") {
    return s.map((i) => typeof i == "string" ? `'${i}'` : i).join(o);
  }
  t.joinValues = r, t.jsonStringifyReplacer = (s, o) => typeof o == "bigint" ? o.toString() : o;
})(gn || (gn = {}));
var RY;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
    // second overwrites first
  });
})(RY || (RY = {}));
const nt = gn.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Ku = (t) => {
  switch (typeof t) {
    case "undefined":
      return nt.undefined;
    case "string":
      return nt.string;
    case "number":
      return Number.isNaN(t) ? nt.nan : nt.number;
    case "boolean":
      return nt.boolean;
    case "function":
      return nt.function;
    case "bigint":
      return nt.bigint;
    case "symbol":
      return nt.symbol;
    case "object":
      return Array.isArray(t) ? nt.array : t === null ? nt.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? nt.promise : typeof Map < "u" && t instanceof Map ? nt.map : typeof Set < "u" && t instanceof Set ? nt.set : typeof Date < "u" && t instanceof Date ? nt.date : nt.object;
    default:
      return nt.unknown;
  }
}, Ne = gn.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class lu extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const n = e || function(o) {
      return o.message;
    }, r = { _errors: [] }, s = (o) => {
      for (const i of o.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(s);
        else if (i.code === "invalid_return_type")
          s(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          s(i.argumentsError);
        else if (i.path.length === 0)
          r._errors.push(n(i));
        else {
          let a = r, c = 0;
          for (; c < i.path.length; ) {
            const l = i.path[c];
            c === i.path.length - 1 ? (a[l] = a[l] || { _errors: [] }, a[l]._errors.push(n(i))) : a[l] = a[l] || { _errors: [] }, a = a[l], c++;
          }
        }
    };
    return s(this), r;
  }
  static assert(e) {
    if (!(e instanceof lu))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, gn.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, r = [];
    for (const s of this.issues)
      if (s.path.length > 0) {
        const o = s.path[0];
        n[o] = n[o] || [], n[o].push(e(s));
      } else
        r.push(e(s));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
lu.create = (t) => new lu(t);
const I$ = (t, e) => {
  let n;
  switch (t.code) {
    case Ne.invalid_type:
      t.received === nt.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case Ne.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, gn.jsonStringifyReplacer)}`;
      break;
    case Ne.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${gn.joinValues(t.keys, ", ")}`;
      break;
    case Ne.invalid_union:
      n = "Invalid input";
      break;
    case Ne.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${gn.joinValues(t.options)}`;
      break;
    case Ne.invalid_enum_value:
      n = `Invalid enum value. Expected ${gn.joinValues(t.options)}, received '${t.received}'`;
      break;
    case Ne.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case Ne.invalid_return_type:
      n = "Invalid function return type";
      break;
    case Ne.invalid_date:
      n = "Invalid date";
      break;
    case Ne.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : gn.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case Ne.too_small:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "bigint" ? n = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
      break;
    case Ne.too_big:
      t.type === "array" ? n = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
      break;
    case Ne.custom:
      n = "Invalid input";
      break;
    case Ne.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case Ne.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case Ne.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = e.defaultError, gn.assertNever(t);
  }
  return { message: n };
};
let _Ft = I$;
function EFt() {
  return _Ft;
}
const TFt = (t) => {
  const { data: e, path: n, errorMaps: r, issueData: s } = t, o = [...n, ...s.path || []], i = {
    ...s,
    path: o
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: o,
      message: s.message
    };
  let a = "";
  const c = r.filter((l) => !!l).slice().reverse();
  for (const l of c)
    a = l(i, { data: e, defaultError: a }).message;
  return {
    ...s,
    path: o,
    message: a
  };
};
function Ve(t, e) {
  const n = EFt(), r = TFt({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      // contextual error map is first priority
      t.schemaErrorMap,
      // then schema-bound map if available
      n,
      // then global override map
      n === I$ ? void 0 : I$
      // then global default map
    ].filter((s) => !!s)
  });
  t.common.issues.push(r);
}
class ka {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted")
        return Mt;
      s.status === "dirty" && e.dirty(), r.push(s.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, n) {
    const r = [];
    for (const s of n) {
      const o = await s.key, i = await s.value;
      r.push({
        key: o,
        value: i
      });
    }
    return ka.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, n) {
    const r = {};
    for (const s of n) {
      const { key: o, value: i } = s;
      if (o.status === "aborted" || i.status === "aborted")
        return Mt;
      o.status === "dirty" && e.dirty(), i.status === "dirty" && e.dirty(), o.value !== "__proto__" && (typeof i.value < "u" || s.alwaysSet) && (r[o.value] = i.value);
    }
    return { status: e.value, value: r };
  }
}
const Mt = Object.freeze({
  status: "aborted"
}), sx = (t) => ({ status: "dirty", value: t }), bc = (t) => ({ status: "valid", value: t }), $Y = (t) => t.status === "aborted", LY = (t) => t.status === "dirty", Ry = (t) => t.status === "valid", OP = (t) => typeof Promise < "u" && t instanceof Promise;
var st;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(st || (st = {}));
class Vf {
  constructor(e, n, r, s) {
    this._cachedPath = [], this.parent = e, this.data = n, this._path = r, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const FY = (t, e) => {
  if (Ry(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new lu(t.common.issues);
      return this._error = n, this._error;
    }
  };
};
function qt(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: r, description: s } = t;
  if (e && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (i, a) => {
    const { message: c } = t;
    return i.code === "invalid_enum_value" ? { message: c ?? a.defaultError } : typeof a.data > "u" ? { message: c ?? r ?? a.defaultError } : i.code !== "invalid_type" ? { message: a.defaultError } : { message: c ?? n ?? a.defaultError };
  }, description: s };
}
class fn {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Ku(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: Ku(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new ka(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Ku(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (OP(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const r = this.safeParse(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, n) {
    const r = {
      common: {
        issues: [],
        async: (n == null ? void 0 : n.async) ?? !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ku(e)
    }, s = this._parseSync({ data: e, path: r.path, parent: r });
    return FY(r, s);
  }
  "~validate"(e) {
    var r, s;
    const n = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ku(e)
    };
    if (!this["~standard"].async)
      try {
        const o = this._parseSync({ data: e, path: [], parent: n });
        return Ry(o) ? {
          value: o.value
        } : {
          issues: n.common.issues
        };
      } catch (o) {
        (s = (r = o == null ? void 0 : o.message) == null ? void 0 : r.toLowerCase()) != null && s.includes("encountered") && (this["~standard"].async = !0), n.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: n }).then((o) => Ry(o) ? {
      value: o.value
    } : {
      issues: n.common.issues
    });
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Ku(e)
    }, s = this._parse({ data: e, path: r.path, parent: r }), o = await (OP(s) ? s : Promise.resolve(s));
    return FY(r, o);
  }
  refine(e, n) {
    const r = (s) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, o) => {
      const i = e(s), a = () => o.addIssue({
        code: Ne.custom,
        ...r(s)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((c) => c ? !0 : (a(), !1)) : i ? !0 : (a(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((r, s) => e(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n), !1));
  }
  _refinement(e) {
    return new Ly({
      schema: this,
      typeName: Ot.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (n) => this["~validate"](n)
    };
  }
  optional() {
    return If.create(this, this._def);
  }
  nullable() {
    return Fy.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Gl.create(this);
  }
  promise() {
    return RP.create(this, this._def);
  }
  or(e) {
    return NP.create([this, e], this._def);
  }
  and(e) {
    return jP.create(this, e, this._def);
  }
  transform(e) {
    return new Ly({
      ...qt(this._def),
      schema: this,
      typeName: Ot.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new A$({
      ...qt(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Ot.ZodDefault
    });
  }
  brand() {
    return new qFt({
      typeName: Ot.ZodBranded,
      type: this,
      ...qt(this._def)
    });
  }
  catch(e) {
    const n = typeof e == "function" ? e : () => e;
    return new M$({
      ...qt(this._def),
      innerType: this,
      catchValue: n,
      typeName: Ot.ZodCatch
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return gz.create(this, e);
  }
  readonly() {
    return O$.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const PFt = /^c[^\s-]{8,}$/i, IFt = /^[0-9a-z]+$/, kFt = /^[0-9A-HJKMNP-TV-Z]{26}$/i, AFt = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, MFt = /^[a-z0-9_-]{21}$/i, OFt = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, DFt = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, NFt = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, jFt = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let nD;
const RFt = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, $Ft = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, LFt = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, FFt = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, BFt = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, zFt = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, Nbe = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", UFt = new RegExp(`^${Nbe}$`);
function jbe(t) {
  let e = "[0-5]\\d";
  t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`);
  const n = t.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${n}`;
}
function HFt(t) {
  return new RegExp(`^${jbe(t)}$`);
}
function VFt(t) {
  let e = `${Nbe}T${jbe(t)}`;
  const n = [];
  return n.push(t.local ? "Z?" : "Z"), t.offset && n.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${n.join("|")})`, new RegExp(`^${e}$`);
}
function WFt(t, e) {
  return !!((e === "v4" || !e) && RFt.test(t) || (e === "v6" || !e) && LFt.test(t));
}
function KFt(t, e) {
  if (!OFt.test(t))
    return !1;
  try {
    const [n] = t.split(".");
    if (!n)
      return !1;
    const r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), s = JSON.parse(atob(r));
    return !(typeof s != "object" || s === null || "typ" in s && (s == null ? void 0 : s.typ) !== "JWT" || !s.alg || e && s.alg !== e);
  } catch {
    return !1;
  }
}
function GFt(t, e) {
  return !!((e === "v4" || !e) && $Ft.test(t) || (e === "v6" || !e) && FFt.test(t));
}
class gf extends fn {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== nt.string) {
      const o = this._getOrReturnCtx(e);
      return Ve(o, {
        code: Ne.invalid_type,
        expected: nt.string,
        received: o.parsedType
      }), Mt;
    }
    const r = new ka();
    let s;
    for (const o of this._def.checks)
      if (o.kind === "min")
        e.data.length < o.value && (s = this._getOrReturnCtx(e, s), Ve(s, {
          code: Ne.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "max")
        e.data.length > o.value && (s = this._getOrReturnCtx(e, s), Ve(s, {
          code: Ne.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), r.dirty());
      else if (o.kind === "length") {
        const i = e.data.length > o.value, a = e.data.length < o.value;
        (i || a) && (s = this._getOrReturnCtx(e, s), i ? Ve(s, {
          code: Ne.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }) : a && Ve(s, {
          code: Ne.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }), r.dirty());
      } else if (o.kind === "email")
        NFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
          validation: "email",
          code: Ne.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "emoji")
        nD || (nD = new RegExp(jFt, "u")), nD.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
          validation: "emoji",
          code: Ne.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "uuid")
        AFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
          validation: "uuid",
          code: Ne.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "nanoid")
        MFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
          validation: "nanoid",
          code: Ne.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid")
        PFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
          validation: "cuid",
          code: Ne.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid2")
        IFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
          validation: "cuid2",
          code: Ne.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "ulid")
        kFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
          validation: "ulid",
          code: Ne.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), Ve(s, {
            validation: "url",
            code: Ne.invalid_string,
            message: o.message
          }), r.dirty();
        }
      else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        validation: "regex",
        code: Ne.invalid_string,
        message: o.message
      }), r.dirty())) : o.kind === "trim" ? e.data = e.data.trim() : o.kind === "includes" ? e.data.includes(o.value, o.position) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        code: Ne.invalid_string,
        validation: { includes: o.value, position: o.position },
        message: o.message
      }), r.dirty()) : o.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : o.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : o.kind === "startsWith" ? e.data.startsWith(o.value) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        code: Ne.invalid_string,
        validation: { startsWith: o.value },
        message: o.message
      }), r.dirty()) : o.kind === "endsWith" ? e.data.endsWith(o.value) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        code: Ne.invalid_string,
        validation: { endsWith: o.value },
        message: o.message
      }), r.dirty()) : o.kind === "datetime" ? VFt(o).test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        code: Ne.invalid_string,
        validation: "datetime",
        message: o.message
      }), r.dirty()) : o.kind === "date" ? UFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        code: Ne.invalid_string,
        validation: "date",
        message: o.message
      }), r.dirty()) : o.kind === "time" ? HFt(o).test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        code: Ne.invalid_string,
        validation: "time",
        message: o.message
      }), r.dirty()) : o.kind === "duration" ? DFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        validation: "duration",
        code: Ne.invalid_string,
        message: o.message
      }), r.dirty()) : o.kind === "ip" ? WFt(e.data, o.version) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        validation: "ip",
        code: Ne.invalid_string,
        message: o.message
      }), r.dirty()) : o.kind === "jwt" ? KFt(e.data, o.alg) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        validation: "jwt",
        code: Ne.invalid_string,
        message: o.message
      }), r.dirty()) : o.kind === "cidr" ? GFt(e.data, o.version) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        validation: "cidr",
        code: Ne.invalid_string,
        message: o.message
      }), r.dirty()) : o.kind === "base64" ? BFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        validation: "base64",
        code: Ne.invalid_string,
        message: o.message
      }), r.dirty()) : o.kind === "base64url" ? zFt.test(e.data) || (s = this._getOrReturnCtx(e, s), Ve(s, {
        validation: "base64url",
        code: Ne.invalid_string,
        message: o.message
      }), r.dirty()) : gn.assertNever(o);
    return { status: r.value, value: e.data };
  }
  _regex(e, n, r) {
    return this.refinement((s) => e.test(s), {
      validation: n,
      code: Ne.invalid_string,
      ...st.errToObj(r)
    });
  }
  _addCheck(e) {
    return new gf({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...st.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...st.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...st.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...st.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...st.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...st.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...st.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...st.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...st.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...st.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...st.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...st.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...st.errToObj(e) });
  }
  datetime(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (e == null ? void 0 : e.offset) ?? !1,
      local: (e == null ? void 0 : e.local) ?? !1,
      ...st.errToObj(e == null ? void 0 : e.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      ...st.errToObj(e == null ? void 0 : e.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...st.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...st.errToObj(n)
    });
  }
  includes(e, n) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: n == null ? void 0 : n.position,
      ...st.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...st.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...st.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...st.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...st.errToObj(n)
    });
  }
  length(e, n) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...st.errToObj(n)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, st.errToObj(e));
  }
  trim() {
    return new gf({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new gf({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new gf({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
gf.create = (t) => new gf({
  checks: [],
  typeName: Ot.ZodString,
  coerce: (t == null ? void 0 : t.coerce) ?? !1,
  ...qt(t)
});
function YFt(t, e) {
  const n = (t.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, s = n > r ? n : r, o = Number.parseInt(t.toFixed(s).replace(".", "")), i = Number.parseInt(e.toFixed(s).replace(".", ""));
  return o % i / 10 ** s;
}
class f0 extends fn {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== nt.number) {
      const o = this._getOrReturnCtx(e);
      return Ve(o, {
        code: Ne.invalid_type,
        expected: nt.number,
        received: o.parsedType
      }), Mt;
    }
    let r;
    const s = new ka();
    for (const o of this._def.checks)
      o.kind === "int" ? gn.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), Ve(r, {
        code: Ne.invalid_type,
        expected: "integer",
        received: "float",
        message: o.message
      }), s.dirty()) : o.kind === "min" ? (o.inclusive ? e.data < o.value : e.data <= o.value) && (r = this._getOrReturnCtx(e, r), Ve(r, {
        code: Ne.too_small,
        minimum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), s.dirty()) : o.kind === "max" ? (o.inclusive ? e.data > o.value : e.data >= o.value) && (r = this._getOrReturnCtx(e, r), Ve(r, {
        code: Ne.too_big,
        maximum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), s.dirty()) : o.kind === "multipleOf" ? YFt(e.data, o.value) !== 0 && (r = this._getOrReturnCtx(e, r), Ve(r, {
        code: Ne.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), s.dirty()) : o.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), Ve(r, {
        code: Ne.not_finite,
        message: o.message
      }), s.dirty()) : gn.assertNever(o);
    return { status: s.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, st.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, st.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, st.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, st.toString(n));
  }
  setLimit(e, n, r, s) {
    return new f0({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: st.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new f0({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: st.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: st.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: st.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: st.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: st.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: st.toString(n)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: st.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: st.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: st.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && gn.isInteger(e.value));
  }
  get isFinite() {
    let e = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(e);
  }
}
f0.create = (t) => new f0({
  checks: [],
  typeName: Ot.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...qt(t)
});
class h0 extends fn {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== nt.bigint)
      return this._getInvalidInput(e);
    let r;
    const s = new ka();
    for (const o of this._def.checks)
      o.kind === "min" ? (o.inclusive ? e.data < o.value : e.data <= o.value) && (r = this._getOrReturnCtx(e, r), Ve(r, {
        code: Ne.too_small,
        type: "bigint",
        minimum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), s.dirty()) : o.kind === "max" ? (o.inclusive ? e.data > o.value : e.data >= o.value) && (r = this._getOrReturnCtx(e, r), Ve(r, {
        code: Ne.too_big,
        type: "bigint",
        maximum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), s.dirty()) : o.kind === "multipleOf" ? e.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), Ve(r, {
        code: Ne.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), s.dirty()) : gn.assertNever(o);
    return { status: s.value, value: e.data };
  }
  _getInvalidInput(e) {
    const n = this._getOrReturnCtx(e);
    return Ve(n, {
      code: Ne.invalid_type,
      expected: nt.bigint,
      received: n.parsedType
    }), Mt;
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, st.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, st.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, st.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, st.toString(n));
  }
  setLimit(e, n, r, s) {
    return new h0({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: st.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new h0({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: st.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: st.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: st.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: st.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: st.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
h0.create = (t) => new h0({
  checks: [],
  typeName: Ot.ZodBigInt,
  coerce: (t == null ? void 0 : t.coerce) ?? !1,
  ...qt(t)
});
class BY extends fn {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== nt.boolean) {
      const r = this._getOrReturnCtx(e);
      return Ve(r, {
        code: Ne.invalid_type,
        expected: nt.boolean,
        received: r.parsedType
      }), Mt;
    }
    return bc(e.data);
  }
}
BY.create = (t) => new BY({
  typeName: Ot.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...qt(t)
});
class DP extends fn {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== nt.date) {
      const o = this._getOrReturnCtx(e);
      return Ve(o, {
        code: Ne.invalid_type,
        expected: nt.date,
        received: o.parsedType
      }), Mt;
    }
    if (Number.isNaN(e.data.getTime())) {
      const o = this._getOrReturnCtx(e);
      return Ve(o, {
        code: Ne.invalid_date
      }), Mt;
    }
    const r = new ka();
    let s;
    for (const o of this._def.checks)
      o.kind === "min" ? e.data.getTime() < o.value && (s = this._getOrReturnCtx(e, s), Ve(s, {
        code: Ne.too_small,
        message: o.message,
        inclusive: !0,
        exact: !1,
        minimum: o.value,
        type: "date"
      }), r.dirty()) : o.kind === "max" ? e.data.getTime() > o.value && (s = this._getOrReturnCtx(e, s), Ve(s, {
        code: Ne.too_big,
        message: o.message,
        inclusive: !0,
        exact: !1,
        maximum: o.value,
        type: "date"
      }), r.dirty()) : gn.assertNever(o);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new DP({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: st.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: st.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
DP.create = (t) => new DP({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || !1,
  typeName: Ot.ZodDate,
  ...qt(t)
});
class zY extends fn {
  _parse(e) {
    if (this._getType(e) !== nt.symbol) {
      const r = this._getOrReturnCtx(e);
      return Ve(r, {
        code: Ne.invalid_type,
        expected: nt.symbol,
        received: r.parsedType
      }), Mt;
    }
    return bc(e.data);
  }
}
zY.create = (t) => new zY({
  typeName: Ot.ZodSymbol,
  ...qt(t)
});
class UY extends fn {
  _parse(e) {
    if (this._getType(e) !== nt.undefined) {
      const r = this._getOrReturnCtx(e);
      return Ve(r, {
        code: Ne.invalid_type,
        expected: nt.undefined,
        received: r.parsedType
      }), Mt;
    }
    return bc(e.data);
  }
}
UY.create = (t) => new UY({
  typeName: Ot.ZodUndefined,
  ...qt(t)
});
class HY extends fn {
  _parse(e) {
    if (this._getType(e) !== nt.null) {
      const r = this._getOrReturnCtx(e);
      return Ve(r, {
        code: Ne.invalid_type,
        expected: nt.null,
        received: r.parsedType
      }), Mt;
    }
    return bc(e.data);
  }
}
HY.create = (t) => new HY({
  typeName: Ot.ZodNull,
  ...qt(t)
});
class VY extends fn {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return bc(e.data);
  }
}
VY.create = (t) => new VY({
  typeName: Ot.ZodAny,
  ...qt(t)
});
class WY extends fn {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return bc(e.data);
  }
}
WY.create = (t) => new WY({
  typeName: Ot.ZodUnknown,
  ...qt(t)
});
class Wf extends fn {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return Ve(n, {
      code: Ne.invalid_type,
      expected: nt.never,
      received: n.parsedType
    }), Mt;
  }
}
Wf.create = (t) => new Wf({
  typeName: Ot.ZodNever,
  ...qt(t)
});
class KY extends fn {
  _parse(e) {
    if (this._getType(e) !== nt.undefined) {
      const r = this._getOrReturnCtx(e);
      return Ve(r, {
        code: Ne.invalid_type,
        expected: nt.void,
        received: r.parsedType
      }), Mt;
    }
    return bc(e.data);
  }
}
KY.create = (t) => new KY({
  typeName: Ot.ZodVoid,
  ...qt(t)
});
class Gl extends fn {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e), s = this._def;
    if (n.parsedType !== nt.array)
      return Ve(n, {
        code: Ne.invalid_type,
        expected: nt.array,
        received: n.parsedType
      }), Mt;
    if (s.exactLength !== null) {
      const i = n.data.length > s.exactLength.value, a = n.data.length < s.exactLength.value;
      (i || a) && (Ve(n, {
        code: i ? Ne.too_big : Ne.too_small,
        minimum: a ? s.exactLength.value : void 0,
        maximum: i ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), r.dirty());
    }
    if (s.minLength !== null && n.data.length < s.minLength.value && (Ve(n, {
      code: Ne.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (Ve(n, {
      code: Ne.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((i, a) => s.type._parseAsync(new Vf(n, i, n.path, a)))).then((i) => ka.mergeArray(r, i));
    const o = [...n.data].map((i, a) => s.type._parseSync(new Vf(n, i, n.path, a)));
    return ka.mergeArray(r, o);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new Gl({
      ...this._def,
      minLength: { value: e, message: st.toString(n) }
    });
  }
  max(e, n) {
    return new Gl({
      ...this._def,
      maxLength: { value: e, message: st.toString(n) }
    });
  }
  length(e, n) {
    return new Gl({
      ...this._def,
      exactLength: { value: e, message: st.toString(n) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Gl.create = (t, e) => new Gl({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Ot.ZodArray,
  ...qt(e)
});
function im(t) {
  if (t instanceof _r) {
    const e = {};
    for (const n in t.shape) {
      const r = t.shape[n];
      e[n] = If.create(im(r));
    }
    return new _r({
      ...t._def,
      shape: () => e
    });
  } else return t instanceof Gl ? new Gl({
    ...t._def,
    type: im(t.element)
  }) : t instanceof If ? If.create(im(t.unwrap())) : t instanceof Fy ? Fy.create(im(t.unwrap())) : t instanceof tg ? tg.create(t.items.map((e) => im(e))) : t;
}
class _r extends fn {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = gn.objectKeys(e);
    return this._cached = { shape: e, keys: n }, this._cached;
  }
  _parse(e) {
    if (this._getType(e) !== nt.object) {
      const l = this._getOrReturnCtx(e);
      return Ve(l, {
        code: Ne.invalid_type,
        expected: nt.object,
        received: l.parsedType
      }), Mt;
    }
    const { status: r, ctx: s } = this._processInputParams(e), { shape: o, keys: i } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof Wf && this._def.unknownKeys === "strip"))
      for (const l in s.data)
        i.includes(l) || a.push(l);
    const c = [];
    for (const l of i) {
      const d = o[l], u = s.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: d._parse(new Vf(s, u, s.path, l)),
        alwaysSet: l in s.data
      });
    }
    if (this._def.catchall instanceof Wf) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const d of a)
          c.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: s.data[d] }
          });
      else if (l === "strict")
        a.length > 0 && (Ve(s, {
          code: Ne.unrecognized_keys,
          keys: a
        }), r.dirty());
      else if (l !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const d of a) {
        const u = s.data[d];
        c.push({
          key: { status: "valid", value: d },
          value: l._parse(
            new Vf(s, u, s.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const d of c) {
        const u = await d.key, f = await d.value;
        l.push({
          key: u,
          value: f,
          alwaysSet: d.alwaysSet
        });
      }
      return l;
    }).then((l) => ka.mergeObjectSync(r, l)) : ka.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return st.errToObj, new _r({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, r) => {
          var o, i;
          const s = ((i = (o = this._def).errorMap) == null ? void 0 : i.call(o, n, r).message) ?? r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: st.errToObj(e).message ?? s
          } : {
            message: s
          };
        }
      } : {}
    });
  }
  strip() {
    return new _r({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _r({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new _r({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new _r({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: Ot.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new _r({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    for (const r of gn.objectKeys(e))
      e[r] && this.shape[r] && (n[r] = this.shape[r]);
    return new _r({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    for (const r of gn.objectKeys(this.shape))
      e[r] || (n[r] = this.shape[r]);
    return new _r({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return im(this);
  }
  partial(e) {
    const n = {};
    for (const r of gn.objectKeys(this.shape)) {
      const s = this.shape[r];
      e && !e[r] ? n[r] = s : n[r] = s.optional();
    }
    return new _r({
      ...this._def,
      shape: () => n
    });
  }
  required(e) {
    const n = {};
    for (const r of gn.objectKeys(this.shape))
      if (e && !e[r])
        n[r] = this.shape[r];
      else {
        let o = this.shape[r];
        for (; o instanceof If; )
          o = o._def.innerType;
        n[r] = o;
      }
    return new _r({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return Rbe(gn.objectKeys(this.shape));
  }
}
_r.create = (t, e) => new _r({
  shape: () => t,
  unknownKeys: "strip",
  catchall: Wf.create(),
  typeName: Ot.ZodObject,
  ...qt(e)
});
_r.strictCreate = (t, e) => new _r({
  shape: () => t,
  unknownKeys: "strict",
  catchall: Wf.create(),
  typeName: Ot.ZodObject,
  ...qt(e)
});
_r.lazycreate = (t, e) => new _r({
  shape: t,
  unknownKeys: "strip",
  catchall: Wf.create(),
  typeName: Ot.ZodObject,
  ...qt(e)
});
class NP extends fn {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = this._def.options;
    function s(o) {
      for (const a of o)
        if (a.result.status === "valid")
          return a.result;
      for (const a of o)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const i = o.map((a) => new lu(a.ctx.common.issues));
      return Ve(n, {
        code: Ne.invalid_union,
        unionErrors: i
      }), Mt;
    }
    if (n.common.async)
      return Promise.all(r.map(async (o) => {
        const i = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await o._parseAsync({
            data: n.data,
            path: n.path,
            parent: i
          }),
          ctx: i
        };
      })).then(s);
    {
      let o;
      const i = [];
      for (const c of r) {
        const l = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: n.data,
          path: n.path,
          parent: l
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !o && (o = { result: d, ctx: l }), l.common.issues.length && i.push(l.common.issues);
      }
      if (o)
        return n.common.issues.push(...o.ctx.common.issues), o.result;
      const a = i.map((c) => new lu(c));
      return Ve(n, {
        code: Ne.invalid_union,
        unionErrors: a
      }), Mt;
    }
  }
  get options() {
    return this._def.options;
  }
}
NP.create = (t, e) => new NP({
  options: t,
  typeName: Ot.ZodUnion,
  ...qt(e)
});
function k$(t, e) {
  const n = Ku(t), r = Ku(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === nt.object && r === nt.object) {
    const s = gn.objectKeys(e), o = gn.objectKeys(t).filter((a) => s.indexOf(a) !== -1), i = { ...t, ...e };
    for (const a of o) {
      const c = k$(t[a], e[a]);
      if (!c.valid)
        return { valid: !1 };
      i[a] = c.data;
    }
    return { valid: !0, data: i };
  } else if (n === nt.array && r === nt.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let o = 0; o < t.length; o++) {
      const i = t[o], a = e[o], c = k$(i, a);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else return n === nt.date && r === nt.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class jP extends fn {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = (o, i) => {
      if ($Y(o) || $Y(i))
        return Mt;
      const a = k$(o.value, i.value);
      return a.valid ? ((LY(o) || LY(i)) && n.dirty(), { status: n.value, value: a.data }) : (Ve(r, {
        code: Ne.invalid_intersection_types
      }), Mt);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([o, i]) => s(o, i)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
jP.create = (t, e, n) => new jP({
  left: t,
  right: e,
  typeName: Ot.ZodIntersection,
  ...qt(n)
});
class tg extends fn {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== nt.array)
      return Ve(r, {
        code: Ne.invalid_type,
        expected: nt.array,
        received: r.parsedType
      }), Mt;
    if (r.data.length < this._def.items.length)
      return Ve(r, {
        code: Ne.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Mt;
    !this._def.rest && r.data.length > this._def.items.length && (Ve(r, {
      code: Ne.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const o = [...r.data].map((i, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new Vf(r, i, r.path, a)) : null;
    }).filter((i) => !!i);
    return r.common.async ? Promise.all(o).then((i) => ka.mergeArray(n, i)) : ka.mergeArray(n, o);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new tg({
      ...this._def,
      rest: e
    });
  }
}
tg.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new tg({
    items: t,
    typeName: Ot.ZodTuple,
    rest: null,
    ...qt(e)
  });
};
class GY extends fn {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== nt.map)
      return Ve(r, {
        code: Ne.invalid_type,
        expected: nt.map,
        received: r.parsedType
      }), Mt;
    const s = this._def.keyType, o = this._def.valueType, i = [...r.data.entries()].map(([a, c], l) => ({
      key: s._parse(new Vf(r, a, r.path, [l, "key"])),
      value: o._parse(new Vf(r, c, r.path, [l, "value"]))
    }));
    if (r.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of i) {
          const l = await c.key, d = await c.value;
          if (l.status === "aborted" || d.status === "aborted")
            return Mt;
          (l.status === "dirty" || d.status === "dirty") && n.dirty(), a.set(l.value, d.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of i) {
        const l = c.key, d = c.value;
        if (l.status === "aborted" || d.status === "aborted")
          return Mt;
        (l.status === "dirty" || d.status === "dirty") && n.dirty(), a.set(l.value, d.value);
      }
      return { status: n.value, value: a };
    }
  }
}
GY.create = (t, e, n) => new GY({
  valueType: e,
  keyType: t,
  typeName: Ot.ZodMap,
  ...qt(n)
});
class p0 extends fn {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== nt.set)
      return Ve(r, {
        code: Ne.invalid_type,
        expected: nt.set,
        received: r.parsedType
      }), Mt;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (Ve(r, {
      code: Ne.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (Ve(r, {
      code: Ne.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), n.dirty());
    const o = this._def.valueType;
    function i(c) {
      const l = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return Mt;
        d.status === "dirty" && n.dirty(), l.add(d.value);
      }
      return { status: n.value, value: l };
    }
    const a = [...r.data.values()].map((c, l) => o._parse(new Vf(r, c, r.path, l)));
    return r.common.async ? Promise.all(a).then((c) => i(c)) : i(a);
  }
  min(e, n) {
    return new p0({
      ...this._def,
      minSize: { value: e, message: st.toString(n) }
    });
  }
  max(e, n) {
    return new p0({
      ...this._def,
      maxSize: { value: e, message: st.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
p0.create = (t, e) => new p0({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: Ot.ZodSet,
  ...qt(e)
});
class YY extends fn {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
YY.create = (t, e) => new YY({
  getter: t,
  typeName: Ot.ZodLazy,
  ...qt(e)
});
class qY extends fn {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return Ve(n, {
        received: n.data,
        code: Ne.invalid_literal,
        expected: this._def.value
      }), Mt;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
qY.create = (t, e) => new qY({
  value: t,
  typeName: Ot.ZodLiteral,
  ...qt(e)
});
function Rbe(t, e) {
  return new $y({
    values: t,
    typeName: Ot.ZodEnum,
    ...qt(e)
  });
}
class $y extends fn {
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return Ve(n, {
        expected: gn.joinValues(r),
        received: n.parsedType,
        code: Ne.invalid_type
      }), Mt;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(e.data)) {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return Ve(n, {
        received: n.data,
        code: Ne.invalid_enum_value,
        options: r
      }), Mt;
    }
    return bc(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  extract(e, n = this._def) {
    return $y.create(e, {
      ...this._def,
      ...n
    });
  }
  exclude(e, n = this._def) {
    return $y.create(this.options.filter((r) => !e.includes(r)), {
      ...this._def,
      ...n
    });
  }
}
$y.create = Rbe;
class XY extends fn {
  _parse(e) {
    const n = gn.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== nt.string && r.parsedType !== nt.number) {
      const s = gn.objectValues(n);
      return Ve(r, {
        expected: gn.joinValues(s),
        received: r.parsedType,
        code: Ne.invalid_type
      }), Mt;
    }
    if (this._cache || (this._cache = new Set(gn.getValidEnumValues(this._def.values))), !this._cache.has(e.data)) {
      const s = gn.objectValues(n);
      return Ve(r, {
        received: r.data,
        code: Ne.invalid_enum_value,
        options: s
      }), Mt;
    }
    return bc(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
XY.create = (t, e) => new XY({
  values: t,
  typeName: Ot.ZodNativeEnum,
  ...qt(e)
});
class RP extends fn {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== nt.promise && n.common.async === !1)
      return Ve(n, {
        code: Ne.invalid_type,
        expected: nt.promise,
        received: n.parsedType
      }), Mt;
    const r = n.parsedType === nt.promise ? n.data : Promise.resolve(n.data);
    return bc(r.then((s) => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
RP.create = (t, e) => new RP({
  type: t,
  typeName: Ot.ZodPromise,
  ...qt(e)
});
class Ly extends fn {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ot.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = this._def.effect || null, o = {
      addIssue: (i) => {
        Ve(r, i), i.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (o.addIssue = o.addIssue.bind(o), s.type === "preprocess") {
      const i = s.transform(r.data, o);
      if (r.common.async)
        return Promise.resolve(i).then(async (a) => {
          if (n.value === "aborted")
            return Mt;
          const c = await this._def.schema._parseAsync({
            data: a,
            path: r.path,
            parent: r
          });
          return c.status === "aborted" ? Mt : c.status === "dirty" || n.value === "dirty" ? sx(c.value) : c;
        });
      {
        if (n.value === "aborted")
          return Mt;
        const a = this._def.schema._parseSync({
          data: i,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? Mt : a.status === "dirty" || n.value === "dirty" ? sx(a.value) : a;
      }
    }
    if (s.type === "refinement") {
      const i = (a) => {
        const c = s.refinement(a, o);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? Mt : (a.status === "dirty" && n.dirty(), i(a.value), { status: n.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => a.status === "aborted" ? Mt : (a.status === "dirty" && n.dirty(), i(a.value).then(() => ({ status: n.value, value: a.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Ry(i))
          return Mt;
        const a = s.transform(i.value, o);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((i) => Ry(i) ? Promise.resolve(s.transform(i.value, o)).then((a) => ({
          status: n.value,
          value: a
        })) : Mt);
    gn.assertNever(s);
  }
}
Ly.create = (t, e, n) => new Ly({
  schema: t,
  typeName: Ot.ZodEffects,
  effect: e,
  ...qt(n)
});
Ly.createWithPreprocess = (t, e, n) => new Ly({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: Ot.ZodEffects,
  ...qt(n)
});
class If extends fn {
  _parse(e) {
    return this._getType(e) === nt.undefined ? bc(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
If.create = (t, e) => new If({
  innerType: t,
  typeName: Ot.ZodOptional,
  ...qt(e)
});
class Fy extends fn {
  _parse(e) {
    return this._getType(e) === nt.null ? bc(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Fy.create = (t, e) => new Fy({
  innerType: t,
  typeName: Ot.ZodNullable,
  ...qt(e)
});
class A$ extends fn {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let r = n.data;
    return n.parsedType === nt.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
A$.create = (t, e) => new A$({
  innerType: t,
  typeName: Ot.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...qt(e)
});
class M$ extends fn {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return OP(s) ? s.then((o) => ({
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new lu(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new lu(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
M$.create = (t, e) => new M$({
  innerType: t,
  typeName: Ot.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...qt(e)
});
class ZY extends fn {
  _parse(e) {
    if (this._getType(e) !== nt.nan) {
      const r = this._getOrReturnCtx(e);
      return Ve(r, {
        code: Ne.invalid_type,
        expected: nt.nan,
        received: r.parsedType
      }), Mt;
    }
    return { status: "valid", value: e.data };
  }
}
ZY.create = (t) => new ZY({
  typeName: Ot.ZodNaN,
  ...qt(t)
});
class qFt extends fn {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class gz extends fn {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.common.async)
      return (async () => {
        const o = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? Mt : o.status === "dirty" ? (n.dirty(), sx(o.value)) : this._def.out._parseAsync({
          data: o.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return s.status === "aborted" ? Mt : s.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(e, n) {
    return new gz({
      in: e,
      out: n,
      typeName: Ot.ZodPipeline
    });
  }
}
class O$ extends fn {
  _parse(e) {
    const n = this._def.innerType._parse(e), r = (s) => (Ry(s) && (s.value = Object.freeze(s.value)), s);
    return OP(n) ? n.then((s) => r(s)) : r(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
O$.create = (t, e) => new O$({
  innerType: t,
  typeName: Ot.ZodReadonly,
  ...qt(e)
});
_r.lazycreate;
var Ot;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(Ot || (Ot = {}));
const XFt = gf.create;
Wf.create;
Gl.create;
const ZFt = _r.create;
_r.strictCreate;
NP.create;
jP.create;
tg.create;
const QFt = $y.create;
RP.create;
If.create;
Fy.create;
const QY = (t, e, n) => {
  if (t && "reportValidity" in t) {
    const r = Fe(n, e);
    t.setCustomValidity(r && r.message || ""), t.reportValidity();
  }
}, $be = (t, e) => {
  for (const n in e.fields) {
    const r = e.fields[n];
    r && r.ref && "reportValidity" in r.ref ? QY(r.ref, n, t) : r.refs && r.refs.forEach((s) => QY(s, n, t));
  }
}, JFt = (t, e) => {
  e.shouldUseNativeValidation && $be(t, e);
  const n = {};
  for (const r in t) {
    const s = Fe(e.fields, r), o = Object.assign(t[r] || {}, { ref: s && s.ref });
    if (e3t(e.names || Object.keys(t), r)) {
      const i = Object.assign({}, Fe(n, r));
      kn(i, "root", o), kn(n, r, i);
    } else kn(n, r, o);
  }
  return n;
}, e3t = (t, e) => t.some((n) => n.startsWith(e + "."));
var t3t = function(t, e) {
  for (var n = {}; t.length; ) {
    var r = t[0], s = r.code, o = r.message, i = r.path.join(".");
    if (!n[i]) if ("unionErrors" in r) {
      var a = r.unionErrors[0].errors[0];
      n[i] = { message: a.message, type: a.code };
    } else n[i] = { message: o, type: s };
    if ("unionErrors" in r && r.unionErrors.forEach(function(d) {
      return d.errors.forEach(function(u) {
        return t.push(u);
      });
    }), e) {
      var c = n[i].types, l = c && c[r.code];
      n[i] = Pbe(i, e, n, s, l ? [].concat(l, r.message) : r.message);
    }
    t.shift();
  }
  return n;
}, n3t = function(t, e, n) {
  return n === void 0 && (n = {}), function(r, s, o) {
    try {
      return Promise.resolve(function(i, a) {
        try {
          var c = Promise.resolve(t[n.mode === "sync" ? "parse" : "parseAsync"](r, e)).then(function(l) {
            return o.shouldUseNativeValidation && $be({}, o), { errors: {}, values: n.raw ? r : l };
          });
        } catch (l) {
          return a(l);
        }
        return c && c.then ? c.then(void 0, a) : c;
      }(0, function(i) {
        if (function(a) {
          return Array.isArray(a == null ? void 0 : a.errors);
        }(i)) return { values: {}, errors: JFt(t3t(i.errors, !o.shouldUseNativeValidation && o.criteriaMode === "all"), o) };
        throw i;
      }));
    } catch (i) {
      return Promise.reject(i);
    }
  };
};
const r3t = "vite_react_shadcn_ts", s3t = "1.0.0", o3t = "module", i3t = {
  dev: "vite",
  build: "vite build",
  "build:dev": "vite build --mode development",
  lint: "eslint .",
  preview: "vite preview",
  test: "vitest run",
  "test:watch": "vitest"
}, a3t = {
  "@blocknote/mantine": "^0.46.2",
  "@hello-pangea/dnd": "^16.6.0",
  "@hookform/resolvers": "^3.10.0",
  "@instantdb/react": "^0.22.123",
  "@radix-ui/react-accordion": "^1.2.11",
  "@radix-ui/react-alert-dialog": "^1.1.14",
  "@radix-ui/react-aspect-ratio": "^1.1.7",
  "@radix-ui/react-avatar": "^1.1.10",
  "@radix-ui/react-checkbox": "^1.3.2",
  "@radix-ui/react-collapsible": "^1.1.11",
  "@radix-ui/react-context-menu": "^2.2.15",
  "@radix-ui/react-dialog": "^1.1.14",
  "@radix-ui/react-dropdown-menu": "^2.1.15",
  "@radix-ui/react-hover-card": "^1.1.14",
  "@radix-ui/react-label": "^2.1.7",
  "@radix-ui/react-menubar": "^1.1.15",
  "@radix-ui/react-navigation-menu": "^1.2.13",
  "@radix-ui/react-popover": "^1.1.14",
  "@radix-ui/react-progress": "^1.1.7",
  "@radix-ui/react-radio-group": "^1.3.7",
  "@radix-ui/react-scroll-area": "^1.2.9",
  "@radix-ui/react-select": "^2.2.5",
  "@radix-ui/react-separator": "^1.1.7",
  "@radix-ui/react-slider": "^1.3.5",
  "@radix-ui/react-slot": "^1.2.3",
  "@radix-ui/react-switch": "^1.2.5",
  "@radix-ui/react-tabs": "^1.1.12",
  "@radix-ui/react-toast": "^1.2.14",
  "@radix-ui/react-toggle": "^1.1.9",
  "@radix-ui/react-toggle-group": "^1.1.10",
  "@radix-ui/react-tooltip": "^1.2.7",
  "@tanstack/react-query": "^5.83.0",
  "@types/uuid": "^9.0.8",
  "@xyflow/react": "^12.10.0",
  "class-variance-authority": "^0.7.1",
  clsx: "^2.1.1",
  cmdk: "^1.1.1",
  "date-fns": "^3.6.0",
  "embla-carousel-react": "^8.6.0",
  "input-otp": "^1.4.2",
  "lucide-react": "^0.462.0",
  "next-themes": "^0.3.0",
  react: "^18.3.1",
  "react-big-calendar": "^1.19.4",
  "react-day-picker": "^8.10.1",
  "react-dom": "^18.3.1",
  "react-hook-form": "^7.61.1",
  "react-resizable-panels": "^2.1.9",
  "react-router-dom": "^6.30.1",
  "react-use": "^17.6.0",
  recharts: "^2.15.4",
  sonner: "^1.7.4",
  "tailwind-merge": "^2.6.0",
  "tailwindcss-animate": "^1.0.7",
  tldraw: "^3.15.5",
  uuid: "^9.0.1",
  vaul: "^0.9.9",
  zod: "^3.25.76"
}, c3t = {
  "@eslint/js": "^9.32.0",
  "@tailwindcss/typography": "^0.5.16",
  "@testing-library/jest-dom": "^6.6.0",
  "@testing-library/react": "^16.0.0",
  "@types/node": "^22.16.5",
  "@types/react": "^18.3.23",
  "@types/react-dom": "^18.3.7",
  "@vitejs/plugin-react": "^4.7.0",
  "@vitejs/plugin-react-swc": "^3.11.0",
  autoprefixer: "^10.4.21",
  eslint: "^9.32.0",
  "eslint-plugin-react-hooks": "^5.2.0",
  "eslint-plugin-react-refresh": "^0.4.20",
  globals: "^15.15.0",
  jsdom: "^20.0.3",
  "lovable-tagger": "^1.1.13",
  postcss: "^8.5.6",
  tailwindcss: "^3.4.17",
  typescript: "^5.8.3",
  "typescript-eslint": "^8.38.0",
  vite: "^5.4.19",
  vitest: "^3.2.4"
}, l3t = {
  name: r3t,
  private: !0,
  version: s3t,
  type: o3t,
  scripts: i3t,
  dependencies: a3t,
  devDependencies: c3t
}, d3t = "https://raw.githubusercontent.com/send2cloud/blueprint/main/package.json";
function JY() {
  return l3t.version;
}
async function u3t() {
  const t = await fetch(d3t, { cache: "no-store" });
  if (!t.ok) throw new Error("Failed to fetch blueprint package.json");
  return (await t.json()).version || "0.0.0";
}
function f3t(t, e) {
  const n = t.replace(/[^0-9.]/g, "").split(".").map(Number), r = e.replace(/[^0-9.]/g, "").split(".").map(Number);
  for (let s = 0; s < Math.max(n.length, r.length); s++) {
    const o = n[s] || 0, i = r[s] || 0;
    if (i > o) return !0;
    if (i < o) return !1;
  }
  return !1;
}
async function h3t() {
  try {
    const t = JY(), e = await u3t();
    return f3t(t, e) ? {
      hasUpdate: !0,
      current: t,
      latest: e
    } : { hasUpdate: !1, current: t, latest: e };
  } catch (t) {
    return console.error("Failed to check for Blueprint updates:", t), { hasUpdate: !1, current: JY(), latest: "0.0.0", error: t };
  }
}
const p3t = ZFt({
  provider: QFt(["local", "instantdb"]),
  instantAppId: XFt().optional()
}).refine((t) => t.provider === "instantdb" ? !!t.instantAppId && t.instantAppId.trim().length > 0 : !0, {
  message: "Instant App ID is required for InstantDB provider",
  path: ["instantAppId"]
});
function g3t() {
  const { enabledTools: t, loading: e, storage: n } = TIe(), { toggleTool: r } = EIe(), [s, o] = he(!1), [i, a] = he(""), [c, l] = he(!1), d = fe(null), [u, f] = he(null);
  me(() => {
    h3t().then((O) => {
      f(O);
    }).catch(console.error);
  }, []);
  const { control: p, handleSubmit: g, watch: y, setValue: m, reset: v, formState: { isDirty: b, isValid: x } } = CFt({
    resolver: n3t(p3t),
    defaultValues: {
      provider: "local",
      instantAppId: ""
    }
  }), w = y("provider"), S = y("instantAppId") || "";
  me(() => {
    const O = E_e();
    l(O);
    const D = $Z();
    D && (v({
      provider: D.provider,
      instantAppId: D.instantAppId ?? ""
    }), a(D.instantAppId ?? ""));
  }, [v]);
  const C = (O) => {
    var k, A;
    const D = O.provider === "instantdb" && ((k = O.instantAppId) == null ? void 0 : k.trim()) !== i;
    if (O.provider === "local")
      b6({ provider: "local" }), TN(), Fd({
        title: "Using Local Storage",
        description: "Blueprint will store artifacts in this browser only."
      });
    else {
      const R = ((A = O.instantAppId) == null ? void 0 : A.trim()) || "";
      if (D && i)
        try {
          const j = `blueprint:instant:${i}`;
          Object.keys(localStorage).forEach(($) => {
            $.startsWith(j) && localStorage.removeItem($);
          });
        } catch (j) {
          console.error("Failed to clear old caches:", j);
        }
      b6({ provider: "instantdb", instantAppId: R }), TN(), Fd({
        title: D ? "Database Switched" : "Connected to InstantDB",
        description: D ? "Switched to a new project. Caches cleared and loading new data." : "Blueprint will now store artifacts in your project database."
      });
    }
    setTimeout(() => {
      window.location.reload();
    }, 600);
  }, _ = async () => {
    try {
      const [O, D] = await Promise.all([
        n.listArtifacts(),
        n.getSettings()
      ]), k = {
        schemaVersion: ss,
        exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
        artifacts: O,
        settings: D
      }, A = new Blob([JSON.stringify(k, null, 2)], { type: "application/json" }), R = URL.createObjectURL(A), j = document.createElement("a");
      j.href = R, j.download = "blueprint-data.json", document.body.appendChild(j), j.click(), j.remove(), URL.revokeObjectURL(R), Fd({ title: "Exported Blueprint data" });
    } catch (O) {
      Fd({
        title: "Export failed",
        description: O instanceof Error ? O.message : "Unable to export data.",
        variant: "destructive"
      });
    }
  }, E = () => {
    var O;
    (O = d.current) == null || O.click();
  }, M = async (O) => {
    var k, A;
    const D = (k = O.target.files) == null ? void 0 : k[0];
    if (D)
      try {
        const R = await D.text(), j = JSON.parse(R), $ = Array.isArray(j.artifacts) ? j.artifacts : [];
        let F = 0;
        for (const L of $) {
          const z = Ii(L);
          z && (await n.saveArtifact(z), F += 1);
        }
        (A = j.settings) != null && A.enabledTools && await n.saveSettings({
          enabledTools: j.settings.enabledTools.filter(
            (L) => Za.includes(L)
          ),
          seededNoteCreated: j.settings.seededNoteCreated
        }), Fd({
          title: "Import complete",
          description: `Imported ${F} artifacts.`
        });
      } catch (R) {
        Fd({
          title: "Import failed",
          description: R instanceof Error ? R.message : "Unable to import data.",
          variant: "destructive"
        });
      } finally {
        O.target.value = "";
      }
  }, N = Ke(() => s || !S ? S : S.length <= 4 ? "****" : `----${S.slice(-4)}`, [S, s]);
  return /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(zl, { title: "Settings", icon: _0 }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 p-6 max-w-2xl px-4 sm:px-6", children: /* @__PURE__ */ h.jsxs("div", { className: "space-y-6 pb-12", children: [
      (u == null ? void 0 : u.hasUpdate) && /* @__PURE__ */ h.jsxs("div", { className: "rounded-lg border border-teal-500/30 bg-teal-500/10 p-4 shadow-sm flex items-start gap-3", children: [
        /* @__PURE__ */ h.jsx(Zxe, { className: "h-5 w-5 text-teal-500 mt-0.5" }),
        /* @__PURE__ */ h.jsxs("div", { className: "flex-1", children: [
          /* @__PURE__ */ h.jsx("h3", { className: "text-sm font-semibold text-foreground", children: "Blueprint Update Available!" }),
          /* @__PURE__ */ h.jsxs("p", { className: "text-xs text-muted-foreground mt-1", children: [
            "A new version of Blueprint is available (",
            u.latest,
            "). You are currently running v",
            u.current,
            "."
          ] }),
          /* @__PURE__ */ h.jsx("div", { className: "mt-3", children: /* @__PURE__ */ h.jsx(
            "a",
            {
              href: "https://github.com/send2cloud/blueprint",
              target: "_blank",
              rel: "noreferrer",
              className: "inline-flex items-center justify-center rounded-md text-xs font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 bg-teal-500 text-primary-foreground hover:bg-teal-500/90 h-8 px-4",
              children: "View on GitHub"
            }
          ) })
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-4 rounded-lg border border-border bg-card p-4 sm:p-6 shadow-sm", children: [
        /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col sm:flex-row sm:items-center justify-between gap-4", children: [
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ h.jsx("div", { className: "p-2 rounded-md bg-primary/10", children: /* @__PURE__ */ h.jsx(Jxe, { className: "h-5 w-5 text-primary" }) }),
            /* @__PURE__ */ h.jsxs("div", { children: [
              /* @__PURE__ */ h.jsx("h2", { className: "text-lg font-semibold text-foreground", children: "Database Connection" }),
              /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground", children: "Store Blueprint artifacts inside your project database." })
            ] })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 text-xs font-medium self-start sm:self-center bg-muted/50 px-2 py-1 rounded-full", children: [
            /* @__PURE__ */ h.jsx(
              "span",
              {
                className: `inline-block h-2 w-2 rounded-full ${w === "instantdb" && S.trim().length > 0 ? "bg-emerald-500 animate-pulse" : "bg-muted-foreground/40"}`
              }
            ),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground uppercase tracking-wider", children: w === "instantdb" && S.trim().length > 0 ? "Live Output" : "Local Only" })
          ] })
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "grid gap-4 md:grid-cols-[200px_1fr] mt-2", children: [
          /* @__PURE__ */ h.jsxs("div", { className: "space-y-1.5", children: [
            /* @__PURE__ */ h.jsx(Po, { htmlFor: "db-provider", className: "text-xs font-bold uppercase text-muted-foreground", children: "Store Mode" }),
            /* @__PURE__ */ h.jsx(
              _Y,
              {
                name: "provider",
                control: p,
                render: ({ field: O }) => /* @__PURE__ */ h.jsxs(z_, { value: O.value, onValueChange: O.onChange, children: [
                  /* @__PURE__ */ h.jsx(zx, { id: "db-provider", className: "h-10", children: /* @__PURE__ */ h.jsx(U_, { placeholder: "Select provider" }) }),
                  /* @__PURE__ */ h.jsxs(Ux, { children: [
                    /* @__PURE__ */ h.jsx(Gh, { value: "local", children: "Local Storage" }),
                    /* @__PURE__ */ h.jsx(Gh, { value: "instantdb", children: "InstantDB (Sync)" })
                  ] })
                ] })
              }
            )
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: `space-y-1.5 transition-opacity ${w === "local" ? "opacity-40 grayscale" : ""}`, children: [
            /* @__PURE__ */ h.jsx(Po, { htmlFor: "instant-app-id", className: "text-xs font-bold uppercase text-muted-foreground", children: "Instant App ID" }),
            /* @__PURE__ */ h.jsxs("div", { className: "relative group", children: [
              /* @__PURE__ */ h.jsx(
                _Y,
                {
                  name: "instantAppId",
                  control: p,
                  render: ({ field: O }) => /* @__PURE__ */ h.jsx(
                    pa,
                    {
                      id: "instant-app-id",
                      placeholder: "app_...",
                      ...O,
                      value: s ? O.value : N,
                      onFocus: () => o(!0),
                      onBlur: () => o(!1),
                      disabled: w === "local",
                      className: "h-10 pr-10 font-mono text-sm tracking-tight"
                    }
                  )
                }
              ),
              w === "instantdb" && /* @__PURE__ */ h.jsx(
                "button",
                {
                  type: "button",
                  onClick: () => o(!s),
                  className: "absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground transition-colors",
                  children: s ? /* @__PURE__ */ h.jsx(twe, { className: "h-4 w-4" }) : /* @__PURE__ */ h.jsx(nwe, { className: "h-4 w-4" })
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col sm:flex-row items-center justify-between gap-4 pt-2 border-t border-border/50", children: [
          /* @__PURE__ */ h.jsx("p", { className: "text-[11px] leading-relaxed text-muted-foreground max-w-[70%] italic", children: c ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
            /* @__PURE__ */ h.jsx("span", { className: "font-semibold text-primary", children: "Environment config active." }),
            " App ID is set via ",
            /* @__PURE__ */ h.jsx("span", { className: "font-mono", children: "VITE_INSTANTDB_APP_ID" }),
            " and applies to all published builds."
          ] }) : w === "instantdb" ? /* @__PURE__ */ h.jsxs(h.Fragment, { children: [
            "Blueprint uses isolated namespaces (",
            /* @__PURE__ */ h.jsx("span", { className: "font-mono text-primary", children: "blueprint_notes" }),
            ") to prevent collisions with your main app schema."
          ] }) : /* @__PURE__ */ h.jsx(h.Fragment, { children: "Artifacts are scoped to your browser session and won't sync across machines." }) }),
          /* @__PURE__ */ h.jsx(
            _t,
            {
              onClick: g(C),
              disabled: !x || c || !b,
              className: "w-full sm:w-auto shadow-md hover:shadow-lg transition-all px-8",
              children: c ? "Configured via Env" : "Save & Connect"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "space-y-4 rounded-lg border border-border bg-card p-4 sm:p-6 shadow-sm", children: [
        /* @__PURE__ */ h.jsxs("div", { children: [
          /* @__PURE__ */ h.jsx("h3", { className: "text-sm font-semibold text-foreground", children: "Backup & Portability" }),
          /* @__PURE__ */ h.jsx("p", { className: "text-xs text-muted-foreground mt-1", children: "Move your artifacts between projects or keep a local copy." })
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "flex flex-wrap gap-3", children: [
          /* @__PURE__ */ h.jsx(_t, { variant: "outline", size: "sm", onClick: _, className: "bg-background", children: "Download Backup (.json)" }),
          /* @__PURE__ */ h.jsx(_t, { variant: "outline", size: "sm", onClick: E, className: "bg-background", children: "Restore Project" }),
          /* @__PURE__ */ h.jsx(
            "input",
            {
              ref: d,
              type: "file",
              accept: "application/json",
              className: "hidden",
              onChange: M
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("div", { className: "pt-2", children: [
        /* @__PURE__ */ h.jsx("h2", { className: "text-lg font-semibold text-foreground mb-1", children: "Active Modules" }),
        /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground", children: "Customize your workspace by toggling available toolkits." })
      ] }),
      /* @__PURE__ */ h.jsx("div", { className: "grid gap-3 sm:grid-cols-2", children: Za.map((O) => {
        const D = er[O], k = D.icon, A = t.includes(O);
        return /* @__PURE__ */ h.jsxs(
          "div",
          {
            className: `flex items-center justify-between p-4 rounded-lg border transition-all duration-200 ${A ? "border-primary/20 bg-primary/[0.02] shadow-sm" : "border-border bg-card opacity-70"}`,
            children: [
              /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-3", children: [
                /* @__PURE__ */ h.jsx("div", { className: `p-2 rounded-md ${A ? "bg-primary/10" : "bg-muted"}`, children: /* @__PURE__ */ h.jsx(k, { className: `h-5 w-5 ${A ? "text-primary" : "text-muted-foreground"}` }) }),
                /* @__PURE__ */ h.jsxs("div", { children: [
                  /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
                    /* @__PURE__ */ h.jsx(Po, { htmlFor: O, className: "text-sm font-bold text-foreground cursor-pointer", children: D.title }),
                    /* @__PURE__ */ h.jsx("kbd", { className: "hidden sm:inline-block px-1.5 py-0.5 text-[10px] font-mono bg-muted rounded text-muted-foreground border border-border/50", children: D.shortcut })
                  ] }),
                  /* @__PURE__ */ h.jsx("p", { className: "text-[11px] text-muted-foreground line-clamp-1", children: D.description })
                ] })
              ] }),
              /* @__PURE__ */ h.jsx(
                az,
                {
                  id: O,
                  checked: A,
                  onCheckedChange: () => r(O),
                  disabled: e,
                  className: "data-[state=checked]:bg-primary"
                }
              )
            ]
          },
          O
        );
      }) }),
      /* @__PURE__ */ h.jsxs("div", { className: "pt-6 border-t border-border/60", children: [
        /* @__PURE__ */ h.jsx("h3", { className: "text-xs font-bold uppercase tracking-widest text-muted-foreground mb-4", children: "Command Center" }),
        /* @__PURE__ */ h.jsx("div", { className: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-y-4 gap-x-6 text-[12px] text-muted-foreground", children: [
          { k: "W", v: "Whiteboard" },
          { k: "F", v: "Flow" },
          { k: "T", v: "Tasks" },
          { k: "D", v: "Docs" },
          { k: "S", v: "Favorites" },
          { k: "\\", v: "Dark Mode" },
          { k: "N", v: "New Item" },
          { k: "G", v: "Gallery" }
        ].map((O) => /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2.5", children: [
          /* @__PURE__ */ h.jsx("kbd", { className: "flex h-6 w-6 items-center justify-center rounded border border-border bg-muted font-mono text-[10px] shadow-sm", children: O.k }),
          /* @__PURE__ */ h.jsx("span", { className: "font-medium", children: O.v })
        ] }, O.k)) })
      ] })
    ] }) })
  ] });
}
function m3t() {
  return /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsx(zl, { title: "Help", icon: Vy }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1 overflow-auto p-6", children: /* @__PURE__ */ h.jsxs("div", { className: "mx-auto max-w-3xl space-y-8", children: [
      /* @__PURE__ */ h.jsxs("section", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsx("h2", { className: "text-xl font-semibold text-foreground", children: "What Blueprint Is" }),
        /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground", children: "Blueprint is your private, project-local idea room. It stores notes, sketches, flows, and tasks that explain the spark behind a project and keep your thinking coherent over time." })
      ] }),
      /* @__PURE__ */ h.jsxs("section", { className: "space-y-3", children: [
        /* @__PURE__ */ h.jsx("h2", { className: "text-xl font-semibold text-foreground", children: "Cross-Tool Integration" }),
        /* @__PURE__ */ h.jsxs("ul", { className: "list-disc pl-5 space-y-2 text-sm text-muted-foreground", children: [
          /* @__PURE__ */ h.jsxs("li", { children: [
            /* @__PURE__ */ h.jsx("strong", { children: "TaskCalendar Sync:" }),
            " Add due dates to task cards and they automatically appear on the Calendar."
          ] }),
          /* @__PURE__ */ h.jsxs("li", { children: [
            /* @__PURE__ */ h.jsx("strong", { children: "Artifact Linking:" }),
            " Use ",
            /* @__PURE__ */ h.jsx("code", { className: "px-1 bg-muted rounded", children: "[[artifact name]]" }),
            " syntax to create links between artifacts. These links are tracked and shown in the backlinks panel."
          ] }),
          /* @__PURE__ */ h.jsxs("li", { children: [
            /* @__PURE__ */ h.jsx("strong", { children: "Command Palette:" }),
            " Press ",
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 text-xs font-mono bg-muted rounded", children: "K" }),
            " (or ",
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 text-xs font-mono bg-muted rounded", children: "Ctrl+K" }),
            ") to quickly navigate, search, and create new artifacts."
          ] }),
          /* @__PURE__ */ h.jsxs("li", { children: [
            /* @__PURE__ */ h.jsx("strong", { children: "Relationship Graph:" }),
            " Press ",
            /* @__PURE__ */ h.jsx("kbd", { className: "px-1.5 py-0.5 text-xs font-mono bg-muted rounded", children: "R" }),
            " or visit the Relationships page to see a visual graph of how your artifacts connect to each other."
          ] })
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("section", { className: "space-y-3", children: [
        /* @__PURE__ */ h.jsx("h2", { className: "text-xl font-semibold text-foreground", children: "Hidden LLM Payload (Invisible Ink)" }),
        /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground", children: "Every artifact page includes a hidden JSON payload in the HTML source. Humans never see it, but LLMs can read it from the page source. This helps LLMs grasp context without cluttering the UI." }),
        /* @__PURE__ */ h.jsx("div", { className: "rounded-lg border border-border bg-muted/40 p-3 text-xs text-muted-foreground", children: /* @__PURE__ */ h.jsx("div", { className: "font-mono", children: '<script id="blueprint-llm" type="application/json"><\/script>' }) }),
        /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground", children: "When you share a link, the copied message tells the LLM to check the page source for this JSON." })
      ] }),
      /* @__PURE__ */ h.jsxs("section", { className: "space-y-3", children: [
        /* @__PURE__ */ h.jsx("h2", { className: "text-xl font-semibold text-foreground", children: "Best Practices" }),
        /* @__PURE__ */ h.jsxs("ul", { className: "list-disc pl-5 space-y-2 text-sm text-muted-foreground", children: [
          /* @__PURE__ */ h.jsx("li", { children: "Capture the project spark early (why it exists, what problem it solves)." }),
          /* @__PURE__ */ h.jsx("li", { children: 'Keep one "north star" note updated with current status and open questions.' }),
          /* @__PURE__ */ h.jsx("li", { children: "Use diagrams to define flows before implementation." }),
          /* @__PURE__ */ h.jsx("li", { children: "Use tasks for outcomes, not just to-dos. Add due dates to sync with Calendar." }),
          /* @__PURE__ */ h.jsxs("li", { children: [
            "Link related artifacts using ",
            /* @__PURE__ */ h.jsx("code", { className: "px-1 bg-muted rounded", children: "[[artifact name]]" }),
            " to build a knowledge graph."
          ] }),
          /* @__PURE__ */ h.jsx("li", { children: "Share links back to the LLM with brief context and the hidden-payload instruction." })
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("section", { className: "space-y-3", children: [
        /* @__PURE__ */ h.jsx("h2", { className: "text-xl font-semibold text-foreground", children: "Keyboard Shortcuts" }),
        /* @__PURE__ */ h.jsxs("div", { className: "grid grid-cols-2 gap-2 text-sm", children: [
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "K" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Command palette" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "W" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Whiteboard" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "F" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Flow" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "T" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Tasks" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "D" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Docs" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "C" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Calendar" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "R" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Relationships" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "S" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Favorites" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "N" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "New artifact" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "G" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Gallery view" })
          ] }),
          /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ h.jsx("kbd", { className: "px-2 py-1 text-xs font-mono bg-muted rounded", children: "\\" }),
            /* @__PURE__ */ h.jsx("span", { className: "text-muted-foreground", children: "Toggle theme" })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("section", { className: "space-y-4", children: [
        /* @__PURE__ */ h.jsx("h2", { className: "text-xl font-semibold text-foreground", children: "Examples" }),
        /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx("h3", { className: "text-sm font-semibold text-foreground", children: "Tasks (Board)" }),
          /* @__PURE__ */ h.jsxs("div", { className: "rounded-lg border border-border bg-card p-3 text-sm text-muted-foreground", children: [
            "Columns: Backlog  In Progress  Done",
            /* @__PURE__ */ h.jsx("br", {}),
            "Example cards:",
            /* @__PURE__ */ h.jsx("br", {}),
            '- "Prototype main loop"',
            /* @__PURE__ */ h.jsx("br", {}),
            '- "Define onboarding flow"',
            /* @__PURE__ */ h.jsx("br", {}),
            '- "Ship first playtest build"'
          ] })
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx("h3", { className: "text-sm font-semibold text-foreground", children: "Drawings (Canvas)" }),
          /* @__PURE__ */ h.jsxs("div", { className: "rounded-lg border border-border bg-card p-3 text-sm text-muted-foreground", children: [
            "Sketch the main screen, UI layout, or a rough level map.",
            /* @__PURE__ */ h.jsx("br", {}),
            "Use arrows and labels for spatial or interaction cues."
          ] })
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx("h3", { className: "text-sm font-semibold text-foreground", children: "Flows (Diagram)" }),
          /* @__PURE__ */ h.jsxs("div", { className: "rounded-lg border border-border bg-card p-3 text-sm text-muted-foreground", children: [
            'Example: "Purchase flow"',
            /* @__PURE__ */ h.jsx("br", {}),
            "Start  Select item  Confirm  Payment  Success / Failure  Receipt"
          ] })
        ] }),
        /* @__PURE__ */ h.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ h.jsx("h3", { className: "text-sm font-semibold text-foreground", children: "Notes (Docs)" }),
          /* @__PURE__ */ h.jsxs("div", { className: "rounded-lg border border-border bg-card p-3 text-sm text-muted-foreground", children: [
            "Write the project spark, constraints, key decisions, and open questions.",
            /* @__PURE__ */ h.jsx("br", {}),
            'Keep a running "Current Status" section.'
          ] })
        ] })
      ] }),
      /* @__PURE__ */ h.jsxs("section", { className: "space-y-2", children: [
        /* @__PURE__ */ h.jsx("h2", { className: "text-xl font-semibold text-foreground", children: "Sharing With LLMs" }),
        /* @__PURE__ */ h.jsx("p", { className: "text-sm text-muted-foreground", children: "Use the Share button on an artifact. It copies a message like:" }),
        /* @__PURE__ */ h.jsxs("div", { className: "rounded-lg border border-border bg-muted/40 p-3 text-xs text-muted-foreground", children: [
          "Here is the link I want you to reference: [artifact link]",
          /* @__PURE__ */ h.jsx("br", {}),
          'Please check the page source for LLM instructions (look for the "blueprint-llm" JSON block).'
        ] })
      ] })
    ] }) })
  ] });
}
function y3t() {
  const { tag: t } = $P(), e = rd(), { artifacts: n, loading: r, deleteArtifact: s, toggleFavorite: o, togglePinned: i } = uu(), a = t ? decodeURIComponent(t) : "", c = n.filter(
    (d) => {
      var u;
      return (u = d.tags) == null ? void 0 : u.includes(a);
    }
  ), l = bf(c);
  return r ? /* @__PURE__ */ h.jsx("div", { className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ h.jsx("div", { className: "animate-pulse text-muted-foreground", children: "Loading..." }) }) : /* @__PURE__ */ h.jsx("div", { className: "flex-1 p-6 overflow-auto", children: /* @__PURE__ */ h.jsxs("div", { className: "max-w-7xl mx-auto", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [
      /* @__PURE__ */ h.jsx(
        _t,
        {
          variant: "ghost",
          size: "icon",
          onClick: () => e("/"),
          className: "h-8 w-8",
          children: /* @__PURE__ */ h.jsx(BP, { className: "h-4 w-4" })
        }
      ),
      /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ h.jsx(E0, { className: "h-5 w-5 text-muted-foreground" }),
        /* @__PURE__ */ h.jsx("h1", { className: "text-2xl font-semibold text-foreground", children: a }),
        /* @__PURE__ */ h.jsxs("span", { className: "text-muted-foreground", children: [
          "(",
          l.length,
          " ",
          l.length === 1 ? "item" : "items",
          ")"
        ] })
      ] })
    ] }),
    l.length === 0 ? /* @__PURE__ */ h.jsx("div", { className: "text-center py-12", children: /* @__PURE__ */ h.jsx("p", { className: "text-muted-foreground", children: "No artifacts with this tag." }) }) : /* @__PURE__ */ h.jsx("div", { className: "columns-1 sm:columns-2 lg:columns-3 xl:columns-4 gap-4 space-y-4", children: l.map((d) => /* @__PURE__ */ h.jsx("div", { className: "break-inside-avoid", children: /* @__PURE__ */ h.jsx(
      tF,
      {
        artifact: d,
        onDelete: s,
        onToggleFavorite: o,
        onTogglePinned: i
      }
    ) }, d.id)) })
  ] }) });
}
const rD = {
  canvas: "hsl(262, 83%, 58%)",
  // Purple
  diagram: "hsl(199, 89%, 48%)",
  // Blue
  board: "hsl(25, 95%, 53%)",
  // Orange
  notes: "hsl(142, 76%, 36%)"
  // Green
};
function v3t() {
  const t = rd(), { resolvedTheme: e } = Yy(), n = e === "dark" ? "dark" : "light", { nodes: r, edges: s, loading: o } = cOe(), { initialNodes: i, initialEdges: a } = Ke(() => {
    const y = Math.max(200, r.length * 40), m = 2 * Math.PI / Math.max(r.length, 1), v = r.map((x, w) => {
      const S = w * m, C = 400 + y * Math.cos(S), _ = 300 + y * Math.sin(S);
      return {
        id: x.id,
        type: "default",
        position: { x: C, y: _ },
        data: {
          label: x.name,
          type: x.type
        },
        style: {
          background: rD[x.type] || "hsl(var(--primary))",
          color: "white",
          border: "none",
          borderRadius: "8px",
          padding: "10px 16px",
          fontSize: "12px",
          fontWeight: 500
        }
      };
    }), b = s.map((x, w) => ({
      id: `edge-${w}`,
      source: x.source,
      target: x.target,
      animated: !0,
      style: { stroke: "hsl(var(--muted-foreground))" }
    }));
    return { initialNodes: v, initialEdges: b };
  }, [r, s]), [c, l, d] = ume(i), [u, f, p] = fme(a), g = re((y, m) => {
    var b;
    const v = (b = m.data) == null ? void 0 : b.type;
    if (v && er[v]) {
      const x = er[v];
      t(`${x.path}/${m.id}`);
    }
  }, [t]);
  return o ? /* @__PURE__ */ h.jsx("div", { className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ h.jsx(Wy, { className: "h-8 w-8 animate-spin text-muted-foreground" }) }) : /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col h-full", children: [
    /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-2 border-b border-border bg-background px-4 py-3", children: [
      /* @__PURE__ */ h.jsx(W_, { className: "h-5 w-5 text-muted-foreground" }),
      /* @__PURE__ */ h.jsx("h1", { className: "text-lg font-semibold text-foreground", children: "Relationship Graph" }),
      /* @__PURE__ */ h.jsxs("span", { className: "text-sm text-muted-foreground ml-2", children: [
        r.length,
        " artifacts  ",
        s.length,
        " connections"
      ] })
    ] }),
    /* @__PURE__ */ h.jsx("div", { className: "flex-1", children: r.length === 0 ? /* @__PURE__ */ h.jsxs("div", { className: "flex flex-col items-center justify-center h-full text-center p-8", children: [
      /* @__PURE__ */ h.jsx(W_, { className: "h-16 w-16 text-muted-foreground mb-4" }),
      /* @__PURE__ */ h.jsx("h2", { className: "text-lg font-medium text-foreground mb-2", children: "No connections yet" }),
      /* @__PURE__ */ h.jsxs("p", { className: "text-sm text-muted-foreground max-w-md", children: [
        "Use ",
        /* @__PURE__ */ h.jsx("code", { className: "px-1.5 py-0.5 bg-muted rounded", children: "[[artifact name]]" }),
        " syntax in your Docs, Tasks, or Flows to create links between artifacts. They'll appear here as a visual graph."
      ] })
    ] }) : /* @__PURE__ */ h.jsxs(
      dme,
      {
        nodes: c,
        edges: u,
        onNodesChange: d,
        onEdgesChange: p,
        onNodeClick: g,
        colorMode: n,
        fitView: !0,
        proOptions: { hideAttribution: !0 },
        children: [
          /* @__PURE__ */ h.jsx(mme, {}),
          /* @__PURE__ */ h.jsx(
            vme,
            {
              nodeColor: (y) => {
                var m;
                return rD[(m = y.data) == null ? void 0 : m.type] || "hsl(var(--primary))";
              }
            }
          ),
          /* @__PURE__ */ h.jsx(pme, { variant: Kl.Dots, gap: 16, size: 1 })
        ]
      }
    ) }),
    /* @__PURE__ */ h.jsx("div", { className: "border-t border-border bg-background px-4 py-2", children: /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-4 text-xs text-muted-foreground", children: [
      /* @__PURE__ */ h.jsx("span", { className: "font-medium", children: "Legend:" }),
      Object.entries(rD).map(([y, m]) => {
        var v;
        return /* @__PURE__ */ h.jsxs("div", { className: "flex items-center gap-1.5", children: [
          /* @__PURE__ */ h.jsx(
            "div",
            {
              className: "w-3 h-3 rounded",
              style: { backgroundColor: m }
            }
          ),
          /* @__PURE__ */ h.jsx("span", { className: "capitalize", children: ((v = er[y]) == null ? void 0 : v.title) || y })
        ] }, y);
      })
    ] }) })
  ] });
}
const b3t = () => {
  const t = N$();
  return me(() => {
    console.error("404 Error: User attempted to access non-existent route:", t.pathname);
  }, [t.pathname]), /* @__PURE__ */ h.jsx("div", { className: "flex min-h-screen items-center justify-center bg-muted", children: /* @__PURE__ */ h.jsxs("div", { className: "text-center", children: [
    /* @__PURE__ */ h.jsx("h1", { className: "mb-4 text-4xl font-bold", children: "404" }),
    /* @__PURE__ */ h.jsx("p", { className: "mb-4 text-xl text-muted-foreground", children: "Oops! Page not found" }),
    /* @__PURE__ */ h.jsx("a", { href: "/", className: "text-primary underline hover:text-primary/90", children: "Return to Home" })
  ] }) });
};
TN();
const x3t = new A1e(), w3t = pq(() => import("./NotesGallery-soEZFxPT.js")), eq = pq(() => import("./NotesPage-D09OQL6w.js")), S3t = () => /* @__PURE__ */ h.jsx("div", { className: "blueprint-app h-full", children: /* @__PURE__ */ h.jsx(j1e, { client: x3t, children: /* @__PURE__ */ h.jsx(Y1e, { children: /* @__PURE__ */ h.jsxs(RX, { children: [
  /* @__PURE__ */ h.jsx(Hwe, {}),
  /* @__PURE__ */ h.jsx(_0e, {}),
  /* @__PURE__ */ h.jsx(
    Hbe,
    {
      fallback: /* @__PURE__ */ h.jsx("div", { className: "min-h-screen flex items-center justify-center text-muted-foreground", children: "Loading" }),
      children: /* @__PURE__ */ h.jsxs(Ybe, { children: [
        /* @__PURE__ */ h.jsxs(Dr, { element: /* @__PURE__ */ h.jsx(pke, {}), children: [
          /* @__PURE__ */ h.jsx(Dr, { index: !0, element: /* @__PURE__ */ h.jsx(mke, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "canvas", element: /* @__PURE__ */ h.jsx(eOe, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "canvas/new", element: /* @__PURE__ */ h.jsx(L7, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "canvas/:id", element: /* @__PURE__ */ h.jsx(L7, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "diagram", element: /* @__PURE__ */ h.jsx(Zct, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "diagram/new", element: /* @__PURE__ */ h.jsx(KW, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "diagram/:id", element: /* @__PURE__ */ h.jsx(KW, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "board", element: /* @__PURE__ */ h.jsx(Zgt, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "board/new", element: /* @__PURE__ */ h.jsx(XK, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "board/:id", element: /* @__PURE__ */ h.jsx(XK, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "calendar", element: /* @__PURE__ */ h.jsx(rFt, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "notes", element: /* @__PURE__ */ h.jsx(w3t, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "notes/new", element: /* @__PURE__ */ h.jsx(eq, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "notes/:id", element: /* @__PURE__ */ h.jsx(eq, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "tag/:tag", element: /* @__PURE__ */ h.jsx(y3t, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "relationships", element: /* @__PURE__ */ h.jsx(v3t, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "favorites", element: /* @__PURE__ */ h.jsx(sFt, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "help", element: /* @__PURE__ */ h.jsx(m3t, {}) }),
          /* @__PURE__ */ h.jsx(Dr, { path: "settings", element: /* @__PURE__ */ h.jsx(g3t, {}) })
        ] }),
        /* @__PURE__ */ h.jsx(Dr, { path: "*", element: /* @__PURE__ */ h.jsx(b3t, {}) })
      ] })
    }
  )
] }) }) }) }), S5t = ({ basename: t = "" } = {}) => (
  // Provide basePath via context so navigate() calls throughout Blueprint
  // prefix absolute paths correctly (e.g. /canvas  /blueprint/canvas).
  /* @__PURE__ */ h.jsx(S_e, { value: t, children: /* @__PURE__ */ h.jsx(S3t, {}) })
);
export {
  pw as $,
  nF as A,
  iWe as B,
  yg as C,
  km as D,
  hm as E,
  Pe as F,
  ht as G,
  W9 as H,
  gWe as I,
  Am as J,
  We as K,
  cWe as L,
  lWe as M,
  Zc as N,
  H7e as O,
  fo as P,
  ks as Q,
  $l as R,
  Ht as S,
  zl as T,
  Ns as U,
  Uie as V,
  rh as W,
  Tae as X,
  X9e as Y,
  hs as Z,
  ec as _,
  er as a,
  Wr as a0,
  QJe as a1,
  bet as a2,
  Uue as a3,
  Hue as a4,
  r5t as a5,
  ret as a6,
  LV as a7,
  kJe as a8,
  $ue as a9,
  S5t as aA,
  Z5 as aa,
  Hz as ab,
  Yl as ac,
  nl as ad,
  Yx as ae,
  DSe as af,
  ha as ag,
  qm as ah,
  Af as ai,
  rl as aj,
  nL as ak,
  Aht as al,
  jSe as am,
  RSe as an,
  LSe as ao,
  wSe as ap,
  I3t as aq,
  FSe as ar,
  jq as as,
  BSe as at,
  $Se as au,
  k3t as av,
  zSe as aw,
  Yy as ax,
  I4 as ay,
  rF as az,
  Oa as b,
  Eae as c,
  nWe as d,
  Dt as e,
  V7e as f,
  tWe as g,
  Tie as h,
  Z7e as i,
  h as j,
  Q7e as k,
  fv as l,
  W7e as m,
  q7e as n,
  QI as o,
  K7e as p,
  G7e as q,
  J7e as r,
  rWe as s,
  fWe as t,
  eWe as u,
  oc as v,
  Y7e as w,
  X7e as x,
  sWe as y,
  aWe as z
};
